quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Energy Efficiency,"tion at line 44 of file PxPyPzE4D.h. Public Types; typedef ScalarType Scalar;  . Public Member Functions;  PxPyPzE4D ();  Default constructor with x=y=z=t=0. ;  ; template<class CoordSystem > ; constexpr PxPyPzE4D (const CoordSystem &v);  construct from any vector or coordinate system class implementing x(), y() and z() and t() ;  ;  PxPyPzE4D (const PxPyPzE4D &v);  copy constructor ;  ;  PxPyPzE4D (Scalar px, Scalar py, Scalar pz, Scalar e);  Constructor from x, y , z , t values. ;  ; Scalar E () const;  ; Scalar Et () const;  transverse energy ;  ; Scalar Et2 () const;  transverse energy squared ;  ; Scalar Eta () const;  pseudorapidity ;  ; void GetCoordinates (Scalar &px, Scalar &py, Scalar &pz, Scalar &e) const;  get internal data into 4 Scalar numbers ;  ; void GetCoordinates (Scalar dest[]) const;  get internal data into an array of 4 Scalar numbers ;  ; Scalar M () const;  invariant mass ;  ; Scalar M2 () const;  vector magnitude squared (or mass squared) ;  ; Scalar Mag () const;  ; Scalar Mag2 () const;  ; Scalar Mt () const;  transverse mass ;  ; Scalar Mt2 () const;  transverse mass squared ;  ; void Negate ();  negate the 4-vector ;  ; bool operator!= (const PxPyPzE4D &rhs) const;  ; template<class AnyCoordSystem > ; PxPyPzE4D & operator= (const AnyCoordSystem &v);  Assignment from a generic coordinate system implementing x(), y(), z() and t() ;  ; PxPyPzE4D & operator= (const PxPyPzE4D &v);  assignment operator ;  ; bool operator== (const PxPyPzE4D &rhs) const;  Exact equality. ;  ; Scalar P () const;  magnitude of spatial components (magnitude of 3-momentum) ;  ; Scalar P2 () const;  squared magnitude of spatial components ;  ; Scalar Perp () const;  ; Scalar Perp2 () const;  ; Scalar Phi () const;  azimuthal angle ;  ; Scalar Pt () const;  Transverse spatial component (P_perp or rho) ;  ; Scalar Pt2 () const;  transverse spatial component squared ;  ; Scalar Px () const;  ; Scalar Py () const;  ; Scalar Pz () const;  ; Scalar R () const;  ; Scalar Rho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1PxPyPzE4D.html:1214,energy,energy,1214,doc/master/classROOT_1_1Math_1_1PxPyPzE4D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1PxPyPzE4D.html,2,['energy'],['energy']
Energy Efficiency,tion at line 58 of file TPostScript.h. ◆ fDXC. Float_t TPostScript::fDXC. protected . Definition at line 31 of file TPostScript.h. ◆ fDYC. Float_t TPostScript::fDYC. protected . Definition at line 32 of file TPostScript.h. ◆ fFileName. TString TPostScript::fFileName. protected . PS file name. ; Definition at line 77 of file TPostScript.h. ◆ fFontEmbed. Bool_t TPostScript::fFontEmbed. protected . True is FontEmbed has been called. ; Definition at line 78 of file TPostScript.h. ◆ fFX. Float_t TPostScript::fFX. protected . Definition at line 35 of file TPostScript.h. ◆ fFY. Float_t TPostScript::fFY. protected . Definition at line 36 of file TPostScript.h. ◆ fgLineCap. Int_t TPostScript::fgLineCap = 0. staticprotected . Appearance of line caps. ; Definition at line 81 of file TPostScript.h. ◆ fgLineJoin. Int_t TPostScript::fgLineJoin = 0. staticprotected . Appearance of joining lines. ; Definition at line 80 of file TPostScript.h. ◆ fGreen. Float_t TPostScript::fGreen. protected . Per cent of green. ; Definition at line 49 of file TPostScript.h. ◆ fIXzone. Int_t TPostScript::fIXzone. protected . Current zone along X. ; Definition at line 55 of file TPostScript.h. ◆ fIYzone. Int_t TPostScript::fIYzone. protected . Current zone along Y. ; Definition at line 56 of file TPostScript.h. ◆ fLastCellBlue. Int_t TPostScript::fLastCellBlue. protected . Last blue value. ; Definition at line 75 of file TPostScript.h. ◆ fLastCellGreen. Int_t TPostScript::fLastCellGreen. protected . Last green value. ; Definition at line 74 of file TPostScript.h. ◆ fLastCellRed. Int_t TPostScript::fLastCellRed. protected . Last red value. ; Definition at line 73 of file TPostScript.h. ◆ fLineScale. Float_t TPostScript::fLineScale. protected . Line width scale factor. ; Definition at line 51 of file TPostScript.h. ◆ fMarkerSizeCur. Float_t TPostScript::fMarkerSizeCur. protected . current transformed value of marker size ; Definition at line 57 of file TPostScript.h. ◆ fMaxLines. Int_t TPostScript::fMax,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPostScript.html:54433,green,green,54433,doc/master/classTPostScript.html,https://root.cern,https://root.cern/doc/master/classTPostScript.html,1,['green'],['green']
Energy Efficiency,"tion between classes. void GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". EFisherMethod GetFisherMethod( void ); { return fFisherMethod; }. » Author: Andreas Hoecker, Xavier Prudent, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodFisher.html:21641,power,power,21641,root/html534/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodFisher.html,2,['power'],['power']
Energy Efficiency,"tion code valid for RooAddPdf. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Double_t expectedEvents(const RooArgSet* nset); Return the number of expected events, which is either the sum of all coefficients; or the sum of the components extended terms, multiplied with the fraction that; is in the current range w.r.t the reference range. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs; return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Loop over components for plot sampling hints and merge them if there are multiple. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; P.d.f is self normalized. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset). const RooArgList& pdfList() const; Return list of component p.d.fs. const RooArgList& coefList() const; Return list of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddPdf.html:46642,efficient,efficiently,46642,root/html526/RooAddPdf.html,https://root.cern,https://root.cern/root/html526/RooAddPdf.html,1,['efficient'],['efficiently']
Energy Efficiency,"tion f to all the data points f may be a 2-D function TF2 or 3-d function TF3 The Z values of the 2D graph are replaced by the new values computed using the function. ; Definition at line 658 of file TGraph2D.cxx. ◆ Browse(). void TGraph2D::Browse ; (; TBrowser * ; ). overridevirtual . Browse. ; Reimplemented from TObject.; Definition at line 671 of file TGraph2D.cxx. ◆ Build(). void TGraph2D::Build ; (; Int_t ; n). protected . Creates the 2D graph basic data structure. ; Definition at line 602 of file TGraph2D.cxx. ◆ Class(). static TClass * TGraph2D::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGraph2D::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGraph2D::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 171 of file TGraph2D.h. ◆ Clear(). void TGraph2D::Clear ; (; Option_t * ; option = """"). overridevirtual . Free all memory allocated by this object. ; Reimplemented from TObject.; Definition at line 681 of file TGraph2D.cxx. ◆ CreateInterpolator(). void TGraph2D::CreateInterpolator ; (; Bool_t ; oldInterp). private . Add a TGraphDelaunay in the list of the fHistogram's functions. ; Definition at line 968 of file TGraph2D.cxx. ◆ DeclFileName(). static const char * TGraph2D::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 171 of file TGraph2D.h. ◆ DirectoryAutoAdd(). void TGraph2D::DirectoryAutoAdd ; (; TDirectory * ; dir). virtual . Perform the automatic addition of the graph to the given directory. ; Note this function is called in place when the semantic requires this object to be added to a directory (I.e. when being read from a TKey or being Cloned) ; Definition at line 715 of file TGraph2D.cxx. ◆ DistancetoPrimitive(). Int_t TGraph2D::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Computes distance from point px,py ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph2D.html:39362,allocate,allocated,39362,doc/master/classTGraph2D.html,https://root.cern,https://root.cern/doc/master/classTGraph2D.html,1,['allocate'],['allocated']
Energy Efficiency,"tion for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:60997,efficient,efficiently,60997,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,10,['efficient'],['efficiently']
Energy Efficiency,"tion from a string ;  . Protected Member Functions; VirtualIntegratorOneDim * CreateIntegrator (IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule);  . Private Member Functions;  IntegratorOneDim (const IntegratorOneDim &);  ; IntegratorOneDim & operator= (const IntegratorOneDim &);  . Private Attributes; IGenFunction * fFunc;  pointer to owned function ;  ; VirtualIntegratorOneDim * fIntegrator;  pointer to integrator interface class ;  . #include <Math/Integrator.h>; Member Typedef Documentation. ◆ Type. typedef IntegrationOneDim::Type ROOT::Math::IntegratorOneDim::Type. Definition at line 102 of file Integrator.h. Constructor & Destructor Documentation. ◆ IntegratorOneDim() [1/4]. ROOT::Math::IntegratorOneDim::IntegratorOneDim ; (; IntegrationOneDim::Type ; type = IntegrationOneDim::kDEFAULT, . double ; absTol = -1, . double ; relTol = -1, . unsigned int ; size = 0, . unsigned int ; rule = 0 . ). inlineexplicit . Constructor of one dimensional Integrator, default type is adaptive. ; Parameters. typeintegration type (adaptive, non-adaptive, etc..) ; absToldesired absolute Error ; relToldesired relative Error ; sizemaximum number of sub-intervals ; ruleGauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL) Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6) lower rules are indicated for singular functions while higher for smooth functions to get better accuracies; NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions ; Definition at line 123 of file Integrator.h. ◆ IntegratorOneDim() [2/4]. ROOT::Math::IntegratorOneDim::IntegratorOneDim ; (; const IGenFunction & ; f, . IntegrationOneDim::Type ; type = IntegrationOneDim::kDEFAULT, . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html:7922,adapt,adaptive,7922,doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDim.html,1,['adapt'],['adaptive']
Energy Efficiency,"tion is required, compute; corresponding square-root matrices; the reference histograms require the correct boundaries. Since in Likelihood classification; the transformations are applied using both classes, also the corresponding boundaries; need to take this into account. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the likelihood estimator for signal; fill a new Likelihood branch into the testTree. Double_t TransformLikelihoodOutput(Double_t ps, Double_t pb) const; returns transformed or non-transformed output. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to stream. void AddWeightsXMLTo(void* parent) const; write weights to XML. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void WriteWeightsToStream(TFile& rf) const; write reference PDFs to ROOT file. void ReadWeightsFromXML(void* wghtnode); read weights from XML. void ReadWeightsFromStream(istream& istr); read weight info from file; nothing to do for this method. void ReadWeightsFromStream(TFile& istr); read reference PDF from ROOT file. void WriteMonitoringHistosToFile( void ); write histograms and PDFs to file for monitoring purposes. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific header of the classifier (mostly include files). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Peter Speckmayer, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id: MethodLikelihood.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodLikelihood.html:21923,monitor,monitoring,21923,root/html530/TMVA__MethodLikelihood.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodLikelihood.html,1,['monitor'],['monitoring']
Energy Efficiency,"tion iter); voidSetKernelType(TKDE::EKernelType kern); voidSetMirror(TKDE::EMirror mir); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidSetNBins(UInt_t nbins); static voidTObject::SetObjectStat(Bool_t stat); voidSetRange(Double_t xMin, Double_t xMax); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidSetTuneFactor(Double_t rho); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUseBinsNEvents(UInt_t nEvents); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0., Double_t xMax = 0., const Option_t* option = ""KernelType:Gaussian;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.); TKDE(UInt_t events, const Double_t* data, const Double_t* dataWeight, Double_t xMin = 0., Double_t xMax = 0., const Option_t* option = ""KernelType:Gaussian;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tApproximateBias(const Double_t* x, const Double_t*) const; voidAssureOptions(); Double_tBiweightKernel(Double_t x) const; voidCheckKernelValidity(); voidCheckOptions(Bool_t isUserDefinedKernel = kFALSE); voidComputeDataStats(); Double_tComputeKer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TKDE.html:5981,Adapt,Adaptive,5981,root/html604/TKDE.html,https://root.cern,https://root.cern/root/html604/TKDE.html,1,['Adapt'],['Adaptive']
Energy Efficiency,"tion iter); voidSetKernelType(TKDE::EKernelType kern); voidSetMirror(TKDE::EMirror mir); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidSetNBins(UInt_t nbins); static voidTObject::SetObjectStat(Bool_t stat); voidSetRange(Double_t xMin, Double_t xMax); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidSetTuneFactor(Double_t rho); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUseBinsNEvents(UInt_t nEvents); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0., Double_t xMax = 0., const Option_t* option = ""KernelType:Gaussian;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tApproximateBias(const Double_t* x, const Double_t*) const; voidAssureOptions(); Double_tBiweightKernel(Double_t x) const; voidCheckKernelValidity(); voidCheckOptions(Bool_t isUserDefinedKernel = kFALSE); Double_tComputeKernelIntegral() const; Double_tComputeKernelL2Norm() const; Double_tComputeKernelMu() const; Double_tComputeKernelSigma2() const; Double_tComputeMidspread(); Double_tCosineArchKernel(Double_t x) const; voidDrawConfidenceInterval(TString& drawOpt, double cl = 0.9",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TKDE.html:5939,Adapt,Adaptive,5939,root/html602/TKDE.html,https://root.cern,https://root.cern/root/html602/TKDE.html,1,['Adapt'],['Adaptive']
Energy Efficiency,"tion lists the contents of a class on stdout. ;  ; void MakeCustomMenuList ();  Makes a customizable version of the popup menu list, i.e. ;  ; Bool_t MatchLegacyCheckSum (UInt_t checksum) const;  Return true if the checksum passed as argument is one of the checksum value produced by the older checksum calculation algorithm. ;  ; void Move (void *arenaFrom, void *arenaTo) const;  Register the fact that an object was moved from the memory location 'arenaFrom' to the memory location 'arenaTo'. ;  ; void * New (ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) const;  Return a pointer to a newly allocated object of this class. ;  ; void * New (void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; void * NewArray (Long_t nElements, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated array of objects of this class. ;  ; void * NewArray (Long_t nElements, void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; ObjectPtr NewObject (ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) const;  ; ObjectPtr NewObject (void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; ObjectPtr NewObjectArray (Long_t nElements, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated array of objects of this class. ;  ; ObjectPtr NewObjectArray (Long_t nElements, void *arena, ENewType defConstructor=kClassNew) const;  Return a pointer to a newly allocated object of this class. ;  ; virtual void PostLoadCheck ();  Do the initialization that can only be done after the CINT dictionary has been fully populated and can not be delayed efficiently. ;  ; Long_t Property () const override;  Returns the properties of the TClass as a bit field stored as a Long_t value. ;  ; Int_t ReadBuffer (TBuffer &b, void *pointer);  Function called by the Str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:20468,allocate,allocated,20468,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['allocate'],['allocated']
Energy Efficiency,"tion name; Integrator class. ROOT::Math::IntegratorMultiDim::kADAPTIVE; ROOT::Math::AdaptiveIntegratorMultiDim. ROOT::Math::IntegratorMultiDim::kVEGAS; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kMISER; ROOT::Math:::GSLMCIntegrator. ROOT::Math::IntegratorMultiDim::kPLAIN; ROOT::Math:::GSLMCIntegrator. The control parameters for the integration algorithms can be specified using the ROOT::Math::IntegratorMultiDimOptions class. Static methods are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:712150,adapt,adaptive,712150,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Adapt', 'adapt']","['AdaptiveIntegratorMultiDim', 'adaptive']"
Energy Efficiency,"tion of inverse transformation; Log() << kFATAL << ""Inverse transformation for PCA transformation not yet implemented. Hence, this transformation cannot be applied together with regression. Please contact the authors if necessary."" << Endl;. void CalculatePrincipalComponents(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); calculate the principal components for the signal and the background data; it uses the MakePrincipal method of ROOT's TPrincipal class. void X2P(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Calculate the principal components from the original data vector; x, and return it in p (function extracted from TPrincipal::X2P); It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). void P2X(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Perform the back-transformation from the principal components; pc, and return x; It's the users responsibility to make sure that both x and pc are; of the right size (i.e., memory must be allocated for p). void WriteTransformationToStream(ostream& ) const; write mean values to stream. void AttachXMLTo(void* parent); create XML description of PCA transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read mean values from input stream. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates C++ code fragment of the PCA transform for inclusion in standalone C++ class. VariablePCATransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: VariablePCATransform.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__VariablePCATransform.html:11331,allocate,allocated,11331,root/html532/TMVA__VariablePCATransform.html,https://root.cern,https://root.cern/root/html532/TMVA__VariablePCATransform.html,2,['allocate'],['allocated']
Energy Efficiency,"tion of std::uninitialized_value_construct; 529template <typename ForwardIt>; 530void UninitializedValueConstruct(ForwardIt first, ForwardIt last); 531{; 532#if __cplusplus < 201703L; 533 for (; first != last; ++first); 534 new (static_cast<void *>(std::addressof(*first))) typename std::iterator_traits<ForwardIt>::value_type();; 535#else; 536 std::uninitialized_value_construct(first, last);; 537#endif; 538}; 539 ; 540/// An unsafe function to reset the buffer for which this RVec is acting as a view.; 541///; 542/// \note This is a low-level method that _must_ be called on RVecs that are already non-owning:; 543/// - it does not put the RVec in ""non-owning mode"" (fCapacity == -1); 544/// - it does not free any owned buffer; 545template <typename T>; 546void ResetView(RVec<T> &v, T* addr, std::size_t sz); 547{; 548 v.fBeginX = addr;; 549 v.fSize = sz;; 550}; 551 ; 552} // namespace VecOps; 553} // namespace Internal; 554 ; 555namespace Detail {; 556namespace VecOps {; 557 ; 558/// This class consists of common code factored out of the SmallVector class to; 559/// reduce code duplication based on the SmallVector 'N' template parameter.; 560template <typename T>; 561class R__CLING_PTRCHECK(off) RVecImpl : public Internal::VecOps::SmallVectorTemplateBase<T> {; 562 using SuperClass = Internal::VecOps::SmallVectorTemplateBase<T>;; 563 ; 564public:; 565 using iterator = typename SuperClass::iterator;; 566 using const_iterator = typename SuperClass::const_iterator;; 567 using reference = typename SuperClass::reference;; 568 using size_type = typename SuperClass::size_type;; 569 ; 570protected:; 571 // Default ctor - Initialize to empty.; 572 explicit RVecImpl(unsigned N) : ROOT::Internal::VecOps::SmallVectorTemplateBase<T>(N) {}; 573 ; 574public:; 575 RVecImpl(const RVecImpl &) = delete;; 576 ; 577 ~RVecImpl(); 578 {; 579 // Subclass has already destructed this vector's elements.; 580 // If this wasn't grown from the inline copy, deallocate the old space.; 581 if (!this->isS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:20594,reduce,reduce,20594,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['reduce'],['reduce']
Energy Efficiency,"tion& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000, int rule = 3). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000, int rule = 3). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html:6292,adapt,adaptive,6292,root/html526/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html,2,['adapt'],['adaptive']
Energy Efficiency,"tion) const;  ; virtual TH1D * DoProjection (bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const;  Internal (protected) method for performing projection on the X or Y axis called by ProjectionX or ProjectionY. ;  ; virtual TH1D * DoQuantiles (bool onX, const char *name, Double_t prob) const;  Implementation of quantiles for x or y. ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input array of type float. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup);  Constructor for fix bin size histograms. ;  ; virtual Int_t AutoP2FindLimits (Double_t min, Double_t max);  Buffer-based estimate of the histogram range using the power of 2 algorithm. ;  ; Int_t AxisChoice (Option_t *axis) const;  Choose an axis according to ""axis"". ;  ; virtual void DoFillN (Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1);  Internal method to fill histogram content from a vector called directly by TH1::BufferEmpty. ;  ; virtual Double_t DoIntegral (Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t &err, Option_t *opt, Bool_t doerr=kFALSE) const;  Internal function compute integral and optionally the error between the limits specified by the bin number values working for all histograms (1D, 2D and 3D) ;  ; virtual Bool_t FindNewAxisLimits (const TAxis *axis, const Double_t point, Double_t &newMin, Double_t &newMax);  finds new limits for the axis so that point is within the range and the limits are compatible with the previous ones (see TH1::Merge). ;  ; UInt_t GetAxisLabelStatus () const;  Internal function used in TH1::Fill to see ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:57017,power,power,57017,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,2,['power'],['power']
Energy Efficiency,"tion, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TGHtmlUri.h>. Inheritance diagram for TGHtmlUri:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGHtmlUri() [1/3]. TGHtmlUri::TGHtmlUri ; (; const TGHtmlUri & ; ). privatedelete . ◆ TGHtmlUri() [2/3]. TGHtmlUri::TGHtmlUri ; (; const char * ; zUri = nullptr). Parse a text URI into an HtmlUri structure. ; Definition at line 54 of file TGHtmlUri.cxx. ◆ TGHtmlUri() [3/3]. TGHtmlUri::TGHtmlUri ; (; const TGHtmlUri * ; uri). Html uri copy constructor. ; Definition at line 92 of file TGHtmlUri.cxx. ◆ ~TGHtmlUri(). TGHtmlUri::~TGHtmlUri ; (; ). override . Html uri destructor. ; Definition at line 108 of file TGHtmlUri.cxx. Member Function Documentation. ◆ BuildUri(). char * TGHtmlUri::BuildUri ; (; ). Create a string to hold the given URI. ; Memory to hold the string is allocated with new[] and must be freed by the calling function. ; Definition at line 204 of file TGHtmlUri.cxx. ◆ ComponentLength(). int TGHtmlUri::ComponentLength ; (; const char * ; z, . const char * ; zInit, . const char * ; zTerm . ). Return the length of the next component of the URL in z[] given that the component starts at z[0]. ; The initial sequence of the component must be zInit[]. The component is terminated by any character in zTerm[]. The length returned is 0 if the component doesn't exist. The length includes the zInit[] string, but not the termination character. Component zInit zTerm; ---------- ------- -------; scheme """" "":/?#""; authority ""//"" ""/?#""; path ""/"" ""?#""; query ""?"" ""#""; fragment ""#"" """" . Definition at line 183 of file TGHtmlUri.cxx. ◆ EqualsUri(). int TGHtmlUri::EqualsUri ; (; const TGHtmlUri * ; uri, . int ; field_mask = ( (1<<0)  |  (1<<1)  |    (1<<2)  |  (1<<3)  |    (1<<4) ) . ). Compare another uri with given field mask. ; Definition at line 120 of file TGHtmlUri.cxx. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtmlUri.html:11197,allocate,allocated,11197,doc/master/classTGHtmlUri.html,https://root.cern,https://root.cern/doc/master/classTGHtmlUri.html,1,['allocate'],['allocated']
Energy Efficiency,"tion, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tPDK(Double_t a, Double_t b, Double_t c). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Double_tfBeta[3]betas of decaying particle; TLorentzVectorfDecPro[18]kinematics of the generated particles; Double_tfMass[18]masses of particles; Int_tfNtnumber of decay particles; Double_tfTeCmTmtotal energy in the C.M. minus the total mass; Double_tfWtMaxmaximum weigth. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t PDK(Double_t a, Double_t b, Double_t c); the PDK function. TGenPhaseSpace(const TGenPhaseSpace& gen); copy constructor. TGenPhaseSpace& operator=(const TGenPhaseSpace& gen); Assignment operator. Double_t Generate(); Generate a random final state.; The function returns the weigth of the current event.; The TLorentzVector of each decay product can be obtained using GetDecay(n). Note that Momentum, Energy units are Gev/C, GeV. TLorentzVector * GetDecay(Int_t n); return Lorentz vector corresponding to decay n. Bool_t SetDecay(TLorentzVector& P, Int_t nt, const Double_t* mass, Option_t* opt = """"); input:; TLorentzVector &P: decay particle (Momentum, Energy units are Gev/C, GeV); Int_t nt: number of decay products; Double_t *mass: a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGenPhaseSpace.html:6569,energy,energy,6569,root/html602/TGenPhaseSpace.html,https://root.cern,https://root.cern/root/html602/TGenPhaseSpace.html,4,['energy'],['energy']
Energy Efficiency,"tion; GSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x). construct from an interface of a multi-dimensional function. GSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x, const double* scale). construct from an interface of a multi-dimensional function; Use optionally a scale factor (for each coordinate) which can be used to scale the step sizes; (this is used for example by the minimization algorithm). GSLSimAnFunc(). derived classes might need to re-define completely the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modified. double Distance(const ROOT::Math::GSLSimAnFunc& func) const. calculate the distance (metric) between this one and another configuration; Presently a cartesian metric is used.; re-implement by derived classes if needed to be modified. void Print(). print the position in the standard output ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary. void SetX(const double* x). change the x values (used by sim annealing to take a step). void SetX(unsigned int i, double x). unsigned int NDim() const; { return fX.size(); }. double X(unsigned int i) const; { return fX[i]; }. cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html:2806,Energy,Energy,2806,root/html534/ROOT__Math__GSLSimAnFunc.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html,1,['Energy'],['Energy']
Energy Efficiency,"tion; GSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x). construct from an interface of a multi-dimensional function. GSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x, const double* scale). construct from an interface of a multi-dimensional function; Use optionally a scale factor (for each coordinate) which can be used to scale the step sizes; (this is used for example by the minimization algorithm). GSLSimAnFunc(). derived classes might need to re-define completely the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modified. double Distance(const ROOT::Math::GSLSimAnFunc& func) const. calculate the distance (metric) between this one and another configuration; Presently a cartesian metric is used.; re-implement by derived classes if needed to be modified. void Print(). print the position in the standard output std::ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary. void SetX(const double* x). change the x values (used by sim annealing to take a step). void SetX(unsigned int i, double x). unsigned int NDim() const; { return fX.size(); }. double X(unsigned int i) const; { return fX[i]; }.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GSLSimAnFunc.html:2875,Energy,Energy,2875,root/html602/ROOT__Math__GSLSimAnFunc.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GSLSimAnFunc.html,2,['Energy'],['Energy']
Energy Efficiency,"tion; TVirtualX(const char* name, const char* title); Ctor of ABC. TVirtualX *& Instance(); Returns gVirtualX global. void GetWindowAttributes(Window_t id, WindowAttributes_t& attr); The WindowAttributes_t structure is set to default. Bool_t ParseColor(Colormap_t cmap, const char* cname, ColorStruct_t& color); Looks up the string name of a color ""cname"" with respect to the screen; associated with the specified colormap. It returns the exact color value.; If the color name is not in the Host Portable Character Encoding,; the result is implementation dependent. cmap - the colormap; cname - the color name string; use of uppercase or lowercase; does not matter; color - returns the exact color value for later use. The ColorStruct_t structure is set to default. Let system think we; could parse color. Bool_t AllocColor(Colormap_t cmap, ColorStruct_t& color); Allocates a read-only colormap entry corresponding to the closest RGB; value supported by the hardware. If no cell could be allocated it; returns kFALSE, otherwise kTRUE. The pixel value is set to default. Let system think we could allocate; color. cmap - the colormap; color - specifies and returns the values actually used in the cmap. void QueryColor(Colormap_t cmap, ColorStruct_t& color); Returns the current RGB value for the pixel in the ""color"" structure. The color components are set to default. cmap - the colormap; color - specifies and returns the RGB values for the pixel specified; in the structure. void NextEvent(Event_t& event); The ""event"" is set to default event.; This method however, should never be called. void GetPasteBuffer(Window_t id, Atom_t atom, TString& text, Int_t& nchar, Bool_t del); Gets contents of the paste buffer ""atom"" into the string ""text"".; (nchar = number of characters) If ""del"" is true deletes the paste; buffer afterwards. Bool_t Init(void* display = 0); Initializes the X system. Returns kFALSE in case of failure.; It is implementation dependent. void ClearWindow(); Clears the entire area",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualX.html:22264,allocate,allocated,22264,root/html528/TVirtualX.html,https://root.cern,https://root.cern/root/html528/TVirtualX.html,10,['allocate'],['allocated']
Energy Efficiency,"tionCuts(). Double_t TMVA::MethodBDT::ApplyPreselectionCuts ; (; const Event * ; ev). private . Apply the preselection cuts before even bothering about any Decision Trees in the GetMVA . ; . --> -1 for background +1 for Signal ; Definition at line 3132 of file MethodBDT.cxx. ◆ Bagging(). Double_t TMVA::MethodBDT::Bagging ; (; ). private . Call it boot-strapping, re-sampling or whatever you like, in the end it is nothing else but applying ""random"" poisson weights to each event. ; Definition at line 2139 of file MethodBDT.cxx. ◆ Boost(). Double_t TMVA::MethodBDT::Boost ; (; std::vector< const TMVA::Event * > & ; eventSample, . DecisionTree * ; dt, . UInt_t ; cls = 0 . ). Apply the boosting algorithm (the algorithm is selecte via the ""option"" given in the constructor. ; The return value is the boosting weight. ; Definition at line 1717 of file MethodBDT.cxx. ◆ BoostMonitor(). void TMVA::MethodBDT::BoostMonitor ; (; Int_t ; iTree). private . Fills the ROCIntegral vs Itree from the testSample for the monitoring plots during the training . ; . but using the testing events ; Definition at line 1751 of file MethodBDT.cxx. ◆ Class(). static TClass * TMVA::MethodBDT::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::MethodBDT::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::MethodBDT::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 305 of file MethodBDT.h. ◆ CreateRanking(). const TMVA::Ranking * TMVA::MethodBDT::CreateRanking ; (; ). virtual . Compute ranking of input variables. ; Implements TMVA::MethodBase.; Definition at line 2682 of file MethodBDT.cxx. ◆ DeclareCompatibilityOptions(). void TMVA::MethodBDT::DeclareCompatibilityOptions ; (; ). protectedvirtual . Options that are used ONLY for the READER to ensure backward compatibility. ; Reimplemented from TMVA::MethodBase.; Definition at line 454 of file MethodBD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:44973,monitor,monitoring,44973,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['monitor'],['monitoring']
Energy Efficiency,"tionProxy(const char* cl_name, Bool_t silent); Build a Streamer for a collection whose type is described by 'collectionClass'. ~TEmulatedCollectionProxy(); Standard destructor. TVirtualCollectionProxy* Generate() const; Virtual copy constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE) const; Virtual destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; Virtual array destructor. TGenCollectionProxy * InitializeEx(Bool_t silent); Proxy initializer. Bool_t IsValid() const; Return true if the collection proxy was well initialized. UInt_t Size() const; Return the current size of the container. void Clear(const char* opt = """"); Clear the emulated collection. void Shrink(UInt_t nCurr, UInt_t left, Bool_t force); Shrink the container. void Expand(UInt_t nCurr, UInt_t left); Expand the container. void Resize(UInt_t n, Bool_t force_delete); Resize the container. void* At(UInt_t idx); Return the address of the value at index 'idx'. void* Allocate(UInt_t n, Bool_t forceDelete); Allocate the necessary space. void Insert(const void* data, void* container, size_t size); Insert data into the container where data is a C-style array of the actual type contained in the collection; of the given size. For associative container (map, etc.), the data type is the pair<key,value>. void Commit(void* env). void ReadItems(int nElements, TBuffer& b); Object input streamer. void WriteItems(int nElements, TBuffer& b); Object output streamer. void ReadBuffer(TBuffer& buff, void* pObj, const TClass* onfile); Read portion of the streamer. void ReadBuffer(TBuffer& buff, void* pObj); Read portion of the streamer. void Streamer(TBuffer& refBuffer); TClassStreamer IO overload. TEmulatedCollectionProxy & operator=(const TEmulatedCollectionProxy& ). void* New() const; Virtual constructor. { return new Cont_t; }. void* New(void* memory) const; Virtual in-place constructor. { return new(memory) Cont_t; }. void* NewArray(Int_t nElements) const; Virtual array constructor. { return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEmulatedCollectionProxy.html:9002,Allocate,Allocate,9002,root/html602/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TEmulatedCollectionProxy.html,4,['Allocate'],['Allocate']
Energy Efficiency,"tions away from the mean. ; nLExponent of power-law tail on the left. ; alphaRLocation of transition to a power law on the right, in standard deviations away from the mean. ; nRExponent of power-law tail on the right. . Definition at line 102 of file RooCrystalBall.cxx. ◆ RooCrystalBall() [4/5]. RooCrystalBall::RooCrystalBall ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; x, . RooAbsReal & ; x0, . RooAbsReal & ; sigmaLR, . RooAbsReal & ; alpha, . RooAbsReal & ; n, . bool ; doubleSided = false . ). Create a crystal ball shape with symmetric Gaussian core and only a tail on one side (just like RooCBShape) or two symmetric tails (like RooSDSCBShape). ; Parameters. nameName that identifies the PDF in computations. ; titleTitle for plotting. ; xThe variable of the PDF. ; x0Location parameter of the Gaussian component. ; sigmaLRWidth parameter of the Gaussian component. ; alphaLocation of transition to a power law, in standard deviations away from the mean. ; nExponent of power-law tail. ; doubleSidedWhether the tail is only on one side or on both sides . Definition at line 129 of file RooCrystalBall.cxx. ◆ RooCrystalBall() [5/5]. RooCrystalBall::RooCrystalBall ; (; const RooCrystalBall & ; other, . const char * ; name = nullptr . ). Copy a RooCrystalBall. ; Definition at line 150 of file RooCrystalBall.cxx. Member Function Documentation. ◆ analyticalIntegral(). double RooCrystalBall::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); const. overridevirtual . Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ; This functions will only be called with codes returned by getAnalyticalIntegral, except code zero. ; Reimplemented from RooAbsReal.; Definition at line 241 of file RooCrystalBall.cxx. ◆ Class(). static TClass * RooCrystalBall::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCrystalBall::Class_Name ; (; ). static . ReturnsName of this cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCrystalBall.html:78064,power,power-law,78064,doc/master/classRooCrystalBall.html,https://root.cern,https://root.cern/doc/master/classRooCrystalBall.html,1,['power'],['power-law']
Energy Efficiency,"tions inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roundoff noise as significant and will usually either fail to find a minimum, or give incorrect values for the parameter errors.; It is therefore recommended to make sure that all computations in \(\mbox{FCN}\), as well as all methods and functions called by \(\mbox{FCN}\), are done in double precision. If for some reason the computations cannot be done to a precision comparable with that expected by M , the user must inform M of this situation with setting a different machine precision via the MnMachinePrecision::setPrecision(double) method.; With reduced precision, the user may find that certain features sensitive to first and second differences (\(\mbox{HESSE}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)) do not work properly, in which case the calculations must be performed in higher precision.; 4 How to use M; [howto:howto]; 4.1 The \(\mbox{FCN}\) Function; [howto:fcn]; The user must always implement a derived class of FCNBase (the “\(\mbox{FCN}\)”) which calculates the function value to be minimized or analyzed. Note that when M is being used through an intermediate package such as HippoDraw @bib-HippoDraw, then the user’s \(\mbox{FCN}\) may be supplied by the this package.; The name of the user’s class to implement the FCNBase interface may be chosen freely (in documentation we give it the generic name \(\mbox{FCN}\)).; 4.1.1 FCNBase::operator()(const std::vector\(<\)double\(>\)&); The meaning of the vector of parameters std::vector\(<\)double\(>\) in the argument of FCNBase::operator() are of course defined by the user, who uses the values of those parameters to calculate his function value. The order and the position of these parameters is stri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:33119,reduce,reduced,33119,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['reduce'],['reduced']
Energy Efficiency,"tions inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roundoff noise as significant and will usually either fail to find a minimum, or give incorrect values for the parameter errors.; It is therefore recommended to make sure that all computations in \(\mbox{FCN}\), as well as all methods and functions called by \(\mbox{FCN}\), are done in double precision. If for some reason the computations cannot be done to a precision comparable with that expected by M , the user must inform M of this situation with setting a different machine precision via the MnMachinePrecision::setPrecision(double) method.; With reduced precision, the user may find that certain features sensitive to first and second differences (\(\mbox{HESSE}\), \(\mbox{MINOS}\), \(\mbox{CONTOURS}\)) do not work properly, in which case the calculations must be performed in higher precision.; 4 How to use M; [howto:howto]; 4.1 The \(\mbox{FCN}\) Function; [howto:fcn]; The user must always implement a derived class of FCNBase (the “\(\mbox{FCN}\)”) which calculates the function value to be minimized or analyzed. Note that when M is being used through an intermediate package such as HippoDraw @bib-HippoDraw, then the user’s \(\mbox{FCN}\) may be supplied by the this package.; The name of the user’s class to implement the FCNBase interface may be chosen freely (in documentation we give it the generic name \(\mbox{FCN}\)).; 4.1.1 FCNBase::operator()(const std::vector\(<\)double\(>\)&); The meaning of the vector of parameters std::vector\(<\)double\(>\) in the argument of FCNBase::operator() are of course defined by the user, who uses the values of those parameters to calculate their function value. The order and the position of these parameters is st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:29095,reduce,reduced,29095,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,['reduce'],['reduced']
Energy Efficiency,"tions |; Protected Attributes |; List of all members ; TClonesArray Class ReferenceCore ROOT classes » Containers. ; An array of clone (identical) objects. ; Memory for the objects stored in the array is allocated only once in the lifetime of the clones array. All objects must be of the same class. For the rest this class has the same properties as TObjArray.; To reduce the very large number of new and delete calls in large loops like this (O(100000) x O(10000) times new/delete): TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);; ...; ...; }; ...; a.Delete();; }; a#define a(i)Definition RSha256.hxx:99; TObjArrayAn array of TObjects.Definition TObjArray.h:31; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; One better uses a TClonesArray which reduces the number of new/delete calls to only O(10000): TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);; ...; ...; }; ...; a.Delete(); // or a.Clear() or a.Clear(""C""); }; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; To reduce the number of call to the constructor (especially useful if the user class requires memory allocation), the object can be added (and constructed when needed) using ConstructedAt which only calls the constructor once per slot. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear(); // or a.Clear(""C"");; }; Note: the only supported way to add objects to a TClonesArray is via the new with placement method or the ConstructedAt method. The other Add() methods ofTObjArray and its base classes are not a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:1114,reduce,reduces,1114,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['reduce'],['reduces']
Energy Efficiency,"tions). TH1 * Rebin(Int_t ngroup = 2, const char* newname = """", const Double_t* xbins = 0); Rebin this histogram. -case 1 xbins=0; If newname is blank (default), the current histogram is modified and; a pointer to it is returned. If newname is not blank, the current histogram is not modified, and a; new histogram is returned which is a Clone of the current histogram; with its name set to newname. The parameter ngroup indicates how many bins of this have to be merged; into one bin of the result. If the original histogram has errors stored (via Sumw2), the resulting; histograms has new errors correctly calculated. examples: if h1 is an existing TH1F histogram with 100 bins; h1->Rebin(); //merges two bins in one in h1: previous contents of h1 are lost; h1->Rebin(5); //merges five bins in one in h1; TH1F *hnew = h1->Rebin(5,""hnew""); // creates a new histogram hnew; // merging 5 bins of h1 in one bin. NOTE: If ngroup is not an exact divider of the number of bins,; the top limit of the rebinned histogram is reduced; to the upper edge of the last bin that can make a complete; group. The remaining bins are added to the overflow bin.; Statistics will be recomputed from the new bin contents. -case 2 xbins!=0; A new histogram is created (you should specify newname).; The parameter ngroup is the number of variable size bins in the created histogram.; The array xbins must contain ngroup+1 elements that represent the low-edges; of the bins.; If the original histogram has errors stored (via Sumw2), the resulting; histograms has new errors correctly calculated. NOTE: The bin edges specified in xbins should correspond to bin edges; in the original histogram. If a bin edge in the new histogram is; in the middle of a bin in the original histogram, all entries in; the split bin in the original histogram will be transfered to the; lower of the two possible bins in the new histogram. This is; probably not what you want. examples: if h1 is an existing TH1F histogram with 100 bins; Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1.html:97173,reduce,reduced,97173,root/html532/TH1.html,https://root.cern,https://root.cern/root/html532/TH1.html,8,['reduce'],['reduced']
Energy Efficiency,"tions*-*-*-*-*-*. See class TFitPanel for example. TH1 * GetAsymmetry(TH1* h2, Double_t c2 = 1, Double_t dc2 = 0); return an histogram containing the asymmetry of this histogram with h2,; where the asymmetry is defined as:. Asymmetry = (h1 - h2)/(h1 + h2) where h1 = this. works for 1D, 2D, etc. histograms; c2 is an optional argument that gives a relative weight between the two; histograms, and dc2 is the error on this weight. This is useful, for example,; when forming an asymmetry between two histograms from 2 different data sets that; need to be normalized to each other in some way. The function calculates; the errors asumming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)). example: assuming 'h1' and 'h2' are already filled. h3 = h1->GetAsymmetry(h2). then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; h1 and h2 are left intact. Note that it is the user's responsibility to manage the created histogram. code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun. clone the histograms so top and bottom will have the; correct dimensions:; Sumw2 just makes sure the errors will be computed properly; when we form sums and ratios below. Int_t GetDefaultBufferSize(); static function; return the default buffer size for automatic histograms; the parameter fgBufferSize may be changed via SetDefaultBufferSize. Bool_t GetDefaultSumw2(); static function; return kTRUE if TH1::Sumw2 must be called when creating new histograms.; see TH1::SetDefaultSumw2. Double_t GetEntries() const; return the current number of entries. Double_t GetEffectiveEntries() const; number of effective entries of the histogram,; i.e. the number of unweighted entries a histogram would need to; have the same statistical power as this histogram with possibly; weighted entries (i.e. <= TH1::GetEntries()). char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the histogram info (bin number, contents, integral up to bin; corresponding to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:82868,adapt,adapted,82868,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,4,['adapt'],['adapted']
Energy Efficiency,"tions*-*-*-*-*-*. See class TFitPanel for example. TH1 * GetAsymmetry(TH1* h2, Double_t c2 = 1, Double_t dc2 = 0); return an histogram containing the asymmetry of this histogram with h2,; where the asymmetry is defined as:. Asymmetry = (h1 - h2)/(h1 + h2) where h1 = this. works for 1D, 2D, etc. histograms; c2 is an optional argument that gives a relative weight between the two; histograms, and dc2 is the error on this weight. This is useful, for example,; when forming an asymmetry between two histograms from 2 different data sets that; need to be normalized to each other in some way. The function calculates; the errors asumming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)). example: assuming 'h1' and 'h2' are already filled. h3 = h1->GetAsymmetry(h2). then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; h1 and h2 are left intact. Note that it is the user's responsibility to manage the created histogram. code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun. clone the histograms so top and bottom will have the; correct dimensions:; Sumw2 just makes sure the errors will be computed properly; when we form sums and ratios below. Int_t GetDefaultBufferSize(); static function; return the default buffer size for automatic histograms; the parameter fgBufferSize may be changed via SetDefaultBufferSize. Bool_t GetDefaultSumw2(); static function; return kTRUE if TH1::Sumw2 must be called when creating new histograms.; see TH1::SetDefaultSumw2. Double_t GetEntries() const; return the current number of entries. Double_t GetEffectiveEntries() const; number of effective entries of the histogram,; neff = (Sum of weights )^2 / (Sum of weight^2 ); In case of an unweighted histogram this number is equivalent to the; number of entries of the histogram.; For a weighted histogram, this number corresponds to the hypotetical number of unweighted entries; a histogram would need to have the same statistical power as this weighted histogram.; Note:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:87872,adapt,adapted,87872,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,2,['adapt'],['adapted']
Energy Efficiency,"titions); 252 , fMinimizerType (_eMinimizerType); 253 , m_convergenceCount (0); 254 , m_maxConvergenceCount (0); 255 , m_minError (1e10); 256 , m_useMultithreading (_useMultithreading); 257 , fMonitoring (NULL); 258 {; 259 }; 260 ; 261 Settings::~Settings () ; 262 {; 263 }; 264 ; 265 ; 266 ; 267 ; 268 ; 269 ; 270 ; 271 ; 272 ; 273 ; 274 ; 275 ; 276 ; 277 ; 278 /** \brief action to be done when the training cycle is started (e.g. update some monitoring output); 279 *; 280 */; 281 void ClassificationSettings::startTrainCycle () ; 282 {; 283 if (fMonitoring); 284 {; 285 create (""ROC"", 100, 0, 1, 100, 0, 1);; 286 create (""Significance"", 100, 0, 1, 100, 0, 3);; 287 create (""OutputSig"", 100, 0, 1);; 288 create (""OutputBkg"", 100, 0, 1);; 289 fMonitoring->ProcessEvents ();; 290 }; 291 }; 292 ; 293 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 294 *; 295 */; 296 void ClassificationSettings::endTrainCycle (double /*error*/) ; 297 {; 298 if (fMonitoring) fMonitoring->ProcessEvents ();; 299 }; 300 ; 301 /** \brief action to be done after the computation of a test sample (e.g. update some monitoring output); 302 *; 303 */; 304 void ClassificationSettings::testSample (double /*error*/, double output, double target, double weight); 305 {; 306 ; 307 m_output.push_back (output);; 308 m_targets.push_back (target);; 309 m_weights.push_back (weight);; 310 }; 311 ; 312 ; 313 /** \brief action to be done when the test cycle is started (e.g. update some monitoring output); 314 *; 315 */; 316 void ClassificationSettings::startTestCycle () ; 317 {; 318 m_output.clear ();; 319 m_targets.clear ();; 320 m_weights.clear ();; 321 }; 322 ; 323 /** \brief action to be done when the training cycle is ended (e.g. update some monitoring output); 324 *; 325 */; 326 void ClassificationSettings::endTestCycle () ; 327 {; 328 if (m_output.empty ()); 329 return;; 330 double minVal = *std::min_element (begin (m_output), end (m_output));; 331 double maxVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:11379,monitor,monitoring,11379,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"tive mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiM4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiM4D<double>::Scalar phi). set phi value. void SetM(ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). set M value. void SetPxPyPzE(ROOT::Math::PtEtaPhiM4D<double>::Scalar px, ROOT::Math::PtEtaPhiM4D<double>::Scalar py, ROOT::Math::PtEtaPhiM4D<double>::Scalar pz, ROOT::Math::PtEtaPhiM4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector -- Note that the energy cannot be negate (would need an additional data member); therefore negate will work only on the spatial components; One would need to use negate only with vectors having the energy as data members. void Scale(ROOT::Math::PtEtaPhiM4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility secition ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X(); }. Scalar y() const; { return Y(); }. Scalar z() const; { return Z(); }. Scalar t() const; { return E(); }. void SetPx(ROOT::Math::PtEtaPhiM4D<double>::Scalar px); ====== Set member functions for coordinates in other systems =======. void SetPy(ROOT::Math::PtEtaPhiM4D<double>::Scalar py). void SetPz(ROOT::Math::PtEtaPhiM4D<double>::Scalar pz). void SetE(ROOT::Math::PtEtaPhiM4D<double>::Scalar energy). » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__PtEtaPhiM4D_double_.html:8940,energy,energy,8940,root/html534/ROOT__Math__PtEtaPhiM4D_double_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__PtEtaPhiM4D_double_.html,2,['energy'],['energy']
Energy Efficiency,"tleobject title. private:. RooStats::HypoTestInverterResult*fResults. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HypoTestInverterPlot(HypoTestInverterResult* results ); constructor from a HypoTestInverterResult class; name and title are taken from the result class. HypoTestInverterPlot(const char* name, const char* title, RooStats::HypoTestInverterResult* results); constructor with name and title from a HypoTestInverterResult class. TGraphErrors* MakePlot(Option_t* opt = """"); Make the plot of the result of the scan; using the observed data; By default plot CLs or CLsb depending if the flag UseCLs is set. If Option = ""CLb"" return CLb plot; = ""CLs+b"" return CLs+b plot independently of the flag; = ""CLs"" return CLs plot independently of the flag. TMultiGraph* MakeExpectedPlot(double sig1 = 1, double sig2 = 2); Make the expected plot and the bands; nsig1 and nsig2 indicates the n-sigma value for the bands; if nsig1 = 0 no band is drawn (only expected value); if nsig2 > nsig1 (default is nsig1=1 and nsig2=2) the second band is also drawn; The first band is drawn in green while the second in yellow; THe return result is a TMultiGraph object. ~HypoTestInverterPlot(); destructor. void Draw(Option_t* opt = """"); Draw the result in the current canvas; Possible options:; SAME : draw in the current axis; OBS : draw only the observed plot; EXP : draw only the expected plot. CLB : draw also the CLB; 2CL : drow both clsplusb and cls. default draw observed + expected with 1 and 2 sigma bands. SamplingDistPlot * MakeTestStatPlot(int index, int type = 0, int nbins = 100); plot the test statistic distributions; type =0 null and alt; type = 1 only null (S+B); type = 2 only alt (B). HypoTestInverterPlot(HypoTestInverterResult* results ); constructor. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-03-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestInverterPlot.html:7097,green,green,7097,root/html534/RooStats__HypoTestInverterPlot.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestInverterPlot.html,2,['green'],['green']
Energy Efficiency,"tleobject title. private:. RooStats::HypoTestInverterResult*fResults. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HypoTestInverterPlot(HypoTestInverterResult* results ); constructor from a HypoTestInverterResult class; name and title are taken from the result class. HypoTestInverterPlot(const char* name, const char* title, RooStats::HypoTestInverterResult* results); constructor with name and title from a HypoTestInverterResult class. TGraphErrors* MakePlot(Option_t* opt = """"); Make the plot of the result of the scan; using the observed data; By default plot CLs or CLsb depending if the flag UseCLs is set. If Option = ""CLb"" return CLb plot; = ""CLs+b"" return CLs+b plot independently of the flag; = ""CLs"" return CLs plot independently of the flag. TMultiGraph* MakeExpectedPlot(double sig1 = 1, double sig2 = 2); Make the expected plot and the bands; nsig1 and nsig2 indicates the n-sigma value for the bands; if nsig1 = 0 no band is drawn (only expected value); if nsig2 > nsig1 (default is nsig1=1 and nsig2=2) the second band is also drawn; The first band is drawn in green while the second in yellow; THe return result is a TMultiGraph object. ~HypoTestInverterPlot(); destructor. void Draw(Option_t* opt = """"); Draw the result in the current canvas; Possible options:; SAME : draw in the current axis; OBS : draw only the observed plot; EXP : draw only the expected plot. CLB : draw also the CLB; 2CL : drow both clsplusb and cls. default draw observed + expected with 1 and 2 sigma bands. SamplingDistPlot * MakeTestStatPlot(int index, int type = 0, int nbins = 100); plot the test statistic distributions; type =0 null and alt; type = 1 only null (S+B); type = 2 only alt (B). HypoTestInverterPlot(HypoTestInverterResult* results ); constructor. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id$ » Last generated: 2015-06-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HypoTestInverterPlot.html:7558,green,green,7558,root/html602/RooStats__HypoTestInverterPlot.html,https://root.cern,https://root.cern/root/html602/RooStats__HypoTestInverterPlot.html,4,['green'],['green']
Energy Efficiency,"tleobject title. private:. RooStats::HypoTestInverterResult*fResults. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; HypoTestInverterPlot(HypoTestInverterResult* results ); constructor from a HypoTestInverterResult class; name and title are taken from the result class. HypoTestInverterPlot(const char* name, const char* title, RooStats::HypoTestInverterResult* results); constructor with name and title from a HypoTestInverterResult class. TGraphErrors* MakePlot(Option_t* opt = """"); Make the plot of the result of the scan; using the observed data; By default plot CLs or CLsb depending if the flag UseCLs is set. If Option = ""CLb"" return CLb plot; = ""CLs+b"" return CLs+b plot independently of the flag; = ""CLs"" return CLs plot independently of the flag. TMultiGraph* MakeExpectedPlot(double sig1 = 1, double sig2 = 2); Make the expected plot and the bands; nsig1 and nsig2 indicates the n-sigma value for the bands; if nsig1 = 0 no band is drawn (only expected value); if nsig2 > nsig1 (default is nsig1=1 and nsig2=2) the second band is also drawn; The first band is drawn in green while the second in yellow; THe return result is a TMultiGraph object. ~HypoTestInverterPlot(); destructor. void Draw(Option_t* opt = """"); Draw the result in the current canvas; Possible options:; SAME : draw in the current axis; OBS : draw only the observed plot; EXP : draw only the expected plot. CLB : draw also the CLB; 2CL : drow both clsplusb and cls. default draw observed + expected with 1 and 2 sigma bands. SamplingDistPlot * MakeTestStatPlot(int index, int type = 0, int nbins = 100); plot the test statistic distributions; type =0 null and alt; type = 1 only null (S+B); type = 2 only alt (B). HypoTestInverterPlot(HypoTestInverterResult* results ); constructor. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: HypoTestInverterPlot.h 399",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestInverterPlot.html:7078,green,green,7078,root/html530/RooStats__HypoTestInverterPlot.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestInverterPlot.html,3,['green'],['green']
Energy Efficiency,"tly to the reduction of , if the angle. between ; and ; is smaller than; an upper limit , defined by the user; (TMultiDimFit::SetMaxAngle). However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of are chosen first; (TMultiDimFit::TestFunction). In case isn't defined, an alternative method of; performing this second test is used: The ; function. is accepted if (refer also to equation (13)). (14). where is the sum of the first residuals from the; functions previously accepted; and is the total number; of functions allowed in the final expression of the fit (defined by; user). >From this we see, that by restricting -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting. The more coefficients we evaluate, the more the sum of squares of; residuals will be reduced. We can evaluate before inverting. as shown below. Coefficients and Coefficient Errors. Having found a parameterization, that is the 's and , that; minimizes , we still need to determine the coefficients; . However, it's a feature of how we choose the significant; functions, that the evaluation of the 's becomes trivial; [5]. To derive ; , we first note that; equation (4) can be written as. (15). where. (16). Consequently, ; is an upper triangle matrix, which can be; readily inverted. So we now evaluate. (17). The model ; can therefore be written as. The original model ; is therefore identical with; this if. (18). The reason we use ; rather then. is to save storage, since. can be stored in the same matrix as. (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors). Considerations. It's important to realize t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:8699,reduce,reduced,8699,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,4,['reduce'],['reduced']
Energy Efficiency,to 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; mass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const. M() is the invariant mass;; in this coordinate system it can be negagative if set that way. { return fPhi; }. Scalar M() const; { return fM; }. Scalar Mag() const; { return M(); }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<Double32_t>::Scalar pt); --------- Set ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html:6770,energy,energy,6770,root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_Double32_t_.html,7,['energy'],['energy']
Energy Efficiency,to 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; mass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const. M() is the invariant mass;; in this coordinate system it can be negagative if set that way. { return fPhi; }. Scalar M() const; { return fM; }. Scalar Mag() const; { return M(); }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { return E(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { return M2() + fPt*fPt; }. Scalar Mt() const. transverse mass - will be negative if Mt2() is negative. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar pi(); { return M_PI; }. void RestrictNegMass(); restrict the value of negative mass to avoid unphysical negative E2 values; M2 must be less than P2 for the tachionic particles - otherwise use positive values. Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt); --------- Set Coor,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_double_.html:6410,energy,energy,6410,root/html526/ROOT__Math__PtEtaPhiM4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_double_.html,7,['energy'],['energy']
Energy Efficiency,to 4 Scalar numbers. { px=fX; py=fY; pz=fZ; m=fM;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar M() const; { return fM; }. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar E() const; other coordinate representation. Energy. { return std::sqrt(E2() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return E2() - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<Double32_t>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<Double32_t>::Scala,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html:6470,energy,energy,6470,root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_Double32_t_.html,7,['energy'],['energy']
Energy Efficiency,"to 4 Scalar numbers. { px=fX; py=fY; pz=fZ; m=fM;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar M() const; { return fM; }. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar E() const; other coordinate representation. Energy. { return std::sqrt(E2() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return E2() - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzM4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzM4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzM4D<double>::Scalar pz). set Z value. void SetM(ROOT::Math::PxPyPzM4D<double>::Scalar m). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::Px",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_double_.html:6114,energy,energy,6114,root/html526/ROOT__Math__PxPyPzM4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_double_.html,7,['energy'],['energy']
Energy Efficiency,"to a 2D histogram called from TH3::Project3D ;  ; Int_t Fill (const char *, const char *, Double_t);  ; Int_t Fill (const char *, Double_t, Double_t);  ; Int_t Fill (Double_t, const char *, Double_t);  ; Double_t Interpolate (Double_t x) const override;  Not yet implemented. ;  ; Double_t Interpolate (Double_t x, Double_t y) const override;  Not yet implemented. ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input array of type float. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup);  Constructor for fix bin size histograms. ;  ; virtual Int_t AutoP2FindLimits (Double_t min, Double_t max);  Buffer-based estimate of the histogram range using the power of 2 algorithm. ;  ; Int_t AxisChoice (Option_t *axis) const;  Choose an axis according to ""axis"". ;  ; virtual void DoFillN (Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1);  Internal method to fill histogram content from a vector called directly by TH1::BufferEmpty. ;  ; virtual Double_t DoIntegral (Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t &err, Option_t *opt, Bool_t doerr=kFALSE) const;  Internal function compute integral and optionally the error between the limits specified by the bin number values working for all histograms (1D, 2D and 3D) ;  ; virtual Bool_t FindNewAxisLimits (const TAxis *axis, const Double_t point, Double_t &newMin, Double_t &newMax);  finds new limits for the axis so that point is within the range and the limits are compatible with the previous ones (see TH1::Merge). ;  ; UInt_t GetAxisLabelStatus () const;  Internal function used in TH1::Fill to see ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile3D.html:57150,power,power,57150,doc/master/classTProfile3D.html,https://root.cern,https://root.cern/doc/master/classTProfile3D.html,1,['power'],['power']
Energy Efficiency,"to be reduced. If omitted, the first default column is used instead. ; [in]redIdentityThe reduced object of each thread is initialized to this value. . Returnsthe reduced quantity wrapped in a RResultPtr. Example usage:; auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; See the description of the first Reduce overload for more information. ; Definition at line 1711 of file RInterface.hxx. ◆ Reduce() [2/2]. template<typename Proxied , typename DataSource = void> . template<typename F , typename T = typename TTraits::CallableTraits<F>::ret_type> . RResultPtr< T > ROOT::RDF::RInterface< Proxied, DataSource >::Reduce ; (; F ; f, . std::string_view ; columnName = """" . ). inline . Execute a user-defined reduce operation on the values of a column. ; Template Parameters. FThe type of the reduce callable. Automatically deduced. ; TThe type of the column to apply the reduction to. Automatically deduced. . Parameters. [in]fA callable with signature T(T,T) ; [in]columnNameThe column to be reduced. If omitted, the first default column is used instead. . Returnsthe reduced quantity wrapped in a ROOT::RDF:RResultPtr.; A reduction takes two values of a column and merges them into one (e.g. by summing them, taking the maximum, etc). This action performs the specified reduction operation on all processed column values, returning a single value of the same type. The callable f must satisfy the general requirements of a processing function besides having signature T(T,T) where T is the type of column columnName.; The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a default-constructed T object. This is commonly expected to be the neutral/identity element for the specific reduction operation f (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this requirement, users should explicitly specify an initialization value for T by calling the appropriate Reduce overload. Example us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:120636,reduce,reduced,120636,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['reduce'],['reduced']
Energy Efficiency,"to delete only keys;; DeleteValues() to delete only values;; DeleteAll() to delete both keys and values. . Implements TCollection.; Definition at line 97 of file TMap.cxx. ◆ Collisions() [1/2]. Int_t TMap::Collisions ; (; const char * ; keyname); const. Returns the number of collisions for a key with a certain name (i.e. ; number of objects in same slot in the hash table, i.e. length of linked list). ; Definition at line 116 of file TMap.cxx. ◆ Collisions() [2/2]. Int_t TMap::Collisions ; (; TObject * ; key); const. Returns the number of collisions for a key (i.e. ; number of objects in same slot in the hash table, i.e. length of linked list). ; Definition at line 125 of file TMap.cxx. ◆ DeclFileName(). static const char * TMap::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 90 of file TMap.h. ◆ Delete(). void TMap::Delete ; (; Option_t * ; option = """"). overridevirtual . Remove all (key,value) pairs from the map AND delete the keys when they are allocated on the heap. ; Implements TCollection.; Definition at line 134 of file TMap.cxx. ◆ DeleteAll(). void TMap::DeleteAll ; (; ). Remove all (key,value) pairs from the map AND delete the keys AND values when they are allocated on the heap. ; Definition at line 168 of file TMap.cxx. ◆ DeleteEntry(). Bool_t TMap::DeleteEntry ; (; TObject * ; key). Remove (key,value) pair with key from the map. ; Returns true if the key was found and removed, false otherwise. The key and value objects are deleted if map is the owner of keys and values respectively. ; Definition at line 190 of file TMap.cxx. ◆ DeleteKeys(). void TMap::DeleteKeys ; (; ). inline . Definition at line 68 of file TMap.h. ◆ DeleteValues(). void TMap::DeleteValues ; (; ). Remove all (key,value) pairs from the map AND delete the values when they are allocated on the heap. ; Definition at line 151 of file TMap.cxx. ◆ FindObject() [1/2]. TObject * TMap::FindObject ; (; const char * ; keyname); const. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMap.html:19971,allocate,allocated,19971,doc/master/classTMap.html,https://root.cern,https://root.cern/doc/master/classTMap.html,1,['allocate'],['allocated']
Energy Efficiency,"to evaluate the derivative with respect each coordinate. To be implemented by the derived class. . ◆ DoDerivativeWithPrevResult(). template<class T > . virtual T ROOT::Math::IGradientFunctionMultiDimTempl< T >::DoDerivativeWithPrevResult ; (; const T * ; x, . unsigned int ; icoord, . T * ; , . T * ; , . T * ;  . ); const. inlineprivatevirtual . In some cases, the derivative algorithm will use information from the previous step, these can be passed in with this overload. ; The previous_* arrays can also be used to return second derivative and step size so that these can be passed forward again as well at the call site, if necessary. ; Definition at line 231 of file IFunction.h. ◆ FdF(). template<class T > . virtual void ROOT::Math::IGradientFunctionMultiDimTempl< T >::FdF ; (; const T * ; x, . T & ; f, . T * ; df . ); const. inlinevirtual . Optimized method to evaluate at the same time the function value and derivative at a point x. ; Often both value and derivatives are needed and it is often more efficient to compute them at the same time. Derived class should implement this method if performances play an important role and if it is faster to evaluate value and derivative at the same time ; Definition at line 202 of file IFunction.h. ◆ Gradient(). template<class T > . virtual void ROOT::Math::IGradientFunctionMultiDimTempl< T >::Gradient ; (; const T * ; x, . T * ; grad . ); const. inlinevirtual . Evaluate all the vector of function derivatives (gradient) at a point x. ; Derived classes must re-implement it if more efficient than evaluating one at a time ; Definition at line 177 of file IFunction.h. ◆ GradientWithPrevResult(). template<class T > . virtual void ROOT::Math::IGradientFunctionMultiDimTempl< T >::GradientWithPrevResult ; (; const T * ; x, . T * ; grad, . T * ; previous_grad, . T * ; previous_g2, . T * ; previous_gstep . ); const. inlinevirtual . In some cases, the gradient algorithm will use information from the previous step, these can be passed in with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IGradientFunctionMultiDimTempl.html:6422,efficient,efficient,6422,doc/master/classROOT_1_1Math_1_1IGradientFunctionMultiDimTempl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IGradientFunctionMultiDimTempl.html,1,['efficient'],['efficient']
Energy Efficiency,"to manage multiple sockets:; {; TServerSocket *ss = new TServerSocket (9090, kTRUE);. // Accept a connection and return a full-duplex communication socket.; TSocket *s0 = ss->Accept();; TSocket *s1 = ss->Accept();. // tell the clients to start; s0->Send(""go 0"");; s1->Send(""go 1"");. // Close the server socket (unless we will use it; // later to wait for another connection).; ss->Close();. TMonitor *mon = new TMonitor;; mon->Add(s0);; mon->Add(s1);. while (1) {; TMessage *mess;; TSocket *s;; s = mon->Select();; s->Recv(mess);; ...; }; }; The full code for the example above is in $ROOTSYS/tutorials/net/hserv.C and; $ROOTSYS/tutorials/net/hclient.C.; 23 Threads; A thread is an independent flow of control that operates within the same address space as other independent flows of controls within a process. In most UNIX systems, thread and process characteristics are grouped into a single entity called a process. Sometimes, threads are called ""lightweight processes’’.; Note: This introduction is adapted from the AIX 4.3 Programmer’s Manual.; 23.1 Threads and Processes; In traditional single-threaded process systems, a process has a set of properties. In multi-threaded systems, these properties are divided between processes and threads.; 23.1.1 Process Properties; A process in a multi-threaded system is the changeable entity. It must be considered as an execution frame. It has all traditional process attributes, such as:. Process ID, process group ID, user ID, and group ID; Environment; Working directory. A process also provides a common address space and common system resources:. File descriptors; Signal actions; Shared libraries; Inter-process communication tools (such as message queues, pipes, semaphores, or shared memory). 23.1.2 Thread Properties; A thread is the schedulable entity. It has only those properties that are required to ensure its independent flow of control. These include the following properties:. Stack; Scheduling properties (such as policy or priority); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1101302,adapt,adapted,1101302,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['adapt'],['adapted']
Energy Efficiency,"to not disturb its branch structure when retrieving information from it. ; Definition at line 367 of file RooTreeDataStore.cxx. ◆ makeTreeName(). std::string RooTreeDataStore::makeTreeName ; (; ); const. private . Generate a name for the storage tree from the name and title of this instance. ; Definition at line 1185 of file RooTreeDataStore.cxx. ◆ merge(). RooAbsDataStore * RooTreeDataStore::merge ; (; const RooArgSet & ; allVars, . std::list< RooAbsDataStore * > ; dstoreList . ). overridevirtual . Merge columns of supplied data set(s) with this data set. ; All data sets must have equal number of entries. In case of duplicate columns the column of the last dataset in the list prevails ; Implements RooAbsDataStore.; Definition at line 840 of file RooTreeDataStore.cxx. ◆ numEntries(). Int_t RooTreeDataStore::numEntries ; (; ); const. overridevirtual . Implements RooAbsDataStore.; Definition at line 926 of file RooTreeDataStore.cxx. ◆ reduce(). std::unique_ptr< RooAbsDataStore > RooTreeDataStore::reduce ; (; RooStringView ; name, . RooStringView ; title, . const RooArgSet & ; vars, . const RooFormulaVar * ; cutVar, . const char * ; cutRange, . std::size_t ; nStart, . std::size_t ; nStop . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 179 of file RooTreeDataStore.cxx. ◆ reset(). void RooTreeDataStore::reset ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 935 of file RooTreeDataStore.cxx. ◆ Reset(). void RooTreeDataStore::Reset ; (; Option_t * ; option = nullptr). Interface function to TTree::Reset. ; Definition at line 1104 of file RooTreeDataStore.cxx. ◆ resetBuffers(). void RooTreeDataStore::resetBuffers ; (; ). overridevirtual . Implements RooAbsDataStore.; Definition at line 1058 of file RooTreeDataStore.cxx. ◆ resetCache(). void RooTreeDataStore::resetCache ; (; ). overridevirtual . Remove tree with values of cached observables and clear list of cached observables. ; Implements RooAbsDataStore.; Definition at line 10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:35269,reduce,reduce,35269,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['reduce'],['reduce']
Energy Efficiency,"to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*,allocator<const TMVA::Event*> >& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ). const Event* Transform(const TMVA::Event *const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event *const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. void ToggleInputSortOrder(Bool_t sortOrder); { fSortGet = sortOrder; }. void SetOu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__VariableTransformBase.html:10095,adapt,adapt,10095,root/html534/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html534/TMVA__VariableTransformBase.html,2,['adapt'],['adapt']
Energy Efficiency,to xy coordinates. ; Definition at line 492 of file TGSpeedo.cxx. Member Data Documentation. ◆ fAngle. Float_t TGSpeedo::fAngle. protected . Definition at line 38 of file TGSpeedo.h. ◆ fAngleMax. Float_t TGSpeedo::fAngleMax. protected . needle min and max angle ; Definition at line 41 of file TGSpeedo.h. ◆ fAngleMin. Float_t TGSpeedo::fAngleMin. protected . Definition at line 41 of file TGSpeedo.h. ◆ fBase. const TGPicture* TGSpeedo::fBase. protected . picture used as background ; Definition at line 30 of file TGSpeedo.h. ◆ fBuffer. std::vector<Float_t> TGSpeedo::fBuffer. protected . circular buffer for mean calculation ; Definition at line 50 of file TGSpeedo.h. ◆ fBufferCount. Int_t TGSpeedo::fBufferCount. protected . circular buffer count ; Definition at line 49 of file TGSpeedo.h. ◆ fBufferSize. Int_t TGSpeedo::fBufferSize. protected . circular buffer size ; Definition at line 48 of file TGSpeedo.h. ◆ fCounter. Int_t TGSpeedo::fCounter. protected . small odo meter (4 digits) ; Definition at line 32 of file TGSpeedo.h. ◆ fCounterFS. FontStruct_t TGSpeedo::fCounterFS. protected . font structures for text rendering ; Definition at line 31 of file TGSpeedo.h. ◆ fDisplay1. TString TGSpeedo::fDisplay1. protected . first line in the small display ; Definition at line 36 of file TGSpeedo.h. ◆ fDisplay2. TString TGSpeedo::fDisplay2. protected . second line in the small display ; Definition at line 37 of file TGSpeedo.h. ◆ fImage. TImage* TGSpeedo::fImage. protected . image used as background ; Definition at line 28 of file TGSpeedo.h. ◆ fImage2. TImage* TGSpeedo::fImage2. protected . intermediate image used as background ; Definition at line 29 of file TGSpeedo.h. ◆ fLabel1. TString TGSpeedo::fLabel1. protected . main label (first line) ; Definition at line 34 of file TGSpeedo.h. ◆ fLabel2. TString TGSpeedo::fLabel2. protected . main label (second line) ; Definition at line 35 of file TGSpeedo.h. ◆ fMeanMark. Bool_t TGSpeedo::fMeanMark. protected . kTRUE if mean mark is a,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGSpeedo.html:40326,meter,meter,40326,doc/master/classTGSpeedo.html,https://root.cern,https://root.cern/doc/master/classTGSpeedo.html,1,['meter'],['meter']
Energy Efficiency,"togram palette. See also TStyle::SetPalette ; Reimplemented in TWebPalette, and TDefHistImagePalette.; Definition at line 497 of file TAttImage.cxx. ◆ IsA(). TClass * TImagePalette::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 56 of file TAttImage.h. ◆ operator=(). TImagePalette & TImagePalette::operator= ; (; const TImagePalette & ; palette). Assignment operator. ; Definition at line 443 of file TAttImage.cxx. ◆ Streamer(). void TImagePalette::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TImagePalette::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 56 of file TAttImage.h. Member Data Documentation. ◆ fColorAlpha. UShort_t* TImagePalette::fColorAlpha {nullptr}. [fNumPoints] alpha at each anchor point ; Definition at line 41 of file TAttImage.h. ◆ fColorBlue. UShort_t* TImagePalette::fColorBlue {nullptr}. [fNumPoints] blue color at each anchor point ; Definition at line 40 of file TAttImage.h. ◆ fColorGreen. UShort_t* TImagePalette::fColorGreen {nullptr}. [fNumPoints] green color at each anchor point ; Definition at line 39 of file TAttImage.h. ◆ fColorRed. UShort_t* TImagePalette::fColorRed {nullptr}. [fNumPoints] red color at each anchor point ; Definition at line 38 of file TAttImage.h. ◆ fNumPoints. UInt_t TImagePalette::fNumPoints {0}. number of anchor points ; Definition at line 36 of file TAttImage.h. ◆ fPoints. Double_t* TImagePalette::fPoints {nullptr}. [fNumPoints] value of each anchor point [0..1] ; Definition at line 37 of file TAttImage.h. Libraries for TImagePalette:. [legend]; The documentation for this class was generated from the following files:; graf2d/graf/inc/TAttImage.h; graf2d/graf/src/TAttImage.cxx. TImagePalette. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:51 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTImagePalette.html:17393,green,green,17393,doc/master/classTImagePalette.html,https://root.cern,https://root.cern/doc/master/classTImagePalette.html,1,['green'],['green']
Energy Efficiency,"togram parameters; // These ensure that the bin contents of the histograms are only allowed to vary within; // the statistical uncertainty of the Monte Carlo.; RooHistConstraint hc_sig(""hc_sig"",""hc_sig"",p_ph_sig1);; RooHistConstraint hc_bkg(""hc_bkg"",""hc_bkg"",p_ph_bkg1);; ; // Construct the joint model with template PDFs and constraints; RooProdPdf model1(""model1"",""model1"",RooArgSet(hc_sig,hc_bkg),Conditional(model_tmp,x));; ; ; ; // ***** Case 2 - 'Barlow Beeston' light (one parameter per bin for all samples) *****; ; // Construct the histogram shapes, using the same parameters for signal and background; // This requires passing the first histogram to the second, so that their common parameters; // can be re-used.; // The first ParamHistFunc will create one parameter per bin, such as `p_ph_sig2_gamma_bin_0`.; // This allows bin 0 to fluctuate up and down.; // Then, the SAME parameters are connected to the background histogram, so the bins fluctuate; // synchronously. This reduces the number of parameters.; RooParamHistFunc p_ph_sig2(""p_ph_sig2"", ""p_ph_sig2"", *dh_sig, x);; RooParamHistFunc p_ph_bkg2(""p_ph_bkg2"", ""p_ph_bkg2"", *dh_bkg, x, &p_ph_sig2, true);; ; RooRealVar Asig2(""Asig"",""Asig"",1,0.01,5000);; RooRealVar Abkg2(""Abkg"",""Abkg"",1,0.01,5000);; ; // As before, construct the sum of signal2 and background2; RooRealSumPdf model2_tmp(""sp_ph"",""sp_ph"",; RooArgList(p_ph_sig2,p_ph_bkg2),; RooArgList(Asig2,Abkg2),; true);; ; // Construct the subsidiary poisson measurements constraining the statistical fluctuations; RooHistConstraint hc_sigbkg(""hc_sigbkg"",""hc_sigbkg"",RooArgSet(p_ph_sig2,p_ph_bkg2));; ; // Construct the joint model; RooProdPdf model2(""model2"",""model2"",hc_sigbkg, RooFit::Conditional(model2_tmp,x));; ; ; ; // ************ Fit all models to data and plot *********************; ; auto result0 = model0.fitTo(sumData, PrintLevel(0), Save());; auto result1 = model1.fitTo(sumData, PrintLevel(0), Save());; auto result2 = model2.fitTo(sumData, PrintLevel(0), Save());;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:3818,reduce,reduces,3818,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,1,['reduce'],['reduces']
Energy Efficiency,"togram which; is not drawn from an ntuple. The other one is available for a; histogram which is drawn from an ntuple. In this case the rebin; algorithm can create a rebinned histogram from the original data; i.e. the ntuple.; To see te differences do for example:; TFile f(""hsimple.root"");; hpxpy->Draw(""Lego2""); // non ntuple histogram; ntuple->Draw(""px:py"","""",""Lego2""); // ntuple histogram; Non ntuple histogram:; 'Rebin': with the Sliders (one for the x, one for the y axis); the number of bins (shown in the field below the; Slider) can be changed to any number which divides; the number of bins of the original histogram.; Pushing 'Apply' will delete the origin histogram and; replace it by the rebinned one on the screen.; Pushing 'Ignore' the origin histogram will be restored; Histogram drawn from an ntuple:; 'Rebin' with the sliders the number of bins can be enlarged by; a factor of 2,3,4,5 (moving to the right) or reduced; by a factor of 1/2, 1/3, 1/4, 1/5; 'BinOffset': with the BinOffset slider the origin of the; histogram can be changed within one binwidth; Using this slider the effect of binning the data into; bins can be made visible => statistical fluctuations; 'Axis Range': with the DoubleSlider it is possible to zoom into; the specified axis range. It is also possible to set; the upper and lower limit in fields below the slider; 'Delayed drawing': all the Binning sliders can be set to delay; draw mode. Then the changes on the histogram are only; updated, when the Slider is released. This should be; activated if the redrawing of the histogram is too; time consuming. Function Members (Methods); public:. TH2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TH2Editor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAcceptModel(TObject* model); virtual voidTGFrame::Activate(Bool_t); virtual voidActivateBaseClassEditors(TClass* cl); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2Editor.html:3275,reduce,reduced,3275,root/html528/TH2Editor.html,https://root.cern,https://root.cern/root/html528/TH2Editor.html,6,['reduce'],['reduced']
Energy Efficiency,"togram which; is not drawn from an ntuple. The other one is available for a; histogram which is drawn from an ntuple. In this case the rebin; algorithm can create a rebinned histogram from the original data; i.e. the ntuple.; To see te differences do for example:; TFile f(""hsimple.root"");; hpxpy->Draw(""Lego2""); // non ntuple histogram; ntuple->Draw(""px:py"","""",""Lego2""); // ntuple histogram; Non ntuple histogram:; 'Rebin': with the Sliders (one for the x, one for the y axis); the number of bins (shown in the field below the; Slider) can be changed to any number which divides; the number of bins of the original histogram.; Pushing 'Apply' will delete the origin histogram and; replace it by the rebinned one on the screen.; Pushing 'Ignore' the origin histogram will be restored; Histogram drawn from an ntuple:; 'Rebin' with the sliders the number of bins can be enlarged by; a factor of 2,3,4,5 (moving to the right) or reduced; by a factor of 1/2, 1/3, 1/4, 1/5; 'BinOffset': with the BinOffset slider the origin of the; histogram can be changed within one binwidth; Using this slider the effect of binning the data into; bins can be made visible => statistical fluctuations; 'Axis Range': with the DoubleSlider it is possible to zoom into; the specified axis range. It is also possible to set; the upper and lower limit in fields below the slider; 'Delayed drawing': all the Binning sliders can be set to delay; draw mode. Then the changes on the histogram are only; updated, when the Slider is released. This should be; activated if the redrawing of the histogram is too; time consuming. Function Members (Methods); public:. virtual~TH2Editor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAcceptModel(TObject* model); virtual voidTGFrame::Activate(Bool_t); virtual voidActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2Editor.html:3276,reduce,reduced,3276,root/html602/TH2Editor.html,https://root.cern,https://root.cern/root/html602/TH2Editor.html,4,['reduce'],['reduced']
Energy Efficiency,"ton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. Int_tfColormap[64][3]colormap; Pixel_tfPixel[64]pixel values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pix",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGColorPick.html:19555,allocate,allocate,19555,root/html528/TGColorPick.html,https://root.cern,https://root.cern/root/html528/TGColorPick.html,6,['allocate'],['allocate']
Energy Efficiency,"tor (for each coordinate) which can be used to scale the step sizes (this is used for example by the minimization algorithm) ;  ; virtual ~GSLSimAnFunc ();  virtual destructor (no operations) ;  ; virtual GSLSimAnFunc * Clone () const;  clone method. ;  ; virtual double Distance (const GSLSimAnFunc &func) const;  calculate the distance (metric) between this one and another configuration Presently a cartesian metric is used. ;  ; virtual double Energy () const;  evaluate the energy ( objective function value) re-implement by derived classes if needed to be modified ;  ; virtual GSLSimAnFunc & FastCopy (const GSLSimAnFunc &f);  fast copy method called by GSL simulated annealing internally copy only the things which have been changed must be re-implemented by derived classes if needed ;  ; unsigned int NDim () const;  ; virtual void Print ();  print the position in the standard output std::ostream GSL prints in addition n iteration, n function calls, temperature and energy re-implement by derived classes if necessary ;  ; double Scale (unsigned int i) const;  ; void SetX (const double *x);  change the x values (used by sim annealing to take a step) ;  ; template<class IT > ; void SetX (IT begin, IT end);  ; void SetX (unsigned int i, double x);  ; virtual void Step (const GSLRandomEngine &r, double maxstep);  change the x[i] value using a random value urndm generated between [0,1] up to a maximum value maxstep re-implement by derived classes if needed to be modified ;  ; const std::vector< double > & X () const;  ; double X (unsigned int i) const;  . Protected Member Functions;  GSLSimAnFunc ();  derived classes might need to re-define completely the class ;  . Private Attributes; const ROOT::Math::IMultiGenFunction * fFunc;  ; std::vector< double > fScale;  ; std::vector< double > fX;  . #include <Math/GSLSimAnnealing.h>; Constructor & Destructor Documentation. ◆ GSLSimAnFunc() [1/3]. ROOT::Math::GSLSimAnFunc::GSLSimAnFunc ; (; const ROOT::Math::IMultiGenFunction & ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLSimAnFunc.html:1662,energy,energy,1662,doc/master/classROOT_1_1Math_1_1GSLSimAnFunc.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLSimAnFunc.html,2,['energy'],['energy']
Energy Efficiency,"tor is (-,-,-,+).; 40In the case of LorentzVector we don't distinguish the concepts; 41of points and displacement vectors as in the 3D case,; 42since the main use case for 4D Vectors is to describe the kinematics of; 43relativistic particles. A LorentzVector behaves like a; 44DisplacementVector in 4D. The Minkowski components could be viewed as; 45v and t, or for kinematic 4-vectors, as p and E.; 46 ; 47ROOT provides specialisations and aliases to them of the ROOT::Math::LorentzVector template:; 48- ROOT::Math::PtEtaPhiMVector based on pt (rho),eta,phi and M (t) coordinates in double precision; 49- ROOT::Math::PtEtaPhiEVector based on pt (rho),eta,phi and E (t) coordinates in double precision; 50- ROOT::Math::PxPyPzMVector based on px,py,pz and M (mass) coordinates in double precision; 51- ROOT::Math::PxPyPzEVector based on px,py,pz and E (energy) coordinates in double precision; 52- ROOT::Math::XYZTVector based on x,y,z,t coordinates (cartesian) in double precision (same as PxPyPzEVector); 53- ROOT::Math::XYZTVectorF based on x,y,z,t coordinates (cartesian) in float precision (same as PxPyPzEVector but float); 54 ; 55@sa Overview of the @ref GenVector ""physics vector library""; 56*/; 57 ; 58 template< class CoordSystem >; 59 class LorentzVector {; 60 ; 61 public:; 62 ; 63 // ------ ctors ------; 64 ; 65 typedef typename CoordSystem::Scalar Scalar;; 66 typedef CoordSystem CoordinateType;; 67 ; 68 /**; 69 default constructor of an empty vector (Px = Py = Pz = E = 0 ); 70 */; 71 LorentzVector ( ) : fCoordinates() { }; 72 ; 73 /**; 74 generic constructors from four scalar values.; 75 The association between values and coordinate depends on the; 76 coordinate system. For PxPyPzE4D,; 77 \param a scalar value (Px); 78 \param b scalar value (Py); 79 \param c scalar value (Pz); 80 \param d scalar value (E); 81 */; 82 LorentzVector(const Scalar & a,; 83 const Scalar & b,; 84 const Scalar & c,; 85 const Scalar & d) :; 86 fCoordinates(a , b, c, d) { }; 87 ; 88 /**; 89 construct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:2198,energy,energy,2198,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['energy'],['energy']
Energy Efficiency,"tor new[](size_t sz, void* vp); TSpectrum2Fit&operator=(const TSpectrum2Fit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidSetBackgroundParameters(Double_t a0Init, Bool_t fixA0, Double_t axInit, Bool_t fixAx, Double_t ayInit, Bool_t fixAy); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFitParameters(Int_t xmin, Int_t xmax, Int_t ymin, Int_t ymax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPeakParameters(Double_t sigmaX, Bool_t fixSigmaX, Double_t sigmaY, Bool_t fixSigmaY, Double_t ro, Bool_t fixRo, const Float_t* positionInitX, const Bool_t* fixPositionX, const Float_t* positionInitY, const Bool_t* fixPositionY, const Float_t* positionInitX1, const Bool_t* fixPositionX1, const Float_t* positionInitY1, const Bool_t* fixPositionY1, const Float_t* ampInit, const Bool_t* fixAmp, const Float_t* ampInitX1, const Bool_t* fixAmpX1, const Float_t* ampInitY1, const Bool_t* fixAmpY1); voidSetTailParameters(Double_t tInitXY, Bool_t fixTxy, Double_t tInitX, Bool_t fixTx, Double_t tInitY, Bool_t fixTy, Double_t bInitX, Bool_t fixBx, Double_t bInitY, Bool_t fixBy, Double_t sInitXY, Bool_t fixSxy, Double_t sInitX, Bool_t fixSx, Double_t sInitY, Bool_t fixSy); virtual voidTNamed::SetTitle(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:6201,power,power,6201,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,1,['power'],['power']
Energy Efficiency,"tor object. ; If mainloop is true the monitoring will be done in the main event loop. ; Definition at line 109 of file TMonitor.cxx. ◆ TMonitor() [2/2]. TMonitor::TMonitor ; (; const TMonitor & ; m). Copy constructor. ; Definition at line 123 of file TMonitor.cxx. ◆ ~TMonitor(). TMonitor::~TMonitor ; (; ). virtual . Cleanup the monitor object. Does not delete sockets being monitored. ; Definition at line 153 of file TMonitor.cxx. Member Function Documentation. ◆ Activate(). void TMonitor::Activate ; (; TSocket * ; sock). virtual . Activate a de-activated socket. ; Definition at line 250 of file TMonitor.cxx. ◆ ActivateAll(). void TMonitor::ActivateAll ; (; ). virtual . Activate all de-activated sockets. ; Definition at line 268 of file TMonitor.cxx. ◆ Add(). void TMonitor::Add ; (; TSocket * ; sock, . Int_t ; interest = kRead . ). virtual . Add socket to the monitor's active list. ; If interest=kRead then we want to monitor the socket for read readiness, if interest=kWrite then we monitor the socket for write readiness, if interest=kRead|kWrite then we monitor both read and write readiness. ; Definition at line 168 of file TMonitor.cxx. ◆ Class(). static TClass * TMonitor::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMonitor::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMonitor::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 85 of file TMonitor.h. ◆ DeActivate(). void TMonitor::DeActivate ; (; TSocket * ; sock). virtual . De-activate a socket. ; Definition at line 284 of file TMonitor.cxx. ◆ DeActivateAll(). void TMonitor::DeActivateAll ; (; ). virtual . De-activate all activated sockets. ; Definition at line 302 of file TMonitor.cxx. ◆ DeclFileName(). static const char * TMonitor::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 85 of file TMon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMonitor.html:17818,monitor,monitor,17818,doc/master/classTMonitor.html,https://root.cern,https://root.cern/doc/master/classTMonitor.html,3,['monitor'],['monitor']
Energy Efficiency,"tor& insp); Int_tSizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. UInt_tfDatimeDate (relative to 1995) + time. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDatime(); Create a TDatime and set it to the current time. TDatime(Int_t date, Int_t time); Create a TDatime and set it to the specified date and time.; See Set(Int_t, Int_t) about the date, time format. TDatime(Int_t year, Int_t month, Int_t day, Int_t hour, Int_t min, Int_t sec); Create a TDatime and set it to the specified year, month,; day, time, hour, minute and second. See Set() about the format. TDatime(const char* sqlDateTime); Expects as input a string in SQL date/time compatible format, like:; yyyy-mm-dd hh:mm:ss. Int_t GetDayOfWeek() const; Returns day of week, with Monday being day 1 and Sunday day 7. const char * AsString() const; Return the date & time as a string (ctime() format).; Copy result because it points to a statically allocated string. const char * AsString(char* out) const; Return the date & time as a string (ctime() format).; Result is copied into out (and out is returned). Make sure; out can at least contain 26 characters. Thread safe. const char * AsSQLString() const; Return the date & time in SQL compatible string format, like:; 1997-01-15 20:16:28. The returned string buffer is static and; will be reused. UInt_t Convert(Bool_t toGMT = kFALSE) const; Convert fDatime from TDatime format to the standard time_t format.; If toGMT is true, the time offset of the current local time zone is; subtracted from the returned time_t. One use of such a non-standard time_t; value is to convert a TDatime object that contains local time to GMT,; as in this example:. TDatime now;; now.Set(now.Convert(kTRUE));. Caution: the time_t returned from Convert(kTRUE) is incompatible with; regular Unix time - it contains an artificial, locale-dependent offset. void Copy(TDatime& datime) const; Copy this to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDatime.html:3015,allocate,allocated,3015,root/html528/TDatime.html,https://root.cern,https://root.cern/root/html528/TDatime.html,4,['allocate'],['allocated']
Energy Efficiency,"tor&); voidSaveBeltToFile(bool flag = true); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData& data); voidSetLeftSideTailFraction(Double_t leftSideFraction = 0.); virtual voidSetModel(const RooStats::ModelConfig& model); virtual voidSetNuisanceParameters(const RooArgSet&); voidSetParameterPointsToTest(RooAbsData& pointsToTest); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidSetTestSize(Double_t size); voidSetTestStatSampler(RooStats::TestStatSampler& sampler); virtual voidShowMembers(TMemberInspector&); virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUseAdaptiveSampling(bool flag = true). Data Members; private:. boolfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; boolfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set ; Double_tfLeftSideFraction; RooStats::ModelConfig&fModel; RooAbsData*fPointsToTest; boolfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::TestStatSampler*fTestStatSampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; NeymanConstruction(RooAbsData& data, RooStats::ModelConfig& model); default constructor; fWS = new RooWorkspace();; fOwnsWorkspace = true;; fDataName = """";; fPdfName = """";. ~NeymanConstruction(); default constructor; if(fOwnsWorkspace && fWS) delete fWS;; if(fConfBelt) delete fConfBelt;. PointSetInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::SetInterval. NeymanConstruction(RooAbsData& data, RooStats::ModelConfig& model); NeymanConstruction();. void SetTestStatSampler(RooStats::TestStatSampler& sampler); in addition to interface we a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__NeymanConstruction.html:3859,adapt,adaptive,3859,root/html534/RooStats__NeymanConstruction.html,https://root.cern,https://root.cern/root/html534/RooStats__NeymanConstruction.html,2,['adapt'],['adaptive']
Energy Efficiency,"tor.; Definition at line 72 of file BayesianCalculator.h. ◆ SetGlobalObservables(). virtual void RooStats::BayesianCalculator::SetGlobalObservables ; (; const RooArgSet & ; set). inlinevirtual . set the global observables which will be used when creating the NLL so the constraint pdf's will be normalized correctly on the global observables when computing the NLL ; Definition at line 96 of file BayesianCalculator.h. ◆ SetIntegrationType(). void RooStats::BayesianCalculator::SetIntegrationType ; (; const char * ; type). set the integration type (possible type are) : . 1D integration ( used when only one nuisance and when the posterior is scanned): adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration The parameter numIters (settable with SetNumIters) is the max number of function calls. It can be reduced to make the integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC: evaluate posterior by generating toy MC for the nuisance parameters. It is a MC integration, where the function is sampled according to the nuisance. It is convenient to use when all the nuisance are uncorrelated and it is efficient to generate them The toy are generated by default for each poi values (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for each poi value. It can be convenient when the generation time is much larger than the evaluation time, otherwise it is recommended to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html:30667,reduce,reduced,30667,doc/master/classRooStats_1_1BayesianCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html,1,['reduce'],['reduced']
Energy Efficiency,"tor< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fEXlow, fEXhigh, fEXlowd, fEXhighd, fEYlow, fEYhigh, fEYlowd, ; and fEYhighd arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void SaveHistogramAndFunctions (std::ostream &out, const char *varname, Int_t &frameNumber, Option_t *option);  Save histogram and list of functions of TGraph as C++ statement Used in all TGraph-derived classes. ;  ; Double_t ** ShrinkAndCopy (Int_t size, Int_t iend);  if size*2 <= fMaxSize allocate new arrays of size points, copy points [0,oend). ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Double_t * fEXhigh;  [fNpoints] array of X high errors ;  ; Double_t * fEXhighd;  [fNpoints] array of X high displacements ;  ; Double_t * fEXlow;  [fNpoints] array of X low errors ;  ; Double_t * fEXlowd;  [fNpoints] array of X low displacements ;  ; Double_t * fEYhigh;  [fNpoints] array of Y high errors ;  ; Double_t * fEYhighd;  [fNpoints] array of Y high displacements ;  ; Double_t * fEYlow;  [fNpoints] array of Y low errors ;  ; Double_t * fEYlowd;  [fNpoints] array of Y low displacements ;  ;  Protected Attributes inherited from TGraph; TList * fFunctions;  Pointer to list of functions (fits and user) ;  ; TH1F * fHistogram;  Pointer to histogram used for drawing axis. ;  ; Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphBentErrors.html:31181,allocate,allocate,31181,doc/master/classTGraphBentErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphBentErrors.html,1,['allocate'],['allocate']
Energy Efficiency,"torMultiDim*fIntegratorpointer to multi-dimensional integrator base class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorMultiDim.html:3283,adapt,adaptive,3283,root/html528/ROOT__Math__IntegratorMultiDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorMultiDim.html,10,['adapt'],['adaptive']
Energy Efficiency,"torial hist/sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. * Projections; The dimensionality of a THnSparse can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call; THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Functio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnSparse.html:3725,allocate,allocated,3725,root/html534/THnSparse.html,https://root.cern,https://root.cern/root/html534/THnSparse.html,6,['allocate'],['allocated']
Energy Efficiency,"toring > ptrMonitoring);  prepared for monitoring ;  ; virtual void setProgressLimits (double minProgress=0, double maxProgress=100);  ; virtual void startTestCycle ();  callback for monitoring and loggging ;  ; virtual void startTrainCycle ();  ; virtual void startTraining ();  ; virtual void testIteration ();  callback for monitoring and loggging ;  ; size_t testRepetitions () const;  how often is the test data tested ;  ; virtual void testSample (double, double, double, double);  virtual function to be used for monitoring (callback) ;  ; bool useMultithreading () const;  is multithreading turned on? ;  . Public Attributes; size_t count_dE;  ; size_t count_E;  ; size_t count_mb_dE;  ; size_t count_mb_E;  ; double fLearningRate;  ; MinimizerType fMinimizerType;  ; double fMomentum;  ; int fRepetitions;  ; size_t m_batchSize;  mini-batch size ;  ; size_t m_convergenceCount;  ; size_t m_convergenceSteps;  number of steps without improvement to consider the DNN to have converged ;  ; std::vector< double > m_dropOut;  ; double m_dropRepetitions;  ; double m_factorWeightDecay;  ; size_t m_maxConvergenceCount;  ; double m_maxProgress;  current limits for the progress bar ;  ; double m_minError;  ; double m_minProgress;  current limits for the progress bar ;  ; EnumRegularization m_regularization;  ; size_t m_testRepetitions;  ; Timer m_timer;  timer for monitoring ;  . Protected Attributes; std::shared_ptr< Monitoring > fMonitoring;  ; bool m_useMultithreading;  . #include <TMVA/NeuralNet.h>. Inheritance diagram for TMVA::DNN::Settings:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ Settings(). TMVA::DNN::Settings::Settings ; (; TString ; name, . size_t ; _convergenceSteps = 15, . size_t ; _batchSize = 10, . size_t ; _testRepetitions = 7, . double ; _factorWeightDecay = 1e-5, . TMVA::DNN::EnumRegularization ; _regularization = TMVA::DNN::EnumRegularization::NONE, . MinimizerType ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:4528,monitor,monitoring,4528,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['monitor'],['monitoring']
Energy Efficiency,"toring and loggging; 805 virtual void endTestCycle () {} ///< callback for monitoring and loggging; 806 virtual void testIteration () {} ///< callback for monitoring and loggging; 807 virtual void drawSample (const std::vector<double>& /*input*/, const std::vector<double>& /* output */, const std::vector<double>& /* target */, double /* patternWeight */) {} ///< callback for monitoring and logging; 808 ; 809 virtual void computeResult (const Net& /* net */, std::vector<double>& /* weights */) {} ///< callback for monitoring and logging; 810 ; 811 virtual bool hasConverged (double testError); ///< has this training converged already?; 812 ; 813 EnumRegularization regularization () const { return m_regularization; } ///< some regularization of the DNN is turned on?; 814 ; 815 bool useMultithreading () const { return m_useMultithreading; } ///< is multithreading turned on?; 816 ; 817 ; 818 void pads (int numPads) { if (fMonitoring) fMonitoring->pads (numPads); } ///< preparation for monitoring; 819 void create (std::string histoName, int bins, double min, double max) { if (fMonitoring) fMonitoring->create (histoName, bins, min, max); } ///< for monitoring; 820 void create (std::string histoName, int bins, double min, double max, int bins2, double min2, double max2) { if (fMonitoring) fMonitoring->create (histoName, bins, min, max, bins2, min2, max2); } ///< for monitoring; 821 void addPoint (std::string histoName, double x) { if (fMonitoring) fMonitoring->addPoint (histoName, x); } ///< for monitoring; 822 void addPoint (std::string histoName, double x, double y) {if (fMonitoring) fMonitoring->addPoint (histoName, x, y); } ///< for monitoring; 823 void plot (std::string histoName, std::string options, int pad, EColor color) { if (fMonitoring) fMonitoring->plot (histoName, options, pad, color); } ///< for monitoring; 824 void clear (std::string histoName) { if (fMonitoring) fMonitoring->clear (histoName); } ///< for monitoring; 825 bool exists (std::string histoName) { i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:30516,monitor,monitoring,30516,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"toring output ; Definition at line 520 of file NeuralNet.cxx. ◆ setWeightSums(). void TMVA::DNN::ClassificationSettings::setWeightSums ; (; double ; sumOfSigWeights, . double ; sumOfBkgWeights . ). set the weight sums to be scaled to (preparations for monitoring output) ; Definition at line 512 of file NeuralNet.cxx. ◆ startTestCycle(). void TMVA::DNN::ClassificationSettings::startTestCycle ; (; ). virtual . action to be done when the test cycle is started (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 316 of file NeuralNet.cxx. ◆ startTrainCycle(). void TMVA::DNN::ClassificationSettings::startTrainCycle ; (; ). virtual . action to be done when the training cycle is started (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 281 of file NeuralNet.cxx. ◆ testIteration(). void TMVA::DNN::ClassificationSettings::testIteration ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented from TMVA::DNN::Settings.; Definition at line 930 of file NeuralNet.h. ◆ testSample(). void TMVA::DNN::ClassificationSettings::testSample ; (; double ; error, . double ; output, . double ; target, . double ; weight . ). virtual . action to be done after the computation of a test sample (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 304 of file NeuralNet.cxx. Member Data Documentation. ◆ m_ams. std::vector<double> TMVA::DNN::ClassificationSettings::m_ams. Definition at line 1000 of file NeuralNet.h. ◆ m_cutValue. double TMVA::DNN::ClassificationSettings::m_cutValue. Definition at line 1008 of file NeuralNet.h. ◆ m_fileNameNetConfig. std::string TMVA::DNN::ClassificationSettings::m_fileNameNetConfig. Definition at line 1011 of file NeuralNet.h. ◆ m_fileNameResult. std::string TMVA::DNN::ClassificationSettings::m_fileNameResult. Definition at line 1010 of file NeuralNet.h. ◆ m_input. std::vector<double> TMVA::DNN::Classif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html:9069,monitor,monitoring,9069,doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,1,['monitor'],['monitoring']
Energy Efficiency,"tors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; ROOT::Math::IBaseFunctionOneDimROOT::Math::IBaseFunctionOneDim::IBaseFunctionOneDim(); ROOT::Math::IBaseFunctionOneDimROOT::Math::IBaseFunctionOneDim::IBaseFunctionOneDim(const ROOT::Math::IBaseFunctionOneDim&); ROOT::Math::IGradientFunctionOneDimIGradientFunctionOneDim(); ROOT::Math::IGradientFunctionOneDimIGradientFunctionOneDim(const ROOT::Math::IGradientFunctionOneDim&); ROOT::Math::IGradientOneDimROOT::Math::IGradientOneDim::IGradientOneDim(); ROOT::Math::IGradientOneDimROOT::Math::IGradientOneDim::IGradientOneDim(const ROOT::Math::IGradientOneDim&); doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionOneDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IGradientFunctionOneDim.html:2663,efficient,efficient,2663,root/html602/ROOT__Math__IGradientFunctionOneDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IGradientFunctionOneDim.html,2,['efficient'],['efficient']
Energy Efficiency,"tors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; ROOT::Math::IBaseFunctionOneDimROOT::Math::IBaseFunctionOneDim::IBaseFunctionOneDim(); ROOT::Math::IBaseFunctionOneDimROOT::Math::IBaseFunctionOneDim::IBaseFunctionOneDim(const ROOT::Math::IBaseFunctionOneDim&); ROOT::Math::IGradientFunctionOneDimIGradientFunctionOneDim(); ROOT::Math::IGradientFunctionOneDimIGradientFunctionOneDim(const ROOT::Math::IGradientFunctionOneDim&); ROOT::Math::IGradientOneDimROOT::Math::IGradientOneDim::IGradientOneDim(); ROOT::Math::IGradientOneDimROOT::Math::IGradientOneDim::IGradientOneDim(const ROOT::Math::IGradientOneDim&); doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionOneDim(). Virtual Destructor (no operations). {}. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IGradientFunctionOneDim.html:2663,efficient,efficient,2663,root/html604/ROOT__Math__IGradientFunctionOneDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IGradientFunctionOneDim.html,2,['efficient'],['efficient']
Energy Efficiency,"tors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5737,ADAPT,ADAPTIVE,5737,root/html532/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html,2,['ADAPT'],['ADAPTIVE']
Energy Efficiency,"tors; that import data from an external TH1. void initialize(const char* binningName = 0, Bool_t fillTree = kTRUE); Initialization procedure: allocate weights array, calculate; multipliers needed for N-space to 1-dim array jump table,; and fill the internal tree with all bin center coordinates. RooDataHist(const RooDataHist& other, const char* newname = 0); Copy constructor. RooDataHist(const char* name, const char* title, RooDataHist* h, const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t copyCache); Constructor of a data hist from (part of) an existing data hist. The dimensions; of the data set are defined by the 'vars' RooArgSet, which can be identical; to 'dset' dimensions, or a subset thereof. Reduced dimensions will be projected; in the output data hist. The optional 'cutVar' formula variable can used to; select the subset of bins to be copied. For most uses the RooAbsData::reduce() wrapper function, which uses this constructor,; is the most convenient way to create a subset of an existing data. RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Construct a clone of this dataset that contains only the cached variables. RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ~RooDataHist(); Destructor. Int_t getIndex(const RooArgSet& coord). Int_t calcTreeIndex() const; Calculate the index for the weights array corresponding to; to the bin enclosing the current coordinates of the internal argset. void dump2(); Debug stuff, should go... RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Back end function to plotting functionality. Plot RooDataHist on given; frame in mode specified by plot options 'o'. The main purpose of; th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataHist.html:25425,reduce,reduce,25425,root/html526/RooDataHist.html,https://root.cern,https://root.cern/root/html526/RooDataHist.html,5,['reduce'],['reduce']
Energy Efficiency,"tory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containing query results and status; TProofLockPath*fQueryLockquery dir locker; Int_tfQuerySeqNumsequential number of the current or last query; TList*fQueuedMsglist of messages waiting to be processed; Float_tfRealTimereal time spent executing commands; Bool_tfRealTimeLogTRUE if log messages should be send back in real-time; TReaperTimer*fReaperTimerTimer used to control children state; TStopwatchfSaveOutputmeasures time spent saving the partial result; Bool_tfSendLogToMasterOn workers, controls logs sending to master; TStringfServiceservice we are running, either ""proofserv"" or ""proofslave""; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the server session; TShutdownTimer*fShutdownTimerTimer used to shutdown out-of-control sessions; TSocket*fSocketsocket connection to client; TStringfTopSessionTagtag for the global session; Int_tfTotSessionsTotal number of PROOF sessions on the cluster ; TStringfUseruser as which we run; TList*fWaitingQuerieslist of TProofQueryResult waiting to be processed; TStringfWorkDirdirectory containing all proof related info; static FILE*fgErrorHandlerFileFile where to log; static Int_tfgLogToSysLog>0 sent to syslog too; static Float_tfgMemHWMThreshold fraction of max for warning and finer monitoring; static Float_tfgMemStopFraction of max for stop processing; static Int_tfgRecursiveKeep track of recursive inputs during processing; static Long_tfgResMemMaxHard limit on the resident memory checked; static TStringfgSysLogEntitylogging entity (<user>:<group>); static TStringfgSysLogServicename of the syslog service (eg: proofm-0, proofw-0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:20975,monitor,monitoring,20975,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,2,['monitor'],['monitoring']
Energy Efficiency,"tory; RooRealIntegral Real-valued function representing an integral over a RooAbsReal object; RooRealMPFE Multi-process front-end for parallel calculation of a real valued function; RooRealProxy Proxy for a RooAbsReal object; RooRealSumPdf PDF constructed from a sum of (non-pdf) functions; RooRealVar Real-valued variable; RooRealVarSharedProperties Shared properties of a RooRealVar clone set; RooRecursiveFraction Recursive fraction formula f1*(1-f2)*(1-f3) etc...; RooRefArray Helper class for proxy lists; RooRefCountList RooLinkedList with reference counting; RooResolutionModel Abstract Resolution Model; RooScaledFunc Function binding applying scaling to another function binding; RooSecondMoment Representation of moment in a RooAbsReal in a given RooRealVar; RooSegmentedIntegrator1D 1-dimensional piece-wise numerical integration engine; RooSegmentedIntegrator2D 2-dimensional piece-wise numerical integration engine; RooSentinel ; RooSetPair Utility class holding a pair of RooArgSet pointers; RooSetProxy Proxy class for a RooArgSet; RooSharedProperties Abstract interface for shared property implementations; RooSharedPropertiesList Manager for shared properties among clones of certain RooAbsArg-derived types; RooSimGenContext Context for efficiently generating a dataset from a RooSimultaneous PDF; RooSimPdfBuilder RooSimultaneous PDF Builder (obsolete); RooSimSplitGenContext Context for efficiently generating a dataset from a RooSimultaneous PDF; RooSimWSTool Workspace oriented tool for customized cloning of p.d.f. into a simultaneous p.d.f; RooSimWSTool::BuildConfig Build configuration object for RooSimWSTool; RooSimWSTool::MultiBuildConfig Build configuration object for RooSimWSTool with multiple prototype p.d.f.; RooSimWSTool::ObjBuildConfig Validated RooSimWSTool build configuration; RooSimWSTool::ObjSplitRule Validated RooSimWSTool split rule; RooSimWSTool::SplitRule Split rule specification for prototype p.d.f; RooSimultaneous Simultaneous operator p.d.f, functio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:40872,efficient,efficiently,40872,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,8,['efficient'],['efficiently']
Energy Efficiency,"tour(Int_t nlevels=20, const Double_t *levels=nullptr)Set the number and values of contour levels.Definition TF2.cxx:892; TF2::SetNpyvirtual void SetNpy(Int_t npy=100)Set the number of points used to draw the function.Definition TF2.cxx:927; TF2::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF2.cxx:259; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::Rangevoid Range(Double_t x1, Double_t y1, Double_t x2, Double_t y2) overrideSet world coordinate system for the pad.Definition TPad.cxx:5331; TPad::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet Current pad.Definition TPad.cxx:693; TPad::Drawvoid Draw(Option_t *option="""") overrideDraw Pad in Current pad (re-parent pad if necessary).Definition TPad.cxx:1364; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; lineTLine * lineDefinition entrylistblock_figure1.C:235; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; graphDefinition graph.py:1; AuthorOtto Schaile ; Definition in file waves.C. tutorialsgraphswaves.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/waves_8C.html:7673,power,power,7673,doc/master/waves_8C.html,https://root.cern,https://root.cern/doc/master/waves_8C.html,1,['power'],['power']
Energy Efficiency,"tpServer into application) can be implemented in JSON format. There is the TBufferJSON class, which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to create JSON files for selected objects and write such files in a directory, which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser.; There is a demonstration page showing such functionality: https://root.cern/js/latest/demo/update_draw.htm. This demo page reads in cycle 20 json files and displays them.; If one has a web server which already provides such JSON file, one could specify the URL to this file like:; https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz; Here the same problem with Cross-Origin Request can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself.; 1.10.3 Binary file-based monitoring (not recommended); Theoretically, one could use binary ROOT files to implement monitoring. With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats.; First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate.; The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol. There is no http file locking mechanism (at least not for standard web servers), therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:20911,monitor,monitoring,20911,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,4,['monitor'],['monitoring']
Energy Efficiency,"tput. Float_t GetTickLength(Option_t* axis = ""X"") const; Return tick length. Color_t GetTitleColor(Option_t* axis = ""X"") const; Return title color. Style_t GetTitleFont(Option_t* axis = ""X"") const; Return title font. Float_t GetTitleOffset(Option_t* axis = ""X"") const; Return title offset. Float_t GetTitleSize(Option_t* axis = ""X"") const; Return title size. void Paint(Option_t* option = """"); Show the options from the current style; if (TClass::GetClass(""TStyleManager"")) gSystem->Load(""libGed"");. void SetColorModelPS(Int_t c = 0); Define the color model used by TPostScript and TPDF (RGB or CMYK).; CMY and CMYK models are subtractive color models unlike RGB which is; additive. They are mainly used for printing purposes. CMY means Cyan Magenta; Yellow. To convert RGB to CMY it is enough to do: C=1-R, M=1-G and Y=1-B.; CMYK has one more component K (black). The conversion from RGB to CMYK is:. Double_t Black = TMath::Min(TMath::Min(1-Red,1-Green),1-Blue);; Double_t Cyan = (1-Red-Black)/(1-Black);; Double_t Magenta = (1-Green-Black)/(1-Black);; Double_t Yellow = (1-Blue-Black)/(1-Black);. CMYK adds the black component which allows better quality for black; printing. PostScript and PDF support the CMYK model. c = 0 means TPostScript and TPDF will use RGB color model (default); c = 1 means TPostScript and TPDF will use CMYK color model. void SetHistMinimumZero(Bool_t zero = kTRUE); If the argument zero=kTRUE the minimum value for the Y axis of 1-d histograms; is set to 0 if the minimum bin content is greater than 0 and TH1::SetMinimum; has not been called.; Otherwise the minimum is based on the minimum bin content. void SetNdivisions(Int_t n = 510, Option_t* axis = ""X""); Set the number of divisions to draw an axis.; ndiv : Number of divisions. n = N1 + 100*N2 + 10000*N3; N1=number of primary divisions.; N2=number of secondary divisions.; N3=number of 3rd divisions.; e.g.:; nndi=0 --> no tick marks.; nndi=2 --> 2 divisions, one tick mark in the middle; of the axis.; axis spe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStyle.html:26027,Green,Green,26027,root/html532/TStyle.html,https://root.cern,https://root.cern/root/html532/TStyle.html,8,['Green'],"['Green', 'Green-Black']"
Energy Efficiency,"track being transported. void TrackMomentum(TLorentzVector& momentum) const; Return the direction and the momentum (GeV/c) of the track; currently being transported. void TrackMomentum(Double_t& px, Double_t& py, Double_t& pz, Double_t& etot) const; Return the direction and the momentum (GeV/c) of the track; currently being transported. Double_t TrackStep() const; Return the length in centimeters of the current step (in cm). Double_t TrackLength() const; Return the length of the current track from its origin (in cm). Double_t TrackTime() const; Return the current time of flight of the track being transported. Double_t Edep() const; Return the energy lost in the current step. Int_t TrackPid() const. get methods; tracking particle; static properties. Return the PDG of the particle transported. Double_t TrackCharge() const; Return the charge of the track currently transported. Double_t TrackMass() const; Return the mass of the track currently transported. Double_t Etot() const; Return the total energy of the current track. Bool_t IsNewTrack() const. get methods - track status. Return true when the track performs the first step. Bool_t IsTrackInside() const; Return true if the track is not at the boundary of the current volume. Bool_t IsTrackEntering() const; Return true if this is the first step of the track in the current volume. Bool_t IsTrackExiting() const; Return true if this is the last step of the track in the current volume. Bool_t IsTrackOut() const; Return true if the track is out of the setup. Bool_t IsTrackDisappeared() const; Return true if the current particle has disappeared; either because it decayed or because it underwent; an inelastic collision. Bool_t IsTrackStop() const; Return true if the track energy has fallen below the threshold. Bool_t IsTrackAlive() const; Return true if the current particle is alive and will continue to be; transported. Int_t NSecondaries() const. get methods - secondaries. Return the number of secondary particles generated i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:34758,energy,energy,34758,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,10,['energy'],['energy']
Energy Efficiency,"track being transported. void TrackPosition(Double_t& x, Double_t& y, Double_t& z) const; Return the current position in the master reference frame of the; track being transported. void TrackMomentum(TLorentzVector& momentum) const; Return the direction and the momentum (GeV/c) of the track; currently being transported. void TrackMomentum(Double_t& px, Double_t& py, Double_t& pz, Double_t& etot) const; Return the direction and the momentum (GeV/c) of the track; currently being transported. Double_t TrackStep() const; Return the length in centimeters of the current step (in cm). Double_t TrackLength() const; Return the length of the current track from its origin (in cm). Double_t TrackTime() const; Return the current time of flight of the track being transported. Double_t Edep() const; Return the energy lost in the current step. Int_t TrackPid() const. get methods; tracking particle; static properties. Return the PDG of the particle transported. Double_t TrackCharge() const; Return the charge of the track currently transported. Double_t TrackMass() const; Return the mass of the track currently transported. Double_t Etot() const; Return the total energy of the current track. Bool_t IsNewTrack() const. get methods - track status. Return true when the track performs the first step. Bool_t IsTrackInside() const; Return true if the track is not at the boundary of the current volume. Bool_t IsTrackEntering() const; Return true if this is the first step of the track in the current volume. Bool_t IsTrackExiting() const; Return true if this is the last step of the track in the current volume. Bool_t IsTrackOut() const; Return true if the track is out of the setup. Bool_t IsTrackDisappeared() const; Return true if the current particle has disappeared; either because it decayed or because it underwent; an inelastic collision. Bool_t IsTrackStop() const; Return true if the track energy has fallen below the threshold. Bool_t IsTrackAlive() const; Return true if the current partic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:34595,charge,charge,34595,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,10,['charge'],['charge']
Energy Efficiency,"transforms. orthogonal transforms can be successfully used for the processing of nuclear spectra (not only); they can be used to remove high frequency noise, to increase signal-to-background ratio as well as to enhance low intensity components [1], to carry out e.g. Fourier analysis etc.; we have implemented the function for the calculation of the commonly used orthogonal transforms as well as functions for the filtration and enhancement of experimental data. References:; [1] C.V. Hampton, B. Lian, Wm. C. McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray spectroscopy. NIM A353 (1994) 280-284.; [2] Morhac M., Matouoek V., New adaptive Cosine-Walsh transform and its application to nuclear data compression, IEEE Transactions on Signal Processing 48 (2000) 2693.; [3] Morhac M., Matouoek V., Data compression using new fast adaptive Cosine-Haar transforms, Digital Signal Processing 8 (1998) 63.; [4] Morhac M., Matouoek V.: Multidimensional nuclear data compression using fast adaptive Walsh-Haar transform. Acta Physica Slovaca 51 (2001) 307. Example 1 - script Transform2.c:. Fig. 1 Original two-dimensional noisy spectrum. Fig. 2 Transformed spectrum from Fig. 1 using Cosine transform. Energy of the transformed data is concentrated around the beginning of the coordinate system; Script:; Example to illustrate Transform function (class TSpectrumTransform2). To execute this example, do; root > .x Transform2.C; void Transform2() {; Int_t i, j;; Int_t nbinsx = 256;; Int_t nbinsy = 256;; Int_t xmin = 0;; Int_t xmax = nbinsx;; Int_t ymin = 0;; Int_t ymax = nbinsy;; Double_t ** source = new Double_t *[nbinsx];; Double_t ** dest = new Double_t *[nbinsx];; for (i=0;i<nbinsx;i++); source[i]=newDouble_t[nbinsy];; for (i=0;i<nbinsx;i++); dest[i]=newDouble_t[nbinsy];; TH2F *trans = newTH2F(""trans"",""Background estimation"",nbinsx,xmin,xmax,nbinsy,ymin,ymax);; TFile *f = new TFile(""TSpectrum2.root"");; trans=(TH2F*)f->Get(""back3;1"");; TCanvas *Tr = new TCanvas(""Tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Transform.html:31865,adapt,adaptive,31865,doc/master/classTSpectrum2Transform.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Transform.html,1,['adapt'],['adaptive']
Energy Efficiency,"tream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); voidremoveSelfFromDir(); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidset(Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErrLo, Double_t wgtErrHi); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataHist.html:9311,reduce,reduce,9311,root/html526/RooDataHist.html,https://root.cern,https://root.cern/root/html526/RooDataHist.html,1,['reduce'],['reduce']
Energy Efficiency,"tream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); voidremoveSelfFromDir(); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidset(Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErrLo, Double_t wgtErrHi); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t fl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataHist.html:9686,reduce,reduce,9686,root/html530/RooDataHist.html,https://root.cern,https://root.cern/root/html530/RooDataHist.html,1,['reduce'],['reduce']
Energy Efficiency,"tream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); voidremoveSelfFromDir(); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidset(Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErrLo, Double_t wgtErrHi); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataHist.html:9782,reduce,reduce,9782,root/html532/RooDataHist.html,https://root.cern,https://root.cern/root/html532/RooDataHist.html,4,['reduce'],['reduce']
Energy Efficiency,"tream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); voidremoveSelfFromDir(); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidset(Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErrLo, Double_t wgtErrHi); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataHist.html:9367,reduce,reduce,9367,root/html528/RooDataHist.html,https://root.cern,https://root.cern/root/html528/RooDataHist.html,1,['reduce'],['reduce']
Energy Efficiency,"treamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTGraph::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidTGraph::Zero(Int_t& k, Double_t AZ, Double_t BZ, Double_t E2, Double_t& X, Double_t& Y, Int_t maxiterations). protected:. virtual Double_t**Allocate(Int_t size); Double_t**TGraph::AllocateArrays(Int_t Narrays, Int_t arraySize); virtual voidCopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); virtual Bool_tCopyPoints(Double_t** arrays, Int_t ibegin, Int_t iend, Int_t obegin); Bool_tCtorAllocate(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Double_t**TGraph::ExpandAndCopy(Int_t size, Int_t iend); virtual voidFillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); voidTObject::MakeZombie(); Double_t**TGraph::ShrinkAndCopy(Int_t size, Int_t iend); virtual voidSwapPoints(Int_t pos1, Int_t pos2); static voidTGraph::SwapValues(Double_t* arr, Int_t pos1, Int_t pos2). Data Members; public:. enum TGraph::[unnamed] { kClipFrame; kNotEditable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fEX[fNpoints] array of X errors; Double_t*fEY[fNpoints] array of Y errors; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TList*TGraph::fFunctionsPointer to list of functions (fits and user); TH1F*TGraph::fHistogramPointer to histogram used",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphErrors.html:12564,Allocate,Allocate,12564,root/html532/TGraphErrors.html,https://root.cern,https://root.cern/root/html532/TGraphErrors.html,2,['Allocate'],"['Allocate', 'AllocateArrays']"
Energy Efficiency,"treamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTGraph::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidTGraph::Zero(Int_t& k, Double_t AZ, Double_t BZ, Double_t E2, Double_t& X, Double_t& Y, Int_t maxiterations). protected:. virtual Double_t**Allocate(Int_t size); Double_t**TGraph::AllocateArrays(Int_t Narrays, Int_t arraySize); virtual voidCopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); virtual Bool_tCopyPoints(Double_t** arrays, Int_t ibegin, Int_t iend, Int_t obegin); Bool_tCtorAllocate(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Double_t**TGraph::ExpandAndCopy(Int_t size, Int_t iend); virtual voidFillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); voidTObject::MakeZombie(); Double_t**TGraph::ShrinkAndCopy(Int_t size, Int_t iend); virtual voidSwapPoints(Int_t pos1, Int_t pos2); static voidTGraph::SwapValues(Double_t* arr, Int_t pos1, Int_t pos2). Data Members; public:. enum TGraph::[unnamed] { kClipFrame; kNotEditable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fEXhigh[fNpoints] array of X high errors; Double_t*fEXhighd[fNpoints] array of X high displacements; Double_t*fEXlow[fNpoints] array of X low errors; Double_t*fEXlowd[fNpoints] array of X low displacements; Double_t*fEYhigh[fNpoints] array of Y high errors; Double_t*fEYhighd[fNpoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphBentErrors.html:13006,Allocate,Allocate,13006,root/html532/TGraphBentErrors.html,https://root.cern,https://root.cern/root/html532/TGraphBentErrors.html,2,['Allocate'],"['Allocate', 'AllocateArrays']"
Energy Efficiency,"treamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTGraph::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidTGraph::Zero(Int_t& k, Double_t AZ, Double_t BZ, Double_t E2, Double_t& X, Double_t& Y, Int_t maxiterations). protected:. virtual Double_t**Allocate(Int_t size); Double_t**TGraph::AllocateArrays(Int_t Narrays, Int_t arraySize); virtual voidCopyAndRelease(Double_t** newarrays, Int_t ibegin, Int_t iend, Int_t obegin); virtual Bool_tCopyPoints(Double_t** arrays, Int_t ibegin, Int_t iend, Int_t obegin); Bool_tCtorAllocate(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Double_t**TGraph::ExpandAndCopy(Int_t size, Int_t iend); virtual voidFillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); voidTObject::MakeZombie(); Double_t**TGraph::ShrinkAndCopy(Int_t size, Int_t iend); virtual voidSwapPoints(Int_t pos1, Int_t pos2); static voidTGraph::SwapValues(Double_t* arr, Int_t pos1, Int_t pos2). Data Members; public:. enum TGraph::[unnamed] { kClipFrame; kNotEditable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fEXhigh[fNpoints] array of X high errors; Double_t*fEXlow[fNpoints] array of X low errors; Double_t*fEYhigh[fNpoints] array of Y high errors; Double_t*fEYlow[fNpoints] array of Y low errors; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphAsymmErrors.html:13333,Allocate,Allocate,13333,root/html532/TGraphAsymmErrors.html,https://root.cern,https://root.cern/root/html532/TGraphAsymmErrors.html,2,['Allocate'],"['Allocate', 'AllocateArrays']"
Energy Efficiency,"treamerInfo::GetElementsTObjArray * GetElements() const overrideDefinition TStreamerInfo.h:163; TStreamerInfo::fSizeInt_t fSize!size of the persistent classDefinition TStreamerInfo.h:92; TStreamerInfo::GetTypedValueAuxstatic T GetTypedValueAux(Int_t type, void *ladd, int k, Int_t len)Get the value from inside a collection.Definition TStreamerInfo.cxx:4338; TStreamerInfo::GenerateDeclarationvoid GenerateDeclaration(FILE *fp, FILE *sfp, const TList *subClasses, Bool_t top=kTRUE)Write the Declaration of class.Definition TStreamerInfo.cxx:3668; TStreamerInfo::PrintValueAuxstatic void PrintValueAux(char *ladd, Int_t atype, TStreamerElement *aElement, Int_t aleng, Int_t *count)print value of element in object at pointer, type atype, leng aleng or *count The function may be cal...Definition TStreamerInfo.cxx:5429; TStreamerInfo::GetMethodULongptr_t GetMethod(Int_t id) constDefinition TStreamerInfo.h:177; TStreamerInfo::NewArrayvoid * NewArray(Long_t nElements, void *ary=nullptr) overrideAn array of emulated objects is created at address ary, if ary is null, we allocate memory for the ar...Definition TStreamerInfo.cxx:4918; TStreamerInfo::GetStreamerElementTStreamerElement * GetStreamerElement(const char *datamember, Int_t &offset) const overrideReturn the StreamerElement of ""datamember"" inside our class or any of its base classes.Definition TStreamerInfo.cxx:4212; TStreamerInfo::GetCheckSumUInt_t GetCheckSum() const overrideDefinition TStreamerInfo.h:159; TStreamerInfo::Compilevoid Compile() overrideloop on the TStreamerElement list regroup members with same type Store predigested information into l...Definition TStreamerInfoActions.cxx:2972; TStreamerInfo::WriteBufferClonesInt_t WriteBufferClones(TBuffer &b, TClonesArray *clones, Int_t nc, Int_t first, Int_t eoffset)Write for ClonesArray ('first' is an id between -1 and fNfulldata).Definition TStreamerInfoWriteBuffer.cxx:872; TStreamerInfo::BuildCheckvoid BuildCheck(TFile *file=nullptr, Bool_t load=kTRUE) overrideCheck if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8h_source.html:39048,allocate,allocate,39048,doc/master/TStreamerInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8h_source.html,1,['allocate'],['allocate']
Energy Efficiency,"treamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual const Event * Transform (const Event *const, Int_t cls) const;  apply the principal component analysis ;  ; void WriteTransformationToStream (std::ostream &) const;  write mean values to stream ;  ;  Public Member Functions inherited from TMVA::VariableTransformBase;  VariableTransformBase (DataSetInfo &dsi, Types::EVariableTransform tf, const TString &trfName);  standard constructor ;  ; virtual ~VariableTransformBase (void);  ; virtual void CountVariableTypes (UInt_t &nvars, UInt_t &ntgts, UInt_t &nspcts) const;  count variables, targets and spectators ;  ; virtual Bool_t GetInput (const Event *event, std::vector< Float_t > &input, std::vector< Char_t > &mask, Bool_t backTransform=kFALSE) const;  select the values from the event ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; TString GetShortName () const;  ; virtual std::vector< TString > * GetTransformationStrings (Int_t cls) const;  TODO --> adapt to variable,target,spectator selection default transformation output --> only indicate that transformation occurred. ;  ; Types::EVariableTransform GetVariableTransform () const;  ; Bool_t IsCreated () const;  ; Bool_t IsEnabled () const;  ; Bool_t IsNormalised () const;  ; MsgLogger & Log () const;  ; virtual void PrintTransformation (std::ostream &);  ; virtual void SelectInput (const TString &inputVariables, Bool_t putIntoVariables=kFALSE);  select the variables/targets/spectators which serve as input to the transformation ;  ; void SetEnabled (Bool_t e);  ; void SetNormalise (Bool_t n);  ; virtual void SetOutput (Event *event, std::vector< Float_t > &output, std::vector< Char_t > &mask, const Event *oldEvent=nullptr, Bool_t backTransform=kFALSE) const;  select the values from the event ;  ; void SetOutputDataSetInfo (DataSetInfo *outputDsi);  ; void SetTMVAVersion (TMVAVersion_t v);  ; void SetUseSignalTransform (Bool_t e=kTRUE);  ; const std::vector< TMVA::VariableInfo > &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1VariablePCATransform.html:2790,adapt,adapt,2790,doc/master/classTMVA_1_1VariablePCATransform.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1VariablePCATransform.html,1,['adapt'],['adapt']
Energy Efficiency,"treamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. static FreeHookFun_tfgFreeHookfunction called on free; static void*fgFreeHookDatadata used by this function; static Bool_tfgHasCustomNewDeletetrue if using ROOT's new/delete; static size_tfgMaxBlockSizelargest block allocated; static ReAllocCFun_tfgReAllocCHookcustom ReAlloc with length check; static ReAllocFun_tfgReAllocHookcustom ReAlloc; static const UInt_tkObjectAllocMemValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void EnterStat(size_t size, void* p); Register a memory allocation operation. If desired one can trap an; allocation of a certain size in case one tries to find a memory; leak of that particular size. This function is only called via; the ROOT custom new operators. void RemoveStat(void* p); Register a memory free operation. This function is only called via; the custom ROOT delete operator. void * Alloc(size_t size); Allocate a block of memory, that later can be resized using; TStorage::ReAlloc(). void Dealloc(void* ptr); De-allocate block of memory, that was allocated via TStorage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. Don't use if size is larger; than old size, use ReAlloc(void *, size_t, size_t) instead. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::FilledByObjectAllo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStorage.html:3547,Allocate,Allocate,3547,root/html534/TStorage.html,https://root.cern,https://root.cern/root/html534/TStorage.html,1,['Allocate'],['Allocate']
Energy Efficiency,"tree. But now we need to get a handle on the data it stores, as shown below:; ... TTreeReaderValue<Int_t> eventSize(myReader, ""fEventSize"");. ... Loading TTree's Data; For the analysis example we need to access the events' size, which is accessible through the TTreeReaderValue eventSize. But the TTreeReader first needs to get told about which TTree entry to access. For that call TTreeReader::Next() in a loop. It will return false once it has reached the end of the TTree.; In the same loop, compute the total size of all events (simply add the current event size to the total size); ... // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Get the data from the current TTree entry by getting; // the value from the connected reader (eventSize):; totalSize += *eventSize;; }. Accessing the Analysis Result; At the end of the loop, print the sum of all event sizes. This sum shows you the real power of a TTree: even though you can analyze large amounts of data (our example tree with 22MB is tiny!) ROOT needs just a few MB of your RAM, no matter how many events you analyze. Imagine what it would be like if you had to load all data into memory, e.g. using a simple vector!; ... Int_t sizeInMB = totalSize/1024/1024;; printf(""Total size of all events: %d MB\n"", sizeInMB);; }. Running the Macro; To run this macro, simply type .x AnalyzeTree.C and ROOT will execute it. If it finds an error it might be wise to quit ROOT (.q) and try again!; If, for any reason, you don't manage to get it working, you can download a working macro file here: CountEvents.C; Here again, if you are using ROOT via ssh, you have to download the file with wget from your remote directory:; wget http://root-mirror.github.io/training/intro/CountEvents.C; . ‹ TTree and Its Data; up; Histogramming ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/using-macro-read-ttree.html:4857,power,power,4857,d/using-macro-read-ttree.html,https://root.cern,https://root.cern/d/using-macro-read-ttree.html,1,['power'],['power']
Energy Efficiency,"tree.Definition TTreePerfStats.h:52; TTreePerfStats::Browsevoid Browse(TBrowser *b) overrideBrowse.Definition TTreePerfStats.cxx:208; TTreePerfStats::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideReturn distance to one of the objects in the TTreePerfStats.Definition TTreePerfStats.cxx:277; TTreePerfStats::fRealNormDouble_t fRealNormReal time scale factor for fGraphTime.Definition TTreePerfStats.h:57; TTreePerfStats::GetBasketInfoBasketInfo & GetBasketInfo(TBranch *b, size_t basketNumber)Return the BasketInfo corresponding to the given branch and basket.Definition TTreePerfStats.cxx:372; TTreePerfStats::fBasketsInfostd::vector< std::vector< BasketInfo > > fBasketsInfoDefinition TTreePerfStats.h:77; TTreePerfStats::fUnzipObjSizeLong64_t fUnzipObjSizeUncompressed bytes produced by the decompressor.Definition TTreePerfStats.h:63; TTreePerfStats::fWatchTStopwatch * fWatchTStopwatch pointer.Definition TTreePerfStats.h:72; TTreePerfStats::fTreeTTree * fTree! Pointer to the Tree being monitoredDefinition TTreePerfStats.h:68; TTreePerfStats::fHostInfoTString fHostInfoName of the host system, ROOT version and date.Definition TTreePerfStats.h:66; TTreePerfStats::Printvoid Print(Option_t *option="""") const overridePrint the TTree I/O perf stats.Definition TTreePerfStats.cxx:540; TTreePerfStats::fReadCallsInt_t fReadCallsNumber of read calls.Definition TTreePerfStats.h:53; TTreePerfStats::fBytesReadLong64_t fBytesReadNumber of bytes read.Definition TTreePerfStats.h:55; TTreePerfStats::UpdateBranchIndicesvoid UpdateBranchIndices(TObjArray *branchNames) overrideUpdate the fBranchIndexCache collection to match the current TTree given the ordered list of branch n...Definition TTreePerfStats.cxx:360; TTreePerfStats::GetDuplicateBasketCacheBasketList_t GetDuplicateBasketCache() constReturn the collection of baskets which have been read by the TTreeCache more than once.Definition TTreePerfStats.cxx:424; TTreePerfStats::fCpuTimeDouble_t fCpuTimeCpu time.Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:40409,monitor,monitoredDefinition,40409,doc/master/TTreePerfStats_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html,1,['monitor'],['monitoredDefinition']
Energy Efficiency,"tribute the application to the connected cluster; 707df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); 708~~~; 709 ; 710If an instance of [SparkContext](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.SparkContext.html); 711is not provided, the default behaviour is to create one in the background for you.; 712 ; 713### Connecting to a Dask cluster; 714 ; 715Similarly, you can connect to a Dask cluster by creating your own connection object which internally operates with one; 716of the cluster schedulers supported by Dask (more information in the; 717[Dask distributed docs](http://distributed.dask.org/en/stable/)):; 718 ; 719~~~{.py}; 720import ROOT; 721from dask.distributed import Client; 722 ; 723# Point RDataFrame calls to the Dask specific RDataFrame; 724RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; 725 ; 726# In a Python script the Dask client needs to be initalized in a context; 727# Jupyter notebooks / Python session don't need this; 728if __name__ == ""__main__"":; 729 # With an already setup cluster that exposes a Dask scheduler endpoint; 730 client = Client(""dask_scheduler.domain.com:8786""); 731 ; 732 # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; 733 df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); 734 # Proceed as usual; 735 df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); 736~~~; 737 ; 738If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; 739provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; 740using all cores available.; 741 ; 742### Choosing the number of distributed tasks; 743 ; 744A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; 745tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:42120,schedul,scheduler,42120,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['schedul'],['scheduler']
Energy Efficiency,"tribute the application to the connected cluster; 747df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); 748~~~; 749 ; 750If an instance of [SparkContext](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.SparkContext.html); 751is not provided, the default behaviour is to create one in the background for you.; 752 ; 753### Connecting to a Dask cluster; 754 ; 755Similarly, you can connect to a Dask cluster by creating your own connection object which internally operates with one; 756of the cluster schedulers supported by Dask (more information in the; 757[Dask distributed docs](http://distributed.dask.org/en/stable/)):; 758 ; 759~~~{.py}; 760import ROOT; 761from dask.distributed import Client; 762 ; 763# Point RDataFrame calls to the Dask specific RDataFrame; 764RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; 765 ; 766# In a Python script the Dask client needs to be initalized in a context; 767# Jupyter notebooks / Python session don't need this; 768if __name__ == ""__main__"":; 769 # With an already setup cluster that exposes a Dask scheduler endpoint; 770 client = Client(""dask_scheduler.domain.com:8786""); 771 ; 772 # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; 773 df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); 774 # Proceed as usual; 775 df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); 776~~~; 777 ; 778If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; 779provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; 780using all cores available.; 781 ; 782### Choosing the number of distributed tasks; 783 ; 784A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; 785tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:43760,schedul,scheduler,43760,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['schedul'],['scheduler']
Energy Efficiency,"tries based on range: [begin, end). ;  ; RInterface< RDFDetail::RRange< RDFDetail::RLoopManager >, DS_t > Range (unsigned int end);  Creates a node that filters entries based on range. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > Redefine (std::string_view name, F expression, const ColumnNames_t &columns={});  Overwrite the value and/or type of an existing column. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > Redefine (std::string_view name, std::string_view expression);  Overwrite the value and/or type of an existing column. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > RedefineSlot (std::string_view name, F expression, const ColumnNames_t &columns={});  Overwrite the value and/or type of an existing column. ;  ; RInterface< RDFDetail::RLoopManager, DS_t > RedefineSlotEntry (std::string_view name, F expression, const ColumnNames_t &columns={});  Overwrite the value and/or type of an existing column. ;  ; RResultPtr< T > Reduce (F f, std::string_view columnName, const T &redIdentity);  Execute a user-defined reduce operation on the values of a column. ;  ; RResultPtr< T > Reduce (F f, std::string_view columnName="""");  Execute a user-defined reduce operation on the values of a column. ;  ; RResultPtr< RCutFlowReport > Report ();  Gather filtering statistics. ;  ; RResultPtr< RInterface< RLoopManager > > Snapshot (std::string_view treename, std::string_view filename, const ColumnNames_t &columnList, const RSnapshotOptions &options=RSnapshotOptions());  Save selected columns to disk, in a new TTree treename in file filename. ;  ; RResultPtr< RInterface< RLoopManager > > Snapshot (std::string_view treename, std::string_view filename, const ColumnNames_t &columnList, const RSnapshotOptions &options=RSnapshotOptions());  Save selected columns to disk, in a new TTree treename in file filename. ;  ; RResultPtr< RInterface< RLoopManager > > Snapshot (std::string_view treename, std::string_view filename, std::initializer_list< std::string > columnList, const RSnapsh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:96700,reduce,reduce,96700,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['reduce'],['reduce']
Energy Efficiency,"tring & ; json . ). Change search query and belongs to it json string Returns true if any parameter was really changed. ; Definition at line 2130 of file RGeomData.cxx. ◆ SetTopVisible(). void ROOT::RGeomDescription::SetTopVisible ; (; bool ; on = true). inline . Set draw options as string for JSROOT TGeoPainter. ; Definition at line 332 of file RGeomData.hxx. ◆ SetVisLevel(). void ROOT::RGeomDescription::SetVisLevel ; (; int ; lvl = 3). inline . Set maximal visible level. ; Definition at line 327 of file RGeomData.hxx. Friends And Related Symbol Documentation. ◆ RGeomBrowserIter. friend class RGeomBrowserIter. friend . Definition at line 212 of file RGeomData.hxx. Member Data Documentation. ◆ fActiveItemName. std::string ROOT::RGeomDescription::fActiveItemName. private . ! name of item which should be activated in hierarchy ; Definition at line 262 of file RGeomData.hxx. ◆ fActualLevel. int ROOT::RGeomDescription::fActualLevel {0}. private . ! level can be reduced when selecting nodes ; Definition at line 259 of file RGeomData.hxx. ◆ fCfg. RGeomConfig ROOT::RGeomDescription::fCfg. private . ! configuration parameter editable from GUI ; Definition at line 264 of file RGeomData.hxx. ◆ fClickedStack. std::vector<int> ROOT::RGeomDescription::fClickedStack. private . ! clicked element by stack ; Definition at line 250 of file RGeomData.hxx. ◆ fDesc. std::vector<RGeomNode> ROOT::RGeomDescription::fDesc. private . ! converted description, send to client ; Definition at line 243 of file RGeomData.hxx. ◆ fDrawIdCut. int ROOT::RGeomDescription::fDrawIdCut {0}. private . ! sortid used for selection of most-significant nodes ; Definition at line 258 of file RGeomData.hxx. ◆ fDrawJson. std::string ROOT::RGeomDescription::fDrawJson. private . ! JSON with main nodes drawn by client ; Definition at line 257 of file RGeomData.hxx. ◆ fDrawVolume. TGeoVolume* ROOT::RGeomDescription::fDrawVolume {nullptr}. private . ! select volume independent from TGeoManager ; Definition at line 246",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html:28873,reduce,reduced,28873,doc/v632/classROOT_1_1RGeomDescription.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html,2,['reduce'],['reduced']
Energy Efficiency,"trixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are cre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSparse_double_.html:20281,allocate,allocated,20281,root/html528/TMatrixTSparse_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_double_.html,1,['allocate'],['allocated']
Energy Efficiency,"trongly increases with"" << Endl;; 1736 Log() << ""the dimensionality (number of input variables) of the problem."" << Endl;; 1737 Log() << ""This behavior is due to the non-uniqueness of the solution space.""<< Endl;; 1738 Log() << Endl;; 1739 Log() << gTools().Color(""bold"") << ""--- Performance optimisation:"" << gTools().Color(""reset"") << Endl;; 1740 Log() << Endl;; 1741 Log() << ""If the dimensionality exceeds, say, 4 input variables, it is "" << Endl;; 1742 Log() << ""advisable to scrutinize the separation power of the variables,"" << Endl;; 1743 Log() << ""and to remove the weakest ones. If some among the input variables"" << Endl;; 1744 Log() << ""can be described by a single cut (e.g., because signal tends to be"" << Endl;; 1745 Log() << ""larger than background), this can be indicated to MethodCuts via"" << Endl;; 1746 Log() << ""the \""Fsmart\"" options (see option string). Choosing this option"" << Endl;; 1747 Log() << ""reduces the number of requirements for the variable from 2 (min/max)"" << Endl;; 1748 Log() << ""to a single one (TMVA finds out whether it is to be interpreted as"" << Endl;; 1749 Log() << ""min or max)."" << Endl;; 1750 Log() << Endl;; 1751 Log() << gTools().Color(""bold"") << ""--- Performance tuning via configuration options:"" << gTools().Color(""reset"") << Endl;; 1752 Log() << """" << Endl;; 1753 Log() << bold << ""Monte Carlo sampling:"" << resbold << Endl;; 1754 Log() << """" << Endl;; 1755 Log() << ""Apart form the \""Fsmart\"" option for the variables, the only way"" << Endl;; 1756 Log() << ""to improve the MC sampling is to increase the sampling rate. This"" << Endl;; 1757 Log() << ""is done via the configuration option \""MC_NRandCuts\"". The execution"" << Endl;; 1758 Log() << ""time scales linearly with the sampling rate."" << Endl;; 1759 Log() << """" << Endl;; 1760 Log() << bold << ""Genetic Algorithm:"" << resbold << Endl;; 1761 Log() << """" << Endl;; 1762 Log() << ""The algorithm terminates if no significant fitness increase has"" << Endl;; 1763 Log() << ""been achieved within ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:68675,reduce,reduces,68675,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['reduce'],['reduces']
Energy Efficiency,"tructor Documentation. ◆ ClassificationSettings(). TMVA::DNN::ClassificationSettings::ClassificationSettings ; (; TString ; name, . size_t ; _convergenceSteps = 15, . size_t ; _batchSize = 10, . size_t ; _testRepetitions = 7, . double ; _factorWeightDecay = 1e-5, . EnumRegularization ; _regularization = EnumRegularization::NONE, . size_t ; _scaleToNumEvents = 0, . MinimizerType ; _eMinimizerType = MinimizerType::fSteepest, . double ; _learningRate = 1e-5, . double ; _momentum = 0.3, . int ; _repetitions = 3, . bool ; _useMultithreading = true . ). inline . c'tor ; Definition at line 901 of file NeuralNet.h. ◆ ~ClassificationSettings(). virtual TMVA::DNN::ClassificationSettings::~ClassificationSettings ; (; ). inlinevirtual . d'tor ; Definition at line 924 of file NeuralNet.h. Member Function Documentation. ◆ endTestCycle(). void TMVA::DNN::ClassificationSettings::endTestCycle ; (; ). virtual . action to be done when the training cycle is ended (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 326 of file NeuralNet.cxx. ◆ endTrainCycle(). void TMVA::DNN::ClassificationSettings::endTrainCycle ; (; double ; ). virtual . action to be done when the training cycle is ended (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 296 of file NeuralNet.cxx. ◆ setResultComputation(). void TMVA::DNN::ClassificationSettings::setResultComputation ; (; std::string ; _fileNameNetConfig, . std::string ; _fileNameResult, . std::vector< Pattern > * ; _resultPatternContainer . ). preparation for monitoring output ; Definition at line 520 of file NeuralNet.cxx. ◆ setWeightSums(). void TMVA::DNN::ClassificationSettings::setWeightSums ; (; double ; sumOfSigWeights, . double ; sumOfBkgWeights . ). set the weight sums to be scaled to (preparations for monitoring output) ; Definition at line 512 of file NeuralNet.cxx. ◆ startTestCycle(). void TMVA::DNN::ClassificationSettings::startTestCycle ; (; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html:7470,monitor,monitoring,7470,doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,1,['monitor'],['monitoring']
Energy Efficiency,"true variables can be deleted. ~RooAbsData(); Destructor. void convertToVectorStore(); Convert tree-based storage to vector-based storage. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsData.html:15579,reduce,reduce,15579,root/html532/RooAbsData.html,https://root.cern,https://root.cern/root/html532/RooAbsData.html,2,['reduce'],"['reduce', 'reduced']"
Energy Efficiency,"trum2Transform. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » SPECTRUM; » TSpectrum2Transform. class TSpectrum2Transform: public TObject. THIS CLASS CONTAINS 2-DIMENSIONAL ORTHOGONAL TRANSFORM FUNCTIONS. These functions were written by:; Miroslav Morhac; Institute of Physics; Slovak Academy of Sciences; Dubravska cesta 9, 842 28 BRATISLAVA; SLOVAKIA. email:fyzimiro@savba.sk, fax:+421 7 54772479. The original code in C has been repackaged as a C++ class by R.Brun. The algorithms in this class have been published in the following; references:. [1] C.V. Hampton, B. Lian, Wm. C. McHarris: Fast-Fourier-transform; spectral enhancement techniques for gamma-ray spectroscopy.NIM A353; (1994) 280-284.; [2] Morhac M., Matousek V., New adaptive Cosine-Walsh transform and; its application to nuclear data compression, IEEE Transactions on; Signal Processing 48 (2000) 2693.; [3] Morhac M., Matousek V., Data compression using new fast adaptive; Cosine-Haar transforms, Digital Signal Processing 8 (1998) 63.; [4] Morhac M., Matousek V.: Multidimensional nuclear data compression; using fast adaptive Walsh-Haar transform. Acta Physica Slovaca 51; (2001) 307. Function Members (Methods); public:. virtual~TSpectrum2Transform(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2Transform.html:942,adapt,adaptive,942,root/html602/TSpectrum2Transform.html,https://root.cern,https://root.cern/root/html602/TSpectrum2Transform.html,4,['adapt'],['adaptive']
Energy Efficiency,"ts How many events to generate; 56 /// \param arg1,arg2,arg3,arg4,arg5 Optional command arguments.; 57 RooFit::OwningPtr<RooDataSet> generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg& arg1,; 58 const RooCmdArg& arg2={}, const RooCmdArg& arg3={},; 59 const RooCmdArg& arg4={}, const RooCmdArg& arg5={}) {; 60 return generate(whatVars,RooFit::NumEvents(nEvents),arg1,arg2,arg3,arg4,arg5) ;; 61 }; 62 RooFit::OwningPtr<RooDataSet> generate(const RooArgSet &whatVars,; 63 const RooCmdArg& arg1={},const RooCmdArg& arg2={},; 64 const RooCmdArg& arg3={},const RooCmdArg& arg4={},; 65 const RooCmdArg& arg5={},const RooCmdArg& arg6={}) ;; 66 RooFit::OwningPtr<RooDataSet> generate(const RooArgSet &whatVars, double nEvents = 0, bool verbose=false, bool autoBinned=true,; 67 const char* binnedTag="""", bool expectedData=false, bool extended = false) const;; 68 RooFit::OwningPtr<RooDataSet> generate(const RooArgSet &whatVars, const RooDataSet &prototype, Int_t nEvents= 0,; 69 bool verbose=false, bool randProtoOrder=false, bool resampleProto=false) const;; 70 ; 71 ; 72 class GenSpec {; 73 public:; 74 virtual ~GenSpec() ;; 75 GenSpec() = default;; 76 ; 77 private:; 78 GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, bool extended,; 79 bool randProto, bool resampleProto, TString dsetName, bool init=false) ;; 80 GenSpec(const GenSpec& other) ;; 81 ; 82 friend class RooAbsPdf ;; 83 std::unique_ptr<RooAbsGenContext> _genContext;; 84 RooArgSet _whatVars ;; 85 RooDataSet* _protoData = nullptr;; 86 Int_t _nGen = 0;; 87 bool _extended = false;; 88 bool _randProto = false;; 89 bool _resampleProto = false;; 90 TString _dsetName ;; 91 bool _init = false;; 92 ; 93 ClassDef(GenSpec,0) // Generation specification; 94 } ;; 95 ; 96 ///Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification.; 97 GenSpec* prepareMultiGen(const RooArgSet &whatVars,; 98 const RooCmdArg& arg1={},const RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8h_source.html:4040,efficient,efficient,4040,doc/master/RooAbsPdf_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8h_source.html,1,['efficient'],['efficient']
Energy Efficiency,"ts an interpolator class from number of data points and with Interpolation::Type type.; The data can be set later on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The defult interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The defult interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id: Interpolator.h 24403 2008-06-20 08:31:10Z moneta $ » Last generated: 2009-12-07 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Interpolator.html:2868,efficient,efficient,2868,root/html526/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Interpolator.html,1,['efficient'],['efficient']
Energy Efficiency,"ts an interpolator class from number of data points and with Interpolation::Type type.; The data can be set later on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The defult interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The defult interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id: Interpolator.h 24403 2008-06-20 08:31:10Z moneta $ » Last generated: 2010-09-23 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__Interpolator.html:2868,efficient,efficient,2868,root/html528/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__Interpolator.html,1,['efficient'],['efficient']
Energy Efficiency,"ts an interpolator class from number of data points and with Interpolation::Type type.; The data can be set later on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The defult interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The defult interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id: Interpolator.h 24403 2008-06-20 08:31:10Z moneta $ » Last generated: 2011-07-04 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__Interpolator.html:2870,efficient,efficient,2870,root/html530/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__Interpolator.html,1,['efficient'],['efficient']
Energy Efficiency,"ts an interpolator class from number of data points and with Interpolation::Type type.; The data can be set later on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The defult interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The defult interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id: Interpolator.h 24403 2008-06-20 08:31:10Z moneta $ » Last generated: 2011-11-03 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__Interpolator.html:2870,efficient,efficient,2870,root/html532/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__Interpolator.html,2,['efficient'],['efficient']
Energy Efficiency,"ts in the plot. However, when plotting only a sub-range, when e.g. a signal region has to be blinded, one has to exclude the blinded region from the computation of the normalisation.; In this tutorial, we show how to explicitly choose the normalisation when plotting using NormRange(). ; import ROOT; ; # Make a fit model; x = ROOT.RooRealVar(""x"", ""The observable"", 1, 30); tau = ROOT.RooRealVar(""tau"", ""The exponent"", -0.1337, -10.0, -0.1); expo = ROOT.RooExponential(""expo"", ""A falling exponential function"", x, tau); ; # Define the sidebands (e.g. background regions); x.setRange(""full"", 1, 30); x.setRange(""left"", 1, 10); x.setRange(""right"", 20, 30); ; # Generate toy data, and cut out the blinded region.; data = expo.generate(x, 1000); blindedData = data.reduce(CutRange=""left,right""); ; # Kick tau a bit, and run an unbinned fit where the blinded data are missing.; # ----------------------------------------------------------------------------------------------------------; # The fit should be done only in the unblinded regions, otherwise it would try; # to make the model adapt to the empty bins in the blinded region.; tau.setVal(-2.0); expo.fitTo(blindedData, Range=""left,right"", PrintLevel=-1); ; # Clear the ""fitrange"" attribute of the PDF. Otherwise, the fitrange would be; # automatically taken as the NormRange() for plotting. We want to avoid this,; # because the point of this tutorial is to show what can go wrong when the; # NormRange() is not specified.; expo.removeStringAttribute(""fitrange""); ; ; # Here we will plot the results; canvas = ROOT.TCanvas(""canvas"", ""canvas"", 800, 600); canvas.Divide(2, 1); ; ; # Wrong:; # ----------------------------------------------------------------------------------------------------------; # Plotting each slice on its own normalises the PDF over its plotting range. For the full curve, that means; # that the blinded region where data is missing is included in the normalisation calculation. The PDF therefore; # comes out too low, and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8py.html:1587,adapt,adapt,1587,doc/master/rf212__plottingInRanges__blinding_8py.html,https://root.cern,https://root.cern/doc/master/rf212__plottingInRanges__blinding_8py.html,1,['adapt'],['adapt']
Energy Efficiency,"ts last element. Int_t GetN() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how many cells; can be available via GetP() method.; GetN() == 0 then GetP() must return 0 as well. Float_t * GetP() const; GetP() returns the pointer to the float point array; of points if available; The number of the available celss can be found via; GetN() method.; GetN() > 0 shows how many cells. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const; GetXYZ(Float_t *xyz,Int_t idx,Int_t num=1) fills the buffer supplied; by the calling code with the points information. Input parameters:. Float_t *xyz - an external user supplied floating point array.; Int_t num - the total number of the points to be copied; the dimension of that array the size of the; array is num*sizeof(Float_t) at least; Int_t idx - The index of the first copy to be taken. Return: The pointer to the buffer array supplied. virtual ~TPoints3DABC(); {;}. Int_t DistancetoPrimitive(Int_t px, Int_t py). Int_t GetLastPosition() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how many cells; can be available via GetP() method.; GetN() == 0 then GetP() must return 0 as well. Float_t GetX(Int_t idx) const. Float_t GetY(Int_t idx) const. Float_t GetZ(Int_t idx) const. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const. Option_t * GetOption() const. void PaintPoints(Int_t n, Float_t* p, Option_t* option = """"). Int_t SetLastPosition(Int_t idx). void SetOption(Option_t* option = """"). Int_t SetPoint(Int_t point, Float_t x, Float_t y, Float_t z). Int_t SetPoints(Int_t n, Float_t* p = 0, Option_t* option = """"). Int_t Size() const. » Author: Valery Fine(fine@mail.cern.ch) 24/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-03-14 16:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPoints3DABC.html:8489,allocate,allocated,8489,root/html534/TPoints3DABC.html,https://root.cern,https://root.cern/root/html534/TPoints3DABC.html,2,['allocate'],['allocated']
Energy Efficiency,"ts the convolution theorem. f(x) (*) g(x) --F--> f(k_i) * g(k_i). and calculate the convolution by calculate a Real->Complex FFT of both input p.d.fs; multiplying the complex coefficients and performing the reverse Complex->Real FFT; to get the result in the input space. This class using the ROOT FFT Interface to; the (free) FFTW3 package (www.fftw.org) and requires that your ROOT installation is; compiled with the --enable-fftw3 option (instructions for Linux follow). Note that the performance in terms of speed and stability of RooFFTConvPdf is; vastly superior to that of RooNumConvPdf. An important feature of FFT convolutions is that the observable is treated in a; cyclical way. This is correct & desirable behavior for cyclical observables such as angles,; but it may not be for other observables. The effect that is observed is that if; p.d.f is zero at xMin and non-zero at xMax some spillover occurs and; a rising tail may appear at xMin. This effect can be reduced or eliminated by; introducing a buffer zone in the FFT calculation. If this feature is activated; input the sampling array for the FFT calculation is extended in both directions; and filled with repetitions of the lowest bin value and highest bin value; respectively. The buffer bins are stripped again when the FFT output values; are transferred to the p.d.f cache. The default buffer size is 10% of the; observable domain size and can be changed with setBufferFraction() member function. This class is a caching p.d.f inheriting from RooAbsCachedPdf. If this p.d.f; is evaluated for a particular value of x, the FFT calculate the values for the; p.d.f at all points in observables space for the given choice of parameters,; which are stored in the cache. Subsequent evaluations of RooFFTConvPdf with; identical parameters will retrieve results from the cache. If one or more; of the parameters change, the cache will be updated. The sampling density of the cache is controlled by the binning of the; the convolution ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:1424,reduce,reduced,1424,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,11,['reduce'],['reduced']
Energy Efficiency,"ts the histogram to be filled.Definition TGraph2D.cxx:1568; TGraph2D::SetMaximumvoid SetMaximum(Double_t maximum=-1111)Set maximum.Definition TGraph2D.cxx:1619; TGraph2D::GetEXlowvirtual Double_t * GetEXlow() constDefinition TGraph2D.h:129; TGraph2D::Addvirtual void Add(TF2 *f, Double_t c1=1)Performs the operation: z = z + c1*f(x,y,z) Errors are not recalculated.Definition TGraph2D.cxx:642; TGraph2D::GetYmaxDouble_t GetYmax() constReturns the Y maximum.Definition TGraph2D.cxx:1175; TGraph2D::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideComputes distance from point px,py to a graph.Definition TGraph2D.cxx:730; TGraph2D::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default when an 2D graph is created, it is added to the list of 2D graph objects in the current di...Definition TGraph2D.cxx:1544; TGraph2D::fDirectoryTDirectory * fDirectory!Pointer to directory holding this 2D graphDefinition TGraph2D.h:60; TGraph2D::Clearvoid Clear(Option_t *option="""") overrideFree all memory allocated by this object.Definition TGraph2D.cxx:681; TGraph2D::Scalevirtual void Scale(Double_t c1=1., Option_t *option=""z"")Multiply the values of a TGraph2D by a constant c1.Definition TGraph2D.cxx:1506; TGraph2D::GetEXvirtual Double_t * GetEX() constDefinition TGraph2D.h:126; TGraph2D::DirectoryAutoAddvirtual void DirectoryAutoAdd(TDirectory *)Perform the automatic addition of the graph to the given directory.Definition TGraph2D.cxx:715; TGraph2D::CreateInterpolatorvoid CreateInterpolator(Bool_t oldInterp)Add a TGraphDelaunay in the list of the fHistogram's functions.Definition TGraph2D.cxx:968; TGraph2D::GetNpyInt_t GetNpy() constDefinition TGraph2D.h:110; TGraph2D::GetDirectoryTDirectory * GetDirectory() constDefinition TGraph2D.h:108; TGraph2D::fNpyInt_t fNpyNumber of bins along Y in fHistogram.Definition TGraph2D.h:47; TGraph2D::AddPointvirtual void AddPoint(Double_t x, Double_t y, Double_t z)Append a new point to the graph.Definition TGraph2D.h:93; TGr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2D_8h_source.html:18431,allocate,allocated,18431,doc/master/TGraph2D_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraph2D_8h_source.html,1,['allocate'],['allocated']
Energy Efficiency,"ts { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TList*fActivelist of sockets to monitor; TList*fDeActivelist of (temporary) disabled sockets; Bool_tfInterruptflags an interrupt to Select; Bool_tfMainLooptrue if monitoring sockets within the main event loop; TSocket*fReadysocket which is ready to be read or written. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMonitor(Bool_t mainloop = kTRUE); Create a monitor object. If mainloop is true the monitoring will be; done in the main event loop. TMonitor(const TMonitor& m); Copy constructor. ~TMonitor(); Cleanup the monitor object. Does not delete sockets being monitored. void Add(TSocket* sock, Int_t interest = kRead); Add socket to the monitor's active list. If interest=kRead then we; want to monitor the socket for read readiness, if interest=kWrite; then we monitor the socket for write readiness, if interest=kRead|kWrite; then we monitor both read and write readiness. void SetInterest(TSocket* sock, Int_t interest = kRead); Set interest mask for socket sock to interest. If the socket is not; in the active list move it or add it there.; If interest=kRead then we want to monitor the socket for read readiness,; if interest=kWrite then we monitor the socket for write readiness,; if interest=kRead|kWrite then we monitor both read and write readiness. void Remove(TSocket* sock); Remove a socket from the monitor. void RemoveAll(); Remove all sockets from the monitor. void Activate(TSocket* sock",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMonitor.html:10124,monitor,monitoring,10124,root/html528/TMonitor.html,https://root.cern,https://root.cern/root/html528/TMonitor.html,6,['monitor'],['monitoring']
Energy Efficiency,"ts""); dh.plotOn(yframe) # plot projection of 2D binned data on y; ; # Examine the statistics of a binned dataset; print("">> number of bins in dh : "", dh.numEntries()); print("">> sum of weights in dh : "", dh.sum(False)); # accounts for bin volume; print("">> integral over histogram: "", dh.sum(True)); ; # Locate a bin from a set of coordinates and retrieve its properties; x.setVal(0.3); y.setVal(20.5); print("">> retrieving the properties of the bin enclosing coordinate (x,y) = (0.3,20.5) bin center:""); # load bin center coordinates in internal buffer; dh.get({x, y}).Print(""v""); print("" weight = "", dh.weight()) # return weight of last loaded coordinates; ; # Reduce the 2-dimensional binned dataset to a 1-dimensional binned dataset; #; # All reduce() methods are interfaced in RooAbsData. All reduction techniques; # demonstrated on unbinned datasets can be applied to binned datasets as; # well.; print("">> Creating 1-dimensional projection on y of dh for bins with x>0""); dh2 = dh.reduce({y}, ""x>0""); dh2.Print(""v""); ; # Add dh2 to yframe and redraw; dh2.plotOn(yframe, LineColor=""r"", MarkerColor=""r""); ; # Saving and loading from file; # -------------------------------------------------------; ; # Datasets can be persisted with ROOT I/O; print(""\n >> Persisting d via ROOT I/O""); f = ROOT.TFile(""rf402_datahandling.root"", ""RECREATE""); d.Write(); f.ls(); ; # To read back in future session:; # > ROOT.TFile f(""rf402_datahandling.root""); # > d = (ROOT.RooDataSet*) f.FindObject(""d""); ; c = ROOT.TCanvas(""rf402_datahandling"", ""rf402_datahandling"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); yframe.GetYaxis().SetTitleOffset(1.4); yframe.Draw(); ; c.SaveAs(""rf402_datahandling.png""); typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf402__datahandling_8py.html:4666,reduce,reduce,4666,doc/master/rf402__datahandling_8py.html,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8py.html,1,['reduce'],['reduce']
Energy Efficiency,"ts(). TMap * TDataSetManager::GetSubDataSets ; (; const char * ; ds, . const char * ; exclude . ). virtual . Partition dataset 'ds' accordingly to the servers. ; The returned TMap contains: <server> --> <subdataset> (TFileCollection) where <subdataset> is the subset of 'ds' on <server> The partitioning is done using all the URLs in the TFileInfo's, so the resulting datasets are not mutually exclusive. The string 'exclude' contains a comma-separated list of servers to exclude from the map. ; Definition at line 1006 of file TDataSetManager.cxx. ◆ GetUserUsedMap(). virtual TMap * TDataSetManager::GetUserUsedMap ; (; ). inlineprotectedvirtual . Definition at line 71 of file TDataSetManager.h. ◆ IsA(). TClass * TDataSetManager::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TDataSetManagerFile.; Definition at line 158 of file TDataSetManager.h. ◆ MonitorUsedSpace(). void TDataSetManager::MonitorUsedSpace ; (; TVirtualMonitoringWriter * ; monitoring). virtual . Log info to the monitoring server. ; Definition at line 673 of file TDataSetManager.cxx. ◆ NotifyUpdate(). Int_t TDataSetManager::NotifyUpdate ; (; const char * ; group = 0, . const char * ; user = 0, . const char * ; dspath = 0, . Long_t ; mtime = 0, . const char * ; checksum = 0 . ). virtual . Save into the <datasetdir>/dataset.list file the name of the last updated or created or modified dataset Returns 0 on success, -1 on error. ; Reimplemented in TDataSetManagerFile.; Definition at line 773 of file TDataSetManager.cxx. ◆ operator=(). TDataSetManager & TDataSetManager::operator= ; (; const TDataSetManager & ; ). private . ◆ ParseDataSetSrvMaps(). TList * TDataSetManager::ParseDataSetSrvMaps ; (; const TString & ; srvmaps). static . Create a server mapping list from the content of 'srvmaps' Return the list (owned by the caller) or 0 if no valid info could be found) ; Definition at line 1867 of file TDataSetManager.cxx. ◆ ParseIni",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManager.html:26860,monitor,monitoring,26860,doc/master/classTDataSetManager.html,https://root.cern,https://root.cern/doc/master/classTDataSetManager.html,1,['monitor'],['monitoring']
Energy Efficiency,"ts. One is for a histogram which is not drawn from an ntuple. The other one is available for a histogram which is drawn from an ntuple. In this case the rebin algorithm can create a rebinned histogram from the original data i.e. the ntuple. To see te differences do for example: TFile f(""hsimple.root""); hpxpy->Draw(""Lego2""); // non ntuple histogram ntuple->Draw(""px:py"","""",""Lego2""); // ntuple histogram Non ntuple histogram: 'Rebin': with the Sliders (one for the x, one for the y axis) the number of bins (shown in the field below the Slider) can be changed to any number which divides the number of bins of the original histogram. Pushing 'Apply' will delete the origin histogram and replace it by the rebinned one on the screen. Pushing 'Ignore' the origin histogram will be restored Histogram drawn from an ntuple: 'Rebin' with the sliders the number of bins can be enlarged by a factor of 2,3,4,5 (moving to the right) or reduced by a factor of 1/2, 1/3, 1/4, 1/5 'BinOffset': with the BinOffset slider the origin of the histogram can be changed within one binwidth Using this slider the effect of binning the data into bins can be made visible => statistical fluctuations 'Axis Range': with the DoubleSlider it is possible to zoom into the specified axis range. It is also possible to set the upper and lower limit in fields below the slider 'Delayed drawing': all the Binning sliders can be set to delay draw mode. Then the changes on the histogram are only updated, when the Slider is released. This should be activated if the redrawing of the histogram is too time consuming. // ; Definition at line 34 of file TH2Editor.h. Public Member Functions;  TH2Editor (const TGWindow *p=nullptr, Int_t width=140, Int_t height=30, UInt_t options=kChildFrame, Pixel_t back=GetDefaultFrameBackground());  Constructor of histogram attribute GUI. ;  ;  ~TH2Editor () override;  Destructor. ;  ; Bool_t AcceptModel (TObject *model) override;  Check if object is able to configure with this editor. ;  ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Editor.html:3228,reduce,reduced,3228,doc/master/classTH2Editor.html,https://root.cern,https://root.cern/doc/master/classTH2Editor.html,1,['reduce'],['reduced']
Energy Efficiency,"ts.Definition TGraph.cxx:2583; TGraph::GetEYhighdvirtual Double_t * GetEYhighd() constDefinition TGraph.h:150; TGraph::SetOptionvirtual void SetOption(Option_t *option="" "")Definition TGraph.h:190; TGraph::GetXaxisTAxis * GetXaxis() constGet x axis of the graph.Definition TGraph.cxx:1566; TGraph::GetEditableBool_t GetEditable() constReturn kTRUE if kNotEditable bit is not set, kFALSE otherwise.Definition TGraph.cxx:2292; TGraph::GetEXhighvirtual Double_t * GetEXhigh() constDefinition TGraph.h:143; TGraph::GetCorrelationFactorvirtual Double_t GetCorrelationFactor() constReturn graph correlation factor.Definition TGraph.cxx:1296; TGraph::FillZerovirtual void FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE)Set zero values for point arrays in the range [begin, end) Should be redefined in descendant classes.Definition TGraph.cxx:1102; TGraph::GetEYhighvirtual Double_t * GetEYhigh() constDefinition TGraph.h:145; TGraph::ExpandAndCopyDouble_t ** ExpandAndCopy(Int_t size, Int_t iend)if size > fMaxSize allocate new arrays of 2*size points and copy iend first points.Definition TGraph.cxx:1089; TGraph::Expandvirtual void Expand(Int_t newsize)If array sizes <= newsize, expand storage to 2*newsize.Definition TGraph.cxx:1065; TGraph::GetMeanvirtual Double_t GetMean(Int_t axis=1) constReturn mean value of X (axis=1) or Y (axis=2)Definition TGraph.cxx:1324; TGraph::fXDouble_t * fX[fNpoints] array of X pointsDefinition TGraph.h:47; TGraph::PaintStatsvirtual void PaintStats(TF1 *fit)Draw the stats.Definition TGraph.cxx:2004; TGraph::GetYaxisTAxis * GetYaxis() constGet y axis of the graph.Definition TGraph.cxx:1575; TGraph::FindObjectTObject * FindObject(const char *name) const overrideSearch object named name in the list of functions.Definition TGraph.cxx:1111; TGraph::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TGraph.cxx:2431; TGraph::GetHistogramvirtual TH1F * GetHistogram() constReturns a pointer to the histogram used to draw th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8h_source.html:25884,allocate,allocate,25884,doc/master/TGraph_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8h_source.html,1,['allocate'],['allocate']
Energy Efficiency,"ts::IntervalCalculator&); voidSaveBeltToFile(bool flag = true); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData& data); voidSetLeftSideTailFraction(Double_t leftSideFraction = 0.); virtual voidSetModel(const RooStats::ModelConfig& model); virtual voidSetNuisanceParameters(const RooArgSet&); voidSetParameterPointsToTest(RooAbsData& pointsToTest); virtual voidSetParameters(const RooArgSet&); virtual voidSetPdf(RooAbsPdf&); virtual voidSetTestSize(Double_t size); voidSetTestStatSampler(RooStats::TestStatSampler& sampler); virtual voidShowMembers(TMemberInspector& insp); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUseAdaptiveSampling(bool flag = true). Data Members; private:. boolfAdaptiveSamplingcontrols use of adaptive sampling algorithm; Double_tfAdditionalNToysFactorgive user ability to ask for more toys; RooStats::ConfidenceBelt*fConfBelt; boolfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData&fDatadata set ; Double_tfLeftSideFraction; RooStats::ModelConfig&fModel; RooAbsData*fPointsToTest; boolfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::TestStatSampler*fTestStatSampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; NeymanConstruction(RooAbsData& data, RooStats::ModelConfig& model); default constructor; fWS = new RooWorkspace();; fOwnsWorkspace = true;; fDataName = """";; fPdfName = """";. ~NeymanConstruction(); default constructor; if(fOwnsWorkspace && fWS) delete fWS;; if(fConfBelt) delete fConfBelt;. PointSetInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::SetInterval. NeymanConstruction(RooAbsData& data, RooStats::ModelConfig& model); NeymanConstruction();. void SetTestStatSampler(RooStats::TestStatSampler& sampler); in addition to interface we a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__NeymanConstruction.html:3840,adapt,adaptive,3840,root/html528/RooStats__NeymanConstruction.html,https://root.cern,https://root.cern/root/html528/RooStats__NeymanConstruction.html,4,['adapt'],['adaptive']
Energy Efficiency,"ts::RemoveFirstParameter_t<typename TTraits::CallableTraits<F>::arg_types>;; 1644 constexpr auto nColumns = ColTypes_t::list_size;; 1645 ; 1646 const auto validColumnNames = GetValidatedColumnNames(nColumns, columns);; 1647 CheckAndFillDSColumns(validColumnNames, ColTypes_t());; 1648 ; 1649 using Helper_t = RDFInternal::ForeachSlotHelper<F>;; 1650 using Action_t = RDFInternal::RAction<Helper_t, Proxied>;; 1651 ; 1652 auto action = std::make_unique<Action_t>(Helper_t(std::move(f)), validColumnNames, fProxiedPtr, fColRegister);; 1653 ; 1654 fLoopManager->Run();; 1655 }; 1656 ; 1657 // clang-format off; 1658 ////////////////////////////////////////////////////////////////////////////; 1659 /// \brief Execute a user-defined reduce operation on the values of a column.; 1660 /// \tparam F The type of the reduce callable. Automatically deduced.; 1661 /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; 1662 /// \param[in] f A callable with signature `T(T,T)`; 1663 /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; 1664 /// \return the reduced quantity wrapped in a ROOT::RDF:RResultPtr.; 1665 ///; 1666 /// A reduction takes two values of a column and merges them into one (e.g.; 1667 /// by summing them, taking the maximum, etc). This action performs the; 1668 /// specified reduction operation on all processed column values, returning; 1669 /// a single value of the same type. The callable f must satisfy the general; 1670 /// requirements of a *processing function* besides having signature `T(T,T)`; 1671 /// where `T` is the type of column columnName.; 1672 ///; 1673 /// The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a; 1674 /// default-constructed T object. This is commonly expected to be the neutral/identity element for the specific; 1675 /// reduction operation `f` (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:93073,reduce,reduced,93073,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['reduce'],['reduced']
Energy Efficiency,"tte);; 2675 delete[] palette;; 2676 return gHighestColorIndex + 1 - nLines;; 2677}; 2678 ; 2679////////////////////////////////////////////////////////////////////////////////; 2680/// Static function creating a color table with several connected linear gradients.; 2681///; 2682/// - Number: The number of end point colors that will form the gradients.; 2683/// Must be at least 2.; 2684/// - Stops: Where in the whole table the end point colors should lie.; 2685/// Each entry must be on [0, 1], each entry must be greater than; 2686/// the previous entry.; 2687/// - Red, Green, Blue: The end point color values.; 2688/// Each entry must be on [0, 1]; 2689/// - NColors: Total number of colors in the table. Must be at least 1.; 2690/// - alpha: the opacity factor, between 0 and 1. Default is no transparency (1).; 2691/// - setPalette: activate the newly created palette (true by default). If false,; 2692/// the caller is in charge of calling TColor::SetPalette using the; 2693/// return value of the function (first palette color index) and; 2694/// reconstructing the Int_t palette[NColors+1] array.; 2695///; 2696/// Returns a positive value (the index of the first color of the palette) on; 2697/// success and -1 on error.; 2698///; 2699/// The table is constructed by tracing lines between the given points in; 2700/// RGB space. Each color value may have a value between 0 and 1. The; 2701/// difference between consecutive ""Stops"" values gives the fraction of; 2702/// space in the whole table that should be used for the interval between; 2703/// the corresponding color values.; 2704///; 2705/// Normally the first element of Stops should be 0 and the last should be 1.; 2706/// If this is not true, fewer than NColors will be used in proportion with; 2707/// the total interval between the first and last elements of Stops.; 2708///; 2709/// This definition is similar to the povray-definition of gradient; 2710/// color tables.; 2711///; 2712/// For instance:; 2713/// ~~~ {.cpp}; 27",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:97955,charge,charge,97955,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['charge'],['charge']
Energy Efficiency,"tte.Set(0);; 1144 fgPalette=0;; 1145 }; 1146}; 1147 ; 1148////////////////////////////////////////////////////////////////////////////////; 1149/// Color copy constructor.; 1150 ; 1151TColor::TColor(const TColor &color) : TNamed(color); 1152{; 1153 color.TColor::Copy(*this);; 1154}; 1155 ; 1156TColor &TColor::operator=(const TColor &color); 1157{; 1158 if (this != &color); 1159 color.TColor::Copy(*this);; 1160 return *this;; 1161}; 1162 ; 1163////////////////////////////////////////////////////////////////////////////////; 1164/// Initialize colors used by the TCanvas based graphics (via TColor objects).; 1165/// This method should be called before the ApplicationImp is created (which; 1166/// initializes the GUI colors).; 1167 ; 1168void TColor::InitializeColors(); 1169{; 1170 static Bool_t initDone = kFALSE;; 1171 ; 1172 if (initDone) return;; 1173 initDone = kTRUE;; 1174 ; 1175 if (gROOT->GetListOfColors()->First() == nullptr) {; 1176 ; 1177 new TColor(kWhite,1,1,1,""background"");; 1178 new TColor(kBlack,0,0,0,""black"");; 1179 new TColor(2,1,0,0,""red"");; 1180 new TColor(3,0,1,0,""green"");; 1181 new TColor(4,0,0,1,""blue"");; 1182 new TColor(5,1,1,0,""yellow"");; 1183 new TColor(6,1,0,1,""magenta"");; 1184 new TColor(7,0,1,1,""cyan"");; 1185 new TColor(10,0.999,0.999,0.999,""white"");; 1186 new TColor(11,0.754,0.715,0.676,""editcol"");; 1187 ; 1188 // The color white above is defined as being nearly white.; 1189 // Sets the associated dark color also to white.; 1190 TColor::GetColorDark(10);; 1191 TColor *c110 = gROOT->GetColor(110);; 1192 if (c110) c110->SetRGB(0.999,0.999,.999);; 1193 ; 1194 // Initialize Custom colors; 1195 new TColor(20,0.8,0.78,0.67);; 1196 new TColor(31,0.54,0.66,0.63);; 1197 new TColor(41,0.83,0.81,0.53);; 1198 new TColor(30,0.52,0.76,0.64);; 1199 new TColor(32,0.51,0.62,0.55);; 1200 new TColor(24,0.70,0.65,0.59);; 1201 new TColor(21,0.8,0.78,0.67);; 1202 new TColor(47,0.67,0.56,0.58);; 1203 new TColor(35,0.46,0.54,0.57);; 1204 new TColor(33,0.68,0.74,0.7",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:41629,green,green,41629,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"ttings(). TMVA::DNN::Settings::Settings ; (; TString ; name, . size_t ; _convergenceSteps = 15, . size_t ; _batchSize = 10, . size_t ; _testRepetitions = 7, . double ; _factorWeightDecay = 1e-5, . TMVA::DNN::EnumRegularization ; _regularization = TMVA::DNN::EnumRegularization::NONE, . MinimizerType ; _eMinimizerType = MinimizerType::fSteepest, . double ; _learningRate = 1e-5, . double ; _momentum = 0.3, . int ; _repetitions = 3, . bool ; _multithreading = true . ). c'tor ; Definition at line 232 of file NeuralNet.cxx. ◆ ~Settings(). TMVA::DNN::Settings::~Settings ; (; ). virtual . d'tor ; Definition at line 261 of file NeuralNet.cxx. Member Function Documentation. ◆ addPoint() [1/2]. void TMVA::DNN::Settings::addPoint ; (; std::string ; histoName, . double ; x . ). inline . for monitoring ; Definition at line 821 of file NeuralNet.h. ◆ addPoint() [2/2]. void TMVA::DNN::Settings::addPoint ; (; std::string ; histoName, . double ; x, . double ; y . ). inline . for monitoring ; Definition at line 822 of file NeuralNet.h. ◆ batchSize(). size_t TMVA::DNN::Settings::batchSize ; (; ); const. inline . mini-batch size ; Definition at line 767 of file NeuralNet.h. ◆ clear(). void TMVA::DNN::Settings::clear ; (; std::string ; histoName). inline . for monitoring ; Definition at line 824 of file NeuralNet.h. ◆ computeResult(). virtual void TMVA::DNN::Settings::computeResult ; (; const Net & ; , . std::vector< double > & ;  . ). inlinevirtual . callback for monitoring and logging ; Definition at line 809 of file NeuralNet.h. ◆ convergenceCount(). size_t TMVA::DNN::Settings::convergenceCount ; (; ); const. inline . returns the current convergence count ; Definition at line 827 of file NeuralNet.h. ◆ convergenceSteps(). size_t TMVA::DNN::Settings::convergenceSteps ; (; ); const. inline . how many steps until training is deemed to have converged ; Definition at line 766 of file NeuralNet.h. ◆ create() [1/2]. void TMVA::DNN::Settings::create ; (; std::string ; histoName, . int ; bins, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:5832,monitor,monitoring,5832,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['monitor'],['monitoring']
Energy Efficiency,"ttpServer::fEngines. protected . ! engines which runs http server ; Definition at line 34 of file THttpServer.h. ◆ fJSROOT. TString THttpServer::fJSROOT. protected . ! location of external JSROOT files ; Definition at line 46 of file THttpServer.h. ◆ fJSROOTSYS. TString THttpServer::fJSROOTSYS. protected . ! location of local JSROOT files ; Definition at line 44 of file THttpServer.h. ◆ fLocations. std::map<std::string, std::string> THttpServer::fLocations. protected . ! list of local directories, which could be accessed via server ; Definition at line 48 of file THttpServer.h. ◆ fMainThrdId. Long_t THttpServer::fMainThrdId {0}. protected . ! id of the thread for processing requests ; Definition at line 38 of file THttpServer.h. ◆ fMutex. std::mutex THttpServer::fMutex. protected . ! mutex to protect list with arguments ; Definition at line 57 of file THttpServer.h. ◆ fOwnThread. Bool_t THttpServer::fOwnThread {kFALSE}. protected . ! true when specialized thread allocated for processing requests ; Definition at line 40 of file THttpServer.h. ◆ fProcessingThrdId. Long_t THttpServer::fProcessingThrdId {0}. protected . ! id of the thread where events are recently processing ; Definition at line 39 of file THttpServer.h. ◆ fSniffer. std::unique_ptr<TRootSniffer> THttpServer::fSniffer. protected . ! sniffer provides access to ROOT objects hierarchy ; Definition at line 36 of file THttpServer.h. ◆ fTerminated. Bool_t THttpServer::fTerminated {kFALSE}. protected . ! termination flag, disables all requests processing ; Definition at line 37 of file THttpServer.h. ◆ fThrd. std::thread THttpServer::fThrd. protected . ! own thread ; Definition at line 41 of file THttpServer.h. ◆ fTimer. std::unique_ptr<THttpTimer> THttpServer::fTimer. protected . ! timer used to access main thread ; Definition at line 35 of file THttpServer.h. ◆ fTopName. TString THttpServer::fTopName {""ROOT""}. protected . ! name of top folder, default - ""ROOT"" ; Definition at line 45 of file THttpServer.h. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:41411,allocate,allocated,41411,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['allocate'],['allocated']
Energy Efficiency,"tual Bool_tTestFunction(Double_t squareResidual, Double_t dResidur). Data Members; public:. enum EMDFPolyType { kMonomials; kChebyshev; kLegendre; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfBinVarXNumber of bin in independent variables; Int_tfBinVarYNumber of bin in dependent variables; Double_tfChi2Chi square of fit; TVectorDfCoefficientsVector of the final coefficients; TVectorDfCoefficientsRMSVector of RMS of coefficients; Double_tfCorrelationCoeffMulti Correlation coefficient; TMatrixDfCorrelationMatrixCorrelation matrix; Double_tfErrorError from parameterization; TVirtualFitter*fFitter! Fit object (MINUIT); Int_t*fFunctionCodes[fMaxFunctions] acceptance code; TMatrixDfFunctionsFunctions evaluated over sample; Byte_tfHistogramMaskBit pattern of hisograms used; TList*fHistogramsList of histograms; Bool_tfIsUserFunctionFlag for user defined function; Bool_tfIsVerbose; Double_tfMaxAngleMax angle for acepting new function; Int_tfMaxFuncNVfMaxFunctions*fNVariables; Int_tfMaxFunctionsmax number of functions; Int_t*fMaxPowers[fNVariables] maximum powers; Int_t*fMaxPowersFinal[fNVariables] maximum powers from fit;; Double_tfMaxQuantityMax value of dependent quantity; Double_tfMaxResidualMax redsidual value; Int_tfMaxResidualRowRow giving max residual; Int_tfMaxStudymax functions to study; Int_tfMaxTermsMax terms expected in final expr.; TVectorDfMaxVariablesmax value of independent variables; Double_tfMeanQuantityMean of dependent quantity; TVectorDfMeanVariablesmean value of independent variables; Double_tfMinAngleMin angle for acepting new function; Double_tfMinQuantityMin value of dependent quantity; Double_tfMinRelativeErrorMin relative error accepted; Double_tfMinResidualMin redsidual value; Int_tfMinResidualRowRow giving min residual; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:22488,power,powers,22488,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,10,['power'],['powers']
Energy Efficiency,"tual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTMVA::MethodBase::IsSignalLike(); virtual Bool_tTMVA::MethodBase::IsSignalLike(Double_t mvaVal); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidMakeClass(const TString& classFileName = TString("""")) const; voidTObject::MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodTMlpANNMethodTMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodTMlpANNMethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodTMlpANN.html:8573,Monitor,MonitorBoost,8573,root/html532/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodTMlpANN.html,1,['Monitor'],['MonitorBoost']
Energy Efficiency,"tual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTMVA::MethodBase::IsSignalLike(); virtual Bool_tTMVA::MethodBase::IsSignalLike(Double_t mvaVal); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTMVA::MethodBase::MakeClass(const TString& classFileName = TString("""")) const; voidTObject::MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodFisherMethodFisher(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodFisherMethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodFisher.html:10549,Monitor,MonitorBoost,10549,root/html532/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodFisher.html,1,['Monitor'],['MonitorBoost']
Energy Efficiency,"tual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); voidremoveSelfFromDir(); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidset(Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErrLo, Double_t wgtErrHi); voidTObject::SetBit(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataHist.html:9143,reduce,reduce,9143,root/html526/RooDataHist.html,https://root.cern,https://root.cern/root/html526/RooDataHist.html,1,['reduce'],['reduce']
Energy Efficiency,"tual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); voidremoveSelfFromDir(); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidset(Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataHist.html:9518,reduce,reduce,9518,root/html530/RooDataHist.html,https://root.cern,https://root.cern/root/html530/RooDataHist.html,1,['reduce'],['reduce']
Energy Efficiency,"tual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); voidremoveSelfFromDir(); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; RooDataHist(); RooDataHist(const RooDataHist& other, const char* newname = 0); RooDataHist(const char* name, const char* title, const RooArgSet& vars, const char* binningName = 0); RooDataHist(const char* name, const char* title, const RooArgSet& vars, const RooAbsData& data, Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDataHist.html:8607,reduce,reduce,8607,root/html602/RooDataHist.html,https://root.cern,https://root.cern/root/html602/RooDataHist.html,4,['reduce'],['reduce']
Energy Efficiency,"tual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); voidremoveSelfFromDir(); virtual voidreset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidset(Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataHist.html:9614,reduce,reduce,9614,root/html532/RooDataHist.html,https://root.cern,https://root.cern/root/html532/RooDataHist.html,4,['reduce'],['reduce']
Energy Efficiency,"tual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); voidremoveSelfFromDir(); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidset(Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Double_t wgtErr = -1); voidset(const RooArgSet& row, Double_t weight, Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataHist.html:9199,reduce,reduce,9199,root/html528/RooDataHist.html,https://root.cern,https://root.cern/root/html528/RooDataHist.html,1,['reduce'],['reduce']
Energy Efficiency,"tual void PrintCollectionHeader (Option_t *option) const;  Print the collection header. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <THashList.h>. Inheritance diagram for THashList:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ THashList() [1/3]. THashList::THashList ; (; const THashList & ; ). privatedelete . ◆ THashList() [2/3]. THashList::THashList ; (; Int_t ; capacity = TCollection::kInitHashTableCapacity, . Int_t ; rehash = 0 . ). Create a THashList object. ; Capacity is the initial hashtable capacity (i.e. number of slots), by default kInitHashTableCapacity = 17, and rehash is the value at which a rehash will be triggered. I.e. when the average size of the linked lists at a slot becomes longer than rehash then the hashtable will be resized and refilled to reduce the collision rate to about 1. The higher the collision rate, i.e. the longer the linked lists, the longer lookup will take. If rehash=0 the table will NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!! If the name of an object in the HashList is modified, The hashlist must be Rehashed ; Definition at line 43 of file THashList.cxx. ◆ THashList() [3/3]. THashList::THashList ; (; TObject * ; parent, . Int_t ; capacity = TCollection::kInitHashTableCapacity, . Int_t ; rehash = 0 . ). For backward compatibility only. Use other ctor. ; Definition at line 51 of file THashList.cxx. ◆ ~THashList(). THashList::~THashList ; (; ). virtual . Delete a hashlist. ; Objects are not deleted unless the THashList is the owner (set via SetOwner()). ; Definition at line 60 of file THashList.cxx. Member Function Documentation. ◆ AddAfter() [1/2]. void THashList::AddAfter ; (; const TObject * ; after, . TObject * ; obj . ). over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:22853,reduce,reduce,22853,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['reduce'],['reduce']
Energy Efficiency,"tualCollectionProxy* Generate() const; Virtual copy constructor. TEmulatedCollectionProxy(const TEmulatedCollectionProxy& copy); Copy constructor. TEmulatedCollectionProxy(const char* cl_name, Bool_t silent); Initializing constructor. virtual ~TEmulatedCollectionProxy(); Standard destructor. void* New() const; Virtual constructor. { return new Cont_t; }. void* New(void* memory) const; Virtual in-place constructor. { return new(memory) Cont_t; }. void* NewArray(Int_t nElements) const; Virtual array constructor. { return new Cont_t[nElements]; }. void* NewArray(Int_t nElements, void* memory) const; Virtual in-place constructor. { return new(memory) Cont_t[nElements]; }. void Destructor(void* p, Bool_t dtorOnly = kFALSE) const; Virtual destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; Virtual array destructor. UInt_t Sizeof() const; TVirtualCollectionProxy overload: Return the sizeof the collection object. { return sizeof(Cont_t); }. void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. void Resize(UInt_t n, Bool_t force_delete); Resize the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete); Block allocation of containees. void Commit(void* env); Block commit of containees. void ReadBuffer(TBuffer& buff, void* pObj); Read portion of the streamer. void ReadBuffer(TBuffer& buff, void* pObj, const TClass* onfile). void Streamer(TBuffer& refBuffer); Streamer for I/O handling. void Streamer(TBuffer& buff, void* pObj, int siz); Streamer I/O overload. Bool_t IsValid() const; Check validity of the proxy itself. » Author: Markus Frank 28/10/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-09-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEmulatedCollectionProxy.html:8993,Allocate,Allocate,8993,root/html534/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TEmulatedCollectionProxy.html,1,['Allocate'],['Allocate']
Energy Efficiency,"turn current value, normalized by integrating over the observables in nset. ;  ; virtual void initGenerator (Int_t code);  Interface for one-time initialization to setup the generator for the specified code. ;  ; virtual bool isDirectGenSafe (const RooAbsArg &arg) const;  Check if given observable can be safely generated using the pdfs internal generator mechanism (if that existsP). ;  ; bool mustBeExtended () const;  If true PDF must provide extended likelihood term. ;  ; const char * normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:15990,efficient,efficient,15990,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,1,['efficient'],['efficient']
Energy Efficiency,"turs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructor. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y ). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__BinData.html:7688,allocate,allocated,7688,root/html526/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__BinData.html,1,['allocate'],['allocated']
Energy Efficiency,"turs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructor. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__BinData.html:7800,allocate,allocated,7800,root/html528/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__BinData.html,2,['allocate'],['allocated']
Energy Efficiency,"tyle format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; ptTPaveText * ptDefinition entrylist_figure1.C:7; lineTLine * lineDefinition entrylistblock_figure1.C:235; yDouble_t y[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; f1TF1 * f1Definition legend1.C:11; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ASinDouble_t ASin(Double_t)Returns the principal value of the arc sine of x, expressed in radians.Definition TMath.h:624; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; ahDefinition civetweb.c:8348; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4. mathminuitsrcTMinuit.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:43 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:277890,power,power,277890,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['power'],['power']
Energy Efficiency,"type 1), and store the; 18872 * return value */; 18873 tls.user_ptr = ctx->callbacks.init_thread(ctx, 1);; 18874 } else {; 18875 /* No callback: set user pointer to NULL */; 18876 tls.user_ptr = NULL;; 18877 }; 18878 ; 18879 /* Connection structure has been pre-allocated */; 18880 thread_index = (int)(conn - ctx->worker_connections);; 18881 if ((thread_index < 0); 18882 || ((unsigned)thread_index >= (unsigned)ctx->cfg_worker_threads)) {; 18883 mg_cry_ctx_internal(ctx,; 18884 ""Internal error: Invalid worker index %i"",; 18885 thread_index);; 18886 return;; 18887 }; 18888 ; 18889 /* Request buffers are not pre-allocated. They are private to the; 18890 * request and do not contain any state information that might be; 18891 * of interest to anyone observing a server status. */; 18892 conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);; 18893 if (conn->buf == NULL) {; 18894 mg_cry_ctx_internal(; 18895 ctx,; 18896 ""Out of memory: Cannot allocate buffer for worker %i"",; 18897 thread_index);; 18898 return;; 18899 }; 18900 conn->buf_size = (int)ctx->max_request_size;; 18901 ; 18902 conn->dom_ctx = &(ctx->dd); /* Use default domain and default host */; 18903 ; 18904 conn->tls_user_ptr = tls.user_ptr; /* store ptr for quick access */; 18905 ; 18906 conn->request_info.user_data = ctx->user_data;; 18907 /* Allocate a mutex for this connection to allow communication both; 18908 * within the request handler and from elsewhere in the application; 18909 */; 18910 if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {; 18911 mg_free(conn->buf);; 18912 mg_cry_ctx_internal(ctx, ""%s"", ""Cannot create mutex"");; 18913 return;; 18914 }; 18915 ; 18916#if defined(USE_SERVER_STATS); 18917 conn->conn_state = 1; /* not consumed */; 18918#endif; 18919 ; 18920 /* Call consume_socket() even when ctx->stop_flag > 0, to let it; 18921 * signal sq_empty condvar to wake up the master waiting in; 18922 * produce_socket() */; 18923 while (consume_socket(ctx, &conn->client, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:561921,allocate,allocate,561921,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['allocate'],['allocate']
Energy Efficiency,"type 1), and store the; 18873 * return value */; 18874 tls.user_ptr = ctx->callbacks.init_thread(ctx, 1);; 18875 } else {; 18876 /* No callback: set user pointer to NULL */; 18877 tls.user_ptr = NULL;; 18878 }; 18879 ; 18880 /* Connection structure has been pre-allocated */; 18881 thread_index = (int)(conn - ctx->worker_connections);; 18882 if ((thread_index < 0); 18883 || ((unsigned)thread_index >= (unsigned)ctx->cfg_worker_threads)) {; 18884 mg_cry_ctx_internal(ctx,; 18885 ""Internal error: Invalid worker index %i"",; 18886 thread_index);; 18887 return;; 18888 }; 18889 ; 18890 /* Request buffers are not pre-allocated. They are private to the; 18891 * request and do not contain any state information that might be; 18892 * of interest to anyone observing a server status. */; 18893 conn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->phys_ctx);; 18894 if (conn->buf == NULL) {; 18895 mg_cry_ctx_internal(; 18896 ctx,; 18897 ""Out of memory: Cannot allocate buffer for worker %i"",; 18898 thread_index);; 18899 return;; 18900 }; 18901 conn->buf_size = (int)ctx->max_request_size;; 18902 ; 18903 conn->dom_ctx = &(ctx->dd); /* Use default domain and default host */; 18904 ; 18905 conn->tls_user_ptr = tls.user_ptr; /* store ptr for quick access */; 18906 ; 18907 conn->request_info.user_data = ctx->user_data;; 18908 /* Allocate a mutex for this connection to allow communication both; 18909 * within the request handler and from elsewhere in the application; 18910 */; 18911 if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {; 18912 mg_free(conn->buf);; 18913 mg_cry_ctx_internal(ctx, ""%s"", ""Cannot create mutex"");; 18914 return;; 18915 }; 18916 ; 18917#if defined(USE_SERVER_STATS); 18918 conn->conn_state = 1; /* not consumed */; 18919#endif; 18920 ; 18921 /* Call consume_socket() even when ctx->stop_flag > 0, to let it; 18922 * signal sq_empty condvar to wake up the master waiting in; 18923 * produce_socket() */; 18924 while (consume_socket(ctx, &conn->client, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:561954,allocate,allocate,561954,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['allocate'],['allocate']
Energy Efficiency,"ual . Open connection to display server (if such a thing exist on the current platform). ; On X11 this method returns on success the X display socket descriptor (> 0), 0 in case of batch mode and < 0 in case of failure (cannot connect to display dpyName). It also initializes the TGX11 class via Init(). Called from TGClient ctor. ; Reimplemented from TVirtualX.; Definition at line 809 of file GX11Gui.cxx. ◆ OpenDisplay() [2/2]. Int_t TGX11::OpenDisplay ; (; void * ; display). Open the display. Return -1 if the opening fails, 0 when ok. ; Definition at line 1091 of file TGX11.cxx. ◆ OpenPixmap(). Int_t TGX11::OpenPixmap ; (; UInt_t ; w, . UInt_t ; h . ). overridevirtual . Open a new pixmap. ; Parameters. [in]w,h: Width and height of the pixmap. . Reimplemented from TVirtualX.; Definition at line 1243 of file TGX11.cxx. ◆ ParseColor(). Bool_t TGX11::ParseColor ; (; Colormap_t ; cmap, . const char * ; cname, . ColorStruct_t & ; color . ). overridevirtual . Parse string cname containing color name, like ""green"" or ""#00FF00"". ; It returns a filled in ColorStruct_t. Returns kFALSE in case parsing failed, kTRUE in case of success. On success, the ColorStruct_t fRed, fGreen and fBlue fields are all filled in and the mask is set for all three colors, but fPixel is not set. ; Reimplemented from TVirtualX.; Definition at line 1331 of file GX11Gui.cxx. ◆ PointInRegion(). Bool_t TGX11::PointInRegion ; (; Int_t ; x, . Int_t ; y, . Region_t ; reg . ). overridevirtual . Returns true if the point x,y is in the region. ; Reimplemented from TVirtualX.; Definition at line 2569 of file GX11Gui.cxx. ◆ PolygonRegion(). Region_t TGX11::PolygonRegion ; (; Point_t * ; points, . Int_t ; np, . Bool_t ; winding . ). overridevirtual . Create region for the polygon defined by the points array. ; If winding is true use WindingRule else EvenOddRule as fill rule. ; Reimplemented from TVirtualX.; Definition at line 2517 of file GX11Gui.cxx. ◆ PutImage() [1/2]. void TGX11::PutImage ; (; Drawable_t ; id,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:95850,green,green,95850,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,1,['green'],['green']
Energy Efficiency,"ual . Point this branch at an object. ; For a sub-branch, addr is a pointer to the branch object.; For a top-level branch the meaning of addr is as follows:; If addr is zero, then we allocate a branch object internally and the branch is the owner of the allocated object, not the caller. However the caller may obtain a pointer to the branch object with GetObject(). The pointer is reset to zero (nullptr) when the relevant branch object is destroyed.; Example: branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work.; EventDefinition collection_proxies.C:172; If addr is not zero, but the pointer addr points at is zero, then we allocate a branch object and set the passed pointer to point at the allocated object. The caller owns the allocated object and is responsible for deleting it when it is no longer needed.; Example: Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;; If addr is not zero and the pointer addr points at is also not zero, then the caller has allocated a branch object and is asking us to use it. The caller owns it and must delete it when it is no longer needed.; Example: Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;; These rules affect users of TTree::Branch(), TTree::SetBranchAddress(), and TChain::SetBranchAddress() as well because those routines call this one.; An example of a tree with branches with objects allocated and owned by us: TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1->Clone(0);; for (Int_t i = 0; i < 10; ++i) {; t1->GetEntry(i);; t2->Fill();; }; t2->Write(); delete f2;; f2 = 0;; delete f1;; f1 = 0;; f#define f(i)Definition RSha256.hxx:104; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNamed::CloneTObject * Clone(const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:67257,allocate,allocated,67257,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['allocate'],['allocated']
Energy Efficiency,"ual voidShowMembers(TMemberInspector& insp) const; Int_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TEveChunkManager(); TEveChunkManager(Int_t atom_size, Int_t chunk_size); Int_tVecSize() const. protected:. voidReleaseChunks(). private:. TEveChunkManager&operator=(const TEveChunkManager&); TEveChunkManager(const TEveChunkManager&). Data Members; protected:. Int_tfCapacityAvailable capacity within the chunks; vector<TArrayC*>fChunksMemory blocks; Int_tfNNumber of atoms in a chunk; Int_tfSSize of atom; Int_tfSizeSize of container, number of atoms; Int_tfVecSizeNumber of allocated chunks. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ReleaseChunks(); Release all memory chunks. TEveChunkManager(); Default constructor.; Call reset for initialization. TEveChunkManager(Int_t atom_size, Int_t chunk_size); Constructor. ~TEveChunkManager(); Destructor. void Reset(Int_t atom_size, Int_t chunk_size); Empty the container and reset it with given atom and chunk sizes. void Refit(); Refit the container so that all current data fits into a single; chunk. Char_t* NewChunk(); Allocate a new memory chunk and register it. Char_t* NewAtom(). TEveChunkManager(const TEveChunkManager& ). TEveChunkManager& operator=(const TEveChunkManager& ). Int_t S() const; { return fS; }. Int_t N() const; { return fN; }. Int_t Size() const; { return fSize; }. Int_t VecSize() const; { return fVecSize; }. Int_t Capacity() const; { return fCapacity; }. Char_t* Atom(Int_t idx) const; { return fChunks[idx/fN]->fArray + idx%fN*fS; }. Char_t* Chunk(Int_t chk) const; { return fChunks[chk]->fArray; }. Int_t NAtoms(Int_t chk) const; { return (chk < fVecSize-1) ? fN : (fSize-1)%fN + 1; }. » Last changed: root/eve:$Id$ » Last generated: 2015-06-02 15:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEveChunkManager.html:2178,Allocate,Allocate,2178,root/html604/TEveChunkManager.html,https://root.cern,https://root.cern/root/html604/TEveChunkManager.html,1,['Allocate'],['Allocate']
Energy Efficiency,"ual voidShowMembers(TMemberInspector& insp) const; Int_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TEveChunkManager(); TEveChunkManager(Int_t atom_size, Int_t chunk_size); Int_tVecSize() const. protected:. voidReleaseChunks(). private:. TEveChunkManager&operator=(const TEveChunkManager&); TEveChunkManager(const TEveChunkManager&). Data Members; protected:. Int_tfCapacityAvailable capacity within the chunks; vector<TArrayC*>fChunksMemory blocks; Int_tfNNumber of atoms in a chunk; Int_tfSSize of atom; Int_tfSizeSize of container, number of atoms; Int_tfVecSizeNumber of allocated chunks. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ReleaseChunks(); Release all memory chunks. TEveChunkManager(); Default constructor.; Call reset for initialization. TEveChunkManager(Int_t atom_size, Int_t chunk_size); Constructor. ~TEveChunkManager(); Destructor. void Reset(Int_t atom_size, Int_t chunk_size); Empty the container and reset it with given atom and chunk sizes. void Refit(); Refit the container so that all current data fits into a single; chunk. Char_t* NewChunk(); Allocate a new memory chunk and register it. Char_t* NewAtom(). TEveChunkManager(const TEveChunkManager& ). TEveChunkManager& operator=(const TEveChunkManager& ). Int_t S() const; { return fS; }. Int_t N() const; { return fN; }. Int_t Size() const; { return fSize; }. Int_t VecSize() const; { return fVecSize; }. Int_t Capacity() const; { return fCapacity; }. Char_t* Atom(Int_t idx) const; { return fChunks[idx/fN]->fArray + idx%fN*fS; }. Char_t* Chunk(Int_t chk) const; { return fChunks[chk]->fArray; }. Int_t NAtoms(Int_t chk) const; { return (chk < fVecSize-1) ? fN : (fSize-1)%fN + 1; }. » Last changed: root/eve:$Id$ » Last generated: 2015-06-30 14:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveChunkManager.html:2178,Allocate,Allocate,2178,root/html602/TEveChunkManager.html,https://root.cern,https://root.cern/root/html602/TEveChunkManager.html,1,['Allocate'],['Allocate']
Energy Efficiency,"ual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights from output stream. void WriteMonitoringHistosToFile( void ); write method specific monitoring histograms to target file. void MakeClass(const TString& classFileName = TString("""")) const; make ROOT-independent C++ class for classifier response. const Ranking* CreateRanking(); create ranking. void PrintHelpMessage() const; print help message. Bool_t MonitorBoost(TMVA::MethodBoost* boost); perfrom extra actions during the boosting at different stages. void Init(). void DeclareOptions(). void ProcessOptions(). Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets). void MakeClassSpecific(ostream& , const TString& ) const; make ROOT-independent C++ class for classifier response (classifier-specific implementation). void GetHelpMessage() const; get specific help message from classifer. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: IMethod.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__IMethod.html:2273,Monitor,MonitorBoost,2273,root/html532/TMVA__IMethod.html,https://root.cern,https://root.cern/root/html532/TMVA__IMethod.html,1,['Monitor'],['MonitorBoost']
Energy Efficiency,"uality; 256 */; 257 bool operator==(const LorentzVector & rhs) const {; 258 return fCoordinates==rhs.fCoordinates;; 259 }; 260 bool operator!= (const LorentzVector & rhs) const {; 261 return !(operator==(rhs));; 262 }; 263 ; 264 // ------ Individual element access, in various coordinate systems ------; 265 ; 266 /**; 267 dimension; 268 */; 269 unsigned int Dimension() const; 270 {; 271 return fDimension;; 272 };; 273 ; 274 // individual coordinate accessors in various coordinate systems; 275 ; 276 /**; 277 spatial X component; 278 */; 279 Scalar Px() const { return fCoordinates.Px(); }; 280 Scalar X() const { return fCoordinates.Px(); }; 281 /**; 282 spatial Y component; 283 */; 284 Scalar Py() const { return fCoordinates.Py(); }; 285 Scalar Y() const { return fCoordinates.Py(); }; 286 /**; 287 spatial Z component; 288 */; 289 Scalar Pz() const { return fCoordinates.Pz(); }; 290 Scalar Z() const { return fCoordinates.Pz(); }; 291 /**; 292 return 4-th component (time, or energy for a 4-momentum vector); 293 */; 294 Scalar E() const { return fCoordinates.E(); }; 295 Scalar T() const { return fCoordinates.E(); }; 296 /**; 297 return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; 298 (we use -,-,-,+ metric); 299 */; 300 Scalar M2() const { return fCoordinates.M2(); }; 301 /**; 302 return magnitude (mass) using the (-,-,-,+) metric.; 303 If M2 is negative (space-like vector) a GenVector_exception; 304 is suggested and if continuing, - sqrt( -M2) is returned; 305 */; 306 Scalar M() const { return fCoordinates.M();}; 307 /**; 308 return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ); 309 */; 310 Scalar R() const { return fCoordinates.R(); }; 311 Scalar P() const { return fCoordinates.R(); }; 312 /**; 313 return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ); 314 */; 315 Scalar P2() const { return P() * P(); }; 316 /**; 317 return the square of the transverse spatial component ( X**2 + Y**2 ); 318 */; 319 Scalar Perp2( ) const { return fC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:9644,energy,energy,9644,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['energy'],['energy']
Energy Efficiency,"uantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t Odd (Long_t a);  Returns true if a is odd. ;  ; Bool_t Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t Pi ();  \( \pi\) ;  ; constexpr Double_t PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t QeUncertainty ();  Elementary charge uncertainty. ;  ; void Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t R ();  Universal gas constant ( \( Na K \)) in \( J K^{-1} mol^{-1} \) ;  ; constexpr Double_t RadToDeg ();  Conversion from radian to degree: \( \frac{180}{\pi} \). ;  ; Double_t Range (Double_t lb, Double_t ub, Double_t x);  Returns x if lb < x < up, lb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:17318,power,power,17318,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['power'],['power']
Energy Efficiency,"uantity of interest, which depends smoothly; on the observable quantities ; , which we'll denote by. . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow). where ; are independent; variables, is the known, quantity dependent at ; ,; and is the square error in , the class; TMultiDimFit; will; try to find the parameterization. (1). such that. (2). is minimal. Here ; are monomials, or Chebyshev or Legendre; polynomials, labelled ; , in each variable; , ; . So what TMultiDimFit does, is to determine the number of; terms , and then terms (or functions) , and the ; coefficients , so that is minimal; (TMultiDimFit::FindParameterization). Of course it's more than a little unlikely that will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when. Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class. Limiting the Number of Terms. As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5]. There are still a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:3245,power,powers,3245,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,4,['power'],['powers']
Energy Efficiency,"uation in addition to NDim() and Clone(). @ingroup GenFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientOneDim(); doubleDerivative(double x) const; doubleDerivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDimIGradientOneDim(); ROOT::Math::IGradientOneDimIGradientOneDim(const ROOT::Math::IGradientOneDim&); ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is oft",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IGradientOneDim.html:1858,efficient,efficient,1858,root/html602/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IGradientOneDim.html,4,['efficient'],['efficient']
Energy Efficiency,"ubject to the constraints 2 <= r <= 5. [1] J. Humlicek, JQSRT, 21, 437 (1982).; [2] R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its; Derivatives"" JQSRT 62 (1999), pp 29-48.; http://www-atm.physics.ox.ac.uk/user/wells/voigt.html. Bool_t RootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Calculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where; a == coef[3], b == coef[2], c == coef[1], d == coef[0]; coef[3] must be different from 0; If the boolean returned by the method is false:; ==> there are 3 real roots a,b,c; If the boolean returned by the method is true:; ==> there is one real root a and 2 complex conjugates roots (b+i*c,b-i*c); Author: Francois-Xavier Gentit. void Quantiles(Int_t n, Int_t nprob, Double_t* x, Double_t* quantiles, Double_t* prob, Bool_t isSorted = kTRUE, Int_t* index = 0, Int_t type = 7); Computes sample quantiles, corresponding to the given probabilities; Parameters:; x -the data sample; n - its size; quantiles - computed quantiles are returned in there; prob - probabilities where to compute quantiles; nprob - size of prob array; isSorted - is the input array x sorted?; NOTE, that when the input is not sorted, an array of integers of size n needs; to be allocated. It can be passed by the user in parameter index,; or, if not passed, it will be allocated inside the function. type - method to compute (from 1 to 9). Following types are provided:; Discontinuous:; type=1 - inverse of the empirical distribution function; type=2 - like type 1, but with averaging at discontinuities; type=3 - SAS definition: nearest even order statistic; Piecwise linear continuous:; In this case, sample quantiles can be obtained by linear interpolation; between the k-th order statistic and p(k).; type=4 - linear interpolation of empirical cdf, p(k)=k/n;; type=5 - a very popular definition, p(k) = (k-0.5)/n;; type=6 - used by Minitab and SPSS, p(k) = k/(n+1);; type=7 - used by S-Plus and R, p(k) = (k-1)/(n-1);; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:22405,allocate,allocated,22405,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,6,['allocate'],['allocated']
Energy Efficiency,"uble compiling their programs using actual compilers. It implies that you intend to keep the (at best) insane class hierarchy TF1 <- TF2 <- TF3 and so on. This example shows some of the major design flaws in ROOT -- a 2-dimensional function IS a 1-dimensional function? There is no abstract base class? No templates? It implies that you plan to keep the pointless T in front of all the names of ROOT, even though you will have access to namespaces (finally) and thus can move past the 1970's C practice of avoiding name collisions by a sort of weird Hungarian notation. It implies that you plan to maintain the outdated interfaces which make no use of templates. Templates are one of the most powerful features of C++, are more relevant to performance critical tasks than inheritance, and help ensure the type-safety of code (thereby ensuring the accuracy of data by helping to prevent accidental narrowing etc). It implies that you intend to continue to encourage the use of bare new and delete operators, instead of relying on the more efficient, reliable, and safe method of using RAII. Why? This begs the obvious question: why bother migrating at all? You wish to migrate to the modern and superior C++11 in order to not take advantage of its features? Why not just simply maintain ROOT5 and CINT, and just refuse to upgrade? ROOT is not a particularly good framework that is written in a language that isn't quite C++. If you are going to break away and make/use/write cling, then fix the poor design decisions: cling will probably break compatibility anyways despite your best efforts, so you might as well take the time and effort to refactor and clean up the code base. A simple example, taken from this website: """""" TFFTComplex One of the interface classes to the FFTW package, can be used directly or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes complex input/output discrete Fourier transforms (DFT) in one or more dimensions. For the detailed inform",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:10085,efficient,efficient,10085,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['efficient'],['efficient']
Energy Efficiency,"uble& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDimIGradientOneDim(); ROOT::Math::IGradientOneDimIGradientOneDim(const ROOT::Math::IGradientOneDim&); ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IGradientOneDim.html:2277,efficient,efficient,2277,root/html602/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IGradientOneDim.html,2,['efficient'],['efficient']
Energy Efficiency,"uble& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDimIGradientOneDim(); ROOT::Math::IGradientOneDimIGradientOneDim(const ROOT::Math::IGradientOneDim&); ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IGradientOneDim.html:2277,efficient,efficient,2277,root/html604/ROOT__Math__IGradientOneDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IGradientOneDim.html,2,['efficient'],['efficient']
Energy Efficiency,"uble32_t> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}. Scalar R() const; { return fCoordinates.R(); }. Scalar P() const. return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ). { return fCoordinates.R(); }. Scalar P2() const. return the square of the transverse spatial component ( X**2 + Y**2 ). { return P() * P(); }. Scalar Perp2() const; { return fCoordinates.Perp2();}. Scalar Pt() const. return the transverse spatial component sqrt ( X**2 + Y**2 ). {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html:13228,energy,energy,13228,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,7,['energy'],['energy']
Energy Efficiency,"uble32_t> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}. Scalar R() const; { return fCoordinates.R(); }. Scalar P() const. return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ). { return fCoordinates.R(); }. Scalar P2() const. return the square of the transverse spatial component ( X**2 + Y**2 ). { return P() * P(); }. Scalar Perp2() const; { return fCoordinates.Perp2();}. Scalar Pt() const. return the transverse spatial component sqrt ( X**2 + Y**2 ). {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html:13228,energy,energy,13228,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,7,['energy'],['energy']
Energy Efficiency,"uble_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t TMath::Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t TMath::Pi ();  \( \pi\) ;  ; constexpr Double_t TMath::PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t TMath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t TMath::Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t TMath::QeUncertainty ();  Elementary charge uncertainty. ;  ; void TMath::Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t TMath::QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t TMath::R ();  Universal gas constant ( \( Na K \)) in \( J K^{-1} mol^{-1} \) ;  ; constexpr Double_t TMath::RadToDeg ();  Conversion from radian to degree: \( \frac{180}{\pi} \). ;  ; constexpr Double_t TMath:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h.html:15547,power,power,15547,doc/master/TMath_8h.html,https://root.cern,https://root.cern/doc/master/TMath_8h.html,1,['power'],['power']
Energy Efficiency,"uble_t* err = 0, Double_t* errUpper = 0); return boosted MVA response. Double_t GetBoostROCIntegral(Bool_t , TMVA::Types::ETreeType , Bool_t CalcOverlapIntergral = kFALSE); Calculate the ROC integral of a single classifier or even the; whole boosted classifier. The tree type (training or testing; sample) is specified by 'eTT'. If tree type kTraining is set, the original training sample is; used to compute the ROC integral (original weights). - singleMethod - if kTRUE, return ROC integral of single (last; trained) classifier; if kFALSE, return ROC; integral of full classifier. - eTT - tree type (Types::kTraining / Types::kTesting). - CalcOverlapIntergral - if kTRUE, the overlap integral of the; signal/background MVA distributions; is calculated and stored in; 'fOverlap_integral'. void CalcMVAValues(); Calculate MVA values of current method fMethods.back() on; training sample. void SetBoostedMethodName(TString methodName); { fBoostedMethodName = methodName; }. Int_t GetBoostNum(); { return fBoostNum; }. TH1* GetMonitoringHist(Int_t histInd); gives the monitoring historgram from the vector according to index of the; histrogram added in the MonitorBoost function. { return (*fMonitorHist)[fDefaultHistNum+histInd]; }. void AddMonitoringHist(TH1* hist); { return fMonitorHist->push_back(hist); }. Types::EBoostStage GetBoostStage(); { return fBoostStage; }. void ClearAll(); clean up. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; print fit results. MethodBoost* SetStage(TMVA::Types::EBoostStage stage); { fBoostStage = stage; return this; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen, Jan Therhaag, Eckhard von Toerne » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id: MethodBoost.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodBoost.html:21808,monitor,monitoring,21808,root/html532/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodBoost.html,3,"['Monitor', 'monitor']","['MonitorBoost', 'monitoring']"
Energy Efficiency,"uble_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.0); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value for each region. Double_t GradBoostRegression(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); Implementation of M_TreeBoost using a Huber loss function as desribed by Friedman 1999. void InitGradBoost(vector<const TMVA::Event*>& ); initialize targets for first tree. Double_t TestTreeQuality(TMVA::DecisionTree* dt); test the tree quality.. in terms of Miscalssification. Double_t Boost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt, UInt_t cls = 0); apply the boosting alogrithim (the algorithm is selecte via the the ""option"" given; in the constructor. The return value is the boosting weight. void BoostMonitor(Int_t iTree); fills the ROCIntegral vs Itree from the testSample for the monitoring plots; during the training .. but using the testing events. Double_t AdaBoost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaBoost implementation.; a new training sample is generated by weighting; events that are misclassified by the decision tree. The weight; applied is w = (1-err)/err or more general:; w = ((1-err)/err)^beta; where err is the fraction of misclassified events in the tree ( <0.5 assuming; demanding the that previous selection was better than random guessing); and ""beta"" being a free parameter (standard: beta = 1) that modifies the; boosting. Double_t AdaCost(vector<const TMVA::Event*>& , TMVA::DecisionTree* dt); the AdaCost boosting algorithm takes a simple cost Matrix (currently fixed for; all events... later could be modified to use individual cost matrices for each; events as in the original paper... true_signal true_bkg. sel_signal | Css Ctb_ss Cxx.. in the range [0,1]; sel_bkg | Cts_sb Cbb. and takes this into ac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBDT.html:31761,monitor,monitoring,31761,root/html534/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBDT.html,2,['monitor'],['monitoring']
Energy Efficiency,"uble_t>& , Double_t** , Double_t** , Int_t ibin); translate the cuts into parameters (obsolete function). void MatchCutsToPars(vector<Double_t>& , Double_t* , Double_t* ); translates cuts into parameters. void GetEffsfromPDFs(Double_t* cutMin, Double_t* cutMax, Double_t& effS, Double_t& effB); compute signal and background efficiencies from PDFs; for given cut sample. void GetEffsfromSelection(Double_t* cutMin, Double_t* cutMax, Double_t& effS, Double_t& effB); compute signal and background efficiencies from event counting; for given cut sample. void CreateVariablePDFs( void ); for PDF method: create efficiency reference histograms and PDFs. void ReadWeightsFromStream(istream& i); read the cuts from stream. void AddWeightsXMLTo(void* parent) const; create XML description for LD classification and regression; (for arbitrary number of output classes/targets). void ReadWeightsFromXML(void* wghtnode); read coefficients from xml weight file. void WriteMonitoringHistosToFile( void ); write histograms and PDFs to file for monitoring purposes. Double_t GetTrainingEfficiency(const TString& ); - overloaded function to create background efficiency (rejection) versus; signal efficiency plot (first call of this function); - the function returns the signal efficiency at background efficiency; indicated in theString. ""theString"" must have two entries:; [0]: ""Efficiency""; [1]: the value of background efficiency at which the signal efficiency; is to be returned. Double_t GetEfficiency(const TString& , TMVA::Types::ETreeType , Double_t& ); - overloaded function to create background efficiency (rejection) versus; signal efficiency plot (first call of this function); - the function returns the signal efficiency at background efficiency; indicated in theString. ""theString"" must have two entries:; [0]: ""Efficiency""; [1]: the value of background efficiency at which the signal efficiency; is to be returned. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCuts.html:24070,monitor,monitoring,24070,root/html528/TMVA__MethodCuts.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCuts.html,10,['monitor'],['monitoring']
Energy Efficiency,"uble_t ; par . ). Computes the Discrete Poisson distribution function for (x,par). ; This is a discrete and a non-smooth function. This function is equivalent to ROOT::Math::poisson_pdf. Definition at line 615 of file TMath.cxx. ◆ Power() [1/5]. Double_t TMath::Power ; (; Double_t ; x, . Double_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 739 of file TMath.h. ◆ Power() [2/5]. Double_t TMath::Power ; (; Double_t ; x, . Int_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 745 of file TMath.h. ◆ Power() [3/5]. LongDouble_t TMath::Power ; (; Long64_t ; x, . Long64_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 733 of file TMath.h. ◆ Power() [4/5]. LongDouble_t TMath::Power ; (; LongDouble_t ; x, . Long64_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 727 of file TMath.h. ◆ Power() [5/5]. LongDouble_t TMath::Power ; (; LongDouble_t ; x, . LongDouble_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 721 of file TMath.h. ◆ Prob(). Double_t TMath::Prob ; (; Double_t ; chi2, . Int_t ; ndf . ). Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ; Calculations are based on the incomplete gamma function P(a,x), where a=ndf/2 and x=chi2/2.; P(a,x) represents the probability that the observed Chi-squared for a correct model should be less than the value chi2.; The returned probability corresponds to 1-P(a,x), which denotes the probability that an observed Chi-squared exceeds the value chi2 by chance, even for a correct model.; AuthorNvE 14-nov-1998 UU-SAP Utrecht ; Definition at line 637 of file TMath.cxx. ◆ Qe(). constexpr Double_t TMath::Qe ; (; ). constexpr . Elementary charge in \( C \) . ; Definition at line 339 of file TMath.h. ◆ QeUncertainty(). constexpr Double_t TMath::QeUncertainty ; (; ). constexpr . Elementary charge uncertainty. ; Definition at line 346 of file TMath.h. ◆ Quantiles(). v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:72559,power,power,72559,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['power'],['power']
Energy Efficiency,"uble binVolume () const;  ; TObject * clone (const char *newname) const override;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  ; const RooArgSet * get (const RooArgSet &coord) const;  ; const RooArgSet * get (Int_t masterIdx) const;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise that all integrals can be handled internally. ;  ; RooAbsReal & getParameter () const;  ; RooAbsReal & getParameter (Int_t masterIdx) const;  Get the parameter associated with the index. ;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; Int_t numBins () const;  ; const RooArgList & paramList () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; void setConstant (bool constant);  ; void setParamConst (Int_t, bool=true);  ; void setShape (TH1 *shape);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:3469,efficient,efficiently,3469,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency,"ublic TColor. TColorGradient. TColorGradient extends basic TColor.; Actually, this is not a simple color, but linear gradient + shadow; for filled area. By inheriting from TColor, gradients can be placed; inside gROOT's list of colors and use it in all TAttXXX descendants; without modifying any existing code.; Shadow, of course, is not a property of any color, and gradient is; not, but this is the best way to add new attributes to filled area; without re-writing all the graphics code. Function Members (Methods); public:. TColorGradient(const TColorGradient&); ~TColorGradient(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const char*TColor::AsHexString() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTColor::Copy(TObject& color) const; static voidTColor::CreateColorsCircle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorsGray(); static voidTColor::CreateColorsRectangle(Int_t offset, const char* name, UChar_t* rgb); static voidTColor::CreateColorWheel(); static Int_tTColor::CreateGradientColorTable(UInt_t Number, Double_t* Stops, Double_t* Red, Double_t* Green, Double_t* Blue, UInt_t NColors, Float_t alpha = 1.); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TColorGradient.html:1705,Green,Green,1705,root/html534/TColorGradient.html,https://root.cern,https://root.cern/root/html534/TColorGradient.html,1,['Green'],['Green']
Energy Efficiency,"ublic:. TGLFBO(); virtual~TGLFBO(); voidBind(); voidBindTexture(); static TClass*Class(); voidInit(int w, int h, int ms_samples = 0); virtual TClass*IsA() const; voidRelease(); voidSetAsReadBuffer(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUnbind(); voidUnbindTexture(). protected:. UInt_tCreateAndAttachColorTexture(); UInt_tCreateAndAttachRenderBuffer(Int_t format, Int_t type); voidInitMultiSample(); voidInitStandard(). private:. TGLFBO(const TGLFBO&); TGLFBO&operator=(const TGLFBO&). Data Members; protected:. UInt_tfColorTexture; UInt_tfDepthBuffer; UInt_tfFrameBuffer; Int_tfH; Float_tfHScale; Bool_tfIsRescaled; UInt_tfMSColorBuffer; Int_tfMSCoverageSamples; UInt_tfMSFrameBuffer; Int_tfMSSamples; Int_tfW; Float_tfWScale; static Bool_tfgMultiSampleNAWarned; static Bool_tfgRescaleToPow2. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLFBO(); Constructor. ~TGLFBO(); Destructor. void Init(int w, int h, int ms_samples = 0); Acquire GL resources for given width, height and number of; multi-sampling samples. void Release(); Release the allocated GL resources. void Bind(); Bind the frame-buffer object. void Unbind(); Unbind the frame-buffer object. void BindTexture(); Bind texture. void UnbindTexture(); Unbind texture. void SetAsReadBuffer(). void InitStandard(). void InitMultiSample(). UInt_t CreateAndAttachRenderBuffer(Int_t format, Int_t type). UInt_t CreateAndAttachColorTexture(); Initialize color-texture and attach it to current FB. TGLFBO(const TGLFBO& ). TGLFBO& operator=(const TGLFBO& ). » Author: Matevz Tadel, Aug 2009 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFBO.h 36675 2010-11-15 20:33:58Z matevz $ » Last generated: 2010-11-16 10:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLFBO.html:1681,allocate,allocated,1681,root/html528/TGLFBO.html,https://root.cern,https://root.cern/root/html528/TGLFBO.html,1,['allocate'],['allocated']
Energy Efficiency,"ublic:. TGLFBO(); virtual~TGLFBO(); voidBind(); voidBindTexture(); static TClass*Class(); voidInit(int w, int h, int ms_samples = 0); virtual TClass*IsA() const; voidRelease(); voidSetAsReadBuffer(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUnbind(); voidUnbindTexture(). protected:. UInt_tCreateAndAttachColorTexture(); UInt_tCreateAndAttachRenderBuffer(Int_t format, Int_t type); voidInitMultiSample(); voidInitStandard(). private:. TGLFBO(const TGLFBO&); TGLFBO&operator=(const TGLFBO&). Data Members; protected:. UInt_tfColorTexture; UInt_tfDepthBuffer; UInt_tfFrameBuffer; Int_tfH; Float_tfHScale; Bool_tfIsRescaled; UInt_tfMSColorBuffer; Int_tfMSCoverageSamples; UInt_tfMSFrameBuffer; Int_tfMSSamples; Int_tfW; Float_tfWScale; static Bool_tfgMultiSampleNAWarned; static Bool_tfgRescaleToPow2. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLFBO(); Constructor. ~TGLFBO(); Destructor. void Init(int w, int h, int ms_samples = 0); Acquire GL resources for given width, height and number of; multi-sampling samples. void Release(); Release the allocated GL resources. void Bind(); Bind the frame-buffer object. void Unbind(); Unbind the frame-buffer object. void BindTexture(); Bind texture. void UnbindTexture(); Unbind texture. void SetAsReadBuffer(). void InitStandard(). void InitMultiSample(). UInt_t CreateAndAttachRenderBuffer(Int_t format, Int_t type). UInt_t CreateAndAttachColorTexture(); Initialize color-texture and attach it to current FB. TGLFBO(const TGLFBO& ). TGLFBO& operator=(const TGLFBO& ). » Author: Matevz Tadel, Aug 2009 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFBO.h 36675 2010-11-15 20:33:58Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLFBO.html:1681,allocate,allocated,1681,root/html530/TGLFBO.html,https://root.cern,https://root.cern/root/html530/TGLFBO.html,1,['allocate'],['allocated']
Energy Efficiency,"ublic:. TGLFBO(); virtual~TGLFBO(); voidBind(); voidBindTexture(); static TClass*Class(); voidInit(int w, int h, int ms_samples = 0); virtual TClass*IsA() const; voidRelease(); voidSetAsReadBuffer(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUnbind(); voidUnbindTexture(). protected:. UInt_tCreateAndAttachColorTexture(); UInt_tCreateAndAttachRenderBuffer(Int_t format, Int_t type); voidInitMultiSample(); voidInitStandard(). private:. TGLFBO(const TGLFBO&); TGLFBO&operator=(const TGLFBO&). Data Members; protected:. UInt_tfColorTexture; UInt_tfDepthBuffer; UInt_tfFrameBuffer; Int_tfH; Float_tfHScale; Bool_tfIsRescaled; UInt_tfMSColorBuffer; Int_tfMSCoverageSamples; UInt_tfMSFrameBuffer; Int_tfMSSamples; Int_tfW; Float_tfWScale; static Bool_tfgMultiSampleNAWarned; static Bool_tfgRescaleToPow2. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGLFBO(); Constructor. ~TGLFBO(); Destructor. void Init(int w, int h, int ms_samples = 0); Acquire GL resources for given width, height and number of; multi-sampling samples. void Release(); Release the allocated GL resources. void Bind(); Bind the frame-buffer object. void Unbind(); Unbind the frame-buffer object. void BindTexture(); Bind texture. void UnbindTexture(); Unbind texture. void SetAsReadBuffer(). void InitStandard(). void InitMultiSample(). UInt_t CreateAndAttachRenderBuffer(Int_t format, Int_t type). UInt_t CreateAndAttachColorTexture(); Initialize color-texture and attach it to current FB. TGLFBO(const TGLFBO& ). TGLFBO& operator=(const TGLFBO& ). » Author: Matevz Tadel, Aug 2009 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFBO.h 36675 2010-11-15 20:33:58Z matevz $ » Last generated: 2011-11-03 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLFBO.html:1681,allocate,allocated,1681,root/html532/TGLFBO.html,https://root.cern,https://root.cern/root/html532/TGLFBO.html,2,['allocate'],['allocated']
Energy Efficiency,"ubstantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.0000000000000001E-9, double relTol = 1.0000000000000001E-9, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.0000000000000001E-9, double relTol = 1.0000000000000001E-9, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::AdaptiveIntegratorMultiDim&operator=(const ROOT::Math::AdaptiveIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html:3114,Adapt,AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim,3114,root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html,2,['Adapt'],['AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim']
Energy Efficiency,"ubtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(double* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, double* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<double>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are cre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMatrixTSparse_double_.html:20548,allocate,allocated,20548,root/html530/TMatrixTSparse_double_.html,https://root.cern,https://root.cern/root/html530/TMatrixTSparse_double_.html,9,['allocate'],['allocated']
Energy Efficiency,"uct_t. Free the loaded font using DeleteFont(). ; Reimplemented from TVirtualX.; Definition at line 941 of file GX11Gui.cxx. ◆ LookupString(). void TGX11::LookupString ; (; Event_t * ; event, . char * ; buf, . Int_t ; buflen, . UInt_t & ; keysym . ). overridevirtual . Convert the keycode from the event structure to a key symbol (according to the modifiers specified in the event structure and the current keyboard mapping). ; In buf a null terminated ASCII string is returned representing the string that is currently mapped to the key code. ; Reimplemented from TVirtualX.; Definition at line 2281 of file GX11Gui.cxx. ◆ LowerWindow(). void TGX11::LowerWindow ; (; Window_t ; id). overridevirtual . Lower window so it lays below all its siblings. ; Reimplemented from TVirtualX.; Definition at line 287 of file GX11Gui.cxx. ◆ MakeOpaqueColors(). void TGX11::MakeOpaqueColors ; (; Int_t ; percent, . ULong_t * ; orgcolors, . Int_t ; ncolors . ). private . Get RGB values for orgcolors, add percent neutral to the RGB and allocate fNewColors. ; Definition at line 2974 of file TGX11.cxx. ◆ MapColorStruct(). void TGX11::MapColorStruct ; (; ColorStruct_t * ; color, . RXColor & ; xcolor . ). private . Map a ColorStruct_t to a XColor structure. ; Definition at line 1315 of file GX11Gui.cxx. ◆ MapCursor(). void TGX11::MapCursor ; (; ECursor ; cursor, . Int_t & ; xcursor . ). private . ◆ MapEvent(). void TGX11::MapEvent ; (; Event_t & ; ev, . void * ; xevi, . Bool_t ; tox = kTRUE . ). private . Map Event_t structure to XEvent structure. ; If tox is false map the other way. ; Definition at line 1483 of file GX11Gui.cxx. ◆ MapEventMask(). void TGX11::MapEventMask ; (; UInt_t & ; emask, . UInt_t & ; xemask, . Bool_t ; tox = kTRUE . ). private . Map event mask to or from X. ; Definition at line 402 of file GX11Gui.cxx. ◆ MapGCValues(). void TGX11::MapGCValues ; (; GCValues_t & ; gval, . ULong_t & ; xmask, . RXGCValues & ; xgval, . Bool_t ; tox = kTRUE . ). private . Map a GCValues_t to a XCG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:90897,allocate,allocate,90897,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,1,['allocate'],['allocate']
Energy Efficiency,"uctor NOT IMPLEMENTED (NEVER USED) ; Definition at line 207 of file PDEFoam.cxx. ◆ PDEFoam() [2/3]. TMVA::PDEFoam::PDEFoam ; (; ). Default constructor for streamer, user should not use it. ; Definition at line 101 of file PDEFoam.cxx. ◆ PDEFoam() [3/3]. TMVA::PDEFoam::PDEFoam ; (; const TString & ; name). User constructor, to be employed by the user. ; Definition at line 140 of file PDEFoam.cxx. ◆ ~PDEFoam(). TMVA::PDEFoam::~PDEFoam ; (; ). virtual . Default destructor. ; Definition at line 182 of file PDEFoam.cxx. Member Function Documentation. ◆ AddVariableName() [1/2]. void TMVA::PDEFoam::AddVariableName ; (; const char * ; s). inline . Definition at line 217 of file PDEFoam.h. ◆ AddVariableName() [2/2]. void TMVA::PDEFoam::AddVariableName ; (; TObjString * ; s). inline . Definition at line 218 of file PDEFoam.h. ◆ CellFill(). Int_t TMVA::PDEFoam::CellFill ; (; Int_t ; status, . PDEFoamCell * ; parent . ). protected . Internal subprogram used by Create. ; It initializes content of the newly allocated active cell. ; Definition at line 387 of file PDEFoam.cxx. ◆ CellValueIsUndefined(). Bool_t TMVA::PDEFoam::CellValueIsUndefined ; (; PDEFoamCell * ; ). protectedvirtual . Returns true, if the value of the given cell is undefined. ; Default value: kFALSE. This function can be overridden by sub-classes. ; Reimplemented in TMVA::PDEFoamTarget.; Definition at line 989 of file PDEFoam.cxx. ◆ CheckAll(). void TMVA::PDEFoam::CheckAll ; (; Int_t ; level). User utility, miscellaneous and debug. ; Checks all pointers in the tree of cells. This is useful auto-diagnostic. level=0, no printout, failures causes STOP level=1, printout, failures lead to WARNINGS only ; Definition at line 821 of file PDEFoam.cxx. ◆ Class(). static TClass * TMVA::PDEFoam::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::PDEFoam::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::PDEFoam::Class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDEFoam.html:20309,allocate,allocated,20309,doc/master/classTMVA_1_1PDEFoam.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDEFoam.html,1,['allocate'],['allocated']
Energy Efficiency,"ucture; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; static char*_poolBegin! Start of memory pool; static char*_poolCur! Next free slot in memory pool; static char*_poolEnd! End of memory pool ; TNamed*RooAbsCollection::_structureTag! Structure tag; TNamed*RooAbsCollection::_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooArgSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooArgSet(); Default constructor. RooArgSet(const RooArgList& list); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const RooArgList& list, const RooAbsArg* var1); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const char* name); Empty set constructor. RooArgSet(const RooArgSet& set1, const RooArgSet& set2, const char* name = """"); Construct a set from two existing sets. RooArgSet(const RooAbsArg& var1, const char* name = """"); Constructor for set containing 1 initial object. RooArgSet(const RooAbsArg& var1, const RooAbsArg& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgSet.html:14797,allocate,allocates,14797,root/html532/RooArgSet.html,https://root.cern,https://root.cern/root/html532/RooArgSet.html,3,['allocate'],['allocates']
Energy Efficiency,"ude <RooNDKeysPdf.h>. Inheritance diagram for RooNDKeysPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ Mirror. enum RooNDKeysPdf::Mirror. EnumeratorNoMirror ; MirrorLeft ; MirrorRight ; MirrorBoth ; MirrorAsymLeft ; MirrorAsymLeftRight ; MirrorAsymRight ; MirrorLeftAsymRight ; MirrorAsymBoth . Definition at line 48 of file RooNDKeysPdf.h. Constructor & Destructor Documentation. ◆ RooNDKeysPdf() [1/9]. RooNDKeysPdf::RooNDKeysPdf ; (; ). default . ◆ RooNDKeysPdf() [2/9]. RooNDKeysPdf::RooNDKeysPdf ; (; const char * ; name, . const char * ; title, . const RooArgList & ; varList, . const RooDataSet & ; data, . TString ; options = ""ma"", . double ; rho = 1, . double ; nSigma = 3, . bool ; rotate = true, . bool ; sortInput = true . ). Construct N-dimensional kernel estimation p.d.f. ; in observables 'varList' from dataset 'data'. Options can be. 'a' = Use adaptive kernels (width varies with local event density); 'm' = Mirror data points over observable boundaries. Improves modeling behavior at edges for distributions that are not close to zero at edge; 'd' = Debug flag; 'v' = Verbose flag. The parameter rho (default = 1) provides an overall scale factor that can be applied to the bandwidth calculated for each kernel. The nSigma parameter determines the size of the box that is used to search for contributing kernels around a given point in observable space. The nSigma parameters is used in case of non-adaptive bandwidths and for the 1st non-adaptive pass for the calculation of adaptive keys p.d.f.s.; The optional weight arguments allows to specify an observable or function expression in observables that specifies the weight of each event. ; Definition at line 70 of file RooNDKeysPdf.cxx. ◆ RooNDKeysPdf() [3/9]. RooNDKeysPdf::RooNDKeysPdf ; (; const char * ; name, . const char * ; title, . const RooArgList & ; varList, . const TH1 & ; hist, . TString ; options = ""ma"", . double ; rho = 1,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNDKeysPdf.html:80226,adapt,adaptive,80226,doc/master/classRooNDKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRooNDKeysPdf.html,1,['adapt'],['adaptive']
Energy Efficiency,"ude the uncertainty from the expected number of events, the Normalization() argument with ScaleType RooAbsReal::RelativeExpected has to be passed, e.g. pdf.plotOn(frame, VisualizeError(fitResult), Normalization(1.0, RooAbsReal::RelativeExpected));; RooAbsReal::RelativeExpected@ RelativeExpectedDefinition RooAbsReal.h:276. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, double Z=1, bool linearMethod=true) Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma . Reimplemented from RooAbsReal.; Reimplemented in RooSimultaneous, and RooSimultaneous.; Definition at line 1937 of file RooAbsPdf.cxx. ◆ prepareMultiGen(). RooAbsPdf::prepareMultiGen ; (; const RooArgSet & ; whatVars, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {} . ). Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specification. ; NoteThis method does not perform any generation. To generate according to generations specification call RooAbsPdf::generate(RooAbsPdf::GenSpec&) const. Details copied from RooAbsPdf::generate():; Generate the specified number of events or expectedEvents() if not specified. Parameters. [in]whatVarsChoose variables in which to generate events. Variables not listed here will remain constant and not be used for event generation. ; [in]arg1,arg2,arg3,arg4,arg5,arg6Optional RooCmdArg() to change behaviour of generate(). . ReturnsRooDataSet *, owned by caller.; Any variables of this PDF that are not in whatVars will use their current values and be treated as fixed parameters. Returns zero in case of an error. Type of CmdArg Effect on generate . Name(const char* name) Name of the output dataset . Verbose(bool flag) Print informational messages during event generation . NumEvents(int nevt) Generate specified number of events . Extended",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:146486,efficient,efficient,146486,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['efficient'],['efficient']
Energy Efficiency,"ue, 255, alpha);; 3031 }; 3032 break;; 3033 ; 3034 // Inverted Dark Body Radiator; 3035 case 56:; 3036 {; 3037 Double_t red[9] = { 242./255., 234./255., 237./255., 230./255., 212./255., 156./255., 99./255., 45./255., 0./255.};; 3038 Double_t green[9] = { 243./255., 238./255., 238./255., 168./255., 101./255., 45./255., 0./255., 0./255., 0./255.};; 3039 Double_t blue[9] = { 230./255., 95./255., 11./255., 8./255., 9./255., 3./255., 1./255., 1./255., 0./255.};; 3040 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3041 }; 3042 break;; 3043 ; 3044 // Bird; 3045 case 57:; 3046 {; 3047 Double_t red[9] = { 0.2082, 0.0592, 0.0780, 0.0232, 0.1802, 0.5301, 0.8186, 0.9956, 0.9764};; 3048 Double_t green[9] = { 0.1664, 0.3599, 0.5041, 0.6419, 0.7178, 0.7492, 0.7328, 0.7862, 0.9832};; 3049 Double_t blue[9] = { 0.5293, 0.8684, 0.8385, 0.7914, 0.6425, 0.4662, 0.3499, 0.1968, 0.0539};; 3050 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3051 }; 3052 break;; 3053 ; 3054 // Cubehelix; 3055 case 58:; 3056 {; 3057 Double_t red[9] = { 0.0000, 0.0956, 0.0098, 0.2124, 0.6905, 0.9242, 0.7914, 0.7596, 1.0000};; 3058 Double_t green[9] = { 0.0000, 0.1147, 0.3616, 0.5041, 0.4577, 0.4691, 0.6905, 0.9237, 1.0000};; 3059 Double_t blue[9] = { 0.0000, 0.2669, 0.3121, 0.1318, 0.2236, 0.6741, 0.9882, 0.9593, 1.0000};; 3060 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3061 }; 3062 break;; 3063 ; 3064 // Green Red Violet; 3065 case 59:; 3066 {; 3067 Double_t red[9] = {13./255., 23./255., 25./255., 63./255., 76./255., 104./255., 137./255., 161./255., 206./255.};; 3068 Double_t green[9] = {95./255., 67./255., 37./255., 21./255., 0./255., 12./255., 35./255., 52./255., 79./255.};; 3069 Double_t blue[9] = { 4./255., 3./255., 2./255., 6./255., 11./255., 22./255., 49./255., 98./255., 208./255.};; 3070 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3071 }; 3072 break;; 3073 ; 307",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:115117,green,green,115117,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"ueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tEvalControl(const Int_t* powers) const; virtual Double_tEvalFactor(Int_t p, Double_t x) const; virtual voidMakeCandidates(); virtual voidMakeCoefficientErrors(); virtual voidMakeCoefficients(); virtual voidMakeCorrelation(); virtual Double_tMakeGramSchmidt(Int_t function); virtual voidMakeNormalized(); virtual voidMakeParameterization(); virtual voidMakeRealCode(const char* filename, const char* classname, Option_t* option = """"); voidTObject::MakeZombie(); virtual Bool_tSelect(const Int_t* iv); virtual Bool_tTestFunction(Double_t squareResidual, Double_t dResidur). Data Members; public:. enum EMDFPolyType { kMonomials; kChebyshev; kLegendre; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfBinVarXNumber of bin in independent variables; Int_tfBinVarYNumber of bin in dependent variables; Double_tfChi2Chi square of fit; TVectorDfCoefficientsVector of the final coefficients; TVectorDfCoefficientsRMSVector of RMS of coefficients; Double_tfCorrelationCoeffMulti Correlation coefficient; TMatrix",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:21063,power,powers,21063,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,2,['power'],['powers']
Energy Efficiency,"ues not in the right sequence.; The solution to this problem is to call BypassStreamer(kFALSE); for the TClonesArray. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete(). void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClonesArray.html:14966,allocate,allocate,14966,root/html526/TClonesArray.html,https://root.cern,https://root.cern/root/html526/TClonesArray.html,1,['allocate'],['allocate']
Energy Efficiency,"uffer = fBuffer;; 1435 if (nbentries < 0) {; 1436 nbentries = -nbentries;; 1437 // a reset might call BufferEmpty() giving an infinite recursion; 1438 // Protect it by setting fBuffer = nullptr; 1439 fBuffer = nullptr;; 1440 //do not reset the list of functions; 1441 Reset(""ICES"");; 1442 fBuffer = buffer;; 1443 }; 1444 if (CanExtendAllAxes() || (fXaxis.GetXmax() <= fXaxis.GetXmin())) {; 1445 //find min, max of entries in buffer; 1446 Double_t xmin = TMath::Infinity();; 1447 Double_t xmax = -TMath::Infinity();; 1448 for (Int_t i=0;i<nbentries;i++) {; 1449 Double_t x = fBuffer[2*i+2];; 1450 // skip infinity or NaN values; 1451 if (!std::isfinite(x)) continue;; 1452 if (x < xmin) xmin = x;; 1453 if (x > xmax) xmax = x;; 1454 }; 1455 if (fXaxis.GetXmax() <= fXaxis.GetXmin()) {; 1456 Int_t rc = -1;; 1457 if (TestBit(TH1::kAutoBinPTwo)) {; 1458 if ((rc = AutoP2FindLimits(xmin, xmax)) < 0); 1459 Warning(""BufferEmpty"",; 1460 ""inconsistency found by power-of-2 autobin algorithm: fallback to standard method"");; 1461 }; 1462 if (rc < 0); 1463 THLimitsFinder::GetLimitsFinder()->FindGoodLimits(this, xmin, xmax);; 1464 } else {; 1465 fBuffer = nullptr;; 1466 Int_t keep = fBufferSize; fBufferSize = 0;; 1467 if (xmin < fXaxis.GetXmin()) ExtendAxis(xmin, &fXaxis);; 1468 if (xmax >= fXaxis.GetXmax()) ExtendAxis(xmax, &fXaxis);; 1469 fBuffer = buffer;; 1470 fBufferSize = keep;; 1471 }; 1472 }; 1473 ; 1474 // call DoFillN which will not put entries in the buffer as FillN does; 1475 // set fBuffer to zero to avoid re-emptying the buffer from functions called; 1476 // by DoFillN (e.g Sumw2); 1477 buffer = fBuffer; fBuffer = nullptr;; 1478 DoFillN(nbentries,&buffer[2],&buffer[1],2);; 1479 fBuffer = buffer;; 1480 ; 1481 // if action == 1 - delete the buffer; 1482 if (action > 0) {; 1483 delete [] fBuffer;; 1484 fBuffer = nullptr;; 1485 fBufferSize = 0;; 1486 } else {; 1487 // if number of entries is consistent with buffer - set it negative to avoid; 1488 // refilling the histogram every tim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:57205,power,power-of-,57205,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['power'],['power-of-']
Energy Efficiency,"uide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Attributes |; List of all members ; ROOT::Math::QuasiRandom< Engine > Class Template ReferenceMath » MathCore » Interface classes for Random number generation | Math » MathMore » QuasiRandom number generators and distributions. ; template<class Engine>; class ROOT::Math::QuasiRandom< Engine >User class for MathMore random numbers template on the Engine type. ; The API of this class followed that of the class ROOT::Math::Random It must be implemented using as Engine one of the derived classes of ROOT::Math::GSLQuasiRandomEngine, like ROOT::Math::GSLQrngSobol ; Definition at line 60 of file QuasiRandom.h. Public Member Functions;  QuasiRandom (const Engine &e, unsigned int dimension=1);  Create a QuasiRandom generator based on a provided generic engine. ;  ;  QuasiRandom (unsigned int dimension=1);  Create a QuasiRandom generator. ;  ;  ~QuasiRandom ();  Destructor: call Terminate() function of engine to free any allocated resource. ;  ; unsigned int EngineSize () const;  Return the size of the generator state. ;  ; std::string Name () const;  Return the name of the generator. ;  ; unsigned int NDim () const;  Return the dimension of the generator. ;  ; double Next ();  Generate next quasi random numbers point (1 - dimension) ;  ; bool Next (double *x);  Generate next quasi random numbers points. ;  ; double Rndm ();  Generate quasi random numbers between ]0,1[ 0 and 1 are excluded Function to be compatible with ROOT TRandom compatibility. ;  ; bool RndmArray (int n, double *array);  Generate an array of random numbers between ]0,1[ Function to preserve ROOT Trandom compatibility The array will be filled as x1,y1,z1,....x2,y2,z2,... ;  ; bool Skip (unsigned int n);  skip the next n number and jumb directly to the current state + n ;  ; std::string Type () const;  Return the type (name) of the used generator. ;  . Private Attributes; Engine fEngine;  . #include <",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1QuasiRandom.html:1132,allocate,allocated,1132,doc/master/classROOT_1_1Math_1_1QuasiRandom.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1QuasiRandom.html,1,['allocate'],['allocated']
Energy Efficiency,"uit2) It provides support for storing parameter values, step size, parameter transformation etc. More...;  ; class  ROOT::Math::GeneticMinimizer;  GeneticMinimizer. More...;  ; class  ROOT::Math::GSLMinimizer;  GSLMinimizer class. More...;  ; class  ROOT::Math::GSLMultiFit;  GSLMultiFit, internal class for implementing GSL non linear least square GSL fitting. More...;  ; class  ROOT::Math::GSLMultiFitFunctionAdapter< FuncVector >;  Class for adapting a C++ functor class to C function pointers used by GSL MultiFit Algorithm The templated C++ function class must implement: More...;  ; class  ROOT::Math::GSLMultiFitFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinDerivFunctionWrapper;  Wrapper for a multi-dimensional function with derivatives used in GSL multidim minimization algorithm. More...;  ; struct  ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >;  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MultiMin algorithms. More...;  ; class  ROOT::Math::GSLMultiMinFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinimizer;  GSLMultiMinimizer class , for minimizing multi-dimensional function using derivatives. More...;  ; class  ROOT::Math::GSLNLSMinimizer;  GSLNLSMinimizer class for Non Linear Least Square fitting It Uses the Levemberg-Marquardt algorithm from GSL Non Linear Least Square fitting. More...;  ; class  ROOT::Math::GSLSimAnFunc;  GSLSimAnFunc class description. More...;  ; class  ROOT::Math::GSLSimAnMinimizer;  GSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL. More...;  ; class  ROOT::Math::GSLSimAnnealing;  GSLSimAnnealing class for performing a simulated annealing search of a multidimensional function. More...;  ; struct  ROOT::Math::GSLSimAnParams;  s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__MultiMin.html:1462,adapt,adapting,1462,doc/master/group__MultiMin.html,https://root.cern,https://root.cern/doc/master/group__MultiMin.html,1,['adapt'],['adapting']
Energy Efficiency,"ule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:6090,Adapt,Adaptive,6090,root/html532/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html,4,['Adapt'],['Adaptive']
Energy Efficiency,"ullptr, . bool ; verbose = false . ); const. overrideprotectedvirtual . Return specialized context to efficiently generate toy events from RooAddModels. ; Reimplemented from RooAbsPdf.; Definition at line 635 of file RooAddModel.cxx. ◆ generateEvent(). void RooAddModel::generateEvent ; (; Int_t ; code). overridevirtual . This function should never be called as RooAddModel implements a custom generator context. ; Reimplemented from RooAbsPdf.; Definition at line 682 of file RooAddModel.cxx. ◆ getAnalyticalIntegralWN(). Int_t RooAddModel::getAnalyticalIntegralWN ; (; RooArgSet & ; allDeps, . RooArgSet & ; analDeps, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Variant of getAnalyticalIntegral that is also passed the normalization set that should be applied to the integrand of which the integral is requested. ; For certain operator p.d.f it is useful to overload this function rather than analyticalIntegralWN() as the additional normalization information may be useful in determining a more efficient decomposition of the requested integral. ; Reimplemented from RooAbsReal.; Definition at line 455 of file RooAddModel.cxx. ◆ getCompIntList(). void RooAddModel::getCompIntList ; (; const RooArgSet * ; nset, . const RooArgSet * ; iset, . pRooArgList & ; compIntList, . Int_t & ; code, . const char * ; isetRangeName . ); const. protected . Check if this configuration was created before. ; Definition at line 477 of file RooAddModel.cxx. ◆ getGenerator(). Int_t RooAddModel::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Return pseud-code that indicates if all components can do internal generation (1) or not (0) ; Reimplemented from RooAbsPdf.; Definition at line 663 of file RooAddModel.cxx. ◆ getProjCache(). AddCacheElem * RooAddModel::getProjCache ; (; const RooArgSet * ; nset, . const RooArgSet * ; iset = nullptr . ); const. protected .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:86496,efficient,efficient,86496,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['efficient'],['efficient']
Energy Efficiency,"ult().; Information about selected fields (columns); can be obtained with GetNumFields() and GetFieldName() methods.; To receive data for the next result row, NextResultRow() method should be called.; Value from each column can be retrieved with the GetInt(), GetDouble(),; GetString() and other methods. There are no strict limitations on which method should be used; to get column values. GetString() can be used as a generic method,; which should always return correct result, but also conversions between most; basic data types are supported. For instance, if a column contains integer; values, GetInt(), GetLong64(), GetDouble() and GetString() methods can be used.; If column has floating point format, GetDouble() and GetString() methods can; be used without loss of precision while GetInt() or GetLong64() will return; only the integer part of the value. One also can test whether; a value is NULL with the IsNull() method. The buffer length specified for a statement in the TSQLServer::Statement() call; will also be used to allocate buffers for column values. Usage of these; buffers is transparent for users and does not limit the number of rows; which can be accessed with one statement. Again, local databases do not work; with buffers inside TSQLStatement at all and ignore this value.; Example of select query:. stmt = serv->Statement(""SELECT * FROM TESTTABLE"", 100);; // process statement; if (stmt->Process()) {; // store result of statement in buffer; stmt->StoreResult();. // display info about selected field; cout << ""NumFields = "" << stmt->GetNumFields() << endl;; for (int n=0;n<stmt->GetNumFields();n++); cout << ""Field "" << n << "" = "" << stmt->GetFieldName(n) << endl;. // extract rows one after another; while (stmt->NextResultRow()) {; Double_t id1 = stmt->GetDouble(0);; UInt_t id2 = stmt->GetUInt(1);; const char* name1 = stmt->GetString(2);; const char* name2 = stmt->GetString(3);; cout << id1 << "" - "" << id2 << "" "" << name1 << "" "" << name2 << endl;; }; }. 4. Working ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLStatement.html:6823,allocate,allocate,6823,root/html534/TSQLStatement.html,https://root.cern,https://root.cern/root/html534/TSQLStatement.html,2,['allocate'],['allocate']
Energy Efficiency,"ult().; Information about selected fields (columns); can be obtained with GetNumFields() and GetFieldName() methods.; To receive data for the next result row, NextResultRow() method should be called.; Value from each column can be retrieved with the GetInt(), GetDouble(),; GetString() and other methods. There are no strict limitations on which method should be used; to get column values. GetString() can be used as a generic method,; which should always return correct result, but also conversions between most; basic data types are supported. For instance, if a column contains integer; values, GetInt(), GetLong64(), GetDouble() and GetString() methods can be used.; If column has floating point format, GetDouble() and GetString() methods can; be used without loss of precision while GetInt() or GetLong64() will return; only the integer part of the value. One also can test whether; a value is NULL with the IsNull() method. The buffer length specified for a statement in the TSQLServer::Statement() call; will also be used to allocate buffers for column values. Usage of these; buffers is transparent for users and does not limit the number of rows; which can be accessed with one statement. Again, local databases do not work; with buffers inside TSQLStatement at all and ignore this value.; Example of select query:. stmt = serv->Statement(""SELECT * FROM TESTTABLE"", 100);; // process statement; if (stmt->Process()) {; // store result of statement in buffer; stmt->StoreResult();. // display info about selected field; std::cout << ""NumFields = "" << stmt->GetNumFields() << std::endl;; for (int n=0;n<stmt->GetNumFields();n++); std::cout << ""Field "" << n << "" = "" << stmt->GetFieldName(n) << std::endl;. // extract rows one after another; while (stmt->NextResultRow()) {; Double_t id1 = stmt->GetDouble(0);; UInt_t id2 = stmt->GetUInt(1);; const char* name1 = stmt->GetString(2);; const char* name2 = stmt->GetString(3);; std::cout << id1 << "" - "" << id2 << "" "" << name1 << "" "" << name2 <<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLStatement.html:6847,allocate,allocate,6847,root/html602/TSQLStatement.html,https://root.cern,https://root.cern/root/html602/TSQLStatement.html,4,['allocate'],['allocate']
Energy Efficiency,"ult; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:52549,consumption,consumption,52549,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,10,['consumption'],['consumption']
Energy Efficiency,"ultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre); static TMVA::SimulatedAnnealing::EKernelTemperaturekDecreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekGeo; static TMVA::SimulatedAnnealing::EKernelTemperaturekHomo; static TMVA::SimulatedAnnealing::EKernelTemperaturekIncreasingAdaptive; static TMVA::SimulatedAnnealing::EKernelTemperaturekLog; static TMVA::SimulatedAnnealing::EKernelTemperaturekSin; static TMVA::SimulatedAnnealing::EKernelTemperaturekSqrt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); constructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); option setter. ~SimulatedAnnealing(); destructor. void FillWithRandomValues(vector<Double_t>& parameters); random starting parameters. void ReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); copy parameters. void GenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); generate adjacent parameters. std::vector<Double_t> GenerateNeighbour(vector<Double_t>& parameters, Double_t currentTemperature); generate adjacent parameters. void GenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); generate new temperature. Bool_t ShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature); result checker. void SetDefaultScale(); setting of default scale. Double_t GenerateMaxTemperature(vector<Double_t>& parameters); maximum temperature. Double_t Minimize(vector<Double_t>& para",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__SimulatedAnnealing.html:3638,adapt,adaptiveSpeed,3638,root/html602/TMVA__SimulatedAnnealing.html,https://root.cern,https://root.cern/root/html602/TMVA__SimulatedAnnealing.html,4,['adapt'],['adaptiveSpeed']
Energy Efficiency,"um performance out of RDataFrame, make sure to avoid just-in-time compiled versions of transformations and actions if at all possible.; 955For instance, `Filter(""x > 0"")` requires just-in-time compilation of the corresponding C++ logic, while the equivalent `Filter([](float x) { return x > 0.; }, {""x""})` does not.; 956Similarly, `Histo1D(""x"")` requires just-in-time compilation after the type of `x` is retrieved from the dataset, while `Histo1D<float>(""x"")` does not; the latter spelling; 957should be preferred for performance-critical applications.; 958 ; 959Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; 960See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 961 ; 962Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; 963before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs.; 964 ; 965Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging).; 966 ; 967### Memory usage; 968 ; 969There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:55479,reduce,reduce,55479,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['reduce'],['reduce']
Energy Efficiency,"um. Result after deconvolution. We have developed a new high resolution deconvolution algorithm. We have observed that the Gold deconvolution converges to its stable state (solution). It is useless to increase the number of iterations, the result obtained does not change. To continue in decreasing the width of peaks we have found that when the solution reaches its stable state it is necessary to stop iterations, then to change the vector in a way and repeat again the Gold deconvolution . We have found that to change the particular solution we need to apply non-linear boosting function to it. The power function proved to give the best results. At the beginning the function calculates exact solution of the Toeplitz system of linear equations.; \[ x^{(0)} = [x_e^2(0),x_e^2(1),...,x_e^2(N-1),]^T\] where : \[ x_e=H^{'-1}y^{'}\] Then it applies the Gold deconvolution algorithm to the solution and carries out preset number of iterations. Then the power function with the exponent equal to the boosting coefficient is applied to the deconvolved data. These data are then used as initial estimate of the solution of linear system of equations and again the Gold algorithm is employed. The whole procedure is repeated number_of_repetitions times.; The form of the high-resolution deconvolution function is; char *Deconvolution1HighResolution(float *source,; const float *resp,; int size,; int number-of-iterations,; int number-of-repetitions,; double boost);; This function calculates deconvolution from source spectrum according to response spectrum; The result is placed in the vector pointed by source pointer.; Function parameters:. source pointer to the vector of source spectrum; resp pointer to the vector of response spectrum; size length of source and response spectra; number_of_iterations for details we refer to manual; number_of_repetitions for details we refer to manual; boost boosting factor, for details we refer to manual. The result obtained using the data from Figures 4.1, 4.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:26235,power,power,26235,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,2,['power'],['power']
Energy Efficiency,"umber in colors[N]. If the maximum cell content is >ncolors, all cell contents are scaled to ncolors. The current color palette does not have a class or global object of its own. It is defined in the current style as an array of color numbers. The current palette can be changed with:; TStyle::SetPalette(Int_t ncolors,Int_t*color_indexes).; By default, or if ncolors <= 0, a default palette (see above) of 50 colors is defined. The colors defined in this palette are good for coloring pads, labels, and other graphic objects. If ncolors > 0 and colors = 0, the default palette is used with a maximum of ncolors. If ncolors == 1 && colors == 0, then a pretty palette with a spectrum Violet->Red is created. It is recommended to use this pretty palette when drawing lego(s), surfaces or contours. For example, to set the current palette to the “pretty” one, do:; root[] gStyle->SetPalette(1); A more complete example is shown below. It illustrates the definition of a custom palette. You can adapt it to suit your needs. In case you use it for contour coloring, with the current color/contour algorithm, always define two more colors than the number of contours.; void palette() {; // Example of creating new colors (purples); const Int_t colNum = 10; // and defining of a new palette; Int_t palette[colNum];; for (Int_t i=0; i<colNum; i++) {; // get the color and if it does not exist create it; if (! gROOT->GetColor(230+i) ){; TColor *color =; new TColor(230+i,1-(i/((colNum)*1.0)),0.3,0.5,"""");; } else {; TColor *color = gROOT->GetColor(230+i);; color->SetRGB(1-(i/((colNum)*1.0)),0.3,0.5);; }; palette[i] = 230+i;; }; gStyle->SetPalette(colNum,palette);; TF2 *f2 = new TF2(""f2"",""exp(-(x^2)-(y^2))"",-3,3,-3,3);; // two contours less than the number of colors in palette; f2->SetContour(colNum-2);; f2->Draw(""cont"");; }; Since ROOT 6.26, you can also define a palette based on an ASCII text file, using TColor::CreateColorTableFromFile(""filename.txt"") or gStyle->SetPalette(""filename.txt""). The inpu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:364307,adapt,adapt,364307,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['adapt'],['adapt']
Energy Efficiency,"umberClasses, UInt_t numberTargets);  Fisher can only handle classification with 2 classes. ;  ; virtual TClass * IsA () const;  ; void PrintCoefficients (void);  display Fisher coefficients and discriminating power for each variable check maximum length of variable name ;  ; virtual void ReadWeightsFromStream (std::istream &)=0;  ; void ReadWeightsFromStream (std::istream &i);  read Fisher coefficients from weight file ;  ; virtual void ReadWeightsFromStream (TFile &);  ; void ReadWeightsFromXML (void *wghtnode);  read Fisher coefficients from xml weight file ;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Train (void);  computation of Fisher coefficients by series of matrix operations ;  ;  Public Member Functions inherited from TMVA::MethodBase;  MethodBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &dsi, const TString &theOption="""");  standard constructor ;  ;  MethodBase (Types::EMVA methodType, DataSetInfo &dsi, const TString &weightFile);  constructor used for Testing + Application of the MVA, only (no training), using given WeightFiles ;  ; virtual ~MethodBase ();  destructor ;  ; void AddOutput (Types::ETreeType type, Types::EAnalysisType analysisType);  ; TDirectory * BaseDir () const;  returns the ROOT directory where info/histograms etc of the corresponding MVA method instance are stored ;  ; virtual void CheckSetup ();  check may be overridden by derived class (sometimes, eg, fitters are used which can only be implemented during training phase) ;  ; DataSet * Data () const;  ; DataSetInfo & DataInfo () const;  ; virtual void DeclareCompatibilityOptions ();  options that are used ONLY for the READER to ensure backward compatibility they are hence without any effect (the reader is only reading the training options that HAD been used at the training of the .xml weight file at hand ;  ; void DisableWriting (Bool_t setter);  ; Bool_t DoMulticlass ()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html:4951,power,power,4951,doc/master/classTMVA_1_1MethodFisher.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html,1,['power'],['power']
Energy Efficiency,"umbering bins in TH1::GetBin. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static TH1D * DoProject1D (const TH3 &h, const char *name, const char *title, const TAxis *projX, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 1D histogram ;  ; static TH2D * DoProject2D (const TH3 &h, const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF);  static methdod performing the projection to 2D histogram ;  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);  Check that two sub axis are the same. ;  ; static bool CheckEqualAxes (const TAxis *a1, const TAxis *a2);  Check that the axis are the same. ;  ; static Bool_t RecomputeAxisLimits (TAxis &destAxis, const TAxis &anAxis);  Finds new limits for the axis for the Merge function. ;  ; static Bool_t SameLimitsAndNBins (const TAxis &axis1, const TAxis &axis2);  S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:52695,power,power,52695,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['power'],['power']
Energy Efficiency,"ume the same response function (not changing the shape) along the entire energy scale. So the response matrix is composed of mutually shifted response functions by one channel, however of the same shape. Original 1-dimensional spectrum. Response function (one peak). The result after deconvolution is given in Figure 4.3. It substantially improves the resolution in the spectrum. Result after deconvolution. We have developed a new high resolution deconvolution algorithm. We have observed that the Gold deconvolution converges to its stable state (solution). It is useless to increase the number of iterations, the result obtained does not change. To continue in decreasing the width of peaks we have found that when the solution reaches its stable state it is necessary to stop iterations, then to change the vector in a way and repeat again the Gold deconvolution . We have found that to change the particular solution we need to apply non-linear boosting function to it. The power function proved to give the best results. At the beginning the function calculates exact solution of the Toeplitz system of linear equations.; \[ x^{(0)} = [x_e^2(0),x_e^2(1),...,x_e^2(N-1),]^T\] where : \[ x_e=H^{'-1}y^{'}\] Then it applies the Gold deconvolution algorithm to the solution and carries out preset number of iterations. Then the power function with the exponent equal to the boosting coefficient is applied to the deconvolved data. These data are then used as initial estimate of the solution of linear system of equations and again the Gold algorithm is employed. The whole procedure is repeated number_of_repetitions times.; The form of the high-resolution deconvolution function is; char *Deconvolution1HighResolution(float *source,; const float *resp,; int size,; int number-of-iterations,; int number-of-repetitions,; double boost);; This function calculates deconvolution from source spectrum according to response spectrum; The result is placed in the vector pointed by source pointer.; Funct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:25884,power,power,25884,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,2,['power'],['power']
Energy Efficiency,"uments; 1326 RooDataSet* protoData = static_cast<RooDataSet*>(pc.getObject(""proto"",nullptr)) ;; 1327 const char* dsetName = pc.getString(""dsetName"") ;; 1328 Int_t nEvents = pc.getInt(""nEvents"") ;; 1329 bool verbose = pc.getInt(""verbose"") ;; 1330 bool randProto = pc.getInt(""randProto"") ;; 1331 bool resampleProto = pc.getInt(""resampleProto"") ;; 1332 bool extended = pc.getInt(""extended"") ;; 1333 bool autoBinned = pc.getInt(""autoBinned"") ;; 1334 const char* binnedTag = pc.getString(""binnedTag"") ;; 1335 ; 1336 RooAbsGenContext* cx = autoGenContext(whatVars,protoData,nullptr,verbose,autoBinned,binnedTag) ;; 1337 ; 1338 return new GenSpec(cx,whatVars,protoData,nEvents,extended,randProto,resampleProto,dsetName) ;; 1339}; 1340 ; 1341 ; 1342////////////////////////////////////////////////////////////////////////////////; 1343/// If many identical generation requests; 1344/// are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); 1345/// combination than calling the standard generate() multiple times as; 1346/// initialization overhead is only incurred once.; 1347 ; 1348RooFit::OwningPtr<RooDataSet> RooAbsPdf::generate(RooAbsPdf::GenSpec& spec) const; 1349{; 1350 //Int_t nEvt = spec._extended ? RooRandom::randomGenerator()->Poisson(spec._nGen) : spec._nGen ;; 1351 //Int_t nEvt = spec._extended ? RooRandom::randomGenerator()->Poisson(spec._nGen==0?expectedEvents(spec._whatVars):spec._nGen) : spec._nGen ;; 1352 //Int_t nEvt = spec._nGen == 0 ? RooRandom::randomGenerator()->Poisson(expectedEvents(spec._whatVars)) : spec._nGen;; 1353 ; 1354 double nEvt = spec._nGen == 0 ? expectedEvents(spec._whatVars) : spec._nGen;; 1355 ; 1356 std::unique_ptr<RooDataSet> ret{generate(*spec._genContext,spec._whatVars,spec._protoData, nEvt,false,spec._randProto,spec._resampleProto,; 1357 spec._init,spec._extended)};; 1358 spec._init = true ;; 1359 return RooFit::makeOwningPtr(std::move(ret));; 1360}; 1361 ; 1362 ; 1363 ; 1364 ; 1365 ; 1366////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:66107,efficient,efficient,66107,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"ummy error handler for X11. Used by FindUsableVisual(). ; Definition at line 839 of file TGX11.cxx. ◆ GetPixel(). static void GetPixel ; (; int ; y, . int ; width, . Byte_t * ; scline . ). static . Get pixels in line y and put in array scline. ; Definition at line 3308 of file TGX11.cxx. ◆ GIFdecode(). int GIFdecode ; (; Byte_t * ; gifArr, . Byte_t * ; pixArr, . int * ; Width, . int * ; Height, . int * ; Ncols, . Byte_t * ; R, . Byte_t * ; G, . Byte_t * ; B . ). Definition at line 149 of file gifdecode.c. ◆ GIFencode(). long GIFencode ; (; int ; Width, . int ; Height, . Int_t ; Ncol, . Byte_t ; R[], . Byte_t ; G[], . Byte_t ; B[], . Byte_t ; ScLine[], . void(*)(int, int, Byte_t *) ; get_scline, . void(*)(Byte_t) ; pb . ). ◆ GIFinfo(). int GIFinfo ; (; Byte_t * ; gifArr, . int * ; Width, . int * ; Height, . int * ; Ncols . ). Definition at line 80 of file gifdecode.c. ◆ GIFquantize(). int GIFquantize ; (; UInt_t ; width, . UInt_t ; height, . Int_t * ; ncol, . Byte_t * ; red, . Byte_t * ; green, . Byte_t * ; blue, . Byte_t * ; outputBuf, . Byte_t * ; outputCmap . ). ◆ PutByte(). static void PutByte ; (; Byte_t ; b). static . Put byte b in output stream. ; Definition at line 3317 of file TGX11.cxx. ◆ XRotDrawAlignedImageString(). int XRotDrawAlignedImageString ; (; Display * ; dpy, . XFontStruct * ; font, . float ; angle, . Drawable ; drawable, . GC ; gc, . int ; x, . int ; y, . char * ; text, . int ; align . ). A front end to XRotPaintAlignedString: -does alignment, paints background. ; Definition at line 316 of file Rotated.cxx. ◆ XRotDrawAlignedString(). int XRotDrawAlignedString ; (; Display * ; dpy, . XFontStruct * ; font, . float ; angle, . Drawable ; drawable, . GC ; gc, . int ; x, . int ; y, . char * ; text, . int ; align . ). A front end to XRotPaintAlignedString: -does alignment, no background. ; Definition at line 305 of file Rotated.cxx. ◆ XRotDrawImageString(). int XRotDrawImageString ; (; Display * ; dpy, . XFontStruct * ; font, . float ; angle, . Drawabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx.html:5732,green,green,5732,doc/master/TGX11_8cxx.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx.html,2,['green'],['green']
Energy Efficiency,"umns/branches in input to the producer function (excluding slot and entry). . Returnsthe first node of the computation graph for which the new quantity is defined.; The old value of the column can be used as an input for the expression. An exception is thrown in case the column to re-define does not already exist.; See DefineSlotEntry() for more information. ; Definition at line 598 of file RInterface.hxx. ◆ Reduce() [1/2]. template<typename Proxied , typename DataSource = void> . template<typename F , typename T = typename TTraits::CallableTraits<F>::ret_type> . RResultPtr< T > ROOT::RDF::RInterface< Proxied, DataSource >::Reduce ; (; F ; f, . std::string_view ; columnName, . const T & ; redIdentity . ). inline . Execute a user-defined reduce operation on the values of a column. ; Template Parameters. FThe type of the reduce callable. Automatically deduced. ; TThe type of the column to apply the reduction to. Automatically deduced. . Parameters. [in]fA callable with signature T(T,T) ; [in]columnNameThe column to be reduced. If omitted, the first default column is used instead. ; [in]redIdentityThe reduced object of each thread is initialized to this value. . Returnsthe reduced quantity wrapped in a RResultPtr. Example usage:; auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; See the description of the first Reduce overload for more information. ; Definition at line 1711 of file RInterface.hxx. ◆ Reduce() [2/2]. template<typename Proxied , typename DataSource = void> . template<typename F , typename T = typename TTraits::CallableTraits<F>::ret_type> . RResultPtr< T > ROOT::RDF::RInterface< Proxied, DataSource >::Reduce ; (; F ; f, . std::string_view ; columnName = """" . ). inline . Execute a user-defined reduce operation on the values of a column. ; Template Parameters. FThe type of the reduce callable. Automatically deduced. ; TThe type of the column to apply the reduction to. Automatically deduced. . Parameters. [in]fA callab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:119610,reduce,reduced,119610,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['reduce'],['reduced']
Energy Efficiency,"uncType >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ OneDimMultiFunctionAdapter() [1/3]. template<class MultiFuncType = const ROOT::Math::IMultiGenFunction &> . ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >::OneDimMultiFunctionAdapter ; (; MultiFuncType ; f, . const double * ; x, . unsigned int ; icoord = 0, . const double * ; p = nullptr . ). inline . Constructor from the function object , pointer to an external array of x values and coordinate we want to adapt. ; Definition at line 65 of file OneDimFunctionAdapter.h. ◆ OneDimMultiFunctionAdapter() [2/3]. template<class MultiFuncType = const ROOT::Math::IMultiGenFunction &> . ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >::OneDimMultiFunctionAdapter ; (; MultiFuncType ; f, . unsigned int ; dim = 1, . unsigned int ; icoord = 0, . const double * ; p = nullptr . ). inline . Constructor from the function object , dimension of the function and and coordinate we want to adapt. ; The coordinate cached vector is created inside and eventually the values must be passed later with the SetX which will copy them ; Definition at line 81 of file OneDimFunctionAdapter.h. ◆ ~OneDimMultiFunctionAdapter(). template<class MultiFuncType = const ROOT::Math::IMultiGenFunction &> . ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >::~OneDimMultiFunctionAdapter ; (; ). inlineoverride . Destructor (no operations) ; Definition at line 95 of file OneDimFunctionAdapter.h. ◆ OneDimMultiFunctionAdapter() [3/3]. template<class MultiFuncType = const ROOT::Math::IMultiGenFunction &> . ROOT::Math::OneDimMultiFunctionAdapter< MultiFuncType >::OneDimMultiFunctionAdapter ; (; const OneDimMultiFunctionAdapter< MultiFuncType > & ; rhs). inline . Definition at line 142 of file OneDimFunctionAdapter.h. Member Function Documentation. ◆ Clone(). template<class MultiFuncType = const ROOT::Math::IMultiGenFunction &> . OneDimMultiFunctionAdap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1OneDimMultiFunctionAdapter.html:4123,adapt,adapt,4123,doc/master/classROOT_1_1Math_1_1OneDimMultiFunctionAdapter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1OneDimMultiFunctionAdapter.html,1,['adapt'],['adapt']
Energy Efficiency,"unction evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.0000000000000001E-9, double relTol = 1.0000000000000001E-9, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.0000000000000001E-9, double relTol = 1.0000000000000001E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html:6075,Adapt,AdaptiveIntegratorMultiDim,6075,root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html,2,['Adapt'],['AdaptiveIntegratorMultiDim']
Energy Efficiency,"unction members; data members; class charts. ROOT; » CORE; » BASE; » TQObject. class TQObject. This is the ROOT implementation of the Qt object communication; mechanism (see also http://www.troll.no/qt/metaobjects.html). Signals and slots are used for communication between objects.; When an object has changed in some way that might be interesting; for the outside world, it emits a signal to tell whoever is; listening. All slots that are connected to this signal will be; activated (called). It is even possible to connect a signal; directly to another signal (this will emit the second signal; immediately whenever the first is emitted.) There is no limitation; on the number of slots that can be connected to a signal.; The slots will be activated in the order they were connected; to the signal. This mechanism allows objects to be easily reused,; because the object that emits a signal does not need to know; to which objects the signals are connected.; Together, signals and slots make up a powerfull component; programming mechanism. This implementation is provided by; Valeriy Onuchin (onuchin@sirius.ihep.su). Function Members (Methods); public:. TQObject(); virtual~TQObject(); static Bool_tAreAllSignalsBlocked(); Bool_tAreSignalsBlocked() const; static Bool_tBlockAllSignals(Bool_t b); Bool_tBlockSignals(Bool_t b); virtual voidChangedBy(const char* method)SIGNAL ; static TClass*Class(); voidCollectClassSignalLists(TList& list, TClass* cls); Bool_tConnect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tConnect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tConnect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidConnected(const char*); virtual voidDestroyed()SIGNAL ; Bool_tDisconnect(const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tDisconnect(TQObject* sender, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQObject.html:1173,power,powerfull,1173,root/html528/TQObject.html,https://root.cern,https://root.cern/root/html528/TQObject.html,6,['power'],['powerfull']
Energy Efficiency,"unction members; data members; class charts. ROOT; » CORE; » BASE; » TQObject. class TQObject. This is the ROOT implementation of the Qt object communication; mechanism (see also http://www.troll.no/qt/metaobjects.html). Signals and slots are used for communication between objects.; When an object has changed in some way that might be interesting; for the outside world, it emits a signal to tell whoever is; listening. All slots that are connected to this signal will be; activated (called). It is even possible to connect a signal; directly to another signal (this will emit the second signal; immediately whenever the first is emitted.) There is no limitation; on the number of slots that can be connected to a signal.; The slots will be activated in the order they were connected; to the signal. This mechanism allows objects to be easily reused,; because the object that emits a signal does not need to know; to which objects the signals are connected.; Together, signals and slots make up a powerfull component; programming mechanism. This implementation is provided by; Valeriy Onuchin (onuchin@sirius.ihep.su). Function Members (Methods); public:. virtual~TQObject(); static Bool_tAreAllSignalsBlocked(); Bool_tAreSignalsBlocked() const; static Bool_tBlockAllSignals(Bool_t b); Bool_tBlockSignals(Bool_t b); virtual voidChangedBy(const char* method)SIGNAL ; static TClass*Class(); voidCollectClassSignalLists(TList& list, TClass* cls); Bool_tConnect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tConnect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tConnect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidConnected(const char*); virtual voidDestroyed()SIGNAL ; Bool_tDisconnect(const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tDisconnect(TQObject* sender, const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQObject.html:1197,power,powerfull,1197,root/html602/TQObject.html,https://root.cern,https://root.cern/root/html602/TQObject.html,4,['power'],['powerfull']
Energy Efficiency,"unction return the default buffer size for automatic histograms the parameter fgBufferSize may be changed via SetDefaultBufferSize. ; Definition at line 4406 of file TH1.cxx. ◆ GetDefaultSumw2(). Bool_t TH1::GetDefaultSumw2 ; (; ). static . Return kTRUE if TH1::Sumw2 must be called when creating new histograms. ; see TH1::SetDefaultSumw2. ; Definition at line 4415 of file TH1.cxx. ◆ GetDimension(). virtual Int_t TH1::GetDimension ; (; ); const. inlinevirtual . Definition at line 283 of file TH1.h. ◆ GetDirectory(). TDirectory * TH1::GetDirectory ; (; ); const. inline . Definition at line 279 of file TH1.h. ◆ GetEffectiveEntries(). Double_t TH1::GetEffectiveEntries ; (; ); const. virtual . Number of effective entries of the histogram. . \[; neff = \frac{(\sum Weights )^2}{(\sum Weight^2 )}; \]. In case of an unweighted histogram this number is equivalent to the number of entries of the histogram. For a weighted histogram, this number corresponds to the hypothetical number of unweighted entries a histogram would need to have the same statistical power as this weighted histogram. Note: The underflow/overflow are included if one has set the TH1::StatOverFlows flag and if the statistics has been computed at filling time. If a range is set in the histogram the number is computed from the given range. ; Definition at line 4448 of file TH1.cxx. ◆ GetEntries(). Double_t TH1::GetEntries ; (; ); const. virtual . Return the current number of entries. ; Definition at line 4423 of file TH1.cxx. ◆ GetFunction(). TF1 * TH1::GetFunction ; (; const char * ; name); const. virtual . Return pointer to function with name. ; Functions such as TH1::Fit store the fitted function in the list of functions of this histogram. ; Definition at line 9051 of file TH1.cxx. ◆ GetIntegral(). Double_t * TH1::GetIntegral ; (; ). virtual . Return a pointer to the array of bins integral. ; if the pointer fIntegral is null, TH1::ComputeIntegral is called The array dimension is the number of bins in the hist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:156958,power,power,156958,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['power'],['power']
Energy Efficiency,"unction returns 0. If an I/O error occurs, the function returns -1.; If the Tree has friends, also read the friends entry.; To activate/deactivate one or more branches, use TBranch::SetBranchStatus For example, if you have a Tree with several hundred branches, and you are interested only by branches named ""a"" and ""b"", do mytree.SetBranchStatus(""*"",0); //disable all branches; mytree.SetBranchStatus(""a"",1);; mytree.SetBranchStatus(""b"",1);; when calling mytree.GetEntry(i); only branches ""a"" and ""b"" will be read.; WARNING!! If your Tree has been created in split mode with a parent branch ""parent."", mytree.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do: mytree.SetBranchStatus(""parent*"",1);; Without the trailing dot in the branch creation you have no choice but to call SetBranchStatus explicitly for each of the sub branches.; An alternative is to call directly brancha.GetEntry(i); branchb.GetEntry(i);; ; IMPORTANT NOTE; By default, GetEntry reuses the space allocated by the previous object for each branch. You can force the previous object to be automatically deleted if you call mybranch.SetAutoDelete(true) (default is false).; Example:; Consider the example in $ROOTSYS/test/Event.h The top level branch in the tree T is declared with: Event *event = 0; //event must be null or point to a valid object; //it must be initialized; T.SetBranchAddress(""event"",&event);; When reading the Tree, one can choose one of these 3 options:. OPTION 1; for (Long64_t i=0;i<nentries;i++) {; T.GetEntry(i);; // the object event has been filled at this point; }; The default (recommended). At the first entry an object of the class Event will be created and pointed by event. At the following entries, event will be overwritten by the new data. All internal members that are TObject* are automatically deleted. It is important that these members be in a valid state when GetEntry is called. Pointers must be correctly initialized. However these internal member",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:150824,allocate,allocated,150824,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['allocate'],['allocated']
Energy Efficiency,"unction signatures. ; contains additional settings if the DNN problem is classification ; Definition at line 894 of file NeuralNet.h. Public Member Functions;  ClassificationSettings (TString name, size_t _convergenceSteps=15, size_t _batchSize=10, size_t _testRepetitions=7, double _factorWeightDecay=1e-5, EnumRegularization _regularization=EnumRegularization::NONE, size_t _scaleToNumEvents=0, MinimizerType _eMinimizerType=MinimizerType::fSteepest, double _learningRate=1e-5, double _momentum=0.3, int _repetitions=3, bool _useMultithreading=true);  c'tor ;  ; virtual ~ClassificationSettings ();  d'tor ;  ; virtual void endTestCycle ();  action to be done when the training cycle is ended (e.g. ;  ; void endTrainCycle (double);  action to be done when the training cycle is ended (e.g. ;  ; void setResultComputation (std::string _fileNameNetConfig, std::string _fileNameResult, std::vector< Pattern > *_resultPatternContainer);  preparation for monitoring output ;  ; void setWeightSums (double sumOfSigWeights, double sumOfBkgWeights);  set the weight sums to be scaled to (preparations for monitoring output) ;  ; virtual void startTestCycle ();  action to be done when the test cycle is started (e.g. ;  ; void startTrainCycle ();  action to be done when the training cycle is started (e.g. ;  ; void testIteration ();  callback for monitoring and loggging ;  ; void testSample (double error, double output, double target, double weight);  action to be done after the computation of a test sample (e.g. ;  ;  Public Member Functions inherited from TMVA::DNN::Settings;  Settings (TString name, size_t _convergenceSteps=15, size_t _batchSize=10, size_t _testRepetitions=7, double _factorWeightDecay=1e-5, TMVA::DNN::EnumRegularization _regularization=TMVA::DNN::EnumRegularization::NONE, MinimizerType _eMinimizerType=MinimizerType::fSteepest, double _learningRate=1e-5, double _momentum=0.3, int _repetitions=3, bool _multithreading=true);  c'tor ;  ; virtual ~Settings ();  d'tor ;  ; void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html:1305,monitor,monitoring,1305,doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,2,['monitor'],['monitoring']
Energy Efficiency,"unction to be used for monitoring (callback)Definition NeuralNet.h:781; TMVA::DNN::Settings::plotvoid plot(std::string histoName, std::string options, int pad, EColor color)for monitoringDefinition NeuralNet.h:823; TMVA::DNN::Settings::startTrainCyclevirtual void startTrainCycle()Definition NeuralNet.h:782; TMVA::DNN::Settings::convergenceStepssize_t convergenceSteps() consthow many steps until training is deemed to have convergedDefinition NeuralNet.h:766; TMVA::DNN::Settings::factorWeightDecaydouble factorWeightDecay() constget the weight-decay factorDefinition NeuralNet.h:769; TMVA::DNN::Settings::maxConvergenceCountsize_t maxConvergenceCount() constreturns the max convergence count so farDefinition NeuralNet.h:828; TMVA::DNN::Settings::padsvoid pads(int numPads)preparation for monitoringDefinition NeuralNet.h:818; TMVA::DNN::Settings::batchSizesize_t batchSize() constmini-batch sizeDefinition NeuralNet.h:767; TMVA::DNN::Settings::computeResultvirtual void computeResult(const Net &, std::vector< double > &)callback for monitoring and loggingDefinition NeuralNet.h:809; TMVA::DNN::Settings::dropRepetitionssize_t dropRepetitions() constDefinition NeuralNet.h:761; TMVA::DNN::Settings::createvoid create(std::string histoName, int bins, double min, double max)for monitoringDefinition NeuralNet.h:819; TMVA::DNN::Settings::startTestCyclevirtual void startTestCycle()callback for monitoring and logggingDefinition NeuralNet.h:804; TMVA::DNN::Steepest::m_repetitionssize_t m_repetitionsDefinition NeuralNet.h:337; TMVA::DNN::Steepest::m_betadouble m_betainternal parameter (momentum)Definition NeuralNet.h:372; TMVA::DNN::Steepest::m_localGradientsstd::vector< double > m_localGradientslocal gradients for reuse in thread.Definition NeuralNet.h:376; TMVA::DNN::Steepest::m_prevGradientsstd::vector< double > m_prevGradientsvector remembers the gradients of the previous stepDefinition NeuralNet.h:373; TMVA::DNN::Steepest::m_alphadouble m_alphainternal parameter (learningRate)Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:69363,monitor,monitoring,69363,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"unctions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TTVLVContainer.h>. Inheritance diagram for TGItemContext:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGItemContext(). TGItemContext::TGItemContext ; (; ). Constructor. ; Definition at line 33 of file TTVLVContainer.cxx. ◆ ~TGItemContext(). TGItemContext::~TGItemContext ; (; ). inlineoverride . Definition at line 42 of file TTVLVContainer.h. Member Function Documentation. ◆ Associate(). void TGItemContext::Associate ; (; TTVLVEntry * ; item). inline . Definition at line 43 of file TTVLVContainer.h. ◆ Delete(). void TGItemContext::Delete ; (; Option_t * ; option). inlineoverridevirtual . Delete this object. ; Typically called as a command via the interpreter. Normally use ""delete"" operator when object has been allocated on the heap. ; Reimplemented from TObject.; Definition at line 44 of file TTVLVContainer.h. ◆ Draw(). void TGItemContext::Draw ; (; Option_t * ; option = """"). overridevirtual . Draw item. ; Reimplemented from TObject.; Definition at line 41 of file TTVLVContainer.cxx. ◆ EditExpression(). void TGItemContext::EditExpression ; (; ). Edit expression. ; Definition at line 49 of file TTVLVContainer.cxx. ◆ Empty(). void TGItemContext::Empty ; (; ). Empty item. ; Definition at line 57 of file TTVLVContainer.cxx. ◆ RemoveItem(). void TGItemContext::RemoveItem ; (; ). Remove item. ; Definition at line 65 of file TTVLVContainer.cxx. ◆ Scan(). void TGItemContext::Scan ; (; ). Scan item. ; Definition at line 73 of file TTVLVContainer.cxx. ◆ SetExpression(). void TGItemContext::SetExpression ; (; const char * ; name = """", . const char * ; alias = ""-empty-"", . bool ; cut = false . ). Set item expression. ; Definition at line 82 of file TTVLVContainer.cxx. Member Data Document",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGItemContext.html:10742,allocate,allocated,10742,doc/master/classTGItemContext.html,https://root.cern,https://root.cern/doc/master/classTGItemContext.html,1,['allocate'],['allocated']
Energy Efficiency,"unctions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that supports index access from a *contiguous* block of memory,; 84 /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; 85 /// through the internal accumulators based on the value of ""`index % N`"", so `N` accumulators can be filled from a block; 86 /// of `N` numbers in a single instruction.; 87 ///; 88 /// The usage of multiple accumulators might slightly increase the precision in comparison to the single-accumulator version; 89 /// with `N = 1`.; 90 /// This depends on the order and magnitude of the numbers bei",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Util_8h_source.html:2254,reduce,reduces,2254,doc/master/Util_8h_source.html,https://root.cern,https://root.cern/doc/master/Util_8h_source.html,1,['reduce'],['reduces']
Energy Efficiency,"unctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent). private:. TGenCollectionProxy(); TGenCollectionProxy&operator=(const TGenCollectionProxy&). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; void*fCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCopyIterator; void*fFunctionCreateIterators; void*fFunctionDeleteIterator; void*fFunctionDeleteTwoIterators; void*fFunctionNextIterator; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGenCollectionProxy.html:4311,allocate,allocate,4311,root/html534/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TGenCollectionProxy.html,2,['allocate'],['allocate']
Energy Efficiency,"uned for a total write memory of around 300 MB per fill context. ; Definition at line 82 of file RNTupleWriteOptions.hxx. ◆ fUseBufferedWrite. bool ROOT::Experimental::RNTupleWriteOptions::fUseBufferedWrite = true. protected . Whether to use buffered writing (with RPageSinkBuf). ; This buffers compressed pages in memory, reorders them to keep pages of the same column adjacent, and coalesces the writes when committing a cluster. ; Definition at line 85 of file RNTupleWriteOptions.hxx. ◆ fUseDirectIO. bool ROOT::Experimental::RNTupleWriteOptions::fUseDirectIO = false. protected . Whether to use Direct I/O for writing. ; Note that this introduces alignment requirements that may very between filesystems and platforms. ; Definition at line 88 of file RNTupleWriteOptions.hxx. ◆ fUseImplicitMT. EImplicitMT ROOT::Experimental::RNTupleWriteOptions::fUseImplicitMT = EImplicitMT::kDefault. protected . Whether to use implicit multi-threading to compress pages. Only has an effect if buffered writing is turned on. ; Definition at line 93 of file RNTupleWriteOptions.hxx. ◆ fWriteBufferSize. std::size_t ROOT::Experimental::RNTupleWriteOptions::fWriteBufferSize = 4 * 1024 * 1024. protected . Buffer size to use for writing to files, must be a multiple of 4096 bytes. ; Testing suggests that 4MiB gives best performance (with Direct I/O) at a reasonable memory consumption. ; Definition at line 91 of file RNTupleWriteOptions.hxx. ◆ kDefaultMaxKeySize. constexpr std::uint64_t ROOT::Experimental::RNTupleWriteOptions::kDefaultMaxKeySize = 0x4000'0000. staticconstexpr . Definition at line 56 of file RNTupleWriteOptions.hxx. Libraries for ROOT::Experimental::RNTupleWriteOptions:. [legend]; The documentation for this class was generated from the following files:; tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx; tree/ntuple/v7/src/RNTupleWriteOptions.cxx. ROOTExperimentalRNTupleWriteOptions. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html:13076,consumption,consumption,13076,doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html,1,['consumption'],['consumption']
Energy Efficiency,"unning this macro create an instance of Det and Event; Det d;; Event e;; d#define d(i)Definition RSha256.hxx:102; e#define e(i)Definition RSha256.hxx:103; EventDefinition collection_proxies.C:172; now you can see the effect of the ClassDef() and ClassImp() macros. (for the Det class these commands are commented!) For instance 'e' now knows who it is:; cout<<e.Class_Name()<<endl;; whereas d does not.; The methods that are added by the ClassDef()/Imp() macro can be listed with; .class; .class Event; .class Det; ; #include <TRandom.h>; #include <TTree.h>; #include <TCanvas.h>; #include <TStyle.h>; ; #include <Riostream.h>; ; //class Det : public TObject {; class Det { // each detector gives an energy and time signal; public:; Double_t e; //energy; Double_t t; //time; ; // ClassDef(Det,1); };; ; //ClassImp(Det); ; //class Event { //TObject is not required by this example; class Event : public TObject {; public:; ; Det a; // say there are two detectors (a and b) in the experiment; Det b;; ClassDefOverride(Event,1); };; ; ClassImp(Event); ; void tree0() {; // create a TTree; TTree *tree = new TTree(""tree"",""treelibrated tree"");; Event *e = new Event;; ; // create a branch with energy; tree->Branch(""event"",&e);; ; // fill some events with random numbers; Int_t nevent=10000;; for (Int_t iev=0;iev<nevent;iev++) {; if (iev%1000==0) cout<<""Processing event ""<<iev<<""...""<<endl;; ; Float_t ea,eb;; gRandom->Rannor(ea,eb); // the two energies follow a gaus distribution; e->a.e=ea;; e->b.e=eb;; e->a.t=gRandom->Rndm(); // random; e->b.t=e->a.t + gRandom->Gaus(0.,.1); // identical to a.t but a gaussian; // 'resolution' was added with sigma .1; ; tree->Fill(); // fill the tree with the current event; }; ; // start the viewer; // here you can investigate the structure of your Event class; tree->StartViewer();; ; //gROOT->SetStyle(""Plain""); // uncomment to set a different style; ; // now draw some tree variables; TCanvas *c1 = new TCanvas();; c1->Divide(2,2);; c1->cd(1);; tree->Draw(""a.e""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tree0_8C.html:1128,energy,energy,1128,doc/master/tree0_8C.html,https://root.cern,https://root.cern/doc/master/tree0_8C.html,3,['energy'],['energy']
Energy Efficiency,"ur, Int_t min, Int_t sec); 70{; 71 Set(year, month, day, hour, min, sec);; 72}; 73 ; 74////////////////////////////////////////////////////////////////////////////////; 75/// Expects as input a string in SQL date/time compatible format, like:; 76/// yyyy-mm-dd hh:mm:ss.; 77 ; 78TDatime::TDatime(const char *sqlDateTime); 79{; 80 Set(sqlDateTime);; 81}; 82 ; 83////////////////////////////////////////////////////////////////////////////////; 84/// Returns day of week, with Monday being day 1 and Sunday day 7.; 85 ; 86Int_t TDatime::GetDayOfWeek() const; 87{; 88 static TString weekDays[7] = { ""Mon"", ""Tue"", ""Wed"", ""Thu"", ""Fri"", ""Sat"", ""Sun"" };; 89 TString wd = AsString();; 90 int day;; 91 for (day = 0; day < 7; day++) {; 92 if (wd(0, 3) == weekDays[day]); 93 break;; 94 }; 95 return (day < 7) ? day+1: -1;; 96}; 97 ; 98////////////////////////////////////////////////////////////////////////////////; 99/// Return the date & time as a string (ctime() format).; 100/// Copy result because it points to a statically allocated string.; 101 ; 102const char *TDatime::AsString() const; 103{; 104 time_t t = Convert();; 105 char *retStr = ctime(&t);; 106 if (retStr) {; 107 *(retStr + 24) = 0;; 108 return retStr;; 109 } else {; 110 static const char *defaulttime = ""15/06/96"";; 111 Error(""TDatime::AsString"", ""could not get time string"");; 112 return defaulttime;; 113 }; 114}; 115 ; 116////////////////////////////////////////////////////////////////////////////////; 117/// Return the date & time as a string (ctime() format).; 118/// Result is copied into out (and out is returned). Make sure; 119/// out can at least contain 26 characters. Thread safe.; 120 ; 121const char *TDatime::AsString(char *out) const; 122{; 123 time_t t = Convert();; 124#ifndef WIN32; 125#if defined(R__SOLARIS) && (_POSIX_C_SOURCE - 0 < 199506L); 126 char *retStr = ctime_r(&t, out, 26);; 127#else; 128 char *retStr = ctime_r(&t, out);; 129#endif; 130#else; 131 char *retStr = ctime(&t);; 132#endif; 133 if (retStr) {;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDatime_8cxx_source.html:3372,allocate,allocated,3372,doc/master/TDatime_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDatime_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"uring the pave recording; Window_t*fFilteredIdsOnly when GUI for recorer is used: IDs of windows that creates that GUI.; Int_tfFilteredIdsCountOnly when GUI for recorder is used: Count of windows in GUI recorder; TRecGuiEvent*fGuiEventThe newest GUI event to be stored in TTree; TTree*fGuiTreeTTree with recorded GUI events; TTimer*fMouseTimerTimer used for recording mouse position; TRecorder*fRecorderReference to recorder (owner of this state) is kept in order to switch; Int_tfRegWinCounterCounter of registered ROOT windows.; TTimer*fTimerTimer used for recording; ULong64_tfWinThe newest registered window to be stored in TTree; TTree*fWinTreeTTree with registered windows. Class Charts. Inheritance Chart:. TRecorderState. ←; TRecorderRecording. Function documentation; TRecorderRecording(TRecorder* r, const char* filename, Option_t* option, Window_t* w, Int_t winCount); Initializes TRecorderRecording for recording; What is allocated here is deleted in destructor. ~TRecorderRecording(); Freeing of allocated memory. Bool_t StartRecording(); Connects appropriate signals and slots in order to gain all registered; windows and processed events in ROOT and then starts recording. void Stop(TRecorder* r, Bool_t guiCommand); Disconnects all slots and stopps recording. void RegisterWindow(Window_t w); This method is called when RegisteredWindow(Window_t) is emitted from; TGClient. void RecordCmdEvent(const char* line); Records commandline event (text and time) ans saves the previous; commandline event; This 1 event delay in saving ensures that the last commandline events; 'TRecorder::Stop' will be not stored. void RecordGuiEvent(Event_t* e, Window_t wid); Records GUI Event_t *e different from kConfigureNotify (they are; recorded in TRecorderRecording::RecordGuiCNEvent). It is called via signal-slot when an event is processed in; TGClient::HandleEvent(Event_t *event); or in TGClient::HandleMaskEvent(Event_t *event, Window_t wid). If signal is emitted from TGClient::HandleEvent(Eve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecorderRecording.html:3677,allocate,allocated,3677,root/html602/TRecorderRecording.html,https://root.cern,https://root.cern/root/html602/TRecorderRecording.html,4,['allocate'],['allocated']
Energy Efficiency,"urs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Fit__BinData.html:7803,allocate,allocated,7803,root/html532/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html532/ROOT__Fit__BinData.html,8,['allocate'],['allocated']
Energy Efficiency,"us)TObject::kOverwrite; static TFileHandler::(anonymous)kRead; static TObject::(anonymous)TObject::kSingleKey; static TFileHandler::(anonymous)kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. TFileHandler(int fd, int mask). virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFileHandler.html:10410,monitor,monitor,10410,root/html602/TFileHandler.html,https://root.cern,https://root.cern/root/html602/TFileHandler.html,12,['monitor'],['monitor']
Energy Efficiency,"usBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfColLwbColumn lower bound of decomposed matrix; Double_tfConditionmatrix condition number; Double_tfDet1determinant mantissa; Double_tfDet2determinant exponent for powers of 2; Int_tfRowLwbRow lower bound of decomposed matrix; Double_tfTolsqrt(epsilon); epsilon is smallest number number so that 1+epsilon > 1; static TDecompBase::EMatrixDecompStatkCondition; static TDecompBase::EMatrixDecompStatkDecomposed; static TDecompBase::EMatrixDecompStatkDetermined; static TDecompBase::EMatrixDecompStatkInit; static TDecompBase::EMatrixDecompStatkMatrixSet; static TDecompBase::EMatrixDecompStatkPatternSet; static TDecompBase::EMatrixDecompStatkSingular; static TDecompBase::EMatrixDecompStatkValuesSet; static TDecompBase::(anonymous)kWorkMax. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDecompBase(); Default constructor. TDecompBase(const TDecompBase& another); Copy constructor. Int_t Hager(Double_t& est, Int_t iter = 5). void DiagProd(const TVectorD& diag, Double_t tol, Double_t& d1, Double_t& d2). Double_t Condition(); Matrix condition number. Bool_t MultiSolve(TMatrixD& B); Solve set of equations with RHS in columns of B. void Det(Double_t& d1, Double_t& d2); Matrix determinant det = d1*TMath::Power(2.,d2). void Print(Option_t* opt = """") const; Print class members. TDecompBase & operator=(const TDecompBase& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDecompBase.html:10499,power,powers,10499,root/html602/TDecompBase.html,https://root.cern,https://root.cern/root/html602/TDecompBase.html,4,['power'],['powers']
Energy Efficiency,"used for fitting histograms and graphs.; 5.2.1 Fit with a Predefined Function; To fit a histogram with a predefined function, simply pass the name of the function in the first parameter of TH1::Fit. For example, this line fits histogram object hist with a Gaussian.; root[] hist.Fit(""gaus"");; The initial parameter values (and eventual limits) for pre-defined functions are set automatically. For overriding the default limits values use the fit option B.; The list of pre-defined functions that can be used with the Fit method is the following:. “gaus” Gaussian function with 3 parameters: f(x) = p0*exp(-0.5*((x-p1)/p2)^2); “expo”An Exponential with 2 parameters: f(x) = exp(p0+p1*x); “polN” A polynomial of degree N, where N is a number between 0 and 9: f(x) = p0 + p1*x + p2*x2 +...; “chebyshevN” A Chebyshev polynomial of degree N, where N is a number between 0 and 9: f(x) = p0 + p1*x + p2*(2*x2-1) +...; “landau” Landau function with mean and sigma. This function has been adapted from the CERNLIB routine G110 denlan (see TMath::Landau).; “gausn” Normalized form of the gaussian function with 3 parameters f(x) = p0*exp(-0.5*((x-p1)/p2)^2)/(p2 *sqrt(2PI)). 5.2.2 Creating User-Defined Functions (TF1); You can create a TF1 object and use it in the call the TH1::Fit. The parameter in to the Fit method is the NAME of the TF1 object. There are three ways to create a TF1. Using C++ expression using x with a fixed set of operators and functions defined in TFormula.; Same as first one, with parameters; Using a function that you have defined. This can be a free function or a functor object or a particular member function of a class. 5.2.2.1 Creating a TF1 with a Formula; Let’s look at the first case. Here we call the TF1 constructor by giving it the formula: sin(x)/x.; root[] TF1 *f1 = new TF1(""f1"",""sin(x)/x"",0,10); You can also use a TF1 object in the constructor of another TF1.; root[] TF1 *f2 = new TF1(""f2"",""f1*2"",0,10); 5.2.2.2 Creating a TF1 with Parameters; The second way to cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:168295,adapt,adapted,168295,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['adapt'],['adapted']
Energy Efficiency,"using a GSL function pointer type. ; Parameters. f: free function pointer of the GSL required type ; p: pointer to the object carrying the function state (for example the function object itself) . Definition at line 58 of file Derivator.cxx. ◆ ~Derivator(). ROOT::Math::Derivator::~Derivator ; (; ). virtual . destructor ; Definition at line 66 of file Derivator.cxx. ◆ Derivator() [4/4]. ROOT::Math::Derivator::Derivator ; (; const Derivator & ; ). private . Definition at line 72 of file Derivator.cxx. Member Function Documentation. ◆ Error(). double ROOT::Math::Derivator::Error ; (; ); const. return the estimate of the absolute error of the last derivative calculation ; Definition at line 154 of file Derivator.cxx. ◆ Eval() [1/5]. double ROOT::Math::Derivator::Eval ; (; const IGenFunction & ; f, . double ; x, . double ; h = 1E-8 . ). static . Computes the numerical derivative of a function f at a point x. ; It uses Derivator::EvalCentral to compute the derivative using an adaptive central difference algorithm with a step size h ; Definition at line 110 of file Derivator.cxx. ◆ Eval() [2/5]. double ROOT::Math::Derivator::Eval ; (; const IMultiGenFunction & ; f, . const double * ; x, . unsigned int ; icoord = 0, . double ; h = 1E-8 . ). static . Evaluate the partial derivative of a multi-dim function with respect coordinate x_icoord at the point x[]. ; Definition at line 126 of file Derivator.cxx. ◆ Eval() [3/5]. double ROOT::Math::Derivator::Eval ; (; double ; x, . double ; h = 1E-8 . ); const. Computes the numerical derivative of a function f at a point x. ; It uses Derivator::EvalCentral to compute the derivative using an adaptive central difference algorithm with a step size h ; Definition at line 93 of file Derivator.cxx. ◆ Eval() [4/5]. double ROOT::Math::Derivator::Eval ; (; IParamFunction & ; f, . double ; x, . const double * ; p, . unsigned int ; ipar = 0, . double ; h = 1E-8 . ). static . Evaluate the derivative with respect a parameter for one-dim parameteric ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html:5965,adapt,adaptive,5965,doc/master/classROOT_1_1Math_1_1Derivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Derivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"ust implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDimIGradientMultiDim(); ROOT::Math::IGradientMultiDimIGradientMultiDim(const ROOT::Math::IGradientMultiDim&); ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IGradientMultiDim.html:1918,efficient,efficient,1918,root/html602/ROOT__Math__IGradientMultiDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IGradientMultiDim.html,4,['efficient'],['efficient']
Energy Efficiency,"ust implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDimIGradientMultiDim(); ROOT::Math::IGradientMultiDimIGradientMultiDim(const ROOT::Math::IGradientMultiDim&); ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IGradientMultiDim.html:1918,efficient,efficient,1918,root/html604/ROOT__Math__IGradientMultiDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IGradientMultiDim.html,4,['efficient'],['efficient']
Energy Efficiency,"ust; 3445 case 97:; 3446 {; 3447 Double_t red[9] = { 0./255., 30./255., 63./255., 101./255., 143./255., 152./255., 169./255., 187./255., 230./255.};; 3448 Double_t green[9] = { 0./255., 14./255., 28./255., 42./255., 58./255., 61./255., 67./255., 74./255., 91./255.};; 3449 Double_t blue[9] = { 39./255., 26./255., 21./255., 18./255., 15./255., 14./255., 14./255., 13./255., 13./255.};; 3450 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3451 }; 3452 break;; 3453 ; 3454 // Sandy Terrain; 3455 case 98:; 3456 {; 3457 Double_t red[9] = { 149./255., 140./255., 164./255., 179./255., 182./255., 181./255., 131./255., 87./255., 61./255.};; 3458 Double_t green[9] = { 62./255., 70./255., 107./255., 136./255., 144./255., 138./255., 117./255., 87./255., 74./255.};; 3459 Double_t blue[9] = { 40./255., 38./255., 45./255., 49./255., 49./255., 49./255., 38./255., 32./255., 34./255.};; 3460 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3461 }; 3462 break;; 3463 ; 3464 // Sienna; 3465 case 99:; 3466 {; 3467 Double_t red[9] = { 99./255., 112./255., 148./255., 165./255., 179./255., 182./255., 183./255., 183./255., 208./255.};; 3468 Double_t green[9] = { 39./255., 40./255., 57./255., 79./255., 104./255., 127./255., 148./255., 161./255., 198./255.};; 3469 Double_t blue[9] = { 15./255., 16./255., 18./255., 33./255., 51./255., 79./255., 103./255., 129./255., 177./255.};; 3470 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3471 }; 3472 break;; 3473 ; 3474 // Solar; 3475 case 100:; 3476 {; 3477 Double_t red[9] = { 99./255., 116./255., 154./255., 174./255., 200./255., 196./255., 201./255., 201./255., 230./255.};; 3478 Double_t green[9] = { 0./255., 0./255., 8./255., 32./255., 58./255., 83./255., 119./255., 136./255., 173./255.};; 3479 Double_t blue[9] = { 5./255., 6./255., 7./255., 9./255., 9./255., 14./255., 17./255., 19./255., 24./255.};; 3480 Idx = TColor::CreateGradientColorTable(9, stops, re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:136524,green,green,136524,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"ut << ""set a 1d function"" << std::endl;; 101 ; 102 // function is cloned when creating the adapter; 103 fFunc = std::shared_ptr<IModelFunction>(new ROOT::Math::MultiDimParamFunctionAdapter(func));; 104 ; 105 // creates the parameter settings; 106 fConfig.CreateParamsSettings(*fFunc);; 107 fFunc_v.reset();; 108}; 109 ; 110void Fitter::SetFunction(const IGradModelFunction & func, bool useGradient); 111{; 112 fUseGradient = useGradient;; 113 //std::cout << ""set a grad function"" << std::endl;; 114 // set the fit model function (clone the given one and keep a copy ); 115 fFunc = std::shared_ptr<IModelFunction>( dynamic_cast<IGradModelFunction *> ( func.Clone() ) );; 116 assert(fFunc);; 117 ; 118 // creates the parameter settings; 119 fConfig.CreateParamsSettings(*fFunc);; 120 fFunc_v.reset();; 121}; 122 ; 123 ; 124void Fitter::SetFunction(const IGradModel1DFunction & func, bool useGradient); 125{; 126 //std::cout << ""set a 1d grad function"" << std::endl;; 127 fUseGradient = useGradient;; 128 // function is cloned when creating the adapter; 129 fFunc = std::shared_ptr<IModelFunction>(new ROOT::Math::MultiDimParamGradFunctionAdapter(func));; 130 ; 131 // creates the parameter settings; 132 fConfig.CreateParamsSettings(*fFunc);; 133 fFunc_v.reset();; 134}; 135 ; 136 ; 137bool Fitter::DoSetFCN(bool extFcn, const ROOT::Math::IMultiGenFunction & fcn, const double * params, unsigned int dataSize, int fitType) {; 138 // Set the objective function for the fit. First parameter specifies if function object is managed external or internal.; 139 // In case of an internal function object we need to clone because it is a temporary one; 140 // if params is not NULL create the parameter settings; 141 fUseGradient = false;; 142 unsigned int npar = fcn.NDim();; 143 if (npar == 0) {; 144 MATH_ERROR_MSG(""Fitter::SetFCN"",""FCN function has zero parameters "");; 145 return false;; 146 }; 147 if (params != nullptr || fConfig.ParamsSettings().empty()); 148 fConfig.SetParamsSettings(npar, params);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:4345,adapt,adapter,4345,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['adapt'],['adapter']
Energy Efficiency,"ut only the pointers; It requires the original HTI to be alive. HypoTestInverter & operator=(const RooStats::HypoTestInverter& rhs); assignment operator; NOTE: this class does not copy the contained result and; the HypoTestCalculator, but only the pointers; It requires the original HTI to be alive. ~HypoTestInverter(); destructor (delete the HypoTestInverterResult). TestStatistic * GetTestStatistic() const; return the test statistic which is or will be used by the class. bool SetTestStatistic(RooStats::TestStatistic& stat); set the test statistic to use. void Clear(); delete contained result and graph. void CreateResults() const; create a new HypoTestInverterResult to hold all computed results. HypoTestInverterResult* GetInterval() const; Run a fixed scan or the automatic scan depending on the configuration; Return if needed a copy of the result object which will be managed by the user. HypoTestResult * Eval(RooStats::HypoTestCalculatorGeneric& hc, bool adaptive, double clsTarget) const; Run the Hypothesis test at a previous configured point; (internal function called by RunOnePoint). bool RunFixedScan(int nBins, double xMin, double xMax) const; Run a Fixed scan in npoints between min and max. bool RunOnePoint(double thisX, bool adaptive = false, double clTarget = -1) const; run only one point at the given POI value. bool RunLimit(double& limit, double& limitErr, double absTol = 0, double relTol = 0, const double* hint = 0) const; run an automatic scan until the desired accurancy is reached; Start by default from the full interval (min,max) of the POI and then via bisection find the line crossing; the target line; Optionally an hint can be provided and the scan will be done closer to that value; If by bisection the desired accuracy will not be reached a fit to the points is performed. SamplingDistribution * GetLowerLimitDistribution(bool rebuild = false, int nToys = 100); get the distribution of lower limit; if rebuild = false (default) it will re-use the results of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestInverter.html:8489,adapt,adaptive,8489,root/html530/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestInverter.html,3,['adapt'],['adaptive']
Energy Efficiency,"ut only the pointers; It requires the original HTI to be alive. HypoTestInverter & operator=(const RooStats::HypoTestInverter& rhs); assignment operator; NOTE: this class does not copy the contained result and; the HypoTestCalculator, but only the pointers; It requires the original HTI to be alive. ~HypoTestInverter(); destructor (delete the HypoTestInverterResult). TestStatistic * GetTestStatistic() const; return the test statistic which is or will be used by the class. bool SetTestStatistic(RooStats::TestStatistic& stat); set the test statistic to use. void Clear(); delete contained result and graph. void CreateResults() const; create a new HypoTestInverterResult to hold all computed results. HypoTestInverterResult* GetInterval() const; Run a fixed scan or the automatic scan depending on the configuration; Return if needed a copy of the result object which will be managed by the user. HypoTestResult * Eval(RooStats::HypoTestCalculatorGeneric& hc, bool adaptive, double clsTarget) const; Run the Hypothesis test at a previous configured point; (internal function called by RunOnePoint). bool RunFixedScan(int nBins, double xMin, double xMax, bool scanLog = false) const; Run a Fixed scan in npoints between min and max. bool RunOnePoint(double thisX, bool adaptive = false, double clTarget = -1) const; run only one point at the given POI value. bool RunLimit(double& limit, double& limitErr, double absTol = 0, double relTol = 0, const double* hint = 0) const; run an automatic scan until the desired accurancy is reached; Start by default from the full interval (min,max) of the POI and then via bisection find the line crossing; the target line; Optionally an hint can be provided and the scan will be done closer to that value; If by bisection the desired accuracy will not be reached a fit to the points is performed. SamplingDistribution * GetLowerLimitDistribution(bool rebuild = false, int nToys = 100); get the distribution of lower limit; if rebuild = false (default) it will",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestInverter.html:9126,adapt,adaptive,9126,root/html534/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestInverter.html,6,['adapt'],['adaptive']
Energy Efficiency,"ut(""y+z<0""));; ds2.Print();; ; // I m p o r t i n g i n t e g e r T T r e e b r a n c h e s; // ---------------------------------------------------------------; ; // Import integer tree branch as RooRealVar; RooRealVar i(""i"", ""i"", 0, 5);; RooDataSet ds3(""ds3"", ""ds3"", RooArgSet(i, x), Import(*tree));; ds3.Print();; ; // Define category i; RooCategory icat(""i"", ""i"");; icat.defineType(""State0"", 0);; icat.defineType(""State1"", 1);; ; // Import integer tree branch as RooCategory (only events with i==0 and i==1; // will be imported as those are the only defined states); RooDataSet ds4(""ds4"", ""ds4"", RooArgSet(icat, x), Import(*tree));; ds4.Print();; ; // I m p o r t m u l t i p l e R o o D a t a S e t s i n t o a R o o D a t a S e t; // ----------------------------------------------------------------------------------------; ; // Create three RooDataSets in (y,z); std::unique_ptr<RooAbsData> dsA{ds2.reduce({x, y}, ""z<-5"")};; std::unique_ptr<RooAbsData> dsB{ds2.reduce({x, y}, ""abs(z)<5"")};; std::unique_ptr<RooAbsData> dsC{ds2.reduce({x, y}, ""z>5"")};; ; // Create a dataset that imports contents of all the above datasets mapped by index category c; RooDataSet dsABC{""dsABC"", ""dsABC"", RooArgSet(x, y), Index(c), Import(""SampleA"", *dsA),; Import(""SampleB"", *dsB), Import(""SampleC"", *dsC)};; ; dsABC.Print();; }; ; TH1 *makeTH1(const char *name, double mean, double sigma); {; // Create ROOT TH1 filled with a Gaussian distribution; ; TH1D *hh = new TH1D(name, name, 100, -10, 10);; for (int i = 0; i < 1000; i++) {; hh->Fill(gRandom->Gaus(mean, sigma));; }; return hh;; }; ; TTree *makeTTree(); {; // Create ROOT TTree filled with a Gaussian distribution in x and a uniform distribution in y; ; TTree *tree = new TTree(""tree"", ""tree"");; double *px = new double;; double *py = new double;; double *pz = new double;; Int_t *pi = new Int_t;; tree->Branch(""x"", px, ""x/D"");; tree->Branch(""y"", py, ""y/D"");; tree->Branch(""z"", pz, ""z/D"");; tree->Branch(""i"", pi, ""i/I"");; for (int i = 0; i < 100; i++) {;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8C.html:3329,reduce,reduce,3329,doc/master/rf401__importttreethx_8C.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8C.html,1,['reduce'],['reduce']
Energy Efficiency,"ute full covariance matrix from sum of within and between matrices ;  ; void GetCov_WithinClass (void);  the matrix of covariance 'within class' reflects the dispersion of the events relative to the center of gravity of their own class ;  ; void GetDiscrimPower (void);  computation of discrimination power indicator for each variable small values of ""fWith"" indicates little compactness of sig & of backgd big values of ""fBetw"" indicates large separation between sig & backgd ;  ; void GetFisherCoeff (void);  Fisher = Sum { [coeff]*[variables] }. ;  ; void GetMean (void);  compute mean values of variables in each sample, and the overall means ;  ; void Init (void);  default initialization called by all constructors ;  ; void InitMatrices (void);  initialization method; creates global matrices and vectors ;  ; void ProcessOptions ();  process user options ;  . Private Attributes; TMatrixD * fBetw;  between-class matrix ;  ; TMatrixD * fCov;  full covariance matrix ;  ; std::vector< Double_t > * fDiscrimPow;  discriminating power ;  ; Double_t fF0;  offset ;  ; std::vector< Double_t > * fFisherCoeff;  Fisher coefficients. ;  ; EFisherMethod fFisherMethod;  Fisher or Mahalanobis. ;  ; TMatrixD * fMeanMatx;  ; Double_t fSumOfWeightsB;  sum-of-weights for background training events ;  ; Double_t fSumOfWeightsS;  sum-of-weights for signal training events ;  ; TString fTheMethod;  Fisher or Mahalanobis. ;  ; TMatrixD * fWith;  within-class matrix ;  . Additional Inherited Members;  Public Attributes inherited from TMVA::MethodBase; Bool_t fSetupCompleted;  ; TrainingHistory fTrainHistory;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Attributes inherited from TMVA::MethodBase; Types::EAnalysisType fAnalysisType;  ; UInt_t fBackgroundClass;  ; bool fExitFromTraining = false;  ; std::vector< TString > * fInputVars;  ; IPythonInteractive * fInteractive = nullptr;  temporary dataset used when evaluating on a different data (u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html:30851,power,power,30851,doc/master/classTMVA_1_1MethodFisher.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html,1,['power'],['power']
Energy Efficiency,ution; TUnuranEmpDist Wrapper class for empirical distribution ; TUnuranMultiContDist Wrapper class for multi dimensional continuous distribution; TUnuranSampler ; TUploadDataSetDlg New query dialog; TUri Represents an URI; TUrl Represents an URL; TVector2 A 2D physics vector; TVector3 A 3D physics vector; TVectorT<double> Template of Vector class; TVectorT<float> Template of Vector class; TView 3-D View abstract interface for 3-D views; TView3D 3-D View; TViewer3DPad A 3D Viewer painter for TPads; TViewerX3D Interface to the X3D viewer; TVirtualArray ; TVirtualAuth client auth interface; TVirtualBranchBrowsable Base class for helper objects used for browsing; TVirtualCollectionProxy ; TVirtualDragManager drag and drop manager; TVirtualFFT abstract interface for FFT calculations; TVirtualFitter Abstract interface for fitting; TVirtualGLManip Interface for GL manipulator; TVirtualGLPainter Interface for OpenGL painter; TVirtualGeoPainter Abstract interface for geometry painters; TVirtualGeoTrack virtual geometry tracks; TVirtualGraphPainter Abstract interface for histogram painters; TVirtualHistPainter Abstract interface for histogram painters; TVirtualIndex Abstract interface for Tree Index; TVirtualIsAProxy ; TVirtualMC Interface to Monte Carlo; TVirtualMCApplication Interface to MonteCarlo application; TVirtualMCDecayer Particle Decayer Base Class; TVirtualMCGeometry Interface to Monte Carlo geometry construction; TVirtualMCStack Interface to a particles stack; TVirtualMagField Abstract base field class; TVirtualMonitoringReader ABC for Reading Monitoring Information; TVirtualMonitoringWriter ABC for Sending Monitoring Information; TVirtualMutex Virtual mutex lock class; TVirtualObject ; TVirtualPS Abstract interface to a PostScript driver; TVirtualPacketizer Generate work packets for parallel processing; TVirtualPad Abstract base class for Pads and Canvases; TVirtualPadEditor Abstract interface for graphics pad editor; TVirtualPadPainter Painter interface for pad.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:139448,Monitor,Monitoring,139448,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,2,['Monitor'],['Monitoring']
Energy Efficiency,"utoP2FindLimits ; (; Double_t ; xmi, . Double_t ; xma . ). protectedvirtual . Buffer-based estimate of the histogram range using the power of 2 algorithm. ; Used by the autobin power of 2 algorithm.; Works on arguments (min and max from fBuffer) and internal inputs: fXmin, fXmax, NBinsX (from fXaxis), ... Result save internally in fXaxis.; Overloaded by TH2 and TH3.; Return -1 if internal inputs are inconsistent, 0 otherwise. ; Definition at line 1343 of file TH1.cxx. ◆ AutoP2GetBins(). Int_t TH1::AutoP2GetBins ; (; Int_t ; n). inlinestaticprotected . Auxiliary function to get the next power of 2 integer value larger then n. ; Used by the autobin power of 2 algorithm ; Definition at line 1321 of file TH1.cxx. ◆ AutoP2GetPower2(). Double_t TH1::AutoP2GetPower2 ; (; Double_t ; x, . Bool_t ; next = kTRUE . ). inlinestaticprotected . Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ; next = kTRUE : next larger next = kFALSE : previous smaller; Used by the autobin power of 2 algorithm ; Definition at line 1308 of file TH1.cxx. ◆ AxisChoice(). Int_t TH1::AxisChoice ; (; Option_t * ; axis); const. protected . Choose an axis according to ""axis"". ; Definition at line 14 of file Haxis.cxx. ◆ Browse(). void TH1::Browse ; (; TBrowser * ; b). overridevirtual . Browse the Histogram object. ; Reimplemented from TObject.; Definition at line 762 of file TH1.cxx. ◆ BufferEmpty(). Int_t TH1::BufferEmpty ; (; Int_t ; action = 0). virtual . Fill histogram with all entries in the buffer. . action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); action = 0 histogram is reset and filled from the buffer. When the histogram is filled from the buffer the value fBuffer[0] is set to a negative number (= - number of entries) When calling with action == 0 the histogram is NOT refilled when fBuffer[0] is < 0 While when calling with action = -1 the histogram is reset and ALWAYS refilled independently if the histogram was fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:82185,power,power,82185,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['power'],['power']
Energy Efficiency,"utputFile(const char* fileName). RooCmdArg Format(const char* format, Int_t sigDigit). RooCmdArg Format(const char* what, const RooCmdArg& arg1=RooCmdArg::none(), const RooCmdArg& arg2=RooCmdArg::none(), const RooCmdArg& arg3=RooCmdArg::none(),const RooCmdArg& arg4=RooCmdArg::none(), const RooCmdArg& arg5=RooCmdArg::none(),const RooCmdArg& arg6=RooCmdArg::none(), const RooCmdArg& arg7=RooCmdArg::none(),const RooCmdArg& arg8=RooCmdArg::none()). RooCmdArg Title(const char* name); RooAbsRealLValue::frame arguments. RooCmdArg Bins(Int_t nbin). RooCmdArg AutoSymRange(const RooAbsData& data, Double_t marginFactor=0.1). RooCmdArg AutoRange(const RooAbsData& data, Double_t marginFactor=0.1). RooCmdArg AutoSymBinning(Int_t nbins=100, Double_t marginFactor=0.1); RooAbsData::createHistogram arguments. RooCmdArg AutoBinning(Int_t nbins=100, Double_t marginFactor=0.1). RooCmdArg IntegratedObservables(const RooArgSet& intObs); RooAbsReal::fillHistogram arguments. RooCmdArg SelectVars(const RooArgSet& vars); RooAbsData::reduce arguments. RooCmdArg EventRange(Int_t nStart, Int_t nStop). RooCmdArg FitOptions(const char* opts); RooAbsPdf::fitTo arguments. RooCmdArg Optimize(Bool_t flag=kTRUE). RooCmdArg ProjectedObservables(const RooArgSet& set). RooCmdArg ConditionalObservables(const RooArgSet& set). RooCmdArg Verbose(Bool_t flag=kTRUE). RooCmdArg Save(Bool_t flag=kTRUE). RooCmdArg Timer(Bool_t flag=kTRUE). RooCmdArg PrintLevel(Int_t code). RooCmdArg Warnings(Bool_t flag=kTRUE). RooCmdArg Strategy(Int_t code). RooCmdArg InitialHesse(Bool_t flag=kTRUE). RooCmdArg Hesse(Bool_t flag=kTRUE). RooCmdArg Minos(Bool_t flag=kTRUE). RooCmdArg Minos(const RooArgSet& minosArgs). RooCmdArg SplitRange(Bool_t flag=kTRUE). RooCmdArg SumCoefRange(const char* rangeName). RooCmdArg Constrain(const RooArgSet& params). RooCmdArg Constrained(). RooCmdArg ExternalConstraints(const RooArgSet& constraintPdfs). RooCmdArg PrintEvalErrors(Int_t numErrors). RooCmdArg EvalErrorWall(Bool_t flag). RooCmdArg SumW2Er",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFit.html:22678,reduce,reduce,22678,root/html526/RooFit.html,https://root.cern,https://root.cern/root/html526/RooFit.html,3,['reduce'],['reduce']
Energy Efficiency,"utputFile(const char* fileName). RooCmdArg Format(const char* format, Int_t sigDigit). RooCmdArg Format(const char* what, const RooCmdArg& arg1=RooCmdArg::none(), const RooCmdArg& arg2=RooCmdArg::none(), const RooCmdArg& arg3=RooCmdArg::none(),const RooCmdArg& arg4=RooCmdArg::none(), const RooCmdArg& arg5=RooCmdArg::none(),const RooCmdArg& arg6=RooCmdArg::none(), const RooCmdArg& arg7=RooCmdArg::none(),const RooCmdArg& arg8=RooCmdArg::none()). RooCmdArg Title(const char* name); RooAbsRealLValue::frame arguments. RooCmdArg Bins(Int_t nbin). RooCmdArg AutoSymRange(const RooAbsData& data, Double_t marginFactor=0.1). RooCmdArg AutoRange(const RooAbsData& data, Double_t marginFactor=0.1). RooCmdArg AutoSymBinning(Int_t nbins=100, Double_t marginFactor=0.1); RooAbsData::createHistogram arguments. RooCmdArg AutoBinning(Int_t nbins=100, Double_t marginFactor=0.1). RooCmdArg IntegratedObservables(const RooArgSet& intObs); RooAbsReal::fillHistogram arguments. RooCmdArg SelectVars(const RooArgSet& vars); RooAbsData::reduce arguments. RooCmdArg EventRange(Int_t nStart, Int_t nStop). RooCmdArg FitOptions(const char* opts); RooAbsPdf::fitTo arguments. RooCmdArg Optimize(Int_t flag=2). RooCmdArg ProjectedObservables(const RooArgSet& set). RooCmdArg ConditionalObservables(const RooArgSet& set). RooCmdArg Verbose(Bool_t flag=kTRUE). RooCmdArg Save(Bool_t flag=kTRUE). RooCmdArg Timer(Bool_t flag=kTRUE). RooCmdArg PrintLevel(Int_t code). RooCmdArg Warnings(Bool_t flag=kTRUE). RooCmdArg Strategy(Int_t code). RooCmdArg InitialHesse(Bool_t flag=kTRUE). RooCmdArg Hesse(Bool_t flag=kTRUE). RooCmdArg Minos(Bool_t flag=kTRUE). RooCmdArg Minos(const RooArgSet& minosArgs). RooCmdArg SplitRange(Bool_t flag=kTRUE). RooCmdArg SumCoefRange(const char* rangeName). RooCmdArg Constrain(const RooArgSet& params). RooCmdArg Constrained(). RooCmdArg ExternalConstraints(const RooArgSet& constraintPdfs). RooCmdArg PrintEvalErrors(Int_t numErrors). RooCmdArg EvalErrorWall(Bool_t flag). RooCmdArg SumW2Error(B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFit.html:23676,reduce,reduce,23676,root/html532/RooFit.html,https://root.cern,https://root.cern/root/html532/RooFit.html,2,['reduce'],['reduce']
Energy Efficiency,"utputFile(const char* fileName). RooCmdArg Format(const char* format, Int_t sigDigit). RooCmdArg Format(const char* what, const RooCmdArg& arg1=RooCmdArg::none(), const RooCmdArg& arg2=RooCmdArg::none(), const RooCmdArg& arg3=RooCmdArg::none(),const RooCmdArg& arg4=RooCmdArg::none(), const RooCmdArg& arg5=RooCmdArg::none(),const RooCmdArg& arg6=RooCmdArg::none(), const RooCmdArg& arg7=RooCmdArg::none(),const RooCmdArg& arg8=RooCmdArg::none()). RooCmdArg Title(const char* name); RooAbsRealLValue::frame arguments. RooCmdArg Bins(Int_t nbin). RooCmdArg AutoSymRange(const RooAbsData& data, Double_t marginFactor=0.1). RooCmdArg AutoRange(const RooAbsData& data, Double_t marginFactor=0.1). RooCmdArg AutoSymBinning(Int_t nbins=100, Double_t marginFactor=0.1); RooAbsData::createHistogram arguments. RooCmdArg AutoBinning(Int_t nbins=100, Double_t marginFactor=0.1). RooCmdArg IntegratedObservables(const RooArgSet& intObs); RooAbsReal::fillHistogram arguments. RooCmdArg SelectVars(const RooArgSet& vars); RooAbsData::reduce arguments. RooCmdArg EventRange(Int_t nStart, Int_t nStop). RooCmdArg FitOptions(const char* opts); RooAbsPdf::fitTo arguments. RooCmdArg Optimize(Int_t flag=2). RooCmdArg ProjectedObservables(const RooArgSet& set). RooCmdArg ConditionalObservables(const RooArgSet& set). RooCmdArg Verbose(Bool_t flag=kTRUE). RooCmdArg Save(Bool_t flag=kTRUE). RooCmdArg Timer(Bool_t flag=kTRUE). RooCmdArg PrintLevel(Int_t code). RooCmdArg Warnings(Bool_t flag=kTRUE). RooCmdArg Strategy(Int_t code). RooCmdArg InitialHesse(Bool_t flag=kTRUE). RooCmdArg Hesse(Bool_t flag=kTRUE). RooCmdArg Minos(Bool_t flag=kTRUE). RooCmdArg Minos(const RooArgSet& minosArgs). RooCmdArg SplitRange(Bool_t flag=kTRUE). RooCmdArg SumCoefRange(const char* rangeName). RooCmdArg Constrain(const RooArgSet& params). RooCmdArg GlobalObservables(const RooArgSet& globs). RooCmdArg GlobalObservablesTag(const char* tagName). RooCmdArg Constrained(). RooCmdArg ExternalConstraints(const RooArgSet& constraintPdfs)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFit.html:25237,reduce,reduce,25237,root/html534/RooFit.html,https://root.cern,https://root.cern/root/html534/RooFit.html,2,['reduce'],['reduce']
Energy Efficiency,"utsch; 24 <ghost@aladdin.com>. Other authors are noted in the change history; 25 that follows (in reverse chronological order):; 26 ; 27 2002-04-13 lpd Removed support for non-ANSI compilers; removed; 28 references to Ghostscript; clarified derivation from RFC 1321;; 29 now handles byte order either statically or dynamically.; 30 1999-11-04 lpd Edited comments slightly for automatic TOC extraction.; 31 1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5);; 32 added conditionalization for C++ compilation from Martin; 33 Purschke <purschke@bnl.gov>.; 34 1999-05-03 lpd Original version.; 35 */; 36 ; 37#if !defined(md5_INCLUDED); 38#define md5_INCLUDED; 39 ; 40/*; 41 * This package supports both compile-time and run-time determination of CPU; 42 * byte order. If ARCH_IS_BIG_ENDIAN is defined as 0, the code will be; 43 * compiled to run only on little-endian CPUs; if ARCH_IS_BIG_ENDIAN is; 44 * defined as non-zero, the code will be compiled to run only on big-endian; 45 * CPUs; if ARCH_IS_BIG_ENDIAN is not defined, the code will be compiled to; 46 * run on either big- or little-endian CPUs, but will run slightly less; 47 * efficiently on either one than if ARCH_IS_BIG_ENDIAN is defined.; 48 */; 49 ; 50typedef unsigned char md5_byte_t; /* 8-bit byte */; 51typedef unsigned int md5_word_t; /* 32-bit word */; 52 ; 53/* Define the state of the MD5 Algorithm. */; 54typedef struct md5_state_s {; 55 md5_word_t count[2]; /* message length in bits, lsw first */; 56 md5_word_t abcd[4]; /* digest buffer */; 57 md5_byte_t buf[64]; /* accumulate block */; 58} md5_state_t;; 59 ; 60#if defined(__cplusplus); 61extern ""C"" {; 62#endif; 63 ; 64/* Initialize the algorithm. */; 65MD5_STATIC void md5_init(md5_state_t *pms);; 66 ; 67/* Append a string to the message. */; 68MD5_STATIC void; 69md5_append(md5_state_t *pms, const md5_byte_t *data, size_t nbytes);; 70 ; 71/* Finish the message and return the digest. */; 72MD5_STATIC void md5_finish(md5_state_t *pms, md5_byte_t diges",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md5_8inl_source.html:2149,efficient,efficiently,2149,doc/master/md5_8inl_source.html,https://root.cern,https://root.cern/doc/master/md5_8inl_source.html,1,['efficient'],['efficiently']
Energy Efficiency,"utside [0,1] on line %d of %s "", r,; 2640 nLines, fileName.Data());; 2641 f.close();; 2642 return -1;; 2643 }; 2644 if (g < 0. || g > 1.) {; 2645 ::Error(""TColor::CreateColorPalette(const TString)"", ""Green value %f outside [0,1] on line %d of %s "", g,; 2646 nLines, fileName.Data());; 2647 f.close();; 2648 return -1;; 2649 }; 2650 if (b < 0. || b > 1.) {; 2651 ::Error(""TColor::CreateColorPalette(const TString)"", ""Blue value %f outside [0,1] on line %d of %s "", b,; 2652 nLines, fileName.Data());; 2653 f.close();; 2654 return -1;; 2655 }; 2656 reds.emplace_back(r);; 2657 greens.emplace_back(g);; 2658 blues.emplace_back(b);; 2659 }; 2660 f.close();; 2661 if (nLines < 2) {; 2662 ::Error(""TColor::CreateColorPalette(const TString)"", ""Found insufficient color lines (%d) on %s"", nLines,; 2663 fileName.Data());; 2664 return -1;; 2665 }; 2666 ; 2667 TColor::InitializeColors();; 2668 Int_t *palette = new Int_t[nLines];; 2669 ; 2670 for (Int_t i = 0; i < nLines; ++i) {; 2671 new TColor(reds.at(i), greens.at(i), blues.at(i), alpha);; 2672 palette[i] = gHighestColorIndex;; 2673 }; 2674 TColor::SetPalette(nLines, palette);; 2675 delete[] palette;; 2676 return gHighestColorIndex + 1 - nLines;; 2677}; 2678 ; 2679////////////////////////////////////////////////////////////////////////////////; 2680/// Static function creating a color table with several connected linear gradients.; 2681///; 2682/// - Number: The number of end point colors that will form the gradients.; 2683/// Must be at least 2.; 2684/// - Stops: Where in the whole table the end point colors should lie.; 2685/// Each entry must be on [0, 1], each entry must be greater than; 2686/// the previous entry.; 2687/// - Red, Green, Blue: The end point color values.; 2688/// Each entry must be on [0, 1]; 2689/// - NColors: Total number of colors in the table. Must be at least 1.; 2690/// - alpha: the opacity factor, between 0 and 1. Default is no transparency (1).; 2691/// - setPalette: activate the newly created palette (true",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:96905,green,greens,96905,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['greens']
Energy Efficiency,"v_BetweenClass( void ); the matrix of covariance 'between class' reflects the dispersion of the; events of a class relative to the global center of gravity of all the class; hence the separation between classes. void GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". EFisherMethod GetFisherMethod( void ); { return fFisherMethod; }. » Author: Andreas Hoecker, Xavier Prudent, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ »",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodFisher.html:21436,power,power,21436,root/html534/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodFisher.html,2,['power'],['power']
Energy Efficiency,"v_BetweenClass( void ); the matrix of covariance 'between class' reflects the dispersion of the; events of a class relative to the global center of gravity of all the class; hence the separation between classes. void GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". EFisherMethod GetFisherMethod( void ); { return fFisherMethod; }. » Author: Andreas Hoecker, Xavier Prudent, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodFisher.html:20753,power,power,20753,root/html528/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodFisher.html,4,['power'],['power']
Energy Efficiency,"v_BetweenClass( void ); the matrix of covariance 'between class' reflects the dispersion of the; events of a class relative to the global center of gravity of all the class; hence the separation between classes. void GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0). EFisherMethod GetFisherMethod( void ); { retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodFisher.html:22672,power,power,22672,root/html602/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodFisher.html,4,['power'],['power']
Energy Efficiency,"values for tensor tensor_0bias"");; }; f.close();; ; //---- allocate the intermediate dynamic tensors; //--- broadcast bias tensor 0biasfor Gemm op; {; float * data = TMVA::Experimental::SOFIE::UTILITY::UnidirectionalBroadcast<float>(tensor_0bias,{ 16 }, { 2 , 16 });; std::copy(data, data + 32, tensor_0biasbcast);; delete [] data;; }; //--- broadcast bias tensor 2biasfor Gemm op; {; float * data = TMVA::Experimental::SOFIE::UTILITY::UnidirectionalBroadcast<float>(tensor_2bias,{ 8 }, { 2 , 8 });; std::copy(data, data + 16, tensor_2biasbcast);; delete [] data;; }; }; ; std::vector<float> infer(float* tensor_input1){; ; //--------- Gemm; char op_0_transA = 'n';; char op_0_transB = 't';; int op_0_m = 2;; int op_0_n = 16;; int op_0_k = 32;; float op_0_alpha = 1;; float op_0_beta = 1;; int op_0_lda = 32;; int op_0_ldb = 32;; std::copy(tensor_0biasbcast, tensor_0biasbcast + 32, tensor_input0);; BLAS::sgemm_(&op_0_transB, &op_0_transA, &op_0_n, &op_0_m, &op_0_k, &op_0_alpha, tensor_0weight, &op_0_ldb, tensor_input1, &op_0_lda, &op_0_beta, tensor_input0, &op_0_n);; ; //------ RELU; for (int id = 0; id < 32 ; id++){; tensor_result[id] = ((tensor_input0[id] > 0 )? tensor_input0[id] : 0);; }; ; //--------- Gemm; char op_2_transA = 'n';; char op_2_transB = 't';; int op_2_m = 2;; int op_2_n = 8;; int op_2_k = 16;; float op_2_alpha = 1;; float op_2_beta = 1;; int op_2_lda = 16;; int op_2_ldb = 16;; std::copy(tensor_2biasbcast, tensor_2biasbcast + 16, tensor_input2);; BLAS::sgemm_(&op_2_transB, &op_2_transA, &op_2_n, &op_2_m, &op_2_k, &op_2_alpha, tensor_2weight, &op_2_ldb, tensor_result, &op_2_lda, &op_2_beta, tensor_input2, &op_2_n);; ; //------ RELU; for (int id = 0; id < 16 ; id++){; tensor_result3[id] = ((tensor_input2[id] > 0 )? tensor_input2[id] : 0);; }; return fTensor_result3;; }; }; // end of Session; } //TMVA_SOFIE_PyTorchModel; ; #endif // ROOT_TMVA_SOFIE_PYTORCHMODEL; AuthorSanjiban Sengupta ; Definition in file TMVA_SOFIE_PyTorch.C. tutorialstmvaTMVA_SOFIE_PyTorch.C. RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html:10237,allocate,allocate,10237,doc/master/TMVA__SOFIE__PyTorch_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html,1,['allocate'],['allocate']
Energy Efficiency,"values. ; Definition at line 71 of file PtEtaPhiM4D.h. ◆ PtEtaPhiM4D() [3/4]. template<class ScalarType > . template<class CoordSystem > . constexpr ROOT::Math::PtEtaPhiM4D< ScalarType >::PtEtaPhiM4D ; (; const CoordSystem & ; c). inlineexplicitconstexpr . Generic constructor from any 4D coordinate system implementing Pt(), Eta(), Phi() and M() ; Definition at line 82 of file PtEtaPhiM4D.h. ◆ PtEtaPhiM4D() [4/4]. template<class ScalarType > . ROOT::Math::PtEtaPhiM4D< ScalarType >::PtEtaPhiM4D ; (; const PtEtaPhiM4D< ScalarType > & ; v). inline . copy constructor ; Definition at line 91 of file PtEtaPhiM4D.h. Member Function Documentation. ◆ E(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::E ; (; ); const. inline . Energy (timelike component of momentum-energy 4-vector) ; Definition at line 198 of file PtEtaPhiM4D.h. ◆ E2(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::E2 ; (; ); const. inline . energy squared ; Definition at line 189 of file PtEtaPhiM4D.h. ◆ Et(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::Et ; (; ); const. inline . transverse energy ; Definition at line 250 of file PtEtaPhiM4D.h. ◆ Et2(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::Et2 ; (; ); const. inline . transverse energy squared ; Definition at line 241 of file PtEtaPhiM4D.h. ◆ Eta(). template<class ScalarType > . Scalar ROOT::Math::PtEtaPhiM4D< ScalarType >::Eta ; (; ); const. inline . Definition at line 142 of file PtEtaPhiM4D.h. ◆ GetCoordinates() [1/2]. template<class ScalarType > . void ROOT::Math::PtEtaPhiM4D< ScalarType >::GetCoordinates ; (; Scalar & ; pt, . Scalar & ; eta, . Scalar & ; phi, . Scalar & ; mass . ); const. inline . get internal data into 4 Scalar numbers ; Definition at line 134 of file PtEtaPhiM4D.h. ◆ GetCoordinates() [2/2]. template<class ScalarType > . void ROOT::Math::PtEtaPhiM4D< ScalarType >::GetCoordinates ; (; Scalar ; dest[]); const. i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1PtEtaPhiM4D.html:6154,energy,energy,6154,doc/master/classROOT_1_1Math_1_1PtEtaPhiM4D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1PtEtaPhiM4D.html,1,['energy'],['energy']
Energy Efficiency,"vantage of a pool of worker threads. **Each worker thread processes a distinct; 899subset of entries**, and their partial results are merged before returning the final values to the user.; 900There are no guarantees on the order in which threads will process the batches of entries.; 901In particular, note that this means that, for multi-thread event loops, there is no; 902guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; 903 ; 904\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 905a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 906~~~{.cpp}; 907ROOT::EnableImplicitMT(i); 908~~~; 909replacing `i` with the number of CPUs/slots that were allocated for this job.; 910 ; 911### Thread-safety of user-defined expressions; 912RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 913User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 914will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 915 ; 916Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 917expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 918which eliminates all risks of race conditions.; 919 ; 920In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 921offer thread-aware counterp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:51394,allocate,allocated,51394,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"vantage of a pool of worker threads. **Each worker thread processes a distinct; 939subset of entries**, and their partial results are merged before returning the final values to the user.; 940There are no guarantees on the order in which threads will process the batches of entries.; 941In particular, note that this means that, for multi-thread event loops, there is no; 942guarantee on the order in which Snapshot() will _write_ entries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; 943 ; 944\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 945a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 946~~~{.cpp}; 947ROOT::EnableImplicitMT(i); 948~~~; 949replacing `i` with the number of CPUs/slots that were allocated for this job.; 950 ; 951### Thread-safety of user-defined expressions; 952RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 953User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 954will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 955 ; 956Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 957expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 958which eliminates all risks of race conditions.; 959 ; 960In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 961offer thread-aware counterp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:53034,allocate,allocated,53034,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"vas *c = (TCanvas*)gROOT->GetListOfCanvases()->FindObject(cname);; if (c) c->cd();; else c = new TCanvas(cname, """",800,600);; top->Draw();; // top->RandomRays(0,0,0,0,sensor->GetName());; // Track random ""particles"" coming from the block side and draw only the tracklets; // actually crossing one of the sensors. Note that some of the tracks coming; // from the outer side may see the full sensor, while the others only part of it.; TStopwatch timer;; timer.Start();; top->RandomRays(100000,0,0,-30,sensor->GetName());; timer.Stop();; timer.Print();; TView3D *view = (TView3D*)gPad->GetView();; if (view) {; view->SetParallel();; view->Side();; }; if (usepw) pw->PrintDetectedOverlaps();; }; ; //______________________________________________________________________________; void align(); {; // Aligning 2 sensors so they will overlap with the support. One sensor is positioned; // normally while the other using the shared matrix; TGeoPhysicalNode *node;; TGeoParallelWorld *pw = gGeoManager->GetParallelWorld();; Double_t sag;; for (Int_t i=0; i<10; i++) {; node = gGeoManager->MakePhysicalNode(TString::Format(""/TOP_1/chip_%d"",i+1));; sag = 8.-0.494*(i-4.5)*(i-4.5);; TGeoTranslation *tr = new TGeoTranslation(0., -225.+50.*i, 10-sag);; node->Align(tr);; if (pw) pw->AddNode(TString::Format(""/TOP_1/chip_%d"",i+1));; }; }; c#define c(i)Definition RSha256.hxx:101; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; cnameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/parallel__world_8C.html:3793,sensor,sensor,3793,doc/master/parallel__world_8C.html,https://root.cern,https://root.cern/doc/master/parallel__world_8C.html,1,['sensor'],['sensor']
Energy Efficiency,"vates the pad editor, etc.; The algorithm in use is simple and is based on the object-oriented relationship and communication. When the user activates the editor, according to the selected object <obj> in the canvas it looks for a class name <obj>Editor. For that reason, the correct naming is very important. If a class with this name is found, the editor verifies that this class derives from the base editor class TGedFrame. If all checks are satisfied, the editor makes an instance of the object editor. Then, it scans all object base classes searching the corresponding object editors. When it finds one, it makes an instance of the base class editor too.; Once the object editor is in place, it sets the user interface elements according to the object’s status. After that, it is ready to interact with the object following the user actions.; The graphics editor gives an intuitive way to edit objects in a canvas with immediate feedback. Complexity of some object editors is reduced by hiding GUI elements and revealing them only on users’ requests.; An object in the canvas is selected by clicking on it with the left mouse button. Its name is displayed on the top of the editor frame in red color. If the editor frame needs more space than the canvas window, a vertical scroll bar appears for easy navigation. Histogram, pad and axis editors. 25.9.2 Editor Design Elements; The next rules describe the path to follow when creating your own object editor that will be recognized and loaded by the graphics editor in ROOT, i.e. it will be included as a part of it. Derive the code of your object editor from the base editor class TGedFrame.; Keep the correct naming convention: the name of the object editor should be the object class name concatenated with the word ‘Editor'.; Provide a default constructor.; Use the signals/slots communication mechanism for event processing.; Implement the virtual method SetModel(TObject *obj) where all widgets are set with the current object’s attributes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1223123,reduce,reduced,1223123,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['reduce'],['reduced']
Energy Efficiency,"ve Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html:5814,adapt,adaptive,5814,root/html528/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html,20,['adapt'],['adaptive']
Energy Efficiency,"ve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ). const Event* Transform(const TMVA::Event *const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event *const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. void ToggleInputSortOrder(Bool_t sortOrder); { fSortGet = sortOrder; }. void SetOu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__VariableTransformBase.html:10052,adapt,adapt,10052,root/html530/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html530/TMVA__VariableTransformBase.html,3,['adapt'],['adapt']
Energy Efficiency,"ve at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(IParamFunction & f, double x, const double * p, unsigned int ipar = 0, double h = 1E-8",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Derivator.html:4597,adapt,adaptive,4597,root/html526/ROOT__Math__Derivator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Derivator.html,1,['adapt'],['adaptive']
Energy Efficiency,"ve at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__Derivator.html:4597,adapt,adaptive,4597,root/html528/ROOT__Math__Derivator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__Derivator.html,6,['adapt'],['adaptive']
Energy Efficiency,"ve* wrk, TMessage* m, Bool_t deactonfail = kFALSE); Analyze the received message.; Returns 0 on success (1 if this the last message from this socket), -1 if; any failure occurs. void HandleSubmerger(TMessage* mess, TSlave* sl); Process a message of type kPROOF_SUBMERGER. void RedirectWorker(TSocket* s, TSlave* sl, Int_t output_size); Redirect output of worker sl to some merger. Int_t FindNextFreeMerger(); Return a merger, which is both active and still accepts some workers to be; assigned to it. It works on the 'round-robin' basis. void AskForOutput(TSlave* sl); Master asks for output from worker sl. void UpdateDialog(); Final update of the progress dialog. void ActivateAsyncInput(); Activate the a-sync input handler. void DeActivateAsyncInput(); De-activate a-sync input handler. Int_t GetActiveMergersCount(); Get the active mergers count. Bool_t CreateMerger(TSlave* sl, Int_t port); Create a new merger. void MarkBad(TSlave* wrk, const char* reason = 0); Add a bad slave server to the bad slave list and remove it from; the active list and from the two monitor objects. Assume that the work; done by this worker was lost and ask packerizer to reassign it. void MarkBad(TSocket* s, const char* reason = 0); Add slave with socket s to the bad slave list and remove if from; the active list and from the two monitor objects. void TerminateWorker(TSlave* wrk); Ask an active worker 'wrk' to terminate, i.e. to shutdown. void TerminateWorker(const char* ord); Ask an active worker 'ord' to terminate, i.e. to shutdown. Int_t Ping(); Ping PROOF. Returns 1 if master server responded. Int_t Ping(TProof::ESlaves list); Ping PROOF slaves. Returns the number of slaves that responded. void Touch(); Ping PROOF slaves. Returns the number of slaves that responded. void Print(Option_t* option = """") const; Print status of PROOF cluster. Int_t HandleOutputOptions(TString& opt, TString& target, Int_t action); Extract from opt information about output handling settings.; The understood keywords ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:48529,monitor,monitor,48529,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,6,['monitor'],['monitor']
Energy Efficiency,"ve* wrk, TMessage* m, Bool_t deactonfail = kFALSE); Analyze the received message.; Returns 0 on success (1 if this the last message from this socket), -1 if; any failure occurs. void HandleSubmerger(TMessage* mess, TSlave* sl); Process a message of type kPROOF_SUBMERGER. void RedirectWorker(TSocket* s, TSlave* sl, Int_t output_size); Redirect output of worker sl to some merger. Int_t FindNextFreeMerger(); Return a merger, which is both active and still accepts some workers to be; assigned to it. It works on the 'round-robin' basis. void AskForOutput(TSlave* sl); Master asks for output from worker sl. void UpdateDialog(); Final update of the progress dialog. void ActivateAsyncInput(); Activate the a-sync input handler. void DeActivateAsyncInput(); De-activate a-sync input handler. Int_t GetActiveMergersCount(); Get the active mergers count. Bool_t CreateMerger(TSlave* sl, Int_t port); Create a new merger. void MarkBad(TSlave* wrk, const char* reason = 0); Add a bad slave server to the bad slave list and remove it from; the active list and from the two monitor objects. Assume that the work; done by this worker was lost and ask packerizer to reassign it. void MarkBad(TSocket* s, const char* reason = 0); Add slave with socket s to the bad slave list and remove if from; the active list and from the two monitor objects. void TerminateWorker(TSlave* wrk); Ask an active worker 'wrk' to terminate, i.e. to shutdown. void TerminateWorker(const char* ord); Ask an active worker 'ord' to terminate, i.e. to shutdown. Int_t Ping(); Ping PROOF. Returns 1 if master server responded. Int_t Ping(TProof::ESlaves list); Ping PROOF slaves. Returns the number of slaves that responded. void Touch(); Ping PROOF slaves. Returns the number of slaves that responded. void Print(Option_t* option = """") const; Print status of PROOF cluster. Long64_t Process(TDSet* dset, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TDSet) using th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:44404,monitor,monitor,44404,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['monitor'],['monitor']
Energy Efficiency,"veVectorD &s, const TEveVectorD &r, Double_t rMagInv, TEveVectorD &c);  Get closest point from given vertex v to line segment defined with s and r. ;  ; Bool_t HelixIntersectPlane (const TEveVectorD &p, const TEveVectorD &point, const TEveVectorD &normal, TEveVectorD &itsect);  Intersect helix with a plane. ;  ; Bool_t LineIntersectPlane (const TEveVectorD &p, const TEveVectorD &point, const TEveVectorD &normal, TEveVectorD &itsect);  Intersect line with a plane. ;  ; void LineToBounds (TEveVectorD &p);  Propagate neutral particle with momentum p to bounds. ;  ; Bool_t LineToVertex (TEveVectorD &v);  Propagate neutral particle to vertex v. ;  ; void LoopToBounds (TEveVectorD &p);  Propagate charged particle with momentum p to bounds. ;  ; Bool_t LoopToLineSegment (const TEveVectorD &s, const TEveVectorD &r, TEveVectorD &p);  Propagate charged particle with momentum p to line segment with point s and vector r to the second point. ;  ; Bool_t LoopToVertex (TEveVectorD &v, TEveVectorD &p);  Propagate charged particle with momentum p to vertex v. ;  ; Bool_t PointOverVertex (const TEveVector4D &v0, const TEveVector4D &v, Double_t *p=nullptr);  ; void RebuildTracks ();  Rebuild all tracks using this render-style. ;  ; void Step (const TEveVector4D &v, const TEveVectorD &p, TEveVector4D &vOut, TEveVectorD &pOut);  Wrapper to step helix. ;  ; void StepRungeKutta (Double_t step, Double_t *vect, Double_t *vout);  Wrapper to step with method RungeKutta. ;  ; void Update (const TEveVector4D &v, const TEveVectorD &p, Bool_t full_update=kFALSE, Bool_t enforce_max_step=kFALSE);  Update helix / B-field projection state. ;  ;  Protected Member Functions inherited from TEveElement; virtual void AnnihilateRecursively ();  Protected member function called from TEveElement::Annihilate(). ;  ; virtual void PreDeleteElement ();  Externally assigned and controlled user data. ;  ; virtual void RemoveElementsInternal ();  Remove all elements. ;  ;  Protected Member Functions inherited from ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTrackPropagator.html:38859,charge,charged,38859,doc/master/classTEveTrackPropagator.html,https://root.cern,https://root.cern/doc/master/classTEveTrackPropagator.html,1,['charge'],['charged']
Energy Efficiency,"vector<Double_t> >*_weights!; vector<std::vector<Double_t> >_weights0; vector<std::vector<Double_t> >_weights1; Double_t_widthFactor; vector<Double_t>_x; vector<Double_t>_x0; vector<Double_t>_x1; vector<Double_t>_x2; vector<Double_t>_xDatHi; vector<Double_t>_xDatHi3s; vector<Double_t>_xDatLo; vector<Double_t>_xDatLo3s; vector<Double_t>_xVarHi; vector<Double_t>_xVarHiM3s; vector<Double_t>_xVarHiP3s; vector<Double_t>_xVarLo; vector<Double_t>_xVarLoM3s; vector<Double_t>_xVarLoP3s; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNDKeysPdf(const char* name, const char* title, const RooArgList& varList, RooDataSet& data, TString options = ""a"", Double_t rho = 1, Double_t nSigma = 3, Bool_t rotate = kTRUE); Construct N-dimensional kernel estimation p.d.f. in observables 'varList'; from dataset 'data'. Options can be. 'a' = Use adaptive kernels (width varies with local event density); 'm' = Mirror data points over observable boundaries. Improves modeling; behavior at edges for distributions that are not close to zero; at edge; 'd' = Debug flag; 'v' = Verbose flag. The parameter rho (default = 1) provides an overall scale factor that can; be applied to the bandwith calculated for each kernel. The nSigma parameter; determines the size of the box that is used to search for contributing kernels; around a given point in observable space. The nSigma parameters is used; in case of non-adaptive bandwidths and for the 1st non-adaptive pass for; the calculation of adaptive keys p.d.f.s. The optional weight arguments allows to specify an observable or function; expression in observables that specifies the weight of each event. RooNDKeysPdf(const char* name, const char* title, const RooArgList& varList, RooDataSet& data, const TVectorD& rho, TString options = ""a"", Double_t nSigma = 3, Bool_t rotate = kTRUE); Constructor. RooNDKeysPdf(const char* name, const char* title,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNDKeysPdf.html:47085,adapt,adaptive,47085,root/html534/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html534/RooNDKeysPdf.html,2,['adapt'],['adaptive']
Energy Efficiency,"ved; classes:; THnD (typedef for THnT<Double_t>): bin content held by a Double_t,; THnF (typedef for THnT<Float_t>): bin content held by a Float_t,; THnL (typedef for THnT<Long_t>): bin content held by a Long_t,; THnI (typedef for THnT<Int_t>): bin content held by an Int_t,; THnS (typedef for THnT<Short_t>): bin content held by a Short_t,; THnC (typedef for THnT<Char_t>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2F h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnF hn(""hn"", ""hn"", 2, bins, min, max);. * Filling; A THn is filled just like a regular histogram, using; THn::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Storage is allocated when the first bin content is stored. * Projections; The dimensionality of a THn can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THn. See the Projection() members. To only project parts of the; histogram, call; hn->GetAxis(12)->SetRange(from_bin, to_bin);. * Conversion from other histogram classes; The static factory function THn::CreateHn() can be used to create a THn; from a TH1, TH2, TH3, THnSparse and (for copying) even from a THn. The; created THn will have compatble storage type, i.e. calling CreateHn() on; a TH2F will create a THnF. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THn(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidAddBinContent(const Int_t* idx, Double_t v = 1.);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THn.html:1721,allocate,allocated,1721,root/html534/THn.html,https://root.cern,https://root.cern/root/html534/THn.html,6,['allocate'],['allocated']
Energy Efficiency,"vely. ; [in]maxptsMaximum number of function evaluations to be allowed. maxpts >= 2^n +2*n*(n+1) +1 if maxpts<minpts, maxpts is set to 10*minpts ; [in]epsrelSpecified relative accuracy. ; [in]epsabsSpecified absolute accuracy. The integration algorithm will attempt to reach either the relative or the absolute accuracy. In case the maximum function called is reached the algorithm will stop earlier without having reached the desired accuracy; [out]relerrContains, on exit, an estimation of the relative accuracy of the result. ; [out]nfnevlnumber of function evaluations performed. ; [out]ifail0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the specified value of maxpts.; 3 n<2 or n>15 . Method:; The default method used is the Genz-Mallik adaptive multidimensional algorithm using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator() to different integrators. Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class Possible methods are : Vegas, Miser or Plain IN case of MC integration the accuracy is determined by the number of function calls, one should be careful not to use a too large value of maxpts ; Definition at line 2851 of file TF1.cxx. ◆ IntegralMultiple() [3/3]. virtual Double_t TF1::IntegralMultiple ; (; Int_t ; n, . const Double_t * ; a, . const Double_t * ; b, . Int_t ; , . Int_t ; maxpts, . Double_t ; epsrel, . Double_t & ; relerr, . Int_t & ; nfnevl, . Int_t & ; ifail . ). inlinevirtual . Definition at line 616 of file TF1.h. ◆ IntegralOneDim(). Double_t TF1::IntegralOneDim ; (; Double_t ; a, . Double_t ; b, . Double_t ; epsrel, . Double_t ; epsabs, . Double_t & ; error . ). virtual . Return Integral of function between a and b using",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:100375,adapt,adaptive,100375,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['adapt'],['adaptive']
Energy Efficiency,"vent used to fill tree; TH2D*fProcTimeHist!histogram of real time spent processing packets; Int_tfSlaves!number of active slaves; Long64_tfTotBytesRead!total bytes read on all slaves; Double_tfTotCpuTime!total cpu time of all slaves; Long64_tfTotEvents!total number of events processed; TTree*fTrace!TTree with trace events; TTimeStampfTzero!start time of this run; static Long_tfgResMemMax! Max resident memory used by this process; static Long_tfgVirtMemMax! Max virtual memory used by this process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPerfStats(TList* input, TList* output); Normal constructor. ~TPerfStats(); Destructor. void SimpleEvent(TVirtualPerfStats::EEventType type); Simple event. void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); Packet event.; See WriteQueryLog for the descripition of the structure sent for monitoring; when fMonitorPerPacket is kTRUE. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void FileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); Record TTree file unzip event.; start is the TimeStamp before unzip; pos is where in the file the compressed buffer came from; complen is the length of the compressed buffer; objlen is the length of the de-compressed buffer. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long64_t GetBytesRead() const; Get number of bytes read. void WriteQueryLog(); Send to the connected monitoring servers information related to this query.; The",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPerfStats.html:8548,monitor,monitoring,8548,root/html532/TPerfStats.html,https://root.cern,https://root.cern/root/html532/TPerfStats.html,2,['monitor'],['monitoring']
Energy Efficiency,"vents from CMS OpenData containing muon candidates part of 2012 dataset (DOI: 10.7483/OPENDATA.CMS.YLIC.86ZZ and DOI: 10.7483/OPENDATA.CMS.M5AD.Y3V3). The macro matches muon pairs and produces an histogram of the dimuon mass spectrum showing resonances up to the Z mass. Note that the bump at 30 GeV is not a resonance but a trigger effect.; More details about the dataset can be found on the CERN Open Data portal. ; #include ""ROOT/RDataFrame.hxx""; #include ""ROOT/RDFHelpers.hxx""; #include ""ROOT/RVec.hxx""; #include ""TCanvas.h""; #include ""TH1D.h""; #include ""TLatex.h""; #include ""TStyle.h""; ; using namespace ROOT::VecOps;; ; void df102_NanoAODDimuonAnalysis(); {; // Enable multi-threading; ROOT::EnableImplicitMT();; ; // Create dataframe from NanoAOD files; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/opendata/cms/derived-data/AOD2NanoAODOutreachTool/""; ""Run2012BC_DoubleMuParked_Muons.root"");; ; // Add ProgressBar; ROOT::RDF::Experimental::AddProgressBar(df);; ; // For simplicity, select only events with exactly two muons and require opposite charge; auto df_2mu = df.Filter(""nMuon == 2"", ""Events with exactly two muons"");; auto df_os = df_2mu.Filter(""Muon_charge[0] != Muon_charge[1]"", ""Muons with opposite charge"");; ; // Compute invariant mass of the dimuon system; auto df_mass = df_os.Define(""Dimuon_mass"", InvariantMass<float>, {""Muon_pt"", ""Muon_eta"", ""Muon_phi"", ""Muon_mass""});; ; // Make histogram of dimuon mass spectrum. Note how we can set title and axis labels in one go; auto h = df_mass.Histo1D({""Dimuon_mass"", ""Dimuon mass;m_{#mu#mu} (GeV);N_{Events}"", 30000, 0.25, 300}, ""Dimuon_mass"");; ; // Request cut-flow report; auto report = df.Report();; ; // Produce plot; gStyle->SetOptStat(0); gStyle->SetTextFont(42);; auto c = new TCanvas(""c"", """", 800, 700);; c->SetLogx(); c->SetLogy();; ; h->GetXaxis()->SetTitleSize(0.04);; h->GetYaxis()->SetTitleSize(0.04);; h->DrawClone();; ; TLatex label; label.SetNDC(true);; label.DrawLatex(0.175, 0.740, ""#eta"");; label.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html:1518,charge,charge,1518,doc/master/df102__NanoAODDimuonAnalysis_8C.html,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html,1,['charge'],['charge']
Energy Efficiency,"ventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; trainingTree in the weight file, and to rebuild the binary tree in the; test phase from scratch. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); init the size of a volume element using a defined fraction of the; volume containing the entire events. const std::vector< Float_t >& GetRegressionValues(). void CalcAverages(); compute also average RMS values required for adaptive Gaussian. void CreateBinarySearchTree(TMVA::Types::ETreeType type); create binary search trees for signal and background. void SetVolumeElement( void ); defines volume dimensions. Double_t IGetVolumeContentForRoot(Double_t ); Interface to RootFinder. Double_t GetVolumeContentForRoot(Double_t ); count number of events in rescaled volume. void GetSample(const TMVA::Event& e, vector<const TMVA::BinarySearchTreeNode*,allocator<const TMVA::BinarySearchTreeNode*> >& events, TMVA::Volume* volume). Double_t CRScalc(const TMVA::Event& ). void RRScalc(const TMVA::Event& , vector<Float_t>* count). Double_t CKernelEstimate(const TMVA::Event& , vector<const TMVA::BinarySearchTreeNode*,allocator<const TMVA::BinarySearchTreeNode*> >& , TMVA::Volume& ); normalization factors so we can work with radius 1 hyperspheres. void RKernelEstimate(const TMVA::Event& , vector<const TMVA::BinarySearchTreeNode*,allocator<const TMVA::BinarySearchTreeNode*> >& , TMVA::Volume& , vecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodPDERS.html:21995,adapt,adaptive,21995,root/html528/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html,6,['adapt'],['adaptive']
Energy Efficiency,"ventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options specified by the user. void Train( void ); this is a dummy training: the preparation work to do is the construction; of the binary tree as a pointer chain. It is easier to directly save the; trainingTree in the weight file, and to rebuild the binary tree in the; test phase from scratch. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); init the size of a volume element using a defined fraction of the; volume containing the entire events. const std::vector< Float_t >& GetRegressionValues(). void CalcAverages(); compute also average RMS values required for adaptive Gaussian. void CreateBinarySearchTree(TMVA::Types::ETreeType type); create binary search trees for signal and background. void SetVolumeElement( void ); defines volume dimensions. Double_t IGetVolumeContentForRoot(Double_t ); Interface to RootFinder. Double_t GetVolumeContentForRoot(Double_t ); count number of events in rescaled volume. void GetSample(const TMVA::Event& e, vector<const TMVA::BinarySearchTreeNode*>& events, TMVA::Volume* volume). Double_t CRScalc(const TMVA::Event& ). void RRScalc(const TMVA::Event& , vector<Float_t>* count). Double_t CKernelEstimate(const TMVA::Event& , vector<const TMVA::BinarySearchTreeNode*>& , TMVA::Volume& ); normalization factors so we can work with radius 1 hyperspheres. void RKernelEstimate(const TMVA::Event& , vector<const TMVA::BinarySearchTreeNode*>& , TMVA::Volume& , vector<Float_t>* pdfSum); normalization factors so we can work with radius 1 hyperspheres. Double_t ApplyKernelFunction(Double_t normalized_dis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodPDERS.html:24362,adapt,adaptive,24362,root/html602/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodPDERS.html,4,['adapt'],['adaptive']
Energy Efficiency,"verall means. void GetCov_WithinClass( void ); the matrix of covariance 'within class' reflects the dispersion of the; events relative to the center of gravity of their own class. void GetCov_BetweenClass( void ); the matrix of covariance 'between class' reflects the dispersion of the; events of a class relative to the global center of gravity of all the class; hence the separation between classes. void GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". EFisherMethod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodFisher.html:20485,power,power,20485,root/html528/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodFisher.html,6,['power'],['power']
Energy Efficiency,"verall means. void GetCov_WithinClass( void ); the matrix of covariance 'within class' reflects the dispersion of the; events relative to the center of gravity of their own class. void GetCov_BetweenClass( void ); the matrix of covariance 'between class' reflects the dispersion of the; events of a class relative to the global center of gravity of all the class; hence the separation between classes. void GetCov_Full( void ); compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodFisher(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodFisher.html:22404,power,power,22404,root/html602/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodFisher.html,4,['power'],['power']
Energy Efficiency,"vertex v. Bool_t GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate particle with momentum p to line with start point s and vector r to the second point. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4D& v, const TEveVectorD& p, TEveVector4D& vOut, TEveVectorD& pOut); Wrapper to step helix. void LoopToBounds(TEveVectorD& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVectorD& v, TEveVectorD& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-update was called before. Bool_t LoopToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate charged particle with momentum p to line segment with point s and vector r to the second point.; It is expected that Update() with full-update was called before. Returns kFALSE if hits bounds. void DistributeOffset(const TEveVectorD& off, Int_t first_point, Int_t np, TEveVectorD& p); Distribute offset between first and last point index and rotate; momentum. Bool_t LineToVertex(TEveVectorD& v); Propagate neutral particle to vertex v. void LineToBounds(TEveVectorD& p); Propagatate neutral particle with momentum p to bounds. Bool_t HelixIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Intersect helix with a plane. Current position and argument p define; the helix. Bool_t LineIntersectPlane(const TEveVectorD& p, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTrackPropagator.html:28500,charge,charged,28500,root/html534/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html,6,['charge'],['charged']
Energy Efficiency,"verwrite; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kPacket; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kRate; static TObject::(anonymous)TObject::kSingleKey; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStart; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStop; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kUnDefined; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Long64_tfBytesReadNumber of bytes read; Long64_tfBytesReadExtraNumber of bytes (overhead) of the readahead cache; Double_tfCompressTree compression factor; Double_tfCpuTimeCpu time; Double_tfDiskTimeTime spent in pure raw disk IO; TFile*fFile!pointer to the file containing the Tree; TGraphErrors*fGraphIOpointer to the graph with IO data; TGraphErrors*fGraphTimepointer to the graph with timestamp info; TStringfHostInfoname of the host system, ROOT version and date; TText*fHostInfoTextGraphics Text object with the fHostInfo data; TStringfNamename of this TTreePerfStats; Int_tfNleavesNumber of leaves in the tree; TPaveText*fPavepointer to annotation pavetext; Int_tfReadCallsNumber of read calls; Int_tfReadaheadSizeReadahead cache size; Double_tfRealNormReal time scale factor for fGraphTime; Double_tfRealTimeReal time; TGaxis*fRealTimeAxispointer to TGaxis object showing real-time; TTree*fTree!pointer to the Tree being monitored; Int_tfTreeCacheSizeTTreeCache buffer size; Double_tfUnzipTimeTime spent uncompressing the data.; TStopwatch*fWatchTStopwatch pointer. Class Charts. Inheritance Chart:. TObject. ←; TVirtualPerfStats. ←; TTreePerfStats. Function documentation; TTreePerfStats(); default constructor (used when reading an object only). TTreePerfStats(const char* name, TTree* T); Create a TTree I/O perf stats object. ~TTreePerfStats(); Destructor. void Browse(TBrowser* b); Browse. Int_t DistancetoPrimitive(Int_t px, Int_t py); Return distance to one of the objects in the TTreePerfStats. void D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreePerfStats.html:11323,monitor,monitored,11323,root/html602/TTreePerfStats.html,https://root.cern,https://root.cern/root/html602/TTreePerfStats.html,4,['monitor'],['monitored']
Energy Efficiency,"very simple probability density estimator (PDE) has been suggested in hep-ex/0211019. The PDE for a given test event is obtained from counting the (normalized) number of signal and background (training) events that occur in the ""vicinity"" of the test event. The volume that describes ""vicinity"" is user-defined. A search method based on binary-trees is used to effectively reduce the selection time for the range search. Three different volume definitions are optional:. MinMax: the volume is defined in each dimension with respect to the full variable range found in the training sample.; RMS: the volume is defined in each dimensions with respect to the RMS estimated from the training sample.; Adaptive: a volume element is defined in each dimensions with respect to the RMS estimated from the training sample. The overall scale of the volume element is then determined for each event so that the total number of events confined in the volume be within a user-defined range. The adaptive range search is used by default. ; Definition at line 61 of file MethodPDERS.h. Public Member Functions;  MethodPDERS (const TString &jobName, const TString &methodTitle, DataSetInfo &theData, const TString &theOption);  standard constructor for the PDERS method ;  ;  MethodPDERS (DataSetInfo &theData, const TString &theWeightFile);  construct MethodPDERS through from file ;  ; virtual ~MethodPDERS (void);  destructor ;  ; void AddWeightsXMLTo (void *parent) const;  write weights to xml file ;  ; Double_t GetMvaValue (Double_t *err=nullptr, Double_t *errUpper=nullptr);  init the size of a volume element using a defined fraction of the volume containing the entire events ;  ; const std::vector< Float_t > & GetRegressionValues ();  ; Double_t GetVolumeContentForRoot (Double_t);  count number of events in rescaled volume ;  ; virtual Bool_t HasAnalysisType (Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets);  PDERS can handle classification with 2 classes and regression with on",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html:1861,adapt,adaptive,1861,doc/master/classTMVA_1_1MethodPDERS.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html,1,['adapt'],['adaptive']
Energy Efficiency,"ves only to point x,y.; If NN=0 the x,y are written in the SVG file; according to the current transformation.; If NN>0 the line is clipped as a line.; If NN<0 the line is clipped as a fill area. void DrawPolyMarker(Int_t n, Float_t* x, Float_t* y); Paint PolyMarker. void DrawPolyMarker(Int_t n, Double_t* x, Double_t* y); Paint PolyMarker. void DrawPS(Int_t n, Double_t* xw, Double_t* yw); This function defines a path with xw and yw and draw it according the; value of nn:. If nn>0 a line is drawn.; If nn<0 a closed polygon is drawn. void Initialize(); Initialize the SVG file. The main task of the function is to ouput the; SVG header file which consist in <title>, <desc> and <defs>. The; HeaderPS provided by the user program is written in the <defs> part. void MovePS(Int_t x, Int_t y); Move to a new position (ix, iy). The move is done in relative coordinates; which allows to have short numbers which decrease the size of the file.; This function use the full power of the SVG's paths by using the; horizontal and vertical move whenever it is possible. void NewPage(); Start the SVG page. This function initialize the pad conversion; coefficients and ouput the <svg> directive which is close later in the; the function Close. void Range(Float_t xrange, Float_t yrange); Set the range for the paper in centimetres. void SetFillColor(Color_t cindex = 1); Set color index for fill areas. void SetLineColor(Color_t cindex = 1); Set color index for lines. void SetLineStyle(Style_t linestyle = 1); Change the line style. linestyle = 2 dashed; = 3 dotted; = 4 dash-dotted; = else solid (1 in is used most of the time). void SetLineWidth(Width_t linewidth = 1); Set the lines width. void SetMarkerColor(Color_t cindex = 1); Set color index for markers. void SetColor(Int_t color = 1); Set color with its color index. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. void SetTextColor(Color_t ci",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSVG.html:14500,power,power,14500,root/html528/TSVG.html,https://root.cern,https://root.cern/root/html528/TSVG.html,4,['power'],['power']
Energy Efficiency,"ving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::Error",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:16319,reduce,reduced,16319,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,9,['reduce'],['reduced']
Energy Efficiency,"ving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsData.html:16221,reduce,reduced,16221,root/html526/RooAbsData.html,https://root.cern,https://root.cern/root/html526/RooAbsData.html,1,['reduce'],['reduced']
Energy Efficiency,"virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html:3044,Adapt,AdaptiveIntegratorMultiDim,3044,root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__AdaptiveIntegratorMultiDim.html,1,['Adapt'],['AdaptiveIntegratorMultiDim']
Energy Efficiency,"virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:4974,Adapt,AdaptiveIntegratorMultiDim,4974,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,1,['Adapt'],['AdaptiveIntegratorMultiDim']
Energy Efficiency,"virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTMVA::MethodBase::IsSignalLike(); virtual Bool_tTMVA::MethodBase::IsSignalLike(Double_t mvaVal); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTMVA::MethodBase::MakeClass(const TString& classFileName = TString("""")) const; voidTObject::MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodBoostMethodBoost(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodBoostMethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = NULL); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodBoost.html:8909,Monitor,MonitorBoost,8909,root/html532/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodBoost.html,1,['Monitor'],['MonitorBoost']
Energy Efficiency,"vogadro constant (Avogadro's Number) in \( mol^{-1} \). ;  ; constexpr Double_t NaUncertainty ();  Avogadro constant (Avogadro's Number) uncertainty. ;  ; Long_t NextPrime (Long_t x);  ; template<typename T > ; Int_t Nint (T x);  Round to nearest integer. Rounds half integers to the nearest even integer. ;  ; template<typename T > ; T * Normal2Plane (const T v1[3], const T v2[3], const T v3[3], T normal[3]);  Calculates a normal vector of a plane. ;  ; Double_t Normalize (Double_t v[3]);  Normalize a vector v in place. ;  ; Float_t Normalize (Float_t v[3]);  Normalize a vector v in place. ;  ; template<typename T > ; T NormCross (const T v1[3], const T v2[3], T out[3]);  Calculates the Normalized Cross Product of two vectors. ;  ; Double_t NormQuantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t Odd (Long_t a);  Returns true if a is odd. ;  ; Bool_t Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t Pi ();  \( \pi\) ;  ; constexpr Double_t PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:16583,adapt,adapted,16583,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['adapt'],['adapted']
Energy Efficiency,"void AddTargetsXMLTo(void* parent) const; write target info to XML. void ReadVariablesFromXML(void* varnode); read variable info from XML. void ReadSpectatorsFromXML(void* specnode); read spectator info from XML. void ReadClassesFromXML(void* clsnode); read number of classes from XML. void ReadTargetsFromXML(void* tarnode); read target info from XML. TDirectory* BaseDir() const; returns the ROOT directory where info/histograms etc of the; corresponding MVA method instance are stored. TDirectory* MethodBaseDir() const; returns the ROOT directory where all instances of the; corresponding MVA method are stored. void SetWeightFileDir(TString fileDir); set directory of weight file. void SetWeightFileName(TString ); set the weight file name (depreciated). TString GetWeightFileName() const; retrieve weight file name. void WriteEvaluationHistosToFile(TMVA::Types::ETreeType treetype); writes all MVA evaluation histograms to file. void WriteMonitoringHistosToFile( void ); write special monitoring histograms to file; dummy implementation here -----------------. Bool_t GetLine(istream& fin, char* buf); reads one line from the input stream; checks for certain keywords and interprets; the line if keywords are found. void CreateMVAPdfs(); Create PDFs of the MVA output variables. Double_t GetProba(Double_t mvaVal, Double_t ap_sig); compute likelihood ratio. Double_t GetRarity(Double_t mvaVal, TMVA::Types::ESBType reftype = Types::kBackground) const; compute rarity:; R(x) = Integrate_[-oo..x] { PDF(x') dx' }; where PDF(x) is the PDF of the classifier's signal or background distribution. Double_t GetEfficiency(const TString& , TMVA::Types::ETreeType , Double_t& err); fill background efficiency (resp. rejection) versus signal efficiency plots; returns signal efficiency at background efficiency indicated in theString. Double_t GetTrainingEfficiency(const TString& ). std::vector<Float_t> GetMulticlassEfficiency(vector<std::vector<Float_t> >& purity). std::vector<Float_t> GetMulticlassTr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBase.html:25218,monitor,monitoring,25218,root/html528/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html,4,['monitor'],['monitoring']
Energy Efficiency,"void AddTargetsXMLTo(void* parent) const; write target info to XML. void ReadVariablesFromXML(void* varnode); read variable info from XML. void ReadSpectatorsFromXML(void* specnode); read spectator info from XML. void ReadClassesFromXML(void* clsnode); read number of classes from XML. void ReadTargetsFromXML(void* tarnode); read target info from XML. TDirectory* BaseDir() const; returns the ROOT directory where info/histograms etc of the; corresponding MVA method instance are stored. TDirectory* MethodBaseDir() const; returns the ROOT directory where all instances of the; corresponding MVA method are stored. void SetWeightFileDir(TString fileDir); set directory of weight file. void SetWeightFileName(TString ); set the weight file name (depreciated). TString GetWeightFileName() const; retrieve weight file name. void WriteEvaluationHistosToFile(TMVA::Types::ETreeType treetype); writes all MVA evaluation histograms to file. void WriteMonitoringHistosToFile( void ); write special monitoring histograms to file; dummy implementation here -----------------. Bool_t GetLine(istream& fin, char* buf); reads one line from the input stream; checks for certain keywords and interprets; the line if keywords are found. void CreateMVAPdfs(); Create PDFs of the MVA output variables. Double_t GetProba(const TMVA::Event* ev); the simple one, automatically calcualtes the mvaVal and uses the; SAME sig/bkg ratio as given in the training sample (typically 50/50; .. (NormMode=EqualNumEvents) but can be different). Double_t GetProba(Double_t mvaVal, Double_t ap_sig); compute likelihood ratio. Double_t GetRarity(Double_t mvaVal, TMVA::Types::ESBType reftype = Types::kBackground) const; compute rarity:; R(x) = Integrate_[-oo..x] { PDF(x') dx' }; where PDF(x) is the PDF of the classifier's signal or background distribution. Double_t GetEfficiency(const TString& , TMVA::Types::ETreeType , Double_t& err); fill background efficiency (resp. rejection) versus signal efficiency plots; returns signal e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBase.html:26912,monitor,monitoring,26912,root/html534/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBase.html,6,['monitor'],['monitoring']
Energy Efficiency,"void RooLagrangianMorphFunc::setParameters ; (; const char * ; foldername). set the morphing parameters to those supplied in the sample with the given name ; Definition at line 2483 of file RooLagrangianMorphFunc.cxx. ◆ setParameters() [2/4]. void RooLagrangianMorphFunc::setParameters ; (; const ParamSet & ; params). retrieve a set of couplings (-?-) ; Definition at line 2747 of file RooLagrangianMorphFunc.cxx. ◆ setParameters() [3/4]. void RooLagrangianMorphFunc::setParameters ; (; const RooArgList * ; list). set the morphing parameters to those supplied in the list with the given name ; Definition at line 2506 of file RooLagrangianMorphFunc.cxx. ◆ setParameters() [4/4]. void RooLagrangianMorphFunc::setParameters ; (; TH1 * ; paramhist). set the morphing parameters to those supplied in the given param hist ; Definition at line 2474 of file RooLagrangianMorphFunc.cxx. ◆ setScale(). void RooLagrangianMorphFunc::setScale ; (; double ; val). set energy scale of the EFT expansion ; Definition at line 1969 of file RooLagrangianMorphFunc.cxx. ◆ setup(). void RooLagrangianMorphFunc::setup ; (; bool ; ownParams = true). private . setup this instance with the given set of operators and vertices if own=true, the class will own the operators template <class Base> ; Definition at line 1839 of file RooLagrangianMorphFunc.cxx. ◆ setupObservable(). RooRealVar * RooLagrangianMorphFunc::setupObservable ; (; const char * ; obsname, . TClass * ; mode, . TObject * ; inputExample . ). private . setup observable, recycle existing observable if defined ; Definition at line 1620 of file RooLagrangianMorphFunc.cxx. ◆ Streamer(). void RooLagrangianMorphFunc::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooLagrangianMorphFunc::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 257 of file RooLagrangianMorphFunc.h. ◆ updateCoefficients(). bool RooLagrang",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:92983,energy,energy,92983,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,1,['energy'],['energy']
Energy Efficiency,"void TMVA::DNN::ClassificationSettings::endTrainCycle ; (; double ; ). virtual . action to be done when the training cycle is ended (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 296 of file NeuralNet.cxx. ◆ setResultComputation(). void TMVA::DNN::ClassificationSettings::setResultComputation ; (; std::string ; _fileNameNetConfig, . std::string ; _fileNameResult, . std::vector< Pattern > * ; _resultPatternContainer . ). preparation for monitoring output ; Definition at line 520 of file NeuralNet.cxx. ◆ setWeightSums(). void TMVA::DNN::ClassificationSettings::setWeightSums ; (; double ; sumOfSigWeights, . double ; sumOfBkgWeights . ). set the weight sums to be scaled to (preparations for monitoring output) ; Definition at line 512 of file NeuralNet.cxx. ◆ startTestCycle(). void TMVA::DNN::ClassificationSettings::startTestCycle ; (; ). virtual . action to be done when the test cycle is started (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 316 of file NeuralNet.cxx. ◆ startTrainCycle(). void TMVA::DNN::ClassificationSettings::startTrainCycle ; (; ). virtual . action to be done when the training cycle is started (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 281 of file NeuralNet.cxx. ◆ testIteration(). void TMVA::DNN::ClassificationSettings::testIteration ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented from TMVA::DNN::Settings.; Definition at line 930 of file NeuralNet.h. ◆ testSample(). void TMVA::DNN::ClassificationSettings::testSample ; (; double ; error, . double ; output, . double ; target, . double ; weight . ). virtual . action to be done after the computation of a test sample (e.g. ; update some monitoring output) ; Reimplemented from TMVA::DNN::Settings.; Definition at line 304 of file NeuralNet.cxx. Member Data Documentation. ◆ m_ams. std::vector<double> TMVA::DNN::Classif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html:8575,monitor,monitoring,8575,doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1ClassificationSettings.html,1,['monitor'],['monitoring']
Energy Efficiency,"voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. static THashList*fgList. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfEnergyCutLower energy cut off, the default is 10 keV; Double_tfEnergyLimitHigh energy cut off, the default is 10 TeV; Double_tfGranularityGranularity of the fLogEScale; Int_tfMCnumberOfPDGPDG MC number followed by; Double_tfPDGChargeCharge of the particle in units of e; Double_tfPDGDecayWidthLife time of the particle in sec.; Double_tfPDGMassMass of the particle in GeV/c2; Bool_tfPDGStableLogical indicator, if TRUE the particle can not decay; TStringfParticleTypeText indicator for the particle family. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAttParticle(). Particle definition default constructor. TAttParticle(const char* name, const char* title, Double_t Mass, Bool_t Stable, Double_t DecayWidth, Double_t Charge, const char* Type, Int_t MCnumber, Int_t granularity = 90, Double_t LowerCutOff = 1.e-5, Double_t HighCutOff = 1.e4). Particle definition normal constructor. If the particle is set to be; stable, the decay width parameter does have no meaning and can be set to; any value. The parameters granularity, LowerCutOff and HighCutOff are; used for the construction of the mean free path look ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAttParticle.html:6336,energy,energy,6336,root/html526/TAttParticle.html,https://root.cern,https://root.cern/root/html526/TAttParticle.html,14,['energy'],['energy']
Energy Efficiency,"void FillWithRandomValues (std::vector< Double_t > &parameters);  random starting parameters ;  ; Double_t GenerateMaxTemperature (std::vector< Double_t > &parameters);  maximum temperature ;  ; std::vector< Double_t > GenerateNeighbour (std::vector< Double_t > &parameters, Double_t currentTemperature);  generate adjacent parameters ;  ; void GenerateNeighbour (std::vector< Double_t > &parameters, std::vector< Double_t > &oldParameters, Double_t currentTemperature);  generate adjacent parameters ;  ; void GenerateNewTemperature (Double_t &currentTemperature, Int_t Iter);  generate new temperature ;  ; MsgLogger & Log () const;  ; void ReWriteParameters (std::vector< Double_t > &from, std::vector< Double_t > &to);  copy parameters ;  ; void SetDefaultScale ();  setting of default scale ;  ; Bool_t ShouldGoIn (Double_t currentFit, Double_t localFit, Double_t currentTemperature);  result checker ;  . Private Attributes; Double_t fAdaptiveSpeed;  how fast temperature change in adaptive (in adaptive two variables describe the change of temperature, but fAdaptiveSpeed should be 1.0 and its not recommended to change it) ;  ; Double_t fEps;  epsilon ;  ; bool * fExitFromTraining = nullptr;  ; IFitterTarget & fFitterTarget;  the fitter target ;  ; Double_t fInitialTemperature;  initial temperature ;  ; UInt_t * fIPyCurrentIter = nullptr;  ; enum TMVA::SimulatedAnnealing::EKernelTemperature fKernelTemperature;  ; MsgLogger * fLogger;  ! message logger ;  ; Int_t fMaxCalls;  maximum number of minimisation calls ;  ; Double_t fMinTemperature;  minimum temperature ;  ; Double_t fProgress;  ; TRandom * fRandom;  random generator ;  ; const std::vector< TMVA::Interval * > & fRanges;  parameter ranges ;  ; Double_t fTemperatureAdaptiveStep;  used to calculate InitialTemperature if fUseDefaultTemperature ;  ; Double_t fTemperatureScale;  how fast temperature change ;  ; Bool_t fUseDefaultScale;  if TRUE, SA calculates its own TemperatureScale ;  ; Bool_t fUseDefaultTemperature;  if T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1SimulatedAnnealing.html:2820,adapt,adaptive,2820,doc/master/classTMVA_1_1SimulatedAnnealing.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1SimulatedAnnealing.html,2,['adapt'],['adaptive']
Energy Efficiency,"void Reset (void);  Reset the method, as if it had just been instantiated (forget all training etc.). ;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Train (void);  Call the Optimizer with the set of parameters and ranges that are meant to be tuned. ;  ; void WriteMonitoringHistosToFile (void) const;  write special monitoring histograms to file dummy implementation here --------------— ;  ;  Public Member Functions inherited from TMVA::MethodBase;  MethodBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &dsi, const TString &theOption="""");  standard constructor ;  ;  MethodBase (Types::EMVA methodType, DataSetInfo &dsi, const TString &weightFile);  constructor used for Testing + Application of the MVA, only (no training), using given WeightFiles ;  ; virtual ~MethodBase ();  destructor ;  ; void AddOutput (Types::ETreeType type, Types::EAnalysisType analysisType);  ; TDirectory * BaseDir () const;  returns the ROOT directory where info/histograms etc of the corresponding MVA method instance are stored ;  ; virtual void CheckSetup ();  check may be overridden by derived class (sometimes, eg, fitters are used which can only be implemented during training phase) ;  ; DataSet * Data () const;  ; DataSetInfo & DataInfo () const;  ; void DisableWriting (Bool_t setter);  ; Bool_t DoMulticlass () const;  ; Bool_t DoRegression () const;  ; void ExitFromTraining ();  ; Types::EAnalysisType GetAnalysisType () const;  ; UInt_t GetCurrentIter ();  ; virtual Double_t GetEfficiency (const TString &, Types::ETreeType, Double_t &err);  fill background efficiency (resp. ;  ; const Event * GetEvent () const;  ; const Event * GetEvent (const TMVA::Event *ev) const;  ; const Event * GetEvent (Long64_t ievt) const;  ; const Event * GetEvent (Long64_t ievt, Types::ETreeType type) const;  ; const std::vector< TMVA::Event * > & GetEventCollection (Types::ETreeType type);  returns the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCrossValidation.html:2314,monitor,monitoring,2314,doc/master/classTMVA_1_1MethodCrossValidation.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCrossValidation.html,1,['monitor'],['monitoring']
Energy Efficiency,"vt);  train network over a single event this uses the new event model ;  ; void TrainOneEventFast (Int_t ievt, Float_t *&branchVar, Int_t &type);  fast per-event training ;  ; void UpdateNetwork (const std::vector< Float_t > &desired, Double_t eventWeight=1.0);  update the network based on how closely the output matched the desired output ;  ; void UpdateNetwork (Double_t desired, Double_t eventWeight=1.0);  update the network based on how closely the output matched the desired output ;  ; void UpdatePriors ();  zjh ;  ; void UpdateRegulators ();  zjh ;  ; void UpdateSynapses ();  update synapse error fields and adjust the weights (if in sequential mode) ;  . Private Attributes; Int_t fBatchSize;  batch size, only matters if in batch learning mode ;  ; EBPTrainingMode fBPMode;  backprop learning mode (sequential or batch) ;  ; TString fBpModeS;  backprop learning mode option string (sequential or batch) ;  ; bool fCalculateErrors;  compute inverse hessian matrix at the end of the training ;  ; Double_t fDecayRate;  decay rate for above learning rate ;  ; std::vector< std::pair< Float_t, Float_t > > * fDeviationsFromTargets;  deviation from the targets, event weight ;  ; Bool_t fEpochMon;  create and fill epoch-wise monitoring histograms (makes outputfile big!) ;  ; Int_t fGA_nsteps;  GA settings: number of steps. ;  ; Int_t fGA_preCalc;  GA settings: number of pre-calc steps. ;  ; Double_t fGA_SC_factor;  GA settings: SC_factor. ;  ; Int_t fGA_SC_rate;  GA settings: SC_rate. ;  ; Int_t fGA_SC_steps;  GA settings: SC_steps. ;  ; Double_t fLastAlpha;  line search variable ;  ; Double_t fLearnRate;  learning rate for synapse weight adjustments ;  ; Double_t fPrior;  zjh ;  ; std::vector< Double_t > fPriorDev;  zjh ;  ; Int_t fResetStep;  reset time (how often we clear hessian matrix) ;  ; Float_t fSamplingEpoch;  fraction of epochs where sampling is used ;  ; Float_t fSamplingFraction;  fraction of events which is sampled for training ;  ; Bool_t fSamplingTesting;  The ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:34370,monitor,monitoring,34370,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['monitor'],['monitoring']
Energy Efficiency,"w Double_t[fNpoints];; 367 Double_t *newEZ = new Double_t[fNpoints];; 368 ; 369 Int_t j = -1;; 370 for (Int_t i = 0; i < fNpoints + 1; i++) {; 371 if (i == ipoint) continue;; 372 j++;; 373 newX[j] = fX[i];; 374 newY[j] = fY[i];; 375 newZ[j] = fZ[i];; 376 newEX[j] = fEX[i];; 377 newEY[j] = fEY[i];; 378 newEZ[j] = fEZ[i];; 379 }; 380 delete [] fX;; 381 delete [] fY;; 382 delete [] fZ;; 383 delete [] fEX;; 384 delete [] fEY;; 385 delete [] fEZ;; 386 fX = newX;; 387 fY = newY;; 388 fZ = newZ;; 389 fEX = newEX;; 390 fEY = newEY;; 391 fEZ = newEZ;; 392 fSize = fNpoints;; 393 if (fHistogram) {; 394 delete fHistogram;; 395 fHistogram = nullptr;; 396 fDelaunay = nullptr;; 397 }; 398 return ipoint;; 399}; 400 ; 401////////////////////////////////////////////////////////////////////////////////; 402/// Set x, y and z values for point number i; 403 ; 404void TGraph2DErrors::SetPoint(Int_t i, Double_t x, Double_t y, Double_t z); 405{; 406 if (i < 0) return;; 407 if (i >= fNpoints) {; 408 // re-allocate the object; 409 Double_t *savex = new Double_t[i+1];; 410 Double_t *savey = new Double_t[i+1];; 411 Double_t *savez = new Double_t[i+1];; 412 Double_t *saveex = new Double_t[i+1];; 413 Double_t *saveey = new Double_t[i+1];; 414 Double_t *saveez = new Double_t[i+1];; 415 if (fNpoints > 0) {; 416 memcpy(savex, fX, fNpoints*sizeof(Double_t));; 417 memcpy(savey, fY, fNpoints*sizeof(Double_t));; 418 memcpy(savez, fZ, fNpoints*sizeof(Double_t));; 419 memcpy(saveex,fEX,fNpoints*sizeof(Double_t));; 420 memcpy(saveey,fEY,fNpoints*sizeof(Double_t));; 421 memcpy(saveez,fEZ,fNpoints*sizeof(Double_t));; 422 }; 423 if (fX) delete [] fX;; 424 if (fY) delete [] fY;; 425 if (fZ) delete [] fZ;; 426 if (fEX) delete [] fEX;; 427 if (fEY) delete [] fEY;; 428 if (fEZ) delete [] fEZ;; 429 fX = savex;; 430 fY = savey;; 431 fZ = savez;; 432 fEX = saveex;; 433 fEY = saveey;; 434 fEZ = saveez;; 435 fNpoints = i+1;; 436 }; 437 fX[i] = x;; 438 fY[i] = y;; 439 fZ[i] = z;; 440}; 441 ; 442 ; 443//////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:12044,allocate,allocate,12044,doc/master/TGraph2DErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"w, Int_t *icol, Element *data);  Copy nr elements from row/col index and data array to matrix . ;  ; virtual TMatrixTBase< Element > & SetMatrixArray (Int_t nr_nonzeros, Int_t nrows, Int_t ncols, Int_t *irow, Int_t *icol, Element *data);  ; TMatrixTBase< Element > & SetRowIndexArray (Int_t *data) override;  ; TMatrixTSparse< Element > & SetSparseIndex (const TMatrixTBase< Element > &another);  Use non-zero data of matrix source to set the sparse structure. ;  ; TMatrixTSparse< Element > & SetSparseIndex (Int_t nelem_new);  Increase/decrease the number of non-zero elements to nelems_new. ;  ; TMatrixTSparse< Element > & SetSparseIndexAB (const TMatrixT< Element > &a, const TMatrixTSparse< Element > &b);  Set the row/column indices to the ""sum"" of matrices a and b It is checked that enough space has been allocated. ;  ; TMatrixTSparse< Element > & SetSparseIndexAB (const TMatrixTSparse< Element > &a, const TMatrixT< Element > &b);  ; TMatrixTSparse< Element > & SetSparseIndexAB (const TMatrixTSparse< Element > &a, const TMatrixTSparse< Element > &b);  Set the row/column indices to the ""sum"" of matrices a and b It is checked that enough space has been allocated. ;  ; TMatrixTBase< Element > & SetSub (Int_t row_lwb, Int_t col_lwb, const TMatrixTBase< Element > &source) override;  Insert matrix source starting at [row_lwb][col_lwb], thereby overwriting the part [row_lwb..row_lwb+nrows_source-1][col_lwb..col_lwb+ncols_source-1];. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TMatrixTSparse. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; TMatrixTSparse< Element > & T ();  ; TMatrixTSparse< Element > & Transpose (const TMatrixTSparse< Element > &source);  Transpose a matrix. Set the matrix to ncols x nrows if nrows != ncols. ;  ; TMatrixTBase< Element > & UnitMatrix () override;  Make a unit matrix (matrix need not be a square one). ;  ; const TMatrixTSparse< Element > & Use (const TMatrixTSparse< Element > &a) const;  ; const TMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSparse.html:12579,allocate,allocated,12579,doc/master/classTMatrixTSparse.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSparse.html,1,['allocate'],['allocated']
Energy Efficiency,"wTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » About Team. . Axel Naumann ; ; Starting off as a physicist, Axel studied physics and math in Muenster, Germany. In 2000, he got a Ph.D. position for high energy physics in Nijmegen, The Netherlands. They sent him to Fermilab at Chicago, where he worked with the DØ experiment - which also meant writing software from PCI drivers to data analysis code. During that time he got involved with ROOT, converting from a user to a developer. He contributed to whatever he needed, e.g. the statistics part, the documentation engine, and porting it to cygwin. After a position with the Fermilab Computing Division in 2005 he ended up at CERN in the ROOT development team. Axel is leading the ROOT project since 2017.; ; . Bertrand Bellenot ; ; Bertrand was primary working in Aluminum industry as process engineer, developing software for data acquisition, data analysis, statistical process control (SPC) and for X-Ray spectrometry. He has been involved in ROOT development since 2001 by porting ROOT to Windows. Bertrand is a member of the ROOT development team at CERN since August 2005. He's currently working on GUI (Graphical User Interface), core (mainly Windows suppor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/team.html:1995,energy,energy,1995,d/team.html,https://root.cern,https://root.cern/d/team.html,1,['energy'],['energy']
Energy Efficiency,"w[](size_t sz, void* vp); TMultiDimFit&operator=(const TMultiDimFit&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = ""ps"") constMENU ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidSetBinVarX(Int_t nbbinvarx); voidSetBinVarY(Int_t nbbinvary); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxAngle(Double_t angle = 0); voidSetMaxFunctions(Int_t n); voidSetMaxPowers(const Int_t* powers); voidSetMaxStudy(Int_t n); voidSetMaxTerms(Int_t terms); voidSetMinAngle(Double_t angle = 1); voidSetMinRelativeError(Double_t error); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetPowerLimit(Double_t limit = 1e-3); virtual voidSetPowers(const Int_t* powers, Int_t terms); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:19831,power,powers,19831,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,1,['power'],['powers']
Energy Efficiency,"want to know that ""signal"" / ""background"" thing: we just ""mis""-use; // TMVA to analyze the parameter correlations. Nonetheless, let's just define signal; // and background as triggered / not triggered. Both are in the same tree.; // We distinguish them using TCut objects: selections as one would use in TTree::Draw(). ; TCut signalCut(""muons.fTriggered"");; TCut backgroundCut(""!muons.fTriggered"");; factory->SetInputTrees(tree, signalCut, backgroundCut);. // Now select which algorithm to run - it's not important here as long as it; // determines the parameter correlations.; factory->BookMethod( TMVA::Types::kFisher, ""Fisher"", ""H:!V"" );; // And start the correlation analysis:; factory->TestAllMethods();; }. Parameter correlations; We want to know what muons.fTriggered depends on. A simple check is to look for correlations: variables that it depends on might be linearly correlated. TMVA tells us that the muon and the X position is completely uncorrelated. It also tells us that the muons' pT and energy are somewhat correlated. But what would be the best parameter to determine the muon trigger efficiency - what is most correlated with it?; . ‹ 5. Fitting; up; 7. Using the TTreeReader ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/6-multivariate-analysis.html:5481,energy,energy,5481,d/6-multivariate-analysis.html,https://root.cern,https://root.cern/d/6-multivariate-analysis.html,1,['energy'],['energy']
Energy Efficiency,"ways when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5]. There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if. where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out). Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3). The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the modified Gram-Schmidt; orthogonalisation algorithm [5] [3] to the; functions , we can evaluate the contribution to the reduction of; from each function in turn, and we may delay the actual inversion; of the curvature-matrix; (TMultiDimFit::MakeGramSchmidt). So we are let to consider an matrix ; , an; element ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:4397,power,power,4397,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,4,['power'],['power']
Energy Efficiency,"wever, the method automatically readjusts the value of this angle while fitting is in progress, in order to make the selection criteria less and less difficult to be fulfilled. The result is that the functions contributing most to the reduction of \( S\) are chosen first (TMultiDimFit::TestFunction).; In case \( \phi \) isn't defined, an alternative method of performing this second test is used: The \(L^{\mbox{th}}\) function \(\textbf{f}_L\) is accepted if (refer also to equation (13)) ; \[; \Delta S_L > \frac{S_{L-1}}{L_{max}-L}; \]. where \( S_{L-1}\) is the sum of the \( L-1\) first residuals from the \( L-1\) functions previously accepted; and \( L_{max}\) is the total number of functions allowed in the final expression of the fit (defined by user).; From this we see, that by restricting \( L_{max}\) – the number of terms in the final model – the fit is more difficult to perform, since the above selection criteria is more limiting.; The more coefficients we evaluate, the more the sum of squares of residuals \( S\) will be reduced. We can evaluate \( S\) before inverting \(\mathsf{B}\) as shown below. Coefficients and Coefficient Errors; Having found a parameterization, that is the \( F_l\)'s and \( L\), that minimizes \( S\), we still need to determine the coefficients \( c_l\). However, it's a feature of how we choose the significant functions, that the evaluation of the \( c_l\)'s becomes trivial 5. To derive \(\mathbf{c}\), we first note that equation (4) can be written as ; \[; \mathsf{F} = \mathsf{W}\mathsf{B}; \]. where ; \begin{eqnarray*}; b_{ij} = \frac{\mathbf{f}_j \bullet \mathbf{w}_i}{\mathbf{w}_i^2}; & \mbox{if} & i < j\\; 1 & \mbox{if} & i = j\\; 0 & \mbox{if} & i > j; \end{eqnarray*}. Consequently, \(\mathsf{B}\) is an upper triangle matrix, which can be readily inverted. So we now evaluate ; \[; \mathsf{F}\mathsf{B}^{-1} = \mathsf{W}; \]. The model \(\mathsf{W}\mathbf{a}\) can therefore be written as \((\mathsf{F}\mathsf{B}^{-1})\mathbf{a} = \math",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:11727,reduce,reduced,11727,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['reduce'],['reduced']
Energy Efficiency,"which; diff = abs(bin_content-c) <= maxdiff; In case several bins in the specified range with diff=0 are found; the first bin found is returned in binx.; In case several bins in the specified range satisfy diff <=maxdiff; the bin with the smallest difference is returned in binx.; In all cases the function returns the smallest difference. NOTE1: if firstx <= 0, firstx is set to bin 1; if (lastx < firstx then firstx is set to the number of bins; ie if firstx=0 and lastx=0 (default) the search is on all bins.; NOTE2: if maxdiff=0 (default), the first bin with content=c is returned. Double_t Interpolate(Double_t x); Given a point x, approximates the value via linear interpolation; based on the two nearest bin centers; Andy Mastbaum 10/21/08. Double_t Interpolate(Double_t x, Double_t y). Double_t Interpolate(Double_t x, Double_t y, Double_t z). Bool_t IsBinOverflow(Int_t bin) const. Bool_t IsBinUnderflow(Int_t bin) const. void LabelsDeflate(Option_t* axis = ""X""); Reduce the number of bins for the axis passed in the option to the number of bins having a label.; The method will remove only the extra bins existing after the last ""labeled"" bin.; Note that if there are ""un-labeled"" bins present between ""labeled"" bins they will not be removed. void LabelsInflate(Option_t* axis = ""X""); Double the number of bins for axis.; Refill histogram; This function is called by TAxis::FindBin(const char *label). void LabelsOption(Option_t* option = ""h"", Option_t* axis = ""X""); Set option(s) to draw axis with labels; option = ""a"" sort by alphabetic order; = "">"" sort by decreasing values; = ""<"" sort by increasing values; = ""h"" draw labels horizontal; = ""v"" draw labels vertical; = ""u"" draw labels up (end of label right adjusted); = ""d"" draw labels down (start of label left adjusted). Bool_t SameLimitsAndNBins(const TAxis& axis1, const TAxis& axis2); Same limits and bins. Bool_t RecomputeAxisLimits(TAxis& destAxis, const TAxis& anAxis); Finds new limits for the axis for the Merge function.; ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:98410,Reduce,Reduce,98410,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['Reduce'],['Reduce']
Energy Efficiency,"will have medium number NUMED.; If NUMED=0 they will get the medium number of the divided volume (this). If NDIV<=0,; all range of IAXIS will be divided and the resulting number of divisions will be centered on; IAXIS. If STEP<=0, the real STEP will be computed as the full range of IAXIS divided by NDIV.; Options (case insensitive):; N - divide all range in NDIV cells (same effect as STEP<=0) (GSDVN in G3); NX - divide range starting with START in NDIV cells (GSDVN2 in G3); S - divide all range with given STEP. NDIV is computed and divisions will be centered; in full range (same effect as NDIV<=0) (GSDVS, GSDVT in G3); SX - same as DVS, but from START position. (GSDVS2, GSDVT2 in G3). Int_t DistancetoPrimitive(Int_t px, Int_t py); compute the closest distance of approach from point px,py to this volume. void Draw(Option_t* option = """"); draw top volume according to option. void DrawOnly(Option_t* option = """"); draw only this volume. Bool_t OptimizeVoxels(); Perform an exensive sampling to find which type of voxelization is; most efficient. void Paint(Option_t* option = """"); paint volume. void PrintVoxels() const; Print the voxels for this volume. void ReplayCreation(const TGeoVolume* other); Recreate the content of the other volume without pointer copying. Voxels are; ignored and supposed to be created in a later step via Voxelize. void PrintNodes() const; print nodes. TH2F * LegoPlot(Int_t ntheta = 20, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 60, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RegisterYourself(Option_t* option = """"); Register the volume and all materials/media/matrices/shapes to the manager. void RandomPoints(Int_t npoints = 1000000, Option_t* option = """"); Draw random points in the bounding box of this volume. void RandomRays(Int_t nrays = 10000, Double_t startx = 0, Double_t starty = 0, Double_t st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoVolume.html:26529,efficient,efficient,26529,root/html528/TGeoVolume.html,https://root.cern,https://root.cern/root/html528/TGeoVolume.html,4,['efficient'],['efficient']
Energy Efficiency,"will have medium number NUMED.; If NUMED=0 they will get the medium number of the divided volume (this). If NDIV<=0,; all range of IAXIS will be divided and the resulting number of divisions will be centered on; IAXIS. If STEP<=0, the real STEP will be computed as the full range of IAXIS divided by NDIV.; Options (case insensitive):; N - divide all range in NDIV cells (same effect as STEP<=0) (GSDVN in G3); NX - divide range starting with START in NDIV cells (GSDVN2 in G3); S - divide all range with given STEP. NDIV is computed and divisions will be centered; in full range (same effect as NDIV<=0) (GSDVS, GSDVT in G3); SX - same as DVS, but from START position. (GSDVS2, GSDVT2 in G3). Int_t DistancetoPrimitive(Int_t px, Int_t py); compute the closest distance of approach from point px,py to this volume. void Draw(Option_t* option = """"); draw top volume according to option. void DrawOnly(Option_t* option = """"); draw only this volume. Bool_t OptimizeVoxels(); Perform an exensive sampling to find which type of voxelization is; most efficient. void Print(Option_t* option = """") const; Print volume info. void Paint(Option_t* option = """"); paint volume. void PrintVoxels() const; Print the voxels for this volume. void ReplayCreation(const TGeoVolume* other); Recreate the content of the other volume without pointer copying. Voxels are; ignored and supposed to be created in a later step via Voxelize. void PrintNodes() const; print nodes. TH2F * LegoPlot(Int_t ntheta = 20, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 60, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RegisterYourself(Option_t* option = """"); Register the volume and all materials/media/matrices/shapes to the manager. void RandomPoints(Int_t npoints = 1000000, Option_t* option = """"); Draw random points in the bounding box of this volume. void RandomRays(Int_t nrays = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:37151,efficient,efficient,37151,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,6,['efficient'],['efficient']
Energy Efficiency,"window=3. The form of the generalized peak searching function is as follows.; Int-t Search1General(float *spectrum,; int size,; float sigma,; int threshold,; bool markov,; int aver-window);; This function searches for peaks in source spectrum. The number of found peaks and their positions are written into structure pointed by one_dim_peak structure pointer.; Function parameters:. spectrum pointer to the vector of source spectrum source spectrum is replaced by new spectrum calculated using Markov chains method.; size length of source spectrum; sigma sigma of searched peaks; threshold threshold value for selecting of peaks; markov logical variable, if it is true, first the source spectrum is replaced by new spectrum calculated using Markov chains method.; aver_window averaging window used in calculation of Markov spectrum, applies only for markov variable is true. The methods of peak searching are sensitive to the sigma. Usually the sigma value is known beforehand. It also changes only slightly with the energy. We have investigated as well the robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10 (see Figure 3.6). Robustness of the proposed algorithms to the spectrum with the peaks with sigma changing from 1 to 10. We applied peak searching algorithm based on Markov approach. We changed sigma in the interval from 1 to 10. The spectra for averaging windows 3, 5, 10 are shown in Figure 3.7. Spectra for averaging windows 3, 5, 10. When we applied peak searching function to the Markov spectrum averaged with the window=10, we obtained correct estimate of all 10 peak positions for sigma=2,3,4,5,6,7,8. It was not the case when we made the same experiment with the original spectrum. For all sigmas some peaks were not discovered.; 3.2 2-DIMENSIONAL SPECTRA; The basic function of the 2-dimensional peak searching is in detail described in [4].. It identifies automatically the peaks in a spectrum with the presence of the continuous b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:18946,energy,energy,18946,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,2,['energy'],['energy']
Energy Efficiency,"with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrunk and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; This is a simplified version of ExpandCreate used in the TTree mechanism. TObject * RemoveAt(Int_t idx); Remove object at index idx. TObject * Remove(TObject* obj); Remove object from array. void RemoveRange(Int_t idx1, Int_t idx2); Remove objects from index idx1 to idx2 included. void SetClass(const TClass* cl, Int_t size = 1000); Create an array of clone objects of class cl. The class must inherit from; TObject. If the class defines an own operator delete(), make sure that; it looks like this:. void MyClass::operator delete(void *vp); {; if ((Long_t) vp != TObject::GetDtorOnly()); ::operator delete(vp); // delete space; else; TObject::SetDtorOnly(0);; }. The second argument s indicates an approximate number of objects; that will be entered in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:20767,allocate,allocated,20767,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,8,['allocate'],['allocated']
Energy Efficiency,"with 255 colors are available when colors == 0.; The following value of ncolors give access to:. if ncolors = 51 and colors=0, a Deep Sea palette is used.; if ncolors = 52 and colors=0, a Grey Scale palette is used.; if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); if ncolors = 55 and colors=0, a Rain Bow palette is used.; if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used. If ncolors > 0 && colors == 0, the default palette is used; with a maximum of ncolors.; The default palette defines:. index 0 to 9 : shades of grey; index 10 to 19 : shades of brown; index 20 to 29 : shades of blue; index 30 to 39 : shades of red; index 40 to 49 : basic colors. The color numbers specified in the palette can be viewed by selecting; the item ""colors"" in the ""VIEW"" menu of the canvas tool bar.; The red, green, and blue components of a color can be changed thanks to; TColor::SetRGB().; Drawing a sub-range of a 2D histogram; the [cutg] option; Using a TCutG object, it is possible to draw a sub-range of a 2D; histogram. One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the Draw() option.; For example, with a TCutG named ""cutg"", one can call:. myhist->Draw(""surf1 [cutg]"");. To invert the cut, it is enough to put a ""-"" in front of its name:. myhist->Draw(""surf1 [-cutg]"");. It is possible to apply several cuts ("","" means logical AND):. myhist->Draw(""surf1 [cutg1,cutg2]"");. Picture; Source. #include ""TF2.h""; #include ""TH2.h""; #include ""TCutG.h""; #include ""TMath.h""; #include ""TCanvas.h""; #include ""TStyle.h"". //+ Fitting a 2-D histogram (a variant); // This tutorial illustrates :; // - how to create a 2-d function; // - fill a 2-d histogram randomly from this function; // - fit the histogram; // - display the fitted function on top of the histogram (lego-plot); // using a surface plot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THistPainter.html:65239,green,green,65239,root/html534/THistPainter.html,https://root.cern,https://root.cern/root/html534/THistPainter.html,6,['green'],['green']
Energy Efficiency,"wningPtr< RooAbsReal > createIntegral(const RooArgSet &iset, const char *rangeName) constCreate integral over observables in iset in range named rangeName.Definition RooAbsReal.h:207; RooAbsReal::defaultErrorLevelvirtual double defaultErrorLevel() constDefinition RooAbsReal.h:248; RooAbsReal::_DEBUG_getValdouble _DEBUG_getVal(const RooArgSet *normalisationSet) constDebug version of getVal(), which is slow and does error checking.Definition RooAbsReal.cxx:4434; RooAbsReal::createFundamentalRooFit::OwningPtr< RooAbsArg > createFundamental(const char *newname=nullptr) const overrideCreate a RooRealVar fundamental object with our properties.Definition RooAbsReal.cxx:3130; RooAbsReal::plotSanityChecksbool plotSanityChecks(RooPlot *frame) constUtility function for plotOn(), perform general sanity check on frame to ensure safe plotting operatio...Definition RooAbsReal.cxx:2860; RooAbsReal::bindVarsRooFit::OwningPtr< RooAbsFunc > bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constCreate an interface adaptor f(vars) that binds us to the specified variables (in arbitrary order).Definition RooAbsReal.cxx:2980; RooAbsReal::selectNormalizationvirtual void selectNormalization(const RooArgSet *depSet=nullptr, bool force=false)Interface function to force use of a given set of observables to interpret function value.Definition RooAbsReal.cxx:3360; RooAbsReal::derivativeRooDerivative * derivative(RooRealVar &obs, Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::chi2FitTovirtual RooFit::OwningPtr< RooFitResult > chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})Perform a fit to given histogram.Definition RooAbsReal.cxx:4105; RooAbsReal::asTFTF1 * asTF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8h_source.html:38039,adapt,adaptor,38039,doc/master/RooAbsReal_8h_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8h_source.html,1,['adapt'],['adaptor']
Energy Efficiency,"ws currently returns the actual number of values plotted; and thus if the formula contains arrays, this number might be greater than; the number of entries in the trees.; By default TTree::Draw creates the arrays obtained; with all GetVal and GetW with a length corresponding to the; parameter fEstimate. By default fEstimate=10000 and can be modified; via TTree::SetEstimate. A possible recipee is to do; tree->SetEstimate(tree->GetEntries());; You must call SetEstimate if the expected number of selected rows; is greater than 10000.; See TTree::Draw for additional details. TTreeFormula* GetVar(Int_t i) const; Return the TTreeFormula corresponding to the i-th component; of the request formula (where the component are ':' separated). void InitArrays(Int_t newsize); Initialization of the primitive type arrays if the new size is bigger than the available space. UInt_t SplitNames(const TString& varexp, vector<TString>& names); Build Index array for names in varexp.; This will allocated a C style array of TString and Ints. Bool_t Notify(); This function is called at the first entry of a new tree in a chain. void ProcessFill(Long64_t entry); Called in the entry loop for all entries accepted by Select. void ProcessFillMultiple(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Complex case with multiplicity. void ProcessFillObject(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Case where the only variable returns an object (or pointer to). void SetEstimate(Long64_t n); Set number of entries to estimate variable limits. void TakeAction(); Execute action for object obj fNfill times. void TakeEstimate(); Estimate limits for 1-D, 2-D or 3-D objects. void Terminate(); Called at the end of a loop on a TTree. TSelectorDraw(const TSelectorDraw& ). TSelectorDraw& operator=(const TSelectorDraw& ). Int_t GetAction() const; {return fAction;}. Bool_t GetCleanElist() const; {return fCleanElist;}. Int_t GetDimension() const; {return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSelectorDraw.html:11252,allocate,allocated,11252,root/html530/TSelectorDraw.html,https://root.cern,https://root.cern/root/html530/TSelectorDraw.html,9,['allocate'],['allocated']
Energy Efficiency,"x parameter; sxErr - gets error value of sx parameter; sy - gets the fitted value of sy parameter; syErr - gets error value of sy parameter . Definition at line 5858 of file TSpectrum2Fit.cxx. ◆ GetVolumeErrors(). void TSpectrum2Fit::GetVolumeErrors ; (; Double_t * ; volumeErrors). This function gets errors of the volumes of fitted 2D peaks. . volumeErrors - gets vector of volumes errors of 2D peaks . Definition at line 5780 of file TSpectrum2Fit.cxx. ◆ GetVolumes(). void TSpectrum2Fit::GetVolumes ; (; Double_t * ; volumes). This function gets the volumes of fitted 2D peaks. . volumes - gets vector of volumes of 2D peaks . Definition at line 5769 of file TSpectrum2Fit.cxx. ◆ IsA(). TClass * TSpectrum2Fit::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 190 of file TSpectrum2Fit.h. ◆ Ourpowl(). Double_t TSpectrum2Fit::Ourpowl ; (; Double_t ; a, . Int_t ; pw . ). protected . power function ; Definition at line 347 of file TSpectrum2Fit.cxx. ◆ SetBackgroundParameters(). void TSpectrum2Fit::SetBackgroundParameters ; (; Double_t ; a0Init, . Bool_t ; fixA0, . Double_t ; axInit, . Bool_t ; fixAx, . Double_t ; ayInit, . Bool_t ; fixAy . ). This function sets the following fitting parameters of background: . a0Init - initial value of a0 parameter (background is estimated as a0+ax*x+ay*y); fixA0 - logical value of a0 parameter, which allows to fix the parameter (not to fit); axInit - initial value of ax parameter; fixAx - logical value of ax parameter, which allows to fix the parameter (not to fit); ayInit - initial value of ay parameter; fixAy - logical value of ay parameter, which allows to fix the parameter (not to fit) . Definition at line 5652 of file TSpectrum2Fit.cxx. ◆ SetFitParameters(). void TSpectrum2Fit::SetFitParameters ; (; Int_t ; xmin, . Int_t ; xmax, . Int_t ; ymin, . Int_t ; ymax, . Int_t ; numberIterations, . Double_t ; alpha, . Int_t ; statisticType, . Int_t ; alphaOptim, . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:69738,power,power,69738,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['power'],['power']
Energy Efficiency,"x subtraction. Create a matrix C such that C = A - B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> GetMatrix2Array(float* data, Option_t* = """") const; Copy matrix data to array . It is assumed that array is of size >= fNelems. TMatrixTBase<Element> &TMatrixTSparse<Element> SetMatrixArray(Int_t nr_nonzeros, Int_t* irow, Int_t* icol, float* data); Copy nr elements from row/col index and data array to matrix . It is assumed; that arrays are of size >= nr; Note that the input arrays are not passed as const since they will be modified !. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(Int_t nelem_new); Increase/decrease the number of non-zero elements to nelems_new. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndex(const TMatrixTBase<float>& another); Use non-zero data of matrix source to set the sparse structure. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTSparse<Element> &TMatrixTSparse<Element> SetSparseIndexAB(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b); Set the row/column indices to the ""sum"" of matrices a and b; It is checked that enough space has been allocated. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t nr_nonzeros = -1); Set size of the matrix to nrows x ncols with nr_nonzeros non-zero entries; if nr_nonzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are cre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMatrixTSparse_float_.html:20328,allocate,allocated,20328,root/html530/TMatrixTSparse_float_.html,https://root.cern,https://root.cern/root/html530/TMatrixTSparse_float_.html,9,['allocate'],['allocated']
Energy Efficiency,"x tried in track-propagation.; Int_tTPolyMarker3D::fLastPointThe index of the last filled point; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTEveTrack::fLockPointsLock points that are currently in - do nothing in MakeTrack().; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TEveProjectionManager*TEveProjected::fManagermanager; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTPolyMarker3D::fNNumber of allocated points; TStringTPolyMarker3D::fNameName of polymarker; Int_tTEveElement::fNumChildren!; TStringTPolyMarker3D::fOptionOptions; Bool_tTPointSet3D::fOwnIdsFlag specifying id-objects are owned by the point-set; TEveVectorDTEveTrack::fPStarting momentum; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates; TEveVectorDTEveTrack::fPEndMomentum at the last point of extrapolation; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; TEveElement::List_tTEveElement::fParentsList of parents.; TEveTrack::vPathMark_tTEveTrack::fPathMarksTEveVector of known points along the track; Int_tTEveTrack::fPdgPDG code; Bool_tTEveElement::fPickable; TEveProjectable*TEveProjected::fProjectablelink to original object; TEveProjectable::ProjList_tTEveProjectable::fProjectedListreferences to projected instances.; TEveTrackPropagator*TEveTrack::fPropagatorPointer to shared render-style; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveLine::fRnrLine; Bool_tTEveLine::fRnrPoints; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveTrackProjected.html:29867,allocate,allocated,29867,root/html602/TEveTrackProjected.html,https://root.cern,https://root.cern/root/html602/TEveTrackProjected.html,4,['allocate'],['allocated']
Energy Efficiency,"x tried in track-propagation.; Int_tTPolyMarker3D::fLastPointThe index of the last filled point; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTEveTrack::fLockPointsLock points that are currently in - do nothing in MakeTrack().; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TEveProjectionManager*TEveProjected::fManagermanager; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTPolyMarker3D::fNNumber of allocated points; TStringTPolyMarker3D::fNameName of polymarker; Int_tTEveElement::fNumChildren!; TStringTPolyMarker3D::fOptionOptions; Bool_tTPointSet3D::fOwnIdsFlag specifying id-objects are owned by the point-set; TEveVectorDTEveTrack::fPStarting momentum; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates; TEveVectorDTEveTrack::fPEndMomentum at the last point of extrapolation; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; vector<TEvePathMarkT<double> >TEveTrack::fPathMarksTEveVector of known points along the track; Int_tTEveTrack::fPdgPDG code; Bool_tTEveElement::fPickable; TEveProjectable*TEveProjected::fProjectablelink to original object; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; TEveTrackPropagator*TEveTrack::fPropagatorPointer to shared render-style; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveLine::fRnrLine; Bool_tTEveLine::fRnrPoints; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTrackProjected.html:29718,allocate,allocated,29718,root/html534/TEveTrackProjected.html,https://root.cern,https://root.cern/root/html534/TEveTrackProjected.html,2,['allocate'],['allocated']
Energy Efficiency,"x)Clear the pixmap pix.Definition TGX11.cxx:407; TGX11::fTextMagnitudeFloat_t fTextMagnitudeText Magnitude.Definition TGX11.h:138; TGX11::SetCharacterUpvoid SetCharacterUp(Float_t chupx, Float_t chupy) overrideSet character up vector.Definition TGX11.cxx:1983; TGX11::fRootWinDrawable fRootWinRoot window used as parent of all windows.Definition TGX11.h:127; TGX11::WritePixmapvoid WritePixmap(Int_t wid, UInt_t w, UInt_t h, char *pxname) overrideWrite the pixmap wid in the bitmap file pxname.Definition TGX11.cxx:3278; TGX11::SetInputvoid SetInput(Int_t inp)Set input on or off.Definition TGX11.cxx:2257; TGX11::GetPlanesvoid GetPlanes(Int_t &nplanes) overrideGet maximum number of planes.Definition TGX11.cxx:1019; TGX11::fTextAlignHInt_t fTextAlignHText Alignment Horizontal.Definition TGX11.h:133; TGX11::ClearWindowvoid ClearWindow() overrideClear current window.Definition TGX11.cxx:422; TGX11::fXEventvoid * fXEventCurrent native (X11) event.Definition TGX11.h:87; TGX11::fGreenShiftInt_t fGreenShiftBits to left shift green.Definition TGX11.h:144; TGX11::DrawBoxvoid DrawBox(Int_t x1, Int_t y1, Int_t x2, Int_t y2, EBoxMode mode) overrideDraw a box.Definition TGX11.cxx:525; TGX11::CopyPixmapvoid CopyPixmap(Int_t wid, Int_t xpos, Int_t ypos) overrideCopy the pixmap wid at the position xpos, ypos in the current window.Definition TGX11.cxx:496; TGX11::SetOpacityvoid SetOpacity(Int_t percent) overrideSet opacity of a window.Definition TGX11.cxx:2884; TGX11::OpenPixmapInt_t OpenPixmap(UInt_t w, UInt_t h) overrideOpen a new pixmap.Definition TGX11.cxx:1243; TGX11::GetColorXColor_t & GetColor(Int_t cid)Return reference to internal color structure associated to color index cid.Definition TGX11.cxx:909; TGX11::fBlueDivInt_t fBlueDivBlue value divider.Definition TGX11.h:142; TGX11::DrawPolyMarkervoid DrawPolyMarker(Int_t n, TPoint *xy) overrideDraw n markers with the current attributes at position x, y.Definition TGX11.cxx:676; TGX11::CloseWindowvoid CloseWindow() overrideDelete curre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:150061,green,green,150061,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TArrayC; Char_t * fArray;  ;  Public Attributes inherited from TArray; Int_t fN;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);  Check that two sub axis are the same. ;  ; static bool CheckEqualAxes (const TAxis *a1, const TAxis *a2);  Check that the axis are the same. ;  ; static Bool_t RecomputeAxisLimits (TAxis &destAxis, const TAxis &anAxis);  Finds new limits for the axis for the Merge function. ;  ; static Bool_t SameLimitsAndNBins (const TAxis &axis1, const TAxis &axis2);  S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1C.html:47932,power,power,47932,doc/master/classTH1C.html,https://root.cern,https://root.cern/doc/master/classTH1C.html,2,['power'],['power']
Energy Efficiency,"xTreeType)number of signal events (used to compute significance)Definition DataLoader.cxx:371; TMVA::DataLoader::AddSpectatorvoid AddSpectator(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:524; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddBackgroundTreevoid AddBackgroundTree(TTree *background, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)number of signal events (used to compute significance)Definition DataLoader.cxx:402; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Types::kFisher@ kFisherDefinition Types.h:82; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMVA::TMVAGuivoid TMVAGui(const char *fName=""TMVA.root"", TString dataset=""""); Factory.h; AuthorKim Albertsson (adapted from code originally by Andreas Hoecker) ; Definition in file TMVACrossValidation.C. tutorialstmvaTMVACrossValidation.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:30205,adapt,adapted,30205,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['adapt'],['adapted']
Energy Efficiency,"x[0]-par[1])/par[2]);; double r2 = double((x[1]-par[3])/par[4]);; return par[0]*TMath::Exp(-0.5*(r1*r1+r2*r2));; }; double fun2(double *x, double *par) {; double *p1 = &par[0];; double *p2 = &par[5];; double *p3 = &par[10];; double result = g2(x,p1) + g2(x,p2) + g2(x,p3);; return result;; }; ; void fit2() {; const int npar = 15;; double f2params[npar] =; {100,-3,3,-3,3,160,0,0.8,0,0.9,40,4,0.7,4,0.7};; TF2 *f2 = new TF2(""f2"",fun2,-10,10,-10,10, npar);; f2->SetParameters(f2params);; ; //Create an histogram and fill it randomly with f2; TH2F *h2 = new TH2F(""h2"",""from f2"",40,-10,10,40,-10,10);; int nentries = 100000;; h2->FillRandom(""f2"",nentries);; //Fit h2 with original function f2; float ratio = 4*nentries/100000;; f2params[ 0] *= ratio;; f2params[ 5] *= ratio;; f2params[10] *= ratio;; f2->SetParameters(f2params);; h2->Fit(""f2"");; }; TF2.h; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TH2.h; nentriesint nentriesDefinition THbookFile.cxx:91; TMath.h; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF2A 2-Dim function with parameters.Definition TF2.h:29; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; double; xDouble_t x[n]Definition legend1.C:17; RooFit::Detail::MathFuncs::ratiodouble ratio(double numerator, double denominator)Definition MathFuncs.h:103; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; AuthorRene Brun ; Definition in file fit2.C. tutorialsfitfit2.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fit2_8C.html:2999,power,power,2999,doc/master/fit2_8C.html,https://root.cern,https://root.cern/doc/master/fit2_8C.html,1,['power'],['power']
Energy Efficiency,"xcept;  ; reverse_iterator rbegin () noexcept;  ; const_reverse_iterator rend () const noexcept;  ; reverse_iterator rend () noexcept;  ; size_t size () const;  ; size_type size_in_bytes () const;  ;  Public Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase; size_t capacity () const noexcept;  ; bool empty () const;  ; void set_size (size_t N);  Set the array size to N, which the current array must have enough capacity for. ;  ; size_t size () const;  . Private Types; using SuperClass = RVecN< T, Internal::VecOps::RVecInlineStorageSize< T >::value >;  . Friends; void Internal::VecOps::ResetView (RVec< T > &v, T *addr, std::size_t sz);  ; bool ROOT::Detail::VecOps::IsAdopting (const RVec< T > &v);  ; bool ROOT::Detail::VecOps::IsSmall (const RVec< T > &v);  . Additional Inherited Members;  Protected Member Functions inherited from ROOT::Detail::VecOps::RVecImpl< T >;  RVecImpl (unsigned N);  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorTemplateBase< T, bool >;  SmallVectorTemplateBase (size_t Size);  ; void grow (size_t MinSize=0);  Grow the allocated memory (without initializing new elements), doubling the size of the allocated memory. ;  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorTemplateCommon< T >;  SmallVectorTemplateCommon (size_t Size);  ; void grow_pod (size_t MinSize, size_t TSize);  ; bool isSmall () const;  Return true if this is a smallvector which has not had dynamic memory allocated for it. ;  ; void resetToSmall ();  Put this vector in a state of being small. ;  ;  Protected Member Functions inherited from ROOT::Internal::VecOps::SmallVectorBase;  SmallVectorBase ()=delete;  ;  SmallVectorBase (void *FirstEl, size_t TotalCapacity);  ; void grow_pod (void *FirstEl, size_t MinSize, size_t TSize);  This is an implementation of the grow() method which only works on POD-like data types and is out of line to reduce code duplication. ;  ; bool Owns () const;  If fals",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html:17980,allocate,allocated,17980,doc/v632/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html,4,['allocate'],['allocated']
Energy Efficiency,"xel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHtml(const TGWindow* p, int w, int h, int id = -1); HTML Widget constructor. ~TGHtml(); HTML widget destructor. void UpdateBackgroundStart(); Start background update. void FreeColor(ColorStruct_t* color); Free system color. ColorStruct_t * AllocColor(const char* name); Allocate system color by name. ColorStruct_t * AllocColorByValue(ColorStruct_t* color); Allocate system color by value. void Clear(Option_t* = """"); Erase all HTML from this widget and clear the screen. This is; typically done before loading a new document. int ParseText(char* text, const char* index = 0); Appends (or insert at the specified position) the given HTML text to the; end of any HTML text that may have been inserted by prior calls to this; command. Then it runs the tokenizer, parser and layout engine as far as; possible with the text that is available. The display is updated; appropriately. void SetTableRelief(int relief); Sets relief mode of html table. void SetRuleRelief(int relief); Sets relief mode of html rule. void UnderlineLinks(int onoff); Set/reset html links underline. void SetBaseUri(const char* uri); Sets base URI. int GotoAnchor(const char* name); Go to anchor position. const char * GetUid(const char* string); Given a string, this procedure returns a uniq",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGHtml.html:31953,Allocate,Allocate,31953,root/html532/TGHtml.html,https://root.cern,https://root.cern/root/html532/TGHtml.html,2,['Allocate'],['Allocate']
Energy Efficiency,"ximate; is introduced to enable or disable (default) the approximation. Ideas for improvements of this algorithm are welcome. No suggestions; received since our call for advice to roottalk in Jul 2002.; see for instance: http://root.cern.ch/root/roottalk/roottalk02/2916.html. Option_t * GetErrorOption() const; -*Return option to compute profile errors; *-* =======================================. void GetStats(Double_t* stats) const; fill the array stats from the contents of this profile; The array stats must be correctly dimensionned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2; stats[4] = sumwy; stats[5] = sumwy2. If no axis-subrange is specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. void LabelsDeflate(Option_t* axis = ""X""); Reduce the number of bins for this axis to the number of bins having a label. void LabelsInflate(Option_t* axis = ""X""); Double the number of bins for axis.; Refill histogram; This function is called by TAxis::FindBin(const char *label). void LabelsOption(Option_t* option = ""h"", Option_t* axis = ""X""); Set option(s) to draw axis with labels; option = ""a"" sort by alphabetic order; = "">"" sort by decreasing values; = ""<"" sort by increasing values; = ""h"" draw labels horizonthal; = ""v"" draw labels vertical; = ""u"" draw labels up (end of label right adjusted); = ""d"" draw labels down (start of label left adjusted). Long64_t Merge(TCollection* list); Merge all histograms in the collection in this histogram.; This function computes the min/max for the x axis,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is succes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProfile.html:39859,Reduce,Reduce,39859,root/html602/TProfile.html,https://root.cern,https://root.cern/root/html602/TProfile.html,2,['Reduce'],['Reduce']
Energy Efficiency,ximum size of file buffers; Long64_tfChainOffset! Offset of 1st entry of this Tree in a TChain; TList*fClones! List of cloned trees which share our addresses; Long64_t*fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfDebug! Debug level; Long64_tfDebugMax! Last entry number to debug; Long64_tfDebugMin! First entry number to debug; Int_tfDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*fDirectory! Pointer to directory holding this tree; Long64_tfEntriesNumber of entries; TEntryList*fEntryList! Pointer to event selection list (if one); Long64_tfEstimateNumber of entries to estimate histogram limits; TEventList*fEventList! Pointer to event selection list (if one); Int_tfFileNumber! current file number (if file extensions); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tfFlushedBytesNumber of autoflushed bytes; UInt_tfFriendLockStatus! Record which method is locking the friend recursion; TList*fFriendspointer to list of friend elements; TArrayIfIndexIndex of sorted values; TArrayDfIndexValuesSorted index values; TObjArrayfLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tfMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tfMaxClusterRange! Memory allocated for the cluster range.; Long64_tfMaxEntriesMaximum number of entries in case of circular buffers; Long64_tfMaxEntryLoopMaximum number of entries to process; Long64_tfMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tfNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject id,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:32174,allocate,allocated,32174,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,3,['allocate'],['allocated']
Energy Efficiency,"xisting i/o buffers are deleted.; Entries, max and min are reset. void ResetAfterMerge(TFileMergeInfo* ); Reset a Branch after a Merge operation (drop data but keep customizations). void ResetAddress(); Set branch address to zero and free all allocated memory. void ResetDeleteObject(); -- Release ownership of any allocated objects. Note: This interface was added so that clone trees could; be told they do not own the allocated objects. void SetAddress(void* addobj); -- Point this branch at an object. For a sub-branch, addr is a pointer to the branch object. For a top-level branch the meaning of addr is as follows:. If addr is zero, then we allocate a branch object; internally and the branch is the owner of the allocated; object, not the caller. However the caller may obtain; a pointer to the branch object with GetObject(). Example:. branch->SetAddress(0);; Event* event = branch->GetObject();; ... Do some work. If addr is not zero, but the pointer addr points at is; zero, then we allocate a branch object and set the passed; pointer to point at the allocated object. The caller; owns the allocated object and is responsible for deleting; it when it is no longer needed. Example:. Event* event = 0;; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. If addr is not zero and the pointer addr points at is; also not zero, then the caller has allocated a branch; object and is asking us to use it. The caller owns it; and must delete it when it is no longer needed. Example:. Event* event = new Event();; branch->SetAddress(&event);; ... Do some work.; delete event;; event = 0;. These rules affect users of TTree::Branch(),; TTree::SetBranchAddress(), and TChain::SetBranchAddress(); as well because those routines call this one. An example of a tree with branches with objects allocated; and owned by us:. TFile* f1 = new TFile(""myfile_original.root"");; TTree* t1 = (TTree*) f->Get(""MyTree"");; TFile* f2 = new TFile(""myfile_copy.root"", ""recreate"");; TTree* t2 = t1-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBranchElement.html:31401,allocate,allocate,31401,root/html532/TBranchElement.html,https://root.cern,https://root.cern/root/html532/TBranchElement.html,16,['allocate'],"['allocate', 'allocated']"
Energy Efficiency,"xp,yp lies inside the polygon defined by the np points in arrays x and y, kFALSE otherwise. ; Note that the polygon may be open or closed. ; Definition at line 1233 of file TMath.h. ◆ IsNaN() [1/2]. Bool_t TMath::IsNaN ; (; Double_t ; x). inline . Definition at line 892 of file TMath.h. ◆ IsNaN() [2/2]. Bool_t TMath::IsNaN ; (; Float_t ; x). inline . Definition at line 893 of file TMath.h. ◆ K(). constexpr Double_t TMath::K ; (; ). constexpr . Boltzmann's constant in \( J K^{-1} \): \( k \). ; Definition at line 247 of file TMath.h. ◆ Kcgs(). constexpr Double_t TMath::Kcgs ; (; ). constexpr . \( erg K^{-1} \) ; Definition at line 254 of file TMath.h. ◆ KolmogorovProb(). Double_t TMath::KolmogorovProb ; (; Double_t ; z). Calculates the Kolmogorov distribution function,. . \[; P(z) = 2 \sum_{j=1}^{\infty} (-1)^{j-1} e^{-2 j^2 z^2}; \]. which gives the probability that Kolmogorov's test statistic will exceed the value z assuming the null hypothesis. This gives a very powerful test for comparing two one-dimensional distributions. see, for example, Eadie et al, ""statistical Methods in Experimental; Physics', pp 269-270). This function returns the confidence level for the null hypothesis, where:; - \_form#593, and; - \_form#594 is the maximum deviation between a hypothetical distribution; function and an experimental distribution with; - \_form#354 events. NOTE: To compare two experimental distributions with m and n events,; use \_form#595. Accuracy: The function is far too accurate for any imaginable application.; Probabilities less than \_form#596 are returned as zero.; However, remember that the formula is only valid for ""large"" n.; Theta function inversion formula is used for z <= 1; This function was translated by Rene Brun from PROBKL in CERNLIB. ; Definition at line 679 of file TMath.cxx. ◆ KolmogorovTest(). Double_t TMath::KolmogorovTest ; (; Int_t ; na, . const Double_t * ; a, . Int_t ; nb, . const Double_t * ; b, . Option_t * ; option . ). Statistical test whethe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:50174,power,powerful,50174,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['power'],['powerful']
Energy Efficiency,"xpr . \( \frac{\pi}{2} \) ; Definition at line 51 of file TMath.h. ◆ PiOver4(). constexpr Double_t TMath::PiOver4 ; (; ). constexpr . \( \frac{\pi}{4} \) ; Definition at line 58 of file TMath.h. ◆ Poisson(). Double_t TMath::Poisson ; (; Double_t ; x, . Double_t ; par . ). Computes the Poisson distribution function for (x,par). ; The Poisson PDF is implemented by means of Euler's Gamma-function (for the factorial), so for any x integer argument it is the correct Poisson distribution. BUT for non-integer x values, it IS NOT equal to the Poisson distribution !. Definition at line 587 of file TMath.cxx. ◆ PoissonI(). Double_t TMath::PoissonI ; (; Double_t ; x, . Double_t ; par . ). Computes the Discrete Poisson distribution function for (x,par). ; This is a discrete and a non-smooth function. This function is equivalent to ROOT::Math::poisson_pdf. Definition at line 615 of file TMath.cxx. ◆ Power() [1/5]. Double_t TMath::Power ; (; Double_t ; x, . Double_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 739 of file TMath.h. ◆ Power() [2/5]. Double_t TMath::Power ; (; Double_t ; x, . Int_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 745 of file TMath.h. ◆ Power() [3/5]. LongDouble_t TMath::Power ; (; Long64_t ; x, . Long64_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 733 of file TMath.h. ◆ Power() [4/5]. LongDouble_t TMath::Power ; (; LongDouble_t ; x, . Long64_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 727 of file TMath.h. ◆ Power() [5/5]. LongDouble_t TMath::Power ; (; LongDouble_t ; x, . LongDouble_t ; y . ). inline . Returns x raised to the power y. ; Definition at line 721 of file TMath.h. ◆ Prob(). Double_t TMath::Prob ; (; Double_t ; chi2, . Int_t ; ndf . ). Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ; Calculations are based on the incomplete gamma function P(a,x), where a=ndf/2 and x=chi2/2.; P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:71890,power,power,71890,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['power'],['power']
Energy Efficiency,"xpressed in the base specified (range=2-36), i.e. ; {0,1} for base 2, {0-9,a-f,A-F} for base 16, {0-9,a-z,A-Z} for base 36. Returns false in case string length is 0 or string contains other characters. ; Definition at line 1957 of file TString.cxx. ◆ IsLong(). Bool_t TString::IsLong ; (; ); const. inlineprivate . Definition at line 238 of file TString.h. ◆ IsNull(). Bool_t TString::IsNull ; (; ); const. inline . Definition at line 414 of file TString.h. ◆ IsOct(). Bool_t TString::IsOct ; (; ); const. Returns true if all characters in string are octal digits (0-7). ; Returns false in case string length is 0 or string contains other characters. ; Definition at line 1924 of file TString.cxx. ◆ IsWhitespace(). Bool_t TString::IsWhitespace ; (; ); const. inline . Definition at line 415 of file TString.h. ◆ Itoa(). TString TString::Itoa ; (; Int_t ; value, . Int_t ; base . ). static . Converts an Int_t to a TString with respect to the base specified (2-36). ; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html). Usage: the following statement produce the same output, namely ""1111"" std::cout << TString::Itoa(15,2) ;; std::cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; std::cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; TString::Itoastatic TString Itoa(Int_t value, Int_t base)Converts an Int_t to a TString with respect to the base specified (2-36).Definition TString.cxx:2092; In case of error returns the ""!"" string. ; Definition at line 2092 of file TString.cxx. ◆ Last(). Ssiz_t TString::Last ; (; char ; c); const. Find last occurrence of a character c. ; Definition at line 931 of file TString.cxx. ◆ Length(). Ssiz_t TString::Length ; (; ); const. inline . Definition at line 417 of file TString.h. ◆ LLtoa(). TString TString::LLtoa ; (; Long64_t ; value, . Int_t ; base . ). static . Converts a Long64_t to a TString with respect to the base specified (2-36). ; Thus it is an enhanced vers",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTString.html:41416,adapt,adapted,41416,doc/v632/classTString.html,https://root.cern,https://root.cern/doc/v632/classTString.html,2,['adapt'],['adapted']
Energy Efficiency,"xpression, const ColumnNames_t &columns={});  Overwrite the value and/or type of an existing column. ;  ; RInterface< Proxied, DS_t > Redefine (std::string_view name, std::string_view expression);  Overwrite the value and/or type of an existing column. ;  ; template<typename F > ; RInterface< Proxied, DS_t > RedefineSlot (std::string_view name, F expression, const ColumnNames_t &columns={});  Overwrite the value and/or type of an existing column. ;  ; template<typename F > ; RInterface< Proxied, DS_t > RedefineSlotEntry (std::string_view name, F expression, const ColumnNames_t &columns={});  Overwrite the value and/or type of an existing column. ;  ; template<typename F , typename T = typename TTraits::CallableTraits<F>::ret_type> ; RResultPtr< T > Reduce (F f, std::string_view columnName, const T &redIdentity);  Execute a user-defined reduce operation on the values of a column. ;  ; template<typename F , typename T = typename TTraits::CallableTraits<F>::ret_type> ; RResultPtr< T > Reduce (F f, std::string_view columnName="""");  Execute a user-defined reduce operation on the values of a column. ;  ; RResultPtr< RCutFlowReport > Report ();  Gather filtering statistics. ;  ; template<typename... ColumnTypes> ; RResultPtr< RInterface< RLoopManager > > Snapshot (std::string_view treename, std::string_view filename, const ColumnNames_t &columnList, const RSnapshotOptions &options=RSnapshotOptions());  Save selected columns to disk, in a new TTree treename in file filename. ;  ; RResultPtr< RInterface< RLoopManager > > Snapshot (std::string_view treename, std::string_view filename, const ColumnNames_t &columnList, const RSnapshotOptions &options=RSnapshotOptions());  Save selected columns to disk, in a new TTree treename in file filename. ;  ; RResultPtr< RInterface< RLoopManager > > Snapshot (std::string_view treename, std::string_view filename, std::initializer_list< std::string > columnList, const RSnapshotOptions &options=RSnapshotOptions());  Save selected columns to d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:15755,reduce,reduce,15755,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['reduce'],['reduce']
Energy Efficiency,"xternal covariance matrix designed for the interaction of the user. The result of the minimization (internal covariance matrix) is converted into the user representable format. It can also be used as input prior to the minimization. The size of the covariance matrix is according to the number of variable parameters (free and limited).; 5.13.1 MnUserCovariance(const std::vector\(<\)double\(>\)&, unsigned int nrow); Construct from data, positions of the elements in the array are arranged according to the packed storage format. The size of the array must be \(nrow*(nrow+1)/2\). The array must contain the upper triangular part of the symmetric matrix packed sequentially, column by column, so that arr(0) contains covar(0,0), arr(1) and arr(2) contain covar(0,1) and covar(1,1) respectively, and so on. The number of rows (columns) has to be specified.; 5.13.2 MnUserCovariance(unsigned int nrow); Specify the number of rows (columns) at instantiation. It will allocate an array of the length \(nrow*(nrow+1)/2\) and initialize it to \(0\). Elements can then be set using the method operator()(unsigned int, unsigned int).; 5.13.3 MnUserCovariance::operator()(unsigned int, unsigned int); Individual elements can be accessed via the operator(), both for reading and writing.; 5.14 MnUserParameters; [api:parameters] MnUserParameters is the main class for user interaction with the parameters. It serves both as input to the minimization as well as output as the result of the minimization is converted into the user representable format in order to allow for further interaction. Parameters for M can be added (defined) specifying a name, value and initial uncertainty.; 5.14.1 add(…); The method MnUserParameters::add(…) is overloaded for three kind of parameters:. add(const char*, double, double) for adding a free variable parameter; add(const char*, double, double, double, double) for adding a variable parameter with limits (lower and upper); add(const char*, double) for adding a constant",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:53883,allocate,allocate,53883,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,['allocate'],['allocate']
Energy Efficiency,"xtract the correlation matrix and the; global correlation coefficients from the MINUIT memory buffer and; fill the internal arrays. Bool_t isIdentical(const RooFitResult& other, Double_t tol = 5e-5, Double_t tolCorr = 1e-4, Bool_t verbose = kTRUE) const; Return true if this fit result is identical to other within tolerance 'tol' on fitted values; and tolerance 'tolCor' on correlation coefficients. RooFitResult* lastMinuitFit(const RooArgList& varList = RooArgList()); Import the results of the last fit performed by gMinuit, interpreting; the fit parameters as the given varList of parameters. void setCovarianceMatrix(TMatrixDSym& V); Store externally provided correlation matrix in his RooFitResult ;. TH2* correlationHist(const char* name = ""correlation_matrix"") const; Return TH2D of correlation matrix. const TMatrixDSym& covarianceMatrix() const; Return covariance matrix. TMatrixDSym reducedCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix (Note that Vred _is_ a simple sub-matrix of V,; row/columns are ordered to matched the convention given in input argument 'params'. TMatrixDSym conditionalCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix, which is calculated as; ___ -1; Vred = V22 = V11 - V12 * V22 * V21. Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; is the Shur complement of V22, calculated as shown above. (Note that Vred is _not_ a simple sub-matrix of V). const TMatrixDSym& correlationMatrix() const; Return correlation matrix ;. RooAbsPdf* createHessePdf(const RooArgSet& params) const; Return a p.d.f that represents the fit result as a multi-variate probability densisty; function on the floating fit parameters, including correlations. void SetName(const char* name); Change name of RooFitResult object. void SetNameTitle(const char* name, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFitResult.html:14786,reduce,reducedCovarianceMatrix,14786,root/html532/RooFitResult.html,https://root.cern,https://root.cern/root/html532/RooFitResult.html,8,['reduce'],"['reduced', 'reducedCovarianceMatrix']"
Energy Efficiency,"xx. ◆ IsA(). TClass * RooStats::HypoTestInverterPlot::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 76 of file HypoTestInverterPlot.h. ◆ MakeExpectedPlot(). TMultiGraph * HypoTestInverterPlot::MakeExpectedPlot ; (; double ; sig1 = 1, . double ; sig2 = 2 . ). Make the expected plot and the bands nsig1 and nsig2 indicates the n-sigma value for the bands if nsig1 = 0 no band is computed (only expected value) if nsig2 > nsig1 (default is nsig1=1 and nsig2=2) the second band is also done. ; Make the expected plot and the bands nsig1 and nsig2 indicates the n-sigma value for the bands if nsig1 = 0 no band is drawn (only expected value) if nsig2 > nsig1 (default is nsig1=1 and nsig2=2) the second band is also drawn The first band is drawn in green while the second in yellow THe return result is a TMultiGraph object.; The first band is drawn in green while the second in yellow The plot (expected value + bands) is returned as a TMultiGraph object ; Definition at line 149 of file HypoTestInverterPlot.cxx. ◆ MakePlot(). TGraphErrors * HypoTestInverterPlot::MakePlot ; (; Option_t * ; opt = """"). return a TGraphErrors with the obtained observed p-values resultinf from the scan By default (Option = """") return CLs or CLsb depending if the flag UseCLs is set If Option = ""CLb"" return CLb plot = ""CLs+b"" return CLs+b plot independently of the flag = ""CLs"" return CLs plot independently of the flag ; Make the plot of the result of the scan using the observed data.; By default plot CLs or CLsb depending if the flag UseCLs is set for the results that are passed to this instance.; Parameters. optOptions according to following list:; Empty: Return CLs or CLs+b depending on the value of UseCLs.ƒ; ""CLB"": return CLb plot; ""CLS+B"" / ""CLSPLUSB"": return CLs+b plot independently of the flag; ""CLS"": return CLs plot independently of the flag . Definition at line 80 of file HypoTestInverterPlot.cxx. ◆ MakeTestStatPl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterPlot.html:16067,green,green,16067,doc/master/classRooStats_1_1HypoTestInverterPlot.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterPlot.html,1,['green'],['green']
Energy Efficiency,"xx. ◆ reduce() [2/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooArgSet & ; varSubset, . const char * ; cut = nullptr . ); const. Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ; The cut expression can refer to any variable in the data set. For cuts involving other variables, such as intermediate formula objects, use the equivalent reduce method specifying the as a RooFormulVar reference. ; Definition at line 500 of file RooAbsData.cxx. ◆ reduce() [3/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooArgSet & ; varSubset, . const RooFormulaVar & ; cutVar . ); const. Create a subset of the data set by applying the given cut on the data points and reducing the dimensions to the specified set. ; The 'cutVar' formula variable is used to select the subset of data points to be retained in the reduced data collection. ; Definition at line 530 of file RooAbsData.cxx. ◆ reduce() [4/5]. RooFit::OwningPtr< RooAbsData > RooAbsData::reduce ; (; const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ); const. Create a reduced copy of this dataset. ; The caller takes ownership of the returned dataset; The following optional named arguments are accepted . SelectVars(const RooArgSet& vars) Only retain the listed observables in the output dataset . Cut(const char* expression) Only retain event surviving the given cut expression. . Cut(const RooFormulaVar& expr) Only retain event surviving the given cut formula. . CutRange(const char* name) Only retain events inside range with given name. Multiple CutRange arguments may be given to select multiple ranges. Note that this will also consider the variables that are not selected by SelectVars(). . EventRange(int lo, int hi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:63355,reduce,reduce,63355,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['reduce'],['reduce']
Energy Efficiency,"xy.cxx:168; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; TMVA::DNN::ClassificationSettings::startTrainCyclevoid startTrainCycle()action to be done when the training cycle is started (e.g.Definition NeuralNet.cxx:281; TMVA::DNN::ClassificationSettings::endTrainCyclevoid endTrainCycle(double)action to be done when the training cycle is ended (e.g.Definition NeuralNet.cxx:296; TMVA::DNN::ClassificationSettings::endTestCyclevirtual void endTestCycle()action to be done when the training cycle is ended (e.g.Definition NeuralNet.cxx:326; TMVA::DNN::ClassificationSettings::m_pResultPatternContainerstd::vector< Pattern > * m_pResultPatternContainerDefinition NeuralNet.h:1009; TMVA::DNN::ClassificationSettings::setResultComputationvoid setResultComputation(std::string _fileNameNetConfig, std::string _fileNameResult, std::vector< Pattern > *_resultPatternContainer)preparation for monitoring outputDefinition NeuralNet.cxx:520; TMVA::DNN::ClassificationSettings::m_fileNameResultstd::string m_fileNameResultDefinition NeuralNet.h:1010; TMVA::DNN::ClassificationSettings::m_significancesstd::vector< double > m_significancesDefinition NeuralNet.h:1001; TMVA::DNN::ClassificationSettings::m_sumOfSigWeightsdouble m_sumOfSigWeightsDefinition NeuralNet.h:1004; TMVA::DNN::ClassificationSettings::m_weightsstd::vector< double > m_weightsDefinition NeuralNet.h:998; TMVA::DNN::ClassificationSettings::m_fileNameNetConfigstd::string m_fileNameNetConfigDefinition NeuralNet.h:1011; TMVA::DNN::ClassificationSettings::m_targetsstd::vector< double > m_targetsDefinition NeuralNet.h:997; TMVA::DNN::ClassificationSettings::testSamplevoid testSample(double error, double output, double target, double weight)action to be done after the computation of a test sample (e.g.Definition NeuralNet.cxx:304; TMVA:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:22210,monitor,monitoring,22210,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,1,['monitor'],['monitoring']
Energy Efficiency,"xyInfo::Environ<char[64]> TGenCollectionProxy::Env_t. protected . Definition at line 287 of file TGenCollectionProxy.h. ◆ EnvironBase_t. typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase TGenCollectionProxy::EnvironBase_t. protected . Definition at line 288 of file TGenCollectionProxy.h. ◆ Feedfunc_t. typedef void *(* TGenCollectionProxy::Feedfunc_t) (void *from, void *to, size_t size). protected . Definition at line 295 of file TGenCollectionProxy.h. ◆ Info_t. typedef const std::type_info& TGenCollectionProxy::Info_t. Definition at line 41 of file TGenCollectionProxy.h. ◆ Proxies_t. typedef std::vector<EnvironBase_t*> TGenCollectionProxy::Proxies_t. protected . Definition at line 290 of file TGenCollectionProxy.h. ◆ Sizing_t. typedef void(* TGenCollectionProxy::Sizing_t) (void *obj, size_t size). protected . Definition at line 294 of file TGenCollectionProxy.h. ◆ Staged_t. typedef std::vector<TStaging*> TGenCollectionProxy::Staged_t. protected . Collection of pre-allocated staged array for associative containers. ; Definition at line 289 of file TGenCollectionProxy.h. Member Enumeration Documentation. ◆ anonymous enum. anonymous enum. EnumeratorkBIT_ISSTRING ; kBIT_ISTSTRING . Definition at line 44 of file TGenCollectionProxy.h. Constructor & Destructor Documentation. ◆ TGenCollectionProxy() [1/4]. TGenCollectionProxy::TGenCollectionProxy ; (; ). private . ◆ TGenCollectionProxy() [2/4]. TGenCollectionProxy::TGenCollectionProxy ; (; const TGenCollectionProxy & ; copy). Build a proxy for an emulated container. ; Definition at line 556 of file TGenCollectionProxy.cxx. ◆ TGenCollectionProxy() [3/4]. TGenCollectionProxy::TGenCollectionProxy ; (; Info_t ; typ, . size_t ; iter_size . ). Build a proxy for a collection whose type is described by 'collectionClass'. ; Definition at line 594 of file TGenCollectionProxy.cxx. ◆ TGenCollectionProxy() [4/4]. TGenCollectionProxy::TGenCollectionProxy ; (; const ROOT::Detail::TCollectionProxyInfo & ; info, . TClass * ; cl . ). B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:14064,allocate,allocated,14064,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['allocate'],['allocated']
Energy Efficiency,"y constructor. Bool_t Decompose(); Matrix A is decomposed in components U and L so that P * A = U * L; If the decomposition succeeds, bit kDecomposed is set , otherwise kSingular. const TMatrixD GetMatrix(); Reconstruct the original matrix using the decomposition parts. void SetMatrix(const TMatrixD& a); Set matrix to be decomposed. Bool_t Solve(TVectorD& b); Solve Ax=b assuming the LU form of A is stored in fLU, but assume b has *not*; been transformed. Solution returned in b. Bool_t Solve(TMatrixDColumn& b); Solve Ax=b assuming the LU form of A is stored in fLU, but assume b has *not*; been transformed. Solution returned in b. Bool_t TransSolve(TVectorD& b); Solve A^T x=b assuming the LU form of A^T is stored in fLU, but assume b has *not*; been transformed. Solution returned in b. Bool_t TransSolve(TMatrixDColumn& b); Solve A^T x=b assuming the LU form of A^T is stored in fLU, but assume b has *not*; been transformed. Solution returned in b. void Det(Double_t& d1, Double_t& d2); Calculate determinant det = d1*TMath::Power(2.,d2). Bool_t Invert(TMatrixD& inv); For a matrix A(m,m), its inverse A_inv is defined as A * A_inv = A_inv * A = unit; (m x m) Ainv is returned . TMatrixD Invert(Bool_t& status); For a matrix A(m,n), its inverse A_inv is defined as A * A_inv = A_inv * A = unit; (n x m) Ainv is returned . void Print(Option_t* opt = """") const; Print internals of this object. TDecompLU & operator=(const TDecompLU& source); assignement operator. Bool_t DecomposeLUCrout(TMatrixD& lu, Int_t* index, Double_t& sign, Double_t tol, Int_t& nrZeros); Crout/Doolittle algorithm of LU decomposing a square matrix, with implicit partial; pivoting. The decomposition is stored in fLU: U is explicit in the upper triag; and L is in multiplier form in the subdiagionals .; Row permutations are mapped out in fIndex. fSign, used for calculating the; determinant, is +/- 1 for even/odd row permutations. . Bool_t DecomposeLUGauss(TMatrixD& lu, Int_t* index, Double_t& sign, Double_t tol, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDecompLU.html:9707,Power,Power,9707,root/html532/TDecompLU.html,https://root.cern,https://root.cern/root/html532/TDecompLU.html,4,['Power'],['Power']
Energy Efficiency,"y copy is deleted and the object is again read from the file. If opt==""dirs"", only subdirectories will be read If opt==""dirs*"" complete directory tree will be read ; Reimplemented from TDirectory.; Definition at line 1326 of file TDirectoryFile.cxx. ◆ ReadKeys(). Int_t TDirectoryFile::ReadKeys ; (; Bool_t ; forceRead = kTRUE). overridevirtual . Read the linked list of keys. ; Every directory has a linked list (fKeys). This linked list has been written on the file via WriteKeys as a single data record.; It is interesting to call this function in the following situation. Assume another process1 is connecting this directory in Update mode; Process1 is adding/updating objects in this directory; You want to see the latest status from process1. Example Process1: obj1.Write();; obj2.Write();; gDirectory->SaveSelf();; gDirectory#define gDirectoryDefinition TDirectory.h:384. Example Process2: gDirectory->ReadKeys();; obj1->Draw();; This is an efficient way (without opening/closing files) to view the latest updates of a file being modified by another process as it is typically the case in a data acquisition system. ; Reimplemented from TDirectory.; Definition at line 1379 of file TDirectoryFile.cxx. ◆ ReadTObject(). Int_t TDirectoryFile::ReadTObject ; (; TObject * ; obj, . const char * ; keyname . ). overridevirtual . Read object with keyname from the current directory. ; Read contents of object with specified name from the current directory. First the key with keyname is searched in the current directory, next the key buffer is deserialized into the object. The object must have been created before via the default constructor. See TObject::Write(). ; Reimplemented from TDirectory.; Definition at line 1465 of file TDirectoryFile.cxx. ◆ ResetAfterMerge(). void TDirectoryFile::ResetAfterMerge ; (; TFileMergeInfo * ; info). virtual . Reset the TDirectory after its content has been merged into another Directory. ; This returns the TDirectoryFile object back to its state before any",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDirectoryFile.html:44155,efficient,efficient,44155,doc/master/classTDirectoryFile.html,https://root.cern,https://root.cern/doc/master/classTDirectoryFile.html,1,['efficient'],['efficient']
Energy Efficiency,"y interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TSpectrumTransform might still be a valid solution. For modeling a spectrum fitting and estimating the background one can use RooFit while for deconvolution and unfolding one can use TUnfold.; Class to carry out transforms of 1D spectra, its filtering and enhancement. It allows to calculate classic Fourier, Cosine, Sin, Hartley, Walsh, Haar transforms as well as mixed transforms (Fourier- Walsh, Fourier-Haar, Walsh-Haar, Cosine-Walsh, Cosine-Haar, Sin-Walsh and Sin-Haar). All the transforms are fast.; The algorithms in this class have been published in the following references:. C.V. Hampton, B. Lian, Wm. C. McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray spectroscopy.NIM A353(1994) 280-284.; Morhac M., Matousek V., New adaptive Cosine-Walsh transform and its application to nuclear data compression, IEEE Transactions on Signal Processing 48 (2000) 2693.; Morhac M., Matousek V., Data compression using new fast adaptive Cosine-Haar transforms, Digital Signal Processing 8 (1998) 63.; Morhac M., Matousek V.: Multidimensional nuclear data compression using fast adaptive Walsh-Haar transform. Acta Physica Slovaca 51 (2001) 307. . Definition at line 18 of file TSpectrumTransform.h. Public Types; enum  { ;   kTransformHaar =0; , kTransformWalsh =1; , kTransformCos =2; , kTransformSin =3; , ;   kTransformFourier =4; , kTransformHartley =5; , kTransformFourierWalsh =6; , kTransformFourierHaar =7; , ;   kTransformWalshHaar =8; , kTransformCosWalsh =9; , kTransformCosHaar =10; , kTransformSinWalsh =11; , ;   kTransformSinHaar =12; , kTransformForward =0; , kTransformInverse =1. };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumTransform.html:1451,adapt,adaptive,1451,doc/master/classTSpectrumTransform.html,https://root.cern,https://root.cern/doc/master/classTSpectrumTransform.html,1,['adapt'],['adaptive']
Energy Efficiency,"y knew PAW the twenty-year-old FORTRAN libraries had reached their limits. Although still very popular, these tools could not scale up to the challenges offered by the Large Hadron Collider, where the data is a few orders of magnitude larger than anything seen before.; At the same time, computer science had made leaps of progress especially in the area of Object Oriented Design, and René and Fons were ready to take advantage of it.; ROOT was developed in the context of the NA49 experiment at CERN. NA49 has generated an impressive amount of data, around 10 Terabytes per run. This rate provided the ideal environment to develop and test the next generation data analysis.; ROOT was, and still is, developed in the “Bazaar style”, a term from the book “The Cathedral and the Bazaar” by Eric S. Raymond. It means a liberal, informal development style that heavily relies on the diverse and deep talent of the user community. The result is that physicists developed ROOT for themselves; this made it specific, appropriate, useful, and over time refined and very powerful. The development of ROOT is a continuous conversation between users and developers with the line between the two blurring at times and the users becoming co-developers.; When it comes to storing and mining large amount of data, physics plows the way with its Terabytes, but other fields and industry follow close behind as they acquiring more and more data over time. They are ready to use the true and tested technologies physics has invented. In this way, other fields and industries have found ROOT useful and they have started to use it also.; In the bazaar view, software is released early and frequently to expose it to thousands of eager co-developers to pound on, report bugs, and contribute possible fixes. More users find more bugs, because they stress the program in different ways. By now, after ten years, the age of ROOT is quite mature. Most likely, you will find the features you are looking for, and if you hav",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:7122,power,powerful,7122,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['power'],['powerful']
Energy Efficiency,"y not be used (but we need to provide it since it is a pure virtual in TCollection). ;  ; Float_t AverageCollisions () const;  Return the ratio of entries vs occupied slots. ;  ; Int_t Capacity () const;  Return number of slots in the hashtable. ;  ; void Clear (Option_t *option="""") override;  Remove all (key,value) pairs from the map. ;  ; Int_t Collisions (const char *keyname) const;  Returns the number of collisions for a key with a certain name (i.e. ;  ; Int_t Collisions (TObject *key) const;  Returns the number of collisions for a key (i.e. ;  ; void Delete (Option_t *option="""") override;  Remove all (key,value) pairs from the map AND delete the keys when they are allocated on the heap. ;  ; void DeleteAll ();  Remove all (key,value) pairs from the map AND delete the keys AND values when they are allocated on the heap. ;  ; Bool_t DeleteEntry (TObject *key);  Remove (key,value) pair with key from the map. ;  ; void DeleteKeys ();  ; void DeleteValues ();  Remove all (key,value) pairs from the map AND delete the values when they are allocated on the heap. ;  ; TObject * FindObject (const char *keyname) const override;  Check if a (key,value) pair exists with keyname as name of the key. ;  ; TObject * FindObject (const TObject *key) const override;  Check if a (key,value) pair exists with key as key. ;  ; TObject ** GetObjectRef (const TObject *obj) const override;  ; const THashTable * GetTable () const;  ; TObject * GetValue (const char *keyname) const;  Returns a pointer to the value associated with keyname as name of the key. ;  ; TObject * GetValue (const TObject *key) const;  Returns a pointer to the value associated with key. ;  ; TClass * IsA () const override;  ; Bool_t IsOwnerValue () const;  ; TIterator * MakeIterator (Bool_t dir=kIterForward) const override;  Create an iterator for TMap. ;  ; TObject * operator() (const char *keyname) const;  ; TObject * operator() (const TObject *key) const;  ; void Rehash (Int_t newCapacity, Bool_t checkObjValidity",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMap.html:2970,allocate,allocated,2970,doc/master/classTMap.html,https://root.cern,https://root.cern/doc/master/classTMap.html,1,['allocate'],['allocated']
Energy Efficiency,"y of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used in a fit, the parameter; can vary freely. The parameter limits are reset to 0,0. void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); Save values of function in array fSave. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetCurrent(TF1* f1); Static function setting the current function.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:58892,adapt,adaptive,58892,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,6,['adapt'],['adaptive']
Energy Efficiency,"y or range cuts) for the same material.; 18.2.2 Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; One can make materials or mixtures from radionuclides:; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; The following properties of radionuclides can be currently accessed via getters in the TGeoElementRN class:; Atomic number and charge (from the base class TGeoElement). Isomeric number (ISO); ENDF code - following the convention: ENDF=10000*Z+100*A+ISO; Isomeric energy level [MeV]; Mass excess [MeV]; Half life [s]; Spin/Parity - can be retrieved with: TGeoElementRN::GetTitle(); Hynalation and ingestion toxicities; List of decays - TGeoElementRN::GetDecays(). The radioactive decays of a radionuclide are represented by the class TGeoDecayChannel and they are stored in a TObjArray. Decay provides:. Decay mode; Variation of isomeric number; Q value for the decay [GeV]; Parent element; Daughter element. Radionuclides are linked one to each other via their decays, until the last element in the decay chain which must be stable. One can iterate decay chains using the iterator TGeoElemIter:; root[] TGeoElemIter next(c14);; root[] TGeoElementRN *elem;; root[] while ((elem=next())) next.Print();; 6-C-014 (100% BetaMinus) T1/2=1.81e+11; 7-N-014 stable; To create a radioactive m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:892258,charge,charge,892258,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['charge'],['charge']
Energy Efficiency,"y supported for backward compatibility; it requires the file name ot contain the string '.root' and its use is deprecated.; A. If nentries <= 0, the file is opened and the tree header read into memory to get the number of entries.; B. If nentries > 0, the file is not opened, and nentries is assumed to be the number of entries in the file. In this case, no check is made that the file exists nor that the tree exists in the file, nor that the real TTree entries match with the input argument. This second mode is interesting in case the number of entries in the file is already stored in a run database for example. WarningIf you pass nentries > tree_entries, this may lead to silent data corruption in your analysis or undefined behavior in your program. Use the other options if unsure.; C. If nentries == TTree::kMaxEntries (default), the file is not opened. The number of entries in each file will be read only when the file is opened to read an entry. This option is the default and very efficient if one processes the chain sequentially. Note that in case GetEntry(entry) is called and entry refers to an entry in the third file, for example, this forces the tree headers in the first and second file to be read to find the number of entries in those files. Note that if one calls GetEntriesFast() after having created a chain with this default, GetEntriesFast() will return TTree::kMaxEntries! Using the GetEntries() function instead will force all of the tree headers in the chain to be read to read the number of entries in each tree.; D. The TChain data structure Each TChainElement has a name equal to the tree name of this TChain and a title equal to the file name. So, to loop over the TFiles that have been added to this chain: TObjArray *fileElements=chain->GetListOfFiles();; TIter next(fileElements);; TChainElement *chEl=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }; The function returns 1 if the file is successfully con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:62768,efficient,efficient,62768,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['efficient'],['efficient']
Energy Efficiency,"y to point x,y.; If NN=0 the x,y are written in the SVG file; according to the current transformation.; If NN>0 the line is clipped as a line.; If NN<0 the line is clipped as a fill area. void DrawPolyMarker(Int_t n, Float_t* x, Float_t* y); Paint PolyMarker. void DrawPolyMarker(Int_t n, Double_t* x, Double_t* y); Paint PolyMarker. void DrawPS(Int_t n, Double_t* xw, Double_t* yw); This function defines a path with xw and yw and draw it according the; value of nn:. If nn>0 a line is drawn.; If nn<0 a closed polygon is drawn. void Initialize(); Initialize the SVG file. The main task of the function is to output the; SVG header file which consist in <title>, <desc> and <defs>. The; HeaderPS provided by the user program is written in the <defs> part. void MovePS(Double_t x, Double_t y); Move to a new position (ix, iy). The move is done in relative coordinates; which allows to have short numbers which decrease the size of the file.; This function use the full power of the SVG's paths by using the; horizontal and vertical move whenever it is possible. void NewPage(); Start the SVG page. This function initialize the pad conversion; coefficients and output the <svg> directive which is close later in the; the function Close. void Range(Float_t xrange, Float_t yrange); Set the range for the paper in centimetres. void SetFillColor(Color_t cindex = 1); Set color index for fill areas. void SetLineColor(Color_t cindex = 1); Set color index for lines. void SetLineStyle(Style_t linestyle = 1); Change the line style. linestyle = 2 dashed; = 3 dotted; = 4 dash-dotted; = else solid (1 in is used most of the time). void SetLineWidth(Width_t linewidth = 1); Set the lines width. void SetMarkerColor(Color_t cindex = 1); Set color index for markers. void SetColor(Int_t color = 1); Set color with its color index. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. void SetTextColor(Color_t c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSVG.html:15102,power,power,15102,root/html534/TSVG.html,https://root.cern,https://root.cern/root/html534/TSVG.html,6,['power'],['power']
Energy Efficiency,y() const { return fCoordinates.Py(); }; 644 Scalar z() const { return fCoordinates.Pz(); }; 645 Scalar t() const { return fCoordinates.E(); }; 646 Scalar px() const { return fCoordinates.Px(); }; 647 Scalar py() const { return fCoordinates.Py(); }; 648 Scalar pz() const { return fCoordinates.Pz(); }; 649 Scalar e() const { return fCoordinates.E(); }; 650 Scalar r() const { return fCoordinates.R(); }; 651 Scalar theta() const { return fCoordinates.Theta(); }; 652 Scalar phi() const { return fCoordinates.Phi(); }; 653 Scalar rho() const { return fCoordinates.Rho(); }; 654 Scalar eta() const { return fCoordinates.Eta(); }; 655 Scalar pt() const { return fCoordinates.Pt(); }; 656 Scalar perp2() const { return fCoordinates.Perp2(); }; 657 Scalar mag2() const { return fCoordinates.M2(); }; 658 Scalar mag() const { return fCoordinates.M(); }; 659 Scalar mt() const { return fCoordinates.Mt(); }; 660 Scalar mt2() const { return fCoordinates.Mt2(); }; 661 ; 662 ; 663 // Methods requested by CMS ---; 664 Scalar energy() const { return fCoordinates.E(); }; 665 Scalar mass() const { return fCoordinates.M(); }; 666 Scalar mass2() const { return fCoordinates.M2(); }; 667 ; 668 ; 669 /**; 670 Methods setting a Single-component; 671 Work only if the component is one of which the vector is represented.; 672 For example SetE will work for a PxPyPzE Vector but not for a PxPyPzM Vector.; 673 */; 674 LorentzVector<CoordSystem>& SetE ( Scalar a ) { fCoordinates.SetE (a); return *this; }; 675 LorentzVector<CoordSystem>& SetEta( Scalar a ) { fCoordinates.SetEta(a); return *this; }; 676 LorentzVector<CoordSystem>& SetM ( Scalar a ) { fCoordinates.SetM (a); return *this; }; 677 LorentzVector<CoordSystem>& SetPhi( Scalar a ) { fCoordinates.SetPhi(a); return *this; }; 678 LorentzVector<CoordSystem>& SetPt ( Scalar a ) { fCoordinates.SetPt (a); return *this; }; 679 LorentzVector<CoordSystem>& SetPx ( Scalar a ) { fCoordinates.SetPx (a); return *this; }; 680 LorentzVector<CoordSystem>& SetPy ( Sc,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:21543,energy,energy,21543,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['energy'],['energy']
Energy Efficiency,"y(Int_t nElements, void* arena) const; Execute the container constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Execute the container destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE); Execute the container array destructor. UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objectstart); Set the address of the container being proxied and keep track of the previous one. void PopProxy(); Reset the address of the container being proxied to the previous container. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass(); Return a pointer to the TClass representing the content. EDataType GetType(); If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); Copy the iterator source, into dest. dest should contain the loc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualCollectionProxy.html:4647,Allocate,Allocate,4647,root/html532/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TVirtualCollectionProxy.html,1,['Allocate'],['Allocate']
Energy Efficiency,"y,z) but only event for which (y+z<0) is ROOT.True; # Import observables (x,y,z) but only event for which (y+z<0) is ROOT.True; ds2 = ROOT.RooDataSet(""ds2"", ""ds2"", {x, y, z}, Import=tree, Cut=""y+z<0""); ds2.Print(); ; # Importing integer ROOT TTree branches; # ---------------------------------------------------------------; ; # Import integer tree branch as ROOT.RooRealVar; i = ROOT.RooRealVar(""i"", ""i"", 0, 5); ds3 = ROOT.RooDataSet(""ds3"", ""ds3"", {i, x}, Import=tree); ds3.Print(); ; # Define category i; icat = ROOT.RooCategory(""i"", ""i"", {""State0"": 0, ""State1"": 1}); ; # Import integer tree branch as ROOT.RooCategory (only events with i==0 and i==1; # will be imported as those are the only defined states); ds4 = ROOT.RooDataSet(""ds4"", ""ds4"", {icat, x}, Import=tree); ds4.Print(); ; # Import multiple RooDataSets into a RooDataSet; # ----------------------------------------------------------------------------------------; ; # Create three ROOT.RooDataSets in (y,z); dsA = ds2.reduce({x, y}, ""z<-5""); dsB = ds2.reduce({x, y}, ""abs(z)<5""); dsC = ds2.reduce({x, y}, ""z>5""); ; # Create a dataset that imports contents of all the above datasets mapped; # by index category c; dsABC = ROOT.RooDataSet(""dsABC"", ""dsABC"", {x, y}, Index=c, Import={""SampleA"": dsA, ""SampleB"": dsB, ""SampleC"": dsC}); ; dsABC.Print(); RooDataHist::dh[c,x] = 300 bins (2964 weights); RooDataHist::dh[c,x] = 300 bins (2964 weights); [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:Dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8py.html:3455,reduce,reduce,3455,doc/master/rf401__importttreethx_8py.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8py.html,1,['reduce'],['reduce']
Energy Efficiency,"y. In this case, the normal Bar::Streamer function; will be called. The Bar::Streamer function works OK independently; if the Bar StreamerInfo had been generated in optimized mode or not. void Compress(); Remove empty slots from array. void Clear(Option_t* option = """"); Clear the clones array. Only use this routine when your objects don't; allocate memory since it will not call the object dtors.; However, if the class in the TClonesArray implements the function; Clear(Option_t *option) and if option = ""C"" the function Clear(); is called for all objects in the array. In the function Clear(), one; can delete objects or dynamic arrays allocated in the class.; This procedure is much faster than calling TClonesArray::Delete().; When the option starts with ""C+"", eg ""C+xyz"" the objects in the array; are in turn cleared with the option ""xyz"". void Delete(Option_t* option = """"); Clear the clones array. Use this routine when your objects allocate; memory (e.g. objects inheriting from TNamed or containing TStrings; allocate memory). If not you better use Clear() since if is faster. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. void ExpandCreate(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked and the allocated space is freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). void ExpandCreateFast(Int_t n); Expand or shrink the array to n elements and create the clone; objects by calling their default ctor. If n is less than the current size; the array is shrinked but the allocated space is _not_ freed.; This routine is typically used to create a clonesarray into which; one can directly copy object data without going via the; ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly).; Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:17734,allocate,allocate,17734,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,2,['allocate'],['allocate']
Energy Efficiency,"y.cxx. ◆ DeclFileName(). static const char * TClonesArray::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 83 of file TClonesArray.h. ◆ Delete(). void TClonesArray::Delete ; (; Option_t * ; option = """"). overridevirtual . Clear the clones array. ; Use this routine when your objects allocate memory (e.g. objects inheriting from TNamed or containing TStrings allocate memory). If not you better use Clear() since if is faster. ; Implements TCollection.; Definition at line 452 of file TClonesArray.cxx. ◆ Expand(). void TClonesArray::Expand ; (; Int_t ; newSize). overridevirtual . Expand or shrink the array to newSize elements. ; Reimplemented from TObjArray.; Definition at line 480 of file TClonesArray.cxx. ◆ ExpandCreate(). void TClonesArray::ExpandCreate ; (; Int_t ; n). virtual . Expand or shrink the array to n elements and create the clone objects by calling their default ctor. ; If n is less than the current size the array is shrunk and the allocated space is freed. This routine is typically used to create a clonesarray into which one can directly copy object data without going via the ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). ; Definition at line 514 of file TClonesArray.cxx. ◆ ExpandCreateFast(). void TClonesArray::ExpandCreateFast ; (; Int_t ; n). virtual . Expand or shrink the array to n elements and create the clone objects by calling their default ctor. ; If n is less than the current size the array is shrunk but the allocated space is not freed. This routine is typically used to create a clonesarray into which one can directly copy object data without going via the ""new (arr[i]) MyObj()"" (i.e. the vtbl is already set correctly). This is a simplified version of ExpandCreate used in the TTree mechanism. ; Definition at line 558 of file TClonesArray.cxx. ◆ GetClass(). TClass * TClonesArray::GetClass ; (; ); const. inline . Definition at line 53 of file TClonesArray.h. ◆ IsA()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:36606,allocate,allocated,36606,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['allocate'],['allocated']
Energy Efficiency,"y; 935<div class=""pyrootbox"">; 936\endhtmlonly; 937## PyROOT; 938The RooAbsData::createHistogram() function is pythonized with the command argument pythonization.; 939The keywords must correspond to the CmdArgs of the function.; 940\htmlonly; 941</div>; 942\endhtmlonly; 943 ; 944\fn RooAbsData::plotOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 945\brief \parblock \endparblock; 946\htmlonly; 947<div class=""pyrootbox"">; 948\endhtmlonly; 949## PyROOT; 950The RooAbsData::plotOn() function is pythonized with the command argument pythonization.; 951The keywords must correspond to the CmdArgs of the function.; 952\htmlonly; 953</div>; 954\endhtmlonly; 955 ; 956\fn RooAbsData::reduce(const RooCmdArg& arg1,const RooCmdArg& arg2, const RooCmdArg& arg3,const RooCmdArg& arg4, const RooCmdArg& arg5,const RooCmdArg& arg6, const RooCmdArg& arg7,const RooCmdArg& arg8); 957\brief \parblock \endparblock; 958\htmlonly; 959<div class=""pyrootbox"">; 960\endhtmlonly; 961## PyROOT; 962The RooAbsData::reduce() function is pythonized with the command argument pythonization.; 963The keywords must correspond to the CmdArgs of the function.; 964\htmlonly; 965</div>; 966\endhtmlonly; 967 ; 968\fn RooAbsData::statOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 969\brief \parblock \endparblock; 970\htmlonly; 971<div class=""pyrootbox"">; 972\endhtmlonly; 973## PyROOT; 974The RooAbsData::statOn() function is pythonized with the command argument pythonization.; 975The keywords must correspond to the CmdArgs of the function.; 976\htmlonly; 977</div>; 978\endhtmlonly; 979 ; 980\class RooAbsPdf; 981\brief \parblock \endparblock; 982\htmlonly; 983<div class=""pyrootbox"">; 984\endhtmlonly; 985#",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/__roofit_8pyzdoc_source.html:47048,reduce,reduce,47048,doc/master/__roofit_8pyzdoc_source.html,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html,2,['reduce'],['reduce']
Energy Efficiency,"y_t. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass(); virtual Int_tGetCollectionType(); virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement(); virtual Int_tGetProperties(); virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType(); virtual TClass*GetValueClass(); virtual TStreamerInfoActions::TActionSequence*GetWriteMemberWiseActions(); virtual Bool_tHasPointers() const; virtual void*New() const; virtual void*New(void* arena) const; virtual void*NewArray(Int_t nElements) const; virtual void*NewArray(Int_t nElements, void* arena) const; char*operator[](UInt_t idx) const; virtual voidPopProxy(); virtual voidPushProxy(void* objectstart); virtual UInt_tSize() const; virtual UInt_tSizeof() const. protected:. virtual voidSetValueClass(TClass* newcl). private:. TVirtualCollectionProxy&operator=(const TVirtualCollectionProxy&). Data Members; public:. enum EProperty { ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualCollectionProxy.html:783,Allocate,Allocate,783,root/html532/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TVirtualCollectionProxy.html,1,['Allocate'],['Allocate']
Energy Efficiency,"y_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooParamHistFunc(const char* name, const char* title, RooDataHist& dh, Bool_t paramRelative = kTRUE); Populate x with observables. RooParamHistFunc(const char* name, const char* title, const RooAbsArg& x, RooDataHist& dh, Bool_t paramRelative = kTRUE); Populate x with observables. RooParamHistFunc(const char* name, const char* title, RooDataHist& dh, const RooParamHistFunc& paramSource, Bool_t paramRelative = kTRUE). RooParamHistFunc(const RooParamHistFunc& other, const char* name = 0). Double_t evaluate() const. Double_t getActual(Int_t ibin). void setActual(Int_t ibin, Double_t newVal). Double_t getNominal(Int_t ibin) const. Double_t getNominalError(Int_t ibin) const. list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Return sampling hint for making curves of (projections) of this function; as the recursive division strategy of RooCurve cannot deal efficiently; with the vertical lines that occur in a non-interpolated histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implement analytical integrations by doing appropriate weighting from component integrals; functions to integrators of components. RooParamHistFunc(); {}. TObject* clone(const char* newname) const; { return new RooParamHistFunc(*this,newname); }. virtual ~RooP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooParamHistFunc.html:36873,efficient,efficiently,36873,root/html534/RooParamHistFunc.html,https://root.cern,https://root.cern/root/html534/RooParamHistFunc.html,6,['efficient'],['efficiently']
Energy Efficiency,"yet saved. ; Reimplemented from TObject.; Definition at line 428 of file TKey.cxx. ◆ Build(). void TKey::Build ; (; TDirectory * ; motherDir, . const char * ; classname, . Long64_t ; filepos . ). protected . Method used in all TKey constructor to initialize basic data fields. ; The member filepos is used to calculate correct version number of key if filepos==-1, end of file position is used. ; Definition at line 390 of file TKey.cxx. ◆ Class(). static TClass * TKey::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TKey::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TKey::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 116 of file TKey.h. ◆ Create(). void TKey::Create ; (; Int_t ; nbytes, . TFile * ; externFile = nullptr . ). protectedvirtual . Create a TKey object of specified size. ; If externFile!=0, key will be allocated in specified file, otherwise file of mother directory will be used. ; Definition at line 460 of file TKey.cxx. ◆ DeclFileName(). static const char * TKey::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 116 of file TKey.h. ◆ Delete(). void TKey::Delete ; (; Option_t * ; option = """"). overridevirtual . Delete an object from the file. ; Note: the key is not deleted. You still have to call ""delete key"". This is different from the behaviour of TObject::Delete()! ; Reimplemented from TObject.; Reimplemented in TKeySQL, and TKeyXML.; Definition at line 539 of file TKey.cxx. ◆ DeleteBuffer(). void TKey::DeleteBuffer ; (; ). virtual . Delete key buffer(s). ; Reimplemented in TKeySQL, and TKeyXML.; Definition at line 560 of file TKey.cxx. ◆ FillBuffer(). void TKey::FillBuffer ; (; char *& ; buffer). overridevirtual . Encode key header into output buffer. ; Reimplemented from TNamed.; Reimplemented in TKeySQL, and TKeyXML.; Definition at line",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKey.html:21348,allocate,allocated,21348,doc/master/classTKey.html,https://root.cern,https://root.cern/doc/master/classTKey.html,1,['allocate'],['allocated']
Energy Efficiency,"ying a specific operation to two prototypes. ;  ;  TMatrixTSparse (const TMatrixTSparse< Element > &another);  ;  TMatrixTSparse (EMatrixCreatorsOp1 op, const TMatrixTSparse< Element > &prototype);  Create a matrix applying a specific operation to the prototype. ;  ;  TMatrixTSparse (Int_t nrows, Int_t ncols);  Space is allocated for row/column indices and data, but the sparse structure information has still to be set ! ;  ;  TMatrixTSparse (Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t *rowptr, Int_t *col, Element *data);  Space is allocated for row/column indices and data. ;  ;  TMatrixTSparse (Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t *row, Int_t *col, Element *data);  Space is allocated for row/column indices and data. ;  ;  TMatrixTSparse (Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros=0);  Space is allocated for row/column indices and data, but the sparse structure information has still to be set ! ;  ;  ~TMatrixTSparse () override;  ; TClass * Class ();  ; void Clear (Option_t *="""") override;  ; Element ColNorm () const override;  Column matrix norm, MAX{ SUM{ |M(i,j)|, over i}, over j}. ;  ; void ExtractRow (Int_t row, Int_t col, Element *v, Int_t n=-1) const override;  Store in array v, n matrix elements of row rown starting at column coln. ;  ; const Int_t * GetColIndexArray () const override;  ; Int_t * GetColIndexArray () override;  ; void GetMatrix2Array (Element *data, Option_t *="""") const override;  Copy matrix data to array . It is assumed that array is of size >= fNelems. ;  ; const Element * GetMatrixArray () const override;  ; Element * GetMatrixArray () override;  ; const Int_t * GetRowIndexArray () const override;  ; Int_t * GetRowIndexArray () override;  ; TMatrixTSparse< Element > GetSub (Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Option_t *option=""S"") const;  ; TMatrixTBase< Element > & GetSub (Int_t row_lwb, Int_t row_upb, Int_t col",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSparse.html:6842,allocate,allocated,6842,doc/master/classTMatrixTSparse.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSparse.html,1,['allocate'],['allocated']
Energy Efficiency,"yleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; RooArgSetRooAbsDataStore::_cachedVars; Int_t_curIndex! Index associated with current event; RooAbsDataStore*_curStore! Datastore associated with current event; map<Int_t,RooAbsDataStore*>_dataMap; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; RooCategory*_indexCat; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; Bool_t_ownComps!; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCompositeDataStore(). RooCompositeDataStore(const char* name, const char* title, const RooArgSet& vars, RooCategory& indexCat, map<string,RooAbsDataStore*> inputData); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const char* newname = 0); Convert map by label to map by index for more efficient internal use. RooCompositeDataStore(const RooCompositeDataStore& other, const RooArgSet& vars, const char* newname = 0); Update index category pointer, if it is contained in input argument vars. ~RooCompositeDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); Forward recalculate request to all subsets. Bool_t hasFilledCache() const. void forceCacheUpdate(). Int_t fill(); Forward fill request to appropriate subset. Double_t sumEntries() const; Forward fill request to appropriate subset. const RooArgSet* get(Int_t index) const; Load the n-th data point (n=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCompositeDataStore.html:11139,efficient,efficient,11139,root/html602/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html602/RooCompositeDataStore.html,4,['efficient'],['efficient']
Energy Efficiency,"ymmetric errors. void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE); Set zero values for point arrays in the range [begin, end). Double_t GetErrorX(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along X at point i. Double_t GetErrorY(Int_t bin) const; This function is called by GraphFitChisquare.; It returns the error along Y at point i. Double_t GetErrorXhigh(Int_t i) const; Get high error on X. Double_t GetErrorXlow(Int_t i) const; Get low error on X. Double_t GetErrorYhigh(Int_t i) const; Get high error on Y. Double_t GetErrorYlow(Int_t i) const; Get low error on Y. void Print(Option_t* chopt = """") const; Print graph and errors values. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); Set ex and ey values for point pointed by the mouse. void SetPointError(Int_t i, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); Set ex and ey values for point number i. void SetPointEXlow(Int_t i, Double_t exl); Set EXlow for point i. void SetPointEXhigh(Int_t i, Double_t exh); Set EXhigh for point i. void SetPointEYlow(Int_t i, Double_t eyl); Set EYlow for point i. void SetPointEYhigh(Int_t i, Double_t eyh); Set EYhigh for point i. void Streamer(TBuffer& ); Stream an object of class TGraphAsymmErrors. void SwapPoints(Int_t pos1, Int_t pos2); Swap points. Double_t** Allocate(Int_t size). Double_t * GetEXlow() const; {return fEXlow;}. Double_t * GetEXhigh() const; {return fEXhigh;}. Double_t * GetEYlow() const; {return fEYlow;}. Double_t * GetEYhigh() const; {return fEYhigh;}. » Author: Rene Brun 03/03/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphAsymmErrors.html:23793,Allocate,Allocate,23793,root/html534/TGraphAsymmErrors.html,https://root.cern,https://root.cern/root/html534/TGraphAsymmErrors.html,1,['Allocate'],['Allocate']
Energy Efficiency,"ymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfBestBest Edge for division; TReffDaught0Pointer to daughter 1; TReffDaught1Pointer to daughter 2; Short_tfDimDimension of the vector space; Double_tfDriveDriver integral, only for cell build-up; TObject*fElementmay set by the user to save some data in this cell; Double_tfIntegralIntegral over cell (estimate from exploration); TReffParentPointer to parent cell; Int_tfSerialSerial number; Int_tfStatusStatus (active, inactive); Double_tfVolumeCartesian Volume of cell; Double_tfXdivFactor for division. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamCell(); Default constructor for streamer. PDEFoamCell(Int_t ); User constructor allocating single empty Cell. PDEFoamCell(const TMVA::PDEFoamCell& ); Copy constructor. ~PDEFoamCell(); Destructor. void Fill(Int_t , TMVA::PDEFoamCell* , TMVA::PDEFoamCell* , TMVA::PDEFoamCell* ); Fills in certain data into newly allocated cell. void GetHcub(TMVA::PDEFoamVect& , TMVA::PDEFoamVect& ) const; Provides size and position of the cell; These parameter are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void GetHSize(TMVA::PDEFoamVect& ) const; Provides size of the cell; Size parameters are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void CalcVolume(void); Calculates volume of the cell using size params which are calculated. UInt_t GetDepth(); Get depth of cell in binary tree, where the root cell has depth; 1. UInt_t GetTreeDepth(UInt_t depth = 0); Get depth of cell tree, starting at this cell. void Print(Option_t* option) const; Printout of the cell geometry parameters for the debug purpose. Double_t GetXdiv() const; Geometry. { return fXdiv;}. Int_t GetBest() const; { return fBest;}. void SetBest(Int_t Best); { fBest =Best;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoamCell.html:7417,allocate,allocated,7417,root/html602/TMVA__PDEFoamCell.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoamCell.html,4,['allocate'],['allocated']
Energy Efficiency,"ype values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IntegratorOneDim.html:6026,ADAPT,ADAPTIVE,6026,root/html532/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IntegratorOneDim.html,4,['ADAPT'],['ADAPTIVE']
Energy Efficiency,"ype;; 141 // Since the user can not control the tolerance of this newly created matrix; 142 // we put it to the smallest possible number; 143 const Element oldTol = this->SetTol(std::numeric_limits<Element>::min());; 144 this->Invert();; 145 this->SetTol(oldTol);; 146 break;; 147 }; 148 ; 149 case kAtA:; 150 Allocate(prototype.GetNcols(), prototype.GetNcols(), prototype.GetColLwb(), prototype.GetColLwb(), 1);; 151 TMult(prototype, prototype);; 152 break;; 153 ; 154 default: Error(""TMatrixT(EMatrixCreatorOp1)"", ""operation %d not yet implemented"", op);; 155 }; 156}; 157 ; 158////////////////////////////////////////////////////////////////////////////////; 159/// Constructor of matrix applying a specific operation to two prototypes.; 160/// Example: TMatrixT<Element> a(10,12), b(12,5); ...; TMatrixT<Element> c(a, TMatrixT::kMult, b);; 161/// Supported operations are: kMult (a*b), kTransposeMult (a'*b), kInvMult (a^(-1)*b);; 162/// Whenever kInvMult is invoked and b is not squared, additional memory is allocated for a^(-1); 163 ; 164template <class Element>; 165TMatrixT<Element>::TMatrixT(const TMatrixT<Element> &a, EMatrixCreatorsOp2 op, const TMatrixT<Element> &b); 166{; 167 R__ASSERT(a.IsValid());; 168 R__ASSERT(b.IsValid());; 169 ; 170 switch (op) {; 171 case kMult:; 172 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 173 Mult(a, b);; 174 break;; 175 ; 176 case kTransposeMult:; 177 Allocate(a.GetNcols(), b.GetNcols(), a.GetColLwb(), b.GetColLwb(), 1);; 178 TMult(a, b);; 179 break;; 180 ; 181 case kMultTranspose:; 182 Allocate(a.GetNrows(), b.GetNrows(), a.GetRowLwb(), b.GetRowLwb(), 1);; 183 MultT(a, b);; 184 break;; 185 ; 186 case kInvMult: {; 187 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 188 // if size(a) == size(b), perform in place computation; 189 if (a.GetNrows() == b.GetNcols()) {; 190 *this = a;; 191 const Element oldTol = this->SetTol(std::numeric_limits<Element>::min());; 192 this->Invert();; 193 this->S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMatrixT_8cxx_source.html:6256,allocate,allocated,6256,doc/master/TMatrixT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html,1,['allocate'],['allocated']
Energy Efficiency,"ypesAreCountedtrue if variable types have been counted already; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~VariableTransformBase(). void SelectInput(const TString& inputVariables, Bool_t putIntoVariables = kFALSE); select the variables/targets/spectators which serve as input to the transformation. Bool_t GetInput(const TMVA::Event* event, vector<Float_t>& input, vector<Char_t>& mask, Bool_t backTransform = kFALSE) const; select the values from the event. void SetOutput(TMVA::Event* event, vector<Float_t>& output, vector<Char_t>& mask, const TMVA::Event* oldEvent = 0, Bool_t backTransform = kFALSE) const; select the values from the event. void CountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; count variables, targets and spectators. void CalcNorm(const vector<const TMVA::Event*,allocator<const TMVA::Event*> >& ); TODO --> adapt to variable,target,spectator selection; method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ). const Event* Transform(const TMVA::Event *const , Int_t cls) const. const Event*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__VariableTransformBase.html:9712,adapt,adapt,9712,root/html534/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html534/TMVA__VariableTransformBase.html,2,['adapt'],['adapt']
Energy Efficiency,"ys, and therefore ORDER+1 pointers to sub-trees. The keys are numbered and indexed 1 to ORDER while the pointers are numbered and indexed 0 to ORDER. The 0th ptr points to the sub-tree of all elements that are less than key[1]. Ptr[1] points to the sub-tree that contains all the elements greater than key[1] and less than key[2]. etc. The array of pointers and keys is allocated as ORDER+1 pairs of keys and nodes, meaning that one key field (key[0]) is not used and therefore wasted. Given that the number of interior nodes is small, that this waste allows fewer cases of special code, and that it is useful in certain of the methods, it was felt to be a worthwhile waste.; The size of the exterior nodes (leaf nodes) does not need to be related to the size of the interior nodes at all. Since leaf nodes contain only keys, they may be as large or small as we like independent of the size of the interior nodes. For no particular reason other than it seems like a good idea, we will allocate 2*(ORDER+1) keys in each leaf node, and they will be numbered and indexed from 0 to 2*ORDER+1. It does have the advantage of keeping the size of the leaf and interior arrays the same, so that if we find allocation and de-allocation of these arrays expensive, we can modify their allocation to use a garbage ring, or something.; Both of these numbers will be run-time constants associated with each tree (each tree at run-time can be of a different order). The variable ""order"" is the order of the tree, and the inclusive upper limit on the indices of the keys in the interior nodes. The variable ""order2"" is the inclusive upper limit on the indices of the leaf nodes, and is designed (1) to keep the sizes of the two kinds of nodes the same;; (2) to keep the expressions involving the arrays of keys looking; somewhat the same: lower limit upper limit; for inner nodes: 1 order; for leaf nodes: 0 order2; Remember that index 0 of the inner nodes is special.; indexOption_t Option_t TPoint TPoint const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBtree.html:4531,allocate,allocate,4531,doc/master/classTBtree.html,https://root.cern,https://root.cern/doc/master/classTBtree.html,1,['allocate'],['allocate']
Energy Efficiency,"ystemDirectory.h. ◆ Copy() [1/2]. void TSystemDirectory::Copy ; (; const char * ; to). inlineoverridevirtual . copy this file ; Reimplemented from TSystemFile.; Definition at line 59 of file TSystemDirectory.h. ◆ Copy() [2/2]. void TSystemDirectory::Copy ; (; TObject & ; named); const. inlineoverridevirtual . Copy this to obj. ; Reimplemented from TNamed.; Definition at line 69 of file TSystemDirectory.h. ◆ DeclFileName(). static const char * TSystemDirectory::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 71 of file TSystemDirectory.h. ◆ Delete() [1/2]. void TSystemDirectory::Delete ; (; ). inlineoverridevirtual . delete this file ; Reimplemented from TSystemFile.; Definition at line 58 of file TSystemDirectory.h. ◆ Delete() [2/2]. void TSystemDirectory::Delete ; (; Option_t * ; option). inlineoverridevirtual . Delete this object. ; Typically called as a command via the interpreter. Normally use ""delete"" operator when object has been allocated on the heap. ; Reimplemented from TObject.; Definition at line 68 of file TSystemDirectory.h. ◆ DrawClass(). void TSystemDirectory::DrawClass ; (; ); const. inlineoverridevirtual . Draw class inheritance tree of the class to which this object belongs. ; If a class B inherits from a class A, description of B is drawn on the right side of description of A. Member functions overridden by B are shown in class A with a blue line crossing-out the corresponding member function. The following picture is the class inheritance tree of class TPaveLabel:. Reimplemented from TObject.; Definition at line 63 of file TSystemDirectory.h. ◆ DrawClone(). TObject * TSystemDirectory::DrawClone ; (; Option_t * ; option); const. inlineoverridevirtual . Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ; If pad was not selected - gPad will be used. ; Reimplemented from TObject.; Definition at line 64 of file TSystemDirectory.h. ◆ Edit(). void TSy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystemDirectory.html:16339,allocate,allocated,16339,doc/master/classTSystemDirectory.html,https://root.cern,https://root.cern/doc/master/classTSystemDirectory.html,1,['allocate'],['allocated']
Energy Efficiency,"yze their data or to perform simulations. With ROOT you can:. Save data You can save your data (and any C++ object) in a compressed binary form in a ROOT file. The object format is also saved in the same file: the ROOT files are self-descriptive. Even in the case the source files describing the data model are not available, the information contained in a ROOT file is be always readable. ROOT provides a data structure, the tree, that is extremely powerful for fast access of huge amounts of data - orders of magnitude faster than accessing a normal file.; Access data Data saved into one or several ROOT files can be accessed from your PC, from the web and from large-scale file delivery systems used e.g. in the GRID. ROOT trees spread over several files can be chained and accessed as a unique object, allowing for loops over huge amounts of data.; Mine data Powerful mathematical and statistical tools are provided to operate on your data. The full power of a C++ application and of parallel processing is available for any kind of data manipulation. Data can also be generated following any statistical distribution and modeled, making it possible to simulate complex systems.; Publish results Results can be displayed with histograms, scatter plots, fitting functions. ROOT graphics may be adjusted real-time by few mouse clicks. Publication-quality figures can be saved in PDF or other formats.; Run interactively or build your own application You can use the Cling C++ interpreter for your interactive sessions and to write macros, or you can compile your program to run at full speed. In both cases, you can also create a graphical user interface.; Use ROOT within other languages ROOT provides a set of bindings in order to seamlessly integrate with existing languages such as Python, R and Mathematica. Save dataAccess dataProcess dataShow resultsInteractive or built applicationIntegration with other languages. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/about-root.html:2984,power,power,2984,d/about-root.html,https://root.cern,https://root.cern/d/about-root.html,1,['power'],['power']
Energy Efficiency,"z = buff->points[3*i+2];; 165 }; 166 ; 167 ; 168 /*; 169 * Read segments; 170 */; 171 ; 172 for (i = 0; i < buff->numSegs; i++, currSeg++) {; 173 c = buff->segs[3*i];; 174 p = oldNumOfPoints + buff->segs[3*i+1];; 175 q = oldNumOfPoints + buff->segs[3*i+2];; 176 ; 177 segs[currSeg].color = &(colors[c]);; 178 segs[currSeg].P = &(points[p]);; 179 segs[currSeg].Q = &(points[q]);; 180 ; 181 /*; 182 * Update points' segment lists; 183 */; 184 ; 185 if(points[p].numSegs == 0){; 186 if((points[p].segs = (segment **)calloc(1, sizeof(segment *))) == NULL){; 187 puts(""Unable to allocate memory for point segments !"");; 188 return;; 189 }; 190 }else{; 191 if((points[p].segs = (segment **)realloc(points[p].segs,; 192 (points[p].numSegs + 1) * sizeof(segment *))) == NULL){; 193 puts(""Unable to allocate memory for point segments !"");; 194 return;; 195 }; 196 }; 197 ; 198 if(points[q].numSegs == 0){; 199 if((points[q].segs = (segment **)calloc(1, sizeof(segment *))) == NULL){; 200 puts(""Unable to allocate memory for point segments !"");; 201 return;; 202 }; 203 }else{; 204 if((points[q].segs = (segment **)realloc(points[q].segs,; 205 (points[q].numSegs + 1) * sizeof(segment *))) == NULL){; 206 puts(""Unable to allocate memory for point segments !"");; 207 return;; 208 }; 209 }; 210 points[p].segs[points[p].numSegs] = &(segs[currSeg]);; 211 points[q].segs[points[q].numSegs] = &(segs[currSeg]);; 212 points[p].numSegs++;; 213 points[q].numSegs++;; 214 ; 215 }; 216 ; 217 /*; 218 * Read polygons; 219 */; 220 ; 221 n = 0;; 222 ; 223 for (i = 0; i < buff->numPolys; i++, currPoly++) {; 224 c = buff->polys[n++];; 225 polys[currPoly].color = &(colors)[c];; 226 polys[currPoly].numSegs = buff->polys[n++];; 227 ; 228 polys[currPoly].segs = (segment **) calloc(polys[currPoly].numSegs, sizeof(segment *));; 229 if (!polys[currPoly].segs) {; 230 puts(""Unable to allocate memory for polygon segments !"");; 231 return;; 232 }; 233 for (j = 0; j < polys[currPoly].numSegs; j++) {; 234 int seg = oldNumOfSegmen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/X3DBuffer_8c_source.html:6206,allocate,allocate,6206,doc/master/X3DBuffer_8c_source.html,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html,1,['allocate'],['allocate']
Energy Efficiency,"z<=zlast;binz++) {; 8692 for (biny=yfirst;biny<=ylast;biny++) {; 8693 for (binx=xfirst;binx<=xlast;binx++) {; 8694 bin = GetBin(binx,biny,binz);; 8695 value = RetrieveBinContent(bin);; 8696 if (value < minimum) {; 8697 minimum = value;; 8698 locm = bin;; 8699 locmix = binx;; 8700 locmiy = biny;; 8701 locmiz = binz;; 8702 }; 8703 }; 8704 }; 8705 }; 8706 return locm;; 8707}; 8708 ; 8709///////////////////////////////////////////////////////////////////////////////; 8710/// Retrieve the minimum and maximum values in the histogram; 8711///; 8712/// This will not return a cached value and will always search the; 8713/// histogram for the min and max values. The user can condition whether; 8714/// or not to call this with the GetMinimumStored() and GetMaximumStored(); 8715/// methods. If the cache is empty, then the value will be -1111. Users; 8716/// can then use the SetMinimum() or SetMaximum() methods to cache the results.; 8717/// For example, the following recipe will make efficient use of this method; 8718/// and the cached minimum and maximum values.; 8719//; 8720/// \code{.cpp}; 8721/// Double_t currentMin = pHist->GetMinimumStored();; 8722/// Double_t currentMax = pHist->GetMaximumStored();; 8723/// if ((currentMin == -1111) || (currentMax == -1111)) {; 8724/// pHist->GetMinimumAndMaximum(currentMin, currentMax);; 8725/// pHist->SetMinimum(currentMin);; 8726/// pHist->SetMaximum(currentMax);; 8727/// }; 8728/// \endcode; 8729///; 8730/// \param min reference to variable that will hold found minimum value; 8731/// \param max reference to variable that will hold found maximum value; 8732 ; 8733void TH1::GetMinimumAndMaximum(Double_t& min, Double_t& max) const; 8734{; 8735 // empty the buffer; 8736 if (fBuffer) ((TH1*)this)->BufferEmpty();; 8737 ; 8738 Int_t bin, binx, biny, binz;; 8739 Int_t xfirst = fXaxis.GetFirst();; 8740 Int_t xlast = fXaxis.GetLast();; 8741 Int_t yfirst = fYaxis.GetFirst();; 8742 Int_t ylast = fYaxis.GetLast();; 8743 Int_t zfirst = fZaxis.GetF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:341223,efficient,efficient,341223,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['efficient'],['efficient']
Energy Efficiency,"ze is not known, better using the default of zero or the next constructor later on.; The defult interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The defult interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id: Interpolator.h 24403 2008-06-20 08:31:10Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Interpolator.html:3159,efficient,efficient,3159,root/html526/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Interpolator.html,1,['efficient'],['efficient']
Energy Efficiency,"ze is not known, better using the default of zero or the next constructor later on.; The defult interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The defult interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id: Interpolator.h 24403 2008-06-20 08:31:10Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__Interpolator.html:3159,efficient,efficient,3159,root/html528/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__Interpolator.html,1,['efficient'],['efficient']
Energy Efficiency,"ze is not known, better using the default of zero or the next constructor later on.; The defult interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The defult interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id: Interpolator.h 24403 2008-06-20 08:31:10Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__Interpolator.html:3161,efficient,efficient,3161,root/html530/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__Interpolator.html,1,['efficient'],['efficient']
Energy Efficiency,"ze is not known, better using the default of zero or the next constructor later on.; The defult interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The defult interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const. » Last changed: root/mathmore:$Id: Interpolator.h 24403 2008-06-20 08:31:10Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__Interpolator.html:3161,efficient,efficient,3161,root/html532/ROOT__Math__Interpolator.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__Interpolator.html,2,['efficient'],['efficient']
Energy Efficiency,"ze of a small buffer that can be allocated on the stack to store iterator-specific information. ;  . Protected Attributes; TClassRef fClass;  ; UInt_t fProperties;  . Private Member Functions;  TVirtualCollectionProxy (const TVirtualCollectionProxy &)=delete;  ; TVirtualCollectionProxy & operator= (const TVirtualCollectionProxy &)=delete;  . Friends; class TClass;  . #include <TVirtualCollectionProxy.h>. Inheritance diagram for TVirtualCollectionProxy:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ CopyIterator_t. typedef void *(* TVirtualCollectionProxy::CopyIterator_t) (void *dest, const void *source). Copy the iterator source into dest. ; dest should contain the location of a memory arena of size fgIteratorArenaSize. If iterator-specific information is of that size or less, the iterators will be constructed in place in the given locations. Otherwise, iterators will be allocated via new and their address returned by modifying the value of *begin_arena and *end_arena. The actual address of the iterator is returned in any case. ; Definition at line 227 of file TVirtualCollectionProxy.h. ◆ CreateIterators_t. typedef void(* TVirtualCollectionProxy::CreateIterators_t) (void *collection, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy). *begin_arena and *end_arena should contain the location of a memory arena of size fgIteratorArenaSize. ; If iterator-specific information is of that size or less, the iterators will be constructed in place in the given locations. Otherwise, iterators will be allocated via new and their address returned by modifying the value of *begin_arena and *end_arena. As a special case, given that iterators for array-backed containers are just pointers, the required information will be directly stored in *(begin|end)_arena. ; Definition at line 215 of file TVirtualCollectionProxy.h. ◆ DeleteIterator_t. typedef void(* TVirtualCollectionProxy::DeleteI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualCollectionProxy.html:8196,allocate,allocated,8196,doc/master/classTVirtualCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTVirtualCollectionProxy.html,1,['allocate'],['allocated']
Energy Efficiency,"ze void char Point_t Rectangle_t destDefinition TGWin32VirtualXProxy.cxx:164; srcOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t srcDefinition TGWin32VirtualXProxy.cxx:164; qfloat * qDefinition THbookFile.cxx:89; ROOT::Math::DisplacementVector3DClass describing a generic displacement vector in 3 dimensions.Definition DisplacementVector3D.h:58; ROOT::Math::DisplacementVector3D::Mag2Scalar Mag2() constMagnitute squared ( r^2 in spherical coordinate)Definition DisplacementVector3D.h:323; ROOT::Math::LorentzVectorClass describing a generic LorentzVector in the 4D space-time, using the specified coordinate system ...Definition LorentzVector.h:59; ROOT::Math::LorentzVector::pzScalar pz() constDefinition LorentzVector.h:648; ROOT::Math::LorentzVector::ZScalar Z() constDefinition LorentzVector.h:290; ROOT::Math::LorentzVector::EScalar E() constreturn 4-th component (time, or energy for a 4-momentum vector)Definition LorentzVector.h:294; ROOT::Math::LorentzVector::thetaScalar theta() constDefinition LorentzVector.h:651; ROOT::Math::LorentzVector::EtScalar Et() constreturn the transverse energyDefinition LorentzVector.h:349; ROOT::Math::LorentzVector::YScalar Y() constDefinition LorentzVector.h:285; ROOT::Math::LorentzVector::SetPzLorentzVector< CoordSystem > & SetPz(Scalar a)Definition LorentzVector.h:681; ROOT::Math::LorentzVector::TScalar T() constDefinition LorentzVector.h:295; ROOT::Math::LorentzVector::GetCoordinatesvoid GetCoordinates(Scalar dest[]) constget internal data into an array of 4 Scalar numbersDefinition LorentzVector.h:211; ROOT::Math::LorentzVector::BoostToCMBetaVector BoostToCM() constThe beta vector for the boost that would bring this vector into its center of mass frame (zero moment...Definition LorentzVector.h:555; ROOT::Math::LorentzVector::operator==bool operator==(const LorentzVector &rhs) constExact equality.Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:27063,energy,energy,27063,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['energy'],['energy']
Energy Efficiency,"ze_t numNodes) constprepare the drop-out-container (select the nodes which are to be dropped out)Definition NeuralNet.cxx:572; TMVA::DNN::Net::numWeightssize_t numWeights(size_t trainingStartLayer=0) constreturns the number of weights in this netDefinition NeuralNet.cxx:540; TMVA::DNN::Settings::clearvoid clear(std::string histoName)for monitoringDefinition NeuralNet.h:824; TMVA::DNN::Settings::hasConvergedvirtual bool hasConverged(double testError)has this training converged already?Definition NeuralNet.cxx:485; TMVA::DNN::Settings::SettingsSettings(TString name, size_t _convergenceSteps=15, size_t _batchSize=10, size_t _testRepetitions=7, double _factorWeightDecay=1e-5, TMVA::DNN::EnumRegularization _regularization=TMVA::DNN::EnumRegularization::NONE, MinimizerType _eMinimizerType=MinimizerType::fSteepest, double _learningRate=1e-5, double _momentum=0.3, int _repetitions=3, bool _multithreading=true)c'torDefinition NeuralNet.cxx:232; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x)for monitoringDefinition NeuralNet.h:821; TMVA::DNN::Settings::~Settingsvirtual ~Settings()d'torDefinition NeuralNet.cxx:261; TMVA::DNN::Settings::m_convergenceCountsize_t m_convergenceCountDefinition NeuralNet.h:857; TMVA::DNN::Settings::m_minErrordouble m_minErrorDefinition NeuralNet.h:859; TMVA::DNN::Settings::convergenceStepssize_t convergenceSteps() consthow many steps until training is deemed to have convergedDefinition NeuralNet.h:766; TMVA::DNN::Settings::fMonitoringstd::shared_ptr< Monitoring > fMonitoringDefinition NeuralNet.h:865; TMVA::DNN::Settings::createvoid create(std::string histoName, int bins, double min, double max)for monitoringDefinition NeuralNet.h:819; TMVA::DNN::Settings::m_maxConvergenceCountsize_t m_maxConvergenceCountDefinition NeuralNet.h:858; TStringBasic string class.Definition TString.h:139; double; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8cxx_source.html:27542,monitor,monitoringDefinition,27542,doc/master/NeuralNet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8cxx_source.html,1,['monitor'],['monitoringDefinition']
Energy Efficiency,"zed"";; 4736 }; 4737 if (sequenceType.Length()) {; 4738 sequenceType.Prepend("" ["");; 4739 sequenceType += ""]"";; 4740 }; 4741 Printf("" i=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4742 i,element->GetName(),fCompOpt[i]->fType,fCompOpt[i]->fOffset,fCompOpt[i]->fLength,fCompOpt[i]->fMethod,; 4743 sequenceType.Data());; 4744 if (optimized && wantOrig) {; 4745 Bool_t done;; 4746 do {; 4747 element = (TStreamerElement*)fCompFull[j]->fElem;; 4748 element->GetSequenceType(sequenceType);; 4749 if (sequenceType.Length()) {; 4750 sequenceType.Prepend("" ["");; 4751 sequenceType += ""]"";; 4752 }; 4753 Printf("" j=%2d, %-15s type=%3d, offset=%3d, len=%d, method=%ld%s"",; 4754 j,element->GetName(),fCompFull[j]->fType,fCompFull[j]->fOffset,fCompFull[j]->fLength,fCompFull[j]->fMethod,; 4755 sequenceType.Data());; 4756 ++j;; 4757 done = j >= fNfulldata || ( (i+1 < fNdata) && fCompOpt[i+1]->fElem == fCompFull[j+1]->fElem );; 4758 } while (!done);; 4759 ; 4760 }; 4761 }; 4762 }; 4763}; 4764 ; 4765////////////////////////////////////////////////////////////////////////////////; 4766/// An emulated object is created at address obj, if obj is null we; 4767/// allocate memory for the object.; 4768 ; 4769void* TStreamerInfo::New(void *obj); 4770{; 4771 //???FIX ME: What about varying length array elements?; 4772 ; 4773 char* p = (char*) obj;; 4774 ; 4775 TIter next(fElements);; 4776 ; 4777 if (!p) {; 4778 // Allocate and initialize the memory block.; 4779 p = new char[fSize];; 4780 memset(p, 0, fSize);; 4781 }; 4782 ; 4783 next.Reset();; 4784 TStreamerElement* element = (TStreamerElement*) next();; 4785 ; 4786 for (; element; element = (TStreamerElement*) next()) {; 4787 ; 4788 // Skip elements which have not been allocated memory.; 4789 if (element->GetOffset() == kMissing) {; 4790 continue;; 4791 }; 4792 ; 4793 // Skip elements for which we do not have any class; 4794 // information. FIXME: Document how this could happen.; 4795 TClass* cle = element->GetClassPointer();; 4796 if (!",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:192285,allocate,allocate,192285,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['allocate'],['allocate']
Energy Efficiency,"zeof(Int_t) * fNdimensions);; 762 return 0.;; 763}; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Get square of the error of bin addressed by linidx as; 767/// \f$\sum weight^{2}\f$; 768/// If errors are not enabled (via Sumw2() or CalculateErrors()); 769/// return contents.; 770 ; 771Double_t THnSparse::GetBinError2(Long64_t linidx) const {; 772 if (!GetCalculateErrors()); 773 return GetBinContent(linidx);; 774 ; 775 if (linidx < 0) return 0.;; 776 THnSparseArrayChunk* chunk = GetChunk(linidx / fChunkSize);; 777 linidx %= fChunkSize;; 778 if (!chunk || chunk->fContent->GetSize() < linidx); 779 return 0.;; 780 ; 781 return chunk->fSumw2->GetAt(linidx);; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Return the index for fCurrentBinIndex.; 787/// If it doesn't exist then return -1, or allocate a new bin if allocate is set; 788 ; 789Long64_t THnSparse::GetBinIndexForCurrentBin(Bool_t allocate); 790{; 791 THnSparseCompactBinCoord* cc = GetCompactCoord();; 792 ULong64_t hash = cc->GetHash();; 793 if (fBinContent.GetSize() && !fBins.GetSize()); 794 FillExMap();; 795 Long64_t linidx = (Long64_t) fBins.GetValue(hash);; 796 while (linidx) {; 797 // fBins stores index + 1!; 798 THnSparseArrayChunk* chunk = GetChunk((linidx - 1)/ fChunkSize);; 799 if (chunk->Matches((linidx - 1) % fChunkSize, cc->GetBuffer())); 800 return linidx - 1; // we store idx+1, 0 is ""TExMap: not found""; 801 ; 802 Long64_t nextlinidx = fBinsContinued.GetValue(linidx);; 803 if (!nextlinidx) break;; 804 ; 805 linidx = nextlinidx;; 806 }; 807 if (!allocate) return -1;; 808 ; 809 ++fFilledBins;; 810 ; 811 // allocate bin in chunk; 812 THnSparseArrayChunk *chunk = (THnSparseArrayChunk*) fBinContent.Last();; 813 Long64_t newidx = chunk ? ((Long64_t) chunk->GetEntries()) : -1;; 814 if (!chunk || newidx == (Long64_t)fChunkSize) {; 815 chunk = AddChunk();; 816 newidx = 0;; 817 }; 818 chunk->AddBin(n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:29522,allocate,allocate,29522,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,3,['allocate'],['allocate']
Energy Efficiency,"zerInstantiates the SeedGenerator and MinimumBuilder for Variable Metric Minimization method ;  Cvec;  CVectorOuterProduct;  ►NQuartz;  CCGAAStateGuard;  CCGStateGuard;  CTextLine;  ►NRNamespace associated R package for ROOT ;  Cclass_;  ►CTRDataFrameThis is a class to create DataFrames from ROOT to R ;  CBinding;  CTRFunctionExportThis is a class to pass functions from ROOT to R ;  CTRFunctionImportThis is a class to pass functions from ROOT to R ;  ►CTRInterface ;  CBinding;  CTRObjectThis is a class to get ROOT's objects from R's objects ;  ►NTF1Helper;  CTGradientParFunctionFunction class representing the derivative with respect a parameter of a given TF1 ;  ►Nv5;  CTF1Data;  CTFormulaThe FORMULA class (ROOT version 5) ;  CTFormulaPrimitiveThe Formula Primitive class ;  CTOperOffset;  CTExecutorThis class defines an interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTGenericClassInfo;  CTPoolManagerA manager for the scheduler behind ROOT multithreading operations ;  CTProcessExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTRWSpinLock;  ►CTSchemaRule;  CTSources;  ►CTSeqA pseudo container class which is a generator of indices ;  Citerator;  CTSpinMutexA spin mutex class which respects the STL interface for mutexes ;  CTThreadedObjectA wrapper to make object instances thread private, lazily ;  CTThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTTreeProcessorMPThis class provides an interface to process a TTree dataset in parallel with multi-process technology ;  CTTreeProcessorMTA class to process the entries of a TTree in parallel ;  ►NROOTwriter;  CROOTwriter;  ►NstdSTL namespace ;  ►N__ROOT;  ►Ntest;  Ctest;  ►NTMath;  CLimits;  ►NTMVAAbstract ClassifierFactory template that handles arbitrary types",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:67045,schedul,scheduler,67045,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['schedul'],['scheduler']
Energy Efficiency,"zip; pos is where in the file the compressed buffer came from; complen is the length of the compressed buffer; objlen is the length of the de-compressed buffer. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long64_t GetBytesRead() const; Get number of bytes read. void WriteQueryLog(); Connect to SQL server and register query log used for quotas.; The <proofquerylog> table has the format:; CREATE TABLE <proofquerylog> (; id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,; user VARCHAR(32) NOT NULL,; proofgroup VARCHAR(32),; begin DATETIME,; end DATETIME,; walltime INT,; cputime FLOAT,; bytesread BIGINT,; events BIGINT,; workers INT; querytag VARCHAR(64) NOT NULL,; vmemmxw BIGINT, (*); rmemmxw BIGINT, (*); vmemmxm BIGINT, (*); rmemmxm BIGINT, (*); dataset VARCHAR(512), (*, **); numfiles INT (*); status INT (*); ); (*) Only for fMonitorInfo > 0; (**) Size controlled by variable Proof.Monitor.DataSetLen .; The name of the table is set while initializing the monitor writer object.; The same info is send to Monalisa (or other monitoring systems) in the; form of a list of name,value pairs. void Setup(TList* input); Setup the PROOF input list with requested statistics and tracing options. void Start(TList* input, TList* output); Initialize PROOF statistics run. void Stop(); Terminate the PROOF statistics run. void SetMemValues(); Record memory usage. virtual ~TPerfStats(); {}. void SetNumEvents(Long64_t num); { fNumEvents = num; }. Long64_t GetNumEvents() const; { return fNumEvents; }. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TPerfStats.h 38709 2011-04-01 16:27:30Z ganis $ » Last generated: 2011-07-04 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPerfStats.html:10069,monitor,monitor,10069,root/html530/TPerfStats.html,https://root.cern,https://root.cern/root/html530/TPerfStats.html,2,['monitor'],"['monitor', 'monitoring']"
Energy Efficiency,"zoomed graph. 4.15 The User Interface for Graphs; The class TGraphEditor provides the user interface for setting the following graph attributes interactively:. Title text entry field … sets the title of the graph.; Shape radio button group - sets the graph shapes:. No Line: draw unconnected points;; Smooth Line: a smooth curve;; Simple Line: a simple poly-line;; Bart Chart: a bar chart at each point.; Fill Area: a fill area is drawn. Show Marker - sets markers as visible or invisible.; Exclusion Zone - specifies the exclusion zone parameters :. ’+-‘ check button: sets on which side of the line the exclusion zone will be drawn;; Width combo box: defines the width of the zone. 5 Fitting Histograms; To fit a histogram you can use the Fit Panel on a visible histogram via the context menu, or you can use the TH1::Fit method. The Fit Panel, which is limited, is best for prototyping. The histogram needs to be drawn in a pad before the Fit Panel is invoked. The method TH1::Fit is more powerful and is used in scripts and programs.; 5.1 The Fit Method; The Fit method is implemented in ROOT for the histogram classes TH1, the sparse histogram classes, THnSparse, the graph classes, TGraph, TGraph2D and TMultiGraph for fitting a collection of Graphs with the same function.; 5.1.1 The TH1::Fit Method; To fit a histogram programmatically, you can use the TH1::Fit method. Here is the signatures of TH1::Fit and an explanation of the parameters:; TFitResultPtr Fit(TF1 *function, Option_t *option, Option_t *goption,; Axis_t xxmin, Axis_t xxmax). function a pointer to the fitted function (the fit model) object. One can also use the function name. This name may be one of ROOT pre-defined function names or a user-defined function. See the next paragraph for the list of pre-defined functions.; *option: The second parameter is the fitting option. Here is the list of fitting options:. “W” Set all weights to 1 for non empty bins; ignore error bars; “WW” Set all weights to 1 including empty bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:163545,power,powerful,163545,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['power'],['powerful']
Energy Efficiency,"{ ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TH2Poly; enum  { kNOverflow = 9; };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from TH1; static Int_t AutoP2GetBins (Int_t n);  Auxiliary function to get the next power of 2 integer value larger then n. ;  ; static Double_t AutoP2GetPower2 (Double_t x, Bool_t next=kTRUE);  Auxiliary function to get the power of 2 next (larger) or previous (smaller) a given x. ;  ; static bool CheckAxisLimits (const TAxis *a1, const TAxis *a2);  Check that the axis limits of the histograms are the same. ;  ; static bool CheckBinLabels (const TAxis *a1, const TAxis *a2);  Check that axis have same labels. ;  ; static bool CheckBinLimits (const TAxis *a1, const TAxis *a2);  Check bin limits. ;  ; static int CheckConsistency (const TH1 *h1, const TH1 *h2);  Check histogram compatibility. ;  ; static bool CheckConsistentSubAxes (const TAxis *a1, Int_t firstBin1, Int_t lastBin1, const TAxis *a2, Int_t firstBin2=0, Int_t lastBin2=0);  Check that two sub axis are the same. ;  ; static bool CheckEqualAxes (const TAxis *a1, const TAxis *a2);  Check that the axis are the same. ;  ; static Bool_t RecomputeAxisLimits (TAxis &destAxis, const TAxis &anAxis);  Finds new limits for the axis for the Merge function. ;  ; static Bool_t SameLimitsAndNBins (const TAxis &axis1, const TAxis &axis2);  S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2Poly.html:56967,power,power,56967,doc/master/classTProfile2Poly.html,https://root.cern,https://root.cern/doc/master/classTProfile2Poly.html,1,['power'],['power']
Energy Efficiency,"{ return fY;}. Scalar Z() const; { return fZ;}. Scalar T() const; { return fT;}. Scalar P2() const; other coordinate representation. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared). { return fT*fT - fX*fX - fY*fY - fZ*fZ;}. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return fT*fT - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar pz). set Z value. void SetE(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar e). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzE4D<Double32_t>::Scalar px, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar py, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar pz, ROOT::Math::PxPyPzE4D<Double32_t>::Scalar e). set all values using cartesian coordinates. void Negate(); ------ Manipulations -------------. negate the 4-vector. { fX = -fX; fY = -fY; fZ = -fZ; fT = -fT;}. void Scale(const ROOT::Math::PxPyPzE4D<Double32_t>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ==========",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzE4D_Double32_t_.html:6676,energy,energy,6676,root/html526/ROOT__Math__PxPyPzE4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzE4D_Double32_t_.html,7,['energy'],['energy']
Energy Efficiency,"{ return fY;}. Scalar Z() const; { return fZ;}. Scalar T() const; { return fT;}. Scalar P2() const; other coordinate representation. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared). { return fT*fT - fX*fX - fY*fY - fZ*fZ;}. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return std::sqrt(Perp2());}. Scalar Perp() const; { return Pt();}. Scalar Rho() const; { return Pt();}. Scalar Mt2() const. transverse mass squared. { return fT*fT - fZ*fZ; }. Scalar Mt() const. transverse mass. Scalar Et2() const. transverse energy squared. Scalar Et() const. transverse energy. Scalar Phi() const. azimuthal angle. Scalar Theta() const. polar angle. Scalar Eta() const. pseudorapidity. void SetPx(ROOT::Math::PxPyPzE4D<double>::Scalar px); --------- Set Coordinates of this system ---------------. set X value. void SetPy(ROOT::Math::PxPyPzE4D<double>::Scalar py). set Y value. void SetPz(ROOT::Math::PxPyPzE4D<double>::Scalar pz). set Z value. void SetE(ROOT::Math::PxPyPzE4D<double>::Scalar e). set T value. void SetPxPyPzE(ROOT::Math::PxPyPzE4D<double>::Scalar px, ROOT::Math::PxPyPzE4D<double>::Scalar py, ROOT::Math::PxPyPzE4D<double>::Scalar pz, ROOT::Math::PxPyPzE4D<double>::Scalar e). set all values using cartesian coordinates. void Negate(); ------ Manipulations -------------. negate the 4-vector. { fX = -fX; fY = -fY; fZ = -fZ; fT = -fT;}. void Scale(const ROOT::Math::PxPyPzE4D<double>::Scalar& a). scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility section ==========",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzE4D_double_.html:6324,energy,energy,6324,root/html526/ROOT__Math__PxPyPzE4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzE4D_double_.html,15,['energy'],['energy']
Energy Efficiency,"{1, 2, 0}.; v1 = Take(v0, v1_indices);; ROOT::VecOps::ArgsortRVec< typename RVec< T >::size_type > Argsort(const RVec< T > &v)Return an RVec of indices that sort the input RVec.Definition RVec.hxx:2250; The Take utility allows to extract portions of the RVec. The content to be taken can be specified with an RVec of indices or an integer. If the integer is negative, elements will be picked starting from the end of the container: RVecF vf {1.f, 2.f, 3.f, 4.f};; auto vf_1 = Take(vf, {1, 3}); // The content is {2.f, 4.f}; auto vf_2 = Take(vf, 2); // The content is {1.f, 2.f}; auto vf_3 = Take(vf, -3); // The content is {2.f, 3.f, 4.f}. Usage in combination with RDataFrame; RDataFrame leverages internally RVecs. Suppose to have a dataset stored in a TTree which holds these columns (here we choose C arrays to represent the collections, they could be as well std::vector instances): nPart ""nPart/I"" An integer representing the number of particles; px ""px[nPart]/D"" The C array of the particles' x component of the momentum; py ""py[nPart]/D"" The C array of the particles' y component of the momentum; E ""E[nPart]/D"" The C array of the particles' Energy; Suppose you'd like to plot in a histogram the transverse momenta of all particles for which the energy is greater than 200 MeV. The code required would just be: RDataFrame d(""mytree"", ""myfile.root"");; auto cutPt = [](RVecD &pxs, RVecD &pys, RVecD &Es) {; auto all_pts = sqrt(pxs * pxs + pys * pys);; auto good_pts = all_pts[Es > 200.];; return good_pts;; };; ; auto hpt = d.Define(""pt"", cutPt, {""px"", ""py"", ""E""}); .Histo1D(""pt"");; hpt->Draw();; d#define d(i)Definition RSha256.hxx:102; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; And if you'd like to express your selection as a string: RDataFrame d(""mytree"", ""myfile.root"");; auto hpt = d.Define(""pt"", ""sqrt(pxs * pxs + pys * pys)[E>200]""); .Histo1D(""pt"");; hpt->Draw();; . PyROOT; The ROOT::R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html:7870,energy,energy,7870,doc/v632/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html,2,['energy'],['energy']
Energy Efficiency,"{; 128 A |= (A >> 1);; 129 A |= (A >> 2);; 130 A |= (A >> 4);; 131 A |= (A >> 8);; 132 A |= (A >> 16);; 133 A |= (A >> 32);; 134 return A + 1;; 135}; 136 ; 137/// This is all the stuff common to all SmallVectors.; 138class R__CLING_PTRCHECK(off) SmallVectorBase {; 139public:; 140 // This limits the maximum size of an RVec<char> to ~4GB but we don't expect this to ever be a problem,; 141 // and we prefer the smaller Size_T to reduce the size of each RVec object.; 142 using Size_T = int32_t;; 143 ; 144protected:; 145 void *fBeginX;; 146 /// Always >= 0.; 147 // Type is signed only for consistency with fCapacity.; 148 Size_T fSize = 0;; 149 /// Always >= -1. fCapacity == -1 indicates the RVec is in ""memory adoption"" mode.; 150 Size_T fCapacity;; 151 ; 152 /// The maximum value of the Size_T used.; 153 static constexpr size_t SizeTypeMax() { return std::numeric_limits<Size_T>::max(); }; 154 ; 155 SmallVectorBase() = delete;; 156 SmallVectorBase(void *FirstEl, size_t TotalCapacity) : fBeginX(FirstEl), fCapacity(TotalCapacity) {}; 157 ; 158 /// This is an implementation of the grow() method which only works; 159 /// on POD-like data types and is out of line to reduce code duplication.; 160 /// This function will report a fatal error if it cannot increase capacity.; 161 void grow_pod(void *FirstEl, size_t MinSize, size_t TSize);; 162 ; 163 /// Report that MinSize doesn't fit into this vector's size type. Throws; 164 /// std::length_error or calls report_fatal_error.; 165 static void report_size_overflow(size_t MinSize);; 166 /// Report that this vector is already at maximum capacity. Throws; 167 /// std::length_error or calls report_fatal_error.; 168 static void report_at_maximum_capacity();; 169 ; 170 /// If false, the RVec is in ""memory adoption"" mode, i.e. it is acting as a view on a memory buffer it does not own.; 171 bool Owns() const { return fCapacity != -1; }; 172 ; 173public:; 174 size_t size() const { return fSize; }; 175 size_t capacity() const noexcept { return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RVec_8hxx_source.html:4839,reduce,reduce,4839,doc/master/RVec_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RVec_8hxx_source.html,2,['reduce'],['reduce']
Energy Efficiency,"{; 3327 Double_t red[9] = { 180./255., 106./255., 104./255., 135./255., 164./255., 188./255., 189./255., 165./255., 144./255.};; 3328 Double_t green[9] = { 72./255., 126./255., 154./255., 184./255., 198./255., 207./255., 205./255., 190./255., 179./255.};; 3329 Double_t blue[9] = { 41./255., 120./255., 158./255., 188./255., 194./255., 181./255., 145./255., 100./255., 62./255.};; 3330 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3331 }; 3332 break;; 3333 ; 3334 // Lake; 3335 case 86:; 3336 {; 3337 Double_t red[9] = { 57./255., 72./255., 94./255., 117./255., 136./255., 154./255., 174./255., 192./255., 215./255.};; 3338 Double_t green[9] = { 0./255., 33./255., 68./255., 109./255., 140./255., 171./255., 192./255., 196./255., 209./255.};; 3339 Double_t blue[9] = { 116./255., 137./255., 173./255., 201./255., 200./255., 201./255., 203./255., 190./255., 187./255.};; 3340 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3341 }; 3342 break;; 3343 ; 3344 // Light Temperature; 3345 case 87:; 3346 {; 3347 Double_t red[9] = { 31./255., 71./255., 123./255., 160./255., 210./255., 222./255., 214./255., 199./255., 183./255.};; 3348 Double_t green[9] = { 40./255., 117./255., 171./255., 211./255., 231./255., 220./255., 190./255., 132./255., 65./255.};; 3349 Double_t blue[9] = { 234./255., 214./255., 228./255., 222./255., 210./255., 160./255., 105./255., 60./255., 34./255.};; 3350 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3351 }; 3352 break;; 3353 ; 3354 // Light Terrain; 3355 case 88:; 3356 {; 3357 Double_t red[9] = { 123./255., 108./255., 109./255., 126./255., 154./255., 172./255., 188./255., 196./255., 218./255.};; 3358 Double_t green[9] = { 184./255., 138./255., 130./255., 133./255., 154./255., 175./255., 188./255., 196./255., 218./255.};; 3359 Double_t blue[9] = { 208./255., 130./255., 109./255., 99./255., 110./255., 122./255., 150./255., 171./255., 218./255.};; 3360 Idx = TCol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:130234,green,green,130234,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['green'],['green']
Energy Efficiency,"|; Protected Member Functions |; Protected Attributes |; List of all members ; RooEffProd Class Reference. ; The class RooEffProd implements the product of a PDF with an efficiency function. ; The normalization integral of the product is calculated numerically, but the event generation is handled by a specialized generator context that implements the event generation in a more efficient for cases where the PDF has an internal generator that is smarter than accept reject. ; Definition at line 19 of file RooEffProd.h. Public Member Functions;  RooEffProd ();  ;  RooEffProd (const char *name, const char *title, RooAbsPdf &pdf, RooAbsReal &efficiency);  Constructs the product of the PDF inPdf with the efficiency function inEff. ;  ;  RooEffProd (const RooEffProd &other, const char *name=nullptr);  Copy constructor. ;  ; TObject * clone (const char *newname) const override;  ; RooAbsGenContext * genContext (const RooArgSet &vars, const RooDataSet *prototype, const RooArgSet *auxProto, bool verbose) const override;  Return specialized generator context for RooEffProds that implements generation in a more efficient way than can be done for generic correlated products. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooEffProd.html:1314,efficient,efficient,1314,doc/master/classRooEffProd.html,https://root.cern,https://root.cern/doc/master/classRooEffProd.html,1,['efficient'],['efficient']
Energy Efficiency,"|; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; ROOT::R::TRInterface Class ReferenceR Interface for Statistical Computing. ; ROOT R was implemented using the R Project library and the modules Rcpp and RInside ; TRInterface class; The TRInterface class lets you process R code from ROOT.; You can call R libraries and their functions, plot results in R or ROOT,; and use the power of ROOT and R at the same time.; It also lets you pass scalars, vectors and matrices from ROOT to R; and from R to ROOT using TRObject; but you can to use overloaded operators [],<< and >> ; to work with ROOTR like work with streams of data. TRInterface class can not be instantiated directly, but you can create objects using the static methods TRInterface& Instance() and TRInterface* InstancePtr() to create your own objects. Show an example below: Create an exponential fit, the idea is to create a set of numbers x,y with noise from ROOT, pass them to R and fit the data to \( x^3 \), get the fitted coefficient(power) and plot the data, the known function and the fitted function. TCanvas *c1 = new TCanvas(""c1"",""Curve Fit"",700,500);; c1->SetGrid();; ; // draw a frame for multiples graphs; TMultiGraph *mg = new TMultiGraph();; ; // create the first graph (points with gaussian noise); const Int_t n = 24;; Double_t x[n] ;; Double_t y[n] ;; //Generate points along a X^3 with noise; TRandom rg;; rg.SetSeed(520);; for (Int_t i = 0; i < n; i++) {; x[i] = rg.Uniform(0, 1);; y[i] = TMath::Power(x[i], 3) + rg.Gaus() * 0.06;; }; ; TGraph *gr1 = new TGraph(n,x,y);; gr1->SetMarkerColor(kBlue);; gr1->SetMarkerStyle(8);; gr1->SetMarkerSize(1);; mg->Add(gr1);; ; // create second graph; TF1 *f_known=new TF1(""f_known"",""pow(x,3)"",0,1);; TGraph *gr2 = new TGraph(f_known);; gr2->SetMarkerColor(kRed);; gr2->SetMarkerStyle(8);; gr2->SetMarkerSize(1);; mg->Add(gr2);; ; //passing x and y values to R for fitting; ROOT::R::TRInterface &r=ROOT::R::TRInterface::I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html:1245,power,power,1245,doc/master/classROOT_1_1R_1_1TRInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1R_1_1TRInterface.html,1,['power'],['power']
Energy Efficiency,"}, ""intCol"");; 1682 /// ~~~; 1683 ///; 1684 /// This action is *lazy*: upon invocation of this method the calculation is; 1685 /// booked but not executed. Also see RResultPtr.; 1686 // clang-format on; 1687 template <typename F, typename T = typename TTraits::CallableTraits<F>::ret_type>; 1688 RResultPtr<T> Reduce(F f, std::string_view columnName = """"); 1689 {; 1690 static_assert(; 1691 std::is_default_constructible<T>::value,; 1692 ""reduce object cannot be default-constructed. Please provide an initialisation value (redIdentity)"");; 1693 return Reduce(std::move(f), columnName, T());; 1694 }; 1695 ; 1696 ////////////////////////////////////////////////////////////////////////////; 1697 /// \brief Execute a user-defined reduce operation on the values of a column.; 1698 /// \tparam F The type of the reduce callable. Automatically deduced.; 1699 /// \tparam T The type of the column to apply the reduction to. Automatically deduced.; 1700 /// \param[in] f A callable with signature `T(T,T)`; 1701 /// \param[in] columnName The column to be reduced. If omitted, the first default column is used instead.; 1702 /// \param[in] redIdentity The reduced object of each thread is initialized to this value.; 1703 /// \return the reduced quantity wrapped in a RResultPtr.; 1704 ///; 1705 /// ### Example usage:; 1706 /// ~~~{.cpp}; 1707 /// auto sumOfIntColWithOffset = d.Reduce([](int x, int y) { return x + y; }, ""intCol"", 42);; 1708 /// ~~~; 1709 /// See the description of the first Reduce overload for more information.; 1710 template <typename F, typename T = typename TTraits::CallableTraits<F>::ret_type>; 1711 RResultPtr<T> Reduce(F f, std::string_view columnName, const T &redIdentity); 1712 {; 1713 return Aggregate(f, f, columnName, redIdentity);; 1714 }; 1715 ; 1716 ////////////////////////////////////////////////////////////////////////////; 1717 /// \brief Return the number of entries processed (*lazy action*).; 1718 /// \return the number of entries wrapped in a RResultPtr.; 17",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:95358,reduce,reduced,95358,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['reduce'],['reduced']
Energy Efficiency,"}. Scalar Rho() const; { return Pt(); }. Scalar T() const; { return E(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar M2() const. vector magnitude squared (or mass squared). { Scalar p = P(); return fE*fE - p*p; }. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { Scalar pz = Pz(); return fE*fE - pz*pz; }. Scalar Mt() const. transverse mass. Scalar Et() const. transverse energy. transverse energy. Scalar Et2() const. transverse energy squared. { Scalar et = Et(); return et*et; }. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar phi). set phi value. void SetE(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e). set E value. void SetPxPyPzE(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar px, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar py, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar pz, ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector. void Scale(ROOT::Math::PtEtaPhiE4D<Double32_t>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiE4D_Double32_t_.html:7008,energy,energy,7008,root/html526/ROOT__Math__PtEtaPhiE4D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiE4D_Double32_t_.html,7,['energy'],['energy']
Energy Efficiency,"}. Scalar Rho() const; { return Pt(); }. Scalar T() const; { return E(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar M2() const. vector magnitude squared (or mass squared). { Scalar p = P(); return fE*fE - p*p; }. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fPt*fPt;}. Scalar Perp2() const; { return Pt2(); }. Scalar Mt2() const. transverse mass squared. { Scalar pz = Pz(); return fE*fE - pz*pz; }. Scalar Mt() const. transverse mass. Scalar Et() const. transverse energy. transverse energy. Scalar Et2() const. transverse energy squared. { Scalar et = Et(); return et*et; }. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Theta() const. polar angle. void SetPt(ROOT::Math::PtEtaPhiE4D<double>::Scalar pt); --------- Set Coordinates of this system ---------------. set Pt value. void SetEta(ROOT::Math::PtEtaPhiE4D<double>::Scalar eta). set eta value. void SetPhi(ROOT::Math::PtEtaPhiE4D<double>::Scalar phi). set phi value. void SetE(ROOT::Math::PtEtaPhiE4D<double>::Scalar e). set E value. void SetPxPyPzE(ROOT::Math::PtEtaPhiE4D<double>::Scalar px, ROOT::Math::PtEtaPhiE4D<double>::Scalar py, ROOT::Math::PtEtaPhiE4D<double>::Scalar pz, ROOT::Math::PtEtaPhiE4D<double>::Scalar e). set values using cartesian coordinate system. void Negate(); ------ Manipulations -------------. negate the 4-vector. void Scale(ROOT::Math::PtEtaPhiE4D<double>::Scalar a). Scale coordinate values by a scalar quantity a. Scalar x() const; ============= Compatibility seci",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiE4D_double_.html:6652,energy,energy,6652,root/html526/ROOT__Math__PtEtaPhiE4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiE4D_double_.html,7,['energy'],['energy']
Energy Efficiency,"}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. Scalar Dot(const OtherLorentzVector & q); ------ Operations combining two Lorentz vectors ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html:18028,energy,energy,18028,root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,6,['energy'],['energy']
Energy Efficiency,"}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. Scalar Dot(const OtherLorentzVector & q); ------ Operations combining two Lorentz vectors ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html:17290,energy,energy,17290,root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,6,['energy'],['energy']
Energy Efficiency,"}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. Scalar Dot(const OtherLorentzVector & q); ------ Operations combining two Lorentz vectors ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html:18870,energy,energy,18870,root/html528/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,6,['energy'],['energy']
Energy Efficiency,"}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. Scalar Dot(const OtherLorentzVector & q); ------ Operations combining two Lorentz vectors ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html:17264,energy,energy,17264,root/html528/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,6,['energy'],['energy']
Energy Efficiency,"};; ; // If you do the fit the usual was in RooFit, you will get a bias in the; // result. This is because the continuous, normalized pdf is evaluated only; // at the bin centers.; std::unique_ptr<RooFitResult> fit1{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit1->Print();; ; // In the case of an exponential function, the bias that you get by; // evaluating the pdf only at the bin centers is a constant scale factor in; // each bin. Here, we can do a trick to get rid of the bias: we also; // evaluate the normalization integral for the pdf the same way, i.e.,; // summing the values of the unnormalized pdf at the bin centers. Like this; // the bias cancels out. You can achieve this by customizing the way how the; // pdf is integrated (see also the rf901_numintconfig tutorial).; enableBinIntegrator(expo, x.numBins());; std::unique_ptr<RooFitResult> fit2{expo.fitTo(*expoData, Save(), PrintLevel(-1), SumW2Error(false))};; fit2->Print();; disableBinIntegrator(expo);; ; // Power law example; // -----------------; ; // Let's not look at another example: a power law \f[x^a\f].; RooRealVar a{""a"", ""a"", -0.3, -5.0, 5.0};; RooPowerSum powerlaw{""powerlaw"", ""powerlaw"", x, RooConst(1.0), a};; std::unique_ptr<RooAbsData> powerlawData{generateBinnedAsimov(powerlaw, x, 10000)};; ; // Again, if you do a vanilla fit, you'll get a bias; std::unique_ptr<RooFitResult> fit3{powerlaw.fitTo(*powerlawData, Save(), PrintLevel(-1), SumW2Error(false))};; fit3->Print();; ; // This time, the bias is not the same factor in each bin! This means our; // trick by sampling the integral in the same way doesn't cancel out the; // bias completely. The average bias is canceled, but there are per-bin; // biases that remain. Still, this method has some value: it is cheaper than; // rigurously correcting the bias by integrating the pdf in each bin. So if; // you know your per-bin bias variations are small or performance is an; // issue, this approach can be sufficient.; enableBinIntegra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html:4171,power,power,4171,doc/master/rf614__binned__fit__problems_8C.html,https://root.cern,https://root.cern/doc/master/rf614__binned__fit__problems_8C.html,1,['power'],['power']
Energy Efficiency,"~~~; 4314///; 4315/// works for 1D, 2D, etc. histograms; 4316/// c2 is an optional argument that gives a relative weight between the two; 4317/// histograms, and dc2 is the error on this weight. This is useful, for example,; 4318/// when forming an asymmetry between two histograms from 2 different data sets that; 4319/// need to be normalized to each other in some way. The function calculates; 4320/// the errors assuming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)).; 4321///; 4322/// example: assuming 'h1' and 'h2' are already filled; 4323///; 4324/// ~~~ {.cpp}; 4325/// h3 = h1->GetAsymmetry(h2); 4326/// ~~~; 4327///; 4328/// then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; 4329/// h1 and h2 are left intact.; 4330///; 4331/// Note that it is the user's responsibility to manage the created histogram.; 4332/// The name of the returned histogram will be `Asymmetry_nameOfh1-nameOfh2`; 4333///; 4334/// code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun; 4335///; 4336/// clone the histograms so top and bottom will have the; 4337/// correct dimensions:; 4338/// Sumw2 just makes sure the errors will be computed properly; 4339/// when we form sums and ratios below.; 4340 ; 4341TH1 *TH1::GetAsymmetry(TH1* h2, Double_t c2, Double_t dc2); 4342{; 4343 TH1 *h1 = this;; 4344 TString name = TString::Format(""Asymmetry_%s-%s"",h1->GetName(),h2->GetName() );; 4345 TH1 *asym = (TH1*)Clone(name);; 4346 ; 4347 // set also the title; 4348 TString title = TString::Format(""(%s - %s)/(%s+%s)"",h1->GetName(),h2->GetName(),h1->GetName(),h2->GetName() );; 4349 asym->SetTitle(title);; 4350 ; 4351 asym->Sumw2();; 4352 Bool_t addStatus = TH1::AddDirectoryStatus();; 4353 TH1::AddDirectory(kFALSE);; 4354 TH1 *top = (TH1*)asym->Clone();; 4355 TH1 *bottom = (TH1*)asym->Clone();; 4356 TH1::AddDirectory(addStatus);; 4357 ; 4358 // form the top and bottom of the asymmetry, and then divide:; 4359 top->Add(h1,h2,1,-c2);; 4360 bottom->Add(h1,h2,1,c2);; 436",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:179299,adapt,adapted,179299,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['adapt'],['adapted']
Energy Efficiency," . #include <TSpectrum2Transform.h>. Inheritance diagram for TSpectrum2Transform:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ anonymous enum. anonymous enum. EnumeratorkTransformHaar ; kTransformWalsh ; kTransformCos ; kTransformSin ; kTransformFourier ; kTransformHartley ; kTransformFourierWalsh ; kTransformFourierHaar ; kTransformWalshHaar ; kTransformCosWalsh ; kTransformCosHaar ; kTransformSinWalsh ; kTransformSinHaar ; kTransformForward ; kTransformInverse . Definition at line 30 of file TSpectrum2Transform.h. Constructor & Destructor Documentation. ◆ TSpectrum2Transform() [1/2]. TSpectrum2Transform::TSpectrum2Transform ; (; ). Default constructor. ; Definition at line 41 of file TSpectrum2Transform.cxx. ◆ TSpectrum2Transform() [2/2]. TSpectrum2Transform::TSpectrum2Transform ; (; Int_t ; sizeX, . Int_t ; sizeY . ). The constructor creates TSpectrum2Transform object. ; Its sizes must be > than zero and must be power of 2. It sets default transform type to be Cosine transform. Transform parameters can be changed using setter functions. ; Definition at line 59 of file TSpectrum2Transform.cxx. ◆ ~TSpectrum2Transform(). TSpectrum2Transform::~TSpectrum2Transform ; (; ). override . Destructor. ; Definition at line 97 of file TSpectrum2Transform.cxx. Member Function Documentation. ◆ BitReverse(). void TSpectrum2Transform::BitReverse ; (; Double_t * ; working_space, . Int_t ; num . ). protected . This function carries out bit-reverse reordering of data. ; Function parameters:; working_space-pointer to vector of processed data; num-length of processed data . Definition at line 242 of file TSpectrum2Transform.cxx. ◆ BitReverseHaar(). void TSpectrum2Transform::BitReverseHaar ; (; Double_t * ; working_space, . Int_t ; shift, . Int_t ; num, . Int_t ; start . ). protected . This function carries out bit-reverse reordering for Haar transform. ; Function parameters:; working_space-pointer t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Transform.html:16492,power,power,16492,doc/master/classTSpectrum2Transform.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Transform.html,1,['power'],['power']
Energy Efficiency," . ). inlineprotected . Definition at line 57 of file TMatrixTSparse.h. ◆ APlusB() [1/3]. template<class Element > . void TMatrixTSparse< Element >::APlusB ; (; const TMatrixT< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). inlineprotected . Definition at line 67 of file TMatrixTSparse.h. ◆ APlusB() [2/3]. template<class Element > . void TMatrixTSparse< Element >::APlusB ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixT< Element > & ; b, . Int_t ; constr = 0 . ). protected . General matrix addition. ; Replace this matrix with C such that C = A + B. Note, matrix C is allocated for constr=1. ; Definition at line 927 of file TMatrixTSparse.cxx. ◆ APlusB() [3/3]. template<class Element > . void TMatrixTSparse< Element >::APlusB ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). protected . General matrix addition. ; Replace this matrix with C such that C = A + B. Note, matrix C is allocated for constr=1. ; Definition at line 845 of file TMatrixTSparse.cxx. ◆ Class() [1/2]. template<class Element > . static TClass * TMatrixTSparse< Element >::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class() [2/2]. TClass * TMatrixTSparse< double >::Class ; (; ). ◆ Class_Name(). template<class Element > . static const char * TMatrixTSparse< Element >::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). template<class Element > . static constexpr Version_t TMatrixTSparse< Element >::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 215 of file TMatrixTSparse.h. ◆ Clear(). template<class Element > . void TMatrixTSparse< Element >::Clear ; (; Option_t * ; = """"). inlineoverridevirtual . Implements TMatrixTBase< Element >.; Definition at line 130 of file TMatrixTSparse.h. ◆ ColNorm(). template<class Element > . Element TMatrixTSparse< Element >::ColNorm. overridevirtual . Column matrix norm, MAX{ S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSparse.html:37380,allocate,allocated,37380,doc/master/classTMatrixTSparse.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSparse.html,1,['allocate'],['allocated']
Energy Efficiency," . Protected Member Functions; Double_t RetrieveBinContent (Int_t bin) const override;  Raw retrieval of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ; void UpdateBinContent (Int_t bin, Double_t content) override;  Raw update of bin content on internal data structure see convention for numbering bins in TH1::GetBin. ;  ;  Protected Member Functions inherited from TH1;  TH1 ();  Histogram default constructor. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins);  Constructor for variable bin size histograms using an input array of type double. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins);  Constructor for variable bin size histograms using an input array of type float. ;  ;  TH1 (const char *name, const char *title, Int_t nbinsx, Double_t xlow, Double_t xup);  Constructor for fix bin size histograms. ;  ; virtual Int_t AutoP2FindLimits (Double_t min, Double_t max);  Buffer-based estimate of the histogram range using the power of 2 algorithm. ;  ; Int_t AxisChoice (Option_t *axis) const;  Choose an axis according to ""axis"". ;  ; virtual Int_t BufferFill (Double_t x, Double_t w);  accumulate arguments in buffer. ;  ; virtual void DoFillN (Int_t ntimes, const Double_t *x, const Double_t *w, Int_t stride=1);  Internal method to fill histogram content from a vector called directly by TH1::BufferEmpty. ;  ; virtual Double_t DoIntegral (Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t &err, Option_t *opt, Bool_t doerr=kFALSE) const;  Internal function compute integral and optionally the error between the limits specified by the bin number values working for all histograms (1D, 2D and 3D) ;  ; virtual Bool_t FindNewAxisLimits (const TAxis *axis, const Double_t point, Double_t &newMin, Double_t &newMax);  finds new limits for the axis so that point is within the range and the limits are compatible with the previous ones (see TH1::Merg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1C.html:43349,power,power,43349,doc/master/classTH1C.html,https://root.cern,https://root.cern/doc/master/classTH1C.html,6,['power'],['power']
Energy Efficiency," ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TTree.cxx. Go to the documentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Rene Brun 12/01/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11/**; 12 \defgroup tree Tree Library; 13 ; 14 In order to store columnar datasets, ROOT provides the TTree, TChain,; 15 TNtuple and TNtupleD classes.; 16 The TTree class represents a columnar dataset. Any C++ type can be stored in the; 17 columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; 18 it is demonstrated to scale and it's battle tested. It has been optimized during the years; 19 to reduce dataset sizes on disk and to deliver excellent runtime performance.; 20 It allows to access only part of the columns of the datasets, too.; 21 The TNtuple and TNtupleD classes are specialisations of the TTree class which can; 22 only hold single precision and double precision floating-point numbers respectively;; 23 The TChain is a collection of TTrees, which can be located also in different files.; 24 ; 25*/; 26 ; 27/** \class TTree; 28\ingroup tree; 29 ; 30A TTree represents a columnar dataset. Any C++ type can be stored in its columns.; 31 ; 32A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; 33represented by the TBranch class.; 34Behind each branch, buffers are allocated automatically by ROOT.; 35Such buffers are automatically written to disk or kept in memory until the size stored in the; 36attribute fMaxVirtualSize is reached.; 37Variables of one branch are written to the same buffer. A branch buffer is; 38automatically compressed if the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:1039,reduce,reduce,1039,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['reduce'],['reduce']
Energy Efficiency," ; Bool_t GetRnrDecay () const;  ; Bool_t GetRnrFV () const;  ; Bool_t GetRnrPTBMarkers () const;  ; Bool_t GetRnrReferences () const;  ; EStepper_e GetStepper () const;  ; Double_t GetTrackLength (Int_t start_point=0, Int_t end_point=-1) const;  Calculate track length from start_point to end_point. ;  ; virtual void GoToBounds (TEveVectorD &p);  Propagate particle to bounds. ;  ; void GoToBounds (TEveVectorF &p);  TEveVectorF wrapper. ;  ; virtual Bool_t GoToLineSegment (const TEveVectorD &s, const TEveVectorD &r, TEveVectorD &p);  Propagate particle with momentum p to line with start point s and vector r to the second point. ;  ; Bool_t GoToLineSegment (const TEveVectorF &s, const TEveVectorF &r, TEveVectorF &p);  TEveVectorF wrapper. ;  ; virtual Bool_t GoToVertex (TEveVectorD &v, TEveVectorD &p);  Propagate particle with momentum p to vertex v. ;  ; Bool_t GoToVertex (TEveVectorF &v, TEveVectorF &p);  TEveVectorF wrapper. ;  ; void InitTrack (const TEveVectorD &v, Int_t charge);  Initialize internal data-members for given particle parameters. ;  ; void InitTrack (const TEveVectorF &v, Int_t charge);  TEveVectorF wrapper. ;  ; Bool_t IntersectPlane (const TEveVectorD &p, const TEveVectorD &point, const TEveVectorD &normal, TEveVectorD &itsect);  Find intersection of currently propagated track with a plane. ;  ; TClass * IsA () const override;  ; void OnZeroRefCount () override;  Virtual from TEveRefBackPtr - track reference count has reached zero. ;  ; void PrintMagField (Double_t x, Double_t y, Double_t z) const;  ; TMarker & RefFVAtt ();  ; TMarker & RefPMAtt ();  ; TMarker & RefPTBAtt ();  ; void ResetTrack ();  Reset cache holding particle trajectory. ;  ; void SetDelta (Double_t x);  Set maximum error and rebuild tracks. ;  ; void SetEditPathMarks (Bool_t x);  ; void SetFitCluster2Ds (Bool_t x);  Set 2D-cluster fitting and rebuild tracks. ;  ; void SetFitDaughters (Bool_t x);  Set daughter creation point fitting and rebuild tracks. ;  ; void SetFitDecay (Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveTrackPropagator.html:5279,charge,charge,5279,doc/master/classTEveTrackPropagator.html,https://root.cern,https://root.cern/doc/master/classTEveTrackPropagator.html,1,['charge'],['charge']
Energy Efficiency," ; TList * GetListOfConnections () const;  ; TList * GetListOfSignals () const;  ; virtual Bool_t HasConnection (const char *signal_name) const;  Return true if there is any object connected to this signal. ;  ; virtual void HighPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void LowPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void Message (const char *msg);  ; virtual Int_t NumberOfConnections () const;  Return number of connections for this object. ;  ; virtual Int_t NumberOfSignals () const;  Return number of signals for this object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Protected Member Functions; TGListBox * BuildLogList (TGFrame *parent);  Build the list of workers. ;  ; TGraph * DoAveragePlot (Int_t &max_el, Int_t &min_el);  Create the average plots. ;  ; TGraph * DoAveragePlotOld (Int_t &max_el, Int_t &min_el);  ; TGraph * DoMasterPlot (TProofLogElem *ple);  a master or submaster log display without meaningful labels for now ;  ; TGraph * DoWorkerPlot (TProofLogElem *ple);  Make a memory consumption graph for a worker. ;  ; Int_t ParseLine (TString l, Long64_t &v, Long64_t &r, Long64_t &e);  Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the number of events 'e'. ;  ;  Protected Member Functions inherited from TGMainFrame; TString GetMWMfuncString () const;  used in SaveSource() ;  ; TString GetMWMinpString () const;  used in SaveSource() ;  ; TString GetMWMvalueString () const;  used in SaveSource() ;  ;  Protected Member Functions inherited from TGFrame; void DoRedraw () override;  Redraw the frame. ;  ; virtual void Draw3dRectangle (UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h);  Draw 3D rectangle on the frame border. ;  ; TString GetOptionString () const;  Returns a frame option string - used in SavePrimitive(). ;  ; const TGResourcePool * GetResourcePool () const;  ; void * GetSender () override;  ; virtual void StartGuiBuilding",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressMemoryPlot.html:25045,consumption,consumption,25045,doc/master/classTProofProgressMemoryPlot.html,https://root.cern,https://root.cern/doc/master/classTProofProgressMemoryPlot.html,1,['consumption'],['consumption']
Energy Efficiency," ; ibin); const. Definition at line 119 of file RooParamHistFunc.cxx. ◆ IsA(). TClass * RooParamHistFunc::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 63 of file RooParamHistFunc.h. ◆ isBinnedDistribution(). bool RooParamHistFunc::isBinnedDistribution ; (; const RooArgSet & ; ); const. inlineoverridevirtual . Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ; Reimplemented from RooAbsReal.; Definition at line 34 of file RooParamHistFunc.h. ◆ paramList(). const RooArgList & RooParamHistFunc::paramList ; (; ); const. inline . Definition at line 46 of file RooParamHistFunc.h. ◆ plotSamplingHint(). std::list< double > * RooParamHistFunc::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 130 of file RooParamHistFunc.cxx. ◆ setActual(). void RooParamHistFunc::setActual ; (; Int_t ; ibin, . double ; newVal . ). Definition at line 104 of file RooParamHistFunc.cxx. ◆ Streamer(). void RooParamHistFunc::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooParamHistFunc::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 63 of file RooParamHistFunc.h. ◆ translate(). void RooParamHistFunc::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooParamHistFunc.html:65267,efficient,efficiently,65267,doc/master/classRooParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooParamHistFunc.html,1,['efficient'],['efficiently']
Energy Efficiency," ; init = 0, . Int_t ; nr_nonzeros = 0 . ). protected . Allocate new matrix. ; Arguments are number of rows, columns, row lowerbound (0 default) and column lowerbound (0 default), 0 initialization flag and number of non-zero elements (only relevant for sparse format). ; Definition at line 384 of file TMatrixTSparse.cxx. ◆ AMinusB() [1/3]. template<class Element > . void TMatrixTSparse< Element >::AMinusB ; (; const TMatrixT< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). protected . General matrix subtraction. ; Replace this matrix with C such that C = A - B. Note, matrix C is allocated for constr=1. ; Definition at line 1151 of file TMatrixTSparse.cxx. ◆ AMinusB() [2/3]. template<class Element > . void TMatrixTSparse< Element >::AMinusB ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixT< Element > & ; b, . Int_t ; constr = 0 . ). protected . General matrix subtraction. ; Replace this matrix with C such that C = A - B. Note, matrix C is allocated for constr=1. ; Definition at line 1080 of file TMatrixTSparse.cxx. ◆ AMinusB() [3/3]. template<class Element > . void TMatrixTSparse< Element >::AMinusB ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). protected . General matrix subtraction. ; Replace this matrix with C such that C = A - B. Note, matrix C is allocated for constr=1. ; Definition at line 998 of file TMatrixTSparse.cxx. ◆ AMultB() [1/3]. template<class Element > . void TMatrixTSparse< Element >::AMultB ; (; const TMatrixT< Element > & ; a, . const TMatrixTSparse< Element > & ; b, . Int_t ; constr = 0 . ). inlineprotected . Definition at line 54 of file TMatrixTSparse.h. ◆ AMultB() [2/3]. template<class Element > . void TMatrixTSparse< Element >::AMultB ; (; const TMatrixTSparse< Element > & ; a, . const TMatrixT< Element > & ; b, . Int_t ; constr = 0 . ). inlineprotected . Definition at line 51 of file TMatrixTSparse.h. ◆ AMultB() [3/3]. template<class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSparse.html:34200,allocate,allocated,34200,doc/master/classTMatrixTSparse.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSparse.html,1,['allocate'],['allocated']
Energy Efficiency," ; t = """" . ). Constructor. ; Definition at line 51 of file TEveJetCone.cxx. ◆ ~TEveJetCone(). TEveJetCone::~TEveJetCone ; (; ). inlineoverride . Definition at line 49 of file TEveJetCone.h. Member Function Documentation. ◆ AddCone(). Int_t TEveJetCone::AddCone ; (; Float_t ; eta, . Float_t ; phi, . Float_t ; cone_r, . Float_t ; length = 0 . ). Add jet cone. ; parameters are :; (eta,phi) : of the center/leading particle; cone_r : cone radius in eta-phi space; length : length of the cone; if cylinder is set and length is adapted to cylinder.; if length is given, it will be used as scalar factor. if cylinder is not set, length is used as length of the cone Return 0 on success. . Definition at line 92 of file TEveJetCone.cxx. ◆ AddEllipticCone(). Int_t TEveJetCone::AddEllipticCone ; (; Float_t ; eta, . Float_t ; phi, . Float_t ; reta, . Float_t ; rphi, . Float_t ; length = 0 . ). Add jet cone. ; parameters are :; (eta,phi) : of the center/leading particle; (reta, rphi) : radius of cone in eta-phi space; length : length of the cone; if cylinder is set and length is adapted to cylinder.; if length is given, it will be used as scalar factor. if cylinder is not set, length is used as length of the cone Returns 0 on success. . Definition at line 108 of file TEveJetCone.cxx. ◆ CalcBaseVec() [1/2]. TEveVector TEveJetCone::CalcBaseVec ; (; Float_t ; alpha); const. protected . Returns point on the base of the cone with internal angle alpha: alpha = 0 -> max eta, alpha = pi/2 -> max phi, ... ; Definition at line 166 of file TEveJetCone.cxx. ◆ CalcBaseVec() [2/2]. TEveVector TEveJetCone::CalcBaseVec ; (; Float_t ; eta, . Float_t ; phi . ); const. protected . Returns point on the base of the cone with given eta and phi. ; Definition at line 135 of file TEveJetCone.cxx. ◆ CalcEtaPhiVec(). TEveVector TEveJetCone::CalcEtaPhiVec ; (; Float_t ; eta, . Float_t ; phi . ); const. protected . Fill TEveVector with eta and phi, magnitude 1. ; Definition at line 125 of file TEveJetCone.cxx. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveJetCone.html:41135,adapt,adapted,41135,doc/master/classTEveJetCone.html,https://root.cern,https://root.cern/doc/master/classTEveJetCone.html,1,['adapt'],['adapted']
Energy Efficiency," ; virtual Bool_t HasAnalysisType (Types::EAnalysisType type, UInt_t numberClasses, UInt_t);  RuleFit can handle classification with 2 classes. ;  ; virtual TClass * IsA () const;  ; virtual void ReadWeightsFromStream (std::istream &)=0;  ; void ReadWeightsFromStream (std::istream &istr);  read rules from an std::istream ;  ; virtual void ReadWeightsFromStream (TFile &);  ; void ReadWeightsFromXML (void *wghtnode);  read rules from XML node ;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Train (void);  ; Bool_t UseBoost () const;  ; void WriteMonitoringHistosToFile (void) const;  write special monitoring histograms to file (here ntuple) ;  ;  Public Member Functions inherited from TMVA::MethodBase;  MethodBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &dsi, const TString &theOption="""");  standard constructor ;  ;  MethodBase (Types::EMVA methodType, DataSetInfo &dsi, const TString &weightFile);  constructor used for Testing + Application of the MVA, only (no training), using given WeightFiles ;  ; virtual ~MethodBase ();  destructor ;  ; void AddOutput (Types::ETreeType type, Types::EAnalysisType analysisType);  ; TDirectory * BaseDir () const;  returns the ROOT directory where info/histograms etc of the corresponding MVA method instance are stored ;  ; virtual void CheckSetup ();  check may be overridden by derived class (sometimes, eg, fitters are used which can only be implemented during training phase) ;  ; DataSet * Data () const;  ; DataSetInfo & DataInfo () const;  ; virtual void DeclareCompatibilityOptions ();  options that are used ONLY for the READER to ensure backward compatibility they are hence without any effect (the reader is only reading the training options that HAD been used at the training of the .xml weight file at hand ;  ; void DisableWriting (Bool_t setter);  ; Bool_t DoMulticlass () const;  ; Bool_t DoRegression () const;  ; void Exi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodRuleFit.html:2645,monitor,monitoring,2645,doc/master/classTMVA_1_1MethodRuleFit.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodRuleFit.html,1,['monitor'],['monitoring']
Energy Efficiency," Array of floats (32 bits per element). More...;  ; class  TArrayI;  Array of integers (32 bits per element). More...;  ; class  TArrayL;  Array of longs (32 or 64 bits per element). More...;  ; class  TArrayL64;  Array of long64s (64 bits per element). More...;  ; class  TArrayS;  Array of shorts (16 bits per element). More...;  ; class  TBits;  Container of bits. More...;  ; class  TBtree;  B-tree class. More...;  ; class  TClassTable;  This class registers for all classes their name, id and dictionary function in a hash table. More...;  ; class  TClonesArray;  An array of clone (identical) objects. More...;  ; class  TCollection;  Collection abstract base class. More...;  ; class  THashList;  THashList implements a hybrid collection class consisting of a hash table and a list to store TObject's. More...;  ; class  THashTable;  THashTable implements a hash table to store TObject's. More...;  ; class  TIterator;  Iterator abstract base class. More...;  ; class  TList;  A doubly linked list. More...;  ; class  TMap;  TMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries). More...;  ; class  TObjArray;  An array of TObjects. More...;  ; class  TObjectTable;  This class registers all instances of TObject and its derived classes in a hash table. More...;  ; class  TOrdCollection;  Ordered collection. More...;  ; class  TRefArray;  An array of references to TObjects. More...;  ; class  TRefTable;  A TRefTable maintains the association between a referenced object and the parent object supporting this referenced object. More...;  ; class  ROOT::TSeq< T >;  A pseudo container class which is a generator of indices. More...;  ; class  TSeqCollection;  Sequenceable collection abstract base class. More...;  ; class  TSortedList;  A sorted doubly linked list. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Containers.html:2482,efficient,efficient,2482,doc/master/group__Containers.html,https://root.cern,https://root.cern/doc/master/group__Containers.html,1,['efficient'],['efficient']
Energy Efficiency," CAlgebraicSumType< vec, gen >;  CAlgebraicSumType< vec, sym >;  CAnalyticalGradientCalculator;  CBasicFunctionGradient;  ►CBasicFunctionMinimumResult of the minimization; both internal and external (MnUserParameterState) representation available For the parameters at the Minimum ;  CMnAboveMaxEdm;  CMnReachedCallLimit;  ►CBasicMinimumErrorInternal Class containing the error information on the estimated minimum : Error matrix + dcovar + additional flags for quality and validity checks ;  CMnHesseFailed;  CMnInvertFailed;  CMnMadePosDef;  CMnNotPosDef;  CBasicMinimumParameters;  CBasicMinimumSeed;  CBasicMinimumState;  CBFGSErrorUpdatorUpdate of the covariance matrix for the Variable Metric minimizer (MIGRAD) ;  CBFGSMinimizerType;  CCombinedMinimizerCombined minimizer: combination of Migrad and Simplex ;  CCombinedMinimumBuilder;  CContoursError;  CDavidonErrorUpdatorUpdate of the covariance matrix for the Variable Metric minimizer (MIGRAD) ;  CFCNAdapterTemplate wrapped class for adapting to FCNBase signature ;  CFCNBaseInterface (abstract class) defining the function to be minimized, which has to be implemented by the user ;  CFCNGradAdapterTemplate wrapped class for adapting to FCNBase signature a IGradFunction ;  CFCNGradientBaseExtension of the FCNBase for providing the analytical Gradient of the function ;  CFumiliBuilderBuilds the FunctionMinimum using the Fumili method ;  CFumiliChi2FCNExtension of the FCNBase for the Fumili method ;  CFumiliErrorUpdatorIn the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives ;  CFumiliFCNAdapterTemplate wrapped class for adapting to FumiliFCNBase signature ;  CFumiliFCNBaseExtension of the FCNBase for the Fumili method ;  CFumiliGradientCalculator;  CFumiliMaximumLikelihoodFCNExtension of the FCNBase for the Fumili method ;  CFumiliMinimizerInstantiates the seed generator ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:62895,adapt,adapting,62895,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,3,['adapt'],['adapting']
Energy Efficiency," CGaussIntegratorUser class for performing function integration ;  CGaussLegendreIntegratorUser class for performing function integration ;  CGenAlgoOptionsClass implementing generic options for a numerical algorithm Just store the options in a map of string-value pairs ;  CGeneticMinimizerGeneticMinimizer ;  CGeneticMinimizerParameters;  CGenVector_exception;  CGlobalCoordinateSystemTagTag for identifying vectors based on a global coordinate system ;  CGoFTest;  CGradFunctorGradFunctor class for Multidimensional gradient functions ;  CGradFunctor1DGradFunctor1D class for one-dimensional gradient functions ;  CGSL1DMinimizerWrapperWrapper class for gsl_min_fminimizer structure ;  CGSLChebSeriesWrapper class for C struct gsl_cheb_series ;  CGSLDerivatorClass for computing numerical derivative of a function based on the GSL numerical algorithm This class is implemented using the numerical derivatives algorithms provided by GSL (see GSL Online Manual ) ;  CGSLFunctionAdapterClass for adapting any C++ functor class to C function pointers used by GSL ;  CGSLFunctionDerivWrapperClass to wrap a gsl_function_fdf (with derivatives) ;  CGSLFunctionWrapperWrapper class to the gsl_function C structure ;  CGSLIntegrationWorkspace;  CGSLIntegratorClass for performing numerical integration of a function in one dimension ;  CGSLInterpolatorInterpolation class based on GSL interpolation functions ;  CGSLMCIntegrationWorkspace;  CGSLMCIntegrator;  CGSLMinimizerGSLMinimizer class ;  CGSLMinimizer1DMinimizer for arbitrary one dimensional functions ;  CGSLMiserIntegrationWorkspaceWorkspace for MISER ;  CGSLMonteFunctionAdapter;  CGSLMonteFunctionWrapperWrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm ;  CGSLMultiFitGSLMultiFit, internal class for implementing GSL non linear least square GSL fitting ;  CGSLMultiFitFunctionAdapterClass for adapting a C++ functor class to C function pointers used by GSL MultiFit Algorithm The templ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:30766,adapt,adapting,30766,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,4,['adapt'],['adapting']
Energy Efficiency," CObjBuildConfig;  CObjSplitRule;  CSimWSIFace;  CSplitRule;  CRooSpHarmonicImplementation of the so-called real spherical harmonics, using the orthonormal normalization, which are related to spherical harmonics as: ;  CRooStepFunctionThe Step Function is a binned function whose parameters are the heights of each bin ;  CRooStreamParser;  CRooStringVarRooStringVar implements a string values RooAbsArg ;  CRooStudyManagerRooStudyManager is a utility class to manage studies that consist of repeated applications of generate-and-fit operations on a workspace ;  CRooStudyPackageRooStudyPackage is a utility class to manage studies that consist of repeated applications of generate-and-fit operations on a workspace ;  CRooSuperCategoryRooSuperCategory consolidates several RooAbsCategoryLValue objects into a single category ;  CRooTableRooTable is the abstract interface for table objects ;  CROOTApplicationDelegate;  CRooTFnBinding;  CRooTFnPdfBinding;  CRooTFoamBindingLightweight interface adaptor that binds a RooAbsPdf to TFOAM ;  CRooThreshEntryClass RooThreshEntry is a utility class for RooThresholdCategory ;  CRooThresholdCategoryClass RooThresholdCategory provides a real-to-category mapping defined by a series of thresholds ;  CRooTMathReg;  CRooTObjWrapRooInt is a minimal implementation of a TNamed holding a TObject ;  CROOTOpenGLView;  CRooTraceClass RooTrace controls the memory tracing hooks in all RooFit objects ;  CRooTreeDataRooTreeData is the abstract base class for data collection that use a TTree as internal storage mechanism ;  CRooTreeDataStoreRooTreeDataStore is the abstract base class for data collection that use a TTree as internal storage mechanism ;  CRooTruthModelRooTruthModel is an implementation of RooResolution model that provides a delta-function resolution model The truth model supports all basis functions because it evaluates each basis function as ; as a RooFormulaVar ;  CRooUnblindCPAsymVarImplementation of BlindTools' CP asymmetry blinding meth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:129557,adapt,adaptor,129557,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['adapt'],['adaptor']
Energy Efficiency," CRooMapCatEntry;  ►CRooMappedCategory;  CEntry;  CRooMath;  CRooMathCoreReg;  CRooMathMoreReg;  CRooMCIntegratorRooMCIntegrator implements an adaptive multi-dimensional Monte Carlo numerical integration, following the VEGAS algorithm originally described in G ;  CRooMCStudyRooMCStudy is a help class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fitting a PDF to multiple toy Monte Carlo sets generated from the same PDF or another PDF ;  CRooMinimizerRooMinimizer is a wrapper class around ROOT::Fit:Fitter that provides a seamless interface between the minimizer functionality and the native RooFit interface ;  CRooMinimizerFcn;  CRooMinuitRooMinuit is a wrapper class around TFitter/TMinuit that provides a seamless interface between the MINUIT functionality and the native RooFit interface ;  CRooMomentRooMoment represents the first, second, or third order derivative of any RooAbsReal as calculated (numerically) by the MathCore Richardson derivator class ;  ►CRooMomentMorph;  CCacheElem;  ►CRooMomentMorphFunc;  CCacheElem;  ►CRooMomentMorphFuncND;  CCacheElem;  CDigits;  CGrid2;  ►CRooMomentMorphND;  CCacheElem;  CGrid;  CRooMPSentinelRooMPSentinel is a singleton class that keeps track of all parellel execution processes for goodness-of-fit calculations ;  ►CRooMsgServiceSingleton class that organizes informational, debugging, warning and errors messages generated by the RooFit core code ;  CStreamConfig;  CRooMultiBinomialRooMultiBinomial is an efficiency function which makes all combinations of efficiencies given as input different efficiency functions for different categories ;  CRooMultiCategoryRooMultiCategory consolidates several RooAbsCategory objects into a single category ;  CRooMultiCatIterRooMultiCatIter iterators over all state permutations of a list of categories ;  CRooMultiGenFunctionLightweight interface adaptor that exports a RooAbsReal as a ROOT::Math::IMultiGenFunction ;  ►CRooMultiVarGaussianMultivariate Gaussian p.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:112615,adapt,adaptor,112615,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,3,['adapt'],['adaptor']
Energy Efficiency," Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; void DeclareOptions ();  declare SA options. ;  . Private Attributes; Double_t fAdaptiveSpeed;  how fast temperature change in adaptive (in adaptive two variables describe the change of temperature, but fAdaptiveSpeed should be 1.0 and its not recommended to change it) ;  ; Double_t fEps;  relative required FCN accuracy at minimum ;  ; Double_t fInitialTemperature;  initial temperature (depends on FCN) ;  ; TString fKernelTemperatureS;  string just to set fKernelTemperature ;  ; Int_t fMaxCalls;  max number of FCN calls ;  ; Double_t fMinTemperature;  minimum temperature before SA quit ;  ; Double_t fTemperatureAdaptiveStep;  used to calculate InitialTemperature if fUseDefaultTemperature ;  ; Double_t fTemperatureScale;  how fast temperature change ;  ; Bool_t fUseDefaultScale;  if TRUE, SA calculates its own TemperatureScale ;  ; Bool_t fUseDefaultTemperature;  if TRUE, SA calculates its own InitialTemperature (MinTemperautre) ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1SimulatedAnnealingFitter.html:13701,adapt,adaptive,13701,doc/master/classTMVA_1_1SimulatedAnnealingFitter.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1SimulatedAnnealingFitter.html,2,['adapt'],['adaptive']
Energy Efficiency," Reset the merge progress notificator. ;  ; void ResetMergers ();  ; Int_t RestoreActiveList ();  Restore saved list of active workers. ;  ; void SaveActiveList ();  Save current list of active workers. ;  ; Int_t SendCommand (const char *cmd, ESlaves list=kActive);  Send command to be executed on the PROOF master and/or slaves. ;  ; Int_t SendCurrentState (ESlaves list=kActive);  Transfer the current state of the master to the active slave servers. ;  ; Int_t SendCurrentState (TList *list);  Transfer the current state of the master to the active slave servers. ;  ; Int_t SendGroupView ();  Send to all active slaves servers the current slave group size and their unique id. ;  ; Int_t SendInitialState ();  Transfer the initial (i.e. ;  ; Int_t SendObject (const TObject *obj, ESlaves list=kActive);  Send object to master or slave servers. ;  ; Int_t SendPrint (Option_t *option="""");  Send print command to master server. ;  ; void SetMonitor (TMonitor *mon=0, Bool_t on=kTRUE);  Activate (on == TRUE) or deactivate (on == FALSE) all sockets monitored by 'mon'. ;  ; Int_t SetParallelSilent (Int_t nodes, Bool_t random=kFALSE);  Tell PROOF how many slaves to use in parallel. ;  ; void SetRunStatus (ERunStatus rst);  ; void TerminateWorker (const char *ord);  Ask an active worker 'ord' to terminate, i.e. to shutdown. ;  ; void TerminateWorker (TSlave *wrk);  Ask an active worker 'wrk' to terminate, i.e. to shutdown. ;  ; Int_t UnloadPackage (const char *package);  Unload specified package. ;  ; Int_t UnloadPackages ();  Unload all packages. ;  . Static Private Member Functions; static TList * GetDataSetSrvMaps (const TString &srvmaps);  . Private Attributes; TMonitor * fActiveMonitor;  ; TList * fActiveSlaves;  ; TString fActiveSlavesSaved;  ; TMonitor * fAllUniqueMonitor;  ; TList * fAllUniqueSlaves;  ; Long64_t fBytesRead;  ; TList * fChains;  ; Int_t fCheckFileStatus;  ; std::recursive_mutex fCloseMutex;  ; Float_t fCpuTime;  ; TMonitor * fCurrentMonitor;  ; Int_t fDrawQue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:53329,monitor,monitored,53329,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['monitor'],['monitored']
Energy Efficiency," RooHistPdf (const char *name, const char *title, const RooArgList &pdfObs, const RooArgList &histObs, const RooDataHist &dhist, Int_t intOrder=0);  Constructor from a RooDataHist. ;  ;  RooHistPdf (const char *name, const char *title, const RooArgList &pdfObs, const RooArgList &histObs, std::unique_ptr< RooDataHist > dhist, int intOrder=0);  ;  RooHistPdf (const char *name, const char *title, const RooArgSet &vars, const RooDataHist &dhist, Int_t intOrder=0);  Constructor from a RooDataHist. ;  ;  RooHistPdf (const char *name, const char *title, const RooArgSet &vars, std::unique_ptr< RooDataHist > dhist, int intOrder=0);  ;  RooHistPdf (const RooHistPdf &other, const char *name=nullptr);  Copy constructor. ;  ; double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const override;  Return integral identified by 'code'. ;  ; std::list< double > * binBoundaries (RooAbsRealLValue &, double, double) const override;  Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; std::string buildCallToAnalyticIntegral (int code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines the analytical integral translation for the class. ;  ; TObject * clone (const char *newname) const override;  ; RooDataHist * cloneAndOwnDataHist (const char *newname="""");  Replaces underlying RooDataHist with a clone, which is now owned, and returns the clone. ;  ; RooDataHist & dataHist ();  ; const RooDataHist & dataHist () const;  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &analVars, const char *rangeName=nullptr) const override;  Determine integration scenario. ;  ; bool get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:1773,efficient,efficiently,1773,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,1,['efficient'],['efficiently']
Energy Efficiency," Static Protected Member Functions inherited from TEveElement; static const char * ToString (Bool_t b);  Convert Bool_t to string - kTRUE or kFALSE. ;  . #include <TEveJetCone.h>. Inheritance diagram for TEveJetCone:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TEveJetCone() [1/2]. TEveJetCone::TEveJetCone ; (; const TEveJetCone & ; ). private . ◆ TEveJetCone() [2/2]. TEveJetCone::TEveJetCone ; (; const Text_t * ; n = ""TEveJetCone"", . const Text_t * ; t = """" . ). Constructor. ; Definition at line 51 of file TEveJetCone.cxx. ◆ ~TEveJetCone(). TEveJetCone::~TEveJetCone ; (; ). inlineoverride . Definition at line 49 of file TEveJetCone.h. Member Function Documentation. ◆ AddCone(). Int_t TEveJetCone::AddCone ; (; Float_t ; eta, . Float_t ; phi, . Float_t ; cone_r, . Float_t ; length = 0 . ). Add jet cone. ; parameters are :; (eta,phi) : of the center/leading particle; cone_r : cone radius in eta-phi space; length : length of the cone; if cylinder is set and length is adapted to cylinder.; if length is given, it will be used as scalar factor. if cylinder is not set, length is used as length of the cone Return 0 on success. . Definition at line 92 of file TEveJetCone.cxx. ◆ AddEllipticCone(). Int_t TEveJetCone::AddEllipticCone ; (; Float_t ; eta, . Float_t ; phi, . Float_t ; reta, . Float_t ; rphi, . Float_t ; length = 0 . ). Add jet cone. ; parameters are :; (eta,phi) : of the center/leading particle; (reta, rphi) : radius of cone in eta-phi space; length : length of the cone; if cylinder is set and length is adapted to cylinder.; if length is given, it will be used as scalar factor. if cylinder is not set, length is used as length of the cone Returns 0 on success. . Definition at line 108 of file TEveJetCone.cxx. ◆ CalcBaseVec() [1/2]. TEveVector TEveJetCone::CalcBaseVec ; (; Float_t ; alpha); const. protected . Returns point on the base of the cone with internal angle alpha: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveJetCone.html:40583,adapt,adapted,40583,doc/master/classTEveJetCone.html,https://root.cern,https://root.cern/doc/master/classTEveJetCone.html,1,['adapt'],['adapted']
Energy Efficiency," fCharacterUpX. Float_t TGX11::fCharacterUpX. protected . Character Up vector along X. ; Definition at line 136 of file TGX11.h. ◆ fCharacterUpY. Float_t TGX11::fCharacterUpY. protected . Character Up vector along Y. ; Definition at line 137 of file TGX11.h. ◆ fColormap. Colormap TGX11::fColormap. protected . Default colormap, 0 if b/w. ; Definition at line 129 of file TGX11.h. ◆ fColors. TExMap* TGX11::fColors. private . Hash list of colors. ; Definition at line 85 of file TGX11.h. ◆ fCursors. Cursor TGX11::fCursors[kNumCursors]. private . List of cursors. ; Definition at line 86 of file TGX11.h. ◆ fDepth. Int_t TGX11::fDepth. protected . Number of color planes. ; Definition at line 139 of file TGX11.h. ◆ fDisplay. void* TGX11::fDisplay. protected . Pointer to display. ; Definition at line 125 of file TGX11.h. ◆ fGreenDiv. Int_t TGX11::fGreenDiv. protected . Green value divider. ; Definition at line 141 of file TGX11.h. ◆ fGreenShift. Int_t TGX11::fGreenShift. protected . Bits to left shift green. ; Definition at line 144 of file TGX11.h. ◆ fHasTTFonts. Bool_t TGX11::fHasTTFonts. protected . True when TrueType fonts are used. ; Definition at line 146 of file TGX11.h. ◆ fHasXft. Bool_t TGX11::fHasXft. protected . True when XftFonts are used. ; Definition at line 147 of file TGX11.h. ◆ fMaxNumberOfWindows. Int_t TGX11::fMaxNumberOfWindows. private . Maximum number of windows. ; Definition at line 83 of file TGX11.h. ◆ fRedDiv. Int_t TGX11::fRedDiv. protected . Red value divider, -1 if no TrueColor visual. ; Definition at line 140 of file TGX11.h. ◆ fRedShift. Int_t TGX11::fRedShift. protected . Bits to left shift red, -1 if no TrueColor visual. ; Definition at line 143 of file TGX11.h. ◆ fRootWin. Drawable TGX11::fRootWin. protected . Root window used as parent of all windows. ; Definition at line 127 of file TGX11.h. ◆ fScreenNumber. Int_t TGX11::fScreenNumber. protected . Screen number. ; Definition at line 132 of file TGX11.h. ◆ fTextAlign. Int_t TGX11::fTextAlign",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:124340,green,green,124340,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,1,['green'],['green']
Energy Efficiency," fNbins;  ; Int_t fNbinsH;  ; Int_t fNbinsMVAoutput;  ; Ranking * fRanking;  ; std::vector< Float_t > * fRegressionReturnVal;  ; Results * fResults;  ; UInt_t fSignalClass;  ; DataSet * fTmpData = nullptr;  temporary event when testing on a different DataSet than the own one ;  ; const Event * fTmpEvent;  ;  Protected Attributes inherited from TMVA::Configurable; MsgLogger * fLogger;  ! message logger ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Private Types; enum  EKernelEstimator { ;   kBox = 0; , kSphere; , kTeepee; , kGauss; , ;   kSinc3; , kSinc5; , kSinc7; , kSinc9; , ;   kSinc11; , kLanczos2; , kLanczos3; , kLanczos5; , ;   kLanczos8; , kTrim. };  ; enum  EVolumeRangeMode { ;   kUnsupported = 0; , kMinMax; , kRMS; , kAdaptive; , ;   kUnscaled; , kkNN. };  . Private Member Functions; void CalcAverages ();  compute also average RMS values required for adaptive Gaussian ;  ; void CreateBinarySearchTree (Types::ETreeType type);  create binary search trees for signal and background ;  ; Double_t CRScalc (const Event &);  ; void DeclareOptions ();  define the options (their key words) that can be set in the option string. ;  ; Float_t GetError (Float_t countS, Float_t countB, Float_t sumW2S, Float_t sumW2B) const;  statistical error estimate for RS estimator ;  ; void GetSample (const Event &e, std::vector< const BinarySearchTreeNode * > &events, Volume *volume);  ; void Init (void);  default initialisation routine called by all constructors ;  ; void ProcessOptions ();  process the options specified by the user ;  ; void RRScalc (const Event &, std::vector< Float_t > *count);  ; void SetVolumeElement (void);  defines volume dimensions ;  ; void UpdateThis ();  update static this pointer ;  . Static Private Member Functions; static MethodPDERS *& GetMethodPDERSThreadLocal ();  . Private Attributes; std::vector< Float_t > fAverageRMS;  average RMS of signal and background ;  ; BinarySearchTree * fBinaryTree;  binary tree ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html:29964,adapt,adaptive,29964,doc/master/classTMVA_1_1MethodPDERS.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPDERS.html,1,['adapt'],['adaptive']
Energy Efficiency," operator= (const TCudaMatrix &)=default;  ; TCudaMatrix & operator= (TCudaMatrix &&)=default;  ; void Print () const;  ; void SetComputeStream (cudaStream_t stream);  ; void Synchronize (const TCudaMatrix &) const;  Blocking synchronization with the associated compute stream, if it's not the default stream. ;  ; void Zero ();  . Static Public Member Functions; static curandState_t * GetCurandStatesPointer ();  ; static AFloat GetDeviceReturn ();  Transfer the value in the device return buffer to the host. ;  ; static AFloat * GetDeviceReturnPointer ();  Return device pointer to the device return buffer. ;  ; static size_t GetNDim ();  ; static AFloat * GetOnes ();  ; static void ResetDeviceReturn (AFloat value=0.0);  Set the return buffer on the device to the specified value. ;  . Static Public Attributes; static Bool_t gInitializeCurand = kFALSE;  . Private Member Functions; void InitializeCuda ();  Initializes all shared devices resource and makes sure that a sufficient number of curand states are allocated on the device and initialized as well as that the one-vector for the summation over columns has the right size. ;  ; void InitializeCurandStates ();  . Private Attributes; TCudaDeviceBuffer< AFloat > fElementBuffer;  ; size_t fNCols;  ; size_t fNRows;  . Static Private Attributes; static cublasHandle_t fCublasHandle = nullptr;  ; static curandState_t * fCurandStates = nullptr;  ; static AFloat * fDeviceReturn = nullptr;  Buffer for kernel return values. ;  ; static size_t fInstances = 0;  Current number of matrix instances. ;  ; static size_t fNCurandStates = 0;  ; static size_t fNOnes = 0;  Current length of the one vector. ;  ; static AFloat * fOnes = nullptr;  Vector used for summations of columns. ;  . #include <TMVA/DNN/Architectures/Cuda/CudaMatrix.h>; Constructor & Destructor Documentation. ◆ TCudaMatrix() [1/6]. template<typename AFloat > . TMVA::DNN::TCudaMatrix< AFloat >::TCudaMatrix. Definition at line 57 of file CudaMatrix.cu. ◆ TCudaMatrix() [2/6]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCudaMatrix.html:3450,allocate,allocated,3450,doc/master/classTMVA_1_1DNN_1_1TCudaMatrix.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCudaMatrix.html,1,['allocate'],['allocated']
Energy Efficiency,"     This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TAttBBox(); Float_t*AssertBBox(); static TClass*Class(); virtual voidComputeBBox(); Float_t*GetBBox(); Bool_tGetBBoxOK() const; virtual TClass*IsA() const; TAttBBox&operator=(const TAttBBox& tab); voidResetBBox(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidAssertBBoxExtents(Float_t epsilon = 0.005); voidBBoxCheckPoint(const Float_t* p); voidBBoxCheckPoint(Float_t x, Float_t y, Float_t z); voidBBoxClear(); voidBBoxInit(Float_t infinity = 1e6); voidBBoxZero(Float_t epsilon = 0, Float_t x = 0, Float_t y = 0, Float_t z = 0). Data Members; protected:. Float_t*fBBox! Dynamic Float_t[6] X(min,max), Y(min,max), Z(min,max). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void BBoxInit(Float_t infinity = 1e6); Allocate and prepare for incremental filling. void BBoxZero(Float_t epsilon = 0, Float_t x = 0, Float_t y = 0, Float_t z = 0); Create cube of volume (2*epsiolon)^3 at (x,y,z).; epsilon iz zero by default. void BBoxClear(); Remove BBox information. void AssertBBoxExtents(Float_t epsilon = 0.005); Assert extents of all sides of the bounding-box are at least epsilon. void BBoxCheckPoint(Float_t x, Float_t y, Float_t z). void BBoxCheckPoint(const Float_t* p). virtual ~TAttBBox(); { BBoxClear(); }. TAttBBox& operator=(const TAttBBox& tab). Bool_t GetBBoxOK() const; { return fBBox != 0; }. Float_t* GetBBox(); { return fBBox; }. Float_t* AssertBBox(); { if(fBBox == 0) ComputeBBox(); return fBBox; }. void ResetBBox(); { if(fBBox != 0) BBoxClear(); }. void ComputeBBox(). » Author: Matevz Tadel 7/4/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-12 16:37; This page has been automatically generated. For comments o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TAttBBox.html:1451,Allocate,Allocate,1451,root/html534/TAttBBox.html,https://root.cern,https://root.cern/root/html534/TAttBBox.html,1,['Allocate'],['Allocate']
Energy Efficiency, ► src;  3DConversions.cxx;  3DDistances.cxx;  AxisAngle.cxx;  AxisAngleXother.cxx;  BitReproducible.cxx;  Boost.cxx;  BoostX.cxx;  BoostY.cxx;  BoostZ.cxx;  EulerAngles.cxx;  GenVector_exception.cxx;  LorentzRotation.cxx;  Plane3D.cxx;  Quaternion.cxx;  QuaternionXaxial.cxx;  Rotation3D.cxx;  Rotation3DxAxial.cxx;  RotationZYX.cxx;  Transform3D.cxx;  Translation3D.cxx;  VectorUtil.cxx;  ► test;  coordinates3D.cxx;  coordinates4D.cxx;  CoordinateTraits.h;  rotationApplication.cxx;  RotationTraits.h;  stress2D.cxx;  stress3D.cxx;  testBoost.cxx;  testGenVector.cxx;  testIterator.cxx;  testVectorIO.cxx;  Track.h;  TrackLinkDef.h;  vectorOperation.cxx;  ► mathcore;  ► inc;  ► Fit;  BasicFCN.h;  BinData.h;  BinPoint.h;  Chi2FCN.h;  DataOptions.h;  DataRange.h;  DataVector.h;  DataVectorfwd.h;  FcnAdapter.h;  FitConfig.h;  FitResult.h;  Fitter.h;  FitUtil.h;  FitUtilParallel.h;  LogLikelihoodFCN.h;  ParameterSettings.h;  PoissonLikelihoodFCN.h;  SparseData.h;  UnBinData.h;  ► Math;  AdaptiveIntegratorMultiDim.h;  AllIntegrationTypes.h;  BasicMinimizer.h;  BrentMethods.h;  BrentMinimizer1D.h;  BrentRootFinder.h;  ChebyshevPol.h;  Delaunay2D.h;  DistFunc.h;  DistFuncMathCore.h;  DistSampler.h;  DistSamplerOptions.h;  Error.h;  Factory.h;  FitMethodFunction.h;  Functor.h;  GaussIntegrator.h;  GaussLegendreIntegrator.h;  GenAlgoOptions.h;  GoFTest.h;  IFunction.h;  IFunctionfwd.h;  IMinimizer1D.h;  Integrator.h;  IntegratorMultiDim.h;  IntegratorOptions.h;  IOptions.h;  IParamFunction.h;  IParamFunctionfwd.h;  IRootFinderMethod.h;  KDTree.h;  KDTree.icc;  Math.h;  MersenneTwisterEngine.h;  Minimizer.h;  MinimizerOptions.h;  MinimizerVariableTransformation.h;  MinimTransformFunction.h;  MinimTransformVariable.h;  MixMaxEngine.h;  MultiDimParamFunctionAdapter.h;  OneDimFunctionAdapter.h;  ParamFunctor.h;  PdfFunc.h;  PdfFuncMathCore.h;  ProbFunc.h;  ProbFuncMathCore.h;  QuantFunc.h;  QuantFuncMathCore.h;  Random.h;  RandomFunctions.h;  RichardsonDerivator.h;  RootFinder.h;  Sp,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:43232,Adapt,AdaptiveIntegratorMultiDim,43232,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['Adapt'],['AdaptiveIntegratorMultiDim']
Energy Efficiency,"“Threads”, and “PROOF: Parallel Processing”.; 1.3 Conventions Used in This Book; We tried to follow a style convention for the sake of clarity. The styles in used are described below.; To show source code in scripts or source files:; {; cout << "" Hello"" << endl;; float x = 3.;; float y = 5.;; int i = 101;; cout <<"" x = ""<<x<<"" y = ""<<y<<"" i = ""<<i<< endl;; }; To show the ROOT command line, we show the ROOT prompt without numbers. In the interactive system, the ROOT prompt has a line number (root[12]); for the sake of simplicity, the line numbers are left off.; root[] TLine l; root[] l.Print(); TLine X1=0.000000 Y1=0.000000 X2=0.000000 Y2=0.000000; Italic bold monotype font indicates a global variable, for example gDirectory.; When a variable term is used, it is shown between angled brackets. In the example below the variable term <library> can be replaced with any library in the $ROOTSYS directory: $ROOTSYS/<library>/inc.; 1.4 The Framework; ROOT is an object-oriented framework aimed at solving the data analysis challenges of high-energy physics. There are two key words in this definition, object oriented and framework. First, we explain what we mean by a framework and then why it is an object-oriented framework.; 1.4.1 What Is a Framework?; Programming inside a framework is a little like living in a city. Plumbing, electricity, telephone, and transportation are services provided by the city. In your house, you have interfaces to the services such as light switches, electrical outlets, and telephones. The details, for example, the routing algorithm of the phone switching system, are transparent to you as the user. You do not care; you are only interested in using the phone to communicate with your collaborators to solve your domain specific problems.; Programming outside of a framework may be compared to living in the country. In order to have transportation and water, you will have to build a road and dig a well. To have services like telephone and electricity you w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:10385,energy,energy,10385,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['energy'],['energy']
Energy Efficiency,"←. TApplication; ←. PyROOT::TPyROOTApplication. TApplicationRemote. TApplicationServer. TGApplication. TProofServ; ←. TProofServLite. TXProofServ. TQApplication. TRint.  [more...]. Function documentation; TString CompressName(const char* method_name); Removes ""const"" words and blanks from full (with prototype); method name and resolve any typedefs in the method signature.; If a null or empty string is passed in, an empty string; is returned. Example: CompressName("" Draw(const char *, const char *,; Option_t * , Int_t , Int_t)"");; returns the string ""Draw(char*,char*,char*,int,int)"". Int_t CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Checking of consitency of sender/receiver methods/arguments.; Returns -1 on error, otherwise number or arguments of signal function.; Static method. TQObject(); TQObject Constructor.; Comment:; - In order to minimize memory allocation fListOfSignals and; fListOfConnections are allocated only if it is neccesary; - When fListOfSignals/fListOfConnections are empty they will; be deleted. ~TQObject(); TQObject Destructor.; - delete all connections and signal list. TList * GetListOfClassSignals() const; Returns pointer to list of signals of this class. void CollectClassSignalLists(TList& list, TClass* cls); Collect class signal lists from class cls and all its; base-classes. The recursive traversal is not performed for classes not; deriving from TQClass. void HighPriority(const char* signal_name, const char* slot_name = 0); 1. If slot_name = 0 => makes signal defined by the signal_name; to be the first in the fListOfSignals, this decreases; the time for lookup.; 2. If slot_name != 0 => makes slot defined by the slot_name; to be executed first when signal_name is emitted.; Signal name is not compressed. void LowPriority(const char* signal_name, const char* slot_name = 0); 1. If slot_name = 0 => makes signal defined by the signal_name; to be the last in the fListOfSignals",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQObject.html:5778,allocate,allocated,5778,root/html602/TQObject.html,https://root.cern,https://root.cern/root/html602/TQObject.html,4,['allocate'],['allocated']
Energy Efficiency,"←; TNamed. TAttLine. TAttFill. TAttText. TAttMarker. ←; TVirtualX. ←. TGQt. TGX11; ←. TGX11TTF. Function documentation; TVirtualX(const char* name, const char* title); Ctor of ABC. TVirtualX *& Instance(); Returns gVirtualX global. void GetWindowAttributes(Window_t id, WindowAttributes_t& attr); The WindowAttributes_t structure is set to default. Bool_t ParseColor(Colormap_t cmap, const char* cname, ColorStruct_t& color); Looks up the string name of a color ""cname"" with respect to the screen; associated with the specified colormap. It returns the exact color value.; If the color name is not in the Host Portable Character Encoding,; the result is implementation dependent. cmap - the colormap; cname - the color name string; use of uppercase or lowercase; does not matter; color - returns the exact color value for later use. The ColorStruct_t structure is set to default. Let system think we; could parse color. Bool_t AllocColor(Colormap_t cmap, ColorStruct_t& color); Allocates a read-only colormap entry corresponding to the closest RGB; value supported by the hardware. If no cell could be allocated it; returns kFALSE, otherwise kTRUE. The pixel value is set to default. Let system think we could allocate; color. cmap - the colormap; color - specifies and returns the values actually used in the cmap. void QueryColor(Colormap_t cmap, ColorStruct_t& color); Returns the current RGB value for the pixel in the ""color"" structure. The color components are set to default. cmap - the colormap; color - specifies and returns the RGB values for the pixel specified; in the structure. void NextEvent(Event_t& event); The ""event"" is set to default event.; This method however, should never be called. void GetPasteBuffer(Window_t id, Atom_t atom, TString& text, Int_t& nchar, Bool_t del); Gets contents of the paste buffer ""atom"" into the string ""text"".; (nchar = number of characters) If ""del"" is true deletes the paste; buffer afterwards. Bool_t Init(void* display = 0); Initializes the X sys",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualX.html:24071,Allocate,Allocates,24071,root/html602/TVirtualX.html,https://root.cern,https://root.cern/root/html602/TVirtualX.html,2,['Allocate'],['Allocates']
Energy Efficiency,"◆ MethodCFMlpANN() [1/2]. TMVA::MethodCFMlpANN::MethodCFMlpANN ; (; const TString & ; jobName, . const TString & ; methodTitle, . DataSetInfo & ; theData, . const TString & ; theOption = ""3000:N-1:N-2"" . ). standard constructor ; option string: ""n_training_cycles:n_hidden_layers""; default is: n_training_cycles = 5000, n_layers = 4. note that the number of hidden layers in the NN is: n_hidden_layers = n_layers - 2; since there is one input and one output layer. The number of nodes (neurons) is predefined to be:; n_nodes[i] = nvars + 1 - i (where i=1..n_layers); with nvars being the number of variables used in the NN. Hence, the default case is: n_neurons(layer 1 (input)) : nvars; n_neurons(layer 2 (hidden)): nvars-1; n_neurons(layer 3 (hidden)): nvars-1; n_neurons(layer 4 (out)) : 2; This artificial neural network usually needs a relatively large number of cycles to converge (8000 and more). Overtraining can be efficiently tested by comparing the signal and background output of the NN for the events that were used for training and an independent data sample (with equal properties). If the separation performance is significantly better for the training sample, the NN interprets statistical effects, and is hence overtrained. In this case, the number of cycles should be reduced, or the size of the training sample increased. ; Definition at line 130 of file MethodCFMlpANN.cxx. ◆ MethodCFMlpANN() [2/2]. TMVA::MethodCFMlpANN::MethodCFMlpANN ; (; DataSetInfo & ; theData, . const TString & ; theWeightFile . ). constructor from weight file ; Definition at line 149 of file MethodCFMlpANN.cxx. ◆ ~MethodCFMlpANN(). TMVA::MethodCFMlpANN::~MethodCFMlpANN ; (; void ; ). virtual . destructor ; Definition at line 269 of file MethodCFMlpANN.cxx. Member Function Documentation. ◆ AddWeightsXMLTo(). void TMVA::MethodCFMlpANN::AddWeightsXMLTo ; (; void * ; parent); const. virtual . write weights to xml file ; Implements TMVA::MethodBase.; Definition at line 537 of file MethodCFMlpANN.cxx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCFMlpANN.html:35386,efficient,efficiently,35386,doc/master/classTMVA_1_1MethodCFMlpANN.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCFMlpANN.html,1,['efficient'],['efficiently']
Energy Efficiency,◆ SetTestSignalEfficiency(). void TMVA::MethodCuts::SetTestSignalEfficiency ; (; Double_t ; effS). inline . Definition at line 116 of file MethodCuts.h. ◆ Streamer(). virtual void TMVA::MethodCuts::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::MethodBase. ◆ StreamerNVirtual(). void TMVA::MethodCuts::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 238 of file MethodCuts.h. ◆ TestClassification(). void TMVA::MethodCuts::TestClassification ; (; ). virtual . nothing to test ; Reimplemented from TMVA::MethodBase.; Definition at line 827 of file MethodCuts.cxx. ◆ Train(). void TMVA::MethodCuts::Train ; (; void ; ). virtual . training method: here the cuts are optimised for the training sample ; Implements TMVA::MethodBase.; Definition at line 578 of file MethodCuts.cxx. ◆ WriteMonitoringHistosToFile(). void TMVA::MethodCuts::WriteMonitoringHistosToFile ; (; void ; ); const. virtual . write histograms and PDFs to file for monitoring purposes ; Reimplemented from TMVA::MethodBase.; Definition at line 1411 of file MethodCuts.cxx. Member Data Documentation. ◆ fAllVarsI. TString* TMVA::MethodCuts::fAllVarsI. private . what to do with variables ; Definition at line 188 of file MethodCuts.h. ◆ fBinaryTreeB. BinarySearchTree* TMVA::MethodCuts::fBinaryTreeB. private . Definition at line 181 of file MethodCuts.h. ◆ fBinaryTreeS. BinarySearchTree* TMVA::MethodCuts::fBinaryTreeS. private . Definition at line 180 of file MethodCuts.h. ◆ fCutMax. Double_t** TMVA::MethodCuts::fCutMax. private . maximum requirement ; Definition at line 185 of file MethodCuts.h. ◆ fCutMin. Double_t** TMVA::MethodCuts::fCutMin. private . minimum requirement ; Definition at line 184 of file MethodCuts.h. ◆ fCutRange. std::vector<Interval*> TMVA::MethodCuts::fCutRange. private . allowed ranges for cut optimisation ; Definition at line 177 of file MethodCuts.h. ◆ fCutRangeMax. Double_t* TMVA::MethodCuts::fCutRangeMax. private . maximum of allowed cu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html:47948,monitor,monitoring,47948,doc/master/classTMVA_1_1MethodCuts.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html,1,['monitor'],['monitoring']
Energy Efficiency,"� kTransformCos. ����������������������� kTransformSin. ����������������������� kTransformFourier. ����������������������� kTransformHartley. ����������� Mixed transforms:; ����������������������� kTransformFourierWalsh. ����������������������� kTransformFourierHaar. ����������������������� kTransformWalshHaar. ����������������������� kTransformCosWalsh. ����������������������� kTransformCosHaar. ����������������������� kTransformSinWalsh. ����������������������� kTransformSinHaar. fDirection-direction-transform; direction (forward, inverse); ����������������������� kTransformForward. ����������������������� kTransformInverse. fDegree-applies; only for mixed transforms [2], [3], [4]. ; ����������������; �Allowed range� . ; References:; [1] C.V. Hampton, B. Lian, Wm. C.; McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray; spectroscopy. NIM A353 (1994) 280-284. ; [2] Morh�č M., Matou�ek V.,; New adaptive Cosine-Walsh� transform and its application to nuclear data; compression, IEEE Transactions on Signal Processing 48 (2000) 2693.� ; [3] Morh�č M., Matou�ek V.,; Data compression using new fast adaptive Cosine-Haar transforms, Digital Signal; Processing 8 (1998) 63. ; [4] Morh�č M., Matou�ek V.:; Multidimensional nuclear data compression using fast adaptive Walsh-Haar; transform. Acta Physica Slovaca 51 (2001) 307. ;  ; Example 1 � script Transform2.c:. Fig. 1 Original two-dimensional noisy spectrum. Fig. 2 Transformed spectrum; from Fig. 1 using Cosine transform. Energy of the trasnsformed data is; concentrated around the beginning of the coordinate system;  ; Script:; // Example to illustrate; Transform function (class TSpectrumTransform2).; // To execute this example,; do; // root > .x Transform2.C; void Transform2() {; �� Int_t i, j;; �� Int_t nbinsx =; 256;; �� Int_t nbinsy =; 256;�� ; �� Int_t xmin� = 0;; �� Int_t xmax� =; nbinsx;; �� Int_t ymin� = 0;; �� Int_t ymax� = nbinsy;; �� Double_t ** source = new Double_t *[nbinsx];�� ; �� Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2Transform.html:17416,adapt,adaptive,17416,root/html602/TSpectrum2Transform.html,https://root.cern,https://root.cern/root/html602/TSpectrum2Transform.html,4,['adapt'],['adaptive']
Energy Efficiency,"� kTransformCos. ����������������������� kTransformSin. ����������������������� kTransformFourier. ����������������������� kTransformHartley. ����������� Mixed transforms:; ����������������������� kTransformFourierWalsh. ����������������������� kTransformFourierHaar. ����������������������� kTransformWalshHaar. ����������������������� kTransformCosWalsh. ����������������������� kTransformCosHaar. ����������������������� kTransformSinWalsh. ����������������������� kTransformSinHaar. fDirection-direction-transform; direction (forward, inverse); ����������������������� kTransformForward. ����������������������� kTransformInverse. fDegree-applies; only for mixed transforms [2], [3], [4]. ; ����������������; �Allowed range� . ; References:; [1] C.V. Hampton, B. Lian, Wm. C.; McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray; spectroscopy. NIM A353 (1994) 280-284. ; [2] Morh�č M., Matou�ek V.,; New adaptive Cosine-Walsh� transform and its application to nuclear data; compression, IEEE Transactions on Signal Processing 48 (2000) 2693.� ; [3] Morh�č M., Matou�ek V.,; Data compression using new fast adaptive Cosine-Haar transforms, Digital Signal; Processing 8 (1998) 63. ; [4] Morh�č M., Matou�ek V.:; Multidimensional nuclear data compression using fast adaptive Walsh-Haar; transform. Acta Physica Slovaca 51 (2001) 307. ;  ; Example 1 � script Transform2.c:. Fig. 1 Original two-dimensional noisy spectrum. Fig. 2 Transformed spectrum; from Fig. 1 using Cosine transform. Energy of the trasnsformed data is; concentrated around the beginning of the coordinate system;  ; Script:; // Example to illustrate; Transform function (class TSpectrumTransform2).; // To execute this example,; do; // root > .x Transform2.C; void Transform2() {; �� Int_t i, j;; �� Int_t nbinsx =; 256;; �� Int_t nbinsy =; 256;�� ; �� Int_t xmin� = 0;; �� Int_t xmax� =; nbinsx;; �� Int_t ymin� = 0;; �� Int_t ymax� = nbinsy;; �� Float_t ** source = new float *[nbinsx];�� ; �� Float_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Transform.html:16231,adapt,adaptive,16231,root/html528/TSpectrum2Transform.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Transform.html,6,['adapt'],['adaptive']
Energy Efficiency,"�� kTransformCos. ����������������������� kTransformSin. ����������������������� kTransformFourier. ����������������������� kTransformHartey. ����������� Mixed transforms:; ����������������������� kTransformFourierWalsh. ����������������������� kTransformFourierHaar. ����������������������� kTransformWalshHaar. ����������������������� kTransformCosWalsh. ����������������������� kTransformCosHaar. ����������������������� kTransformSinWalsh. ����������������������� kTransformSinHaar. fDirection-direction-transform; direction (forward, inverse); ����������������������� kTransformForward. ����������������������� kTransformInverse. fDegree-applies; only for mixed transforms [2], [3], [4]. ; ����������������; �Allowed range� . ; References:; [1] C.V. Hampton, B. Lian, Wm. C.; McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray; spectroscopy. NIM A353 (1994) 280-284. ; [2] Morh�č M., Matou�ek V.,; New adaptive Cosine-Walsh� transform and its application to nuclear data; compression, IEEE Transactions on Signal Processing 48 (2000) 2693.� ; [3] Morh�č M., Matou�ek V.,; Data compression using new fast adaptive Cosine-Haar transforms, Digital Signal; Processing 8 (1998) 63. ; [4] Morh�č M., Matou�ek V.:; Multidimensional nuclear data compression using fast adaptive Walsh-Haar; transform. Acta Physica Slovaca 51 (2001) 307. ;  ; Example �� script Transform.c:. Fig. 1 Original gamma-ray spectrum.  ; Fig. 2 Transformed spectrum from Fig. 1 using Cosine; transform;  ; Script:; // Example to illustrate; Transform function (class TSpectrumTransform).; // To execute this example,; do; // root > .x Transform.C; �� ; #include <TSpectrum>; #include; <TSpectrumTransform>;  ; void Transform() {; �� Int_t i;; �� Double_t nbins =; 4096;; �� Double_t xmin� =; 0;; �� Double_t xmax� =; (Double_t)nbins;; �� Double_t * source = new Double_t[nbins];; �� Double_t * dest = new; Double_t[nbins];�� ; �� TH1F *h = new TH1F(""h"",""Transformed; spectrum using Cosine transform"",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrumTransform.html:15581,adapt,adaptive,15581,root/html602/TSpectrumTransform.html,https://root.cern,https://root.cern/root/html602/TSpectrumTransform.html,4,['adapt'],['adaptive']
Energy Efficiency,"�� kTransformCos. ����������������������� kTransformSin. ����������������������� kTransformFourier. ����������������������� kTransformHartey. ����������� Mixed transforms:; ����������������������� kTransformFourierWalsh. ����������������������� kTransformFourierHaar. ����������������������� kTransformWalshHaar. ����������������������� kTransformCosWalsh. ����������������������� kTransformCosHaar. ����������������������� kTransformSinWalsh. ����������������������� kTransformSinHaar. fDirection-direction-transform; direction (forward, inverse); ����������������������� kTransformForward. ����������������������� kTransformInverse. fDegree-applies; only for mixed transforms [2], [3], [4]. ; ����������������; �Allowed range� . ; References:; [1] C.V. Hampton, B. Lian, Wm. C.; McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray; spectroscopy. NIM A353 (1994) 280-284. ; [2] Morh�č M., Matou�ek V.,; New adaptive Cosine-Walsh� transform and its application to nuclear data; compression, IEEE Transactions on Signal Processing 48 (2000) 2693.� ; [3] Morh�č M., Matou�ek V.,; Data compression using new fast adaptive Cosine-Haar transforms, Digital Signal; Processing 8 (1998) 63. ; [4] Morh�č M., Matou�ek V.:; Multidimensional nuclear data compression using fast adaptive Walsh-Haar; transform. Acta Physica Slovaca 51 (2001) 307. ;  ; Example �� script Transform.c:. Fig. 1 Original gamma-ray spectrum.  ; Fig. 2 Transformed spectrum from Fig. 1 using Cosine; transform;  ; Script:; // Example to illustrate; Transform function (class TSpectrumTransform).; // To execute this example,; do; // root > .x Transform.C; �� ; #include <TSpectrum>; #include; <TSpectrumTransform>;  ; void Transform() {; �� Int_t i;; �� Double_t nbins =; 4096;; �� Double_t xmin� =; 0;; �� Double_t xmax� =; (Double_t)nbins;; �� Float_t * source = new float[nbins];; �� Float_t * dest = new; float[nbins];�� ; �� TH1F *h = new TH1F(""h"",""Transformed; spectrum using Cosine transform"",nbins,xm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrumTransform.html:14367,adapt,adaptive,14367,root/html528/TSpectrumTransform.html,https://root.cern,https://root.cern/root/html528/TSpectrumTransform.html,6,['adapt'],['adaptive']
Energy Efficiency,"������ bin = 1 + Int_t(a +; 0.5);�� ������������ ; ������� PosX[i] =; d->GetBinCenter(bin);; ������� PosY[i] =; d->GetBinContent(bin);; �� }; �� TPolyMarker * pm =; (TPolyMarker*)h->GetListOfFunctions()->FindObject(""TPolyMarker"");; �� if (pm) {; �����; h->GetListOfFunctions()->Remove(pm);; ����� delete pm;; �� }; �� pm = new; TPolyMarker(nfound, PosX, PosY);; ��; h->GetListOfFunctions()->Add(pm);; �� pm->SetMarkerStyle(23);; ��; pm->SetMarkerColor(kRed);; �� pm->SetMarkerSize(1);��. }. void SetFitParameters(Int_t xmin, Int_t xmax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor). SETTER FUNCTION. This function sets the following fitting parameters:; -xmin, xmax - fitting region; -numberIterations - # of desired iterations in the fit; -alpha - convergence coefficient, it should be positive number and <=1, for details see references; -statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; -alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; -power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; -fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. void SetPeakParameters(Double_t sigma, Bool_t fixSigma, const Double_t* positionInit, const Bool_t* fixPosition, const Double_t* ampInit, const Bool_t* fixAmp). SETTER FUNCTION. This function sets the following fitting parameters of peaks:; -sigma - initial value of sigma parameter; -fixSigma - logical value of sigma parameter, which allows to fix the parameter (not to fit); -positionInit - aray of initial values of peaks positions; -fixPosition - array of logical value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrumFit.html:36381,power,power,36381,root/html602/TSpectrumFit.html,https://root.cern,https://root.cern/root/html602/TSpectrumFit.html,4,['power'],['power']
Energy Efficiency,"������ bin = 1 + Int_t(a +; 0.5);�� ������������ ; ������� PosX[i] =; d->GetBinCenter(bin);; ������� PosY[i] =; d->GetBinContent(bin);; �� }; �� TPolyMarker * pm =; (TPolyMarker*)h->GetListOfFunctions()->FindObject(""TPolyMarker"");; �� if (pm) {; �����; h->GetListOfFunctions()->Remove(pm);; ����� delete pm;; �� }; �� pm = new; TPolyMarker(nfound, PosX, PosY);; ��; h->GetListOfFunctions()->Add(pm);; �� pm->SetMarkerStyle(23);; ��; pm->SetMarkerColor(kRed);; �� pm->SetMarkerSize(1);��. }. void SetFitParameters(Int_t xmin, Int_t xmax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor). SETTER FUNCTION. This function sets the following fitting parameters:; -xmin, xmax - fitting region; -numberIterations - # of desired iterations in the fit; -alpha - convergence coefficient, it should be positive number and <=1, for details see references; -statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; -alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; -power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; -fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. void SetPeakParameters(Double_t sigma, Bool_t fixSigma, const Float_t* positionInit, const Bool_t* fixPosition, const Float_t* ampInit, const Bool_t* fixAmp). SETTER FUNCTION. This function sets the following fitting parameters of peaks:; -sigma - initial value of sigma parameter; -fixSigma - logical value of sigma parameter, which allows to fix the parameter (not to fit); -positionInit - aray of initial values of peaks positions; -fixPosition - array of logical values ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrumFit.html:35335,power,power,35335,root/html528/TSpectrumFit.html,https://root.cern,https://root.cern/root/html528/TSpectrumFit.html,6,['power'],['power']
Energy Efficiency,"���������� kTransformWalshHaar. ����������������������� kTransformCosWalsh. ����������������������� kTransformCosHaar. ����������������������� kTransformSinWalsh. ����������������������� kTransformSinHaar. fDirection-direction-transform; direction (forward, inverse); ����������������������� kTransformForward. ����������������������� kTransformInverse. fDegree-applies; only for mixed transforms [2], [3], [4]. ; ����������������; �Allowed range� . ; References:; [1] C.V. Hampton, B. Lian, Wm. C.; McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray; spectroscopy. NIM A353 (1994) 280-284. ; [2] Morh�č M., Matou�ek V.,; New adaptive Cosine-Walsh� transform and its application to nuclear data; compression, IEEE Transactions on Signal Processing 48 (2000) 2693.� ; [3] Morh�č M., Matou�ek V.,; Data compression using new fast adaptive Cosine-Haar transforms, Digital Signal; Processing 8 (1998) 63. ; [4] Morh�č M., Matou�ek V.:; Multidimensional nuclear data compression using fast adaptive Walsh-Haar; transform. Acta Physica Slovaca 51 (2001) 307. ;  ; Example 1 � script Transform2.c:. Fig. 1 Original two-dimensional noisy spectrum. Fig. 2 Transformed spectrum; from Fig. 1 using Cosine transform. Energy of the trasnsformed data is; concentrated around the beginning of the coordinate system;  ; Script:; // Example to illustrate; Transform function (class TSpectrumTransform2).; // To execute this example,; do; // root > .x Transform2.C; void Transform2() {; �� Int_t i, j;; �� Int_t nbinsx =; 256;; �� Int_t nbinsy =; 256;�� ; �� Int_t xmin� = 0;; �� Int_t xmax� =; nbinsx;; �� Int_t ymin� = 0;; �� Int_t ymax� = nbinsy;; �� Double_t ** source = new Double_t *[nbinsx];�� ; �� Double_t ** dest = new; Double_t *[nbinsx];����� ; �� for (i=0;i<nbinsx;i++); ����������������������������������������������� source[i]=new; Double_t[nbinsy];; �� for (i=0;i<nbinsx;i++); ����������������������������������������������� dest[i]=new; Double_t[nbinsy];�� ; �� TH2F *trans ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2Transform.html:17775,adapt,adaptive,17775,root/html602/TSpectrum2Transform.html,https://root.cern,https://root.cern/root/html602/TSpectrum2Transform.html,4,['adapt'],['adaptive']
Energy Efficiency,"���������� kTransformWalshHaar. ����������������������� kTransformCosWalsh. ����������������������� kTransformCosHaar. ����������������������� kTransformSinWalsh. ����������������������� kTransformSinHaar. fDirection-direction-transform; direction (forward, inverse); ����������������������� kTransformForward. ����������������������� kTransformInverse. fDegree-applies; only for mixed transforms [2], [3], [4]. ; ����������������; �Allowed range� . ; References:; [1] C.V. Hampton, B. Lian, Wm. C.; McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray; spectroscopy. NIM A353 (1994) 280-284. ; [2] Morh�č M., Matou�ek V.,; New adaptive Cosine-Walsh� transform and its application to nuclear data; compression, IEEE Transactions on Signal Processing 48 (2000) 2693.� ; [3] Morh�č M., Matou�ek V.,; Data compression using new fast adaptive Cosine-Haar transforms, Digital Signal; Processing 8 (1998) 63. ; [4] Morh�č M., Matou�ek V.:; Multidimensional nuclear data compression using fast adaptive Walsh-Haar; transform. Acta Physica Slovaca 51 (2001) 307. ;  ; Example 1 � script Transform2.c:. Fig. 1 Original two-dimensional noisy spectrum. Fig. 2 Transformed spectrum; from Fig. 1 using Cosine transform. Energy of the trasnsformed data is; concentrated around the beginning of the coordinate system;  ; Script:; // Example to illustrate; Transform function (class TSpectrumTransform2).; // To execute this example,; do; // root > .x Transform2.C; void Transform2() {; �� Int_t i, j;; �� Int_t nbinsx =; 256;; �� Int_t nbinsy =; 256;�� ; �� Int_t xmin� = 0;; �� Int_t xmax� =; nbinsx;; �� Int_t ymin� = 0;; �� Int_t ymax� = nbinsy;; �� Float_t ** source = new float *[nbinsx];�� ; �� Float_t ** dest = new; float *[nbinsx];����� ; �� for (i=0;i<nbinsx;i++); ����������������������������������������������� source[i]=new; float[nbinsy];; �� for (i=0;i<nbinsx;i++); ����������������������������������������������� dest[i]=new; float[nbinsy];�� ; �� TH2F *trans = new; TH2F(""t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Transform.html:16590,adapt,adaptive,16590,root/html528/TSpectrum2Transform.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Transform.html,6,['adapt'],['adaptive']
Energy Efficiency,"���������� kTransformWalshHaar. ����������������������� kTransformCosWalsh. ����������������������� kTransformCosHaar. ����������������������� kTransformSinWalsh. ����������������������� kTransformSinHaar. fDirection-direction-transform; direction (forward, inverse); ����������������������� kTransformForward. ����������������������� kTransformInverse. fDegree-applies; only for mixed transforms [2], [3], [4]. ; ����������������; �Allowed range� . ; References:; [1] C.V. Hampton, B. Lian, Wm. C.; McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray; spectroscopy. NIM A353 (1994) 280-284. ; [2] Morh�č M., Matou�ek V.,; New adaptive Cosine-Walsh� transform and its application to nuclear data; compression, IEEE Transactions on Signal Processing 48 (2000) 2693.� ; [3] Morh�č M., Matou�ek V.,; Data compression using new fast adaptive Cosine-Haar transforms, Digital Signal; Processing 8 (1998) 63. ; [4] Morh�č M., Matou�ek V.:; Multidimensional nuclear data compression using fast adaptive Walsh-Haar; transform. Acta Physica Slovaca 51 (2001) 307. ;  ; Example �� script Transform.c:. Fig. 1 Original gamma-ray spectrum.  ; Fig. 2 Transformed spectrum from Fig. 1 using Cosine; transform;  ; Script:; // Example to illustrate; Transform function (class TSpectrumTransform).; // To execute this example,; do; // root > .x Transform.C; �� ; #include <TSpectrum>; #include; <TSpectrumTransform>;  ; void Transform() {; �� Int_t i;; �� Double_t nbins =; 4096;; �� Double_t xmin� =; 0;; �� Double_t xmax� =; (Double_t)nbins;; �� Double_t * source = new Double_t[nbins];; �� Double_t * dest = new; Double_t[nbins];�� ; �� TH1F *h = new TH1F(""h"",""Transformed; spectrum using Cosine transform"",nbins,xmin,xmax);; �� TFile *f = new; TFile(""spectra\\TSpectrum.root"");; �� h=(TH1F*); f->Get(""transform1;1"");�� ; �� for (i = 0; i < nbins;; i++) source[i]=h->GetBinContent(i + 1);�������� ; �� TCanvas *Transform1 =; gROOT->GetListOfCanvases()->FindObject(""Transform1"");; �� if (!T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrumTransform.html:15940,adapt,adaptive,15940,root/html602/TSpectrumTransform.html,https://root.cern,https://root.cern/root/html602/TSpectrumTransform.html,4,['adapt'],['adaptive']
Energy Efficiency,"���������� kTransformWalshHaar. ����������������������� kTransformCosWalsh. ����������������������� kTransformCosHaar. ����������������������� kTransformSinWalsh. ����������������������� kTransformSinHaar. fDirection-direction-transform; direction (forward, inverse); ����������������������� kTransformForward. ����������������������� kTransformInverse. fDegree-applies; only for mixed transforms [2], [3], [4]. ; ����������������; �Allowed range� . ; References:; [1] C.V. Hampton, B. Lian, Wm. C.; McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray; spectroscopy. NIM A353 (1994) 280-284. ; [2] Morh�č M., Matou�ek V.,; New adaptive Cosine-Walsh� transform and its application to nuclear data; compression, IEEE Transactions on Signal Processing 48 (2000) 2693.� ; [3] Morh�č M., Matou�ek V.,; Data compression using new fast adaptive Cosine-Haar transforms, Digital Signal; Processing 8 (1998) 63. ; [4] Morh�č M., Matou�ek V.:; Multidimensional nuclear data compression using fast adaptive Walsh-Haar; transform. Acta Physica Slovaca 51 (2001) 307. ;  ; Example �� script Transform.c:. Fig. 1 Original gamma-ray spectrum.  ; Fig. 2 Transformed spectrum from Fig. 1 using Cosine; transform;  ; Script:; // Example to illustrate; Transform function (class TSpectrumTransform).; // To execute this example,; do; // root > .x Transform.C; �� ; #include <TSpectrum>; #include; <TSpectrumTransform>;  ; void Transform() {; �� Int_t i;; �� Double_t nbins =; 4096;; �� Double_t xmin� =; 0;; �� Double_t xmax� =; (Double_t)nbins;; �� Float_t * source = new float[nbins];; �� Float_t * dest = new; float[nbins];�� ; �� TH1F *h = new TH1F(""h"",""Transformed; spectrum using Cosine transform"",nbins,xmin,xmax);; �� TFile *f = new; TFile(""spectra\\TSpectrum.root"");; �� h=(TH1F*); f->Get(""transform1;1"");�� ; �� for (i = 0; i < nbins;; i++) source[i]=h->GetBinContent(i + 1);�������� ; �� TCanvas *Transform1 =; gROOT->GetListOfCanvases()->FindObject(""Transform1"");; �� if (!Transform",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrumTransform.html:14726,adapt,adaptive,14726,root/html528/TSpectrumTransform.html,https://root.cern,https://root.cern/root/html528/TSpectrumTransform.html,6,['adapt'],['adaptive']
Energy Efficiency,"����������� kTransformInverse. fDegree-applies; only for mixed transforms [2], [3], [4]. ; ����������������; �Allowed range� . ; References:; [1] C.V. Hampton, B. Lian, Wm. C.; McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray; spectroscopy. NIM A353 (1994) 280-284. ; [2] Morh�č M., Matou�ek V.,; New adaptive Cosine-Walsh� transform and its application to nuclear data; compression, IEEE Transactions on Signal Processing 48 (2000) 2693.� ; [3] Morh�č M., Matou�ek V.,; Data compression using new fast adaptive Cosine-Haar transforms, Digital Signal; Processing 8 (1998) 63. ; [4] Morh�č M., Matou�ek V.:; Multidimensional nuclear data compression using fast adaptive Walsh-Haar; transform. Acta Physica Slovaca 51 (2001) 307. ;  ; Example 1 � script Transform2.c:. Fig. 1 Original two-dimensional noisy spectrum. Fig. 2 Transformed spectrum; from Fig. 1 using Cosine transform. Energy of the trasnsformed data is; concentrated around the beginning of the coordinate system;  ; Script:; // Example to illustrate; Transform function (class TSpectrumTransform2).; // To execute this example,; do; // root > .x Transform2.C; void Transform2() {; �� Int_t i, j;; �� Int_t nbinsx =; 256;; �� Int_t nbinsy =; 256;�� ; �� Int_t xmin� = 0;; �� Int_t xmax� =; nbinsx;; �� Int_t ymin� = 0;; �� Int_t ymax� = nbinsy;; �� Double_t ** source = new Double_t *[nbinsx];�� ; �� Double_t ** dest = new; Double_t *[nbinsx];����� ; �� for (i=0;i<nbinsx;i++); ����������������������������������������������� source[i]=new; Double_t[nbinsy];; �� for (i=0;i<nbinsx;i++); ����������������������������������������������� dest[i]=new; Double_t[nbinsy];�� ; �� TH2F *trans = new; TH2F(""trans"",""Background; estimation"",nbinsx,xmin,xmax,nbinsy,ymin,ymax);; �� TFile *f = new; TFile(""TSpectrum2.root"");; �� trans=(TH2F*); f->Get(""back3;1"");; �� TCanvas *Tr = new; TCanvas(""Transform"",""Illustation of transform; function"",10,10,1000,700);; �� for (i = 0; i < nbinsx;; i++){; ���� for (j = 0; j <; nb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2Transform.html:17995,Energy,Energy,17995,root/html602/TSpectrum2Transform.html,https://root.cern,https://root.cern/root/html602/TSpectrum2Transform.html,2,['Energy'],['Energy']
Energy Efficiency,"����������� kTransformInverse. fDegree-applies; only for mixed transforms [2], [3], [4]. ; ����������������; �Allowed range� . ; References:; [1] C.V. Hampton, B. Lian, Wm. C.; McHarris: Fast-Fourier-transform spectral enhancement techniques for gamma-ray; spectroscopy. NIM A353 (1994) 280-284. ; [2] Morh�č M., Matou�ek V.,; New adaptive Cosine-Walsh� transform and its application to nuclear data; compression, IEEE Transactions on Signal Processing 48 (2000) 2693.� ; [3] Morh�č M., Matou�ek V.,; Data compression using new fast adaptive Cosine-Haar transforms, Digital Signal; Processing 8 (1998) 63. ; [4] Morh�č M., Matou�ek V.:; Multidimensional nuclear data compression using fast adaptive Walsh-Haar; transform. Acta Physica Slovaca 51 (2001) 307. ;  ; Example 1 � script Transform2.c:. Fig. 1 Original two-dimensional noisy spectrum. Fig. 2 Transformed spectrum; from Fig. 1 using Cosine transform. Energy of the trasnsformed data is; concentrated around the beginning of the coordinate system;  ; Script:; // Example to illustrate; Transform function (class TSpectrumTransform2).; // To execute this example,; do; // root > .x Transform2.C; void Transform2() {; �� Int_t i, j;; �� Int_t nbinsx =; 256;; �� Int_t nbinsy =; 256;�� ; �� Int_t xmin� = 0;; �� Int_t xmax� =; nbinsx;; �� Int_t ymin� = 0;; �� Int_t ymax� = nbinsy;; �� Float_t ** source = new float *[nbinsx];�� ; �� Float_t ** dest = new; float *[nbinsx];����� ; �� for (i=0;i<nbinsx;i++); ����������������������������������������������� source[i]=new; float[nbinsy];; �� for (i=0;i<nbinsx;i++); ����������������������������������������������� dest[i]=new; float[nbinsy];�� ; �� TH2F *trans = new; TH2F(""trans"",""Background; estimation"",nbinsx,xmin,xmax,nbinsy,ymin,ymax);; �� TFile *f = new; TFile(""TSpectrum2.root"");; �� trans=(TH2F*); f->Get(""back3;1"");; �� TCanvas *Tr = new; TCanvas(""Transform"",""Illustation of transform; function"",10,10,1000,700);; �� for (i = 0; i < nbinsx;; i++){; ���� for (j = 0; j <; nbinsy; j++){; �",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSpectrum2Transform.html:16879,Energy,Energy,16879,root/html532/TSpectrum2Transform.html,https://root.cern,https://root.cern/root/html532/TSpectrum2Transform.html,2,['Energy'],['Energy']
Integrability," "" << id2 << "" "" << name1 << "" "" << name2 << endl;; }; }. 4. Working with date/time parameters. The current implementation supports date, time, date&time and timestamp; data (all time intervals are not supported yet). To set or get date/time values,; the following methods should be used:; SetTime()/GetTime() - only time (hour:min:sec),; SetDate()/GetDate() - only date (year-month-day),; SetDatime()/GetDatime() - date and time; SetTimestamp()/GetTimestamp() - timestamp with seconds fraction; For some of these methods TDatime type can be used as parameter / return value.; Be aware that TDatime supports only dates after 1995-01-01.; There are also methods to get year, month, day, hour, minutes and seconds separately. Note that different SQL databases treat date/time types differently.; For instance, MySQL has all correspondent types (TIME, DATE, DATETIME and TIMESTAMP),; Oracle native driver supports only DATE (which is actually date and time) and TIMESTAMP; ODBC interface provides access for time, date and timestamps,; for PostgreSQL, TIMESTAMP is available and can be retrieved via all methods,; the implementation for SQLite interprets the column content as; a timestamp with second fraction.; Due to these differences, one should use correct methods to access such data.; For instance, in MySQL SQL type 'DATE' is only date (one should use GetDate() to; access such data), while in Oracle it is date and time. Therefore,; to get complete data from a 'DATE' column in Oracle, one should use the GetDatime() method. The only difference between timestamp and date/time is that timestamp has a fractional; seconds part. Be aware that the fractional part has different meanings; (actual value) in different SQL plugins.; For PostgreSQL, it is given back as microseconds, while for SQLite3,; milliseconds correspond to the fraction (similar to the DATETIME-functions; implemented in the SQLite3 language). 5. Binary data. Most modern data bases support just binary data, which is; typicall",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLStatement.html:8695,interface,interface,8695,root/html534/TSQLStatement.html,https://root.cern,https://root.cern/root/html534/TSQLStatement.html,2,['interface'],['interface']
Integrability," "" failed to converge !!!"" << std::endl;; Error(""NumericalMinimization"",""fail to converge"");; }; ; return 0;; }; Functor.h; Minimizer.h; f#define f(i)Definition RSha256.hxx:104; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRandom2.h; ROOT::Math::Factory::CreateMinimizerstatic ROOT::Math::Minimizer * CreateMinimizer(const std::string &minimizerType="""", const std::string &algoType="""")static method to create the corresponding Minimizer given the string Supported Minimizers types are: ...Definition Factory.cxx:63; ROOT::Math::FunctorDocumentation for class Functor class.Definition Functor.h:47; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::Xvirtual const double * X() const =0return pointer to X values at the minimum; ROOT::Math::Minimizer::SetMaxIterationsvoid SetMaxIterations(unsigned int maxiter)set maximum iterations (one iteration can have many function calls)Definition Minimizer.h:334; ROOT::Math::Minimizer::SetFunctionvirtual void SetFunction(const ROOT::Math::IMultiGenFunction &func)=0set the function to minimize; ROOT::Math::Minimizer::SetTolerancevoid SetTolerance(double tol)set the toleranceDefinition Minimizer.h:337; ROOT::Math::Minimizer::Minimizevirtual bool Minimize()=0method to perform the minimization; ROOT::Math::Minimizer::SetPrintLevelvoid SetPrintLevel(int level)set print levelDefinition Minimizer.h:328; ROOT::Math::Minimizer::SetVariablevirtual bool SetVariable(unsigned int ivar, const std::string &name, double val, double step)=0set a new free variable; ROOT::Math::Minimizer::SetMaxFunction",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NumericalMinimization_8C.html:3684,interface,interface,3684,doc/master/NumericalMinimization_8C.html,https://root.cern,https://root.cern/doc/master/NumericalMinimization_8C.html,1,['interface'],['interface']
Integrability," """"); Merge all chains in the collection. (NOT IMPLEMENTED). Long64_t Merge(TFile* file, Int_t basketsize, Option_t* option = """"); Merge all the entries in the chain into a new tree in the current file. Note: The ""file"" parameter is *not* the file where the new; tree will be inserted. The new tree is inserted into; gDirectory, which is usually the most recently opened; file, or the directory most recently cd()'d to. If option = ""C"" is given, the compression level for all branches; in the new Tree is set to the file compression level. By default,; the compression level of all branches is the original compression; level in the old trees. If basketsize > 1000, the basket size for all branches of the; new tree will be set to basketsize. Example using the file generated in $ROOTSYS/test/Event; merge two copies of Event.root. gSystem.Load(""libEvent"");; TChain ch(""T"");; ch.Add(""Event1.root"");; ch.Add(""Event2.root"");; ch.Merge(""all.root"");. If the chain is expecting the input tree inside a directory,; this directory is NOT created by this routine. So if you do:. TChain ch(""mydir/mytree"");; ch.Merge(""newfile.root"");. The resulting file will not have subdirectories. In order to; preserve the directory structure do the following instead:. TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file);. If 'option' contains the word 'fast' the merge will be done without; unzipping or unstreaming the baskets (i.e., a direct copy of the raw; bytes on disk). When 'fast' is specified, 'option' can also contains a; sorting order for the baskets in the output file. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TChain.html:39921,rout,routine,39921,root/html528/TChain.html,https://root.cern,https://root.cern/root/html528/TChain.html,1,['rout'],['routine']
Integrability," ""@0*@1"", RooArgList(x,y)) // reference by ordinal with @; RooFormulaVar(""gen"", ""x[0]*x[1]"", RooArgList(x,y)) // TFormula-builtin reference by ordinal; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooFormulaVar::RooFormulaVarRooFormulaVar()Definition RooFormulaVar.cxx:65; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; Note that x[i] is an expression reserved for TFormula. All variable references are automatically converted to the TFormula-native format. If a variable with the name x is given, the RooFormula interprets x[i] as a list position, but x without brackets as the name of a RooFit object.; The last two versions, while slightly less readable, are more versatile because the names of the arguments are not hard coded. ; Definition at line 30 of file RooFormulaVar.h. Public Member Functions;  RooFormulaVar ();  ;  RooFormulaVar (const char *name, const char *title, const char *formula, const RooArgList &dependents, bool checkVariables=true);  Constructor with formula expression and list of input variables. ;  ;  RooFormulaVar (const char *name, const char *title, const RooArgList &dependents, bool checkVariables=true);  Constructor with formula expression, title and list of input variables. ;  ;  RooFormulaVar (const RooFormulaVar &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooFormulaVar () override;  ; std::list< double > * binBoundaries (RooAbsRealLValue &, double, double) const override;  Forward the plot sampling hint from the p.d.f. that defines the observable obs. ;  ; TObject * clone (const char *newname) const override;  ; double defaultErrorLevel () const override;  Return the default error level for MINUIT error analysis If the formula contains one or more RooNLLVars and no RooChi2Vars, return the defaultErrorLevel() of RooNLLVar. ;  ; const RooArgList & dependents () const;  ; void doEval (RooFit::EvalContext &ctx) const override;  Base fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFormulaVar.html:2120,depend,dependents,2120,doc/master/classRooFormulaVar.html,https://root.cern,https://root.cern/doc/master/classRooFormulaVar.html,1,['depend'],['dependents']
Integrability," ""centered"" is treated in a special way; 778 // to ensure a better spacing between lines.; 779 if (valign == 2) {; 780 Float_t tsizepad = textsize;; 781 if (tfont%10 == 3) tsizepad = (gPad->AbsPixeltoY(0) - gPad->AbsPixeltoY(textsize))/(gPad->GetY2() - gPad->GetY1());; 782 if (yspace2 < tsizepad) {; 783 entry->SetTextAlign(10*halign+1);; 784 y = ytext - (1. - fEntrySeparation)* yspace2/2.;; 785 } else {; 786 y = ytext;; 787 }; 788 }; 789 ; 790 TLatex entrytex( x, y, entry->GetLabel() );; 791 entrytex.SetNDC();; 792 entry->TAttText::Copy(entrytex);; 793 entrytex.Paint();; 794 ; 795 // reset attributes back to their original values; 796 entry->SetTextAlign(talign);; 797 entry->SetTextAngle(tangle);; 798 entry->SetTextColor(tcolor);; 799 entry->SetTextFont(tfont);; 800 entry->SetTextSize(tsize);; 801 ; 802 // define x,y as the center of the symbol for this entry; 803 Double_t xsym = x1 + margin/2.;; 804 Double_t ysym = ytext;; 805 ; 806 TObject *eobj = entry->GetObject();; 807 ; 808 // depending on the object drawing option, the endcaps for error; 809 // bar are drawn differently.; 810 Int_t endcaps = 0; // no endcaps.; 811 if (eobj) { // eobj == nullptr for the legend header; 812 TString eobjopt = eobj->GetDrawOption();; 813 eobjopt.ToLower();; 814 if (eobjopt.Contains(""e1"") && eobj->InheritsFrom(TH1::Class())) endcaps = 1; // a bar; 815 if (eobj->InheritsFrom(TGraph::Class())) {; 816 endcaps = 1; // a bar, default for TGraph; 817 if (eobjopt.Contains(""z"")) endcaps = 0; // no endcaps.; 818 if (eobjopt.Contains("">"")) endcaps = 2; // empty arrow.; 819 if (eobjopt.Contains(""|>"")) endcaps = 3; // filled arrow.; 820 }; 821 }; 822 float arrow_shift = 0.3;; 823 if (endcaps == 3) arrow_shift = 0.2;; 824 // Draw fill pattern (in a box); 825 ; 826 if ( opt.Contains(""f"")) {; 827 if (eobj && eobj->InheritsFrom(TAttFill::Class())) {; 828 dynamic_cast<TAttFill*>(eobj)->Copy(*entry);; 829 }; 830 ; 831 // Case of exclusion graphs; 832 Float_t wl = 1., wu = 1.;; 833 if (eobj && eobj->I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLegend_8cxx_source.html:28444,depend,depending,28444,doc/master/TLegend_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html,1,['depend'],['depending']
Integrability," ""http_proxy"" has been set and should be used. Bool_t IsOpen() const; A TWebFile that has been correctly constructed is always considered open. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. A TWebFile cannot be reopened in update mode. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via HTTP daemon. This; routine connects to the remote host, sends the request and returns; the buffer. Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via HTTP daemon. This; routine connects to the remote host, sends the request and returns; the buffer. Returns kTRUE in case of error. Bool_t ReadBuffer10(char* buf, Int_t len); Read specified byte range from remote file via HTTP 1.0 daemon (without; mod-root installed). This routine connects to the remote host, sends the; request and returns the buffer. Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read specified byte ranges from remote file via HTTP daemon.; Reads the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t ReadBuffers10(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read specified byte ranges from remote file via HTTP 1.0 daemon (without; mod-root installed). Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TWebFile.html:25848,rout,routine,25848,root/html528/TWebFile.html,https://root.cern,https://root.cern/root/html528/TWebFile.html,10,['rout'],['routine']
Integrability," ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. If 'err' is defined, '*err' on return from a failed call contains an error; code (see NetErrors.h). Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel"" sockets; are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote ser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSocket.html:22134,protocol,protocol,22134,root/html530/TSocket.html,https://root.cern,https://root.cern/root/html530/TSocket.html,9,['protocol'],['protocol']
Integrability," # We prepare an input tree to run on; fileName = 'df004_cutFlowReport_py.root'; treeName = 'myTree'; fill_tree(treeName, fileName); ; # We read the tree from the file and create a RDataFrame, a class that; # allows us to interact with the data contained in the tree.; d = ROOT.RDataFrame(treeName, fileName); ; # ## Define cuts and create the report; # An optional string parameter name can be passed to the Filter method to create a named filter.; # Named filters work as usual, but also keep track of how many entries they accept and reject.; filtered1 = d.Filter('b1 > 25', 'Cut1'); filtered2 = d.Filter('0 == b2 % 2', 'Cut2'); ; augmented1 = filtered2.Define('b3', 'b1 / b2'); filtered3 = augmented1.Filter('b3 < .5','Cut3'); ; # Statistics are retrieved through a call to the Report method:; # when Report is called on the main RDataFrame object, it retrieves stats for; # all named filters declared up to that point. When called on a stored chain; # state (i.e. a chain/graph node), it retrieves stats for all named filters in; # the section of the chain between the main RDataFrame and that node (included).; # Stats are printed in the same order as named filters that have been added to the; # graph, and refer to the latest event-loop that has been running using the relevant; # RDataFrame.; print('Cut3 stats:'); filtered3.Report(); print('All stats:'); allCutsReport = d.Report(); allCutsReport.Print(); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; Cut1 : pass=24 all=50 -- eff=48.00 % cumulative eff=48.00 %; Cut2 : pass=25 all=50 -- eff=50.00 % cumulative eff=50.00 %; Cut3 : pass=23 all=25 -- eff=92.00 % cumulative eff=46.00 %; Cut3 stats:; All stats:; DateMay 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df004_cutFlowReport.py. tutorialsdataframedf004_cutFlowReport.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df004__cutFlowReport_8py.html:2065,interface,interface,2065,doc/master/df004__cutFlowReport_8py.html,https://root.cern,https://root.cern/doc/master/df004__cutFlowReport_8py.html,1,['interface'],['interface']
Integrability," # with the @pythonization decorator. Such decorator allows us to define which; # which class we want to pythonize by providing its class name and its; # namespace (if the latter is not specified, it defaults to the global; # namespace, i.e. '::').; #; # The decorated function - the pythonizor - must accept either one or two; # parameters:; # 1. The class to be pythonized (proxy object where new behaviour can be; # injected); # 2. The fully-qualified name of that class (optional).; #; # Let's see all this with a simple example. Suppose I would like to define how; # `MyClass` objects are represented as a string in Python (i.e. what would be; # shown when I print that object). For that purpose, I can define the following; # pythonizor function. There are two important things to be noted here:; # - The @pythonization decorator has one argument that specifies our target; # class is `MyClass`.; # - The pythonizor function `pythonizor_of_myclass` provides and injects a new; # implementation for `__str__`, the mechanism that Python provides to define; # how to represent objects as strings. This new implementation; # always returns the string ""This is a MyClass object"".; @pythonization('MyClass'); def pythonizor_of_myclass(klass):; klass.__str__ = lambda o : 'This is a MyClass object'; ; # Once we have defined our pythonizor function, let's see it in action.; # We will now use the `MyClass` class for the first time from Python: we will; # create a new instance of that class. At this moment, the pythonizor will; # execute and modify the class - pythonizors are always lazily run when a given; # class is used for the first time from a Python script.; my_object = ROOT.MyClass(); ; # Since the pythonizor already executed, we should now see the new behaviour.; # For that purpose, let's print `my_object` (should show ""This is a MyClass; # object"").; print(my_object); ; # The previous example is just a simple one, but there are many ways in which a; # class can be pythonized. Typic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html:2287,inject,injects,2287,doc/master/pyroot002__pythonizationDecorator_8py.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html,1,['inject'],['injects']
Integrability," #include <TCanvas.h>; #include <TRandom.h>; #include <TF1Convolution.h>; #include <TF1.h>; #include <TH1F.h>; ; void fitConvolution(); {; // Construction of histogram to fit.; TH1F *h_ExpGauss = new TH1F(""h_ExpGauss"", ""Exponential convoluted by Gaussian"", 100, 0., 5.);; for (int i = 0; i < 1e6; i++) {; // Gives a alpha of -0.3 in the exp.; double x = gRandom->Exp(1. / 0.3);; x += gRandom->Gaus(0., 3.);; // Probability density function of the addition of two variables is the; // convolution of two density functions.; h_ExpGauss->Fill(x);; }; ; TF1Convolution *f_conv = new TF1Convolution(""expo"", ""gaus"", -1, 6, true);; f_conv->SetRange(-1., 6.);; f_conv->SetNofPointsFFT(1000);; TF1 *f = new TF1(""f"", *f_conv, 0., 5., f_conv->GetNpar());; f->SetParameters(1., -0.3, 0., 1.);; ; // Fit.; h_ExpGauss->Fit(""f"");; }; f#define f(i)Definition RSha256.hxx:104; TCanvas.h; TF1Convolution.h; TF1.h; TH1F.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TF1ConvolutionClass wrapping convolution of two functions.Definition TF1Convolution.h:20; TF1Convolution::GetNparInt_t GetNpar() constDefinition TF1Convolution.h:68; TF1Convolution::SetRangevoid SetRange(Double_t a, Double_t b) overrideSet the actual range used for the convolution.Definition TF1Convolution.cxx:452; TF1Convolution::SetNofPointsFFTvoid SetNofPointsFFT(Int_t n)Set the number of points used for the FFT convolution.Definition TF1Convolution.cxx:382; TF11-Dim function classDefinition TF1.h:233; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fitConvolution_8C.html:1508,wrap,wrapping,1508,doc/master/fitConvolution_8C.html,https://root.cern,https://root.cern/doc/master/fitConvolution_8C.html,1,['wrap'],['wrapping']
Integrability," %s present."",fName.c_str());; 809 }; 810 if ( 0 == fConstruct ) {; 811 Fatal(""TGenCollectionProxy"",""No 'block constructor' function for class %s present."",fName.c_str());; 812 }; 813 if ( 0 == fDestruct ) {; 814 Fatal(""TGenCollectionProxy"",""No 'block destructor' function for class %s present."",fName.c_str());; 815 }; 816 if ( 0 == fFeed ) {; 817 Fatal(""TGenCollectionProxy"",""No 'data feed' function for class %s present."",fName.c_str());; 818 }; 819 if ( 0 == fCollect ) {; 820 Fatal(""TGenCollectionProxy"",""No 'data collect' function for class %s present."",fName.c_str());; 821 }; 822 if (0 == fCreateEnv.call ) {; 823 Fatal(""TGenCollectionProxy"",""No 'environment creation' function for class %s present."",fName.c_str());; 824 }; 825}; 826 ; 827////////////////////////////////////////////////////////////////////////////////; 828/// Utility routine to issue a Fatal error is the Value object is not valid; 829 ; 830static TGenCollectionProxy::Value *R__CreateValue(const std::string &name, Bool_t silent,; 831 size_t hint_pair_offset = 0, size_t hint_pair_size = 0); 832{; 833 TGenCollectionProxy::Value *val = new TGenCollectionProxy::Value( name, silent, hint_pair_offset, hint_pair_size );; 834 if ( !val->IsValid() ) {; 835 Fatal(""TGenCollectionProxy"",""Could not find %s!"",name.c_str());; 836 }; 837 return val;; 838}; 839 ; 840////////////////////////////////////////////////////////////////////////////////; 841/// Proxy initializer; 842 ; 843TGenCollectionProxy *TGenCollectionProxy::InitializeEx(Bool_t silent); 844{; 845 R__LOCKGUARD(gInterpreterMutex);; 846 if (fValue.load()) return this;; 847 ; 848 TClass *cl = fClass ? fClass.GetClass() : TClass::GetClass(fTypeinfo,kTRUE,silent);; 849 if ( cl ) {; 850 fEnv = 0;; 851 fName = cl->GetName();; 852 fPointers = false;; 853 int nested = 0;; 854 std::vector<std::string> inside;; 855 int num = TClassEdit::GetSplit(cl->GetName(),inside,nested);; 856 if ( num > 1 ) {; 857 std::string nam;; 858 Value* newfValue = nullptr;; 859 if ( inside",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:25772,rout,routine,25772,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['rout'],['routine']
Integrability," & arg : pcmArgs) {; 4994 if (gOptInlineInput && !ROOT::TMetaUtils::IsLinkdefFile(arg.c_str()) && ROOT::TMetaUtils::IsHeaderName(arg)) {; 4995 detectedUmbrella = arg;; 4996 break;; 4997 }; 4998 }; 4999 ; 5000 if (gOptWriteEmptyRootPCM){; 5001 headersDeclsMap.clear();; 5002 }; 5003 ; 5004 ; 5005 std::string headersClassesMapString = ""\""\"""";; 5006 std::string fwdDeclsString = ""\""\"""";; 5007 if (!gOptCxxModule) {; 5008 headersClassesMapString = GenerateStringFromHeadersForClasses(headersDeclsMap,; 5009 detectedUmbrella,; 5010 true);; 5011 if (!gDriverConfig->fBuildingROOTStage1) {; 5012 if (!gOptWriteEmptyRootPCM); 5013 fwdDeclsString = GenerateFwdDeclString(scan, interp);; 5014 }; 5015 }; 5016 modGen.WriteRegistrationSource(dictStream, fwdDeclnArgsToKeepString, headersClassesMapString, fwdDeclsString,; 5017 extraIncludes, gOptCxxModule);; 5018 // If we just want to inline the input header, we don't need; 5019 // to generate any files.; 5020 if (!gOptInlineInput) {; 5021 // Write the module/PCH depending on what mode we are on; 5022 if (modGen.IsPCH()) {; 5023 if (!GenerateAllDict(modGen, CI, currentDirectory)) return 1;; 5024 } else if (gOptCxxModule) {; 5025 if (!CheckModuleValid(modGen, llvmResourceDir, interp, linkdefFilename, moduleName.str())); 5026 return 1;; 5027 }; 5028 }; 5029 }; 5030 ; 5031 ; 5032 if (!gOptLibListPrefix.empty()) {; 5033 string liblist_filename = gOptLibListPrefix + "".out"";; 5034 ; 5035 ofstream outputfile(liblist_filename.c_str(), ios::out);; 5036 if (!outputfile) {; 5037 ROOT::TMetaUtils::Error(nullptr, ""%s: Unable to open output lib file %s\n"",; 5038 executableFileName, liblist_filename.c_str());; 5039 } else {; 5040 const size_t endStr = gLibsNeeded.find_last_not_of("" \t"");; 5041 outputfile << gLibsNeeded.substr(0, endStr + 1) << endl;; 5042 // Add explicit delimiter; 5043 outputfile << ""# Now the list of classes\n"";; 5044 // SELECTION LOOP; 5045 for (auto const & annRcd : scan.fSelectedClasses) {; 5046 // Shouldn't it be GetLong64_Name( cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:204462,depend,depending,204462,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['depend'],['depending']
Integrability," &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return _cachedVars.getSize()>0 ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). » Last changed: Thu Nov 3 20:06:41 2011 » Last generated: 2011-11-03 20:06; This page has been automatically generated. For comments or suggestions regarding the documentati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsDataStore.html:11043,interface,interface,11043,root/html532/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html532/RooAbsDataStore.html,1,['interface'],['interface']
Integrability," &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Jun 2 15:27:04 2015 » Last ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsDataStore.html:12786,interface,interface,12786,root/html604/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html604/RooAbsDataStore.html,2,['interface'],['interface']
Integrability," &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Jun 30 14:30:06 2015 » Last g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsDataStore.html:12786,interface,interface,12786,root/html602/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html,2,['interface'],['interface']
Integrability," &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. Double_t sumEntries() const; { return 0 ; }. void reset(). void attachBuffers(const RooArgSet& extObs); Buffer redirection routines used in inside RooAbsOptTestStatistics. void resetBuffers(). void setExternalWeightArray(Double_t* , Double_t* , Double_t* , Double_t* ); {}. void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void recalculateCache(const RooArgSet* , Int_t , Int_t , Int_t , Bool_t ); {}. void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. Bool_t dirtyProp() const; { return _doDirtyProp ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return kFALSE ; }. const TTree* tree() const; { return 0 ; }. void dump(); {}. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). void forceCacheUpdate(); {}. » Last changed: Tue Mar 10 17:13:58 2015 » Last g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsDataStore.html:11212,interface,interface,11212,root/html534/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html,2,['interface'],['interface']
Integrability," &a, Double_t *b);  Static function, copying the non-zero entries in the upper triangle to array b . ;  ; static void Factor (const Int_t n, const Int_t nz, TArrayI &Airn, TArrayI &Aicn, TArrayD &Aa, TArrayI &Aiw, TArrayI &Aikeep, const Int_t nsteps, Int_t &maxfrt, TArrayI &Aiw1, Int_t *icntl, Double_t *cntl, Int_t *info);  Factorization routine, the workhorse for the decomposition step. ;  ; static void Factor_sub1 (const Int_t n, const Int_t nz, Int_t &nz1, Double_t *a, const Int_t la, Int_t *irn, Int_t *icn, Int_t *iw, const Int_t liw, Int_t *perm, Int_t *iw2, Int_t *icntl, Int_t *info);  Help routine for factorization. ;  ; static void Factor_sub2 (const Int_t n, const Int_t nz, Double_t *a, const Int_t la, Int_t *iw, const Int_t liw, Int_t *perm, Int_t *nstk, const Int_t nsteps, Int_t &maxfrt, Int_t *nelim, Int_t *iw2, Int_t *icntl, Double_t *cntl, Int_t *info);  Help routine for factorization. ;  ; static void Factor_sub3 (Double_t *a, Int_t *iw, Int_t &j1, Int_t &j2, const Int_t itop, const Int_t ireal, Int_t &ncmpbr, Int_t &ncmpbi);  Help routine for factorization. ;  ; static Int_t IDiag (Int_t ix, Int_t iy);  ; static void InitPivot (const Int_t n, const Int_t nz, TArrayI &Airn, TArrayI &Aicn, TArrayI &Aiw, TArrayI &Aikeep, TArrayI &Aiw1, Int_t &nsteps, const Int_t iflag, Int_t *icntl, Double_t *cntl, Int_t *info, Double_t &ops);  Setup Pivoting variables. ;  ; static void InitPivot_sub1 (const Int_t n, const Int_t nz, Int_t *irn, Int_t *icn, Int_t *iw, Int_t *ipe, Int_t *iq, Int_t *flag, Int_t &iwfr, Int_t *icntl, Int_t *info);  Help routine for pivoting setup. ;  ; static void InitPivot_sub2 (const Int_t n, Int_t *ipe, Int_t *iw, const Int_t lw, Int_t &iwfr, Int_t *nv, Int_t *nxt, Int_t *lst, Int_t *ipd, Int_t *flag, const Int_t iovflo, Int_t &ncmpa, const Double_t fratio);  Help routine for pivoting setup. ;  ; static void InitPivot_sub2a (const Int_t n, Int_t *ipe, Int_t *iw, const Int_t lw, Int_t &iwfr, Int_t &ncmpa);  Help routine for pivoting setup. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDecompSparse.html:13197,rout,routine,13197,doc/master/classTDecompSparse.html,https://root.cern,https://root.cern/doc/master/classTDecompSparse.html,1,['rout'],['routine']
Integrability," &convVar, RooAbsReal &pdf, RooAbsReal &resmodel, const RooNumConvolution *proto=nullptr);  Constructor of convolution operator PDF. ;  ;  RooNumConvolution (const RooNumConvolution &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooNumConvolution () override;  Destructor. ;  ; void clearConvolutionWindow ();  Removes previously defined convolution window, reverting to convolution from -inf to +inf. ;  ; TObject * clone (const char *newname) const override;  ; RooNumIntConfig & convIntConfig ();  ; const RooNumIntConfig & convIntConfig () const;  ; double evaluate () const override;  Calculate convolution integral. ;  ; TClass * IsA () const override;  ; RooAbsReal & model () const;  ; RooAbsReal & pdf () const;  ; const TH2 * profileData () const;  ; void setCallProfiling (bool flag, Int_t nbinX=40, Int_t nbinCall=40, Int_t nCallHigh=1000);  Activate call profile if flag is set to true. ;  ; void setCallWarning (Int_t threshold=2000);  Activate warning messages if number of function calls needed for evaluation of convolution integral exceeds given threshold. ;  ; void setConvolutionWindow (RooAbsReal &centerParam, RooAbsReal &widthParam, double widthScaleFactor=1);  Restrict convolution integral to finite range [ x - C - S*W, x - C + S*W ] where x is current value of convolution variablem, C = centerParam, W=widthParam and S = widthScaleFactor Inputs centerParam and withParam can be function expressions (RooAbsReal, RooFormulaVar) etc. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; RooRealVar & var () const;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot ra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvolution.html:3596,message,messages,3596,doc/master/classRooNumConvolution.html,https://root.cern,https://root.cern/doc/master/classRooNumConvolution.html,1,['message'],['messages']
Integrability," &iwfr, Int_t *ips, Int_t *ipv, Int_t *nv, Int_t *flag, Int_t &ncmpa);  Help routine for pivoting setup. ;  ; static void InitPivot_sub5 (const Int_t n, Int_t *ipe, Int_t *nv, Int_t *ips, Int_t *ne, Int_t *na, Int_t *nd, Int_t &nsteps, const Int_t nemin);  Help routine for pivoting setup. ;  ; static void InitPivot_sub6 (const Int_t n, const Int_t nz, Int_t *irn, Int_t *icn, Int_t *perm, Int_t *na, Int_t *ne, Int_t *nd, const Int_t nsteps, Int_t *lstki, Int_t *lstkr, Int_t *iw, Int_t *info, Double_t &ops);  Help routine for pivoting setup. ;  ; static Int_t NonZerosUpperTriang (const TMatrixDSparse &a);  Static function, returning the number of non-zero entries in the upper triangular matrix . ;  ; static void Solve (const Int_t n, TArrayD &Aa, TArrayI &Aiw, TArrayD &Aw, const Int_t maxfrt, TVectorD &b, TArrayI &Aiw1, const Int_t nsteps, Int_t *icntl, Int_t *info);  Main routine for solving Ax=b. ;  ; static void Solve_sub1 (const Int_t n, Double_t *a, Int_t *iw, Double_t *w, Double_t *rhs, Int_t *iw2, const Int_t nblk, Int_t &latop, Int_t *icntl);  Help routine for solving. ;  ; static void Solve_sub2 (const Int_t n, Double_t *a, Int_t *iw, Double_t *w, Double_t *rhs, Int_t *iw2, const Int_t nblk, const Int_t latop, Int_t *icntl);  Help routine for solving. ;  ;  Static Protected Member Functions inherited from TDecompBase; static void DiagProd (const TVectorD &diag, Double_t tol, Double_t &d1, Double_t &d2);  . Protected Attributes; TMatrixDSparse fA;  ; Double_t fCntl [6];  ; TArrayI fColFact;  ; TArrayD fFact;  ; Int_t fIcntl [31];  ; TArrayI fIkeep;  ; Int_t fInfo [21];  ; Double_t fIPessimism;  ; TArrayI fIw;  ; TArrayI fIw1;  ; TArrayI fIw2;  ; Int_t fMaxfrt;  ; Int_t fNnonZeros;  ; Int_t fNrows;  ; Int_t fNsteps;  ; Double_t fPrecision;  ; TArrayI fRowFact;  ; Double_t fRPessimism;  ; Int_t fVerbose;  ; TArrayD fW;  ;  Protected Attributes inherited from TDecompBase; Int_t fColLwb;  ; Double_t fCondition;  ; Double_t fDet1;  ; Double_t fDet2;  ; Int_t fRowLw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDecompSparse.html:15521,rout,routine,15521,doc/master/classTDecompSparse.html,https://root.cern,https://root.cern/doc/master/classTDecompSparse.html,1,['rout'],['routine']
Integrability," &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; virtual bool selfNormalized () const;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRoo2DKeysPdf.html:13731,message,messages,13731,doc/master/classRoo2DKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRoo2DKeysPdf.html,3,['message'],['messages']
Integrability," &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; virtual bool selfNormalized () const;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; TF1 * asTF (const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBreitWigner.html:12712,message,messages,12712,doc/master/classRooBreitWigner.html,https://root.cern,https://root.cern/doc/master/classRooBreitWigner.html,27,['message'],['messages']
Integrability," &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; virtual bool selfNormalized () const;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:17368,message,messages,17368,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,19,['message'],['messages']
Integrability," &r, Float_t &g, Float_t &b);  ; static void HSV2RGB (Float_t h, Float_t s, Float_t v, Float_t &r, Float_t &g, Float_t &b);  Static method to compute RGB from HSV: ;  ; static void InitializeColors ();  Initialize colors used by the TCanvas based graphics (via TColor objects). ;  ; static void InvertPalette ();  Invert the current color palette. ;  ; static Bool_t IsGrayscale ();  Return whether all colors return grayscale values. ;  ; static void ListColors (Int_t ci1=0, Int_t ci2=0, Bool_t showEmpty=kFALSE);  List nb colors from the color index ci. ;  ; static ULong_t Number2Pixel (Int_t ci);  Static method that given a color index number, returns the corresponding pixel value. ;  ; static void Pixel2RGB (ULong_t pixel, Float_t &r, Float_t &g, Float_t &b);  Convert machine dependent pixel value (obtained via RGB2Pixel or via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet. ;  ; static void Pixel2RGB (ULong_t pixel, Int_t &r, Int_t &g, Int_t &b);  Convert machine dependent pixel value (obtained via RGB2Pixel or via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet. ;  ; static const char * PixelAsHexString (ULong_t pixel);  Convert machine dependent pixel value (obtained via RGB2Pixel or via Number2Pixel() or via TColor::GetPixel()) to a hexadecimal string. ;  ; static void RGB2HLS (Float_t r, Float_t g, Float_t b, Float_t &h, Float_t &l, Float_t &s);  Static method to compute HLS from RGB. ;  ; static void RGB2HLS (Int_t r, Int_t g, Int_t b, Int_t &h, Int_t &l, Int_t &s);  Static method to compute HLS from RGB. ;  ; static void RGB2HSV (Float_t r, Float_t g, Float_t b, Float_t &h, Float_t &s, Float_t &v);  Static method to compute HSV from RGB. ;  ; static ULong_t RGB2Pixel (Float_t r, Float_t g, Float_t b);  Convert r,g,b to graphics system dependent pixel value. ;  ; static ULong_t RGB2Pixel (Int_t r, Int_t g, Int_t b);  Convert r,g,b to graphics system dependent pixel value. ;  ; static void RGBtoHLS (Float_t r, Float_t g, Float_t b, Float_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:39671,depend,dependent,39671,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,4,['depend'],['dependent']
Integrability," & ; , . Int_t & ;  . ). inlinevirtual . Reimplemented in TMySQLStatement, TODBCStatement, TPgSQLStatement, and TSQLiteStatement.; Definition at line 93 of file TSQLStatement.h. ◆ GetDay(). Int_t TSQLStatement::GetDay ; (; Int_t ; npar). return day value for parameter (if applicable) ; Definition at line 348 of file TSQLStatement.cxx. ◆ GetDouble(). virtual Double_t TSQLStatement::GetDouble ; (; Int_t ; ). inlinevirtual . Reimplemented in TMySQLStatement, TODBCStatement, TPgSQLStatement, and TSQLiteStatement.; Definition at line 86 of file TSQLStatement.h. ◆ GetErrorCode(). Int_t TSQLStatement::GetErrorCode ; (; ); const. virtual . returns error code of last operation if res==0, no error Each specific implementation of TSQLStatement provides its own error coding ; Definition at line 234 of file TSQLStatement.cxx. ◆ GetErrorMsg(). const char * TSQLStatement::GetErrorMsg ; (; ); const. virtual . returns error message of last operation if no errors, return 0 Each specific implementation of TSQLStatement provides its own error messages ; Definition at line 244 of file TSQLStatement.cxx. ◆ GetFieldName(). virtual const char * TSQLStatement::GetFieldName ; (; Int_t ; ). pure virtual . Implemented in TMySQLStatement, TODBCStatement, TPgSQLStatement, and TSQLiteStatement. ◆ GetHour(). Int_t TSQLStatement::GetHour ; (; Int_t ; npar). return hours value for parameter (if applicable) ; Definition at line 359 of file TSQLStatement.cxx. ◆ GetInt(). virtual Int_t TSQLStatement::GetInt ; (; Int_t ; ). inlinevirtual . Reimplemented in TMySQLStatement, TODBCStatement, TPgSQLStatement, and TSQLiteStatement.; Definition at line 81 of file TSQLStatement.h. ◆ GetLargeObject(). virtual Bool_t TSQLStatement::GetLargeObject ; (; Int_t ; col, . void *& ; mem, . Long_t & ; size . ). inlinevirtual . Reimplemented in TPgSQLStatement.; Definition at line 89 of file TSQLStatement.h. ◆ GetLong(). virtual Long_t TSQLStatement::GetLong ; (; Int_t ; ). inlinevirtual . Reimplemented in TMySQLStatement",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLStatement.html:18772,message,message,18772,doc/master/classTSQLStatement.html,https://root.cern,https://root.cern/doc/master/classTSQLStatement.html,2,['message'],"['message', 'messages']"
Integrability," & ; f, . double ; absTol = 0.0, . double ; relTol = 1E-9, . unsigned int ; maxcall = 100000, . unsigned int ; size = 0 . ). explicit . Construct with a reference to the integrand function and given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and size of the working array. ; Definition at line 37 of file AdaptiveIntegratorMultiDim.cxx. ◆ ~AdaptiveIntegratorMultiDim(). ROOT::Math::AdaptiveIntegratorMultiDim::~AdaptiveIntegratorMultiDim ; (; ). inlineoverride . destructor (no operations) ; Definition at line 113 of file AdaptiveIntegratorMultiDim.h. Member Function Documentation. ◆ DoIntegral(). double ROOT::Math::AdaptiveIntegratorMultiDim::DoIntegral ; (; const double * ; xmin, . const double * ; xmax, . bool ; absVal = false . ). protected . Definition at line 76 of file AdaptiveIntegratorMultiDim.cxx. ◆ Error(). double ROOT::Math::AdaptiveIntegratorMultiDim::Error ; (; ); const. inlineoverridevirtual . return integration error ; Implements ROOT::Math::VirtualIntegrator.; Definition at line 134 of file AdaptiveIntegratorMultiDim.h. ◆ Integral() [1/2]. double ROOT::Math::AdaptiveIntegratorMultiDim::Integral ; (; const double * ; xmin, . const double * ; xmax . ). inlineoverridevirtual . evaluate the integral with the previously given function between xmin[] and xmax[] ; Implements ROOT::Math::VirtualIntegratorMultiDim.; Definition at line 119 of file AdaptiveIntegratorMultiDim.h. ◆ Integral() [2/2]. double ROOT::Math::AdaptiveIntegratorMultiDim::Integral ; (; const IMultiGenFunction & ; f, . const double * ; xmin, . const double * ; xmax . ). evaluate the integral passing a new function ; Definition at line 382 of file AdaptiveIntegratorMultiDim.cxx. ◆ NEval(). int ROOT::Math::AdaptiveIntegratorMultiDim::NEval ; (; ); const. inlineoverridevirtual . return number of function evaluations in calculating the integral ; Reimplemented from ROOT::Math::VirtualIntegrator.; Definition at line 152 of file AdaptiveIntegratorMulti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html:8390,integrat,integration,8390,doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,1,['integrat'],['integration']
Integrability," & ; os = std::cout . ). static . print only the specified default options ; print default options ; Definition at line 215 of file IntegratorOptions.cxx. ◆ SetDefaultAbsTolerance(). void ROOT::Math::IntegratorOneDimOptions::SetDefaultAbsTolerance ; (; double ; tol). static . Definition at line 246 of file IntegratorOptions.cxx. ◆ SetDefaultIntegrator(). void ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator ; (; const char * ; name). static . Definition at line 222 of file IntegratorOptions.cxx. ◆ SetDefaultNPoints(). void ROOT::Math::IntegratorOneDimOptions::SetDefaultNPoints ; (; unsigned int ; n). static . Definition at line 259 of file IntegratorOptions.cxx. ◆ SetDefaultRelTolerance(). void ROOT::Math::IntegratorOneDimOptions::SetDefaultRelTolerance ; (; double ; tol). static . Definition at line 250 of file IntegratorOptions.cxx. ◆ SetDefaultWKSize(). void ROOT::Math::IntegratorOneDimOptions::SetDefaultWKSize ; (; unsigned int ; size). static . Definition at line 255 of file IntegratorOptions.cxx. ◆ SetIntegrator(). void ROOT::Math::IntegratorOneDimOptions::SetIntegrator ; (; const char * ; name). set 1D integrator name ; Definition at line 197 of file IntegratorOptions.cxx. ◆ SetNPoints(). void ROOT::Math::IntegratorOneDimOptions::SetNPoints ; (; unsigned int ; n). inline . Set number of points for active integration rule. . For the GSL adaptive integrator, n = 1,2,3,4,5,6 correspond to the 15,21,31,41,51,61-point integration rules.; For the GaussLegendre integrator, use values > 6, which correspond to the actual number of points being evaluated. . Definition at line 140 of file IntegratorOptions.h. Libraries for ROOT::Math::IntegratorOneDimOptions:. [legend]; The documentation for this class was generated from the following files:; math/mathcore/inc/Math/IntegratorOptions.h; math/mathcore/src/IntegratorOptions.cxx. ROOTMathIntegratorOneDimOptions. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDimOptions.html:8515,integrat,integrator,8515,doc/master/classROOT_1_1Math_1_1IntegratorOneDimOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDimOptions.html,5,['integrat'],"['integration', 'integrator']"
Integrability," ') const; TSubStringTString::SubString(const char* pat, Ssiz_t start = 0, TString::ECaseCompare cmp = kExact) const; TObjArray*TString::Tokenize(const TString& delim) const; Bool_tTString::Tokenize(TString& tok, Ssiz_t& from, const char* delim = "" "") const; voidTString::ToLower(); voidTString::ToUpper(); static voidTString::WriteString(TBuffer& b, const TString* a). protected:. static Ssiz_tTString::AdjustCapacity(Ssiz_t nc); voidTString::AssertElement(Ssiz_t nc) const; voidTString::Clobber(Ssiz_t nc); voidTString::Cow(); voidTString::Cow(Ssiz_t nc); voidTString::InitChar(char c); TStringRef*TString::Pref() const. Data Members; public:. enum TString::EStripType { kLeading; kTrailing; kBoth; };; enum TString::ECaseCompare { kExact; kIgnoreCase; };. protected:. char*TString::fDataref. counted data (TStringRef is in front). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGString(const TGString* s); cconstructor. void Draw(Drawable_t id, GContext_t gc, Int_t x, Int_t y); Draw string. void DrawWrapped(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, FontStruct_t font); Draw a string in a column with width w. If string is longer than; w wrap it to next line. Int_t GetLines(FontStruct_t font, UInt_t w); Get number of lines of width w the string would take using a certain font. TGString(); { }. TGString(const char* s); { }. TGString(Int_t number); { *this += number; }. TGString(const TGString* s). virtual ~TGString(); { }. Int_t GetLength() const; { return Length(); }. const char * GetString() const; { return Data(); }. void SetString(const char* s); { *this = s; }. » Author: Fons Rademakers 05/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGString.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGString.html:8155,wrap,wrap,8155,root/html528/TGString.html,https://root.cern,https://root.cern/root/html528/TGString.html,1,['wrap'],['wrap']
Integrability," 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:64273,integrat,integration,64273,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['integrat'],['integration']
Integrability," 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::unique_ptr< RooPolyFunc > taylorExpand (const char *name, const char *title, RooAbsReal &func, const RooArgList &observables, int order=1, std::vector< double > const &observableValues={}, double eps1=1e-6, double eps2=1e-3);  Taylor expanding given function in terms of observables around observableValues. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPolyFunc.html:46425,integrat,integration,46425,doc/master/classRooPolyFunc.html,https://root.cern,https://root.cern/doc/master/classRooPolyFunc.html,1,['integrat'],['integration']
Integrability," 'no storing, no drawing' settings. ;  ; virtual void DoNumericSliderXChanged ();  Sincronize the numeric sliders with the graphical one. ;  ; virtual void DoNumericSliderYChanged ();  syncronize the numeric slider with the graphical one. ;  ; virtual void DoPrintOpt (Bool_t on);  Slot connected to print option settings. ;  ; virtual void DoReset ();  Reset all fit parameters. ;  ; virtual void DoRobustFit ();  Slot connected to 'robust fitting' option settings. ;  ; virtual void DoSetParameters ();  Open set parameters dialog. ;  ; virtual void DoSliderXMoved ();  Slot connected to range settings on x-axis. ;  ; virtual void DoSliderYMoved ();  Slot connected to range settings on y-axis. ;  ; virtual void DoSliderZMoved ();  Slot connected to range settings on z-axis. ;  ; virtual void DoUpdate ();  Easy here! ;  ; virtual void DoUseFuncRange ();  ; virtual void DoUserDialog ();  Open a dialog for getting a user defined method. ;  ; void FillFunctionList (Int_t selected=-1);  Fills the list of functions depending on the type of fit selected. ;  ; void FillMinMethodList (Int_t selected=-1);  Fills the list of methods depending on the minimization library selected. ;  ; Option_t * GetDrawOption () const override;  Get draw options of the selected object. ;  ; TList * GetListOfFittingFunctions (TObject *obj=nullptr);  ; virtual void Hide ();  Hide the fit panel and set it to non-active state. ;  ; void RecursiveRemove (TObject *obj) override;  When obj is deleted, clear fFitObject if fFitObject = obj. ;  ; virtual void SetFitObject (TVirtualPad *pad, TObject *obj, Int_t event);  Slot called when the user clicks on an object inside a canvas. ;  ; virtual void SetFunction (const char *function);  Set the function to be used in performed fit. ;  ; Bool_t SetObjectType (TObject *obj);  Check whether the object suitable for fitting and set its type, dimension and method combo box accordingly. ;  ; virtual void Show (TVirtualPad *pad, TObject *obj);  Show the fit panel (pos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFitEditor.html:8740,depend,depending,8740,doc/master/classTFitEditor.html,https://root.cern,https://root.cern/doc/master/classTFitEditor.html,1,['depend'],['depending']
Integrability," ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSystem; virtual void DoBeep (Int_t=-1, Int_t=-1) const;  ; virtual const char * ExpandFileName (const char *fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; virtual Bool_t ExpandFileName (TString &fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; TSystem * FindHelper (const char *path, void *dirptr=nullptr);  Create helper TSystem to handle file and directory operations that might be special for remote file access. ;  ; TString & GetLastErrorString ();  Return the thread local storage for the custom last error message. ;  ; const TString & GetLastErrorString () const;  Return the thread local storage for the custom last error message. ;  ; virtual const char * GetLinkedLibraries ();  Get list of shared libraries loaded at the start of the executable. ;  ; virtual void SigAlarmInterruptsSyscalls (Bool_t);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from TSystem; static const char * StripOffProto (const char *path, const char *proto);  Strip off protocol string from specified path. ;  ;  Protected Attributes inherited from TSystem; EAclicMode fAclicMode {kDefault};  ; Int_t fAclicProperties {0};  ; Int_t fBeepDuration {0};  ; Int_t fBeepFreq {0};  ; TString fBuildArch;  ; TString fBuildCompiler;  ; TString fBuildCompilerVersion;  ; TString fBuildCompilerVersionStr;  ; TString fBuildDir;  ; TString fBuildNode;  ; TSeqCollection * fCompiled {nullptr}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixSystem.html:31209,message,message,31209,doc/master/classTDavixSystem.html,https://root.cern,https://root.cern/doc/master/classTDavixSystem.html,2,['message'],['message']
Integrability," ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TSocket; enum  ESocketErrors { kInvalid = -1; , kInvalidStillInList = -2; };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSocket;  TSocket ();  ; Bool_t Authenticate (const char *user);  Authenticated the socket with specified user. ;  ; void MarkBrokenConnection ();  Close the socket and mark as due to a broken connection. ;  ; Bool_t RecvProcessIDs (TMessage *mess);  Receive a message containing process ids. ;  ; Bool_t RecvStreamerInfos (TMessage *mess);  Receive a message containing streamer infos. ;  ; void SendProcessIDs (const TMessage &mess);  Check if TProcessIDs must be sent. ;  ; void SendStreamerInfos (const TMessage &mess);  Check if TStreamerInfo must be sent. ;  ; void SetDescriptor (Int_t desc);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TSocket; TInetAddress fAddress;  ; TBits fBitsInfo;  ; UInt_t fBytesRecv;  ; UInt_t fBytesSent;  ; Int_t fCompress;  ; TTimeStamp fLastUsage;  ; TVirtualMutex * fLastUsageMtx;  ; TInetAddress fLocalAddress;  ; Int_t fRemoteProtocol;  ; TSecContext * fSecContext;  ; TString fService;  ; EServiceType fServType;  ; Int_t fSocket;  ; Int_t fTcpWindowSize;  ; TString fUrl;  ; TList * fUUIDs;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Prote",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPServerSocket.html:18271,message,message,18271,doc/master/classTPServerSocket.html,https://root.cern,https://root.cern/doc/master/classTPServerSocket.html,2,['message'],['message']
Integrability," () const;  ; virtual Int_t GetEntryExport (Long64_t entry, Int_t getall, TClonesArray *list, Int_t n);  Read all leaves of an entry and export buffers to real objects in a TClonesArray list. ;  ; Long64_t GetEntryNumber () const;  ; Int_t GetEntryOffsetLen () const;  ; Int_t GetEvent (Long64_t entry=0);  ; virtual Int_t GetExpectedType (TClass *&clptr, EDataType &type);  Fill expectedClass and expectedType with information on the data type of the object/values contained in this branch (and thus the type of pointers expected to be passed to Set[Branch]Address return 0 in case of success and > 0 in case of failure. ;  ; virtual TFile * GetFile (Int_t mode=0);  Return pointer to the file where branch buffers reside, returns 0 in case branch buffers reside in the same file as tree header. ;  ; const char * GetFileName () const;  ; Long64_t GetFirstEntry () const;  ; virtual TString GetFullName () const;  Return the 'full' name of the branch. ;  ; const char * GetIconName () const override;  Return icon name depending on type of branch. ;  ; TIOFeatures GetIOFeatures () const;  Returns the IO settings currently in use for this branch. ;  ; virtual TLeaf * GetLeaf (const char *name) const;  Return pointer to the 1st Leaf named name in thisBranch. ;  ; TObjArray * GetListOfBaskets ();  ; TObjArray * GetListOfBranches ();  ; TObjArray * GetListOfLeaves ();  ; virtual bool GetMakeClass () const;  Return whether this branch is in a mode where the object are decomposed or not (Also known as MakeClass mode). ;  ; Int_t GetMaxBaskets () const;  ; TBranch * GetMother () const;  Get our top-level parent branch in the tree. ;  ; Int_t GetNleaves () const;  ; Int_t GetOffset () const;  ; Int_t GetReadBasket () const;  ; Long64_t GetReadEntry () const;  ; virtual Int_t GetRow (Int_t row);  Return all elements of one row unpacked in internal array fValues [Actually just returns 1 (?)]. ;  ; Int_t GetSplitLevel () const;  ; TBranch * GetSubBranch (const TBranch *br) const;  Find the p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchClones.html:5480,depend,depending,5480,doc/master/classTBranchClones.html,https://root.cern,https://root.cern/doc/master/classTBranchClones.html,2,['depend'],['depending']
Integrability," ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Connect (const char *sender_class, const char *signal, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; void PMsgBox (const char *title, const char *msg, const TGPicture *icon, Int_t buttons, Int_t *ret_code, Int_t text_align);  Protected, common message dialog box initialization. ;  ;  Protected Member Functions inherited from TGMainFrame; TString GetMWMfuncString () const;  used in SaveSource() ;  ; TString GetMWMinpString () const;  used in SaveSource() ;  ; TString GetMWMvalueString () const;  used in SaveSource() ;  ;  Protected Member Functions inherited from TGFrame; void DoRedraw () override;  Redraw the frame. ;  ; virtual void Draw3dRectangle (UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h);  Draw 3D rectangle on the frame border. ;  ; TString GetOptionString () const;  Returns a frame option string - used in SavePrimitive(). ;  ; const TGResourcePool * GetResourcePool () const;  ; void * GetSender () override;  ; virtual void StartGuiBuilding (Bool_t on=kTRUE);  Go into GUI building mode. ;  ;  Protected Member Functions inherited from TGWindow;  TGWindow (const TGWindow &tgw);  ;  TGWindow (Window_t id);  ; TGWindow & operator= (const TGWindow &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGMsgBox.html:29083,message,message,29083,doc/master/classTGMsgBox.html,https://root.cern,https://root.cern/doc/master/classTGMsgBox.html,1,['message'],['message']
Integrability," ();  Pop on object drawn in a pad to the top of the display list. ;  ; virtual void Print (Option_t *option="""") const;  This method must be overridden when a class wants to print itself. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TGObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGResourcePool.html:9972,message,message,9972,doc/master/classTGResourcePool.html,https://root.cern,https://root.cern/doc/master/classTGResourcePool.html,1,['message'],['message']
Integrability," ();  Pop on object drawn in a pad to the top of the display list. ;  ; virtual void Print (Option_t *option="""") const;  This method must be overridden when a class wants to print itself. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGObject.html:7928,message,message,7928,doc/master/classTGObject.html,https://root.cern,https://root.cern/doc/master/classTGObject.html,1,['message'],['message']
Integrability," ();  To clean out all caches. ;  ; void ResetClassInfo ();  Make sure that the current ClassInfo is up to date. ;  ; void ResetClassInfo (Long_t tagnum);  Make sure that the current ClassInfo is up to date. ;  ; void ResetInstanceCount ();  ; void ResetMenuList ();  Resets the menu list to it's standard value. ;  ; void SetCanSplit (Int_t splitmode);  Set the splitability of this class: ;  ; void SetCollectionProxy (const ROOT::Detail::TCollectionProxyInfo &);  Create the collection proxy object (and the streamer object) from using the information in the TCollectionProxyInfo. ;  ; void SetContextMenuTitle (const char *title);  Change (i.e. set) the title of the TNamed. ;  ; void SetConvStreamerFunc (ClassConvStreamerFunc_t strm);  Set a wrapper/accessor function around this class custom conversion streamer. ;  ; void SetCurrentStreamerInfo (TVirtualStreamerInfo *info);  Set pointer to current TVirtualStreamerInfo. ;  ; void SetDeclFile (const char *name, Short_t line);  ; void SetDelete (ROOT::DelFunc_t deleteFunc);  Install a new wrapper around 'delete'. ;  ; void SetDeleteArray (ROOT::DelArrFunc_t deleteArrayFunc);  Install a new wrapper around 'delete []'. ;  ; void SetDestructor (ROOT::DesFunc_t destructorFunc);  Install a new wrapper around the destructor. ;  ; void SetDirectoryAutoAdd (ROOT::DirAutoAdd_t dirAutoAddFunc);  Install a new wrapper around the directory auto add function. ;  ; void SetGlobalIsA (IsAGlobalFunc_t);  This function installs a global IsA function for this class. ;  ; void SetImplFileName (const char *implFileName);  ; void SetLastReadInfo (TVirtualStreamerInfo *info);  ; void SetMemberStreamer (const char *name, MemberStreamerFunc_t strm);  Install a new member streamer (p will be copied). ;  ; void SetMerge (ROOT::MergeFunc_t mergeFunc);  Install a new wrapper around 'Merge'. ;  ; void SetNew (ROOT::NewFunc_t newFunc);  Install a new wrapper around 'new'. ;  ; void SetNewArray (ROOT::NewArrFunc_t newArrayFunc);  Install a new wrapper a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:23056,wrap,wrapper,23056,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['wrap'],['wrapper']
Integrability," (1 neuron) or softmax (more neurons) activation function. void DrawResult(Int_t index = 0, Option_t* option = ""test"") const; Draws the neural net output; It produces an histogram with the output for the two datasets.; Index is the number of the desired output neuron.; ""option"" can contain:; - test or train to select a dataset; - comp to produce a X-Y comparison plot; - nocanv to not create a new TCanvas for the plot. Bool_t DumpWeights(Option_t* filename = ""-"") const; Dumps the weights to a text file.; Set filename to ""-"" (default) to dump to the standard output. Bool_t LoadWeights(Option_t* filename = """"); Loads the weights from a text file conforming to the format; defined by DumpWeights. Double_t Evaluate(Int_t index, Double_t* params) const; Returns the Neural Net for a given set of input parameters; #parameters must equal #input neurons. void Export(Option_t* filename = ""NNfunction"", Option_t* language = ""C++"") const; Exports the NN as a function for any non-ROOT-dependant code; Supported languages are: only C++ , FORTRAN and Python (yet); This feature is also usefull if you want to plot the NN as; a function (TF1 or TF2). void Shuffle(Int_t* , Int_t ) const; Shuffle the Int_t index[n] in input.; Input:; index: the array to shuffle; n: the size of the array; Output:; index: the shuffled indexes; This method is used for stochastic training. void MLP_Stochastic(Double_t* ); One step for the stochastic method; buffer should contain the previous dw vector and will be updated. void MLP_Batch(Double_t* ); One step for the batch (stochastic) method.; DEDw should have been updated before calling this. void MLP_Line(Double_t* , Double_t* , Double_t ); Sets the weights to a point along a line; Weights are set to [origin + (dist * dir)]. void SteepestDir(Double_t* ); Sets the search direction to steepest descent. bool LineSearch(Double_t* , Double_t* ); Search along the line defined by direction.; buffer is not used but is updated with the new dw; so that it can be used b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiLayerPerceptron.html:28242,depend,dependant,28242,root/html534/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html534/TMultiLayerPerceptron.html,6,['depend'],['dependant']
Integrability," (18). The reason we use ; rather then. is to save storage, since. can be stored in the same matrix as. (TMultiDimFit::MakeCoefficients). The errors in; the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions [1]; (TMultiDimFit::MakeCoefficientErrors). Considerations. It's important to realize that the training sample should be; representive of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a interpolation, rahter then a extrapolation; [5]. Also, the independent variables need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. Define ; are the 5 dependent; quantities that define a track. Compute, for different values of ; , the tracks; through the magnetic field, and determine the corresponding; ; . Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; . Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent. Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; . To process data, using this parameteri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:10330,depend,dependence,10330,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,4,['depend'],['dependence']
Integrability," (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). overrideprotectedvirtual . Intercept a server redirection all and update list of dependents if necessary Specifically update the set proxy 'deps' which introduces the dependency on server value dirty flags of ourselves. ; Reimplemented from RooAbsPdf.; Definition at line 211 of file RooProjectedPdf.cxx. ◆ selfNormalized(). bool RooProjectedPdf::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 36 of file RooProjectedPdf.h. ◆ Streamer(). void RooProjectedPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooProjectedPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 73 of file RooProjectedPdf.h. Member Data Documentation. ◆ _cacheMgr. RooObjCacheManager RooProjectedPdf::_cacheMgr. mutableprotected . ! The cache manager ; Definition at line 64 of file RooProjectedPdf.h. ◆ deps. RooSetProxy RooProjectedPdf::deps. protected . dependents of this p.d.f ; Definition at line 54 of file RooProjectedPdf.h. ◆ intobs. RooSetProxy RooProjectedPdf::intobs. protected . observables that p.d.f is integrated over ; Definition at line 53 of file RooProjectedPdf.h. ◆ intpdf. RooRealProxy RooProjectedPdf::intpdf. protected . p.d.f that is integrated ; Definition at line 52 of file RooProjectedPdf.h. Libraries for RooProjectedPdf:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooProjectedPdf.h; roofit/roofitcore/src/RooProjectedPdf.cxx. RooProjectedPdf. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:06 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProjectedPdf.html:81556,depend,dependents,81556,doc/master/classRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classRooProjectedPdf.html,3,"['depend', 'integrat']","['dependents', 'integrated']"
Integrability," (GSL):; Numerical integration classes implementing the interface ROOT::Math::Integrator which is based on the Adaptive integration algorithms of QUADPACK; Numerical differentiation via ROOT::Math::GSLDerivator; Root finder implementing the ROOT::Math::RootFinder interface, using different solver algorithms from GSL; one-dimensional Minimization implementing the interfaceROOT::Math::IMinimizer1D; Interpolation via ROOT::Math::Interpolation. All the GSL interpolation types are supported; Function approximation based on Chebyshev polynomials via the class ROOT::Math::Chebyshev; Random number generators and distributions based on GSL using the ROOT::Math::Random<Engine_type> class.; Polynomial evaluation and root solvers. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document).The MathMore library is implemented wrapping in C++ the GNU Scientific Library ( ). Building MathMore requires a version of GSL larger or equal 1.8. The source code of MathMore is distributed under the GNU General Public License.; MathMore (and its ROOT Cling dictionary) can be built within ROOT whenever a GSL library is found in the system. The GSL library and header file location can be specified in the ROOT configure script, by doing:; ./configure --with-gsl-incdir=... --with-gsl-libdir=...; MathMore can be built also a stand-alone library (without requiring ROOT) downloding the tar file from the Web at this link. In this case the library will not contain the dictionary information and therefore cannot be used interactively; More information on the classes and functions present in MathMore is available in the online reference documentation.; 13.3 TMath; In the namespace, TMath, a collection of free functions is provided for the following functionality:. numerical constants (like pi, e, h, etc.);; trigonometric and elementar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:659844,wrap,wrapping,659844,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['wrap'],['wrapping']
Integrability," (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Forward calculation of analytical integrals to input p.d.f. ;  ; TObject * clone (const char *newname) const override;  ; std::unique_ptr< RooAbsReal > createExpectedEventsFunc (const RooArgSet *nset) const override;  Returns an object that represents the expected number of events for a given normalization set, similar to how createIntegral() returns an object that returns the integral. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; double expectedEvents (const RooArgSet *nset) const override;  Return the number of expected events over the full range of all variables. ;  ; ExtendMode extendMode () const override;  Returns ability of PDF to provide extended likelihood terms. ;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Forward determination of analytical integration capabilities to input p.d.f. ;  ; TClass * IsA () const override;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExtendPdf.html:2676,integrat,integration,2676,doc/master/classRooExtendPdf.html,https://root.cern,https://root.cern/doc/master/classRooExtendPdf.html,1,['integrat'],['integration']
Integrability," (Int_t x, Int_t y, const char *col=""#000000"") override;  Draw a point at the specified position. ;  ; void ReadImage (const char *file, EImageFileTypes type=TImage::kUnknown) override;  Read specified image file. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void Scale (UInt_t width, UInt_t height) override;  Scale the original image. ;  ; void SetEditable (Bool_t on=kTRUE) override;  ; void SetImage (ASImage *image);  ; void SetImage (const Double_t *imageData, UInt_t width, UInt_t height, TImagePalette *palette=nullptr) override;  Deletes the old image and creates a new image depending on the values of imageData. ;  ; void SetImage (const TArrayD &imageData, UInt_t width, TImagePalette *palette=nullptr) override;  Delete the old image and creates a new image depending on the values of imageData. ;  ; void SetImage (const TVectorD &imageData, UInt_t width, TImagePalette *palette=nullptr) override;  Delete the old image and creates a new image depending on the values of imageData. ;  ; void SetImage (Pixmap_t pxm, Pixmap_t mask=0) override;  Create image from pixmap. ;  ; Bool_t SetImageBuffer (char **buffer, EImageFileTypes type=TImage::kPng) override;  Create image from compressed buffer. ;  ; Bool_t SetJpegDpi (const char *name, UInt_t dpi=72);  Set an image printing resolution in Dots Per Inch units. ;  ; void SetPalette (const TImagePalette *palette) override;  Set a new palette to an image. ;  ; void SetPaletteEnabled (Bool_t on=kTRUE) override;  Switch on/off the image palette. ;  ; void SetTitle (const char *title="""") override;  Set a title for an image. ;  ; void Slice (UInt_t xStart, UInt_t xEnd, UInt_t yStart, UInt_t yEnd, UInt_t toWidth, UInt_t toHeight) override;  Another method of enlarging images where corners remain unchanged, but middle part gets tiled. ;  ; void StartPaletteEditor () override;  Start palette editor. ;  ; void Streamer (TBuffer &) overr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:12698,depend,depending,12698,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['depend'],['depending']
Integrability," (Methods); public:. virtual~IntegratorMultiDimOptions(); doubleROOT::Math::BaseIntegratorOptions::AbsTolerance() const; ROOT::Math::BaseIntegratorOptionsROOT::Math::BaseIntegratorOptions::BaseIntegratorOptions(const ROOT::Math::BaseIntegratorOptions& opt); static ROOT::Math::IOptions&Default(const char* name); static doubleDefaultAbsTolerance(); static stringDefaultIntegrator(); static ROOT::Math::IntegrationMultiDim::TypeDefaultIntegratorType(); static unsigned intDefaultNCalls(); static doubleDefaultRelTolerance(); static unsigned intDefaultWKSize(); ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::ExtraOptions() const; static ROOT::Math::IOptions*FindDefault(const char* name); virtual stringIntegrator() const; ROOT::Math::IntegratorMultiDimOptionsIntegratorMultiDimOptions(ROOT::Math::IOptions* extraOpts = 0); ROOT::Math::IntegratorMultiDimOptionsIntegratorMultiDimOptions(const ROOT::Math::IntegratorMultiDimOptions& rhs); ROOT::Math::IntegrationMultiDim::TypeIntegratorType() const; unsigned intNCalls() const; ROOT::Math::IntegratorMultiDimOptions&operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); voidPrint(ostream& os = std::cout) const; static voidPrintDefault(const char* name = 0, ostream& os = std::cout); doubleROOT::Math::BaseIntegratorOptions::RelTolerance() const; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNCalls(unsigned int ncall); static voidSetDefaultRelTolerance(double tol); static voidSetDefaultWKSize(unsigned int size); voidROOT::Math::BaseIntegratorOptions::SetExtraOptions(const ROOT::Math::IOptions& opt); voidSetIntegrator(const char* name); voidSetNCalls(unsigned int calls); voidROOT::Math::BaseIntegratorOptions::SetRelTolerance(double tol); voidROOT::Math::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. ROOT::M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__IntegratorMultiDimOptions.html:603,Integrat,IntegratorMultiDimOptions,603,root/html602/ROOT__Math__IntegratorMultiDimOptions.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__IntegratorMultiDimOptions.html,16,['Integrat'],"['IntegrationMultiDim', 'IntegratorMultiDimOptions', 'IntegratorMultiDimOptionsIntegratorMultiDimOptions']"
Integrability," (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXTRU.html:8341,message,message,8341,doc/master/classTXTRU.html,https://root.cern,https://root.cern/doc/master/classTXTRU.html,18,['message'],['message']
Integrability," (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileDrawMap.html:6739,message,message,6739,doc/master/classTFileDrawMap.html,https://root.cern,https://root.cern/doc/master/classTFileDrawMap.html,3,['message'],['message']
Integrability," (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAnnotation.html:15314,message,message,15314,doc/master/classTAnnotation.html,https://root.cern,https://root.cern/doc/master/classTAnnotation.html,8,['message'],['message']
Integrability," (TInetAddress addr, Int_t port, Int_t tcpwindowsize=-1);  ; virtual ~TSSLSocket ();  Close gracefully the connection, and free SSL structures. ;  ; void Close (Option_t *option="""") override;  Close the SSL connection. ;  ; TClass * IsA () const override;  ; Int_t Recv (char *mess, Int_t max) override;  Receive a character string message of maximum max length. ;  ; Int_t Recv (char *mess, Int_t max, Int_t &kind) override;  Receive a character string message of maximum max length. ;  ; Int_t Recv (Int_t &status, Int_t &kind) override;  Receives a status and a message type. ;  ; Int_t Recv (TMessage *&mess) override;  Receive a TMessage object. ;  ; Int_t RecvRaw (void *buffer, Int_t length, ESendRecvOptions opt=kDefault) override;  Receive a raw buffer of specified length bytes. ;  ; Int_t Send (const char *mess, Int_t kind=kMESS_STRING) override;  Send a character string buffer. ;  ; Int_t Send (const TMessage &mess) override;  Send a TMessage object. ;  ; Int_t Send (Int_t kind) override;  Send a single message opcode. ;  ; Int_t Send (Int_t status, Int_t kind) override;  Send a status and a single message opcode. ;  ; Int_t SendRaw (const void *buffer, Int_t length, ESendRecvOptions opt=kDefault) override;  Send a raw buffer of specified length. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TSocket;  TSocket (const char *host, const char *service, Int_t tcpwindowsize=-1);  Create a socket. ;  ;  TSocket (const char *host, Int_t port, Int_t tcpwindowsize=-1);  Create a socket; see CreateAuthSocket for the form of url. ;  ;  TSocket (const char *sockpath);  Create a socket in the Unix domain on 'sockpath'. ;  ;  TSocket (const TSocket &s);  TSocket copy ctor. ;  ;  TSocket (Int_t descriptor);  Create a socket. ;  ;  TSocket (Int_t descriptor, const char *sockpath);  Create a socket. ;  ;  TSocket (TInetAddress address, const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSSLSocket.html:1850,message,message,1850,doc/master/classTSSLSocket.html,https://root.cern,https://root.cern/doc/master/classTSSLSocket.html,1,['message'],['message']
Integrability," (TSessionViewer *gui, Int_t w, Int_t h);  Create a Upload DataSet dialog box. Used to create and upload a dataset. ;  ;  ~TUploadDataSetDlg () override;  Delete chain dialog. ;  ; void AddFiles (const char *fileName);  Add File name(s) from the file location URL to the list view. ;  ; void AddFiles (TList *fileList);  Add File name(s) from the file location URL to the list view. ;  ; void BrowseFiles ();  Opens the TGFileDialog to allow user to select local file(s) to be added in the list view of dataset files. ;  ; void ClearFiles ();  Clear content of the list view. ;  ; void CloseWindow () override;  Close upload dataset dialog. ;  ; TClass * IsA () const override;  ; void OnAppendFiles (Bool_t on);  Notification of Append Files check button. ;  ; void OnOverwriteDataset (Bool_t on);  Notification of Overwrite Dataset check button. ;  ; void OnOverwriteFiles (Bool_t on);  Notification of Overwrite Files check button. ;  ; Bool_t ProcessMessage (Longptr_t msg, Longptr_t parm1, Longptr_t parm2) override;  Process messages for upload dataset dialog. ;  ; void RemoveFile ();  Remove the selected entry from the list view. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UploadDataSet ();  Upload the dataset to the server. ;  ;  Public Member Functions inherited from TGTransientFrame;  TGTransientFrame (const TGWindow *p=nullptr, const TGWindow *main=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=kVerticalFrame);  Create a transient window. ;  ; virtual void CenterOnParent (Bool_t croot=kTRUE, EPlacement pos=kCenter);  Position transient frame centered relative to the parent frame. ;  ; const TGWindow * GetMain () const;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a transient frame widget as a C++ statement(s) on output stream out. ;  ; void SaveSource (const char *filename=""Rootdlog.C"", Option_t *option="""") override;  Save the GUI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUploadDataSetDlg.html:1413,message,messages,1413,doc/master/classTUploadDataSetDlg.html,https://root.cern,https://root.cern/doc/master/classTUploadDataSetDlg.html,1,['message'],['messages']
Integrability," (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constructor. ;  ;  RooAbsArg (const char *name, const char *title);  Create an object with the specified name and descriptive title. ;  ;  RooAbsArg (const RooAbsArg &other, const char *name=nullptr);  Copy constructor transfers all boolean and string properties of the original object. ;  ;  ~RooAbsArg () override;  Destructor. ;  ; bool addOwnedComponents (const RooAbsCollection &comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooAbsCollection &&comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooArgList",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:28058,integrat,integrator,28058,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['integrat'],['integrator']
Integrability," (const char *) const;  ; virtual bool importWorkspaceHook (RooWorkspace &ws);  ; virtual bool inRange (const char *) const;  ; virtual bool isCategory () const;  ; bool isConstant () const;  Check if the ""Constant"" attribute is set. ;  ; virtual bool isDerived () const;  Does value or shape of this arg depend on any other arg? ;  ; virtual bool isIdentical (const RooAbsArg &other, bool assumeSameType=false) const =0;  ; virtual bool isReducerNode () const;  ; bool IsSortable () const override;  ; bool localNoDirtyInhibit () const;  ; const TNamed * namePtr () const;  De-duplicated pointer to this object's name. ;  ; Int_t numProxies () const;  Return the number of registered proxies. ;  ; bool observableOverlaps (const RooAbsData *dset, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; bool observableOverlaps (const RooArgSet *depList, const RooAbsArg &testArg) const;  Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ;  ; RooAbsArg & operator= (const RooAbsArg &other)=delete;  ; virtual bool operator== (const RooAbsArg &other) const =0;  ; bool overlaps (const RooAbsArg &testArg, bool valueOnly=false) const;  Test if any of the nodes of tree are shared with that of the given tree. ;  ; const RooArgSet * ownedComponents () const;  ; void Print (Option_t *options=nullptr) const override;  Print the object to the defaultPrintStream(). ;  ; void printAddress (std::ostream &os) const override;  Print address of this RooAbsArg. ;  ; void printArgs (std::ostream &os) const override;  Print object arguments, ie its proxies. ;  ; void printClassName (std::ostream &os) const override;  Print object class name. ;  ; void printCompactTree (const char *indent="""", const char *fileName=nullptr, const char *namePat=nullptr, RooAbsArg *client=nullptr);  Print tree structure of expression tree on stdout, or to fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:12498,depend,dependents,12498,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['depend'],['dependents']
Integrability," (data are copied inside according to the given range) or a 2D data set + weights. ; If is weighted dataZ is the pointer to the list of the weights ; Definition at line 161 of file UnBinData.h. ◆ UnBinData() [11/12]. template<class Iterator > . ROOT::Fit::UnBinData::UnBinData ; (; unsigned int ; maxpoints, . unsigned int ; dim, . Iterator ; dataItr, . const DataRange & ; range, . bool ; isWeighted = false . ). inline . constructor for multi-dim external data and a range (data are copied inside according to the range) Uses as argument an iterator of a list (or vector) containing the const double * of the data An example could be the std::vector<const double *>::begin ; Definition at line 174 of file UnBinData.h. ◆ UnBinData() [12/12]. ROOT::Fit::UnBinData::UnBinData ; (; const UnBinData & ; rhs). copy constructor ; Definition at line 24 of file UnBinData.cxx. ◆ ~UnBinData(). ROOT::Fit::UnBinData::~UnBinData ; (; ). inlineoverride . destructor, delete pointer to internal data or external data wrapper ; Definition at line 189 of file UnBinData.h. Member Function Documentation. ◆ Add() [1/5]. void ROOT::Fit::UnBinData::Add ; (; const double * ; x). inline . add multi-dim coordinate data ; Definition at line 230 of file UnBinData.h. ◆ Add() [2/5]. void ROOT::Fit::UnBinData::Add ; (; const double * ; x, . double ; w . ). inline . add multi-dim coordinate data + weight ; Definition at line 238 of file UnBinData.h. ◆ Add() [3/5]. void ROOT::Fit::UnBinData::Add ; (; double ; x). inline . add one dim coordinate data (unweighted) ; Definition at line 195 of file UnBinData.h. ◆ Add() [4/5]. void ROOT::Fit::UnBinData::Add ; (; double ; x, . double ; y . ). inline . add 2-dim coordinate data can also be used to add 1-dim data with a weight ; Definition at line 207 of file UnBinData.h. ◆ Add() [5/5]. void ROOT::Fit::UnBinData::Add ; (; double ; x, . double ; y, . double ; z . ). inline . add 3-dim coordinate data can also be used to add 2-dim data with a weight ; Definition at line",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1UnBinData.html:14258,wrap,wrapper,14258,doc/master/classROOT_1_1Fit_1_1UnBinData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1UnBinData.html,1,['wrap'],['wrapper']
Integrability," (default); RooArgSetfNuisanceParametersnuisance parameters; RooAbsPdf*fNuisancePdfnuisance pdf (needed when using nuisance sampling technique); intfNumIterationsnumber of iterations (when using ToyMC); RooArgSetfPOIPOI; RooAbsPdf*fPdfmodel pdf (could contain the nuisance pdf as constraint term); ROOT::Math::IBaseFunctionOneDim*fPosteriorFunctionfunction representing the posterior; RooAbsPdf*fPosteriorPdfnormalized (on the poi) posterior pdf ; RooAbsPdf*fPriorPdfprior pdf (typically for the POI); RooAbsPdf*fProductPdfinternal pointer to model * prior; doublefSizesize used for getting the interval; Double_tfUpperupper interval bound; Bool_tfValidInterval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BayesianCalculator(); default constructor. BayesianCalculator( /* const char* name, const char* title, */ RooAbsData& data, RooAbsPdf& pdf,						 const RooArgSet& POI,						 RooAbsPdf& priorPdf,						 const RooArgSet* nuisanceParameters ); Constructor from data set, model pdf, parameter of interests and prior pdf; If nuisance parameters are given they will be integrated according either to the prior or; their constraint term included in the model. BayesianCalculator(RooAbsData& data, RooStats::ModelConfig& model); Constructor from a data set and a ModelConfig; model pdf, poi and nuisances will be taken from the ModelConfig. ~BayesianCalculator(); destructor. void ClearAll() const; clear all cached pdf objects. void SetModel(const RooStats::ModelConfig& model); set the model to use; The model pdf, prior pdf, parameter of interest and nuisances; will be taken according to the model. RooAbsReal* GetPosteriorFunction() const; Build and return the posterior function (not normalized) as a RooAbsReal; the posterior is obtained from the product of the likelihood function and the; prior pdf which is then intergated in the nuisance parameters (if existing).; A prior function for the nuisance can be specified either in the prior pdf objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__BayesianCalculator.html:10979,integrat,integrated,10979,root/html534/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html534/RooStats__BayesianCalculator.html,2,['integrat'],['integrated']
Integrability," (element) {; 2818 expectedClass = element->GetClassPointer();; 2819 if (!expectedClass) {; 2820 TDataType* data = gROOT->GetType(element->GetTypeNameBasic());; 2821 if (!data) {; 2822 Error(""GetExpectedType"", ""Did not find the type number for %s"", element->GetTypeNameBasic());; 2823 return 1;; 2824 } else {; 2825 expectedType = (EDataType) data->GetType();; 2826 }; 2827 }; 2828 } else {; 2829 Error(""GetExpectedType"", ""Did not find the type for %s"",GetName());; 2830 return 2;; 2831 }; 2832 }; 2833 return 0;; 2834}; 2835 ; 2836////////////////////////////////////////////////////////////////////////////////; 2837/// Return the 'full' name of the branch. In particular prefix the mother's name; 2838/// when it does not end in a trailing dot and thus is not part of the branch name; 2839TString TBranchElement::GetFullName() const; 2840{; 2841 TBranchElement* mother = static_cast<TBranchElement*>(GetMother());; 2842 if (!mother || mother==this || mother->GetType() == 3 || mother->GetType() == 4) {; 2843 // The parent's name is already included in the name for split TClonesArray and STL collections; 2844 return fName;; 2845 }; 2846 ; 2847 return TBranch::GetFullName();; 2848}; 2849 ; 2850////////////////////////////////////////////////////////////////////////////////; 2851/// Return icon name depending on type of branch element.; 2852 ; 2853const char* TBranchElement::GetIconName() const; 2854{; 2855 if (IsFolder()) {; 2856 return ""TBranchElement-folder"";; 2857 } else {; 2858 return ""TBranchElement-leaf"";; 2859 }; 2860}; 2861 ; 2862////////////////////////////////////////////////////////////////////////////////; 2863/// Return whether this branch is in a mode where the object are decomposed; 2864/// or not (Also known as MakeClass mode).; 2865 ; 2866bool TBranchElement::GetMakeClass() const; 2867{; 2868 return TestBit(kDecomposedObj); // Same as TestBit(kMakeClass); 2869}; 2870 ; 2871////////////////////////////////////////////////////////////////////////////////; 2872/// Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:101929,depend,depending,101929,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['depend'],['depending']
Integrability," (if any) or store the number of elements that the leaf contains in countval. ;  ; virtual const Counts_t * GetLeafCountValues (Long64_t start, Long64_t len);  If this branch is a branch count, return the set of collection size for the entry range requested start: first entry to read and return information about len: number of entries to read. ;  ; virtual Int_t GetLen () const;  Return the number of effective elements of this leaf, for the current entry. ;  ; virtual Int_t GetLenStatic () const;  Return the fixed length of this leaf. ;  ; virtual Int_t GetLenType () const;  ; virtual Int_t GetMaximum () const;  ; virtual Int_t GetMinimum () const;  ; virtual Int_t GetNdata () const;  ; virtual Int_t GetOffset () const;  ; template<typename T > ; T GetTypedValue (Int_t i=0) const;  ; virtual Double_t GetValue (Int_t i=0) const;  ; virtual Long64_t GetValueLong64 (Int_t i=0) const;  ; virtual LongDouble_t GetValueLongDouble (Int_t i=0) const;  ; virtual void Import (TClonesArray *, Int_t);  ; virtual bool IncludeRange (TLeaf *);  ; virtual bool IsRange () const;  ; virtual bool IsUnsigned () const;  ; virtual void ReadBasketExport (TBuffer &, TClonesArray *, Int_t);  ; virtual bool ReadBasketFast (TBuffer &, Long64_t);  ; virtual bool ReadBasketSerialized (TBuffer &, Long64_t);  ; virtual void ReadValue (std::istream &, Char_t=' ');  ; Int_t ResetAddress (void *add, bool calledFromDestructor=false);  Helper routine for TLeafX::SetAddress. ;  ; virtual void SetBranch (TBranch *branch);  ; virtual void SetLeafCount (TLeaf *leaf);  Set the leaf count of this leaf. ;  ; virtual void SetLen (Int_t len=1);  ; virtual void SetOffset (Int_t offset=0);  ; virtual void SetRange (bool range=true);  ; virtual void SetUnsigned ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafObject.html:5293,rout,routine,5293,doc/master/classTLeafObject.html,https://root.cern,https://root.cern/doc/master/classTLeafObject.html,1,['rout'],['routine']
Integrability," (m) ;  CRoo1DTable;  CRoo2DKeysPdfTwo-dimensional kernel estimation PDF ;  ►CRoo2DMomentMorphFunction2-dimensional morph function between a list of function-numbers as a function of two input parameters (m1 and m2) ;  CSorterL2H;  ►CRooAbsAnaConvPdf;  CCacheElemIterator over _convNormSet ;  CRooAbsArgRooAbsArg is the common abstract base class for objects that represent a value (of arbitrary type) and ""shape"" that in general depends on (is a client of) other RooAbsArg subclasses ;  CRooAbsBinning;  CRooAbsCache;  ►CRooAbsCachedPdf;  CAnaIntConfigRegistry for analytical integration codes ;  CPdfCacheElem;  ►CRooAbsCachedReal;  CFuncCacheElem;  CRooAbsCacheElement;  CRooAbsCategory;  CRooAbsCategoryLValue;  CRooAbsCollection;  ►CRooAbsData;  CPlotOpt;  CRooAbsDataStore;  CRooAbsFunc;  CRooAbsGenContext;  CRooAbsHiddenReal;  CRooAbsIntegrator;  CRooAbsLValue;  CRooAbsMCStudyModule;  CRooAbsMoment;  CRooAbsNumGenerator;  CRooAbsOptTestStatistic;  ►CRooAbsPdfRooAbsPdf is the abstract interface for all probability density functions The class provides hybrid analytical/numerical normalization for its implementations, error tracing and a MC generator interface ;  CCacheElemNormalization set with for above integral ;  CGenSpec;  CRooAbsProxy;  ►CRooAbsRealRooAbsReal is the common abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to construct integrals of them, the ability to advertise (partial) analytical integrals etc ;  CEvalError;  CPlotOpt;  CRooAbsRealLValue;  CRooAbsRootFinder;  CRooAbsSelfCachedPdf;  CRooAbsSelfCachedReal;  CRooAbsString;  CRooAbsStudy;  CRooAbsTestStatistic;  CRooAcceptReject;  CRooAdaptiveGaussKronrodIntegrator1D;  CRooAdaptiveIntegratorND;  CRooAddGenContext;  ►CRooAddition;  CCacheElemIterator over set ;  ►CRooAddModel;  CCacheElemTransiet cache with transformed values of coefficients ;  CIntCacheElem;  ►CRooAddPdf;  CCacheElemTransiet cache",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:80276,interface,interface,80276,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['interface'],['interface']
Integrability," (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet!; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProjectedPdf.html:40918,integrat,integration,40918,root/html534/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html534/RooProjectedPdf.html,2,['integrat'],['integration']
Integrability," (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenericPdf.html:42667,integrat,integration,42667,root/html602/RooGenericPdf.html,https://root.cern,https://root.cern/root/html602/RooGenericPdf.html,4,['integrat'],['integration']
Integrability," (required by base class) ;  ; bool GetDomain (int &xmin, int &xmax) const;  check if distribution has domain and return in case its domain ;  ; bool HasCdf () const;  flag to control if distribution provides also a Cdf ;  ; bool HasMode () const;  flag to control if distribution provides the mode ;  ; bool HasProbSum () const;  flag to control if distribution provides the total area of the probability function ;  ; TClass * IsA () const override;  ; int Mode () const;  get the mode (x location of function maximum) ;  ; TUnuranDiscrDist & operator= (const TUnuranDiscrDist &rhs);  Assignment operator. ;  ; double Pmf (int x) const;  evaluate the distribution (probability mesh function) at the integer value x. ;  ; double ProbSum () const;  return area of the pdf ;  ; const std::vector< double > & ProbVec () const;  retrieve a reference to the vector of the probabilities : Prob(i) If the distribution is defined from a function (i.e. ;  ; void SetCdf (const ROOT::Math::IGenFunction &cdf);  set cdf distribution from a generic function interface. ;  ; void SetCdf (TF1 *cdf);  set cdf distribution from a TF1 pointer. ;  ; void SetDomain (int xmin, int xmax);  Set the distribution domain, by default the domain is [0,INT_MAX] If xmin >= xmax a domain is removed. ;  ; void SetMode (int mode);  set the mode of the distribution (location of maximum probability) ;  ; void SetProbSum (double sum);  set the value of the sum of the probabilities in the given domain ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TUnuranBaseDist; virtual ~TUnuranBaseDist ();  Destructor (no operations) ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnuranDiscrDist.html:3062,interface,interface,3062,doc/master/classTUnuranDiscrDist.html,https://root.cern,https://root.cern/doc/master/classTUnuranDiscrDist.html,1,['interface'],['interface']
Integrability," (ret == 0) { //can't compile a macro; 814 return 2;; 815 }; 816 //end(3); 817 return 0;; 818}; 819 ; 820int TCling_GenerateDictionary(const std::string& className,; 821 const std::vector<std::string> &headers,; 822 const std::vector<std::string> &fwdDecls,; 823 const std::vector<std::string> &unknown); 824{; 825 //This function automatically creates the ""LinkDef.h"" file for templated; 826 //classes then executes CompileMacro on it.; 827 //The name of the file depends on the class name, and it's not generated again; 828 //if the file exist.; 829 std::vector<std::string> classes;; 830 classes.push_back(className);; 831 return TCling_GenerateDictionary(classes, headers, fwdDecls, unknown);; 832}; 833 ; 834//______________________________________________________________________________; 835//; 836//; 837//; 838 ; 839// It is a ""fantom"" method to synchronize user keyboard input; 840// and ROOT prompt line (for WIN32); 841const char* fantomline = ""TRint::EndOfLineAction();"";; 842 ; 843//______________________________________________________________________________; 844//; 845//; 846//; 847 ; 848void* TCling::fgSetOfSpecials = nullptr;; 849 ; 850//______________________________________________________________________________; 851//; 852// llvm error handler through exceptions; see also cling/UserInterface; 853//; 854namespace {; 855 // Handle fatal llvm errors by throwing an exception.; 856 // Yes, throwing exceptions in error handlers is bad.; 857 // Doing nothing is pretty terrible, too.; 858 void exceptionErrorHandler(void * /*user_data*/,; 859 const char *reason,; 860 bool /*gen_crash_diag*/) {; 861 throw std::runtime_error(std::string("">>> Interpreter compilation error:\n"") + reason);; 862 }; 863}; 864 ; 865//______________________________________________________________________________; 866//; 867//; 868//; 869 ; 870////////////////////////////////////////////////////////////////////////////////; 871 ; 872namespace{; 873 // An instance of this class causes the diagno",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:29893,synchroniz,synchronize,29893,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['synchroniz'],['synchronize']
Integrability," (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(a,b). double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html:7592,integrat,integration,7592,root/html526/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html,1,['integrat'],['integration']
Integrability," )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <RooCmdConfig.h>. Inheritance diagram for RooCmdConfig:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooCmdConfig() [1/2]. RooCmdConfig::RooCmdConfig ; (; RooStringView ; methodName). Constructor taking descriptive name of owner/user which is used as prefix for any warning or error messages generated by this parser. ; Definition at line 59 of file RooCmdConfig.cxx. ◆ RooCmdConfig() [2/2]. RooCmdConfig::RooCmdConfig ; (; const RooCmdConfig & ; other). Copy constructor. ; Definition at line 84 of file RooCmdConfig.cxx. Member Function Documentation. ◆ allowUndefined(). void RooCmdConfig::allowUndefined ; (; bool ; flag = true). inline . If flag is true the processing of unrecognized RooCmdArgs is not considered an error. ; Definition at line 44 of file RooCmdConfig.h. ◆ Class(). static TClass * RooCmdConfig::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCmdConfig::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooCmdConfig::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 135 of file RooCmdConfig.h. ◆ DeclFileName(). static const char * RooCmdConfig::DeclFileName ; (; ). inlinest",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCmdConfig.html:17115,message,messages,17115,doc/master/classRooCmdConfig.html,https://root.cern,https://root.cern/doc/master/classRooCmdConfig.html,1,['message'],['messages']
Integrability," ). inline . Definition at line 88 of file MethodBoost.h. ◆ GetBoostROCIntegral(). Double_t TMVA::MethodBoost::GetBoostROCIntegral ; (; Bool_t ; singleMethod, . Types::ETreeType ; eTT, . Bool_t ; CalcOverlapIntergral = kFALSE . ). private . Calculate the ROC integral of a single classifier or even the whole boosted classifier. ; The tree type (training or testing sample) is specified by 'eTT'.; If tree type kTraining is set, the original training sample is used to compute the ROC integral (original weights). singleMethod - if kTRUE, return ROC integral of single (last trained) classifier; if kFALSE, return ROC integral of full classifier; eTT - tree type (Types::kTraining / Types::kTesting); CalcOverlapIntergral - if kTRUE, the overlap integral of the signal/background MVA distributions is calculated and stored in 'fOverlap_integral' . Definition at line 1156 of file MethodBoost.cxx. ◆ GetHelpMessage(). void TMVA::MethodBoost::GetHelpMessage ; (; ); const. protectedvirtual . Get help message text. ; typical length of text line: ""|--------------------------------------------------------------|"" ; Implements TMVA::IMethod.; Definition at line 1049 of file MethodBoost.cxx. ◆ GetMvaValue(). Double_t TMVA::MethodBoost::GetMvaValue ; (; Double_t * ; err = nullptr, . Double_t * ; errUpper = nullptr . ). virtual . return boosted MVA response ; Implements TMVA::MethodBase.; Definition at line 1095 of file MethodBoost.cxx. ◆ HasAnalysisType(). Bool_t TMVA::MethodBoost::HasAnalysisType ; (; Types::EAnalysisType ; type, . UInt_t ; numberClasses, . UInt_t ;  . ). virtual . Boost can handle classification with 2 classes and regression with one regression-target. ; Implements TMVA::IMethod.; Definition at line 166 of file MethodBoost.cxx. ◆ Init(). void TMVA::MethodBoost::Init ; (; void ; ). privatevirtual . Implements TMVA::MethodBase.; Definition at line 264 of file MethodBoost.cxx. ◆ InitHistos(). void TMVA::MethodBoost::InitHistos ; (; ). private . initialisation routine ; Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBoost.html:37699,message,message,37699,doc/master/classTMVA_1_1MethodBoost.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBoost.html,1,['message'],['message']
Integrability," ). virtual . Receives a status and a message type. ; Returns length of received integers, 2*sizeof(Int_t) (can be 0 if other side of connection is closed) or -1 in case of error or -4 in case a non-blocking socket would block (i.e. there is nothing to be read). ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 789 of file TSocket.cxx. ◆ Recv() [4/4]. Int_t TSocket::Recv ; (; TMessage *& ; mess). virtual . Receive a TMessage object. ; The user must delete the TMessage object. Returns length of message in bytes (can be 0 if other side of connection is closed) or -1 in case of error or -4 in case a non-blocking socket would block (i.e. there is nothing to be read) or -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 818 of file TSocket.cxx. ◆ RecvProcessIDs(). Bool_t TSocket::RecvProcessIDs ; (; TMessage * ; mess). protected . Receive a message containing process ids. ; In case the message contains process ids they are imported, the message will be deleted and the method returns kTRUE. ; Definition at line 975 of file TSocket.cxx. ◆ RecvRaw(). Int_t TSocket::RecvRaw ; (; void * ; buffer, . Int_t ; length, . ESendRecvOptions ; opt = kDefault . ). virtual . Receive a raw buffer of specified length bytes. ; Using option kPeek one can peek at incoming data. Returns number of received bytes. Returns -1 in case of error. In case of opt == kOob: -2 means EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock) -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 898 of file TSocket.cxx. ◆ RecvStreamerInfos(). Bool_t TSocket::RecvStreamerInfos ; (; TMessage * ; mess). protected . Receive a message containing streamer infos. ; In case the message contains streamer infos they are imported, the message will be delet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:33096,message,message,33096,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['message'],['message']
Integrability, ). virtual . ◆ StreamerNVirtual(). void TMVA::Config::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 148 of file Config.h. ◆ UseColor(). Bool_t TMVA::Config::UseColor ; (; ); const. inline . Definition at line 59 of file Config.h. ◆ WriteOptionsReference(). Bool_t TMVA::Config::WriteOptionsReference ; (; ); const. inline . Definition at line 65 of file Config.h. Member Data Documentation. ◆ fDrawProgressBar. std::atomic<Bool_t> TMVA::Config::fDrawProgressBar. private . draw progress bar to indicate training evolution ; Definition at line 140 of file Config.h. ◆ fExecutor. Executor TMVA::Config::fExecutor. protected . Definition at line 52 of file Config.h. ◆ fgConfigPtr. std::atomic< TMVA::Config * > TMVA::Config::fgConfigPtr { 0 }. staticprivate . Definition at line 137 of file Config.h. ◆ fIONames. class TMVA::Config::IONames TMVA::Config::fIONames. ◆ fLogger. MsgLogger* TMVA::Config::fLogger. mutableprivate . ! message logger ; Definition at line 145 of file Config.h. ◆ fNWorkers. std::atomic<UInt_t> TMVA::Config::fNWorkers. private . Default number of workers for multi-process jobs. ; Definition at line 141 of file Config.h. ◆ fSilent. std::atomic<Bool_t> TMVA::Config::fSilent. private . no output at all ; Definition at line 143 of file Config.h. ◆ fUseColoredConsole. std::atomic<Bool_t> TMVA::Config::fUseColoredConsole. private . coloured standard output ; Definition at line 142 of file Config.h. ◆ fVariablePlotting. class TMVA::Config::VariablePlotting TMVA::Config::fVariablePlotting. ◆ fWriteOptionsReference. std::atomic<Bool_t> TMVA::Config::fWriteOptionsReference. private . if set true: Configurable objects write file with option reference ; Definition at line 144 of file Config.h. Libraries for TMVA::Config:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/Config.h; tmva/tmva/src/Config.cxx. TMVAConfig. ROOT master - Reference Guide Generated on Tue Nov 5 2,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Config.html:7835,message,message,7835,doc/master/classTMVA_1_1Config.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Config.html,1,['message'],['message']
Integrability," ); 2207 //; 2208 // on frame. If frame contains a histogram, all dimensions of the plotted; 2209 // asymmetry function that occur in the previously plotted dataset are projected via partial integration.; 2210 // Otherwise no projections are performed,; 2211 //; 2212 // The asymmetry function can be multiplied with an optional scale factor. The default projection; 2213 // behaviour can be overridden by supplying an optional set of dependents to project.; 2214 ; 2215 // Sanity checks; 2216 if (plotSanityChecks(frame)) return frame ;; 2217 ; 2218 // ProjDataVars is either all projData observables, or the user indicated subset of it; 2219 RooArgSet projDataVars ;; 2220 if (o.projData) {; 2221 if (o.projDataSet) {; 2222 std::unique_ptr<RooArgSet> tmp{o.projData->get()->selectCommon(*o.projDataSet)};; 2223 projDataVars.add(*tmp) ;; 2224 } else {; 2225 projDataVars.add(*o.projData->get()) ;; 2226 }; 2227 }; 2228 ; 2229 // Must depend on asymCat; 2230 if (!dependsOn(asymCat)) {; 2231 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2232 << "") function doesn't depend on asymmetry category "" << asymCat.GetName() << std::endl ;; 2233 return frame ;; 2234 }; 2235 ; 2236 // asymCat must be a signCat; 2237 if (!asymCat.isSignType()) {; 2238 coutE(Plotting) << ""RooAbsReal::plotAsymOn("" << GetName(); 2239 << "") asymmetry category must have 2 or 3 states with index values -1,0,1"" << std::endl ;; 2240 return frame ;; 2241 }; 2242 ; 2243 // Make list of variables to be projected; 2244 RooArgSet projectedVars ;; 2245 RooArgSet sliceSet ;; 2246 if (o.projSet) {; 2247 makeProjectionSet(frame->getPlotVar(),o.projSet,projectedVars,false) ;; 2248 ; 2249 // Print list of non-projected variables; 2250 if (frame->getNormVars()) {; 2251 RooArgSet sliceSetTmp;; 2252 getObservables(frame->getNormVars(), sliceSetTmp) ;; 2253 sliceSetTmp.remove(projectedVars,true,true) ;; 2254 sliceSetTmp.remove(*frame->getPlotVar(),true,true) ;; 2255 ; 2256 if (o.projData) {; 2257 std::unique_ptr<RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:98028,depend,depend,98028,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,3,['depend'],"['depend', 'dependsOn']"
Integrability," ); const. Return position in archive of current member. ; Definition at line 71 of file TArchiveFile.cxx. ◆ GetMemberIndex(). Int_t TArchiveFile::GetMemberIndex ; (; ); const. inline . Definition at line 57 of file TArchiveFile.h. ◆ GetMemberName(). const char * TArchiveFile::GetMemberName ; (; ); const. inline . Definition at line 56 of file TArchiveFile.h. ◆ GetMembers(). TObjArray * TArchiveFile::GetMembers ; (; ); const. inline . Definition at line 52 of file TArchiveFile.h. ◆ GetNumberOfMembers(). Int_t TArchiveFile::GetNumberOfMembers ; (; ); const. Returns number of members in archive. ; Definition at line 79 of file TArchiveFile.cxx. ◆ IsA(). TClass * TArchiveFile::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TZIPFile.; Definition at line 61 of file TArchiveFile.h. ◆ Open(). TArchiveFile * TArchiveFile::Open ; (; const char * ; url, . TFile * ; file . ). static . Return proper archive file handler depending on passed url. ; The handler is loaded via the plugin manager and is triggered by the extension of the archive file. In case no handler is found 0 is returned. The file argument is used to access the archive. The archive should be specified as url with the member name as the anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"", where tpc.root is the file in the archive to be opened. Alternatively the sub-file can be specified via its index number, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#3"". This function is normally only called via TFile::Open(). ; Definition at line 121 of file TArchiveFile.cxx. ◆ OpenArchive(). virtual Int_t TArchiveFile::OpenArchive ; (; ). pure virtual . Implemented in TZIPFile. ◆ operator=(). TArchiveFile & TArchiveFile::operator= ; (; const TArchiveFile & ; ). privatedelete . Not implemented because TArchiveFile can not be copied. . ◆ ParseUrl(). Bool_t TArchiveFile::ParseUrl ; (; const char * ; url, . TString & ; archive, . TStri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTArchiveFile.html:14771,depend,depending,14771,doc/master/classTArchiveFile.html,https://root.cern,https://root.cern/doc/master/classTArchiveFile.html,1,['depend'],['depending']
Integrability," ); const. inlineoverridevirtual . Reimplemented from RooAbsReal.; Definition at line 46 of file RooNormalizedPdf.h. ◆ getAnalyticalIntegralWN(). Int_t RooNormalizedPdf::getAnalyticalIntegralWN ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const RooArgSet * ; , . const char * ; rangeName = nullptr . ); const. inlineoverridevirtual . Forward determination of analytical integration capabilities to input p.d.f. ; Reimplemented from RooAbsReal.; Definition at line 48 of file RooNormalizedPdf.h. ◆ getValV(). double RooNormalizedPdf::getValV ; (; const RooArgSet * ; nset); const. inlineoverrideprotectedvirtual . Return current value, normalized by integrating over the observables in nset. ; If nset is 0, the unnormalized value is returned. All elements of nset must be lvalues.; Unnormalized values are not cached. Doing so would be complicated as _norm->getVal() could spoil the cache and interfere with returning the cached return value. Since unnormalized calls are typically done in integration calls, there is no performance hit. ; Reimplemented from RooAbsPdf.; Definition at line 79 of file RooNormalizedPdf.h. ◆ selfNormalized(). bool RooNormalizedPdf::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 44 of file RooNormalizedPdf.h. ◆ translate(). void RooNormalizedPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNormalizedPdf.html:77217,integrat,integration,77217,doc/master/classRooNormalizedPdf.html,https://root.cern,https://root.cern/doc/master/classRooNormalizedPdf.html,1,['integrat'],['integration']
Integrability," * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TList; 13\ingroup Containers; 14A doubly linked list.; 15 ; 16All classes inheriting from TObject can be; 17inserted in a TList. Before being inserted into the list the object; 18pointer is wrapped in a TObjLink object which contains, besides; 19the object pointer also a previous and next pointer.; 20 ; 21There are several ways to iterate over a TList; in order of preference, if; 22not forced by other constraints:; 23 ; 24 1. (Preferred way) Using the C++ range-based `for` or `begin()` / `end()`:; 25~~~ {.cpp}; 26 for(TObject *obj: *GetListOfPrimitives()); 27 obj->Write();; 28~~~; 29 2. Using the R__FOR_EACH macro:; 30~~~ {.cpp}; 31 GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);; 32~~~; 33 3. Using the TList iterator TListIter (via the wrapper class TIter):; 34~~~ {.cpp}; 35 TIter next(GetListOfPrimitives());; 36 while (TObject *obj = next()); 37 obj->Draw(next.GetOption());; 38~~~; 39 4. Using the TList iterator TListIter and std::for_each algorithm:; 40~~~ {.cpp}; 41 // A function object, which will be applied to each element; 42 // of the given range.; 43 struct STestFunctor {; 44 bool operator()(TObject *aObj) {; 45 ...; 46 return true;; 47 }; 48 }; 49 ...; 50 ...; 51 TIter iter(mylist);; 52 for_each( iter.Begin(), TIter::End(), STestFunctor() );; 53~~~; 54 5. Using the TObjLink list entries (that wrap the TObject*):; 55~~~ {.cpp}; 56 TObjLink *lnk = GetListOfPrimitives()->FirstLink();; 57 while (lnk) {; 58 lnk->GetObject()->Draw(lnk->GetOption());; 59 lnk = lnk->Next();; 60 }; 61~~~; 62 6. Using the TList's After() and Before() member functions:; 63~~~ {.cpp}; 64 TFree *idcur = this;; 65 while (idcur) {; 66 ...; 67 ...; 68 idcur = (TFree*)GetListOfFree()->After(idcur);; 69 }; 70~~~; 71Methods 3, 4 and 5 c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:1389,wrap,wrapper,1389,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['wrap'],['wrapper']
Integrability," * AttachSession(TProofDesc* , Bool_t = kFALSE); Dummy version provided for completeness. Just returns a pointer to; existing session 'id' (as shown by TProof::QuerySessions) or 0 if 'id' is; not valid. void DetachSession(Int_t , Option_t* = """"); Detach session with 'id' from its proofserv. The 'id' is the number; shown by QuerySessions. The correspondent TProof object is deleted.; If id == 0 all the known sessions are detached.; Option opt=""S"" or ""s"" forces session shutdown. void DetachSession(TProof* , Option_t* = """"); Detach session 'p' from its proofserv. The instance 'p' is invalidated; and should be deleted by the caller. TList * QuerySessions(Option_t* opt = ""S""); Get list of sessions accessible to this manager. Int_t SendMsgToUsers(const char* , const char* = 0); Send a message to connected users. Only superusers can do this.; The first argument specifies the message or the file from where to take; the message.; The second argument specifies the user to which to send the message: if; empty or null the message is send to all the connected users.; return 0 in case of success, -1 in case of error. Int_t Reset(Bool_t hard = kFALSE, const char* usr = 0); Send a cleanup request for the sessions associated with the current; user.; Not supported. void ShowWorkers(); Show available workers. TProofDesc * GetProofDesc(Int_t id); Get TProofDesc instance corresponding to 'id'. TProofDesc * GetProofDesc(TProof* p); Get TProofDesc instance corresponding to TProof object 'p'. void DiscardSession(TProof* p); Discard TProofDesc of session 'p' from the internal list. TProof * CreateSession(const char* = 0, const char* = 0, Int_t = -1); Create a new remote session (master and associated workers). Bool_t MatchUrl(const char* url); Checks if 'url' refers to the same 'user@host:port' entity as the URL; in memory. TList * GetListOfManagers(); Extract pointers to PROOF managers from TROOT::fProofs. TProofMgr * Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofMgr.html:9862,message,message,9862,root/html528/TProofMgr.html,https://root.cern,https://root.cern/root/html528/TProofMgr.html,20,['message'],['message']
Integrability," * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TStreamerElementDefinition TStreamerElement.h:32; TStreamerElement::GetClassTClass * GetClass() constDefinition TStreamerElement.h:108; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::GetPropertiesvirtual Int_t GetProperties() constReturn miscallenous properties of the proxy (see TVirtualCollectionProxy::EProperty)Definition TVirtualCollectionProxy.h:108; TVirtualCollectionProxy::kIsEmulated@ kIsEmulatedDefinition TVirtualCollectionProxy.h:67; TVirtualCollectionProxy::GetValueClassvirtual TClass * GetValueClass() const =0If the value type is a user-defined class, return a pointer to the TClass representing the value type...; TVirtualCollectionProxy::GetCollectionTypevirtual Int_t GetCollectionType() const =0Return the type of the proxied collection (see enumeration TClassEdit::ESTLType); TVirtualCollectionProxy::HasPointersvirtual Bool_t HasPointers() const =0Return true if the content is of type 'pointer to'.; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRuleSet_8cxx_source.html:32182,interface,interface,32182,doc/master/TSchemaRuleSet_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRuleSet_8cxx_source.html,1,['interface'],['interface']
Integrability," * GetSumw2()Definition TH1.h:313; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TIterDefinition TCollection.h:235; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::AtofDouble_t Atof() constReturn floating-point value contained in string.Definition TString.cxx:2054; TString::IsFloatBool_t IsFloat() constReturns kTRUE if string contains a floating point or integer number.Definition TString.cxx:1858; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsDigitBool_t IsDigit() constReturns true if all characters in string are digits (0-9) or white spaces, i.e.Definition TString.cxx:1830; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:70351,message,message,70351,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,1,['message'],['message']
Integrability," * InvertMSparse(const TMatrixDSparse* A) const; get the inverse of a sparse matrix; A: the original matrix; this is a replacement of the call; new TMatrixD(TMatrixD::kInverted, a);; the matrix inversion is optimized for the case; where a large submatrix of A is diagonal. Bool_t InvertMConditioned(TMatrixD* A); invert the matrix A; the inversion is done with pre-conditioning; all rows and columns are normalized to sqrt(abs(a_ii*a_jj)); such that the diagonals are equal to 1.0; This type of preconditioning improves the numerival results; for the symmetric, positive definite matrices which are; treated here in the context of unfolding. TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); set up unfolding matrix and initial regularisation scheme; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; constraint: type of constraint to use; data members initialized to something different from zero:; fA: filled from hist_A; fDA: filled from hist_A; fX0: filled from hist_A; fLsquared: filled depending on the regularisation scheme; Treatment of overflow bins; Bins where the unfolding input (Detector level) is in overflow; are used for the efficiency correction. They have to be filled; properly!; Bins where the unfolding output (Generator level) is in overflow; are treated as a part of the generator level distribution.; I.e. the unfolding output could have non-zero overflow bins if the; input matrix does have such bins. ~TUnfold(void); delete all data members. void SetBias(const TH1* bias); initialize alternative bias from histogram; modifies data member fX0. Int_t RegularizeSize(int bin, Double_t scale = 1.0); add regularisation on the size of bin i; bin: bin number; scale: size of the regularisation; return value: number of conditions which have been skipped; modifies data member fLsquare",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfold.html:24557,depend,depending,24557,root/html528/TUnfold.html,https://root.cern,https://root.cern/root/html528/TUnfold.html,4,['depend'],['depending']
Integrability," * Open(TFileOpenHandle* handle); Waits for the completion of an asynchronous open request.; Returns the associated TFile, transferring ownership of the; handle to the TFile instance. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Interface to system open. All arguments like in POSIX open(). Int_t SysClose(Int_t fd); Interface to system close. All arguments like in POSIX close(). Int_t SysRead(Int_t fd, void* buf, Int_t len); Interface to system read. All arguments like in POSIX read(). Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Interface to system write. All arguments like in POSIX write(). Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Interface to system lseek. All arguments like in POSIX lseek(); except that the offset and return value are of a type which are; able to handle 64 bit file systems. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Return file stat information. The interface and return value is; identical to TSystem::GetPathInfo(). The function returns 0 in; case of success and 1 if the file could not be stat'ed. Int_t SysSync(Int_t fd); Interface to system fsync. All arguments like in POSIX fsync(). Long64_t GetBytesWritten() const; Return the total number of bytes written so far to the file. Long64_t GetFileBytesRead(); Static function returning the total number of bytes read from all files. Long64_t GetFileBytesWritten(); Static function returning the total number of bytes written to all files.; Does not take into account what might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:48383,interface,interface,48383,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,10,['interface'],['interface']
Integrability," *, Version_t > RepoCont_t;  ; typedef void(* StreamerImpl_t) (const TClass *pThis, void *obj, TBuffer &b, const TClass *onfile_class);  Schema evolution rules. ;  . Private Member Functions;  TClass (const TClass &tc)=delete;  ; Bool_t CanSplitBaseAllow ();  Pointer to the function implementing streaming for this class. ;  ; TList * CreateListOfDataMembers (std::atomic< TListOfDataMembers * > &data, TDictionary::EMemberSelection selection, bool load);  Create the list containing the TDataMembers (of actual data members or members pulled in through using declarations) of a class. ;  ; TVirtualStreamerInfo * DetermineCurrentStreamerInfo ();  Determine and set pointer to current TVirtualStreamerInfo. ;  ; TMethod * FindClassOrBaseMethodWithId (DeclId_t faddr);  Find a method with decl id in this class or its bases. ;  ; Int_t GetBaseClassOffsetRecurse (const TClass *toBase);  Return data member offset to the base class ""cl"". ;  ; TMethod * GetClassMethod (Longptr_t faddr);  Look for a method in this class that has the interface function address faddr. ;  ; TListOfFunctions * GetMethodList ();  Return (create an empty one if needed) the list of functions. ;  ; TVirtualStreamerInfo * GetStreamerInfoImpl (Int_t version, Bool_t silent) const;  ; void Init (const char *name, Version_t cversion, const std::type_info *info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il, ClassInfo_t *classInfo, Bool_t silent);  Initialize a TClass object. ;  ; bool IsClassStructOrUnion () const;  ; void LoadClassInfo () const;  Try to load the ClassInfo if available. ;  ; void MoveAddressInRepository (const char *where, void *oldadd, void *newadd, const TClass *what) const;  ; TClass & operator= (const TClass &)=delete;  ; void RegisterAddressInRepository (const char *where, void *location, const TClass *what) const;  ; void SetClassSize (Int_t sizof);  ; void SetClassVersion (Version_t version);  Private function. ;  ; void SetRuntimeProperties ();  Internal ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:40076,interface,interface,40076,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,2,['interface'],['interface']
Integrability," */; 12584 len = (size_t)data_len + header_len;; 12585 ; 12586 /* Copy the data payload into the data pointer for the; 12587 * callback. Cast to 31 bit is OK, since we; 12588 * limited data_len */; 12589 memcpy(data, buf + header_len, (size_t)data_len);; 12590 ; 12591 /* Move the queue forward len bytes */; 12592 memmove(buf, buf + len, body_len - len);; 12593 ; 12594 /* Mark the queue as advanced */; 12595 conn->data_len -= (int)len;; 12596 }; 12597 ; 12598 /* Apply mask if necessary */; 12599 if (mask_len > 0) {; 12600 for (i = 0; i < (size_t)data_len; i++) {; 12601 data[i] ^= mask[i & 3];; 12602 }; 12603 }; 12604 ; 12605 exit_by_callback = 0;; 12606 if (enable_ping_pong && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PONG)) {; 12607 /* filter PONG messages */; 12608 DEBUG_TRACE(""PONG from %s:%u"",; 12609 conn->request_info.remote_addr,; 12610 conn->request_info.remote_port);; 12611 /* No unanwered PINGs left */; 12612 ping_count = 0;; 12613 } else if (enable_ping_pong; 12614 && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PING)) {; 12615 /* reply PING messages */; 12616 DEBUG_TRACE(""Reply PING from %s:%u"",; 12617 conn->request_info.remote_addr,; 12618 conn->request_info.remote_port);; 12619 ret = mg_websocket_write(conn,; 12620 MG_WEBSOCKET_OPCODE_PONG,; 12621 (char *)data,; 12622 (size_t)data_len);; 12623 if (ret <= 0) {; 12624 /* Error: send failed */; 12625 DEBUG_TRACE(""Reply PONG failed (%i)"", ret);; 12626 break;; 12627 }; 12628 ; 12629 ; 12630 } else {; 12631 /* Exit the loop if callback signals to exit (server side),; 12632 * or ""connection close"" opcode received (client side). */; 12633 if (ws_data_handler != NULL) {; 12634#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 12635 if (mop & 0x40) {; 12636 /* Inflate the data received if bit RSV1 is set. */; 12637 if (!conn->websocket_deflate_initialized) {; 12638 if (websocket_deflate_initialize(conn, 1) != Z_OK); 12639 exit_by_callback = 1;; 12640 }; 12641 if (!exit_by_callback) {; 12642 size_t inflate_buf_size_old ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:366426,message,messages,366426,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['message'],['messages']
Integrability," */; 12585 len = (size_t)data_len + header_len;; 12586 ; 12587 /* Copy the data payload into the data pointer for the; 12588 * callback. Cast to 31 bit is OK, since we; 12589 * limited data_len */; 12590 memcpy(data, buf + header_len, (size_t)data_len);; 12591 ; 12592 /* Move the queue forward len bytes */; 12593 memmove(buf, buf + len, body_len - len);; 12594 ; 12595 /* Mark the queue as advanced */; 12596 conn->data_len -= (int)len;; 12597 }; 12598 ; 12599 /* Apply mask if necessary */; 12600 if (mask_len > 0) {; 12601 for (i = 0; i < (size_t)data_len; i++) {; 12602 data[i] ^= mask[i & 3];; 12603 }; 12604 }; 12605 ; 12606 exit_by_callback = 0;; 12607 if (enable_ping_pong && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PONG)) {; 12608 /* filter PONG messages */; 12609 DEBUG_TRACE(""PONG from %s:%u"",; 12610 conn->request_info.remote_addr,; 12611 conn->request_info.remote_port);; 12612 /* No unanwered PINGs left */; 12613 ping_count = 0;; 12614 } else if (enable_ping_pong; 12615 && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PING)) {; 12616 /* reply PING messages */; 12617 DEBUG_TRACE(""Reply PING from %s:%u"",; 12618 conn->request_info.remote_addr,; 12619 conn->request_info.remote_port);; 12620 ret = mg_websocket_write(conn,; 12621 MG_WEBSOCKET_OPCODE_PONG,; 12622 (char *)data,; 12623 (size_t)data_len);; 12624 if (ret <= 0) {; 12625 /* Error: send failed */; 12626 DEBUG_TRACE(""Reply PONG failed (%i)"", ret);; 12627 break;; 12628 }; 12629 ; 12630 ; 12631 } else {; 12632 /* Exit the loop if callback signals to exit (server side),; 12633 * or ""connection close"" opcode received (client side). */; 12634 if (ws_data_handler != NULL) {; 12635#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 12636 if (mop & 0x40) {; 12637 /* Inflate the data received if bit RSV1 is set. */; 12638 if (!conn->websocket_deflate_initialized) {; 12639 if (websocket_deflate_initialize(conn, 1) != Z_OK); 12640 exit_by_callback = 1;; 12641 }; 12642 if (!exit_by_callback) {; 12643 size_t inflate_buf_size_old ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:366459,message,messages,366459,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['message'],['messages']
Integrability," *const ; member). inlinestatic . Definition at line 88 of file TStorage.h. ◆ GetFreeHook(). FreeHookFun_t TStorage::GetFreeHook ; (; ). inlinestatic . Definition at line 135 of file TStorage.h. ◆ GetFreeHookData(). void * TStorage::GetFreeHookData ; (; ). static . return static free hook data ; Definition at line 426 of file TStorage.cxx. ◆ GetMaxBlockSize(). size_t TStorage::GetMaxBlockSize ; (; ). inlinestatic . Definition at line 131 of file TStorage.h. ◆ HasCustomNewDelete(). Bool_t TStorage::HasCustomNewDelete ; (; ). static . return the has custom delete flag ; Definition at line 434 of file TStorage.cxx. ◆ IsA(). virtual TClass * TStorage::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 85 of file TStorage.h. ◆ ObjectAlloc() [1/2]. void * TStorage::ObjectAlloc ; (; size_t ; sz). static . Used to allocate a TObject on the heap (via TObject::operator new()). ; Directly after this routine one can call (in the TObject ctor) TStorage::FilledByObjectAlloc() to find out if the just created object is on the heap. This technique is necessary as there is one stack per thread and we can not rely on comparison with the current stack memory position. ; Definition at line 291 of file TStorage.cxx. ◆ ObjectAlloc() [2/2]. void * TStorage::ObjectAlloc ; (; size_t ; size, . void * ; vp . ). static . Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)) in position vp. ; vp is already allocated (maybe on heap, maybe on stack) so just return. ; Definition at line 314 of file TStorage.cxx. ◆ ObjectAllocArray(). void * TStorage::ObjectAllocArray ; (; size_t ; sz). static . Used to allocate array of TObject on the heap (via TObject::operator new[]()). ; Unlike the 'singular' ObjectAlloc, we do not mark those object has being allocated on the heap as they can not be individually deleted. ; Definition at line 303 of file TStorage.cxx. ◆ ObjectDealloc() [1/2]. void TStorage::ObjectDealloc ; (; void * ; vp). st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStorage.html:7203,rout,routine,7203,doc/master/classTStorage.html,https://root.cern,https://root.cern/doc/master/classTStorage.html,1,['rout'],['routine']
Integrability," *f = TempFileName(gdbmessf);; 2433 fprintf(f, ""%s\n"", gdbmess.Data());; 2434 fclose(f);; 2435 }; 2436 ; 2437 // use gdb to get stack trace; 2438#ifdef R__MACOSX; 2439 gdbscript += GetExePath();; 2440 gdbscript += "" "";; 2441#endif; 2442 gdbscript += GetPid();; 2443 if (gdbmess != """") {; 2444 gdbscript += "" "";; 2445 gdbscript += gdbmessf;; 2446 }; 2447 gdbscript += "" 1>&2"";; 2448 Exec(gdbscript);; 2449 delete [] gdb;; 2450 } else {; 2451 // addr2line uses debug info to convert addresses into file names; 2452 // and line numbers; 2453#ifdef R__MACOSX; 2454 char *addr2line = Which(Getenv(""PATH""), ""atos"", kExecutePermission);; 2455#else; 2456 char *addr2line = Which(Getenv(""PATH""), ""addr2line"", kExecutePermission);; 2457#endif; 2458 if (addr2line) {; 2459 // might take some time so tell what we are doing...; 2460 if (write(fd, message, strlen(message)) < 0); 2461 Warning(""StackTrace"", ""problems writing line numbers (errno: %d)"", TSystem::GetErrno());; 2462 }; 2463 ; 2464 // open tmp file for demangled stack trace; 2465 TString tmpf1 = ""gdb-backtrace"";; 2466 std::ofstream file1;; 2467 if (demangle) {; 2468 FILE *f = TempFileName(tmpf1);; 2469 if (f) fclose(f);; 2470 file1.open(tmpf1);; 2471 if (!file1) {; 2472 Error(""StackTrace"", ""could not open file %s"", tmpf1.Data());; 2473 Unlink(tmpf1);; 2474 demangle = kFALSE;; 2475 }; 2476 }; 2477 ; 2478#ifdef R__MACOSX; 2479 if (addr2line); 2480 demangle = kFALSE; // atos always demangles; 2481#endif; 2482 ; 2483 char buffer[4096];; 2484 void *trace[kMAX_BACKTRACE_DEPTH];; 2485 int depth = backtrace(trace, kMAX_BACKTRACE_DEPTH);; 2486 for (int n = 5; n < depth; n++) {; 2487 ULong_t addr = (ULong_t) trace[n];; 2488 Dl_info info;; 2489 ; 2490 if (dladdr(trace[n], &info) && info.dli_fname && info.dli_fname[0]) {; 2491 const char *libname = info.dli_fname;; 2492 const char *symname = (info.dli_sname && info.dli_sname[0]) ?; 2493 info.dli_sname : ""<unknown>"";; 2494 ULong_t libaddr = (ULong_t) info.dli_fbase;; 2495 ULong_t symaddr = (UL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:76616,message,message,76616,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,2,['message'],['message']
Integrability," *frame, PlotOpt o) const override;  Plot oneself on 'frame'. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (project) PDF on specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Back-end for plotOn() implementation on RooSimultaneous which needs special handling because a RooSimultaneous PDF cannot project out its index category via integration. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void wrapPdfsInBinSamplingPdfs (RooAbsData const &data, double precision);  Wraps the components of this RooSimultaneous in RooBinSamplingPdfs. ;  ; void wrapPdfsInBinSamplingPdfs (RooAbsData const &data, std::map< std::string, double > const &precisions, bool useCategoryNames=false);  Wraps the components of this RooSimultaneous in RooBinSamplingPdfs, with a different precision parameter for each component. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; virtual RooAbsGenContext * binnedGenContext (const RooArgSet &vars, bool verbose=false) const;  Return a binned generator context. ;  ; bool canBeExtended () const;  If true, PDF can provide extended likelihood term. ;  ; RooFit::OwningPtr< RooAbsReal > createCdf (const RooArgSet &iset, const RooArgSet &nset=RooArgSet());  Create a cumulative distribution function of this p.d.f in terms of the observables listed in iset. ;  ; RooFit::OwningPtr< RooAbsReal > createCdf (const RooArgSet &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:7321,wrap,wrapPdfsInBinSamplingPdfs,7321,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,1,['wrap'],['wrapPdfsInBinSamplingPdfs']
Integrability," *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) const;  Fill supplied list with all leaf nodes of the arg tree, starting with ourself as top node. ;  ; void branchNodeServerList (RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) const;  Fill supplied list with all branch nodes of the arg tree starting with ourself as top node. ;  ; void treeNodeServerList (RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool doBranch=true, bool doLeaf=true, bool valueOnly=false, bool recurseNonDerived=false) const;  Fill supplied list with nodes of the arg tree, following all server links, starting with ourself as top node. ;  ; virtual bool isFundamental () const;  Is this object a fundamental type that can be added to a dataset? Fundamental-type subclasses override this method to return true. ;  ; virtual bool isLValue () const;  Is this argument an l-value, i.e., can it appear on the left-hand side of an assignment expression? LValues are also special since they can potentially be analytically integrated and generated. ;  ; bool redirectServers (const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool isRecursionStep=false);  Replace all direct servers of this object with the new servers in newServerList. ;  ; bool redirectServers (std::unordered_map< RooAbsArg *, RooAbsArg * > const &replacements);  Replace some servers of this object. ;  ; bool recursiveRedirectServers (const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool recurseInNewSet=true);  Recursively replace all servers with the new servers in newSet. ;  ; virtual bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep);  Function that is called at the end of redirectServers(). ;  ; virtual void serverNameChangeHook (const RooAbsArg *, const RooAbsArg *);  ; void addServer (RooAbsArg &server, bool valueProp=true, bool ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMappedCategory.html:19182,integrat,integrated,19182,doc/master/classRooMappedCategory.html,https://root.cern,https://root.cern/doc/master/classRooMappedCategory.html,5,['integrat'],['integrated']
Integrability," *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) const;  Fill supplied list with all leaf nodes of the arg tree, starting with ourself as top node. ;  ; void branchNodeServerList (RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) const;  Fill supplied list with all branch nodes of the arg tree starting with ourself as top node. ;  ; void treeNodeServerList (RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool doBranch=true, bool doLeaf=true, bool valueOnly=false, bool recurseNonDerived=false) const;  Fill supplied list with nodes of the arg tree, following all server links, starting with ourself as top node. ;  ; virtual bool isFundamental () const;  Is this object a fundamental type that can be added to a dataset? Fundamental-type subclasses override this method to return true. ;  ; virtual bool isLValue () const;  Is this argument an l-value, i.e., can it appear on the left-hand side of an assignment expression? LValues are also special since they can potentially be analytically integrated and generated. ;  ; bool redirectServers (const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool isRecursionStep=false);  Replace all direct servers of this object with the new servers in newServerList. ;  ; bool redirectServers (std::unordered_map< RooAbsArg *, RooAbsArg * > const &replacements);  Replace some servers of this object. ;  ; bool recursiveRedirectServers (const RooAbsCollection &newServerList, bool mustReplaceAll=false, bool nameChange=false, bool recurseInNewSet=true);  Recursively replace all servers with the new servers in newSet. ;  ; virtual void serverNameChangeHook (const RooAbsArg *, const RooAbsArg *);  ; void addServer (RooAbsArg &server, bool valueProp=true, bool shapeProp=false, std::size_t refCount=1);  Register another RooAbsArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:46229,integrat,integrated,46229,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,140,['integrat'],['integrated']
Integrability," *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TUrl.h>. Inheritance diagram for TUrl:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EStatusBits. enum TUrl::EStatusBits. private . EnumeratorkUrlWithDefaultPort ; kUrlHasDefaultPort . Definition at line 54 of file TUrl.h. Constructor & Destructor Documentation. ◆ TUrl() [1/3]. TUrl::TUrl ; (; ). inline . Definition at line 57 of file TUrl.h. ◆ TUrl() [2/3]. TUrl::TUrl ; (; const char * ; url, . Bool_t ; defaultIsFile = kFALSE . ). Parse url character string and split in its different subcomponents. ; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]; Known protocols: http, root, proof, ftp, news and any special protocols defined in the rootrc Url.Special key. The default protocol is ""http"", unless defaultIsFile is true in which case the url is assumed to be of type ""file"". If a passwd contains a @ it must be escaped by a \, e.g. ""pip@"" becomes ""pip\\@"".; Default ports: http=80, root=1094, proof=1093, ftp=20, news=119. Port #1093 has been assigned by IANA (www.iana.org) to proofd. Port #1094 has been assigned by IANA (www.iana.org) to rootd. ; Definition at line 76 of file TUrl.cxx. ◆ TUrl() [3/3]. TUrl::TUrl ; (; const TUrl & ; url). TUrl copy ctor. ; Definition at line 346 of file TUrl.cxx. ◆ ~TUrl(). TUrl::~TUrl ; (; ). virtual . Cleanup. ; Definition at line 88 of file TUrl.cxx. Member Function Documentation. ◆ Class(). static TClass * TUrl::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TUrl::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TUrl::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 98 of file TUrl.h. ◆ CleanRelativePath(). void TUrl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUrl.html:13706,protocol,protocol,13706,doc/master/classTUrl.html,https://root.cern,https://root.cern/doc/master/classTUrl.html,1,['protocol'],['protocol']
Integrability," *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTDirectory.html:11648,message,message,11648,doc/v632/classTDirectory.html,https://root.cern,https://root.cern/doc/v632/classTDirectory.html,6,['message'],['message']
Integrability," *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:21083,message,message,21083,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,15,['message'],['message']
Integrability," *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:31400,message,message,31400,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,9,['message'],['message']
Integrability," *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:28604,message,message,28604,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['message'],['message']
Integrability," *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassDocInfo.html:5163,message,message,5163,doc/master/classTClassDocInfo.html,https://root.cern,https://root.cern/doc/master/classTClassDocInfo.html,1,['message'],['message']
Integrability," *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class shou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParameter.html:5803,message,message,5803,doc/master/classTParameter.html,https://root.cern,https://root.cern/doc/master/classTParameter.html,2,['message'],['message']
Integrability," *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDrawFeedback.html:4603,message,message,4603,doc/master/classTDrawFeedback.html,https://root.cern,https://root.cern/doc/master/classTDrawFeedback.html,9,['message'],['message']
Integrability," *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle again",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStatistic.html:5096,message,message,5096,doc/master/classTStatistic.html,https://root.cern,https://root.cern/doc/master/classTStatistic.html,1,['message'],['message']
Integrability," *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjString.html:4773,message,message,4773,doc/master/classTObjString.html,https://root.cern,https://root.cern/doc/master/classTObjString.html,1,['message'],['message']
Integrability," *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; virtual TClass * IsA () const;  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; virtual Bool_t IsFolder () const;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option="""") const;  The ls function lists the contents of a class on stdout. ;  ; void MayNotUse (const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTIconBoxThumb.html:3944,message,message,3944,doc/master/classTIconBoxThumb.html,https://root.cern,https://root.cern/doc/master/classTIconBoxThumb.html,1,['message'],['message']
Integrability," *nset, Int_t *sterileIndex=nullptr, const TNamed *isetRangeName=nullptr);  Getter function without integration set. ;  ; RooAbsCacheElement * getObjByIndex (Int_t index) const;  Retrieve payload object by slot index. ;  ; Int_t lastIndex () const;  Return index of slot used in last get or set operation. ;  ; void reset ();  Clear the cache. ;  ; RooArgSet selectFromSet1 (RooArgSet const &argSet, int index) const;  Create RooArgSet containing the objects that are both in the cached set 1 with a given index and an input argSet. ;  ; RooArgSet selectFromSet2 (RooArgSet const &argSet, int index) const;  Create RooArgSet containing the objects that are both in the cached set 2 with a given index and an input argSet. ;  ; Int_t setObj (const RooArgSet *nset, const RooArgSet *iset, RooAbsCacheElement *obj, const TNamed *isetRangeName=nullptr);  Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. ;  ; Int_t setObj (const RooArgSet *nset, RooAbsCacheElement *obj, const TNamed *isetRangeName=nullptr);  Setter function without integration set. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void wireCache () override;  ;  Public Member Functions inherited from RooAbsCache;  RooAbsCache (const RooAbsCache &, RooAbsArg *owner=nullptr);  Copy constructor. Takes owner as argument and registers cache with owne. ;  ;  RooAbsCache (RooAbsArg *owner=nullptr);  Constructor. Takes owner as argument and register cache with owner. ;  ; virtual ~RooAbsCache ();  Destructor. Unregisters cache with owner. ;  ; void setOwner (RooAbsArg *owner);  Reset the owner, triggering the owner to register this cache in its list of caches. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static bool clearObsList ();  ; static const char * DeclFileName ();  ; static void doClearObsList (bool fl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:4437,integrat,integration,4437,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['integrat'],['integration']
Integrability," *onfile_classname, Int_t version) const;  Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. ;  ; TVirtualStreamerInfo * GetConversionStreamerInfo (const TClass *onfile_cl, Int_t version) const;  Return a Conversion StreamerInfo from the class represented by cl for version number 'version' to this class, if any. ;  ; ClassConvStreamerFunc_t GetConvStreamerFunc () const;  Get a wrapper/accessor function around this class custom conversion streamer (member function). ;  ; TVirtualStreamerInfo * GetCurrentStreamerInfo ();  ; TDataMember * GetDataMember (const char *datamember) const;  Return pointer to datamember object with name ""datamember"". ;  ; Longptr_t GetDataMemberOffset (const char *membername) const;  return offset for member name. ;  ; Short_t GetDeclFileLine () const;  ; const char * GetDeclFileName () const;  Return name of the file containing the declaration of this class. ;  ; ROOT::DelFunc_t GetDelete () const;  Return the wrapper around delete ThiObject. ;  ; ROOT::DelArrFunc_t GetDeleteArray () const;  Return the wrapper around delete [] ThiObject. ;  ; ROOT::DesFunc_t GetDestructor () const;  Return the wrapper around the destructor. ;  ; ROOT::DirAutoAdd_t GetDirectoryAutoAdd () const;  Return the wrapper around the directory auto add function. ;  ; TFunctionTemplate * GetFunctionTemplate (const char *name);  ; UInt_t GetHeapInstanceCount () const;  ; Short_t GetImplFileLine () const;  ; const char * GetImplFileName () const;  ; UInt_t GetInstanceCount () const;  ; TVirtualIsAProxy * GetIsAProxy () const;  Return the proxy implementing the IsA functionality. ;  ; TVirtualStreamerInfo * GetLastReadInfo () const;  ; TList * GetListOfAllPublicDataMembers (Bool_t load=kTRUE);  Returns a list of all public data members of this class and its base classes. ;  ; const TList * GetListOfAllPublicMethods (Bool_t load=kTRUE);  Returns a list of all public methods of this class and its base classes. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:12187,wrap,wrapper,12187,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['wrap'],['wrapper']
Integrability," *option)Draw a bar-chart in a normal pad.Definition THistPainter.cxx:5043; THistPainter::ProjectMercator2xystatic Int_t ProjectMercator2xy(Double_t l, Double_t b, Double_t &Al, Double_t &Ab)Static function.Definition THistPainter.cxx:10366; THistPainter::PaintBoxesvirtual void PaintBoxes(Option_t *option)Control function to draw a 2D histogram as a box plotDefinition THistPainter.cxx:5168; THistPainter::MakeChoptvirtual Int_t MakeChopt(Option_t *option)Decode string choptin and fill Hoption structure.Definition THistPainter.cxx:4028; THistPainter::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideDisplay the histogram info (bin number, contents, integral up to bin corresponding to cursor position...Definition THistPainter.cxx:3729; THistPainter::GetContourListTList * GetContourList(Double_t contour) const overrideGet a contour (as a list of TGraphs) using the Delaunay triangulation.Definition THistPainter.cxx:3706; THistPainter::ProcessMessagevoid ProcessMessage(const char *mess, const TObject *obj) overrideProcess message mess.Definition THistPainter.cxx:10311; THistPainter::SetShowProjectionvoid SetShowProjection(const char *option, Int_t nbins) overrideSet projection.Definition THistPainter.cxx:10766; THistPainter::ShowProjectionYvirtual void ShowProjectionY(Int_t px, Int_t py)Show projection onto Y.Definition THistPainter.cxx:10933; THistPainter::GetBestFormatstatic const char * GetBestFormat(Double_t v, Double_t e, const char *f)This function returns the best format to print the error value (e) knowing the parameter value (v) an...Definition THistPainter.cxx:10714; THistPainter::PaintContourvirtual void PaintContour(Option_t *option)Control function to draw a 2D histogram as a contour plot.Definition THistPainter.cxx:5932; THistPainter::fCutsTCutG * fCuts[kMaxCuts]Pointers to graphical cuts.Definition THistPainter.h:65; THistPainter::PaintTablevirtual void PaintTable(Option_t *option)Control function to draw 2D/3D histograms (tables).Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:472859,message,message,472859,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,2,['message'],['message']
Integrability," *rfbase);  constructor ;  ;  RuleFit (void);  default constructor ;  ; virtual ~RuleFit (void);  destructor ;  ; void Boost (TMVA::DecisionTree *dt);  Boost the events. ;  ; void BuildTree (TMVA::DecisionTree *dt);  build the decision tree using fNTreeSample events from fTrainingEventsRndm ;  ; void CalcImportance ();  calculates the importance of each rule ;  ; Double_t CalcWeightSum (const std::vector< const TMVA::Event * > *events, UInt_t neve=0);  calculate the sum of weights ;  ; Double_t EvalEvent (const Event &e);  evaluate single event ;  ; void FillCorr (TH2F *h2, const TMVA::Rule *rule, Int_t v1, Int_t v2);  fill rule correlation between vx and vy, weighted with either the importance or the coefficient ;  ; void FillCut (TH2F *h2, const TMVA::Rule *rule, Int_t vind);  Fill cut. ;  ; void FillLin (TH2F *h2, Int_t vind);  fill lin ;  ; void FillVisHistCorr (const Rule *rule, std::vector< TH2F * > &hlist);  help routine to MakeVisHists() - fills for all correlation plots ;  ; void FillVisHistCut (const Rule *rule, std::vector< TH2F * > &hlist);  help routine to MakeVisHists() - fills for all variables ;  ; void FitCoefficients ();  Fit the coefficients for the rule ensemble. ;  ; void ForestStatistics ();  summary of statistics of all trees ;  ; Bool_t GetCorrVars (TString &title, TString &var1, TString &var2);  get first and second variables from title ;  ; const std::vector< const TMVA::DecisionTree * > & GetForest () const;  ; const MethodBase * GetMethodBase () const;  ; const MethodRuleFit * GetMethodRuleFit () const;  ; Double_t GetNEveEff () const;  ; UInt_t GetNTreeSample () const;  ; void GetRndmSampleEvents (std::vector< const TMVA::Event * > &evevec, UInt_t nevents);  draw a random subsample of the training events without replacement ;  ; const RuleEnsemble & GetRuleEnsemble () const;  ; RuleEnsemble * GetRuleEnsemblePtr ();  ; const RuleFitParams & GetRuleFitParams () const;  ; RuleFitParams * GetRuleFitParamsPtr ();  ; const Event * GetTrainingE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFit.html:1429,rout,routine,1429,doc/master/classTMVA_1_1RuleFit.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFit.html,2,['rout'],['routine']
Integrability," *s)Definition TObjString.h:45; TObjString::GetNameconst char * GetName() const overrideReturns name of object.Definition TObjString.h:38; TObject::kOverwrite@ kOverwriteoverwrite existing object with same nameDefinition TObject.h:92; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::Dataconst char * Data() constDefinition TString.h:376; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::AppendTS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8cxx_source.html:71235,message,message,71235,doc/master/TEntryList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html,1,['message'],['message']
Integrability," *ti) override;  Add timer to list of system timers. ;  ; int AnnounceTcpService (int port, Bool_t reuse, int backlog, int tcpwindowsize=-1) override;  Announce TCP/IP service. ;  ; int AnnounceUdpService (int port, int backlog) override;  Announce UDP service. ;  ; int AnnounceUnixService (const char *sockpath, int backlog) override;  Open a socket on path 'sockpath', bind to it and start listening for Unix domain connections to it. ;  ; int AnnounceUnixService (int port, int backlog) override;  Announce unix domain service. ;  ; const char * BaseName (const char *name) override;  Base name of a file name. ;  ; Bool_t ChangeDirectory (const char *path) override;  Change directory. ;  ; int Chmod (const char *file, UInt_t mode) override;  Set the file permission bits. ;  ; void CloseConnection (int sock, Bool_t force=kFALSE) override;  Close socket. ;  ; int ClosePipe (FILE *pipe) override;  Close the pipe. ;  ; int ConnectService (const char *servername, int port, int tcpwindowsize, const char *protocol=""tcp"");  Connect to service servicename on server servername. ;  ; int CopyFile (const char *from, const char *to, Bool_t overwrite=kFALSE) override;  Copy a file. ;  ; const char * DirName (const char *pathname) override;  Return the directory name in pathname. ;  ; void DispatchOneEvent (Bool_t pendingOnly=kFALSE) override;  Dispatch a single event in TApplication::Run() loop. ;  ; void DispatchSignals (ESignals sig);  Handle and dispatch signals. ;  ; const char DriveName (const char *pathname=""/"");  Return the drive letter in pathname. ;  ; int Exec (const char *shellcmd) override;  Execute a command. ;  ; void Exit (int code, Bool_t mode=kTRUE) override;  Exit the application. ;  ; void ExitLoop () override;  Exit from event loop. ;  ; char * ExpandPathName (const char *path) override;  Expand a pathname getting rid of special shell characaters like ~. ;  ; Bool_t ExpandPathName (TString &patbuf) override;  Expand a pathname getting rid of special shell characat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:3029,protocol,protocol,3029,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['protocol'],['protocol']
Integrability," *title, const char *formula, const RooArgList &dependents, bool checkVariables=true);  Constructor with formula expression and list of input variables. ;  ;  RooFormulaVar (const char *name, const char *title, const RooArgList &dependents, bool checkVariables=true);  Constructor with formula expression, title and list of input variables. ;  ;  RooFormulaVar (const RooFormulaVar &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooFormulaVar () override;  ; std::list< double > * binBoundaries (RooAbsRealLValue &, double, double) const override;  Forward the plot sampling hint from the p.d.f. that defines the observable obs. ;  ; TObject * clone (const char *newname) const override;  ; double defaultErrorLevel () const override;  Return the default error level for MINUIT error analysis If the formula contains one or more RooNLLVars and no RooChi2Vars, return the defaultErrorLevel() of RooNLLVar. ;  ; const RooArgList & dependents () const;  ; void doEval (RooFit::EvalContext &ctx) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; void dumpFormula ();  Dump the formula to stdout. ;  ; double evaluate () const override;  Calculate current value of object from internal formula. ;  ; const char * expression () const;  ; RooAbsArg * getParameter (const char *name) const;  Return pointer to parameter with given name. ;  ; RooAbsArg * getParameter (Int_t index) const;  Return pointer to parameter at given index. ;  ; TClass * IsA () const override;  ; size_t nParameters () const;  Return the number of parameters. ;  ; bool ok () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &, double, double) const override;  Forward the plot sampling hint from the p.d.f. that defines the observable obs. ;  ; void printMetaArgs (std::ostream &os) const override;  Add formula expression as meta argument in printing interface. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFormulaVar.html:3015,depend,dependents,3015,doc/master/classRooFormulaVar.html,https://root.cern,https://root.cern/doc/master/classRooFormulaVar.html,1,['depend'],['dependents']
Integrability," *url, const char *mode, Int_t compressionLevel);  Open merger output file. ;  ; virtual Bool_t OutputFile (const char *url, const char *mode=""RECREATE"");  Open merger output file. ;  ; virtual Bool_t OutputFile (std::unique_ptr< TFile > file);  Set an output file opened externally by the users. ;  ; virtual Bool_t PartialMerge (Int_t type=kAll|kIncremental);  Merge the files. ;  ; virtual void PrintFiles (Option_t *options);  Print list of files being merged. ;  ; void RecursiveRemove (TObject *obj) override;  Intercept the case where the output TFile is deleted! ;  ; virtual void Reset ();  Reset merger file list. ;  ; virtual Bool_t SetCWD (const char *);  ; virtual void SetFastMethod (Bool_t fast=kTRUE);  ; void SetIOFeatures (ROOT::TIOFeatures &features);  ; void SetMaxOpenedFiles (Int_t newmax);  Set a limit to the number of files that TFileMerger will open simultaneously. ;  ; void SetMergeOptions (const std::string_view &options);  ; void SetMergeOptions (const TString &options);  ; void SetMsgPrefix (const char *prefix);  Set the prefix to be used when printing informational message. ;  ; virtual void SetNotrees (Bool_t notrees=kFALSE);  ; void SetPrintLevel (Int_t level);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileMerger.html:4391,message,message,4391,doc/master/classTFileMerger.html,https://root.cern,https://root.cern/doc/master/classTFileMerger.html,1,['message'],['message']
Integrability," *user_data); 18164{; 18165 struct mg_connection *conn = NULL;; 18166 ; 18167#if defined(USE_WEBSOCKET); 18168 struct websocket_client_thread_data *thread_data;; 18169 static const char *magic = ""x3JJHMbDL1EzLkh9GBhXDw=="";; 18170 ; 18171 const char *host = client_options->host;; 18172 int i;; 18173 ; 18174#if defined(__clang__); 18175#pragma clang diagnostic push; 18176#pragma clang diagnostic ignored ""-Wformat-nonliteral""; 18177#endif; 18178 ; 18179 /* Establish the client connection and request upgrade */; 18180 conn = mg_connect_client_impl(client_options,; 18181 use_ssl,; 18182 error_buffer,; 18183 error_buffer_size);; 18184 ; 18185 /* Connection object will be null if something goes wrong */; 18186 if (conn == NULL) {; 18187 /* error_buffer should be already filled ... */; 18188 if (!error_buffer[0]) {; 18189 /* ... if not add an error message */; 18190 mg_snprintf(conn,; 18191 NULL, /* No truncation check for ebuf */; 18192 error_buffer,; 18193 error_buffer_size,; 18194 ""Unexpected error"");; 18195 }; 18196 return NULL;; 18197 }; 18198 ; 18199 if (origin != NULL) {; 18200 if (extensions != NULL) {; 18201 i = mg_printf(conn,; 18202 ""GET %s HTTP/1.1\r\n""; 18203 ""Host: %s\r\n""; 18204 ""Upgrade: websocket\r\n""; 18205 ""Connection: Upgrade\r\n""; 18206 ""Sec-WebSocket-Key: %s\r\n""; 18207 ""Sec-WebSocket-Version: 13\r\n""; 18208 ""Sec-WebSocket-Extensions: %s\r\n""; 18209 ""Origin: %s\r\n""; 18210 ""\r\n"",; 18211 path,; 18212 host,; 18213 magic,; 18214 extensions,; 18215 origin);; 18216 } else {; 18217 i = mg_printf(conn,; 18218 ""GET %s HTTP/1.1\r\n""; 18219 ""Host: %s\r\n""; 18220 ""Upgrade: websocket\r\n""; 18221 ""Connection: Upgrade\r\n""; 18222 ""Sec-WebSocket-Key: %s\r\n""; 18223 ""Sec-WebSocket-Version: 13\r\n""; 18224 ""Origin: %s\r\n""; 18225 ""\r\n"",; 18226 path,; 18227 host,; 18228 magic,; 18229 origin);; 18230 }; 18231 } else {; 18232 ; 18233 if (extensions != NULL) {; 18234 i = mg_printf(conn,; 18235 ""GET %s HTTP/1.1\r\n""; 18236 ""Host: %s\r\n""; 18237 ""Upgrade: websocket\r\n""; 182",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:539909,message,message,539909,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['message'],['message']
Integrability," *user_data); 18165{; 18166 struct mg_connection *conn = NULL;; 18167 ; 18168#if defined(USE_WEBSOCKET); 18169 struct websocket_client_thread_data *thread_data;; 18170 static const char *magic = ""x3JJHMbDL1EzLkh9GBhXDw=="";; 18171 ; 18172 const char *host = client_options->host;; 18173 int i;; 18174 ; 18175#if defined(__clang__); 18176#pragma clang diagnostic push; 18177#pragma clang diagnostic ignored ""-Wformat-nonliteral""; 18178#endif; 18179 ; 18180 /* Establish the client connection and request upgrade */; 18181 conn = mg_connect_client_impl(client_options,; 18182 use_ssl,; 18183 error_buffer,; 18184 error_buffer_size);; 18185 ; 18186 /* Connection object will be null if something goes wrong */; 18187 if (conn == NULL) {; 18188 /* error_buffer should be already filled ... */; 18189 if (!error_buffer[0]) {; 18190 /* ... if not add an error message */; 18191 mg_snprintf(conn,; 18192 NULL, /* No truncation check for ebuf */; 18193 error_buffer,; 18194 error_buffer_size,; 18195 ""Unexpected error"");; 18196 }; 18197 return NULL;; 18198 }; 18199 ; 18200 if (origin != NULL) {; 18201 if (extensions != NULL) {; 18202 i = mg_printf(conn,; 18203 ""GET %s HTTP/1.1\r\n""; 18204 ""Host: %s\r\n""; 18205 ""Upgrade: websocket\r\n""; 18206 ""Connection: Upgrade\r\n""; 18207 ""Sec-WebSocket-Key: %s\r\n""; 18208 ""Sec-WebSocket-Version: 13\r\n""; 18209 ""Sec-WebSocket-Extensions: %s\r\n""; 18210 ""Origin: %s\r\n""; 18211 ""\r\n"",; 18212 path,; 18213 host,; 18214 magic,; 18215 extensions,; 18216 origin);; 18217 } else {; 18218 i = mg_printf(conn,; 18219 ""GET %s HTTP/1.1\r\n""; 18220 ""Host: %s\r\n""; 18221 ""Upgrade: websocket\r\n""; 18222 ""Connection: Upgrade\r\n""; 18223 ""Sec-WebSocket-Key: %s\r\n""; 18224 ""Sec-WebSocket-Version: 13\r\n""; 18225 ""Origin: %s\r\n""; 18226 ""\r\n"",; 18227 path,; 18228 host,; 18229 magic,; 18230 origin);; 18231 }; 18232 } else {; 18233 ; 18234 if (extensions != NULL) {; 18235 i = mg_printf(conn,; 18236 ""GET %s HTTP/1.1\r\n""; 18237 ""Host: %s\r\n""; 18238 ""Upgrade: websocket\r\n""; 182",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:539942,message,message,539942,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['message'],['message']
Integrability," *vp);  ; TObject & operator= (const TObject &rhs);  TObject assignment operator. ;  ; virtual void Paint (Option_t *option="""");  This method must be overridden if a class wants to paint itself. ;  ; virtual void Pop ();  Pop on object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; void ResetBit (UInt_t f);  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFolder.html:13890,message,message,13890,doc/master/classTFolder.html,https://root.cern,https://root.cern/doc/master/classTFolder.html,1,['message'],['message']
Integrability," * ; actualWidth . ). protected . This routine gathers as many tokens as will fit on one line. ; The candidate tokens begin with fPStart and go thru the end of the list or to fPEnd, whichever comes first. The first token at the start of the next line is returned. NULL is returned if we exhaust data.; ""width"" is the maximum allowed width of the line. The actual width is returned in *actualWidth. The actual width does not include any trailing spaces. Sometimes the actual width will be greater than the maximum width. This will happen, for example, for text enclosed in .. that has lines longer than the width of the page.; If the list begins with text, at least one token is returned, even if that one token is longer than the allowed line length. But if the list begins with some kind of break markup (possibly preceded by white space) then the returned list may be empty.; The ""x"" coordinates of all elements are set assuming that the line begins at 0. The calling routine should adjust these coordinates to position the line horizontally. (The FixLine() procedure does this.) Note that the ""x"" coordinate of <li> elements will be negative. Text within <dt>..</dt> might also have a negative ""x"" coordinate. But in no case will the x coordinate every be less than ""minX"".; p_start - First token on new line p_end - End of line. Might be NULL width - How much space is on this line minX - The minimum value of the X coordinate actualWidth - Return space actually required ; Definition at line 203 of file TGHtmlLayout.cxx. ◆ InWrapAround(). int TGHtmlLayoutContext::InWrapAround ; (; ). protected . Return TRUE (non-zero) if we are currently wrapping text around one or more images. ; Definition at line 1044 of file TGHtmlLayout.cxx. ◆ LayoutBlock(). void TGHtmlLayoutContext::LayoutBlock ; (; ). Do as much layout as possible on the block of text defined by the HtmlLayoutContext. ; Definition at line 1076 of file TGHtmlLayout.cxx. ◆ Paragraph(). void TGHtmlLayoutContext::Paragraph ; (; TGHtml",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtmlLayoutContext.html:16586,rout,routine,16586,doc/master/classTGHtmlLayoutContext.html,https://root.cern,https://root.cern/doc/master/classTGHtmlLayoutContext.html,1,['rout'],['routine']
Integrability," * ; cp . ). protected . Modify an index for both pointer and char +/-/=N. ; Definition at line 251 of file TGHtmlIndex.cxx. ◆ IndexToBlockIndex(). void TGHtml::IndexToBlockIndex ; (; SHtmlIndex_t ; sIndex, . TGHtmlBlock ** ; ppBlock, . int * ; piIndex . ). protected . Convert an Element-based index into a Block-based index. ; In other words, given a pointer to an element and an index of a particular character within that element, compute a pointer to the TGHtmlBlock used to display that character and the index in the TGHtmlBlock of the character. ; Definition at line 209 of file TGHtmlIndex.cxx. ◆ InputSelected(). void TGHtml::InputSelected ; (; const char * ; name, . const char * ; val . ). virtual . Emit Selected() signal. ; Definition at line 1326 of file TGHtml.cxx. ◆ InsertToken(). TGHtmlElement * TGHtml::InsertToken ; (; TGHtmlElement * ; pToken, . char * ; zType, . char * ; zArgs, . int ; offs . ). protected . This routine takes a text representation of a token, converts it into an TGHtmlElement object and inserts it immediately prior to pToken. ; If pToken is 0, then the newly created TGHtmlElement is appended.; This routine does nothing to resize, restyle, relayout or redisplay the HTML. That is the calling routines responsibility.; Return the new TGHtmlElement object if successful. Return zero if zType is not a known markup name.; pToken - Insert before this. Append if pToken == 0 zType - Type of markup. Ex: ""/a"" or ""table"" zArgs - List of arguments offs - Calculate offset, and insert changed text into fZText! ; Definition at line 1113 of file TGHtmlParse.cxx. ◆ IsDarkColor(). int TGHtml::IsDarkColor ; (; ColorStruct_t * ; p). protected . Check to see if the given color is too dark to be easily distinguished from black. ; Definition at line 1678 of file TGHtml.cxx. ◆ IsLightColor(). int TGHtml::IsLightColor ; (; ColorStruct_t * ; p). protected . Check to see if the given color is too light to be easily distinguished from white. ; Definition at line 1725 o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:74526,rout,routine,74526,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['rout'],['routine']
Integrability," * ; fn, . TString & ; fdst, . TList & ; dirph . ). staticprivate . Parse file name extracting the directory subcomponents in dirs, stored as TObjStrings. ; Definition at line 745 of file TProofMgr.cxx. ◆ Reset(). Int_t TProofMgr::Reset ; (; Bool_t ; hard = kFALSE, . const char * ; usr = 0 . ). virtual . Send a cleanup request for the sessions associated with the current user. ; Not supported. ; Definition at line 307 of file TProofMgr.cxx. ◆ Rm(). Int_t TProofMgr::Rm ; (; const char * ; what, . const char * ; = 0, . const char * ; = 0 . ). virtual . Run 'rm' on 'what'. Locally it is just a call to TSystem::Unlink . ; Definition at line 1073 of file TProofMgr.cxx. ◆ SendMsgToUsers(). Int_t TProofMgr::SendMsgToUsers ; (; const char * ; , . const char * ; = 0 . ). virtual . Send a message to connected users. ; Only superusers can do this. The first argument specifies the message or the file from where to take the message. The second argument specifies the user to which to send the message: if empty or null the message is send to all the connected users. return 0 in case of success, -1 in case of error ; Definition at line 295 of file TProofMgr.cxx. ◆ SetAlias(). virtual void TProofMgr::SetAlias ; (; const char * ; alias = """"). inlinevirtual . Definition at line 104 of file TProofMgr.h. ◆ SetInvalid(). virtual void TProofMgr::SetInvalid ; (; ). inlinevirtual . Definition at line 78 of file TProofMgr.h. ◆ SetMssUrl(). virtual void TProofMgr::SetMssUrl ; (; const char * ; mss). inlinevirtual . Definition at line 105 of file TProofMgr.h. ◆ SetROOTVersion(). virtual Int_t TProofMgr::SetROOTVersion ; (; const char * ; ). inlinevirtual . Definition at line 106 of file TProofMgr.h. ◆ SetTXProofMgrHook(). void TProofMgr::SetTXProofMgrHook ; (; TProofMgr_t ; pmh). static . Set hook to TXProofMgr ctor. ; Definition at line 619 of file TProofMgr.cxx. ◆ ShowROOTVersions(). virtual void TProofMgr::ShowROOTVersions ; (; ). inlinevirtual . Definition at line 107 of file TProofMgr.h. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofMgr.html:26066,message,message,26066,doc/master/classTProofMgr.html,https://root.cern,https://root.cern/doc/master/classTProofMgr.html,2,['message'],['message']
Integrability," * ; frame, . PlotOpt ; o . ); const. protectedvirtual . Plotting engine function for internal use. ; Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted function that occur in the previously plotted dataset are projected via partial integration, otherwise no projections are performed. Optionally, certain projections can be performed by summing over the values present in a provided dataset ('projData'), to correctly project out data dependents that are not properly described by the PDF (e.g. per-event errors).; The functions value can be multiplied with an optional scale factor. The interpretation of the scale factor is unique for generic real functions, for PDFs there are various interpretations possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details).; The default projection behaviour can be overridden by supplying an optional set of dependents to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface to modify the default projection behaviour. ; Reimplemented in RooAbsPdf, and RooSimultaneous.; Definition at line 1931 of file RooAbsReal.cxx. ◆ plotOn() [3/3]. RooPlot * RooAbsReal::plotOn ; (; RooPlot * ; frame, . RooLinkedList & ; cmdList . ); const. virtual . Internal back-end function of plotOn() with named arguments. ; Reimplemented in RooAbsPdf, RooSimultaneous, and RooSimultaneous.; Definition at line 1659 of file RooAbsReal.cxx. ◆ plotOnCompSelect(). void RooAbsReal::plotOnCompSelect ; (; RooArgSet * ; selNodes); const. protected . Helper function for plotting of composite p.d.fs. ; Given a set of selected components that should be plotted, find all nodes that (in)directly depend on these selected nodes. Mark all directly and indirectly selected nodes as 'selected' using the selectComp() method ; Definition at line 1466 of file RooAbsReal.cxx. ◆ plotOnWithErrorBand(). RooPlot * RooAbsReal::plotOnWithErrorBand ; (; RooPlot * ; frame, . const RooFitResult & ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:137525,interface,interface,137525,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['interface'],['interface']
Integrability," * ; label, . bool ; printError = true . ). virtual . Change category state by specifying a state name. ; If printError is set, a message will be printed if the specified state name does not represent a valid state. Returnsbool to signal an error. ; Implements RooAbsCategoryLValue. ◆ setLabel() [3/4]. bool RooAbsCategoryLValue::setLabel ; (; const std::pair< std::string, value_type > & ; nameIdxPair, . bool ; printError = true . ). inline . Change category state to the state name of another category. ; If printError is set, a message will be printed if the specified state name does not represent a valid state. NoteThe state index of the other category is ignored. ; Returnsbool to signal an error. ; Definition at line 69 of file RooAbsCategoryLValue.h. ◆ setLabel() [4/4]. bool RooAbsCategoryLValue::setLabel ; (; const std::string & ; label, . bool ; printError = true . ). inline . Set value by specifying the name of the desired state. ; If printError is set, a message will be printed if the specified label does not represent a valid state. Returnsfalse on success. ; Definition at line 60 of file RooAbsCategoryLValue.h. ◆ setRange(). void RooCategory::setRange ; (; const char * ; rangeName, . const char * ; stateNameList . ). Definition at line 336 of file RooCategory.cxx. ◆ states(). std::map< std::string, RooAbsCategory::value_type > & RooCategory::states ; (; ). Return a reference to the map of state names to index states. ; This can be used to manipulate the category. NoteCalling this function will always trigger recomputations of of everything that depends on this category, since in case the map gets manipulated, names or indices might change. Also, the order that states have been inserted in gets lost. This changes what is returned by getOrdinal(). ; Definition at line 275 of file RooCategory.cxx. ◆ Streamer(). void RooCategory::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsCategoryLValue.; Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:64395,message,message,64395,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,1,['message'],['message']
Integrability," * ; name). virtual . Removes subdirectory from the directory When directory is deleted, all keys in all subdirectories will be read first and deleted from file (if exists) Equivalent call is Delete(""name;*"");. ; Reimplemented in TDirectoryFile.; Definition at line 1227 of file TDirectory.cxx. ◆ Save(). virtual void TDirectory::Save ; (; ). inlinevirtual . Reimplemented in TDirectoryFile.; Definition at line 253 of file TDirectory.h. ◆ SaveObjectAs(). Int_t TDirectory::SaveObjectAs ; (; const TObject * ; obj, . const char * ; filename = """", . Option_t * ; option = """" . ); const. virtual . Save object in filename, if filename is nullptr or """", a file with ""<objectname>.root"" is created. ; The name of the key is the object name. By default new file will be created. Using option ""a"", one can append object to the existing ROOT file. If the operation is successful, it returns the number of bytes written to the file otherwise it returns 0. By default a message is printed. Use option ""q"" to not print the message. If filename contains "".json"" extension, JSON representation of the object will be created and saved in the text file. Such file can be used in JavaScript ROOT (https://root.cern/js/) to display object in web browser When creating JSON file, option string may contain compression level from 0 to 3 (default 0) ; Reimplemented in TDirectoryFile.; Definition at line 1250 of file TDirectory.cxx. ◆ SaveSelf(). virtual void TDirectory::SaveSelf ; (; Bool_t ; = kFALSE). inlinevirtual . Reimplemented in TDirectoryFile.; Definition at line 255 of file TDirectory.h. ◆ SetBufferSize(). virtual void TDirectory::SetBufferSize ; (; Int_t ; ). inlinevirtual . Reimplemented in TDirectoryFile.; Definition at line 256 of file TDirectory.h. ◆ SetModified(). virtual void TDirectory::SetModified ; (; ). inlinevirtual . Reimplemented in TDirectoryFile.; Definition at line 257 of file TDirectory.h. ◆ SetMother(). virtual void TDirectory::SetMother ; (; TObject * ; mother). inlinevirtual . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTDirectory.html:47736,message,message,47736,doc/v632/classTDirectory.html,https://root.cern,https://root.cern/doc/v632/classTDirectory.html,2,['message'],['message']
Integrability," * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 38 of file RooKeysPdf.h. ◆ DeclFileName(). static const char * RooKeysPdf::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 80 of file RooKeysPdf.h. ◆ evaluate(). double RooKeysPdf::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 278 of file RooKeysPdf.cxx. ◆ g(). double RooKeysPdf::g ; (; double ; x, . double ; sigma . ); const. private . Definition at line 365 of file RooKeysPdf.cxx. ◆ getAnalyticalIntegral(). Int_t RooKeysPdf::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 301 of file RooKeysPdf.cxx. ◆ getMaxVal(). Int_t RooKeysPdf::getMaxVal ; (; const RooArgSet & ; vars); const. overridevirtual . Advertise capability to determine maximum value of function for given set of observables. ; If no direct generator method is provided, this information will assist the accept/reject generator to operate more efficiently as it can skip the initial trial sampling phase to empirically find the function maximum ; Reimplemented from RooAbsReal.; Definition at line 348 of file RooKeysPdf.cxx. ◆ IsA(). TClass * RooKeysPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooKeysPdf.html:78225,depend,dependents,78225,doc/master/classRooKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRooKeysPdf.html,2,"['depend', 'integrat']","['dependents', 'integration']"
Integrability," * ; optStr = """" . ). virtual . Shows datasets in locations that match the uri. ; By default shows the user's datasets and global ones ; Reimplemented in TProofLite.; Definition at line 10846 of file TProof.cxx. ◆ ShowEnabledPackages(). void TProof::ShowEnabledPackages ; (; Bool_t ; all = kFALSE). List which packages are enabled. ; If all is true show enabled packages for all active slaves. If everything is ok all active slaves should have the same packages enabled. ; Definition at line 7818 of file TProof.cxx. ◆ ShowFeedback(). void TProof::ShowFeedback ; (; ); const. Show items in feedback list. ; Definition at line 10020 of file TProof.cxx. ◆ ShowLog() [1/2]. void TProof::ShowLog ; (; const char * ; queryref). Display on screen the content of the temporary log file for query in reference. ; Definition at line 10338 of file TProof.cxx. ◆ ShowLog() [2/2]. void TProof::ShowLog ; (; Int_t ; qry = -1). Display on screen the content of the temporary log file. ; If qry == -2 show messages from the last (current) query. If qry == -1 all the messages not yet displayed are shown (default). If qry == 0, all the messages in the file are shown. If qry > 0, only the messages related to query 'qry' are shown. For qry != -1 the original file offset is restored at the end ; Definition at line 10371 of file TProof.cxx. ◆ ShowMissingFiles(). void TProof::ShowMissingFiles ; (; TQueryResult * ; qr = 0). Show information about missing files during query described by 'qr' or the last query if qr is null (default). ; A short summary is printed in the end. ; Definition at line 12522 of file TProof.cxx. ◆ ShowPackages(). void TProof::ShowPackages ; (; Bool_t ; all = kFALSE, . Bool_t ; redirlog = kFALSE . ). List contents of package directory. ; If all is true show all package directories also on slaves. If everything is ok all package directories should be the same. If redir is kTRUE the result is redirected to the log file (option available for internal actions). ; Definition at line 777",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:150134,message,messages,150134,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['message'],['messages']
Integrability," * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TClass * GetClass (const char *className);  Forward to TROOT::GetClass(). ;  ; static TClass * GetClass (const std::type_info &typeinfo);  Forward to TROOT::GetClass(). ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions;  TMessage (void *buf, Int_t bufsize);  Create a TMessage object for reading objects. ;  ; void SetLength () const;  Set the message length at the beginning of the message buffer. ;  ;  Protected Member Functions inherited from TBufferFile;  TBufferFile ();  ;  TBufferFile (const TBufferFile &)=delete;  not implemented ;  ; Int_t CheckByteCount (UInt_t startpos, UInt_t bcnt, const TClass *clss, const char *classname);  Check byte count with current buffer position. ;  ; void CheckCount (UInt_t offset) override;  Check if offset is not too large (< kMaxMapCount) when writing. ;  ; UInt_t CheckObject (UInt_t offset, const TClass *cl, Bool_t readClass=kFALSE);  Check for object in the read map. ;  ; void operator= (const TBufferFile &)=delete;  not implemented ;  ; void WriteObjectClass (const void *actualObjStart, const TClass *actualClass, Bool_t cacheReuse) override;  Write object to I/O buffer. ;  ;  Protected Member Functions inherited from TBufferIO;  TBufferIO ();  ;  TBufferIO (TBuffer::EMode mode);  constructor ;  ;  TBufferIO (TBuffer::EMode mode, Int_t bufsiz);  constructor ;  ;  TBufferIO (TBuffer::EMode m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMessage.html:34639,message,message,34639,doc/master/classTMessage.html,https://root.cern,https://root.cern/doc/master/classTMessage.html,2,['message'],['message']
Integrability," * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool canComputeBatchWithCuda () const override;  ; void doEval (RooFit::EvalContext &) const override;  do not persist ;  ; double evaluate () const override;  Evaluation. ;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Plot oneself on 'frame'. ;  ; Int_t * randomizeProtoOrder (Int_t nProto, Int_t nGen, bool resample=false) const;  Return lookup table with randomized order for nProto prototype events. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  The cache manager. ;  ; virtual bool syncNormalization (const RooArgSet *dset, bool adjustProxies=true) const;  Verify that the normalization integral cached with this PDF is valid for given set of normalization obser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPowerSum.html:59722,rout,routine,59722,doc/master/classRooPowerSum.html,https://root.cern,https://root.cern/doc/master/classRooPowerSum.html,1,['rout'],['routine']
Integrability," * GetLeafCounter (Int_t &countval) const;  Return a pointer to the counter of this leaf (if any) or store the number of elements that the leaf contains in countval. ;  ; virtual const Counts_t * GetLeafCountValues (Long64_t start, Long64_t len);  If this branch is a branch count, return the set of collection size for the entry range requested start: first entry to read and return information about len: number of entries to read. ;  ; virtual Int_t GetLen () const;  Return the number of effective elements of this leaf, for the current entry. ;  ; virtual Int_t GetLenStatic () const;  Return the fixed length of this leaf. ;  ; virtual Int_t GetLenType () const;  ; virtual Int_t GetMaximum () const;  ; virtual Int_t GetMinimum () const;  ; virtual Int_t GetNdata () const;  ; virtual Int_t GetOffset () const;  ; template<typename T > ; T GetTypedValue (Int_t i=0) const;  ; virtual Long64_t GetValueLong64 (Int_t i=0) const;  ; virtual LongDouble_t GetValueLongDouble (Int_t i=0) const;  ; virtual bool IncludeRange (TLeaf *);  ; virtual bool IsOnTerminalBranch () const;  ; virtual bool IsRange () const;  ; virtual bool IsUnsigned () const;  ; virtual bool ReadBasketFast (TBuffer &, Long64_t);  ; virtual bool ReadBasketSerialized (TBuffer &, Long64_t);  ; Int_t ResetAddress (void *add, bool calledFromDestructor=false);  Helper routine for TLeafX::SetAddress. ;  ; virtual void SetBranch (TBranch *branch);  ; virtual void SetLeafCount (TLeaf *leaf);  Set the leaf count of this leaf. ;  ; virtual void SetLen (Int_t len=1);  ; virtual void SetOffset (Int_t offset=0);  ; virtual void SetRange (bool range=true);  ; virtual void SetUnsigned ();  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLeafD32.html:3936,rout,routine,3936,doc/master/classTLeafD32.html,https://root.cern,https://root.cern/doc/master/classTLeafD32.html,2,['rout'],['routine']
Integrability," + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.0000000000000001E-9, double relTol = 1.0000000000000001E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. » Author: M. Slawinska 08/2007 » Copyright (c) 2007 , LCG ROOT MathLib Team *; » Last changed: root/mathcore:$Id$ » Last ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html:6965,integrat,integration,6965,root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html,8,"['integrat', 'interface']","['integration', 'interface']"
Integrability," , const char* , const char* = """", const char* = """"); { MayNotUse(""Query""); return 0; }. TGridResult * LocateSites(); { MayNotUse(""LocalSites""); return 0; }. TGridResult * Ls(const char* = """", Option_t* = """", Bool_t = kFALSE); --- Catalogue Interface. { MayNotUse(""Ls""); return 0; }. const char * Pwd(Bool_t = kFALSE); { MayNotUse(""Pwd""); return 0; }. const char * GetHomeDirectory(); { MayNotUse(""GetHomeDirectory""); return 0; }. Bool_t Cd(const char* = """", Bool_t = kFALSE); { MayNotUse(""Cd""); return kFALSE; }. Int_t Mkdir(const char* = """", Option_t* = """", Bool_t = kFALSE); { MayNotUse(""Mkdir""); return kFALSE; }. Bool_t Rmdir(const char* = """", Option_t* = """", Bool_t = kFALSE); { MayNotUse(""Mkdir""); return kFALSE; }. Bool_t Register(const char* , const char* , Long_t = -1, const char* = 0, const char* = 0, Bool_t = kFALSE); { MayNotUse(""Mkdir""); return kFALSE; }. Bool_t Rm(const char* , Option_t* = """", Bool_t = kFALSE); { MayNotUse(""Mkdir""); return kFALSE; }. TGridJob * Submit(const char* ); --- Job Submission Interface. { MayNotUse(""Submit""); return 0; }. TGridJDL * GetJDLGenerator(); { MayNotUse(""GetJDLGenerator""); return 0; }. TGridCollection * OpenCollection(const char* , UInt_t = 1000000); { MayNotUse(""OpenCollection""); return 0; }. TGridCollection * OpenCollectionQuery(TGridResult* , Bool_t = kFALSE); { MayNotUse(""OpenCollection""); return 0; }. TGridJobStatusList* Ps(const char* , Bool_t = kTRUE); { MayNotUse(""Ps""); return 0; }. Bool_t KillById(TString ); { MayNotUse(""KillById""); return kFALSE; }. Bool_t ResubmitById(TString ); { MayNotUse(""ResubmitById""); return 0; }. Bool_t Kill(TGridJob* gridjob); { return ((gridjob)?KillById(gridjob->GetJobID()):kFALSE); }. Bool_t Resubmit(TGridJob* gridjob); { return ((gridjob)?ResubmitById(gridjob->GetJobID()):kFALSE); }. » Author: Fons Rademakers 3/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGrid.html:9702,Interface,Interface,9702,root/html534/TGrid.html,https://root.cern,https://root.cern/root/html534/TGrid.html,1,['Interface'],['Interface']
Integrability," , const char* , const char* = """", const char* = """"); { MayNotUse(""Query""); return 0; }. TGridResult * LocateSites(); { MayNotUse(""LocalSites""); return 0; }. TGridResult * Ls(const char* = """", Option_t* = """", Bool_t = kFALSE); --- Catalogue Interface. { MayNotUse(""Ls""); return 0; }. const char * Pwd(Bool_t = kFALSE); { MayNotUse(""Pwd""); return 0; }. const char * GetHomeDirectory(); { MayNotUse(""GetHomeDirectory""); return 0; }. Bool_t Cd(const char* = """", Bool_t = kFALSE); { MayNotUse(""Cd""); return kFALSE; }. Int_t Mkdir(const char* = """", Option_t* = """", Bool_t = kFALSE); { MayNotUse(""Mkdir""); return kFALSE; }. Bool_t Rmdir(const char* = """", Option_t* = """", Bool_t = kFALSE); { MayNotUse(""Mkdir""); return kFALSE; }. Bool_t Register(const char* , const char* , Long_t = -1, const char* = 0, const char* = 0, Bool_t = kFALSE); { MayNotUse(""Mkdir""); return kFALSE; }. Bool_t Rm(const char* , Option_t* = """", Bool_t = kFALSE); { MayNotUse(""Mkdir""); return kFALSE; }. TGridJob * Submit(const char* ); --- Job Submission Interface. { MayNotUse(""Submit""); return 0; }. TGridJDL * GetJDLGenerator(); { MayNotUse(""GetJDLGenerator""); return 0; }. TGridCollection * OpenCollection(const char* , UInt_t = 1000000); { MayNotUse(""OpenCollection""); return 0; }. TGridCollection * OpenCollectionQuery(TGridResult* , Bool_t = kFALSE); { MayNotUse(""OpenCollection""); return 0; }. TGridJobStatusList* Ps(const char* , Bool_t = kTRUE); { MayNotUse(""Ps""); return 0; }. Bool_t KillById(TString ); { MayNotUse(""KillById""); return kFALSE; }. Bool_t ResubmitById(TString ); { MayNotUse(""ResubmitById""); return 0; }. Bool_t Kill(TGridJob* gridjob); { return ((gridjob)?KillById(gridjob->GetJobID()):kFALSE); }. Bool_t Resubmit(TGridJob* gridjob); { return ((gridjob)?ResubmitById(gridjob->GetJobID()):kFALSE); }. » Author: Fons Rademakers 3/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 16:06; This page has been automatically generated. F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGrid.html:10163,Interface,Interface,10163,root/html604/TGrid.html,https://root.cern,https://root.cern/root/html604/TGrid.html,1,['Interface'],['Interface']
Integrability," , const char* , const char* = """", const char* = """"); { MayNotUse(""Query""); return 0; }. TGridResult * LocateSites(); { MayNotUse(""LocalSites""); return 0; }. TGridResult * Ls(const char* = """", Option_t* = """", Bool_t = kFALSE); --- Catalogue Interface. { MayNotUse(""Ls""); return 0; }. const char * Pwd(Bool_t = kFALSE); { MayNotUse(""Pwd""); return 0; }. const char * GetHomeDirectory(); { MayNotUse(""GetHomeDirectory""); return 0; }. Bool_t Cd(const char* = """", Bool_t = kFALSE); { MayNotUse(""Cd""); return kFALSE; }. Int_t Mkdir(const char* = """", Option_t* = """", Bool_t = kFALSE); { MayNotUse(""Mkdir""); return kFALSE; }. Bool_t Rmdir(const char* = """", Option_t* = """", Bool_t = kFALSE); { MayNotUse(""Mkdir""); return kFALSE; }. Bool_t Register(const char* , const char* , Long_t = -1, const char* = 0, const char* = 0, Bool_t = kFALSE); { MayNotUse(""Mkdir""); return kFALSE; }. Bool_t Rm(const char* , Option_t* = """", Bool_t = kFALSE); { MayNotUse(""Mkdir""); return kFALSE; }. TGridJob * Submit(const char* ); --- Job Submission Interface. { MayNotUse(""Submit""); return 0; }. TGridJDL * GetJDLGenerator(); { MayNotUse(""GetJDLGenerator""); return 0; }. TGridCollection * OpenCollection(const char* , UInt_t = 1000000); { MayNotUse(""OpenCollection""); return 0; }. TGridCollection * OpenCollectionQuery(TGridResult* , Bool_t = kFALSE); { MayNotUse(""OpenCollection""); return 0; }. TGridJobStatusList* Ps(const char* , Bool_t = kTRUE); { MayNotUse(""Ps""); return 0; }. Bool_t KillById(TString ); { MayNotUse(""KillById""); return kFALSE; }. Bool_t ResubmitById(TString ); { MayNotUse(""ResubmitById""); return 0; }. Bool_t Kill(TGridJob* gridjob); { return ((gridjob)?KillById(gridjob->GetJobID()):kFALSE); }. Bool_t Resubmit(TGridJob* gridjob); { return ((gridjob)?ResubmitById(gridjob->GetJobID()):kFALSE); }. » Author: Fons Rademakers 3/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 15:06; This page has been automatically generated. F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGrid.html:10163,Interface,Interface,10163,root/html602/TGrid.html,https://root.cern,https://root.cern/root/html602/TGrid.html,1,['Interface'],['Interface']
Integrability," , const char* , const char* = """", const char* = """"); { MayNotUse(""Query""); return 0; }. TGridResult * LocateSites(); { MayNotUse(""LocalSites""); return 0; }. TGridResult * Ls(const char* = """", Option_t* = """", Bool_t = kFALSE); --- Catalogue Interface. { MayNotUse(""Ls""); return 0; }. const char * Pwd(Bool_t = kFALSE); { MayNotUse(""Pwd""); return 0; }. const char * GetHomeDirectory(); { MayNotUse(""GetHomeDirectory""); return 0; }. Bool_t Cd(const char* = """", Bool_t = kFALSE); { MayNotUse(""Cd""); return kFALSE; }. Int_t Mkdir(const char* = """", Option_t* = """", Bool_t = kFALSE); { MayNotUse(""Mkdir""); return kFALSE; }. Bool_t Rmdir(const char* = """", Option_t* = """", Bool_t = kFALSE); { MayNotUse(""Mkdir""); return kFALSE; }. Bool_t Register(const char* , const char* , Long_t = -1, const char* = 0, const char* = 0, Bool_t = kFALSE); { MayNotUse(""Mkdir""); return kFALSE; }. Bool_t Rm(const char* , Option_t* = """", Bool_t = kFALSE); { MayNotUse(""Mkdir""); return kFALSE; }. TGridJob * Submit(const char* ); --- Job Submission Interface. { MayNotUse(""Submit""); return 0; }. TGridJDL * GetJDLGenerator(); { MayNotUse(""GetJDLGenerator""); return 0; }. TGridCollection * OpenCollection(const char* , UInt_t = 1000000); { MayNotUse(""OpenCollection""); return 0; }. TGridCollection * OpenCollectionQuery(TGridResult* , Bool_t = kFALSE); { MayNotUse(""OpenCollection""); return 0; }. TGridJobStatusList* Ps(const char* , Bool_t = kTRUE); { MayNotUse(""Ps""); return 0; }. Bool_t KillById(TString ); { MayNotUse(""KillById""); return kFALSE; }. Bool_t ResubmitById(TString ); { MayNotUse(""ResubmitById""); return 0; }. Bool_t Kill(TGridJob* gridjob); { return ((gridjob)?KillById(gridjob->GetJobID()):kFALSE); }. Bool_t Resubmit(TGridJob* gridjob); { return ((gridjob)?ResubmitById(gridjob->GetJobID()):kFALSE); }. » Author: Fons Rademakers 3/1/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TGrid.h 31993 2010-01-12 14:34:41Z rdm $ » Last generated: 2011-11-03 20:18; This",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGrid.html:9683,Interface,Interface,9683,root/html532/TGrid.html,https://root.cern,https://root.cern/root/html532/TGrid.html,1,['Interface'],['Interface']
Integrability," , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <RooStats/BayesianCalculator.h>. Inheritance diagram for RooStats::BayesianCalculator:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ BayesianCalculator() [1/3]. RooStats::BayesianCalculator::BayesianCalculator ; (; ). constructor ; default constructor ; Definition at line 632 of file BayesianCalculator.cxx. ◆ BayesianCalculator() [2/3]. RooStats::BayesianCalculator::BayesianCalculator ; (; RooAbsData & ; data, . RooAbsPdf & ; pdf, . const RooArgSet & ; POI, . RooAbsPdf & ; priorPdf, . const RooArgSet * ; nuisanceParameters = nullptr . ). Constructor from data set, model pdf, parameter of interests and prior pdf If nuisance parameters are given they will be integrated according either to the prior or their constraint term included in the model. ; Definition at line 654 of file BayesianCalculator.cxx. ◆ BayesianCalculator() [3/3]. RooStats::BayesianCalculator::BayesianCalculator ; (; RooAbsData & ; data, . ModelConfig & ; model . ). Constructor from a data set and a ModelConfig model pdf, poi and nuisances will be taken from the ModelConfig. ; Definition at line 685 of file BayesianCalculator.cxx. ◆ ~BayesianCalculator(). RooStats::BayesianCalculator::~BayesianCalculator ; (; ). override . destructor ; Definition at line 705 of file BayesianCalculator.cxx. Member Function Documentation. ◆ ApproximatePosterior(). void RooStats::BayesianCalculator::ApproximatePosterior ; (; ); const. protected . approximate posterior in nbins using a TF1 scan the poi values and evaluate the posterior at each point and save the result in a cloned TF1 For each point the posterior is evaluated by integrating the nuisance parameters ; Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html:21274,integrat,integrated,21274,doc/master/classRooStats_1_1BayesianCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html,1,['integrat'],['integrated']
Integrability," - X number of the cell; IY - Y number of the cell; NV - number of values for given cell; XY(2,4)- coordinates of the cell corners; V(NV) - cell values; T(4,NV)- additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this line; ICODES(1) - IX; ICODES(2) - IY; ICODES(3) - IV; ICODES(4) - side: 1-face,2-right,3-back,4-left,; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes; IFACE(NP) - face; T(4) - additional function (here Z-coordinate). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoPolar(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in polar coordinates. Input: IORDR - order of variables (0 - R,PHI; 1 - PHI,R); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV) - cell values; TT(4,*) - additional function. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; ICODES(3) - IV; ICODES(4) - side: 1-internal,2-right,3-external,4-left; 5-bottom, 6-top; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void LegoCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw stack of lego-plots in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI; 1 - PHI,Z); NA - number of steps along 1st variable; NPHI - number of steps along 2nd variable. FUN(IA,IB,NV,AB,V,TT) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; NV - number of values for given cell; AB(2,4) - coordinates of the cell corners; V(NV)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPainter3dAlgorithms.html:23398,rout,routine,23398,root/html528/TPainter3dAlgorithms.html,https://root.cern,https://root.cern/root/html528/TPainter3dAlgorithms.html,10,['rout'],['routine']
Integrability," - the structure from which the values are to be taken.; wtype - the window type. Int_t OpenDisplay(const char* dpyName); Opens connection to display server (if such a thing exist on the; current platform). The encoding and interpretation of the display; name; On X11 this method returns on success the X display socket descriptor; >0, 0 in case of batch mode, and <0 in case of failure (cannot connect; to display dpyName). void CloseDisplay(); Closes connection to display server and destroys all windows. Display_t GetDisplay() const; Returns handle to display (might be usefull in some cases where; direct X11 manipulation outside of TVirtualX is needed, e.g. GL; interface). Visual_t GetVisual() const; Returns handle to visual. Might be usefull in some cases where direct X11 manipulation outside; of TVirtualX is needed, e.g. GL interface. Int_t GetScreen() const; Returns screen number. Might be usefull in some cases where direct X11 manipulation outside; of TVirtualX is needed, e.g. GL interface. Int_t GetDepth() const; Returns depth of screen (number of bit planes).; Equivalent to GetPlanes(). Colormap_t GetColormap() const; Returns handle to colormap. Might be usefull in some cases where direct X11 manipulation outside; of TVirtualX is needed, e.g. GL interface. Window_t GetDefaultRootWindow() const; Returns handle to the default root window created when calling; XOpenDisplay(). Atom_t InternAtom(const char* atom_name, Bool_t only_if_exist); Returns the atom identifier associated with the specified ""atom_name""; string. If ""only_if_exists"" is False, the atom is created if it does; not exist. If the atom name is not in the Host Portable Character; Encoding, the result is implementation dependent. Uppercase and; lowercase matter; the strings ""thing"", ""Thing"", and ""thinG"" all; designate different atoms. Window_t GetParent(Window_t id) const; Returns the parent of the window ""id"". FontStruct_t LoadQueryFont(const char* font_name); Provides the most common way for accessing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualX.html:39140,interface,interface,39140,root/html528/TVirtualX.html,https://root.cern,https://root.cern/root/html528/TVirtualX.html,10,['interface'],['interface']
Integrability," -- Debugging tool; const RooArgSet*_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; string_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_t_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_t_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_t_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooAbsTestStatistic**_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpMode_gofOpModeOperation mode of test statistic instance ; Bool_t_init! Is object initialized ; RooRealMPFE**_mpfeArray! Array of parallel execution frond ends; Bool_t_mpinterlUse interleaving strategy rather than N-wise split for partioning of dataset for multiprocessor-split; Int_t_nCPUNumber of processors to use in parallel calculation mode; Int_t_nEventsTotal number of events in test statistic calculation; Int_t_nGofNumber of sub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsTestStatistic.html:34317,integrat,integrator,34317,root/html528/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsTestStatistic.html,2,['integrat'],['integrator']
Integrability," -- Destructor. void Browse(TBrowser* b); Browse the content of this leaf. void FillBasket(TBuffer& b); -- Pack leaf elements in Basket output buffer. TLeaf* GetLeafCounter(Int_t& countval) const; -- Return a pointer to the counter of this leaf. If leaf name has the form var[nelem], where nelem is alphanumeric, then; If nelem is a leaf name, return countval = 1 and the pointer to; the leaf named nelem.; If leaf name has the form var[nelem], where nelem is a digit, then; return countval = nelem and a null pointer.; If leaf name has the form of a multi dimenantion array (eg var[nelem][nelem2]; where nelem and nelem2 are digits) then; return countval = product of all dimension size and a null pointer.; If leaf name has the form var[... (and do not match the previous 2; cases) return countval = -1 and null pointer;; Otherwise return countval=1 and a null pointer. Int_t GetLen() const; -- Return the number of effective elements of this leaf. Int_t ResetAddress(void* add, Bool_t destructor = kFALSE); -- Helper routine for TLeafX::SetAddress. The return value is non-zero if we owned the old; value buffer and must delete it now. The size; of the value buffer is recalculated and stored,; and a decision is made whether or not we own the; new value buffer. void SetLeafCount(TLeaf* leaf); -- Set the leaf count of this leaf. void Streamer(TBuffer& b); -- Stream a class object. Double_t GetValue(Int_t i = 0) const; { return 0.0; }. void PrintValue(Int_t i = 0) const; {}. void SetAddress(void* add = 0); {}. void Export(TClonesArray* , Int_t ); {}. TBranch * GetBranch() const; { return fBranch; }. TLeaf * GetLeafCount() const; { return fLeafCount; }. Int_t GetLenStatic() const; { return fLen; }. Int_t GetLenType() const; { return fLenType; }. Int_t GetMaximum() const; { return 0; }. Int_t GetMinimum() const; { return 0; }. Int_t GetNdata() const; { return fNdata; }. Int_t GetOffset() const; { return fOffset; }. void * GetValuePointer() const; { return 0; }. const char * GetTypeName(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLeaf.html:8496,rout,routine,8496,root/html528/TLeaf.html,https://root.cern,https://root.cern/root/html528/TLeaf.html,1,['rout'],['routine']
Integrability," ----------------------------------------------------------------------------------; ; # Calculate projection of signal and total likelihood on (y,z) observables; # i.e. integrate signal and composite model over x; sigyz = sig.createProjection({x}); totyz = model.createProjection({x}); ; # Construct the log of the signal / signal+background probability; llratio_func = ROOT.RooFormulaVar(""llratio"", ""log10(@0)-log10(@1)"", [sigyz, totyz]); ; # Plot data with a LL ratio cut; # -------------------------------------------------------; ; # Calculate the llratio value for each event in the dataset; data.addColumn(llratio_func); ; # Extract the subset of data with large signal likelihood; dataSel = data.reduce(Cut=""llratio>0.7""); ; # Make plot frame; frame2 = x.frame(Title=""Same projection on X with LLratio(y,z)>0.7"", Bins=40); ; # Plot select data on frame; dataSel.plotOn(frame2); ; # Make MC projection of pdf with same LL ratio cut; # ---------------------------------------------------------------------------------------------; ; # Generate large number of events for MC integration of pdf projection; mcprojData = model.generate({x, y, z}, 10000); ; # Calculate LL ratio for each generated event and select MC events with; # llratio)0.7; mcprojData.addColumn(llratio_func); mcprojDataSel = mcprojData.reduce(Cut=""llratio>0.7""); ; # Project model on x, projected observables (y,z) with Monte Carlo technique; # on set of events with the same llratio cut as was applied to data; model.plotOn(frame2, ProjWData=mcprojDataSel); ; c = ROOT.TCanvas(""rf316_llratioplot"", ""rf316_llratioplot"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); c.SaveAs(""rf316_llratioplot.png""); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf316__llratioplot_8py.html:2705,integrat,integration,2705,doc/master/rf316__llratioplot_8py.html,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8py.html,1,['integrat'],['integration']
Integrability," -------------------------------------------------------; ; # Calculate the llratio value for each event in the dataset; data.addColumn(llratio_func); ; # Extract the subset of data with large signal likelihood; dataSel = data.reduce(Cut=""llratio>0.7""); ; # Make plot frame; frame2 = x.frame(Title=""Same projection on X with LLratio(y,z)>0.7"", Bins=40); ; # Plot select data on frame; dataSel.plotOn(frame2); ; # Make MC projection of pdf with same LL ratio cut; # ---------------------------------------------------------------------------------------------; ; # Generate large number of events for MC integration of pdf projection; mcprojData = model.generate({x, y, z}, 10000); ; # Calculate LL ratio for each generated event and select MC events with; # llratio)0.7; mcprojData.addColumn(llratio_func); mcprojDataSel = mcprojData.reduce(Cut=""llratio>0.7""); ; # Project model on x, projected observables (y,z) with Monte Carlo technique; # on set of events with the same llratio cut as was applied to data; model.plotOn(frame2, ProjWData=mcprojDataSel); ; c = ROOT.TCanvas(""rf316_llratioplot"", ""rf316_llratioplot"", 800, 400); c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.4); frame2.Draw(); c.SaveAs(""rf316_llratioplot.png""); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x integrates over variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) plot on x averages using data variables (y,z); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) only the following components of the projection data will be used: (y,z); [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf316_llratioplot.py. tutorialsroofitrf316_llratioplot.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf316__llratioplot_8py.html:3523,integrat,integrates,3523,doc/master/rf316__llratioplot_8py.html,https://root.cern,https://root.cern/doc/master/rf316__llratioplot_8py.html,1,['integrat'],['integrates']
Integrability," -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");; TSystem::SetMakeExevirtual void SetMakeExe(const char *directives)Directives has the same syntax as the argument of SetMakeSharedLib but is used to create an executabl...Definition TSystem.cxx:4093. Definition at line 4093 of file TSystem.cxx. ◆ SetMakeSharedLib(). void TSystem::SetMakeSharedLib ; (; const char * ; directives). virtual . Directives should contain the description on how to compile and link a shared lib. ; This description can be any valid shell command, including the use of ';' to separate several instructions. However, shell specific construct should be avoided. In particular this description can contain environment variables, like $ROOTSYS (or ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this library depends on; $ObjectFiles Name of source files to be compiler with; their extension changed to .o or .obj; $Opt location of the optimization/debug options; set fFlagsDebug and fFlagsOpt; onOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void onDefinition TGWin32VirtualXProxy.cxx:106; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; extensionconst char * extensionDefinition civetweb.c:8025; TSystem::fFlagsOptTString fFlagsOptDefinition TSystem.h:309; TSystem::fLinkedLibsTString fLinkedLibsDefinition TSystem.h:312; TSystem::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:89102,depend,depends,89102,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['depend'],['depends']
Integrability," . Check if window win is DND aware. ; Definition at line 345 of file TGDNDManager.cxx. ◆ IsDragging(). Bool_t TGDNDManager::IsDragging ; (; ); const. inline . Definition at line 173 of file TGDNDManager.h. ◆ IsTopLevel(). Bool_t TGDNDManager::IsTopLevel ; (; Window_t ; win). protected . ◆ operator=(). TGDNDManager & TGDNDManager::operator= ; (; const TGDNDManager & ; ). privatedelete . ◆ RemoveRootProxy(). Bool_t TGDNDManager::RemoveRootProxy ; (; ). Remove root window proxy. ; Definition at line 1064 of file TGDNDManager.cxx. ◆ SendDNDDrop(). void TGDNDManager::SendDNDDrop ; (; Window_t ; target). protected . Send DND drop message to target window. ; Definition at line 588 of file TGDNDManager.cxx. ◆ SendDNDEnter(). void TGDNDManager::SendDNDEnter ; (; Window_t ; target). protected . Send DND enter message to target window. ; Definition at line 481 of file TGDNDManager.cxx. ◆ SendDNDFinished(). void TGDNDManager::SendDNDFinished ; (; Window_t ; src). protected . Send DND finished message to source window. ; Definition at line 609 of file TGDNDManager.cxx. ◆ SendDNDLeave(). void TGDNDManager::SendDNDLeave ; (; Window_t ; target). protected . Send DND leave message to target window. ; Definition at line 521 of file TGDNDManager.cxx. ◆ SendDNDPosition(). void TGDNDManager::SendDNDPosition ; (; Window_t ; target, . int ; x, . int ; y, . Atom_t ; action, . Time_t ; timestamp . ). protected . Send DND position message to target window. ; Definition at line 543 of file TGDNDManager.cxx. ◆ SendDNDStatus(). void TGDNDManager::SendDNDStatus ; (; Window_t ; target, . Atom_t ; action . ). protected . Send DND status message to source window. ; Definition at line 566 of file TGDNDManager.cxx. ◆ SetDragPixmap(). void TGDNDManager::SetDragPixmap ; (; Pixmap_t ; pic, . Pixmap_t ; mask, . Int_t ; hot_x, . Int_t ; hot_y . ). Set drag window pixmaps and hotpoint. ; Definition at line 893 of file TGDNDManager.cxx. ◆ SetMainFrame(). void TGDNDManager::SetMainFrame ; (; TGFrame * ; mai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDNDManager.html:23434,message,message,23434,doc/master/classTGDNDManager.html,https://root.cern,https://root.cern/doc/master/classTGDNDManager.html,1,['message'],['message']
Integrability," . Definition at line 64 of file FitterBase.h. ◆ GetName(). const char * TMVA::FitterBase::GetName ; (; ); const. inlinevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 70 of file FitterBase.h. ◆ GetNpars(). Int_t TMVA::FitterBase::GetNpars ; (; ); const. inline . Definition at line 67 of file FitterBase.h. ◆ IsA(). virtual TClass * TMVA::FitterBase::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::Configurable.; Reimplemented in TMVA::GeneticFitter, TMVA::MCFitter, TMVA::MinuitFitter, and TMVA::SimulatedAnnealingFitter.; Definition at line 97 of file FitterBase.h. ◆ Log(). MsgLogger & TMVA::FitterBase::Log ; (; ); const. inlineprotected . message logger ; Definition at line 89 of file FitterBase.h. ◆ Run() [1/2]. Double_t TMVA::FitterBase::Run ; (; ). estimator function interface for fitting ; Definition at line 74 of file FitterBase.cxx. ◆ Run() [2/2]. virtual Double_t TMVA::FitterBase::Run ; (; std::vector< Double_t > & ; pars). pure virtual . Implemented in TMVA::GeneticFitter, TMVA::MCFitter, TMVA::MinuitFitter, and TMVA::SimulatedAnnealingFitter. ◆ SetIPythonInteractive(). void TMVA::FitterBase::SetIPythonInteractive ; (; bool * ; ExitFromTraining, . UInt_t * ; fIPyMaxIter_, . UInt_t * ; fIPyCurrentIter_ . ). inline . Definition at line 73 of file FitterBase.h. ◆ Streamer(). virtual void TMVA::FitterBase::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TMVA::Configurable.; Reimplemented in TMVA::GeneticFitter, TMVA::MCFitter, TMVA::MinuitFitter, and TMVA::SimulatedAnnealingFitter. ◆ StreamerNVirtual(). void TMVA::FitterBase::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 97 of file FitterBase.h. Member Data Documentation. ◆ fClassName. TString TMVA::FitterBase::fClassName. p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1FitterBase.html:17331,interface,interface,17331,doc/master/classTMVA_1_1FitterBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1FitterBase.html,1,['interface'],['interface']
Integrability," . Definition at line 90 of file Rule.h. ◆ SetSSBNeve(). void TMVA::Rule::SetSSBNeve ; (; Double_t ; v). inline . Definition at line 93 of file Rule.h. ◆ SetSupport(). void TMVA::Rule::SetSupport ; (; Double_t ; v). inline . Definition at line 87 of file Rule.h. Friends And Related Symbol Documentation. ◆ operator<<. std::ostream & operator<< ; (; std::ostream & ; os, . const Rule & ; rule . ). friend . Member Data Documentation. ◆ fCoefficient. Double_t TMVA::Rule::fCoefficient. private . rule coeff. a(k) ; Definition at line 176 of file Rule.h. ◆ fCut. RuleCut* TMVA::Rule::fCut. private . all cuts associated with the rule ; Definition at line 172 of file Rule.h. ◆ fImportance. Double_t TMVA::Rule::fImportance. private . importance of rule ; Definition at line 177 of file Rule.h. ◆ fImportanceRef. Double_t TMVA::Rule::fImportanceRef. private . importance ref ; Definition at line 178 of file Rule.h. ◆ fLogger. MsgLogger* TMVA::Rule::fLogger. mutableprivate . ! message logger ; Definition at line 183 of file Rule.h. ◆ fNorm. Double_t TMVA::Rule::fNorm. private . normalization - usually 1.0/t(k) ; Definition at line 173 of file Rule.h. ◆ fRuleEnsemble. const RuleEnsemble* TMVA::Rule::fRuleEnsemble. private . pointer to parent RuleEnsemble ; Definition at line 179 of file Rule.h. ◆ fSigma. Double_t TMVA::Rule::fSigma. private . t(k) = sqrt(s*(1-s)) ; Definition at line 175 of file Rule.h. ◆ fSSB. Double_t TMVA::Rule::fSSB. private . S/(S+B) for rule. ; Definition at line 180 of file Rule.h. ◆ fSSBNeve. Double_t TMVA::Rule::fSSBNeve. private . N(events) reaching the last node in reevaluation. ; Definition at line 181 of file Rule.h. ◆ fSupport. Double_t TMVA::Rule::fSupport. private . s(k) ; Definition at line 174 of file Rule.h. Libraries for TMVA::Rule:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/Rule.h; tmva/tmva/src/Rule.cxx. TMVARule. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:42 (GVA ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Rule.html:10882,message,message,10882,doc/master/classTMVA_1_1Rule.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Rule.html,1,['message'],['message']
Integrability," . Definition at line 98 of file TTreeDrawArgsParser.h. ◆ GetShouldDraw(). bool TTreeDrawArgsParser::GetShouldDraw ; (; ); const. inline . Definition at line 88 of file TTreeDrawArgsParser.h. ◆ GetVarExp() [1/2]. TString TTreeDrawArgsParser::GetVarExp ; (; ); const. Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. ; Definition at line 405 of file TTreeDrawArgsParser.cxx. ◆ GetVarExp() [2/2]. TString TTreeDrawArgsParser::GetVarExp ; (; Int_t ; num); const. Returns the num-th variable string in case of an error prints an error message and returns an empty string. ; Definition at line 393 of file TTreeDrawArgsParser.cxx. ◆ IsA(). TClass * TTreeDrawArgsParser::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 106 of file TTreeDrawArgsParser.h. ◆ IsSpecified(). bool TTreeDrawArgsParser::IsSpecified ; (; int ; num); const. returns true if the num-th parameter was specified otherwise returns fFALSE in case of an error (wrong num) prints an error message and returns false. ; Definition at line 380 of file TTreeDrawArgsParser.cxx. ◆ Parse(). bool TTreeDrawArgsParser::Parse ; (; const char * ; varexp, . const char * ; selection, . Option_t * ; option . ). Parses parameters from TTree::Draw(). . varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawing option; see TTree::Draw . Definition at line 237 of file TTreeDrawArgsParser.cxx. ◆ ParseName(). bool TTreeDrawArgsParser::ParseName ; (; TString ; name). protected . Syntax: ; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName to appropriate values.; Returns false in case of an error. ; Definition at line 131 of file TTreeDrawArgsParser.cxx. ◆ ParseOption(). bool TTreeDrawArgsParser::ParseOption ; (; ). protected . Check if options contain some data important f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeDrawArgsParser.html:18870,message,message,18870,doc/master/classTTreeDrawArgsParser.html,https://root.cern,https://root.cern/doc/master/classTTreeDrawArgsParser.html,1,['message'],['message']
Integrability," . Implemented in TBufferText, and TBufferFile. ◆ ReadWithNbits() [2/2]. virtual void TBuffer::ReadWithNbits ; (; Float_t * ; ptr, . Int_t ; nbits . ). pure virtual . Implemented in TBufferText, and TBufferFile. ◆ Reset(). virtual void TBuffer::Reset ; (; ). pure virtual . Implemented in TBufferIO, and TMessage. ◆ ResetMap(). virtual void TBuffer::ResetMap ; (; ). pure virtual . Implemented in TBufferIO. ◆ SetBuffer(). void TBuffer::SetBuffer ; (; void * ; buf, . UInt_t ; newsiz = 0, . Bool_t ; adopt = kTRUE, . ReAllocCharFun_t ; reallocfunc = nullptr . ). Sets a new buffer in an existing TBuffer object. ; If newsiz=0 then the new buffer is expected to have the same size as the previous buffer. The current buffer position is reset to the start of the buffer. If the TBuffer owned the previous buffer, it will be deleted prior to accepting the new buffer. By default the new buffer will be adopted unless adopt is false.; If the new buffer is not adopted and no memory allocation routine is provided, a Fatal error will be issued if the Buffer attempts to expand. ; Definition at line 187 of file TBuffer.cxx. ◆ SetBufferDisplacement() [1/2]. virtual void TBuffer::SetBufferDisplacement ; (; ). pure virtual . Implemented in TBufferIO. ◆ SetBufferDisplacement() [2/2]. virtual void TBuffer::SetBufferDisplacement ; (; Int_t ; skipped). pure virtual . Implemented in TBufferIO. ◆ SetBufferOffset(). void TBuffer::SetBufferOffset ; (; Int_t ; offset = 0). inline . Definition at line 93 of file TBuffer.h. ◆ SetByteCount(). virtual void TBuffer::SetByteCount ; (; UInt_t ; cntpos, . Bool_t ; packInVersion = kFALSE . ). pure virtual . Implemented in TBufferFile, and TBufferText. ◆ SetParent(). void TBuffer::SetParent ; (; TObject * ; parent). Set parent owning this buffer. ; Definition at line 270 of file TBuffer.cxx. ◆ SetPidOffset(). virtual void TBuffer::SetPidOffset ; (; UShort_t ; offset). pure virtual . Implemented in TBufferIO. ◆ SetReadMode(). void TBuffer::SetReadMode ; (; ). Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer.html:53423,rout,routine,53423,doc/master/classTBuffer.html,https://root.cern,https://root.cern/doc/master/classTBuffer.html,1,['rout'],['routine']
Integrability," . Implements RooAbsArg.; Definition at line 40 of file RooBCPGenDecay.h. ◆ coefAnalyticalIntegral(). double RooBCPGenDecay::coefAnalyticalIntegral ; (; Int_t ; coef, . Int_t ; code, . const char * ; rangeName = nullptr . ); const. overridevirtual . Default implementation of function implementing advertised integrals. ; Only the pass-through scenario (no integration) is implemented. ; Reimplemented from RooAbsAnaConvPdf.; Definition at line 152 of file RooBCPGenDecay.cxx. ◆ coefficient(). double RooBCPGenDecay::coefficient ; (; Int_t ; basisIndex); const. overridevirtual . B0 : _tag = +1 B0bar : _tag = -1. ; Implements RooAbsAnaConvPdf.; Definition at line 118 of file RooBCPGenDecay.cxx. ◆ DeclFileName(). static const char * RooBCPGenDecay::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 69 of file RooBCPGenDecay.h. ◆ generateEvent(). void RooBCPGenDecay::generateEvent ; (; Int_t ; code). overridevirtual . Generate mix-state dependent. ; Reimplemented from RooAbsPdf.; Definition at line 206 of file RooBCPGenDecay.cxx. ◆ getCoefAnalyticalIntegral(). Int_t RooBCPGenDecay::getCoefAnalyticalIntegral ; (; Int_t ; coef, . RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Default implementation of function advertising integration capabilities. ; The interface is similar to that of getAnalyticalIntegral except that an integer code is added that designates the coefficient number for which the integration capabilities are requested; This default implementation advertises that no internal integrals are supported. ; Reimplemented from RooAbsAnaConvPdf.; Definition at line 143 of file RooBCPGenDecay.cxx. ◆ getGenerator(). Int_t RooBCPGenDecay::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Load generatedVars with the subset of directVars that we can generate ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBCPGenDecay.html:80549,depend,dependent,80549,doc/master/classRooBCPGenDecay.html,https://root.cern,https://root.cern/doc/master/classRooBCPGenDecay.html,1,['depend'],['dependent']
Integrability," . Note: in cases where the function to be executed takes more than zero/one argument but all are fixed except zero/one, the function can be wrapped in a lambda or via std::bind to give it the right signature.; Note: the user should take care of initializing random seeds differently in each process (e.g. using the process id in the seed). Otherwise several parallel executions might generate the same sequence of pseudo-random numbers.; Return value:; An std::vector. The elements in the container will be the objects returned by func.; Examples:; root[] ROOT::TProcessExecutor pool; auto hists = pool.Map(CreateHisto, 10);; root[] ROOT::TProcessExecutor pool(2); auto squares = pool.Map([](int a) { return a*a; }, {1,2,3});; a#define a(i)Definition RSha256.hxx:99; ROOT::TExecutorCRTP::Mapauto Map(F func, unsigned nTimes) -> std::vector< InvokeResult_t< F > >Execute a function without arguments several times.Definition TExecutorCRTP.hxx:185; ROOT::TProcessExecutorThis class provides a simple interface to execute the same task multiple times in parallel,...Definition TProcessExecutor.hxx:37. ROOT::TProcessExecutor::MapReduce; This set of methods behaves exactly like Map, but takes an additional function as a third argument. This function is applied to the set of objects returned by the corresponding Map execution to ""squash"" them into a single object.; Examples:; root[] ROOT::TProcessExecutor pool; auto ten = pool.MapReduce([]() { return 1; }, 10, [](const std::vector<int> &v) { return std::accumulate(v.begin(), v.end(), 0); }); root[] ROOT::TProcessExecutor pool; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; ROOT::ExecutorUtils::ReduceObjectsMerge collection of TObjects.Definition PoolUtils.h:35; ROOT::TProcessExecutor::MapReduceauto MapReduce(F func, unsigned nTimes, R redfunc) -> InvokeResult_t< F >Execute a function nTimes in parallel (Map) and accumulate the results into a single value (Reduce).Definition TProcessExecutor.hxx:262; v@ vDef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TProcessExecutor.html:2838,interface,interface,2838,doc/v632/classROOT_1_1TProcessExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TProcessExecutor.html,2,['interface'],['interface']
Integrability," . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 131 of file RooAddModel.h. ◆ isDirectGenSafe(). bool RooAddModel::isDirectGenSafe ; (; const RooAbsArg & ; arg); const. overridevirtual . Direct generation is safe if all components say so. ; Reimplemented from RooAbsPdf.; Definition at line 646 of file RooAddModel.cxx. ◆ pdfList(). const RooArgList & RooAddModel::pdfList ; (; ); const. inline . Return list of component p.d.fs. ; Definition at line 66 of file RooAddModel.h. ◆ printMetaArgs(). void RooAddModel::printMetaArgs ; (; std::ostream & ; os); const. overridevirtual . Customized printing of arguments of a RooAddModel to more intuitively reflect the contents of the product operator construction. ; Reimplemented from RooAbsArg.; Definition at line 702 of file RooAddModel.cxx. ◆ resetErrorCounters(). void RooAddModel::resetErrorCounters ; (; Int_t ; resetValue = 10). overridevirtual . Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ; Reimplemented from RooAbsPdf.; Definition at line 420 of file RooAddModel.cxx. ◆ selectNormalization(). void RooAddModel::selectNormalization ; (; const RooArgSet * ; depSet = nullptr, . bool ; force = false . ). overrideprotectedvirtual . Interface function used by test statistics to freeze choice of observables for interpretation of fraction coefficients. ; Reimplemented from RooAbsReal.; Definition at line 599 of file RooAddModel.cxx. ◆ selectNormalizationRange(). void RooAddModel::selectNormalizationRange ; (; const char * ; rangeName = nullptr, . bool ; force = false . ). overrideprotectedvirtual . Interface function used by test statistics to freeze choice of range for interpretation of fraction coefficients. ; Reimplemented from RooAbsReal.; Definition at line 621 of file RooAddModel.cxx. ◆ selfNormalized(). bool RooAddModel::selfNormalized ; (; ); const. inlineoverridevirtual . Model is self normalized when used as p.d.f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:89100,message,messages,89100,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['message'],['messages']
Integrability," . ReturnsTClass describing current object ; Reimplemented from TGCompositeFrame.; Definition at line 302 of file TGListBox.h. ◆ Layout(). void TGListBox::Layout ; (; ). overridevirtual . Layout the listbox components. ; Reimplemented from TGCompositeFrame.; Definition at line 1453 of file TGListBox.cxx. ◆ MoveResize(). void TGListBox::MoveResize ; (; Int_t ; x, . Int_t ; y, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . Move and resize the listbox widget. ; Reimplemented from TGFrame.; Definition at line 1425 of file TGListBox.cxx. ◆ NewEntry(). void TGListBox::NewEntry ; (; const char * ; s = ""Entry""). virtual . method used to add entry via context menu ; Definition at line 1301 of file TGListBox.cxx. ◆ operator=(). TGListBox TGListBox::operator= ; (; const TGListBox & ; ). privatedelete . ◆ ProcessMessage(). Bool_t TGListBox::ProcessMessage ; (; Longptr_t ; msg, . Longptr_t ; parm1, . Longptr_t ; parm2 . ). overridevirtual . Process messages generated by the listbox container and forward messages to the listbox message handling window. ; Reimplemented from TGCompositeFrame.; Definition at line 1552 of file TGListBox.cxx. ◆ RemoveAll(). void TGListBox::RemoveAll ; (; ). overridevirtual . Remove all entries. ; Reimplemented from TGCompositeFrame.; Definition at line 1345 of file TGListBox.cxx. ◆ RemoveEntries(). void TGListBox::RemoveEntries ; (; Int_t ; from_ID, . Int_t ; to_ID . ). virtual . Remove a range of entries defined by from_ID and to_ID. ; Definition at line 1354 of file TGListBox.cxx. ◆ RemoveEntry(). void TGListBox::RemoveEntry ; (; Int_t ; id = -1). virtual . remove entry with id. ; If id = -1 - the selected entry/entries is/are removed. ; Definition at line 1319 of file TGListBox.cxx. ◆ Resize() [1/2]. void TGListBox::Resize ; (; TGDimension ; size). inlineoverridevirtual . Resize the frame. ; Reimplemented from TGFrame.; Definition at line 274 of file TGListBox.h. ◆ Resize() [2/2]. void TGListBox::Resize ; (; UInt_t ; w, . UInt_t ; h . ). override",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGListBox.html:44718,message,messages,44718,doc/master/classTGListBox.html,https://root.cern,https://root.cern/doc/master/classTGListBox.html,3,['message'],"['message', 'messages']"
Integrability," . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 401 of file TGWin32.h. ◆ IsCmdThread(). Bool_t TGWin32::IsCmdThread ; (; ); const. overridevirtual . returns kTRUE if we are inside cmd/server thread ; Reimplemented from TVirtualX.; Definition at line 886 of file TGWin32.cxx. ◆ IsDNDAware(). Bool_t TGWin32::IsDNDAware ; (; Window_t ; win, . Atom_t * ; typelist . ). overridevirtual . Checks if Window win is DND aware, and knows any of the DND formats passed in argument. ; Reimplemented from TVirtualX.; Definition at line 7792 of file TGWin32.cxx. ◆ IsVisible(). Bool_t TGWin32::IsVisible ; (; Int_t ; x, . Int_t ; y, . UInt_t ; w, . UInt_t ; h . ). private . Test if there is really something to render. ; Definition at line 1408 of file TGWin32.cxx. ◆ KeysymToKeycode(). Int_t TGWin32::KeysymToKeycode ; (; UInt_t ; keysym). overridevirtual . Convert a keysym to the appropriate keycode. ; For example keysym is a letter and keycode is the matching keyboard key (which is dependend on the current keyboard mapping). ; Reimplemented from TVirtualX.; Definition at line 6740 of file TGWin32.cxx. ◆ ListFonts(). char ** TGWin32::ListFonts ; (; const char * ; fontname, . Int_t ; max, . Int_t & ; count . ). overridevirtual . Return list of font names matching ""fontname"". ; Reimplemented from TVirtualX.; Definition at line 7231 of file TGWin32.cxx. ◆ LoadQueryFont(). FontStruct_t TGWin32::LoadQueryFont ; (; const char * ; font_name). overridevirtual . Load font and query font. ; If font is not found 0 is returned, otherwise an opaque pointer to the FontStruct_t. Free the loaded font using DeleteFont(). ; Reimplemented from TVirtualX.; Definition at line 5385 of file TGWin32.cxx. ◆ Lock(). void TGWin32::Lock ; (; ). static . Definition at line 938 of file TGWin32.cxx. ◆ LookupString(). void TGWin32::LookupString ; (; Event_t * ; event, . char * ; buf, . Int_t ; buflen, . UInt_t & ; keysym . ). overridevirtual . Convert the keycode from the ev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:87877,depend,dependend,87877,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['depend'],['dependend']
Integrability," . Static function used to attach to an existing remote application or to start one. ; Definition at line 1999 of file TApplication.cxx. ◆ OpenForumTopic(). void TApplication::OpenForumTopic ; (; const TString & ; type). It opens a Forum topic in a web browser with prefilled ROOT version. ; Parameters. [in]typethe issue type (only bug supported right now) . Definition at line 1011 of file TApplication.cxx. ◆ OpenGitHubIssue(). void TApplication::OpenGitHubIssue ; (; const TString & ; type). It opens a GitHub issue in a web browser with prefilled ROOT version. ; Parameters. [in]typethe issue type (bug, feature or improvement) . Definition at line 1034 of file TApplication.cxx. ◆ OpenInBrowser(). void TApplication::OpenInBrowser ; (; const TString & ; url). The function generates and executes a command that loads the Doxygen URL in a browser. ; It works for Mac, Windows and Linux. In the case of Linux, the function also checks if the DISPLAY is set. If it isn't, a warning message and the URL will be displayed on the terminal.; Parameters. [in]urlweb page to be displayed in a browser . Definition at line 629 of file TApplication.cxx. ◆ OpenReferenceGuideFor(). void TApplication::OpenReferenceGuideFor ; (; const TString & ; strippedClass). It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ; If the user types incorrect value, it will return an error or warning.; Parameters. [in]strippedClassthe scope or scope::member . Definition at line 1065 of file TApplication.cxx. ◆ operator=(). TApplication & TApplication::operator= ; (; const TApplication & ; ). privatedelete . ◆ ParseRemoteLine(). Int_t TApplication::ParseRemoteLine ; (; const char * ; ln, . TString & ; hostdir, . TString & ; user, . Int_t & ; dbg, . TString & ; script . ). staticprotected . Parse the content of a line starting with "".R"" (already stripped-off) The format is. ; [user@]host[:dir] ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplication.html:33374,message,message,33374,doc/master/classTApplication.html,https://root.cern,https://root.cern/doc/master/classTApplication.html,1,['message'],['message']
Integrability," . bool ; extended = false, . const ROOT::EExecutionPolicy & ; executionPolicy = ROOT::EExecutionPolicy::kSequential . ). inline . Fit an un-binned data set using the negative log-likelihood method. ; This function uses a shared_ptr to avoid copying the input data. ; Definition at line 195 of file Fitter.h. ◆ Fit() [5/5]. bool ROOT::Fit::Fitter::Fit ; (; const UnBinData & ; data, . bool ; extended = false, . const ROOT::EExecutionPolicy & ; executionPolicy = ROOT::EExecutionPolicy::kSequential . ). inline . Fit an un-binned data set using the negative log-likelihood method. ; This function copies the input data. ; Definition at line 188 of file Fitter.h. ◆ FitFCN() [1/6]. bool ROOT::Fit::Fitter::FitFCN ; (; ). Perform a fit with the previously set FCN function. ; Require SetFCN before ; Definition at line 269 of file Fitter.cxx. ◆ FitFCN() [2/6]. bool ROOT::Fit::Fitter::FitFCN ; (; const ROOT::Math::FitMethodFunction & ; fcn, . const double * ; params = nullptr . ). Fit using a FitMethodFunction interface. ; Same as method above, but now extra information can be taken from the function class ; Definition at line 226 of file Fitter.cxx. ◆ FitFCN() [3/6]. bool ROOT::Fit::Fitter::FitFCN ; (; const ROOT::Math::FitMethodGradFunction & ; fcn, . const double * ; params = nullptr . ). Fit using a FitMethodGradFunction interface. ; Same as method above, but now extra information can be taken from the function class . ◆ FitFCN() [4/6]. bool ROOT::Fit::Fitter::FitFCN ; (; const ROOT::Math::IMultiGenFunction & ; fcn, . const double * ; params = nullptr, . unsigned int ; dataSize = 0, . int ; fitType = 0 . ). Fit using the given FCN function represented by a multi-dimensional function interface (ROOT::Math::IMultiGenFunction). ; Give optionally the initial parameter values, data size to have the fit Ndf correctly set in the FitResult and flag specifying the type of fit. The fitType can be: 0 undefined, 1 least square fit, 2 unbinned likelihood fit, 3 binned likelihood fit Note th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html:24107,interface,interface,24107,doc/master/classROOT_1_1Fit_1_1Fitter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html,1,['interface'],['interface']
Integrability," . bool ; printError = false . ); const. inlineprotectedvirtual . Interface function to check if given value is a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 447 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3464 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Definition at line 3408 of file RooAbsReal.cxx. ◆ makeProjectionSet(). void RooAbsReal::makeProjectionSet ; (; const RooAbsArg * ; plotVar, . const RooArgSet * ; allVars, . RooArgSet & ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:120407,message,messages,120407,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['message'],['messages']
Integrability," . bool ; printError = false . ); const. inlineprotectedvirtual . Interface function to check if given value is a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 454 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3545 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Definition at line 3490 of file RooAbsReal.cxx. ◆ makeProjectionSet(). void RooAbsReal::makeProjectionSet ; (; const RooAbsArg * ; plotVar, . const RooArgSet * ; allVars, . RooArgSet & ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:121737,message,messages,121737,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['message'],['messages']
Integrability," . const char * ; title, . VoidFuncPtr_t * ; initfunc = nullptr . ). Initialize the ROOT system. ; The creation of the TROOT object initializes the ROOT system. It must be the first ROOT related action that is performed by a program. The TROOT object must be created on the stack (can not be called via new since ""operator new"" is protected). The TROOT object is either created as a global object (outside the main() program), or it is one of the first objects created in main(). Make sure that the TROOT object stays in scope for as long as ROOT related actions are performed. TROOT is a so called singleton so only one instance of it can be created. The single TROOT object can always be accessed via the global pointer gROOT. The name and title arguments can be used to identify the running application. The initfunc argument can contain an array of function pointers (last element must be 0). These functions are executed at the end of the constructor. This way one can easily extend the ROOT system without adding permanent dependencies (e.g. the graphics system is initialized via such a function). ; Definition at line 639 of file TROOT.cxx. ◆ ~TROOT(). TROOT::~TROOT ; (; ). virtual . Clean up and free resources used by ROOT (files, network sockets, shared memory segments, etc.). ; Definition at line 867 of file TROOT.cxx. Member Function Documentation. ◆ AddClass(). void TROOT::AddClass ; (; TClass * ; cl). Add a class to the list and map of classes. ; This routine is deprecated, use TClass::AddClass directly. ; Definition at line 1025 of file TROOT.cxx. ◆ AddClassGenerator(). void TROOT::AddClassGenerator ; (; TClassGenerator * ; generator). Add a class generator. ; This generator will be called by TClass::GetClass in case its does not find a loaded rootcint dictionary to request the creation of a TClass object. ; Definition at line 1035 of file TROOT.cxx. ◆ AddExtraInterpreterArgs(). const std::vector< std::string > & TROOT::AddExtraInterpreterArgs ; (; const std::vector< st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:40975,depend,dependencies,40975,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,2,['depend'],['dependencies']
Integrability," . const double * ; params = nullptr, . unsigned int ; dataSize = 0, . int ; fitType = 0 . ). Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that the function dimension (i.e. ; the number of parameter) is needed in this case For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..) ; Definition at line 656 of file Fitter.h. ◆ SetFitType(). void ROOT::Fit::Fitter::SetFitType ; (; int ; type). inline . Set the type of fit when using an external FCN possible types are : 1 (least-square), 2 (unbinned-likelihood), 3 (binned-likelihood) Note that in case of binned likelihood fit the chi2 will be computed as 2 * MinFCN() Note this function should be called before fitting to have effect on th FitResult. ; Definition at line 481 of file Fitter.h. ◆ SetFunction() [1/4]. void ROOT::Fit::Fitter::SetFunction ; (; const IGradModel1DFunction & ; func, . bool ; useGradient = true . ). Set the fitted function from 1D gradient parametric function interface. ; Definition at line 124 of file Fitter.cxx. ◆ SetFunction() [2/4]. void ROOT::Fit::Fitter::SetFunction ; (; const IGradModelFunction & ; func, . bool ; useGradient = true . ). Set the fitted function (model function) from a parametric gradient function interface. ; Definition at line 110 of file Fitter.cxx. ◆ SetFunction() [3/4]. void ROOT::Fit::Fitter::SetFunction ; (; const IModel1DFunction & ; func, . bool ; useGradient = false . ). Set the fitted function (model function) from a vectorized parametric function interface. ; Set the fitted function from a parametric 1D function interface ; Definition at line 86 of file Fitter.cxx. ◆ SetFunction() [4/4]. void ROOT::Fit::Fitter::SetFunction ; (; const IModelFunction & ; func, . bool ; useGradient = false . ). Set the fitted function (model function) from a parametric function interface. ; Definition at line 59 of file Fitter.cxx. ◆ SetNumberOfFitPoints(). void ROOT::Fit::Fitter::SetNumberOfFitPoints",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html:35444,interface,interface,35444,doc/master/classROOT_1_1Fit_1_1Fitter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html,1,['interface'],['interface']
Integrability," . double ; nominal, . int ; doCutoff . ). inline . Definition at line 320 of file MathFuncs.h. ◆ flexibleInterpSingle(). double RooFit::Detail::MathFuncs::flexibleInterpSingle ; (; unsigned int ; code, . double ; low, . double ; high, . double ; boundary, . double ; nominal, . double ; paramVal, . double ; res . ). inline . Definition at line 213 of file MathFuncs.h. ◆ gaussian(). double RooFit::Detail::MathFuncs::gaussian ; (; double ; x, . double ; mean, . double ; sigma . ). inline . Function to evaluate an un-normalized RooGaussian. ; Definition at line 86 of file MathFuncs.h. ◆ gaussianIntegral(). double RooFit::Detail::MathFuncs::gaussianIntegral ; (; double ; xMin, . double ; xMax, . double ; mean, . double ; sigma . ). inline . Function to calculate the integral of an un-normalized RooGaussian over x. ; To calculate the integral over mean, just interchange the respective values of x and mean. Parameters. xMinMinimum value of variable to integrate wrt. ; xMaxMaximum value of of variable to integrate wrt. ; meanMean. ; sigmaSigma. . ReturnsThe integral of an un-normalized RooGaussian over the value in x. ; Definition at line 418 of file MathFuncs.h. ◆ getUniformBinning(). unsigned int RooFit::Detail::MathFuncs::getUniformBinning ; (; double ; low, . double ; high, . double ; val, . unsigned int ; numBins . ). inline . Definition at line 172 of file MathFuncs.h. ◆ interpolate1d(). double RooFit::Detail::MathFuncs::interpolate1d ; (; double ; low, . double ; high, . double ; val, . unsigned int ; numBins, . double const * ; vals . ). inline . Definition at line 178 of file MathFuncs.h. ◆ landau(). double RooFit::Detail::MathFuncs::landau ; (; double ; x, . double ; mu, . double ; sigma . ). inline . Definition at line 331 of file MathFuncs.h. ◆ logNormal(). double RooFit::Detail::MathFuncs::logNormal ; (; double ; x, . double ; k, . double ; m0 . ). inline . Definition at line 338 of file MathFuncs.h. ◆ logNormalIntegral(). double RooFit::Detail::MathFuncs::logN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooFit_1_1Detail_1_1MathFuncs.html:7931,integrat,integrate,7931,doc/master/namespaceRooFit_1_1Detail_1_1MathFuncs.html,https://root.cern,https://root.cern/doc/master/namespaceRooFit_1_1Detail_1_1MathFuncs.html,1,['integrat'],['integrate']
Integrability," . int * ; max_x . ). protected . This routine computes the X and Y coordinates for all elements of a line that has been gathered using GetLine() above. ; It also figures the ascent and descent for in-line images.; The value returned is the Y coordinate of the bottom edge of the new line. The X coordinates are computed by adding the left margin plus any extra space needed for centering or right-justification.; p_start - Start of tokens for this line p_end - First token past end of this line. Maybe NULL mbottom - Put the top of this line here width - This is the space available to the line actualWidth - This is the actual width needed by the line lMargin - The current left margin max_x - Write maximum X coordinate of ink here ; Definition at line 453 of file TGHtmlLayout.cxx. ◆ GetLine(). TGHtmlElement * TGHtmlLayoutContext::GetLine ; (; TGHtmlElement * ; p_start, . TGHtmlElement * ; p_end, . int ; width, . int ; minX, . int * ; actualWidth . ). protected . This routine gathers as many tokens as will fit on one line. ; The candidate tokens begin with fPStart and go thru the end of the list or to fPEnd, whichever comes first. The first token at the start of the next line is returned. NULL is returned if we exhaust data.; ""width"" is the maximum allowed width of the line. The actual width is returned in *actualWidth. The actual width does not include any trailing spaces. Sometimes the actual width will be greater than the maximum width. This will happen, for example, for text enclosed in .. that has lines longer than the width of the page.; If the list begins with text, at least one token is returned, even if that one token is longer than the allowed line length. But if the list begins with some kind of break markup (possibly preceded by white space) then the returned list may be empty.; The ""x"" coordinates of all elements are set assuming that the line begins at 0. The calling routine should adjust these coordinates to position the line horizontally. (The FixLine() proc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtmlLayoutContext.html:15655,rout,routine,15655,doc/master/classTGHtmlLayoutContext.html,https://root.cern,https://root.cern/doc/master/classTGHtmlLayoutContext.html,1,['rout'],['routine']
Integrability," .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSystem. ←. TNetSystem; ←. TXNetSystem. TNetXNGSystem. TUnixSystem. TWebSystem. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSystem.html:18490,interface,interface,18490,root/html602/TSystem.html,https://root.cern,https://root.cern/root/html602/TSystem.html,2,['interface'],['interface']
Integrability," .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; RooFit::PrintLevelRooCmdArg PrintLevel(Int_t code)Definition RooGlobalFunc.cxx:657; RooFit::VerboseRooCmdArg Verbose(bool flag=true)Definition RooGlobalFunc.cxx:645; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf903_numintcacheDefinition rf903_numintcache.py:1; xmlio::Titleconst char * TitleDefinition TXMLSetup.cxx:68; TimerDefinition histspeedtest.cxx:54; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y,z]) using numeric integrator RooAdaptiveIntegratorND to calculate Int(x,y,z); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model_over_model_Int[x,y,z]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_over_model_Int[x,y,z]_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a: using 1; ; prevFCN = 1659.930708 a=0.02833, [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_Int[x,y,z]) using numeric integrator RooAdaptiveIntegratorND to calculate Int(x,y,z); ; prevFCN = 1675.611563 a=-0.02833, ; prevFCN = 1673.217894 a=0.002833, ; prevFCN = 1660.205177 a=-0.002833, ; prevFCN = 1659.94939 a=0.0002833, ; prevFCN = 1659.944972 a=-0.0002833, ; prevFCN = 1659.919376 a=-0.001237, ; prevFCN = 1659.902781 a=-0.001089, ; prevFCN = 1659.903175 a=-0.001384, ; prevFCN = 1659.90318 a=-0.001237, ; prevFCN = 1659.902781 a=-0.001089, ; prevFCN = 1659.903175 a=-0.001384, ; prevFCN = 1659.90318 a=-0.001207, ; prevFCN = 1659",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf903__numintcache_8C.html:8728,integrat,integrator,8728,doc/master/rf903__numintcache_8C.html,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8C.html,2,"['integrat', 'synchroniz']","['integrator', 'synchronize']"
Integrability," / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* file); Remove file from the list of acti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPacketizerAdaptive.html:10662,synchroniz,synchronization,10662,root/html528/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html,1,['synchroniz'],['synchronization']
Integrability," /* full covariance matrix *; float chisq[2]; /* Chi-square per degree of freedom *; float x_first[3]; /* coord. of first measured point (cm) *; float x_last[3]; /* coord. of last measured point (cm) *; float length; /* from first to last point (cm) *; float impact; /* primary vertex (cm) *; unsigned long map[2]; /* extrap. info. (see preceding comments)*; int id; /* Primary key (see comments) *; int iflag; /* bitmask quality info. (see comments) *; int det_id; /* Detector id information *; int method; /* Track finding/fitting method, packed *; int pid; /* Geant particle ID for assumed mass *; int n_point; /* SVT, TPC, FTPC component #s are packed *; int n_max_point; /* SVT, TPC, FTPC component #s are packed *; int n_fit_point; /* SVT, TPC, FTPC component #s are packed *; int icharge; /* Particle charge in units of |e| *; int id_start_vertex; /* final fit and primary track candidates *; } DST_TRACK_ST;. class St_dst_track : public TTable; {; public:; ClassDefTable(St_dst_track,dst_track_st); ClassDef(St_dst_track,2) //C++ wrapper for <dst_track> StAF table; };; #endif. where the CPP macro defines several convinient methods for the; ""table"" class (see: $ROOTSYS/table/inc/Ttypes.h for details:. #define ClassDefTable(className,structName); protected:; static TTableDescriptor *fgColDescriptors;; virtual TTableDescriptor *GetDescriptorPointer() const { return fgColDescriptors;}; virtual void SetDescriptorPointer(TTableDescriptor *list) const { fgColDescriptors = list;}; public:; typedef structName* iterator;; className() : TTable(_QUOTE_(className),sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name) : TTable(name,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(Int_t n) : TTable(_QUOTE_(className),n,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name,Int_t n) : TTable(name,n,sizeof(structName)) {SetType(_QUOTE_(structName));}; structName *GetTable(Int_t i=0) const { return ((structName *)GetArray())+i;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTable.html:2523,wrap,wrapper,2523,root/html534/TTable.html,https://root.cern,https://root.cern/root/html534/TTable.html,10,['wrap'],['wrapper']
Integrability," /* minfo */) const {return 0;}; 497 virtual Long_t MethodInfo_Property(MethodInfo_t * /* minfo */) const = 0;; 498 virtual Long_t MethodInfo_ExtraProperty(MethodInfo_t * /* minfo */) const = 0;; 499 virtual TypeInfo_t *MethodInfo_Type(MethodInfo_t * /* minfo */) const {return nullptr;}; 500 virtual EReturnType MethodInfo_MethodCallReturnType(MethodInfo_t* minfo) const = 0;; 501 virtual const char *MethodInfo_GetMangledName(MethodInfo_t * /* minfo */) const {return nullptr;}; 502 virtual const char *MethodInfo_GetPrototype(MethodInfo_t * /* minfo */) const {return nullptr;}; 503 virtual const char *MethodInfo_Name(MethodInfo_t * /* minfo */) const {return nullptr;}; 504 virtual const char *MethodInfo_TypeName(MethodInfo_t * /* minfo */) const {return nullptr;}; 505 virtual std::string MethodInfo_TypeNormalizedName(MethodInfo_t * /* minfo */) const {return """";}; 506 virtual const char *MethodInfo_Title(MethodInfo_t * /* minfo */) const {return nullptr;}; 507 ; 508 // MethodArgInfo interface; 509 virtual void MethodArgInfo_Delete(MethodArgInfo_t * /* marginfo */) const {}; 510 virtual MethodArgInfo_t *MethodArgInfo_Factory() const {return nullptr;}; 511 virtual MethodArgInfo_t *MethodArgInfo_Factory(MethodInfo_t * /*minfo*/) const {return nullptr;}; 512 virtual MethodArgInfo_t *MethodArgInfo_FactoryCopy(MethodArgInfo_t * /* marginfo */) const {return nullptr;}; 513 virtual Bool_t MethodArgInfo_IsValid(MethodArgInfo_t * /* marginfo */) const {return 0;}; 514 virtual int MethodArgInfo_Next(MethodArgInfo_t * /* marginfo */) const {return 0;}; 515 virtual Long_t MethodArgInfo_Property(MethodArgInfo_t * /* marginfo */) const {return 0;}; 516 virtual const char *MethodArgInfo_DefaultValue(MethodArgInfo_t * /* marginfo */) const {return nullptr;}; 517 virtual const char *MethodArgInfo_Name(MethodArgInfo_t * /* marginfo */) const {return nullptr;}; 518 virtual const char *MethodArgInfo_TypeName(MethodArgInfo_t * /* marginfo */) const {return nullptr;}; 519 virtual std::string",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TInterpreter_8h_source.html:30833,interface,interface,30833,doc/master/TInterpreter_8h_source.html,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html,1,['interface'],['interface']
Integrability," // lookup class to find list of libraries; 7125 if (fMapfile) {; 7126 TEnvRec* libs_record = nullptr;; 7127 libs_record = fMapfile->Lookup(cls);; 7128 if (libs_record) {; 7129 const char* libs = libs_record->GetValue();; 7130 return (*libs) ? libs : nullptr;; 7131 }; 7132 else {; 7133 // Try the old format...; 7134 TString c = TString(""Library."") + cls;; 7135 // convert ""::"" to ""@@"", we used ""@@"" because TEnv; 7136 // considers ""::"" a terminator; 7137 c.ReplaceAll(""::"", ""@@"");; 7138 // convert ""-"" to "" "", since class names may have; 7139 // blanks and TEnv considers a blank a terminator; 7140 c.ReplaceAll("" "", ""-"");; 7141 // Use TEnv::Lookup here as the rootmap file must start with Library.; 7142 // and do not support using any stars (so we do not need to waste time; 7143 // with the search made by TEnv::GetValue).; 7144 TEnvRec* libs_record = nullptr;; 7145 libs_record = fMapfile->Lookup(c);; 7146 if (libs_record) {; 7147 const char* libs = libs_record->GetValue();; 7148 return (*libs) ? libs : nullptr;; 7149 }; 7150 }; 7151 }; 7152 return nullptr;; 7153}; 7154 ; 7155/// This interface returns a list of dependent libraries in the form:; 7156/// lib libA.so libB.so libC.so. The first library is the library we are; 7157/// searching dependencies for.; 7158/// Note: In order to speed up the search, we display the dependencies of the; 7159/// libraries which are not yet loaded. For instance, if libB.so was already; 7160/// loaded the list would contain: lib libA.so libC.so.; 7161static std::string GetSharedLibImmediateDepsSlow(std::string lib,; 7162 cling::Interpreter *interp,; 7163 bool skipLoadedLibs = true); 7164{; 7165 TString LibFullPath(lib);; 7166 if (!llvm::sys::path::is_absolute(lib)) {; 7167 if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {; 7168 Error(""TCling__GetSharedLibImmediateDepsSlow"", ""Cannot find library '%s'"", lib.c_str());; 7169 return """";; 7170 }; 7171 } else {; 7172 assert(llvm::sys::fs::exists(lib) && ""Must exist!"");; 7173 lib = l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:279608,interface,interface,279608,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,"['depend', 'interface']","['dependent', 'interface']"
Integrability," /// \cond HIDDEN_SYMBOLS; 157 template <typename V, bool hasBeginEnd = TTraits::HasBeginAndEnd<V>::value>; 158 struct RIterationHelper {; 159 using Iterator_t = void;; 160 void GetBegin(const V &) { static_assert(sizeof(V) == 0, ""It does not make sense to ask begin for this class.""); }; 161 void GetEnd(const V &) { static_assert(sizeof(V) == 0, ""It does not make sense to ask end for this class.""); }; 162 };; 163 ; 164 template <typename V>; 165 struct RIterationHelper<V, true> {; 166 using Iterator_t = decltype(std::begin(std::declval<V>()));; 167 static Iterator_t GetBegin(const V &v) { return std::begin(v); };; 168 static Iterator_t GetEnd(const V &v) { return std::end(v); };; 169 };; 170 /// \endcond; 171 ; 172 /// Non-owning pointer to the RLoopManager at the root of this computation graph.; 173 /// The RLoopManager is guaranteed to be always in scope if fLoopManager is not a nullptr.; 174 RDFDetail::RLoopManager *fLoopManager = nullptr;; 175 SPT_t fObjPtr; ///< Shared pointer encapsulating the wrapped result; 176 /// Owning pointer to the action that will produce this result.; 177 /// Ownership is shared with other copies of this ResultPtr.; 178 std::shared_ptr<RDFInternal::RActionBase> fActionPtr;; 179 ; 180 /// Triggers the event loop in the RLoopManager; 181 void TriggerRun();; 182 ; 183 /// Get the pointer to the encapsulated result.; 184 /// Ownership is not transferred to the caller.; 185 /// Triggers event loop and execution of all actions booked in the associated RLoopManager.; 186 T *Get(); 187 {; 188 if (fActionPtr != nullptr && !fActionPtr->HasRun()); 189 TriggerRun();; 190 return fObjPtr.get();; 191 }; 192 ; 193 void ThrowIfNull(); 194 {; 195 if (fObjPtr == nullptr); 196 throw std::runtime_error(""Trying to access the contents of a null RResultPtr."");; 197 }; 198 ; 199 RResultPtr(std::shared_ptr<T> objPtr, RDFDetail::RLoopManager *lm,; 200 std::shared_ptr<RDFInternal::RActionBase> actionPtr); 201 : fLoopManager(lm), fObjPtr(std::move(objPtr)), fActi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultPtr_8hxx_source.html:7189,wrap,wrapped,7189,doc/master/RResultPtr_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultPtr_8hxx_source.html,1,['wrap'],['wrapped']
Integrability," /// auto nEntriesAfterCuts = myFilteredDf.Count();; 1727 /// ~~~; 1728 ///; 1729 RResultPtr<ULong64_t> Count(); 1730 {; 1731 const auto nSlots = fLoopManager->GetNSlots();; 1732 auto cSPtr = std::make_shared<ULong64_t>(0);; 1733 using Helper_t = RDFInternal::CountHelper;; 1734 using Action_t = RDFInternal::RAction<Helper_t, Proxied>;; 1735 auto action = std::make_unique<Action_t>(Helper_t(cSPtr, nSlots), ColumnNames_t({}), fProxiedPtr,; 1736 RDFInternal::RColumnRegister(fColRegister));; 1737 return MakeResultPtr(cSPtr, *fLoopManager, std::move(action));; 1738 }; 1739 ; 1740 ////////////////////////////////////////////////////////////////////////////; 1741 /// \brief Return a collection of values of a column (*lazy action*, returns a std::vector by default).; 1742 /// \tparam T The type of the column.; 1743 /// \tparam COLL The type of collection used to store the values.; 1744 /// \param[in] column The name of the column to collect the values of.; 1745 /// \return the content of the selected column wrapped in a RResultPtr.; 1746 ///; 1747 /// The collection type to be specified for C-style array columns is `RVec<T>`:; 1748 /// in this case the returned collection is a `std::vector<RVec<T>>`.; 1749 /// ### Example usage:; 1750 /// ~~~{.cpp}; 1751 /// // In this case intCol is a std::vector<int>; 1752 /// auto intCol = rdf.Take<int>(""integerColumn"");; 1753 /// // Same content as above but in this case taken as a RVec<int>; 1754 /// auto intColAsRVec = rdf.Take<int, RVec<int>>(""integerColumn"");; 1755 /// // In this case intCol is a std::vector<RVec<int>>, a collection of collections; 1756 /// auto cArrayIntCol = rdf.Take<RVec<int>>(""cArrayInt"");; 1757 /// ~~~; 1758 /// This action is *lazy*: upon invocation of this method the calculation is; 1759 /// booked but not executed. Also see RResultPtr.; 1760 template <typename T, typename COLL = std::vector<T>>; 1761 RResultPtr<COLL> Take(std::string_view column = """"); 1762 {; 1763 const auto columns = column.empty() ? Colum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:97636,wrap,wrapped,97636,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['wrap'],['wrapped']
Integrability," //; 18// TLeaf //; 19// //; 20// A TTree object is a list of TBranch. //; 21// A TBranch object is a list of TLeaf. In most cases, the TBranch //; 22// will have one TLeaf. //; 23// A TLeaf describes the branch data types and holds the data. //; 24// //; 25// A few notes about the data held by the leaf. It can contain: //; 26// 1 a single object or primitive (e.g., one float), //; 27// 2 a fixed-number of objects (e.g., each entry has two floats). //; 28// The number of elements per entry is saved in `fLen`. //; 29// 3 a dynamic number of primitives. The number of objects in each //; 30// entry is saved in the `fLeafCount` branch. //; 31// //; 32// Note options (2) and (3) can combined - if fLeafCount says an entry //; 33// has 3 elements and fLen is 2, then there will be 6 objects in that //; 34// entry. //; 35// //; 36// Additionally, `fNdata` is transient and generated on read to //; 37// determine the necessary size of a buffer to hold event data; //; 38// depending on the call-site, it may be sized larger than the number //; 39// of elements //; 40// //; 41//////////////////////////////////////////////////////////////////////////; 42 ; 43 ; 44#include ""TNamed.h""; 45 ; 46#include <vector>; 47 ; 48#ifdef R__LESS_INCLUDES; 49class TBranch;; 50#else; 51#include ""TBranch.h""; 52#endif; 53 ; 54class TClonesArray;; 55class TBrowser;; 56 ; 57class TLeaf : public TNamed {; 58 ; 59private:; 60 ; 61 virtual Int_t GetOffsetHeaderSize() const {return 0;}; 62 ; 63protected:; 64 ; 65 using Counts_t = std::vector<Int_t>;; 66 struct LeafCountValues {; 67 Counts_t fValues;; 68 Long64_t fStartEntry{-1}; ///<! entry number of corresponding to element 0 of the vector.; 69 };; 70 ; 71 Int_t fNdata; ///<! Number of elements in fAddress data buffer.; 72 Int_t fLen; ///< Number of fixed length elements in the leaf's data.; 73 Int_t fLenType; ///< Number of bytes for this data type; 74 Int_t fOffset; ///< Offset in ClonesArray object (if one); 75 bool fIsRange; ///< (=true if leaf has a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLeaf_8h_source.html:1720,depend,depending,1720,doc/master/TLeaf_8h_source.html,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html,1,['depend'],['depending']
Integrability," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCombiTrans.html:3106,interface,interface,3106,root/html528/TGeoCombiTrans.html,https://root.cern,https://root.cern/root/html528/TGeoCombiTrans.html,80,['interface'],['interface']
Integrability," 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStringVar.html:3217,depend,dependsOn,3217,root/html534/RooStringVar.html,https://root.cern,https://root.cern/root/html534/RooStringVar.html,6,['depend'],['dependsOn']
Integrability," 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual Double_tCalcNLL(Double_t xL); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual Bool_tShouldTakeStep(Double_t d). Data Members; public:. enum FunctionSign { kNegative; kPositive; kSignUnset; };; enum FunctionType { kRegular; kLog; kTypeUnset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooAbsReal*fFunctionfunction that will generate likelihood values; Int_tfNumBurnInStepsnumber of iterations to discard as burn-in, starting from the first; Int_tfNumItersnumber of iterations to run metropolis algorithm; RooArgSet*fParametersRooRealVars that define parameter space; RooStats::ProposalFunction*fPropFuncProposal function for MCMC integration; RooStats::MetropolisHastings::FunctionSignfSignwhether the likelihood is negative (like NLL) or positive; RooStats::MetropolisHastings::FunctionTypefTypewhether the likelihood is on a regular, log, (or other) scale. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MetropolisHastings(); default constructor. MetropolisHastings(RooAbsReal& function, RooArgSet& paramsOfInterest, RooStats::ProposalFunction& proposalFunction, Int_t numIters). MarkovChain* ConstructChain(). Bool_t ShouldTakeStep(Double_t d). Double_t CalcNLL(Double_t xL). MetropolisHastings(); default constructor. virtual ~MetropolisHastings(); {}. void SetParameters(RooArgSet& set); specify the parameters of interest in the interval; kbelasco: should clone before removing constant parameters?. { fParameters = &set; RemoveConstantParameters(fParameters); }. void SetProposalFunction(RooStats::ProposalFunction& prop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__MetropolisHastings.html:7833,integrat,integration,7833,root/html526/RooStats__MetropolisHastings.html,https://root.cern,https://root.cern/root/html526/RooStats__MetropolisHastings.html,3,['integrat'],['integration']
Integrability," 0, 0, 0},; 10512 {""PUT"", 1, 0, 0, 1, 0},; 10513 {""DELETE"", 0, 0, 0, 1, 0},; 10514 {""HEAD"", 0, 0, 1, 1, 1},; 10515 {""OPTIONS"", 0, 0, 1, 1, 0},; 10516 {""CONNECT"", 1, 1, 0, 0, 0},; 10517 /* TRACE method (RFC 2616) is not supported for security reasons */; 10518 ; 10519 /* PATCH method (RFC 5789) */; 10520 {""PATCH"", 1, 0, 0, 0, 0},; 10521 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10522 ; 10523 /* WEBDAV (RFC 2518) */; 10524 {""PROPFIND"", 0, 1, 1, 1, 0},; 10525 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10526 * Some PROPFIND results MAY be cached, with care,; 10527 * as there is no cache validation mechanism for; 10528 * most properties. This method is both safe and; 10529 * idempotent (see Section 9.1 of [RFC2616]). */; 10530 {""MKCOL"", 0, 0, 0, 1, 0},; 10531 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10532 * When MKCOL is invoked without a request body,; 10533 * the newly created collection SHOULD have no; 10534 * members. A MKCOL request message may contain; 10535 * a message body. The precise behavior of a MKCOL; 10536 * request when the body is present is undefined,; 10537 * ... ==> We do not support MKCOL with body data.; 10538 * This method is idempotent, but not safe (see; 10539 * Section 9.1 of [RFC2616]). Responses to this; 10540 * method MUST NOT be cached. */; 10541 ; 10542 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10543 {""LOCK"", 1, 1, 0, 0, 0},; 10544 {""UNLOCK"", 1, 0, 0, 0, 0},; 10545 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10546 ; 10547 /* Unsupported WEBDAV Methods: */; 10548 /* COPY, MOVE (RFC 2518) */; 10549 /* + 11 methods from RFC 3253 */; 10550 /* ORDERPATCH (RFC 3648) */; 10551 /* ACL (RFC 3744) */; 10552 /* SEARCH (RFC 5323) */; 10553 /* + MicroSoft extensions; 10554 * https://msdn.microsoft.com/en-us/library/aa142917.aspx */; 10555 ; 10556 /* REPORT method (RFC 3253) */; 10557 {""REPORT"", 1, 1, 1, 1, 1},; 10558 /* REPORT method only allowed for CGI/Lua/LSP and callbacks. */; 10559 /* It was defined for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:302654,message,message,302654,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['message'],['message']
Integrability," 0, 0, 0},; 10513 {""PUT"", 1, 0, 0, 1, 0},; 10514 {""DELETE"", 0, 0, 0, 1, 0},; 10515 {""HEAD"", 0, 0, 1, 1, 1},; 10516 {""OPTIONS"", 0, 0, 1, 1, 0},; 10517 {""CONNECT"", 1, 1, 0, 0, 0},; 10518 /* TRACE method (RFC 2616) is not supported for security reasons */; 10519 ; 10520 /* PATCH method (RFC 5789) */; 10521 {""PATCH"", 1, 0, 0, 0, 0},; 10522 /* PATCH method only allowed for CGI/Lua/LSP and callbacks. */; 10523 ; 10524 /* WEBDAV (RFC 2518) */; 10525 {""PROPFIND"", 0, 1, 1, 1, 0},; 10526 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10527 * Some PROPFIND results MAY be cached, with care,; 10528 * as there is no cache validation mechanism for; 10529 * most properties. This method is both safe and; 10530 * idempotent (see Section 9.1 of [RFC2616]). */; 10531 {""MKCOL"", 0, 0, 0, 1, 0},; 10532 /* http://www.webdav.org/specs/rfc4918.html, 9.1:; 10533 * When MKCOL is invoked without a request body,; 10534 * the newly created collection SHOULD have no; 10535 * members. A MKCOL request message may contain; 10536 * a message body. The precise behavior of a MKCOL; 10537 * request when the body is present is undefined,; 10538 * ... ==> We do not support MKCOL with body data.; 10539 * This method is idempotent, but not safe (see; 10540 * Section 9.1 of [RFC2616]). Responses to this; 10541 * method MUST NOT be cached. */; 10542 ; 10543 /* Methods for write access to files on WEBDAV (RFC 2518) */; 10544 {""LOCK"", 1, 1, 0, 0, 0},; 10545 {""UNLOCK"", 1, 0, 0, 0, 0},; 10546 {""PROPPATCH"", 1, 1, 0, 0, 0},; 10547 ; 10548 /* Unsupported WEBDAV Methods: */; 10549 /* COPY, MOVE (RFC 2518) */; 10550 /* + 11 methods from RFC 3253 */; 10551 /* ORDERPATCH (RFC 3648) */; 10552 /* ACL (RFC 3744) */; 10553 /* SEARCH (RFC 5323) */; 10554 /* + MicroSoft extensions; 10555 * https://msdn.microsoft.com/en-us/library/aa142917.aspx */; 10556 ; 10557 /* REPORT method (RFC 3253) */; 10558 {""REPORT"", 1, 1, 1, 1, 1},; 10559 /* REPORT method only allowed for CGI/Lua/LSP and callbacks. */; 10560 /* It was defined for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:302687,message,message,302687,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['message'],['message']
Integrability," 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Fit model to data; # ----------------------------------; ; r = model.fitTo(data, Save=True, PrintLevel=-1); ; # Create MV Gaussian pdf of fitted parameters; # ------------------------------------------------------------------------------------; ; parabPdf = r.createHessePdf({frac, mean, sigma_g2}); ; # Some exercises with the parameter pdf; # -----------------------------------------------------------------------------; ; # Generate 100K points in the parameter space, from the MVGaussian pdf; d = parabPdf.generate({mean, sigma_g2, frac}, 100000); ; # Sample a 3-D histogram of the pdf to be visualized as an error; # ellipsoid using the GLISO draw option; hh_3d = parabPdf.createHistogram(""mean,sigma_g2,frac"", 25, 25, 25); hh_3d.SetFillColor(ROOT.kBlue); ; # Project 3D parameter pdf down to 3 permutations of two-dimensional pdfs; # The integrations corresponding to these projections are performed analytically; # by the MV Gaussian pdf; pdf_sigmag2_frac = parabPdf.createProjection({mean}); pdf_mean_frac = parabPdf.createProjection({sigma_g2}); pdf_mean_sigmag2 = parabPdf.createProjection({frac}); ; # Make 2D plots of the 3 two-dimensional pdf projections; hh_sigmag2_frac = pdf_sigmag2_frac.createHistogram(""sigma_g2,frac"", 50, 50); hh_mean_frac = pdf_mean_frac.createHistogram(""mean,frac"", 50, 50); hh_mean_sigmag2 = pdf_mean_sigmag2.createHistogram(""mean,sigma_g2"", 50, 50); hh_mean_frac.SetLineColor(ROOT.kBlue); hh_sigmag2_frac.SetLineColor(ROOT.kBlue); hh_mean_sigmag2.SetLineColor(ROOT.kBlue); ; # Draw the 'sigar'; ROOT.gStyle.SetCanvasPreferGL(True); ROOT.gStyle.SetPalette(1); c1 = ROOT.TCanvas(""rf608_fitresultaspdf_1"", ""rf608_fitresultaspdf_1"", 600, 600); hh_3d.Draw(""gliso""); ; c1.SaveAs(""rf608_fitresultaspdf_1.png""); ; # Draw the 2D projections of the 3D pdf; c2 = ROOT.TCanvas(""rf608_fitresultaspdf_2"", ""rf608_fitresultaspdf_2"", 900, 60",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html:1920,integrat,integrations,1920,doc/master/rf608__fitresultaspdf_8py.html,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8py.html,1,['integrat'],['integrations']
Integrability," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:7862,rout,routine,7862,root/html534/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,90,['rout'],['routine']
Integrability," 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:7860,rout,routine,7860,root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,60,['rout'],['routine']
Integrability," 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooGenericPdf.h>. Inheritance diagram for RooGenericPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooGenericPdf() [1/4]. RooGenericPdf::RooGenericPdf ; (; ). Definition at line 56 of file RooGenericPdf.cxx. ◆ ~RooGenericPdf(). RooGenericPdf::~RooGenericPdf ; (; ). override . Definition at line 58 of file RooGenericPdf.cxx. ◆ RooGenericPdf() [2/4]. RooGenericPdf::RooGenericPdf ; (; const char * ; name, . const char * ; title, . const char * ; formula, . const RooArgList & ; dependents . ). Constructor with a name, title, formula expression and a list of variables. ; Definition at line 86 of file RooGenericPdf.cxx. ◆ RooGenericPdf() [3/4]. RooGenericPdf::RooGenericPdf ; (; const char * ; name, . const char * ; title, . const RooArgList & ; dependents . ). Constructor with formula expression and list of input variables. ; Definition at line 67 of file RooGenericPdf.cxx. ◆ RooGenericPdf() [4/4]. RooGenericPdf::RooGenericPdf ; (; const RooGenericPdf & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 106 of file RooGenericPdf.cxx. Member Function Documentation. ◆ Class(). static TClass * RooGenericPdf::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooGenericPdf::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooGenericPdf::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGenericPdf.html:75667,depend,dependents,75667,doc/master/classRooGenericPdf.html,https://root.cern,https://root.cern/doc/master/classRooGenericPdf.html,1,['depend'],['dependents']
Integrability," 1) * Integration::kGAUSS21 : 21 points Gauss-Konrod rule (value = 2) * Integration::kGAUSS31 : 31 points Gauss-Konrod rule (value = 3) * Integration::kGAUSS41 : 41 points Gauss-Konrod rule (value = 4) * Integration::kGAUSS51 : 51 points Gauss-Konrod rule (value = 5) * Integration::kGAUSS61 : 61 points Gauss-Konrod rule (value = 6) The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule is passed, the 31 points rule is used as default. ROOT::Math::Integration::kADAPTIVESINGULAR: based on gsl_integration_qags. It is an integration type which can be used in the case of the presence of singularities.It uses the Gauss-Kronrod 21-point integration rule. This is the default algorithm. Note that when using the common ROOT::Math::IntegratorOneDIm class the enumeration type defining the algorithm must be defined in the namespace ROOT::Math::IntegrationOneDim (to distinguish from the multi-dimensional case) and the rule enumeration (or its corresponding integer) can be passed in the constructor of the ROOT::Math::IntegratorOneDIm.; 13.8.3 Multi-dimensional Integration; The multi-dimensional integration algorithm should be applied to functions with dimension larger than one. Adaptive multi-dimensional integration works for low function dimension, while MC integration can be applied to higher dimensions.; 13.8.3.1 Using ROOT::Math::IntegratorMultiDim; Here is a code example on how to use the ROOT::Math::IntegratorOneDim class (note that the class is defined in the header file Math/Integrator.h). In this example we create different instance of the class using some of the available algorithms in ROOT.; #include ""Math/IntegratorMultiDim.h""; #include ""Math/Functor.h"". double f2(const double * x) {; return x[0] + x[1];; }. int testIntegrationMultiDim() {. const double RESULT = 1.0;; const double ERRORLIMIT = 1E-3;; int status = 0;. ROOT::Math::Fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:708909,Integrat,IntegratorOneDIm,708909,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,['Integrat'],"['IntegrationOneDim', 'IntegratorOneDIm']"
Integrability," 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IntegratorOneDim.html:6150,Integrat,IntegratorOneDimOptions,6150,root/html532/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IntegratorOneDim.html,3,['Integrat'],['IntegratorOneDimOptions']
Integrability," 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointers). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__IntegratorOneDim.html:6120,Integrat,IntegratorOneDimOptions,6120,root/html604/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__IntegratorOneDim.html,1,['Integrat'],['IntegratorOneDimOptions']
Integrability," 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); rebuild temporary textfile from xml weightfile and load this; file into MLP. void ReadWeightsFromStream(istream& istr); read weights from stream; since the MLP can not read from the stream, we; 1st: write the weights to temporary file. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for classifier -> overwrites base class function; create specific class for TMultiLayerPerceptron. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response; nothing to do here - all taken care of by TMultiLayerPerceptron. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void SetHiddenLayer(TString hiddenlayer = """"); { fHiddenLayer=hiddenlayer; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodTMlpANN.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodTMlpANN.html:19530,message,message,19530,root/html530/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodTMlpANN.html,1,['message'],['message']
Integrability," 1.E-4, since the integrator might reach 1.E-4 already in its first; 920 * integration step. If lower precision is desired (more speed), a RooBinSamplingPdf has to be created manually, and its integrator; 921 * has to be manipulated directly.; 922 * - precision = 0: Activate bin integration only for continuous PDFs fit to a RooDataHist.; 923 * - precision < 0: Deactivate.; 924 * \see RooBinSamplingPdf; 925 * <tr><td> `ModularL(bool flag)` <td> Enable or disable modular likelihoods, which will become the default in a future release.; 926 * This does not change any user-facing code, but only enables a different likelihood class in the back-end. Note that this; 927 * should be set to true for parallel minimization of likelihoods!; 928 * Note that it is currently not recommended to use Modular likelihoods without any parallelization enabled in the minimization, since; 929 * some features such as offsetting might not yet work in this case.; 930 * </table>; 931 */; 932 ; 933 ; 934/** @brief Protected implementation of the NLL creation routine.; 935 *; 936 * This virtual function can be overridden in case you want to change the NLL creation logic for custom PDFs.; 937 *; 938 * \note Never call this function directly. Instead, call RooAbsPdf::createNLL().; 939 */; 940 ; 941std::unique_ptr<RooAbsReal> RooAbsPdf::createNLLImpl(RooAbsData &data, const RooLinkedList &cmdList); 942{; 943 return RooFit::FitHelpers::createNLL(*this, data, cmdList);; 944}; 945 ; 946 ; 947/** @fn RooAbsPdf::fitTo(); 948 *; 949 * @brief Fit PDF to given dataset.; 950 *; 951 * If dataset is unbinned, an unbinned maximum likelihood is performed.; 952 * If the dataset is binned, a binned maximum likelihood is performed.; 953 * By default the fit is executed through the MINUIT commands MIGRAD, HESSE in succession.; 954 *; 955 * @param data Reference to a RooAbsData object representing the dataset.; 956 * @param cmdArgs Variadic template arguments representing optional command arguments.; 957 * You can pas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:43056,rout,routine,43056,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['rout'],['routine']
Integrability," 1/// \file; 2/// \ingroup tutorial_tmva; 3/// \notebook -nodraw; 4/// This macro provides examples for the training and testing of the; 5/// TMVA classifiers.; 6///; 7/// As input data is used a toy-MC sample consisting of four Gaussian-distributed; 8/// and linearly correlated input variables.; 9///; 10/// The methods to be used can be switched on and off by means of booleans, or; 11/// via the prompt command, for example:; 12///; 13/// root -l TMVARegression.C\‍(\""LD,MLP\""\‍); 14///; 15/// (note that the backslashes are mandatory); 16/// If no method given, a default set is used.; 17///; 18/// The output file ""TMVAReg.root"" can be analysed with the use of dedicated; 19/// macros (simply say: root -l <macro.C>), which can be conveniently; 20/// invoked through a GUI that will appear at the end of the run of this macro.; 21/// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; 22/// - Package : TMVA; 23/// - Root Macro: TMVARegression; 24///; 25/// \macro_output; 26/// \macro_code; 27/// \author Andreas Hoecker; 28 ; 29#include <cstdlib>; 30#include <iostream>; 31#include <map>; 32#include <string>; 33 ; 34#include ""TChain.h""; 35#include ""TFile.h""; 36#include ""TTree.h""; 37#include ""TString.h""; 38#include ""TObjString.h""; 39#include ""TSystem.h""; 40#include ""TROOT.h""; 41 ; 42#include ""TMVA/Tools.h""; 43#include ""TMVA/Factory.h""; 44#include ""TMVA/DataLoader.h""; 45#include ""TMVA/TMVARegGui.h""; 46 ; 47 ; 48using namespace TMVA;; 49 ; 50void TMVARegression( TString myMethodList = """" ); 51{; 52 // The explicit loading of the shared libTMVA is done in TMVAlogon.C, defined in .rootrc; 53 // if you use your private .rootrc, or run from a different directory, please copy the; 54 // corresponding lines from .rootrc; 55 ; 56 // methods to be processed can be given as an argument; use format:; 57 //; 58 // mylinux~> root -l TMVARegression.C\‍(\""myMethod1,myMethod2,myMethod3\""\‍); 59 //; 60 ; 61 //-----------------------------------------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C_source.html:1055,integrat,integrated,1055,doc/master/TMVARegression_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C_source.html,1,['integrat'],['integrated']
Integrability," 1000, unsigned int rule = 3); ROOT::Math::IntegratorOneDimIntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000, int rule = 3); doubleoperator()(double x); doubleResult() const; voidSetAbsTolerance(double absTolerance); voidSetFunction(const ROOT::Math::IGenFunction& f, bool copy = false); voidSetFunction(const ROOT::Math::IMultiGenFunction& f, unsigned int icoord = 0, const double* x = 0); voidSetRelTolerance(double relTolerance); intStatus() const. protected:. ROOT::Math::VirtualIntegratorOneDim*CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). private:. ROOT::Math::IntegratorOneDimIntegratorOneDim(const ROOT::Math::IntegratorOneDim&); ROOT::Math::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction(const Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(const Function & f). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). double IntegralUp(const ROOT::Math::IGenFunction& f, double a). double Integral(const Function & f, const std::vector<double> & pts). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000, unsigned int rule = 3); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum numbe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html:3743,integrat,integrator,3743,root/html526/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html,2,"['integrat', 'interface']","['integrator', 'interface']"
Integrability," 1027/// object is a type suitable to be stored as a pointer to a ""expectedClass""; 1028/// If expectedClass is null, no check is performed.; 1029///; 1030/// - namecycle has the format name;cycle; 1031/// - name = * is illegal, cycle = * is illegal; 1032/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 1033///; 1034/// ### Very important note; 1035/// The calling application must cast the returned pointer to; 1036/// the type described by the 2 arguments (i.e. cl):; 1037///; 1038/// auto objPtr = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));; 1039///; 1040/// Note: We recommend using the method TDirectoryFile::Get<T>:; 1041/// ~~~{.cpp}; 1042/// auto objPtr = directory->Get<MyClass>(""some object inheriting from MyClass"");; 1043/// if (objPtr) { ... we found what we are looking for ... }; 1044/// ~~~; 1045 ; 1046void *TDirectoryFile::GetObjectChecked(const char *namecycle, const TClass* expectedClass); 1047{; 1048 ; 1049 // If the name is invalid, issue an error message and return a nullptr; 1050 if (!namecycle || '\0' == namecycle[0]) {; 1051 Error(""GetObjectChecked"", ""The provided key name is invalid."");; 1052 return nullptr;; 1053 }; 1054 ; 1055 Short_t cycle;; 1056 char name[kMaxLen];; 1057 ; 1058 DecodeNameCycle(namecycle, name, cycle, kMaxLen);; 1059 Int_t nch = strlen(name);; 1060 for (Int_t i = nch-1; i > 0; i--) {; 1061 if (name[i] == '/') {; 1062 name[i] = 0;; 1063 TDirectory* dirToSearch=GetDirectory(name);; 1064 const char *subnamecycle = namecycle + i + 1;; 1065 name[i] = '/';; 1066 if (dirToSearch) {; 1067 return dirToSearch->GetObjectChecked(subnamecycle, expectedClass);; 1068 } else {; 1069 return nullptr;; 1070 }; 1071 }; 1072 }; 1073 const char *namobj = name;; 1074 ; 1075//*-*---------------------Case of Object in memory---------------------; 1076// ========================; 1077 if (expectedClass==0 || expectedClass->IsTObject()) {; 1078 TObject *objcur = fList ? fList->FindObject(namobj) : nullptr;; 1079",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:35599,message,message,35599,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['message'],['message']
Integrability," 1099 of file RooWorkspace.cxx. ◆ IsA(). TClass * RooWorkspace::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 282 of file RooWorkspace.h. ◆ loadSnapshot(). bool RooWorkspace::loadSnapshot ; (; const char * ; name). Load the values and attributes of the parameters in the snapshot saved with the given name. ; Definition at line 1182 of file RooWorkspace.cxx. ◆ makeDir(). bool RooWorkspace::makeDir ; (; ). Create transient TDirectory representation of this workspace. ; This directory will appear as a subdirectory of the directory that contains the workspace and will have the name of the workspace suffixed with ""Dir"". The TDirectory interface is read-only. Any attempt to insert objects into the workspace directory representation will result in an error message. Note that some ROOT object like TH1 automatically insert themselves into the current directory when constructed. This will give error messages when done in a workspace directory. ; Definition at line 1887 of file RooWorkspace.cxx. ◆ merge(). void RooWorkspace::merge ; (; const RooWorkspace & ; ). inline . Definition at line 102 of file RooWorkspace.h. ◆ obj(). TObject * RooWorkspace::obj ; (; RooStringView ; name); const. Return any type of object (RooAbsArg, RooAbsData or generic object) with given name) ; Definition at line 2007 of file RooWorkspace.cxx. ◆ pdf(). RooAbsPdf * RooWorkspace::pdf ; (; RooStringView ; name); const. Retrieve p.d.f (RooAbsPdf) with given name. A null pointer is returned if not found. ; Definition at line 1214 of file RooWorkspace.cxx. ◆ Print(). void RooWorkspace::Print ; (; Option_t * ; opts = nullptr); const. overridevirtual . Print contents of the workspace. ; Reimplemented from TObject.; Definition at line 2095 of file RooWorkspace.cxx. ◆ RecursiveRemove(). void RooWorkspace::RecursiveRemove ; (; TObject * ; obj). overridevirtual . If one of the TObject we have a referenced to is deleted, remove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace.html:45099,message,messages,45099,doc/master/classRooWorkspace.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace.html,1,['message'],['messages']
Integrability," 111 of file TBranchBrowsable.h. ◆ IsA(). TClass * TMethodBrowsable::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 128 of file TBranchBrowsable.h. ◆ IsMethodBrowsable(). bool TMethodBrowsable::IsMethodBrowsable ; (; const TMethod * ; m). static . A TMethod is browsable if it is const, public and not pure virtual, if does not have any parameter without default value, and if it has a (non-void) return value. ; A method called *, Get*, or get* will not be browsable if there is a persistent data member called f*, _*, or m*, as data member access is faster than method access. Examples: if one of fX, _X, or mX is a persistent data member, the methods GetX(), getX(), and X() will not be browsable. ; Definition at line 530 of file TBranchBrowsable.cxx. ◆ Register(). void TMethodBrowsable::Register ; (; ). static . Wrapper for the registration method. ; Needed against MSVC, which assigned different addr to the same method, depending on what translation unit you're in... ; Definition at line 585 of file TBranchBrowsable.cxx. ◆ Streamer(). void TMethodBrowsable::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TMethodBrowsable::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 128 of file TBranchBrowsable.h. ◆ Unregister(). void TMethodBrowsable::Unregister ; (; ). static . Wrapper for the registration method. ; Needed against MSVC, which assigned different addr to the same method, depending on what translation unit you're in... ; Definition at line 595 of file TBranchBrowsable.cxx. Member Data Documentation. ◆ fMethod. TMethod* TMethodBrowsable::fMethod {nullptr}. private . Definition at line 127 of file TBranchBrowsable.h. Libraries for TMethodBrowsable:. [legend]; The documentation for this class was generated from the following files:; tree/tree/inc/TBran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMethodBrowsable.html:19398,depend,depending,19398,doc/master/classTMethodBrowsable.html,https://root.cern,https://root.cern/doc/master/classTMethodBrowsable.html,1,['depend'],['depending']
Integrability," 1183 of file RooAbsReal.cxx. ◆ createIntegral() [1/6]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const char * ; rangeName . ); const. inline . Create integral over observables in iset in range named rangeName. ; Definition at line 207 of file RooAbsReal.h. ◆ createIntegral() [2/6]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet & ; nset, . const char * ; rangeName = nullptr . ); const. inline . Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset. ; Definition at line 211 of file RooAbsReal.h. ◆ createIntegral() [3/6]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet & ; nset, . const RooNumIntConfig & ; cfg, . const char * ; rangeName = nullptr . ); const. inline . Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ; Definition at line 216 of file RooAbsReal.h. ◆ createIntegral() [4/6]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet * ; nset = nullptr, . const RooNumIntConfig * ; cfg = nullptr, . const char * ; rangeName = nullptr . ); const. virtual . Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over. If nset is specified the integrand is request to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified the integral is performed over the named range, otherwise it is performed over the domain of each integ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:86562,integrat,integration,86562,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['integrat'],['integration']
Integrability," 1211 of file RooAbsReal.cxx. ◆ createIntegral() [1/6]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const char * ; rangeName . ); const. inline . Create integral over observables in iset in range named rangeName. ; Definition at line 207 of file RooAbsReal.h. ◆ createIntegral() [2/6]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet & ; nset, . const char * ; rangeName = nullptr . ); const. inline . Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset. ; Definition at line 211 of file RooAbsReal.h. ◆ createIntegral() [3/6]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet & ; nset, . const RooNumIntConfig & ; cfg, . const char * ; rangeName = nullptr . ); const. inline . Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ; Definition at line 216 of file RooAbsReal.h. ◆ createIntegral() [4/6]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet * ; nset = nullptr, . const RooNumIntConfig * ; cfg = nullptr, . const char * ; rangeName = nullptr . ); const. virtual . Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over. If nset is specified the integrand is request to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified the integral is performed over the named range, otherwise it is performed over the domain of each integ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:87830,integrat,integration,87830,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['integrat'],['integration']
Integrability," 134 ; 135 /// NOTE: if you change this version you also need to update RTFNTuple::fClassVersion in RMiniFile.cxx; 136 ClassDefNV(RNTuple, 2);; 137}; // class RNTuple; 138 ; 139} // namespace ROOT; 140 ; 141#endif; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Rtypes.h; ClassDefNV#define ClassDefNV(name, id)Definition Rtypes.h:350; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; ROOT::Experimental::Internal::RNTupleFileWriterWrite RNTuple data blocks in a TFile or a bare file container.Definition RMiniFile.hxx:103; ROOT::Experimental::Internal::RPageSourceFileStorage provider that reads ntuple pages from a file.Definition RPageStorageFile.hxx:117; ROOT::RNTupleRepresentation of an RNTuple data set in a ROOT file.Definition RNTuple.hxx:69; ROOT::RNTuple::MergeLong64_t Merge(TCollection *input, TFileMergeInfo *mergeInfo)RNTuple implements the hadd MergeFile interface Merge this NTuple with the input list entries.Definition RNTupleMerger.cxx:45; ROOT::RNTuple::fSeekFooterstd::uint64_t fSeekFooterThe file offset of the footer excluding the TKey part.Definition RNTuple.hxx:103; ROOT::RNTuple::fNBytesFooterstd::uint64_t fNBytesFooterThe size of the compressed ntuple footer.Definition RNTuple.hxx:105; ROOT::RNTuple::GetLenFooterstd::uint64_t GetLenFooter() constDefinition RNTuple.hxx:128; ROOT::RNTuple::kVersionPatchstatic constexpr std::uint16_t kVersionPatchDefinition RNTuple.hxx:82; ROOT::RNTuple::GetSeekHeaderstd::uint64_t GetSeekHeader() constDefinition RNTuple.hxx:122; ROOT::RNTuple::fVersionMinorstd::uint16_t fVersionMinorChanging the minor version indicates new optional fields added to the RNTuple meta-data.Definition RNTuple.hxx:93; ROOT::RNTuple::kVersionMajorstatic constexpr std::uint16_t kVersionMajorDefinition RNTuple.hxx:80; ROOT::RNTuple::RNTupleRNTuple()=default; ROOT::RNTuple::GetVersionMajor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTuple_8hxx_source.html:7144,interface,interface,7144,doc/master/RNTuple_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTuple_8hxx_source.html,1,['interface'],['interface']
Integrability," 1346 ; 1347 if (handler->HandleWS(arg)) {; 1348 arg->SetMethod(""WS_READY"");; 1349 ; 1350 if (handler->HandleWS(arg)); 1351 arg->SetTextContent(std::string(israw ? ""txt:"" : """") + std::to_string(arg->GetWSId()));; 1352 } else {; 1353 arg->TakeWSEngine(); // delete handle; 1354 }; 1355 ; 1356 process = arg->IsText();; 1357 } else {; 1358 TUrl url;; 1359 url.SetOptions(arg->fQuery);; 1360 url.ParseOptions();; 1361 const char *connid = url.GetValueFromOptions(""connection"");; 1362 if (connid); 1363 arg->SetWSId(std::stoul(connid));; 1364 if (url.HasOption(""close"")) {; 1365 arg->SetMethod(""WS_CLOSE"");; 1366 arg->SetTextContent(""OK"");; 1367 } else {; 1368 arg->SetMethod(""WS_DATA"");; 1369 }; 1370 ; 1371 process = handler->HandleWS(arg);; 1372 }; 1373 }; 1374 ; 1375 if (!process); 1376 arg->Set404();; 1377 ; 1378 return process;; 1379}; 1380 ; 1381////////////////////////////////////////////////////////////////////////////////; 1382/// Restrict access to specified object; 1383///; 1384/// See TRootSniffer::Restrict() for more details; 1385 ; 1386void THttpServer::Restrict(const char *path, const char *options); 1387{; 1388 fSniffer->Restrict(path, options);; 1389}; 1390 ; 1391////////////////////////////////////////////////////////////////////////////////; 1392/// Register command which can be executed from web interface; 1393///; 1394/// As method one typically specifies string, which is executed with; 1395/// gROOT->ProcessLine() method. For instance:; 1396///; 1397/// serv->RegisterCommand(""Invoke"",""InvokeFunction()"");; 1398///; 1399/// Or one could specify any method of the object which is already registered; 1400/// to the server. For instance:; 1401///; 1402/// serv->Register(""/"", hpx);; 1403/// serv->RegisterCommand(""/ResetHPX"", ""/hpx/->Reset()"");; 1404///; 1405/// Here symbols '/->' separates item name from method to be executed; 1406///; 1407/// One could specify additional arguments in the command with; 1408/// syntax like %arg1%, %arg2% and so on. For example:; 140",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:44500,interface,interface,44500,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['interface'],['interface']
Integrability," 14, 15, T51);; 377 SET(b, c, d, a, 5, 21, T52);; 378 SET(a, b, c, d, 12, 6, T53);; 379 SET(d, a, b, c, 3, 10, T54);; 380 SET(c, d, a, b, 10, 15, T55);; 381 SET(b, c, d, a, 1, 21, T56);; 382 SET(a, b, c, d, 8, 6, T57);; 383 SET(d, a, b, c, 15, 10, T58);; 384 SET(c, d, a, b, 6, 15, T59);; 385 SET(b, c, d, a, 13, 21, T60);; 386 SET(a, b, c, d, 4, 6, T61);; 387 SET(d, a, b, c, 11, 10, T62);; 388 SET(c, d, a, b, 2, 15, T63);; 389 SET(b, c, d, a, 9, 21, T64);; 390#undef SET; 391 ; 392 /* Then perform the following additions. (That is increment each; 393 of the four registers by the value it had before this block; 394 was started.) */; 395 pms->abcd[0] += a;; 396 pms->abcd[1] += b;; 397 pms->abcd[2] += c;; 398 pms->abcd[3] += d;; 399}; 400 ; 401MD5_STATIC void; 402md5_init(md5_state_t *pms); 403{; 404 pms->count[0] = pms->count[1] = 0;; 405 pms->abcd[0] = 0x67452301;; 406 pms->abcd[1] = /*0xefcdab89*/ T_MASK ^ 0x10325476;; 407 pms->abcd[2] = /*0x98badcfe*/ T_MASK ^ 0x67452301;; 408 pms->abcd[3] = 0x10325476;; 409}; 410 ; 411MD5_STATIC void; 412md5_append(md5_state_t *pms, const md5_byte_t *data, size_t nbytes); 413{; 414 const md5_byte_t *p = data;; 415 size_t left = nbytes;; 416 size_t offset = (pms->count[0] >> 3) & 63;; 417 md5_word_t nbits = (md5_word_t)(nbytes << 3);; 418 ; 419 if (nbytes <= 0); 420 return;; 421 ; 422 /* Update the message length. */; 423 pms->count[1] += (md5_word_t)(nbytes >> 29);; 424 pms->count[0] += nbits;; 425 if (pms->count[0] < nbits); 426 pms->count[1]++;; 427 ; 428 /* Process an initial partial block. */; 429 if (offset) {; 430 size_t copy = (offset + nbytes > 64 ? 64 - offset : nbytes);; 431 ; 432 memcpy(pms->buf + offset, p, copy);; 433 if (offset + copy < 64); 434 return;; 435 p += copy;; 436 left -= copy;; 437 md5_process(pms, pms->buf);; 438 }; 439 ; 440 /* Process full blocks. */; 441 for (; left >= 64; p += 64, left -= 64); 442 md5_process(pms, p);; 443 ; 444 /* Process a final partial block. */; 445 if (left); 446 memcpy(pms->buf, p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/md5_8inl_source.html:15362,message,message,15362,doc/master/md5_8inl_source.html,https://root.cern,https://root.cern/doc/master/md5_8inl_source.html,1,['message'],['message']
Integrability," 19// Virtual interface of a proxy object for a collection class //; 20// In particular this is used to implement splitting, emulation, //; 21// and TTreeFormula access to STL containers. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TClassRef.h""; 26#include ""TDataType.h""; 27 ; 28// Macro indicating the version of the Collection Proxy interface followed; 29// by this ROOT build (See also Reflex/Builder/CollectionProxy.h).; 30#define ROOT_COLLECTIONPROXY_VERSION 3; 31 ; 32class TClass;; 33namespace TStreamerInfoActions {; 34 class TActionSequence;; 35}; 36 ; 37// clang-format off; 38/**; 39\class TVirtualCollectionProxy; 40\brief Defines a common interface to inspect/change the contents of an object that represents a collection; 41 ; 42Specifically, an object of a class that derives from TVirtualCollectionProxy relays accesses to any object that; 43matches the proxied collection type.; 44The interface provides two families of functions: (i) for direct manipulation, e.g. `Insert()` or `At()`; and; 45(ii) iterator-based, e.g. `GetFunctionCreateIterators()` or `GetFunctionNext()`.; 46TVirtualCollectionProxy objects are stateful; in particular, many functions require to set the object to operate; 47on via `PushProxy()` / `PopProxy()`. The `TPushPop` RAII class is provided for convenience.; 48A collection proxy for a given class can be permanently set using `TClass::CopyCollectionProxy()`.; 49The `Generate()` function should be overridden in derived classes to return a clean object of the most-derived class.; 50*/; 51// clang-format on; 52class TVirtualCollectionProxy {; 53private:; 54 TVirtualCollectionProxy(const TVirtualCollectionProxy&) = delete;; 55 TVirtualCollectionProxy& operator=(const TVirtualCollectionProxy&) = delete;; 56 ; 57protected:; 58 TClassRef fClass;; 59 UInt_t fProperties;; 60 friend class TClass;; 61 ; 62public:; 63 enum EProperty {; 64 // No longer used; 65 // kIsInitialized = BIT(1),; 66 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:1834,interface,interface,1834,doc/master/TVirtualCollectionProxy_8h_source.html,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html,1,['interface'],['interface']
Integrability," 246 kClonesNode = 3,; 247 kSTLNode = 4,; 248 kClonesMemberNode = 31,; 249 kSTLMemberNode = 41; 250 };; 251 ; 252private:; 253 Int_t FillImpl(ROOT::Internal::TBranchIMTHelper *) override;; 254 ; 255 ClassDefOverride(TBranchElement,10) // Branch in case of an object; 256};; 257 ; 258inline void TBranchElement::SetParentClass(TClass* clparent); 259{; 260 fParentClass = clparent;; 261 fParentName = clparent ? clparent->GetName() : """";; 262}; 263 ; 264inline void TBranchElement::ValidateAddress() const; 265{; 266 // Check to see if the user changed the object pointer without telling us.; 267 ; 268 if (fID < 0) {; 269 // We are a top-level branch.; 270 if (!fTree->GetMakeClass() && fAddress && (*((char**) fAddress) != fObject)) {; 271 // The semantics of fAddress and fObject are violated.; 272 // Assume the user changed the pointer on us.; 273 // Note: The cast is here because we want to be able to; 274 // be called from the constant get functions.; 275 ; 276 // FIXME: Disable the check/warning TTree until we add a missing interface.; 277 if (TestBit(kDeleteObject)) {; 278 // This should never happen!; 279 Error(""ValidateAddress"", ""We owned an object whose address changed! our ptr: %p new ptr: %p"",; 280 (void*)fObject, (void*)*((char**) fAddress));; 281 const_cast<TBranchElement*>(this)->ResetBit(kDeleteObject);; 282 }; 283 const_cast<TBranchElement*>(this)->SetAddress(fAddress);; 284 }; 285 }; 286}; 287 ; 288#endif // ROOT_TBranchElement; b#define b(i)Definition RSha256.hxx:100; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; BIT#define BIT(n)Definition Rtypes.h:90; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TBranch.h; TClassRef.h; EDataTypeEDataTypeDefinition TDataType.h:28; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; offsetOption_t Option_t TPoint TPoint const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8h_source.html:14286,interface,interface,14286,doc/master/TBranchElement_8h_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8h_source.html,1,['interface'],['interface']
Integrability," 2564{; 2565 RooArgSet constraints;; 2566 RooArgSet pdfParams;; 2567 ; 2568 std::unique_ptr<RooArgSet> comps(getComponents());; 2569 for (const auto arg : *comps) {; 2570 auto pdf = dynamic_cast<const RooAbsPdf*>(arg) ;; 2571 if (pdf && !constraints.find(pdf->GetName())) {; 2572 std::unique_ptr<RooArgSet> compRet(; 2573 pdf->getConstraints(observables,constrainedParams, pdfParams));; 2574 if (compRet) {; 2575 constraints.add(*compRet,false) ;; 2576 }; 2577 }; 2578 }; 2579 ; 2580 RooArgSet conParams;; 2581 ; 2582 // Strip any constraints that are completely decoupled from the other product terms; 2583 RooArgSet* finalConstraints = new RooArgSet(""AllConstraints"") ;; 2584 for(auto * pdf : static_range_cast<RooAbsPdf*>(constraints)) {; 2585 ; 2586 RooArgSet tmp;; 2587 pdf->getParameters(nullptr, tmp);; 2588 conParams.add(tmp,true) ;; 2589 ; 2590 if (pdf->dependsOnValue(pdfParams) || !stripDisconnected) {; 2591 finalConstraints->add(*pdf) ;; 2592 } else {; 2593 coutI(Minimization) << ""RooAbsPdf::getAllConstraints("" << GetName() << "") omitting term "" << pdf->GetName(); 2594 << "" as constraint term as it does not share any parameters with the other pdfs in product. ""; 2595 << ""To force inclusion in likelihood, add an explicit Constrain() argument for the target parameter"" << endl ;; 2596 }; 2597 }; 2598 ; 2599 // Now remove from constrainedParams all parameters that occur exclusively in constraint term and not in regular pdf term; 2600 ; 2601 RooArgSet cexl;; 2602 conParams.selectCommon(constrainedParams, cexl);; 2603 cexl.remove(pdfParams,true,true) ;; 2604 constrainedParams.remove(cexl,true,true) ;; 2605 ; 2606 return finalConstraints ;; 2607}; 2608 ; 2609 ; 2610////////////////////////////////////////////////////////////////////////////////; 2611/// Returns the default numeric MC generator configuration for all RooAbsReals; 2612 ; 2613RooNumGenConfig* RooAbsPdf::defaultGeneratorConfig(); 2614{; 2615 return &RooNumGenConfig::defaultConfig() ;; 2616}; 2617 ; 2618 ; 2619///",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:124070,depend,dependsOnValue,124070,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['depend'],['dependsOnValue']
Integrability," 256;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbinsx;; Double_t ymin = 0;; Double_t ymax = (Double_t)nbinsy;; Double_t** source = new Double_t*[nbinsx];; for (i=0;i<nbinsx;i++); source[i] = new Double_t[nbinsy];; TString dir = gROOT->GetTutorialDir();; TString file = dir+""/spectrum/TSpectrum2.root"";; TFile *f = new TFile(file.Data());; auto smooth = (TH2F*) f->Get(""smooth1"");; gStyle->SetOptStat(0);; auto *s = new TSpectrum2();; for (i = 0; i < nbinsx; i++){; for (j = 0; j < nbinsy; j++){; source[i][j] = smooth->GetBinContent(i + 1,j + 1);; }; }; s->SmoothMarkov(source,nbinsx,nbinsx,3); //5,7; for (i = 0; i < nbinsx; i++){; for (j = 0; j < nbinsy; j++); smooth->SetBinContent(i + 1,j + 1, source[i][j]);; }; smooth->Draw(""SURF2"");; }; . Definition at line 582 of file TSpectrum2.cxx. ◆ StaticBackground(). TH1 * TSpectrum2::StaticBackground ; (; const TH1 * ; hist, . Int_t ; niter = 20, . Option_t * ; option = """" . ). static . static function (called by TH1), interface to TSpectrum2::Background ; Definition at line 1721 of file TSpectrum2.cxx. ◆ StaticSearch(). Int_t TSpectrum2::StaticSearch ; (; const TH1 * ; hist, . Double_t ; sigma = 2, . Option_t * ; option = ""goff"", . Double_t ; threshold = 0.05 . ). static . static function (called by TH1), interface to TSpectrum2::Search ; Definition at line 1712 of file TSpectrum2.cxx. ◆ Streamer(). void TSpectrum2::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TNamed. ◆ StreamerNVirtual(). void TSpectrum2::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 61 of file TSpectrum2.h. Member Data Documentation. ◆ fgAverageWindow. Int_t TSpectrum2::fgAverageWindow = 3. staticprotected . Average window of searched peaks. ; Definition at line 27 of file TSpectrum2.h. ◆ fgIterations. Int_t TSpectrum2::fgIterations = 3. staticprotected . Maximum number of decon iterations (default=3) ; Definition at line 28 of file TSpectrum2.h. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2.html:48597,interface,interface,48597,doc/master/classTSpectrum2.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2.html,1,['interface'],['interface']
Integrability," 3) option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc. TVirtualFFT* SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); Returns a pointer to a sine or cosine transform of requested size and kind. Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -r2rkind : transform kind for each dimension; 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DST-III - kind=6; DST-IV - kind=7; -option : consists of 2 parts - flag option and an option to create a new TVirtualFFT; - flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; - option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""ES K"", ""EX"", etc. TVirtualFFT* GetCurrentTransform(); static: return current fgFFT. void SetTransform(TVirtualFFT* ff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualFFT.html:12080,depend,depending,12080,root/html528/TVirtualFFT.html,https://root.cern,https://root.cern/root/html528/TVirtualFFT.html,10,['depend'],['depending']
Integrability," 30 dataset entries, for which strategy 2 is followed. Optimize(Bool_t flag) -- Activate constant term optimization (on by default); SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrain(const RooArgSet&pars) -- For p.d.f.s that contain internal parameter constraint terms, only apply constraints to given subset of parameters; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; GlobalObservablesTag(const char* tagName) -- Define the set of normalization observables to be used for the constraint terms by a string attribute; associated with pdf observables that match he given tagName; Verbose(Bool_t flag) -- Constrols RooFit informational messages in likelihood construction; CloneData(Bool flag) -- Use clone of dataset in NLL (default is true); Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:52415,message,messages,52415,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,2,['message'],['messages']
Integrability," 30 dataset entries, for which strategy 2 is followed. Optimize(Bool_t flag) -- Activate constant term optimization (on by default); SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrain(const RooArgSet&pars) -- For p.d.f.s that contain internal parameter constraint terms, only apply constraints to given subset of parameters; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; GlobalObservablesTag(const char* tagName) -- Define the set of normalization observables to be used for the constraint terms by a string attribute; associated with pdf observables that match the given tagName; Verbose(Bool_t flag) -- Constrols RooFit informational messages in likelihood construction; CloneData(Bool flag) -- Use clone of dataset in NLL (default is true); Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsPdf.html:54579,message,messages,54579,root/html602/RooAbsPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html,4,['message'],['messages']
Integrability, 322 of file RooNumGenConfig.cxx. ◆ Streamer(). void RooNumGenConfig::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooNumGenConfig::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 75 of file RooNumGenConfig.h. Member Data Documentation. ◆ _configSets. RooLinkedList RooNumGenConfig::_configSets. protected . List of configuration sets for individual integration methods. ; Definition at line 73 of file RooNumGenConfig.h. ◆ _method1D. RooCategory RooNumGenConfig::_method1D. protected . Selects integration method for 1D p.d.f.s. ; Definition at line 58 of file RooNumGenConfig.h. ◆ _method1DCat. RooCategory RooNumGenConfig::_method1DCat. protected . Selects integration method for 1D p.d.f.s with categories. ; Definition at line 59 of file RooNumGenConfig.h. ◆ _method1DCond. RooCategory RooNumGenConfig::_method1DCond. protected . Selects integration method for 1D conditional p.d.f.s. ; Definition at line 60 of file RooNumGenConfig.h. ◆ _method1DCondCat. RooCategory RooNumGenConfig::_method1DCondCat. protected . Selects integration method for 1D conditional p.d.f.s with categories. ; Definition at line 61 of file RooNumGenConfig.h. ◆ _method2D. RooCategory RooNumGenConfig::_method2D. protected . Selects integration method for 2D p.d.f.s. ; Definition at line 63 of file RooNumGenConfig.h. ◆ _method2DCat. RooCategory RooNumGenConfig::_method2DCat. protected . Selects integration method for 2D p.d.f.s with categories. ; Definition at line 64 of file RooNumGenConfig.h. ◆ _method2DCond. RooCategory RooNumGenConfig::_method2DCond. protected . Selects integration method for 2D conditional p.d.f.s. ; Definition at line 65 of file RooNumGenConfig.h. ◆ _method2DCondCat. RooCategory RooNumGenConfig::_method2DCondCat. protected . Selects integration method for 2D conditional p.d.f.s with categories. ; Definition at line 66 of file RooNumGenConfig.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumGenConfig.html:20284,integrat,integration,20284,doc/master/classRooNumGenConfig.html,https://root.cern,https://root.cern/doc/master/classRooNumGenConfig.html,1,['integrat'],['integration']
Integrability," 3554 delete [] integral;; 3555 Error(""FillRandom"", ""Integral = zero""); return;; 3556 }; 3557 for (bin=1;bin<=nbinsx;bin++) integral[bin] /= integral[nbinsx];; 3558 ; 3559 // --------------Start main loop ntimes; 3560 for (loop=0;loop<ntimes;loop++) {; 3561 r1 = (rng) ? rng->Rndm() : gRandom->Rndm();; 3562 ibin = TMath::BinarySearch(nbinsx,&integral[0],r1);; 3563 //binx = 1 + ibin;; 3564 //x = xAxis->GetBinCenter(binx); //this is not OK when SetBuffer is used; 3565 x = xAxis->GetBinLowEdge(ibin+first); 3566 +xAxis->GetBinWidth(ibin+first)*(r1-integral[ibin])/(integral[ibin+1] - integral[ibin]);; 3567 Fill(x);; 3568 }; 3569 delete [] integral;; 3570}; 3571 ; 3572////////////////////////////////////////////////////////////////////////////////; 3573/// Fill histogram following distribution in histogram h.; 3574///; 3575/// @param h : Histogram pointer used for sampling random number; 3576/// @param ntimes : number of times the histogram is filled; 3577/// @param rng : (optional) Random number generator used for sampling; 3578///; 3579/// The distribution contained in the histogram h (TH1) is integrated; 3580/// over the channel contents for the bin range of this histogram.; 3581/// It is normalized to 1.; 3582///; 3583/// Getting one random number implies:; 3584/// - Generating a random number between 0 and 1 (say r1); 3585/// - Look in which bin in the normalized integral r1 corresponds to; 3586/// - Fill histogram channel ntimes random numbers are generated; 3587///; 3588/// SPECIAL CASE when the target histogram has the same binning as the source.; 3589/// in this case we simply use a poisson distribution where; 3590/// the mean value per bin = bincontent/integral.; 3591 ; 3592void TH1::FillRandom(TH1 *h, Int_t ntimes, TRandom * rng); 3593{; 3594 if (!h) { Error(""FillRandom"", ""Null histogram""); return; }; 3595 if (fDimension != h->GetDimension()) {; 3596 Error(""FillRandom"", ""Histograms with different dimensions""); return;; 3597 }; 3598 if (std::isnan(h->ComputeIntegr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:142467,integrat,integrated,142467,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['integrat'],['integrated']
Integrability," 3718 if (mode & kOpt); 3719 optdebFlags += fFlagsOpt;; 3720 cmd.ReplaceAll(""$Opt"", optdebFlags);; 3721#ifdef WIN32; 3722 R__FixLink(cmd);; 3723 cmd.ReplaceAll(""-std="", ""-std:"");; 3724#endif; 3725 ; 3726 TString testcmd = fMakeExe;; 3727 TString fakeMain;; 3728 AssignAndDelete( fakeMain, ConcatFileName( build_loc, libname ) );; 3729 fakeMain += ""_ACLiC_main"";; 3730 fakeMain += extension;; 3731 std::ofstream fakeMainFile( fakeMain, std::ios::out );; 3732 fakeMainFile << ""// File Automatically generated by the ROOT Script Compiler ""; 3733 << std::endl;; 3734 fakeMainFile << ""int main(char*argc,char**argvv) {};"" << std::endl;; 3735 fakeMainFile.close();; 3736 // We could append this fake main routine to the compilation line.; 3737 // But in this case compiler may output the name of the dictionary file; 3738 // and of the fakeMain file while it compiles it. (this would be useless; 3739 // confusing output).; 3740 // We could also the fake main routine to the end of the dictionary file; 3741 // however compilation would fail if a main is already there; 3742 // (like stress.cxx); 3743 // dict.Append("" "").Append(fakeMain);; 3744 TString exec;; 3745 AssignAndDelete( exec, ConcatFileName( build_loc, libname ) );; 3746 exec += ""_ACLiC_exec"";; 3747 testcmd.ReplaceAll(""$SourceFiles"",""-D__ACLIC__ \""$SourceFiles\"""");; 3748 testcmd.ReplaceAll(""$SourceFiles"",dict);; 3749 testcmd.ReplaceAll(""$ObjectFiles"",""\""$ObjectFiles\"""");; 3750 testcmd.ReplaceAll(""$ObjectFiles"",dictObj);; 3751 testcmd.ReplaceAll(""$IncludePath"",includes);; 3752 testcmd.ReplaceAll(""$ExeName"",exec);; 3753 testcmd.ReplaceAll(""$LinkedLibs"",linkLibraries);; 3754 testcmd.ReplaceAll(""$BuildDir"",build_loc);; 3755 if (mode==kDebug); 3756 testcmd.ReplaceAll(""$Opt"",fFlagsDebug);; 3757 else; 3758 testcmd.ReplaceAll(""$Opt"",fFlagsOpt);; 3759 ; 3760#ifdef WIN32; 3761 R__FixLink(testcmd);; 3762 testcmd.ReplaceAll(""-std="", ""-std:"");; 3763#endif; 3764 ; 3765 // ======= Build the library; 3766 if (result) {; 3767 TString cmdAllowUnr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:126882,rout,routine,126882,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['rout'],['routine']
Integrability," 376} // end namespace ROOT; 377 ; 378 ; 379#endif /* ROOT_Math_Minimizer */; IFunction.h; MinimizerOptions.h; RSpan.hxx; onOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void onDefinition TGWin32VirtualXProxy.cxx:106; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IOptionsGeneric interface for defining configuration options of a numerical algorithm.Definition IOptions.h:28; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; ROOT::Math::MinimizerOptions::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition MinimizerOptions.h:213; ROOT::Math::MinimizerOptions::SetStrategyvoid SetStrategy(int stra)set the strategyDefinition MinimizerOptions.h:225; ROOT::Math::MinimizerOptions::SetMaxIterationsvoid SetMaxIterations(unsigned int maxiter)set maximum iterations (one iteration can have many function calls)Definition MinimizerOptions.h:216; ROOT::Math::MinimizerOptions::Strategyint Strategy() conststrategyDefinition MinimizerOptions.h:183; ROOT::Math::MinimizerOptions::Tolerancedouble Tolerance() constabsolute toleranceDefinition MinimizerOptions.h:186; ROOT::Math::MinimizerOptions::Precisiondouble Precision() constprecision in the objective function calculation (value <=0 means left to default)Definition Min",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8h_source.html:17553,interface,interface,17553,doc/master/Minimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8h_source.html,1,['interface'],['interface']
Integrability," 3795 Printf("" SET INPut [unitno] [filename]"");; 3796 Printf("" Causes Minuit, in data-driven mode only, to read subsequent"");; 3797 Printf("" commands (or parameter definitions) from a different input"");; 3798 Printf("" file. If no [unitno] is specified, reading reverts to the"");; 3799 Printf("" previous input file, assuming that there was one."");; 3800 Printf("" If [unitno] is specified, and that unit has not been opened,"");; 3801 Printf("" then Minuit attempts to open the file [filename]} if a"");; 3802 Printf("" name is specified. If running in interactive mode and"");; 3803 Printf("" [filename] is not specified and [unitno] is not opened,"");; 3804 Printf("" Minuit prompts the user to enter a file name."");; 3805 Printf("" If the word REWIND is added to the command (note:no blanks"");; 3806 Printf("" between INPUT and REWIND), the file is rewound before"");; 3807 Printf("" reading. Note that this command is implemented in standard"");; 3808 Printf("" Fortran 77 and the results may depend on the system;"");; 3809 Printf("" for example, if a filename is given under VM/CMS, it must"");; 3810 Printf("" be preceded by a slash."");; 3811 ; 3812 Printf("" "");; 3813 Printf("" SET INTeractive"");; 3814 Printf("" Informs Minuit that it is running interactively."");; 3815 ; 3816 Printf("" "");; 3817 Printf("" SET LIMits [parno] [lolim] [uplim]"");; 3818 Printf("" Allows the user to change the limits on one or all"");; 3819 Printf("" parameters. If no arguments are specified, all limits are"");; 3820 Printf("" removed from all parameters. If [parno] alone is specified,"");; 3821 Printf("" limits are removed from parameter [parno]."");; 3822 Printf("" If all arguments are specified, then parameter [parno] will"");; 3823 Printf("" be bounded between [lolim] and [uplim]."");; 3824 Printf("" Limits can be specified in either order, Minuit will take"");; 3825 Printf("" the smaller as [lolim] and the larger as [uplim]."");; 3826 Printf("" However, if [lolim] is equal to [uplim], an error condition"");; 3827 Printf("" results."");; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:126838,depend,depend,126838,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['depend'],['depend']
Integrability, 3D attributes; TAttAxis Axis attributes; TAttBBox Helper for management of bounding-box information; TAttCanvas Canvas attributes; TAttFill Fill area attributes; TAttFillEditor GUI for editing fill attributes; TAttImage Image attributes; TAttLine Line attributes; TAttLineEditor GUI for editing line attributes; TAttMarker Marker attributes; TAttMarkerEditor GUI for editing marker attributes; TAttPad Pad attributes; TAttParticle Particle definition; TAttText Text attributes; TAttTextEditor GUI for editing text attributes; TAuthenticate Class providing remote authentication service; TAxis Axis class; TAxis3D 3-D ruler painting class; TAxisEditor axis editor; TBRIK TBRIK shape; TBackCompFitter Class providing backward compatibility for fitting by implementing the TVirtualFitter interface; TBase64 Base64 encoding/decoding; TBaseClass Description of a base class; TBasket the TBranch buffers; TBasketSQL the TBranch buffers; TBenchmark ROOT utility to help benchmarking applications; TBinomialEfficiencyFitter Binomial Fitter for the division of two histograms; TBits Bit container; TBits::TReference ; TBonjourBrowser Browse hosts for specific bonjour service type; TBonjourRecord Bonjour information record; TBonjourRegistrar Register Bonjour service; TBonjourResolver Resolve Bonjour to actual IP address and port; TBox Box class; TBranch Branch descriptor; TBranchClones Branch in case of an array of clone objects; TBranchElement Branch in case of an object; TBranchObject Branch in case of an object; TBranchRef to support referenced objects on other branches; TBranchSTL Branch handling STL collection of pointers; TBrowser ROOT Object Browser; TBrowserImp ABC describing browser implementation protocol; TBrowserPlugin basic plugin description class; TBtree A B-tree; TBtreeIter B-tree iterator; TBuffer Buffer base class used for serializing objects; TBuffer3D 3D primitives description; TBufferFile concrete implementation of TBuffer for writing/reading to/from a ROOT file or socket.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:52703,protocol,protocol,52703,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,2,['protocol'],['protocol']
Integrability," 4092 ; 4093void TSystem::SetMakeExe(const char *directives); 4094{; 4095 fMakeExe = directives;; 4096 // NOTE: add verification that the directives has the required variables; 4097}; 4098 ; 4099////////////////////////////////////////////////////////////////////////////////; 4100/// Directives should contain the description on how to compile and link a; 4101/// shared lib. This description can be any valid shell command, including; 4102/// the use of ';' to separate several instructions. However, shell specific; 4103/// construct should be avoided. In particular this description can contain; 4104/// environment variables, like $ROOTSYS (or %ROOTSYS% on windows).; 4105/// ~~~ {.cpp}; 4106/// Five special variables will be expanded before execution:; 4107/// Variable name Expands to; 4108/// ------------- ----------; 4109/// $SourceFiles Name of source files to be compiled; 4110/// $SharedLib Name of the shared library being created; 4111/// $LibName Name of shared library without extension; 4112/// $BuildDir Directory where the files will be created; 4113/// $IncludePath value of fIncludePath; 4114/// $LinkedLibs value of fLinkedLibs; 4115/// $DepLibs libraries on which this library depends on; 4116/// $ObjectFiles Name of source files to be compiler with; 4117/// their extension changed to .o or .obj; 4118/// $Opt location of the optimization/debug options; 4119/// set fFlagsDebug and fFlagsOpt; 4120/// ~~~; 4121/// e.g.:; 4122/// ~~~ {.cpp}; 4123/// gSystem->SetMakeSharedLib(; 4124/// ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; 4125/// --no_exceptions --signed_chars --display_error_number; 4126/// --diag_suppress 68 -o $SharedLib"");; 4127///; 4128/// gSystem->setMakeSharedLib(; 4129/// ""Cxx $IncludePath -c $SourceFile;; 4130/// ld -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved; 4131/// \$Opt -shared /usr/lib/cmplrs/cc/crt0.o /usr/lib/cmplrs/cxx/_main.o; 4132/// -o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc""; 4133///; 4134",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:140703,depend,depends,140703,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['depend'],['depends']
Integrability," 40; // fall through; 812 case 5: k1 ^= uint64_t(tail[ 4]) << 32; // fall through; 813 case 4: k1 ^= uint64_t(tail[ 3]) << 24; // fall through; 814 case 3: k1 ^= uint64_t(tail[ 2]) << 16; // fall through; 815 case 2: k1 ^= uint64_t(tail[ 1]) << 8; // fall through; 816 case 1: k1 ^= uint64_t(tail[ 0]) << 0;; 817 k1 *= c1; k1 = ROTL64(k1,31); k1 *= c2; h1 ^= k1;; 818 };; 819 ; 820 //----------; 821 // finalization; 822 ; 823 h1 ^= len; h2 ^= len;; 824 ; 825 h1 += h2;; 826 h2 += h1;; 827 ; 828 h1 = fmix(h1);; 829 h2 = fmix(h2);; 830 ; 831 h1 += h2;; 832 h2 += h1;; 833 ; 834 ((uint64_t*)out)[0] = h1;; 835 ((uint64_t*)out)[1] = h2;; 836 }; 837 ; 838}; 839 ; 840////////////////////////////////////////////////////////////////////////////////; 841/// Calculates hash index from any char string. (static function); 842/// - For string: i = TString::Hash(string,nstring);; 843/// - For int: i = TString::Hash(&intword,sizeof(int));; 844/// - For pointer: i = TString::Hash(&pointer,sizeof(void*));; 845///; 846/// This employs two different hash functions, depending on ntxt:; 847/// - ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; 848/// - else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/; 849 ; 850UInt_t TString::Hash(const void *txt, Int_t ntxt); 851{; 852 if (ntxt != sizeof(void*)) {; 853 uint64_t buf[2] = {0};; 854 MurmurHash3_x64_128(txt, ntxt, 0x6384BA69, buf);; 855 return (UInt_t) buf[0];; 856 } else {; 857 // simple, superfast hash for pointers and alike; 858 UInt_t ret = (UInt_t)0x6384BA69;; 859 // aligned?; 860 if (((size_t)txt) % sizeof(void*)) {; 861 UInt_t* itxt = (UInt_t*)txt;; 862 ret ^= itxt[0];; 863 if (sizeof(void*) > sizeof(UInt_t)) {; 864 ret ^= itxt[1];; 865 }; 866 } else {; 867 const unsigned char* ctxt = (const unsigned char*) txt;; 868 for (unsigned int i = 0; i < 4; ++i) {; 869 ret ^= ctxt[i] << (i * 8);; 870 }; 871 if (sizeof(void*) > sizeof(UInt_t)) {; 872 ctxt += 4;; 873 for (unsigned int i = 0; i < 4; ++i) {; 874 ret ^",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:25537,depend,depending,25537,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['depend'],['depending']
Integrability," 426, ""%s"", ""Protocol upgrade required"");; 13053 return;; 13054 }; 13055 ; 13056 /* Step 1.3: Could check for ""Host"", but we do not really nead this; 13057 * value for anything, so just ignore it. */; 13058 ; 13059 /* Step 2: If a callback is responsible, call it. */; 13060 if (is_callback_resource) {; 13061 /* Step 2.1 check and select subprotocol */; 13062 const char *protocols[64]; // max 64 headers; 13063 int nbSubprotocolHeader = get_req_headers(&conn->request_info,; 13064 ""Sec-WebSocket-Protocol"",; 13065 protocols,; 13066 64);; 13067 if ((nbSubprotocolHeader > 0) && subprotocols) {; 13068 int cnt = 0;; 13069 int idx;; 13070 unsigned long len;; 13071 const char *sep, *curSubProtocol,; 13072 *acceptedWebSocketSubprotocol = NULL;; 13073 ; 13074 ; 13075 /* look for matching subprotocol */; 13076 do {; 13077 const char *protocol = protocols[cnt];; 13078 ; 13079 do {; 13080 sep = strchr(protocol, ',');; 13081 curSubProtocol = protocol;; 13082 len = sep ? (unsigned long)(sep - protocol); 13083 : (unsigned long)strlen(protocol);; 13084 while (sep && isspace((unsigned char)*++sep)); 13085 ; // ignore leading whitespaces; 13086 protocol = sep;; 13087 ; 13088 for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {; 13089 if ((strlen(subprotocols->subprotocols[idx]) == len); 13090 && (strncmp(curSubProtocol,; 13091 subprotocols->subprotocols[idx],; 13092 len); 13093 == 0)) {; 13094 acceptedWebSocketSubprotocol =; 13095 subprotocols->subprotocols[idx];; 13096 break;; 13097 }; 13098 }; 13099 } while (sep && !acceptedWebSocketSubprotocol);; 13100 } while (++cnt < nbSubprotocolHeader; 13101 && !acceptedWebSocketSubprotocol);; 13102 ; 13103 conn->request_info.acceptedWebSocketSubprotocol =; 13104 acceptedWebSocketSubprotocol;; 13105 ; 13106 } else if (nbSubprotocolHeader > 0) {; 13107 /* keep legacy behavior */; 13108 const char *protocol = protocols[0];; 13109 ; 13110 /* The protocol is a comma separated list of names. */; 13111 /* The server must only return one value fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:380742,protocol,protocols,380742,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,9,['protocol'],"['protocol', 'protocols']"
Integrability," 426, ""%s"", ""Protocol upgrade required"");; 13054 return;; 13055 }; 13056 ; 13057 /* Step 1.3: Could check for ""Host"", but we do not really nead this; 13058 * value for anything, so just ignore it. */; 13059 ; 13060 /* Step 2: If a callback is responsible, call it. */; 13061 if (is_callback_resource) {; 13062 /* Step 2.1 check and select subprotocol */; 13063 const char *protocols[64]; // max 64 headers; 13064 int nbSubprotocolHeader = get_req_headers(&conn->request_info,; 13065 ""Sec-WebSocket-Protocol"",; 13066 protocols,; 13067 64);; 13068 if ((nbSubprotocolHeader > 0) && subprotocols) {; 13069 int cnt = 0;; 13070 int idx;; 13071 unsigned long len;; 13072 const char *sep, *curSubProtocol,; 13073 *acceptedWebSocketSubprotocol = NULL;; 13074 ; 13075 ; 13076 /* look for matching subprotocol */; 13077 do {; 13078 const char *protocol = protocols[cnt];; 13079 ; 13080 do {; 13081 sep = strchr(protocol, ',');; 13082 curSubProtocol = protocol;; 13083 len = sep ? (unsigned long)(sep - protocol); 13084 : (unsigned long)strlen(protocol);; 13085 while (sep && isspace((unsigned char)*++sep)); 13086 ; // ignore leading whitespaces; 13087 protocol = sep;; 13088 ; 13089 for (idx = 0; idx < subprotocols->nb_subprotocols; idx++) {; 13090 if ((strlen(subprotocols->subprotocols[idx]) == len); 13091 && (strncmp(curSubProtocol,; 13092 subprotocols->subprotocols[idx],; 13093 len); 13094 == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:380775,protocol,protocols,380775,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,9,['protocol'],"['protocol', 'protocols']"
Integrability," 429//_____________________________________________________________________________; 430bool TGeoMaterial::AddConstProperty(const char *property, const char *ref); 431{; 432 fConstProperties.SetOwner();; 433 if (GetConstPropertyRef(property)) {; 434 Error(""AddConstProperty"", ""Constant property %s already added to material %s"", property, GetName());; 435 return false;; 436 }; 437 fConstProperties.Add(new TNamed(property, ref));; 438 return true;; 439}; 440 ; 441////////////////////////////////////////////////////////////////////////////////; 442/// Connect framework defined extension to the material. The material ""grabs"" a copy,; 443/// so the original object can be released by the producer. Release the previously; 444/// connected extension if any.; 445///; 446/// NOTE: This interface is intended for the use by TGeo and the users should; 447/// NOT connect extensions using this method; 448 ; 449void TGeoMaterial::SetFWExtension(TGeoExtension *ext); 450{; 451 if (fFWExtension); 452 fFWExtension->Release();; 453 fFWExtension = nullptr;; 454 if (ext); 455 fFWExtension = ext->Grab();; 456}; 457 ; 458////////////////////////////////////////////////////////////////////////////////; 459/// Get a copy of the user extension pointer. The user must call Release() on; 460/// the copy pointer once this pointer is not needed anymore (equivalent to; 461/// delete() after calling new()); 462 ; 463TGeoExtension *TGeoMaterial::GrabUserExtension() const; 464{; 465 if (fUserExtension); 466 return fUserExtension->Grab();; 467 return nullptr;; 468}; 469 ; 470////////////////////////////////////////////////////////////////////////////////; 471/// Get a copy of the framework extension pointer. The user must call Release() on; 472/// the copy pointer once this pointer is not needed anymore (equivalent to; 473/// delete() after calling new()); 474 ; 475TGeoExtension *TGeoMaterial::GrabFWExtension() const; 476{; 477 if (fFWExtension); 478 return fFWExtension->Grab();; 479 return nullptr;; 480}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html:14482,interface,interface,14482,doc/master/TGeoMaterial_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8cxx_source.html,1,['interface'],['interface']
Integrability," 430 }; 431 return _civet_clock_gettime(clk_id, t);; 432}; 433#define clock_gettime _civet_safe_clock_gettime; 434#else; 435#define clock_gettime _civet_clock_gettime; 436#endif; 437 ; 438#endif; 439 ; 440 ; 441#if !defined(_WIN32); 442/* Unix might return different error codes indicating to try again.; 443 * For Linux EAGAIN==EWOULDBLOCK, maybe EAGAIN!=EWOULDBLOCK is history from; 444 * decades ago, but better check both and let the compile optimize it. */; 445#define ERROR_TRY_AGAIN(err) \; 446 (((err) == EAGAIN) || ((err) == EWOULDBLOCK) || ((err) == EINTR)); 447#endif; 448 ; 449#if defined(USE_ZLIB); 450#include ""zconf.h""; 451#include ""zlib.h""; 452#endif; 453 ; 454 ; 455/********************************************************************/; 456/* CivetWeb configuration defines */; 457/********************************************************************/; 458 ; 459/* Maximum number of threads that can be configured.; 460 * The number of threads actually created depends on the ""num_threads""; 461 * configuration parameter, but this is the upper limit. */; 462#if !defined(MAX_WORKER_THREADS); 463#define MAX_WORKER_THREADS (1024 * 64) /* in threads (count) */; 464#endif; 465 ; 466/* Timeout interval for select/poll calls.; 467 * The timeouts depend on ""*_timeout_ms"" configuration values, but long; 468 * timeouts are split into timouts as small as SOCKET_TIMEOUT_QUANTUM.; 469 * This reduces the time required to stop the server. */; 470#if !defined(SOCKET_TIMEOUT_QUANTUM); 471#define SOCKET_TIMEOUT_QUANTUM (2000) /* in ms */; 472#endif; 473 ; 474/* Do not try to compress files smaller than this limit. */; 475#if !defined(MG_FILE_COMPRESSION_SIZE_LIMIT); 476#define MG_FILE_COMPRESSION_SIZE_LIMIT (1024) /* in bytes */; 477#endif; 478 ; 479#if !defined(PASSWORDS_FILE_NAME); 480#define PASSWORDS_FILE_NAME "".htpasswd""; 481#endif; 482 ; 483/* Initial buffer size for all CGI environment variables. In case there is; 484 * not enough space, another block is allocated. */; 485#i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:16236,depend,depends,16236,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['depend'],['depends']
Integrability," 47 of file TClassRef.cxx. ◆ TClassRef() [3/4]. TClassRef::TClassRef ; (; const char * ; classname). Create reference to specified class name, but don't set referenced class object. ; Definition at line 39 of file TClassRef.cxx. ◆ TClassRef() [4/4]. TClassRef::TClassRef ; (; const TClassRef & ; org). Copy ctor, increases reference count to original TClass object. ; Definition at line 30 of file TClassRef.cxx. ◆ ~TClassRef(). TClassRef::~TClassRef ; (; ). inline . Definition at line 59 of file TClassRef.h. Member Function Documentation. ◆ Assign() [1/2]. void TClassRef::Assign ; (; const TClassRef & ; rhs). private . Assignment operator implementation, increases reference count to original class object. ; This routines assumes that the copy actually need to be done. ; Definition at line 59 of file TClassRef.cxx. ◆ Assign() [2/2]. void TClassRef::Assign ; (; TClass * ; rhs). private . Assignment operator, increases reference count to original class object. ; This routines assumes that the copy actually need to be done. ; Definition at line 69 of file TClassRef.cxx. ◆ GetClass(). TClass * TClassRef::GetClass ; (; ); const. inline . Definition at line 66 of file TClassRef.h. ◆ GetClassName(). const char * TClassRef::GetClassName ; (; ). inline . Definition at line 65 of file TClassRef.h. ◆ InternalGetClass(). TClass * TClassRef::InternalGetClass ; (; ); const. private . Return the current TClass object corresponding to fClassName. ; Definition at line 83 of file TClassRef.cxx. ◆ operator TClass *(). TClassRef::operator TClass * ; (; ); const. inline . Definition at line 70 of file TClassRef.h. ◆ operator->(). TClass * TClassRef::operator-> ; (; ); const. inline . Definition at line 69 of file TClassRef.h. ◆ operator=() [1/2]. TClassRef & TClassRef::operator= ; (; const TClassRef & ; rhs). inline . Definition at line 44 of file TClassRef.h. ◆ operator=() [2/2]. TClassRef & TClassRef::operator= ; (; TClass * ; rhs). inline . Definition at line 51 of file TClassRef.h. ◆ Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassRef.html:3249,rout,routines,3249,doc/master/classTClassRef.html,https://root.cern,https://root.cern/doc/master/classTClassRef.html,1,['rout'],['routines']
Integrability," 478 Float_t y = gPad->AbsPixeltoY(py);; 479 snprintf(info,64,""x=%g, y=%g"",gPad->PadtoX(x),gPad->PadtoY(y));; 480 return info;; 481}; 482 ; 483////////////////////////////////////////////////////////////////////////////////; 484/// Returns title of object. This default method returns the class title; 485/// (i.e. description). Classes that give objects a title should override; 486/// this method.; 487 ; 488const char *TObject::GetTitle() const; 489{; 490 return IsA()->GetTitle();; 491}; 492 ; 493 ; 494////////////////////////////////////////////////////////////////////////////////; 495/// Execute action in response of a timer timing out. This method; 496/// must be overridden if an object has to react to timers.; 497 ; 498Bool_t TObject::HandleTimer(TTimer *); 499{; 500 return kFALSE;; 501}; 502 ; 503////////////////////////////////////////////////////////////////////////////////; 504/// Return hash value for this object.; 505///; 506/// Note: If this routine is overloaded in a derived class, this derived class; 507/// should also add; 508/// ~~~ {.cpp}; 509/// ROOT::CallRecursiveRemoveIfNeeded(*this); 510/// ~~~; 511/// Otherwise, when RecursiveRemove is called (by ~TObject or example) for this; 512/// type of object, the transversal of THashList and THashTable containers will; 513/// will have to be done without call Hash (and hence be linear rather than; 514/// logarithmic complexity). You will also see warnings like; 515/// ~~~; 516/// Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; 517/// ~~~; 518///; 519 ; 520ULong_t TObject::Hash() const; 521{; 522 //return (ULong_t) this >> 2;; 523 const void *ptr = this;; 524 return TString::Hash(&ptr, sizeof(void*));; 525}; 526 ; 527////////////////////////////////////////////////////////////////////////////////; 528/// Returns kTRUE if object inherits from class ""classname"".; 529 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:17617,rout,routine,17617,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['rout'],['routine']
Integrability," 4780void TBranchElement::ResetAddress(); 4781{; 4782 for (Int_t i = 0; i < fNleaves; ++i) {; 4783 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 4784 //if (leaf) leaf->SetAddress(0);; 4785 leaf->SetAddress(nullptr);; 4786 }; 4787 ; 4788 // Note: We *must* do the sub-branches first, otherwise; 4789 // we may delete the object containing the sub-branches; 4790 // before giving them a chance to cleanup.; 4791 Int_t nbranches = fBranches.GetEntriesFast();; 4792 for (Int_t i = 0; i < nbranches; ++i) {; 4793 TBranch* br = (TBranch*) fBranches[i];; 4794 if (br) br->ResetAddress();; 4795 }; 4796 ; 4797 //; 4798 // SetAddress may have allocated an object.; 4799 //; 4800 ; 4801 ReleaseObject();; 4802 ; 4803 ResetBit(kAddressSet);; 4804 fAddress = nullptr;; 4805 fObject = nullptr;; 4806}; 4807 ; 4808////////////////////////////////////////////////////////////////////////////////; 4809/// Release ownership of any allocated objects.; 4810///; 4811/// Note: This interface was added so that clone trees could; 4812/// be told they do not own the allocated objects.; 4813 ; 4814void TBranchElement::ResetDeleteObject(); 4815{; 4816 ResetBit(kDeleteObject);; 4817 Int_t nb = fBranches.GetEntriesFast();; 4818 for (Int_t i = 0; i < nb; ++i) {; 4819 TBranch* br = (TBranch*) fBranches[i];; 4820 if (br->InheritsFrom(TBranchElement::Class())) {; 4821 ((TBranchElement*) br)->ResetDeleteObject();; 4822 }; 4823 }; 4824}; 4825 ; 4826////////////////////////////////////////////////////////////////////////////////; 4827/// \brief Reset offset and StreamerInfo information from this branch.; 4828/// \param[in] recurse When true call ResetInitInfo on all subbranches.; 4829///; 4830 ; 4831void TBranchElement::ResetInitInfo(bool recurse); 4832{; 4833 fInfo = nullptr;; 4834 fInit = false;; 4835 fInitOffsets = false;; 4836 fCurrentClass = nullptr;; 4837 delete fReadActionSequence;; 4838 fReadActionSequence = nullptr;; 4839 delete fFillActionSequence;; 4840 fFillActionSequence = nullptr;; 4841 ; 4842 if (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:178046,interface,interface,178046,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['interface'],['interface']
Integrability," 49 ; 50 The sampling is provided via these methods:; 51 - TUnuran::Sample() returns a double for all one-dimensional distribution; 52 - TUnuran::SampleDiscr() returns an integer for one-dimensional discrete distribution; 53 - TUnuran::Sample(double *) sample a multi-dimensional distribution. A pointer to a vector with; 54 size at least equal to the distribution dimension must be passed; 55 ; 56 In addition is possible to set the random number generator in the constructor of the class, its seed; 57 via the TUnuran::SetSeed() method.; 58*/; 59 ; 60 ; 61 ; 62//class TUnuranGenerator;; 63struct unur_gen;; 64typedef struct unur_gen UNUR_GEN;; 65 ; 66// struct unur_urng_generic;; 67// typedef struct unur_urng_generic UNUR_URNG;; 68 ; 69struct unur_distr;; 70typedef struct unur_distr UNUR_DISTR;; 71 ; 72struct unur_urng;; 73typedef struct unur_urng UNUR_URNG;; 74 ; 75 ; 76class TRandom;; 77class TH1;; 78 ; 79class TUnuran {; 80 ; 81public:; 82 ; 83 /**; 84 Constructor with a generator instance and given level of log output; 85 */; 86 TUnuran (TRandom * r = nullptr, unsigned int log = 0);; 87 ; 88 ; 89 /**; 90 Destructor; 91 */; 92 ~TUnuran ();; 93 ; 94 // usually copying is non trivial, so we delete this; 95 TUnuran(const TUnuran &) = delete;; 96 TUnuran & operator = (const TUnuran & rhs) = delete;; 97 TUnuran(TUnuran &&) = delete;; 98 TUnuran & operator = (TUnuran && rhs) = delete;; 99 ; 100 /**; 101 Initialize with Unuran string API interface.; 102 See https://statmath.wu.ac.at/unuran/doc/unuran.html#StringAPI; 103 ; 104 @param distr : UNU.RAN distribution string; 105 @param method : UNU.RAN method string; 106 ; 107 Here is an example using the string API:; 108 ```; 109 Tunuran unr;; 110 unr.Init(""normal(3.,0.75); domain = (0,inf)"", ""method = tdr; c = 0"");; 111 ```; 112 */; 113 bool Init(const std::string & distr, const std::string & method);; 114 ; 115 ; 116 /**; 117 Initialize method for continuous one-dimensional distribution.; 118 User must provide a distribution obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnuran_8h_source.html:3329,interface,interface,3329,doc/master/TUnuran_8h_source.html,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html,1,['interface'],['interface']
Integrability," 4924 return (void*)((Longptr_t)obj+off);; 4925 else; 4926 return (void*)((Longptr_t)obj-off);; 4927 }; 4928 return nullptr;; 4929}; 4930 ; 4931////////////////////////////////////////////////////////////////////////////////; 4932/// Cast obj of this class type up to baseclass cl if up is true.; 4933/// Cast obj of this class type down from baseclass cl if up is false.; 4934/// If this class is not a baseclass of cl return 0, else the pointer; 4935/// to the cl part of this (up) or to this (down).; 4936 ; 4937const void *TClass::DynamicCast(const TClass *cl, const void *obj, Bool_t up); 4938{; 4939 return DynamicCast(cl,const_cast<void*>(obj),up);; 4940}; 4941 ; 4942////////////////////////////////////////////////////////////////////////////////; 4943/// Return a pointer to a newly allocated object of this class.; 4944/// The class must have a default constructor. For meaning of; 4945/// defConstructor, see TClass::IsCallingNew().; 4946///; 4947/// If quiet is true, do no issue a message via Error on case; 4948/// of problems, just return 0.; 4949///; 4950/// The constructor actually called here can be customized by; 4951/// using the rootcint pragma:; 4952/// ~~~ {.cpp}; 4953/// #pragma link C++ ioctortype UserClass;; 4954/// ~~~; 4955/// For example, with this pragma and a class named MyClass,; 4956/// this method will called the first of the following 3; 4957/// constructors which exists and is public:; 4958/// ~~~ {.cpp}; 4959/// MyClass(UserClass*);; 4960/// MyClass(TRootIOCtor*);; 4961/// MyClass(); // Or a constructor with all its arguments defaulted.; 4962/// ~~~; 4963///; 4964/// When more than one pragma ioctortype is used, the first seen as priority; 4965/// For example with:; 4966/// ~~~ {.cpp}; 4967/// #pragma link C++ ioctortype UserClass1;; 4968/// #pragma link C++ ioctortype UserClass2;; 4969/// ~~~; 4970/// We look in the following order:; 4971/// ~~~ {.cpp}; 4972/// MyClass(UserClass1*);; 4973/// MyClass(UserClass2*);; 4974/// MyClass(TRootIOCtor*);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:188611,message,message,188611,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['message'],['message']
Integrability," 4991 return (void*)((Longptr_t)obj+off);; 4992 else; 4993 return (void*)((Longptr_t)obj-off);; 4994 }; 4995 return nullptr;; 4996}; 4997 ; 4998////////////////////////////////////////////////////////////////////////////////; 4999/// Cast obj of this class type up to baseclass cl if up is true.; 5000/// Cast obj of this class type down from baseclass cl if up is false.; 5001/// If this class is not a baseclass of cl return 0, else the pointer; 5002/// to the cl part of this (up) or to this (down).; 5003 ; 5004const void *TClass::DynamicCast(const TClass *cl, const void *obj, Bool_t up); 5005{; 5006 return DynamicCast(cl,const_cast<void*>(obj),up);; 5007}; 5008 ; 5009////////////////////////////////////////////////////////////////////////////////; 5010/// Return a pointer to a newly allocated object of this class.; 5011/// The class must have a default constructor. For meaning of; 5012/// defConstructor, see TClass::IsCallingNew().; 5013///; 5014/// If quiet is true, do no issue a message via Error on case; 5015/// of problems, just return 0.; 5016///; 5017/// The constructor actually called here can be customized by; 5018/// using the rootcint pragma:; 5019/// ~~~ {.cpp}; 5020/// #pragma link C++ ioctortype UserClass;; 5021/// ~~~; 5022/// For example, with this pragma and a class named MyClass,; 5023/// this method will called the first of the following 3; 5024/// constructors which exists and is public:; 5025/// ~~~ {.cpp}; 5026/// MyClass(UserClass*);; 5027/// MyClass(TRootIOCtor*);; 5028/// MyClass(); // Or a constructor with all its arguments defaulted.; 5029/// ~~~; 5030///; 5031/// When more than one pragma ioctortype is used, the first seen as priority; 5032/// For example with:; 5033/// ~~~ {.cpp}; 5034/// #pragma link C++ ioctortype UserClass1;; 5035/// #pragma link C++ ioctortype UserClass2;; 5036/// ~~~; 5037/// We look in the following order:; 5038/// ~~~ {.cpp}; 5039/// MyClass(UserClass1*);; 5040/// MyClass(UserClass2*);; 5041/// MyClass(TRootIOCtor*);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:191362,message,message,191362,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['message'],['message']
Integrability," 5*v2;; if (v1==v2) {...}; if (v1!=v2) {...}. Related Vectors; v2 = v1.Unit(); // get unit vector parallel to v1; v2 = v1.Orthogonal(); // get vector orthogonal to v1. Scalar and vector products; s = v1.Dot(v2); // scalar product; s = v1 * v2; // scalar product; v = v1.Cross(v2); // vector product. Angle between two vectors; Double_t a = v1.Angle(v2);; a#define a(i)Definition RSha256.hxx:99. Rotations; Rotation around axes; v.RotateX(.5);; v.RotateY(TMath::Pi());; v.RotateZ(angle);; angleOption_t Option_t TPoint TPoint angleDefinition TGWin32VirtualXProxy.cxx:68; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; Rotation around a vector; v1.Rotate(TMath::Pi()/4, v2); // rotation around v2; Rotation by TRotation; TVector3 objects can be rotated by objects of the TRotation class using the Transform() member functions,; the operator *= or the operator * of the TRotation class:; TRotation m;; ...; v1.transform(m);; v1 = m*v1;; v1 *= m; // Attention v1 = m*v1; TRotation<div class=""legacybox""><h2>Legacy Code</h2> TRotation is a legacy interface: there will be no bug fix...Definition TRotation.h:20; Transformation from rotated frame; TVector3 direction = v.Unit(); v1.RotateUz(direction); // direction must be TVector3 of unit length; TVector3::UnitTVector3 Unit() constReturn unit vector parallel to this.Definition TVector3.cxx:252; TVector3::RotateUzvoid RotateUz(const TVector3 &)NewUzVector must be normalized !Definition TVector3.cxx:305; transforms v1 from the rotated frame (z' parallel to direction, x' in the theta plane and y' in the xy plane as well as perpendicular to the theta plane) to the (x,y,z) frame. ; Definition at line 22 of file TVector3.h. Public Types; typedef Double_t Scalar;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVector3.html:4184,interface,interface,4184,doc/master/classTVector3.html,https://root.cern,https://root.cern/doc/master/classTVector3.html,1,['interface'],['interface']
Integrability," 50 rows are shown before TTree::Scan pauses and ask you to press the Enter key to see the next 50 rows. You can change the default number of rows to be shown before <CR> via mytree->SetScanfield(maxrows) where maxrows is 50 by default. If maxrows is set to 0 all rows of the Tree are shown. This option is interesting when dumping the contents of a Tree to an ascii file, eg from the command line:; root[] tree->SetScanField(0);; root[] tree->Scan(""*""); >tree.log; will create a file tree.log.; Arrays (within an entry) are printed in their linear forms. If several arrays with multiple dimensions are printed together, they will NOT be synchronized. For example, with a tree containing arr1[4][2]and arr2[2][3],; root[] MyTree(""arr1:arr2"");; will results in a printing similar to:; ************************************************; * Row * Instance * arr1 * arr2 *; ***********************************************; * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *; However, if there is a selection criterium which is an array, then all the formulas will be synchronized with the selection criterium (see TTree::Draw for more information).; The third parameter of TTree::Scan can be use to specific the layout of the table:. lenmax=dd - where ‘dd’ is the maximum number of elements per array that should be printed. If ‘dd’ is 0, all elements are printed (this is the default).; colsize=ss - where ‘ss’ will be used as the default size for all the column. If this options is not specified, the default column size is 9.; precision=pp - where ‘pp’ will be used as the default ‘precision’ for the printing format.; col=xxx - where ‘xxx’ is colon (:) delimited list of printing format for each column if no format is specified for a column, the default is used. For example:; tree->Scan(""a:b:c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:620576,synchroniz,synchronized,620576,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['synchroniz'],['synchronized']
Integrability," 5001 ; 5002////////////////////////////////////////////////////////////////////////////////; 5003/// Return pointer to cling interface function for a method of a class with; 5004/// parameters params (params is a string of actual arguments, not formal; 5005/// ones). If the class is 0 the global function list will be searched.; 5006 ; 5007void* TCling::GetInterfaceMethod(TClass* cl, const char* method,; 5008 const char* params, Bool_t objectIsConst /* = kFALSE */); 5009{; 5010 R__LOCKGUARD(gInterpreterMutex);; 5011 TClingCallFunc func(GetInterpreterImpl());; 5012 if (cl) {; 5013 Longptr_t offset;; 5014 func.SetFunc((TClingClassInfo*)cl->GetClassInfo(), method, params, objectIsConst,; 5015 &offset);; 5016 }; 5017 else {; 5018 TClingClassInfo gcl(GetInterpreterImpl());; 5019 Longptr_t offset;; 5020 func.SetFunc(&gcl, method, params, &offset);; 5021 }; 5022 return (void*) func.InterfaceMethod();; 5023}; 5024 ; 5025////////////////////////////////////////////////////////////////////////////////; 5026/// Return pointer to cling interface function for a method of a class with; 5027/// a certain name.; 5028 ; 5029TInterpreter::DeclId_t TCling::GetFunction(ClassInfo_t *opaque_cl, const char* method); 5030{; 5031 R__LOCKGUARD(gInterpreterMutex);; 5032 DeclId_t f;; 5033 TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;; 5034 if (cl) {; 5035 f = cl->GetMethod(method).GetDeclId();; 5036 }; 5037 else {; 5038 TClingClassInfo gcl(GetInterpreterImpl());; 5039 f = gcl.GetMethod(method).GetDeclId();; 5040 }; 5041 return f;; 5042 ; 5043}; 5044 ; 5045////////////////////////////////////////////////////////////////////////////////; 5046/// Insert overloads of name in cl to res.; 5047 ; 5048void TCling::GetFunctionOverloads(ClassInfo_t *cl, const char *funcname,; 5049 std::vector<DeclId_t>& res) const; 5050{; 5051 clang::Sema& S = fInterpreter->getSema();; 5052 clang::ASTContext& Ctx = S.Context;; 5053 const clang::Decl* CtxDecl; 5054 = cl ? (const clang::Decl*)((TClingClassInfo*)cl)->",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:195442,interface,interface,195442,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['interface'],['interface']
Integrability," 5124 }; 5125 return f;; 5126}; 5127 ; 5128////////////////////////////////////////////////////////////////////////////////; 5129/// Return pointer to cling DeclId for a method of a class with; 5130/// a certain prototype, i.e. ""char*,int,float"". If the class is 0 the global; 5131/// function list will be searched.; 5132 ; 5133TInterpreter::DeclId_t TCling::GetFunctionWithValues(ClassInfo_t *opaque_cl, const char* method,; 5134 const char* params,; 5135 Bool_t objectIsConst /* = kFALSE */); 5136{; 5137 R__LOCKGUARD(gInterpreterMutex);; 5138 DeclId_t f;; 5139 TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;; 5140 if (cl) {; 5141 f = cl->GetMethodWithArgs(method, params, objectIsConst, nullptr /*poffset*/).GetDeclId();; 5142 }; 5143 else {; 5144 TClingClassInfo gcl(GetInterpreterImpl());; 5145 f = gcl.GetMethod(method, params, objectIsConst, nullptr /*poffset*/).GetDeclId();; 5146 }; 5147 return f;; 5148}; 5149 ; 5150////////////////////////////////////////////////////////////////////////////////; 5151/// Return pointer to cling interface function for a method of a class with; 5152/// a certain prototype, i.e. ""char*,int,float"". If the class is 0 the global; 5153/// function list will be searched.; 5154 ; 5155TInterpreter::DeclId_t TCling::GetFunctionWithPrototype(ClassInfo_t *opaque_cl, const char* method,; 5156 const char* proto,; 5157 Bool_t objectIsConst /* = kFALSE */,; 5158 EFunctionMatchMode mode /* = kConversionMatch */); 5159{; 5160 R__LOCKGUARD(gInterpreterMutex);; 5161 DeclId_t f;; 5162 TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;; 5163 if (cl) {; 5164 f = cl->GetMethod(method, proto, objectIsConst, nullptr /*poffset*/, mode).GetDeclId();; 5165 }; 5166 else {; 5167 TClingClassInfo gcl(GetInterpreterImpl());; 5168 f = gcl.GetMethod(method, proto, objectIsConst, nullptr /*poffset*/, mode).GetDeclId();; 5169 }; 5170 return f;; 5171}; 5172 ; 5173////////////////////////////////////////////////////////////////////////////////; 5174/// Return pointer to c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:200407,interface,interface,200407,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['interface'],['interface']
Integrability," 566 of file TUDPSocket.cxx. ◆ SendProcessIDs(). void TUDPSocket::SendProcessIDs ; (; const TMessage & ; mess). protected . Check if TProcessIDs must be sent. ; The list of TProcessIDs in the object in the message is found by looking in the TMessage bits. We send only the TProcessIDs not yet send on this socket. ; Definition at line 651 of file TUDPSocket.cxx. ◆ SendRaw(). Int_t TUDPSocket::SendRaw ; (; const void * ; buffer, . Int_t ; length, . ESendRecvOptions ; opt = kDefault . ). virtual . Send a raw buffer of specified length. ; Using option kOob one can send OOB data. Returns the number of bytes sent or -1 in case of error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Definition at line 586 of file TUDPSocket.cxx. ◆ SendStreamerInfos(). void TUDPSocket::SendStreamerInfos ; (; const TMessage & ; mess). protected . Check if TStreamerInfo must be sent. ; The list of TStreamerInfo of classes in the object in the message is in the fInfos list of the message. We send only the TStreamerInfos not yet sent on this socket. ; Definition at line 616 of file TUDPSocket.cxx. ◆ SetCompressionAlgorithm(). void TUDPSocket::SetCompressionAlgorithm ; (; Int_t ; algorithm = ROOT::RCompressionSetting::EAlgorithm::kUseGlobal). See comments for function SetCompressionSettings. ; Definition at line 1016 of file TUDPSocket.cxx. ◆ SetCompressionLevel(). void TUDPSocket::SetCompressionLevel ; (; Int_t ; level = ROOT::RCompressionSetting::ELevel::kUseMin). See comments for function SetCompressionSettings. ; Definition at line 1031 of file TUDPSocket.cxx. ◆ SetCompressionSettings(). void TUDPSocket::SetCompressionSettings ; (; Int_t ; settings = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault). Used to specify the compression level and algorithm: settings = 100 * algorithm + level. ; level = 0, objects written to this file will not be compressed. level = 1, minimal compression level but fast. .... le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUDPSocket.html:32720,message,message,32720,doc/master/classTUDPSocket.html,https://root.cern,https://root.cern/doc/master/classTUDPSocket.html,2,['message'],['message']
Integrability," 5; : ; : Elapsed time for training with 14000 events: 11.9 sec ; : Evaluate deep neural network on CPU using batches with size = 128; : ; DNN_CPU : [dataset] : Evaluation of DNN_CPU on training sample (14000 events); : Elapsed time for evaluation of 14000 events: 0.247 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_DNN_CPU.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_Higgs_Classification_DNN_CPU.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyKeras for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ PyKeras ] :␛[0m; : ; : Keras is a high-level API for the Theano and Tensorflow packages.; : This method wraps the training and predictions steps of the Keras; : Python package for TMVA, so that dataloading, preprocessing and; : evaluation can be done within the TMVA system. To use this Keras; : interface, you have to generate a model with Keras first. Then,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 11200 training events and 2800 validation events; : Training Model Summary; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; dense (Dense) (None, 64) 512 ; ; dense_1 (Dense) (None, 64) 4160 ; ; dense_2 (Dense) (None, 64) 4160 ; ; dense_3 (Dense) (None, 64) 4160 ; ; dense_4 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 13122 (51.26 KB); Trainable params: 13122 (51.26 KB); Non-trainable params: 0 (0.00 Byte); _________________________________________________________________; : Option SaveBestOnly: Only model wei",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:26695,interface,interface,26695,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['interface'],['interface']
Integrability," 61 of file THtml.cxx. Member Function Documentation. ◆ Class(). static TClass * THtml::THelperBase::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * THtml::THelperBase::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t THtml::THelperBase::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 52 of file THtml.h. ◆ DeclFileName(). static const char * THtml::THelperBase::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 52 of file THtml.h. ◆ GetOwner(). THtml * THtml::THelperBase::GetOwner ; (; ); const. inline . Definition at line 49 of file THtml.h. ◆ IsA(). TClass * THtml::THelperBase::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in THtml::TModuleDefinition, and THtml::TPathDefinition.; Definition at line 52 of file THtml.h. ◆ SetOwner(). void THtml::THelperBase::SetOwner ; (; THtml * ; html). Set the THtml object owning this object; if it's already set to a different THtml object than issue an error message and signal to the currently set object that we are not belonging to it anymore. ; Definition at line 74 of file THtml.cxx. ◆ Streamer(). void THtml::THelperBase::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in THtml::TModuleDefinition, and THtml::TPathDefinition. ◆ StreamerNVirtual(). void THtml::THelperBase::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 52 of file THtml.h. Member Data Documentation. ◆ fHtml. THtml* THtml::THelperBase::fHtml. private . Definition at line 51 of file THtml.h. html/inc/THtml.h; html/src/THtml.cxx. THtmlTHelperBase. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHtml_1_1THelperBase.html:11832,message,message,11832,doc/master/classTHtml_1_1THelperBase.html,https://root.cern,https://root.cern/doc/master/classTHtml_1_1THelperBase.html,1,['message'],['message']
Integrability," 6809}; 6810 ; 6811 ; 6812#if defined(GCC_DIAGNOSTIC); 6813/* This block forwards format strings to printf implementations,; 6814 * so we need to disable the format-nonliteral warning. */; 6815#pragma GCC diagnostic push; 6816#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 6817#endif; 6818 ; 6819 ; 6820/* Alternative alloc_vprintf() for non-compliant C runtimes */; 6821static int; 6822alloc_vprintf2(char **buf, const char *fmt, va_list ap); 6823{; 6824 va_list ap_copy;; 6825 size_t size = MG_BUF_LEN / 4;; 6826 int len = -1;; 6827 ; 6828 *buf = NULL;; 6829 while (len < 0) {; 6830 if (*buf) {; 6831 mg_free(*buf);; 6832 }; 6833 ; 6834 size *= 4;; 6835 *buf = (char *)mg_malloc(size);; 6836 if (!*buf) {; 6837 break;; 6838 }; 6839 ; 6840 va_copy(ap_copy, ap);; 6841 len = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);; 6842 va_end(ap_copy);; 6843 (*buf)[size - 1] = 0;; 6844 }; 6845 ; 6846 return len;; 6847}; 6848 ; 6849 ; 6850/* Print message to buffer. If buffer is large enough to hold the message,; 6851 * return buffer. If buffer is to small, allocate large enough buffer on; 6852 * heap,; 6853 * and return allocated buffer. */; 6854static int; 6855alloc_vprintf(char **out_buf,; 6856 char *prealloc_buf,; 6857 size_t prealloc_size,; 6858 const char *fmt,; 6859 va_list ap); 6860{; 6861 va_list ap_copy;; 6862 int len;; 6863 ; 6864 /* Windows is not standard-compliant, and vsnprintf() returns -1 if; 6865 * buffer is too small. Also, older versions of msvcrt.dll do not have; 6866 * _vscprintf(). However, if size is 0, vsnprintf() behaves correctly.; 6867 * Therefore, we make two passes: on first pass, get required message; 6868 * length.; 6869 * On second pass, actually print the message. */; 6870 va_copy(ap_copy, ap);; 6871 len = vsnprintf_impl(NULL, 0, fmt, ap_copy);; 6872 va_end(ap_copy);; 6873 ; 6874 if (len < 0) {; 6875 /* C runtime is not standard compliant, vsnprintf() returned -1.; 6876 * Switch to alternative code path that uses incremental; 6877 * allocations.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:198090,message,message,198090,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['message'],['message']
Integrability," 6810}; 6811 ; 6812 ; 6813#if defined(GCC_DIAGNOSTIC); 6814/* This block forwards format strings to printf implementations,; 6815 * so we need to disable the format-nonliteral warning. */; 6816#pragma GCC diagnostic push; 6817#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 6818#endif; 6819 ; 6820 ; 6821/* Alternative alloc_vprintf() for non-compliant C runtimes */; 6822static int; 6823alloc_vprintf2(char **buf, const char *fmt, va_list ap); 6824{; 6825 va_list ap_copy;; 6826 size_t size = MG_BUF_LEN / 4;; 6827 int len = -1;; 6828 ; 6829 *buf = NULL;; 6830 while (len < 0) {; 6831 if (*buf) {; 6832 mg_free(*buf);; 6833 }; 6834 ; 6835 size *= 4;; 6836 *buf = (char *)mg_malloc(size);; 6837 if (!*buf) {; 6838 break;; 6839 }; 6840 ; 6841 va_copy(ap_copy, ap);; 6842 len = vsnprintf_impl(*buf, size - 1, fmt, ap_copy);; 6843 va_end(ap_copy);; 6844 (*buf)[size - 1] = 0;; 6845 }; 6846 ; 6847 return len;; 6848}; 6849 ; 6850 ; 6851/* Print message to buffer. If buffer is large enough to hold the message,; 6852 * return buffer. If buffer is to small, allocate large enough buffer on; 6853 * heap,; 6854 * and return allocated buffer. */; 6855static int; 6856alloc_vprintf(char **out_buf,; 6857 char *prealloc_buf,; 6858 size_t prealloc_size,; 6859 const char *fmt,; 6860 va_list ap); 6861{; 6862 va_list ap_copy;; 6863 int len;; 6864 ; 6865 /* Windows is not standard-compliant, and vsnprintf() returns -1 if; 6866 * buffer is too small. Also, older versions of msvcrt.dll do not have; 6867 * _vscprintf(). However, if size is 0, vsnprintf() behaves correctly.; 6868 * Therefore, we make two passes: on first pass, get required message; 6869 * length.; 6870 * On second pass, actually print the message. */; 6871 va_copy(ap_copy, ap);; 6872 len = vsnprintf_impl(NULL, 0, fmt, ap_copy);; 6873 va_end(ap_copy);; 6874 ; 6875 if (len < 0) {; 6876 /* C runtime is not standard compliant, vsnprintf() returned -1.; 6877 * Switch to alternative code path that uses incremental; 6878 * allocations.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:198122,message,message,198122,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['message'],['message']
Integrability," 690//==============================================================================; 691// operator<<; 692//==============================================================================; 693template <class T, unsigned int D1, unsigned int D2, class R>; 694inline std::ostream& operator<<(std::ostream& os, const ROOT::Math::SMatrix<T,D1,D2,R>& rhs) {; 695 return rhs.Print(os);; 696}; 697 ; 698 ; 699 } // namespace Math; 700 ; 701} // namespace ROOT; 702 ; 703 ; 704 ; 705#include ""Math/SMatrix.icc""; 706 ; 707#include ""Math/MatrixFunctions.h""; 708 ; 709#endif /* ROOT_Math_SMatrix */; Expression.h; MConfig.h; MatrixFunctions.h; MatrixRepresentationsStatic.h; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; operator<<TBuffer & operator<<(TBuffer &buf, const Tmpl *obj)Definition TBuffer.h:397; SMatrix.icc; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; ROOT::Math::ExprDefinition Expression.h:138; ROOT::Math::MatRepStdExpression wrapper class for Matrix objects.Definition MatrixRepresentationsStatic.h:54; ROOT::Math::SMatrix::SMatrixRow_constDefinition SMatrix.h:382; ROOT::Math::SMatrix::SMatrixRow_const::fMatconst SMatrix< T, D1, D2, R > * fMatDefinition SMatrix.h:391; ROOT::Math::SMatrix::SMatrixRow_const::operator[]const T & operator[](int j) constDefinition SMatrix.h:388; ROOT::Math::SMatrix::SMatrixRow_const::SMatrixRow_constSMatrixRow_const(const SMatrix< T, D1, D2, R > &rhs, unsigned int i)Definition SMatrix.h:384; ROOT::Math::SMatrix::SMatrixRow_const::fRowunsigned int fRowDefinition SMatrix.h:392; ROOT::Math::SMatrix::SMatrixRowDefinition SMatrix.h:371; ROOT::Math::SMatrix::SMatrixRow::fRowunsigned int fRowDefinition SMatrix.h:379; ROOT::Math::SMatrix::SMatrixRow::operator[]T & operator[](int j)Definition SMatrix.h:376; ROOT::Math::SMatrix::SMatrixRow::fMatSMatrix< T, D1, D2, R > * fMatDefinition SMatrix.h:378; ROOT::Math::SMatrix::SMatrixRow::SMatrixRowSMatrixRow(SMatrix< T, D1, D2, R > &rhs, unsi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SMatrix_8h_source.html:24459,wrap,wrapper,24459,doc/master/SMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html,1,['wrap'],['wrapper']
Integrability," 7. const char * AsString() const; Return the date & time as a string (ctime() format).; Copy result because it points to a statically allocated string. const char * AsString(char* out) const; Return the date & time as a string (ctime() format).; Result is copied into out (and out is returned). Make sure; out can at least contain 26 characters. Thread safe. const char * AsSQLString() const; Return the date & time in SQL compatible string format, like:; 1997-01-15 20:16:28. The returned string buffer is static and; will be reused. UInt_t Convert(Bool_t toGMT = kFALSE) const; Convert fDatime from TDatime format to the standard time_t format.; If toGMT is true, the time offset of the current local time zone is; subtracted from the returned time_t. One use of such a non-standard time_t; value is to convert a TDatime object that contains local time to GMT,; as in this example:. TDatime now;; now.Set(now.Convert(kTRUE));. Caution: the time_t returned from Convert(kTRUE) is incompatible with; regular Unix time - it contains an artificial, locale-dependent offset. void Copy(TDatime& datime) const; Copy this to datime. void FillBuffer(char*& buffer); Encode Date/Time into buffer, used by I/O system. UInt_t Get() const; Return raw date/time as encoded by TDatime. Note, this value cannot; be used to e.g. calculate time differences, as it is an encoded value.; To calculate time differences use the Convert() method to get a time; in seconds and then subtract the values. Int_t GetDate() const; Return date in form of 19971224 (i.e. 24/12/1997). Int_t GetTime() const; Return time in form of 123623 (i.e. 12:36:23). void Print(Option_t* option = """") const; Print date and time. void ReadBuffer(char*& buffer); Decode Date/Time from output buffer, used by I/O system. void Set(); Set Date/Time to current time as reported by the system.; Date and Time are encoded into one single unsigned 32 bit word.; Date is stored with the origin being the 1st january 1995.; Time has 1 second precision. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDatime.html:3935,depend,dependent,3935,root/html528/TDatime.html,https://root.cern,https://root.cern/root/html528/TDatime.html,10,['depend'],['dependent']
Integrability," 7391/// \endcode; 7392 ; 7393Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7394{; 7395 ; 7396 if (fNew) return kTRUE;; 7397 ; 7398 if (HasInterpreterInfo()) {; 7399 R__LOCKGUARD(gInterpreterMutex);; 7400 return gCling->ClassInfo_HasDefaultConstructor(GetClassInfo(), testio);; 7401 }; 7402 if (fCollectionProxy) {; 7403 return kTRUE;; 7404 }; 7405 if (fCurrentInfo.load()) {; 7406 // Emulated class, we know how to construct them via the TStreamerInfo; 7407 return kTRUE;; 7408 }; 7409 return kFALSE;; 7410}; 7411 ; 7412////////////////////////////////////////////////////////////////////////////////; 7413/// Returns true if this class has an definition and/or overload of the; 7414/// member function Hash.; 7415///; 7416/// For example to test if the class overload TObject::Hash use; 7417/// ~~~ {.cpp}; 7418/// if (cl->IsTObject() && cl->HasLocalHashMember()); 7419/// ~~~; 7420 ; 7421Bool_t TClass::HasLocalHashMember() const; 7422{; 7423 if (fProperty == (-1)); 7424 Property();; 7425 return TestBit(kHasLocalHashMember);; 7426}; 7427 ; 7428////////////////////////////////////////////////////////////////////////////////; 7429/// Return the wrapper around Merge.; 7430 ; 7431ROOT::MergeFunc_t TClass::GetMerge() const; 7432{; 7433 return fMerge;; 7434}; 7435 ; 7436////////////////////////////////////////////////////////////////////////////////; 7437/// Return the wrapper around Merge.; 7438 ; 7439ROOT::ResetAfterMergeFunc_t TClass::GetResetAfterMerge() const; 7440{; 7441 return fResetAfterMerge;; 7442}; 7443 ; 7444////////////////////////////////////////////////////////////////////////////////; 7445/// Return the wrapper around new ThisClass().; 7446 ; 7447ROOT::NewFunc_t TClass::GetNew() const; 7448{; 7449 return fNew;; 7450}; 7451 ; 7452////////////////////////////////////////////////////////////////////////////////; 7453/// Return the wrapper around new ThisClass[].; 7454 ; 7455ROOT::NewArrFunc_t TClass::GetNewArray() const; 7456{; 7457 return fNewArray;; 7458}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:285236,wrap,wrapper,285236,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['wrap'],['wrapper']
Integrability," 7458/// \endcode; 7459 ; 7460Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7461{; 7462 ; 7463 if (fNew) return kTRUE;; 7464 ; 7465 if (HasInterpreterInfo()) {; 7466 R__LOCKGUARD(gInterpreterMutex);; 7467 return gCling->ClassInfo_HasDefaultConstructor(GetClassInfo(), testio);; 7468 }; 7469 if (fCollectionProxy) {; 7470 return kTRUE;; 7471 }; 7472 if (fCurrentInfo.load()) {; 7473 // Emulated class, we know how to construct them via the TStreamerInfo; 7474 return kTRUE;; 7475 }; 7476 return kFALSE;; 7477}; 7478 ; 7479////////////////////////////////////////////////////////////////////////////////; 7480/// Returns true if this class has an definition and/or overload of the; 7481/// member function Hash.; 7482///; 7483/// For example to test if the class overload TObject::Hash use; 7484/// ~~~ {.cpp}; 7485/// if (cl->IsTObject() && cl->HasLocalHashMember()); 7486/// ~~~; 7487 ; 7488Bool_t TClass::HasLocalHashMember() const; 7489{; 7490 if (fProperty == (-1)); 7491 Property();; 7492 return TestBit(kHasLocalHashMember);; 7493}; 7494 ; 7495////////////////////////////////////////////////////////////////////////////////; 7496/// Return the wrapper around Merge.; 7497 ; 7498ROOT::MergeFunc_t TClass::GetMerge() const; 7499{; 7500 return fMerge;; 7501}; 7502 ; 7503////////////////////////////////////////////////////////////////////////////////; 7504/// Return the wrapper around Merge.; 7505 ; 7506ROOT::ResetAfterMergeFunc_t TClass::GetResetAfterMerge() const; 7507{; 7508 return fResetAfterMerge;; 7509}; 7510 ; 7511////////////////////////////////////////////////////////////////////////////////; 7512/// Return the wrapper around new ThisClass().; 7513 ; 7514ROOT::NewFunc_t TClass::GetNew() const; 7515{; 7516 return fNew;; 7517}; 7518 ; 7519////////////////////////////////////////////////////////////////////////////////; 7520/// Return the wrapper around new ThisClass[].; 7521 ; 7522ROOT::NewArrFunc_t TClass::GetNewArray() const; 7523{; 7524 return fNewArray;; 7525}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:287987,wrap,wrapper,287987,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['wrap'],['wrapper']
Integrability," 7674}; 7675 ; 7676////////////////////////////////////////////////////////////////////////////////; 7677/// Get the interpreter value corresponding to the statement.; 7678int TCling::Evaluate(const char* code, TInterpreterValue& value); 7679{; 7680 auto V = reinterpret_cast<cling::Value*>(value.GetValAddr());; 7681 auto compRes = fInterpreter->evaluate(code, *V);; 7682 return compRes!=cling::Interpreter::kSuccess ? 0 : 1 ;; 7683}; 7684 ; 7685////////////////////////////////////////////////////////////////////////////////; 7686 ; 7687void TCling::RegisterTemporary(const TInterpreterValue& value); 7688{; 7689 using namespace cling;; 7690 const Value* V = reinterpret_cast<const Value*>(value.GetValAddr());; 7691 RegisterTemporary(*V);; 7692}; 7693 ; 7694////////////////////////////////////////////////////////////////////////////////; 7695/// Register value as a temporary, extending its lifetime to that of the; 7696/// interpreter. This is needed for TCling's compatibility interfaces; 7697/// returning long - the address of the temporary objects.; 7698/// As such, ""simple"" types don't need to be stored; they are returned by; 7699/// value; only pointers / references / objects need to be stored.; 7700 ; 7701void TCling::RegisterTemporary(const cling::Value& value); 7702{; 7703 if (value.isValid() && value.needsManagedAllocation()) {; 7704 R__LOCKGUARD(gInterpreterMutex);; 7705 fTemporaries->push_back(value);; 7706 }; 7707}; 7708 ; 7709////////////////////////////////////////////////////////////////////////////////; 7710/// If the interpreter encounters Name, check whether that is an object ROOT; 7711/// could retrieve. To not re-read objects from disk, cache the name/object; 7712/// pair for a given LookupCtx.; 7713 ; 7714TObject* TCling::GetObjectAddress(const char *Name, void *&LookupCtx); 7715{; 7716 // The call to FindSpecialObject might induces any kind of use; 7717 // of the interpreter ... (library loading, function calling, etc.); 7718 // ... and we _know_ we are",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:300281,interface,interfaces,300281,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['interface'],['interfaces']
Integrability," 7740 fVERTq[j-1] = a[j + k*l]*fVERTq[k-1];; 7741 a[j + k*l] = 0;; 7742 }; 7743L50:; 7744 if (k - n < 0) goto L51;; 7745 else if (k - n == 0) goto L60;; 7746 else goto L100;; 7747L51:; 7748 for (j = kp1; j <= n; ++j) {; 7749 fVERTpp[j-1] = a[k + j*l];; 7750 fVERTq[j-1] = -a[k + j*l]*fVERTq[k-1];; 7751 a[k + j*l] = 0;; 7752 }; 7753// elimination proper; 7754L60:; 7755 for (j = 1; j <= n; ++j) {; 7756 for (k = j; k <= n; ++k) { a[j + k*l] += fVERTpp[j-1]*fVERTq[k-1]; }; 7757 }; 7758 }; 7759// elements of left diagonal and unscaling; 7760 for (j = 1; j <= n; ++j) {; 7761 for (k = 1; k <= j; ++k) {; 7762 a[k + j*l] = a[k + j*l]*fVERTs[k-1]*fVERTs[j-1];; 7763 a[j + k*l] = a[k + j*l];; 7764 }; 7765 }; 7766 return;; 7767// failure return; 7768L100:; 7769 ifail = 1;; 7770}; 7771 ; 7772////////////////////////////////////////////////////////////////////////////////; 7773/// Prints Warning messages; 7774///; 7775/// - If COPT='W', CMES is a WARning message from CORG.; 7776/// - If COPT='D', CMES is a DEBug message from CORG.; 7777/// - If SET WARnings is in effect (the default), this routine; 7778/// prints the warning message CMES coming from CORG.; 7779/// - If SET NOWarnings is in effect, the warning message is; 7780/// stored in a circular buffer of length kMAXMES.; 7781/// - If called with CORG=CMES='SHO', it prints the messages in; 7782/// the circular buffer, FIFO, and empties the buffer.; 7783 ; 7784void TMinuit::mnwarn(const char *copt1, const char *corg1, const char *cmes1); 7785{; 7786 TString copt = copt1;; 7787 TString corg = corg1;; 7788 TString cmes = cmes1;; 7789 ; 7790 const Int_t kMAXMES = 10;; 7791 Int_t ityp, i, ic, nm;; 7792 TString englsh, ctyp;; 7793 ; 7794 if (corg(0,3) != ""SHO"" || cmes(0,3) != ""SHO"") {; 7795 ; 7796// Either print warning or put in buffer; 7797 if (copt == ""W"") {; 7798 ityp = 1;; 7799 if (fLwarn) {; 7800 Printf("" MINUIT WARNING IN %s"",(const char*)corg);; 7801 Printf("" ============== %s"",(const char*)cmes);; 7802 return;; 7803 }; 7804 }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:248511,message,message,248511,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['message'],['message']
Integrability," 789 of file RBrowser.cxx. ◆ ProcessPostponedRequests(). void RBrowser::ProcessPostponedRequests ; (; ). protected . Process postponed requests - decouple from websocket handling Only requests which can take longer time should be postponed. ; Definition at line 762 of file RBrowser.cxx. ◆ ProcessRunMacro(). void RBrowser::ProcessRunMacro ; (; const std::string & ; file_path). protected . Process run macro command in the editor. ; Definition at line 384 of file RBrowser.cxx. ◆ ProcessSaveFile(). void RBrowser::ProcessSaveFile ; (; const std::string & ; fname, . const std::string & ; content . ). protected . Process file save command in the editor. ; Definition at line 373 of file RBrowser.cxx. ◆ SendInitMsg(). void RBrowser::SendInitMsg ; (; unsigned ; connid). protected . Process client connect. ; Definition at line 672 of file RBrowser.cxx. ◆ SendProgress(). void RBrowser::SendProgress ; (; unsigned ; connid, . float ; progr . ). protected . Send generic progress message to the web window Should show progress bar on client side. ; Definition at line 715 of file RBrowser.cxx. ◆ SetCatchWindowShow(). void ROOT::RBrowser::SetCatchWindowShow ; (; bool ; on = true). inline . Enable/disable catch of RWebWindow::Show calls to embed created widgets, default on. ; Definition at line 99 of file RBrowser.hxx. ◆ SetUseRCanvas(). void ROOT::RBrowser::SetUseRCanvas ; (; bool ; on = true). inline . Definition at line 83 of file RBrowser.hxx. ◆ SetWorkingPath(). void RBrowser::SetWorkingPath ; (; const std::string & ; path). Set working path in the browser. ; Definition at line 934 of file RBrowser.cxx. ◆ Show(). void RBrowser::Show ; (; const RWebDisplayArgs & ; args = """", . bool ; always_start_new_browser = false . ). show Browser in specified place ; Show or update RBrowser in web window If web window already started - just refresh it like ""reload"" button does If no web window exists or.; Parameters. always_start_new_browserconfigured, starts new window ; argsdisplay arguments .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RBrowser.html:10062,message,message,10062,doc/v632/classROOT_1_1RBrowser.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RBrowser.html,1,['message'],['message']
Integrability," 81 inline T operator() (unsigned int i) const {; 82 return rhs_.apply(i);; 83 }; 84 ; 85 ; 86#ifdef OLD_IMPL; 87 ///; 88 static const unsigned int rows = D;; 89 ///; 90 ///static const unsigned int cols = D2;; 91#else; 92 // use enumerations; 93 enum {; 94 ; 95 kRows = D; 96 ; 97 };; 98#endif; 99 ; 100 /**; 101 function to determine if any use operand; 102 is being used (has same memory address); 103 */; 104 inline bool IsInUse (const T * p) const {; 105 return rhs_.IsInUse(p);; 106 }; 107 ; 108 ; 109 /// used by operator<<(); 110 std::ostream& print(std::ostream& os) const {; 111 os.setf(std::ios::right,std::ios::adjustfield);; 112 unsigned int i=0;; 113 os << ""[ "";; 114 for(; i<D-1; ++i) {; 115 os << apply(i) << "", "";; 116 }; 117 os << apply(i);; 118 os << "" ]"";; 119 ; 120 return os;; 121 }; 122 ; 123private:; 124 ExprType rhs_; // cannot be a reference!; 125};; 126 ; 127 ; 128/**; 129 Expression wrapper class for Matrix objects; 130 ; 131 @ingroup Expression; 132*/; 133 ; 134template <class T, unsigned int D, unsigned int D2> class MatRepStd;; 135 ; 136template <class ExprType, class T, unsigned int D, unsigned int D2 = 1,; 137 class R1=MatRepStd<T,D,D2> >; 138class Expr {; 139public:; 140 typedef T value_type;; 141 ; 142 ///; 143 Expr(const ExprType& rhs) :; 144 rhs_(rhs) {}; 145 ; 146 ///; 147 ~Expr() {}; 148 ; 149 ///; 150 inline T apply(unsigned int i) const {; 151 return rhs_.apply(i);; 152 }; 153 inline T operator() (unsigned int i, unsigned j) const {; 154 return rhs_(i,j);; 155 }; 156 ; 157 /**; 158 function to determine if any use operand; 159 is being used (has same memory address); 160 */; 161 inline bool IsInUse (const T * p) const {; 162 return rhs_.IsInUse(p);; 163 }; 164 ; 165 ; 166 ; 167#ifdef OLD_IMPL; 168 ///; 169 static const unsigned int rows = D;; 170 ///; 171 static const unsigned int cols = D2;; 172#else; 173 // use enumerations; 174 enum {; 175 ///; 176 kRows = D,; 177 ///; 178 kCols = D2; 179 };; 180#endif; 181 ; 182 /// used by operator",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Expression_8h_source.html:3239,wrap,wrapper,3239,doc/master/Expression_8h_source.html,https://root.cern,https://root.cern/doc/master/Expression_8h_source.html,1,['wrap'],['wrapper']
Integrability," 815 of file RBrowser.cxx. ◆ ProcessPostponedRequests(). void RBrowser::ProcessPostponedRequests ; (; ). protected . Process postponed requests - decouple from websocket handling Only requests which can take longer time should be postponed. ; Definition at line 788 of file RBrowser.cxx. ◆ ProcessRunMacro(). void RBrowser::ProcessRunMacro ; (; const std::string & ; file_path). protected . Process run macro command in the editor. ; Definition at line 398 of file RBrowser.cxx. ◆ ProcessSaveFile(). void RBrowser::ProcessSaveFile ; (; const std::string & ; fname, . const std::string & ; content . ). protected . Process file save command in the editor. ; Definition at line 387 of file RBrowser.cxx. ◆ SendInitMsg(). void RBrowser::SendInitMsg ; (; unsigned ; connid). protected . Process client connect. ; Definition at line 686 of file RBrowser.cxx. ◆ SendProgress(). void RBrowser::SendProgress ; (; unsigned ; connid, . float ; progr . ). protected . Send generic progress message to the web window Should show progress bar on client side. ; Definition at line 729 of file RBrowser.cxx. ◆ SetCatchWindowShow(). void ROOT::RBrowser::SetCatchWindowShow ; (; bool ; on = true). inline . Enable/disable catch of RWebWindow::Show calls to embed created widgets, default on. ; Definition at line 99 of file RBrowser.hxx. ◆ SetUseRCanvas(). void ROOT::RBrowser::SetUseRCanvas ; (; bool ; on = true). inline . Definition at line 83 of file RBrowser.hxx. ◆ SetWorkingPath(). void RBrowser::SetWorkingPath ; (; const std::string & ; path). Set working path in the browser. ; Definition at line 960 of file RBrowser.cxx. ◆ Show(). void RBrowser::Show ; (; const RWebDisplayArgs & ; args = """", . bool ; always_start_new_browser = false . ). show Browser in specified place ; Show or update RBrowser in web window If web window already started - just refresh it like ""reload"" button does If no web window exists or.; Parameters. always_start_new_browserconfigured, starts new window ; argsdisplay arguments .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RBrowser.html:10110,message,message,10110,doc/master/classROOT_1_1RBrowser.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RBrowser.html,1,['message'],['message']
Integrability," 93 of file ChebyshevPol.h. ◆ Cross() [1/3]. template<class T , class A > . SVector< T, 3 > ROOT::Math::Cross ; (; const SVector< T, 3 > & ; lhs, . const VecExpr< A, T, 3 > & ; rhs . ). inline . Definition at line 349 of file Functions.h. ◆ Cross() [2/3]. template<class A , class T > . SVector< T, 3 > ROOT::Math::Cross ; (; const VecExpr< A, T, 3 > & ; lhs, . const SVector< T, 3 > & ; rhs . ). inline . Definition at line 336 of file Functions.h. ◆ Cross() [3/3]. template<class A , class B , class T > . SVector< T, 3 > ROOT::Math::Cross ; (; const VecExpr< A, T, 3 > & ; lhs, . const VecExpr< B, T, 3 > & ; rhs . ). inline . Definition at line 362 of file Functions.h. ◆ Dfactir(). template<class Matrix , unsigned int n, unsigned int idim> . bool ROOT::Math::Dfactir ; (; Matrix & ; rhs, . typename Matrix::value_type & ; det, . unsigned int * ; ir . ). Dfactir. ; Function to compute the determinant from a square matrix, Det(A) of dimension idim and order n. A working area ir is returned which is needed by the Dfinv routine.; AuthorT. Glebe ; Definition at line 46 of file Dfactir.h. ◆ Dfinv(). template<class Matrix , unsigned int n, unsigned int idim> . bool ROOT::Math::Dfinv ; (; Matrix & ; rhs, . unsigned int * ; ir . ). Dfinv. ; Function to compute the inverse of a square matrix ( \(A^{-1}\)) of dimension \(idim\) and order \(n\). The routine Dfactir must be called before Dfinv!; AuthorT. Glebe ; Definition at line 47 of file Dfinv.h. ◆ Distance() [1/8]. template<class R > . AxisAngle::Scalar ROOT::Math::Distance ; (; const AxisAngle & ; r1, . const R & ; r2 . ). inline . Distance between two rotations. ; Definition at line 321 of file AxisAngle.h. ◆ Distance() [2/8]. template<class R > . EulerAngles::Scalar ROOT::Math::Distance ; (; const EulerAngles & ; r1, . const R & ; r2 . ). inline . Distance between two rotations. ; Definition at line 358 of file EulerAngles.h. ◆ Distance() [3/8]. template<class R > . Quaternion::Scalar ROOT::Math::Distance ; (; const Quaternion",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:146668,rout,routine,146668,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['rout'],['routine']
Integrability, 979 }; 980 d = rrtpi / (d0 + xq*(d2 + xq));; 981 k = d * y * (a0 + xq);; 982 } else if ( abx > xlim2 ) { // Humlicek W4 Region 2; 983 if ( rg2 != 0 ) { // First point in Region 2; 984 rg2 = 0;; 985 h0 = 0.5625 + yq * (4.5 + yq * (10.5 + yq * (6.0 + yq)));; 986 // Region 2 y-dependents; 987 h2 = -4.5 + yq * (9.0 + yq * ( 6.0 + yq * 4.0));; 988 h4 = 10.5 - yq * (6.0 - yq * 6.0);; 989 h6 = -6.0 + yq * 4.0;; 990 e0 = 1.875 + yq * (8.25 + yq * (5.5 + yq));; 991 e2 = 5.25 + yq * (1.0 + yq * 3.0);; 992 e4 = 0.75 * h6;; 993 }; 994 d = rrtpi / (h0 + xq * (h2 + xq * (h4 + xq * (h6 + xq))));; 995 k = d * y * (e0 + xq * (e2 + xq * (e4 + xq)));; 996 } else if ( abx < xlim3 ) { // Humlicek W4 Region 3; 997 if ( rg3 != 0 ) { // First point in Region 3; 998 rg3 = 0;; 999 z0 = 272.1014 + y * (1280.829 + y *; 1000 (2802.870 + y *; 1001 (3764.966 + y *; 1002 (3447.629 + y *; 1003 (2256.981 + y *; 1004 (1074.409 + y *; 1005 (369.1989 + y *; 1006 (88.26741 + y *; 1007 (13.39880 + y); 1008 )))))))); // Region 3 y-dependents; 1009 z2 = 211.678 + y * (902.3066 + y *; 1010 (1758.336 + y *; 1011 (2037.310 + y *; 1012 (1549.675 + y *; 1013 (793.4273 + y *; 1014 (266.2987 + y *; 1015 (53.59518 + y * 5.0); 1016 ))))));; 1017 z4 = 78.86585 + y * (308.1852 + y *; 1018 (497.3014 + y *; 1019 (479.2576 + y *; 1020 (269.2916 + y *; 1021 (80.39278 + y * 10.0); 1022 ))));; 1023 z6 = 22.03523 + y * (55.02933 + y *; 1024 (92.75679 + y *; 1025 (53.59518 + y * 10.0); 1026 ));; 1027 z8 = 1.496460 + y * (13.39880 + y * 5.0);; 1028 p0 = 153.5168 + y * (549.3954 + y *; 1029 (919.4955 + y *; 1030 (946.8970 + y *; 1031 (662.8097 + y *; 1032 (328.2151 + y *; 1033 (115.3772 + y *; 1034 (27.93941 + y *; 1035 (4.264678 + y * 0.3183291); 1036 )))))));; 1037 p2 = -34.16955 + y * (-1.322256+ y *; 1038 (124.5975 + y *; 1039 (189.7730 + y *; 1040 (139.4665 + y *; 1041 (56.81652 + y *; 1042 (12.79458 + y * 1.2733163); 1043 )))));; 1044 p4 = 2.584042 + y * (10.46332 + y *; 1045 (24.01655 + y *; 1046 (29.81482 + y *; 1047 (,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:33492,depend,dependents,33492,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['depend'],['dependents']
Integrability," : TRangeCast{col != nullptr ? *col : ROOT::Internal::EmptyCollection()} {}; 317};; 318 ; 319/// @brief TRangeStaticCast is an adapter class that allows the typed iteration; 320/// through a TCollection. This requires the collection to contain elements; 321/// of the type requested (or a derived class). Any deviation from this expectation; 322/// will only be caught/reported by an assert in debug builds.; 323///; 324/// This is best used with a TClonesArray, for other cases prefered TRangeDynCast.; 325///; 326/// The typical use is:; 327/// ```{.cpp}; 328/// for(auto bcl : TRangeStaticCast<TBaseClass>( *tbaseClassClonesArrayPtr )) {; 329/// ... use bcl as a TBaseClass*; 330/// }; 331/// for(auto bcl : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; 332/// ... use bcl as a TBaseClass*; 333/// }; 334/// ```; 335/// \tparam T The new type to convert to.; 336template <typename T>; 337using TRangeStaticCast = TRangeCast<T, false>;; 338 ; 339} // namespace Detail; 340} // namespace ROOT; 341 ; 342/// @brief TRangeDynCast is an adapter class that allows the typed iteration; 343/// through a TCollection.; 344///; 345/// The typical use is:; 346/// ```{.cpp}; 347/// for(auto bcl : TRangeDynCast<TBaseClass>( *cl->GetListOfBases() )) {; 348/// if (!bcl) continue;; 349/// ... use bcl as a TBaseClass*; 350/// }; 351/// for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; 352/// if (!bcl) continue;; 353/// ... use bcl as a TBaseClass*; 354/// }; 355/// ```; 356/// \tparam T The new type to convert to.; 357template <typename T>; 358using TRangeDynCast = ROOT::Detail::TRangeCast<T, true>;; 359 ; 360#define R__COLL_COND_MUTEX(mutex) this->IsUsingRWLock() ? mutex : nullptr; 361 ; 362#define R__COLLECTION_READ_LOCKGUARD(mutex) ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex)); 363#define R__COLLECTION_READ_LOCKGUARD_NAMED(name,mutex) ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex)); 364 ; 365#define R__C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:13374,adapter,adapter,13374,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,1,['adapter'],['adapter']
Integrability," : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=None:WeightInitialization=XAVIER:RandomSeed=0:InputLayout=1|1|300:Layout=DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM:CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|300"" [The Layout of the input]; : Layout: ""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:9719,message,message,9719,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,2,['message'],['message']
Integrability," : Using TensorFlow version 2; : Use Keras version from TensorFlow : tf.keras; : Applying GPU option: gpu_options.allow_growth=True; : Disabled TF eager execution when evaluating model ; : Loading Keras Model ; : Loaded model from file: trained_model_cnn.h5; PyKeras : [dataset] : Evaluation of PyKeras on training sample (1600 events); : Elapsed time for evaluation of 1600 events: 0.261 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyKeras.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyKeras.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyTorch for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ PyTorch ] :␛[0m; : ; : PyTorch is a scientific computing package supporting; : automatic differentiation. This method wraps the training; : and predictions steps of the PyTorch Python package for; : TMVA, so that dataloading, preprocessing and evaluation; : can be done within the TMVA system. To use this PyTorch; : interface, you need to generatea model with PyTorch first.; : Then, this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 1280 training events and 320 validation events; : Print Training Model Architecture; : Option SaveBestOnly: Only model weights with smallest validation loss will be stored; : Elapsed time for training with 1600 events: 23.1 sec ; PyTorch : [dataset] : Evaluation of PyTorch on training sample (1600 events); : Elapsed time for evaluation of 1600 events: 0.434 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyTorch.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_CNN_Classification_PyTorch.class.C␛[0m; Factory : Training",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:28390,wrap,wraps,28390,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['wrap'],['wraps']
Integrability," : m[i][j]Definition SMatrix.h:398; ROOT::Math::SMatrix::Place_in_rowSMatrix< T, D1, D2, R > & Place_in_row(const SVector< T, D > &rhs, unsigned int row, unsigned int col)place a vector in a Matrix rowDefinition SMatrix.icc:484; ROOT::Math::SMatrix::DiagonalSVector< T, D1 > Diagonal() constreturn diagonal elements of a matrix as a Vector.Definition SMatrix.icc:755; ROOT::Math::SMatrix::InverseCholSMatrix< T, D1, D2, R > InverseChol(int &ifail) constInvert of a symmetric positive defined Matrix using Choleski decomposition.Definition SMatrix.icc:452; ROOT::Math::SMatrix::SetDiagonalvoid SetDiagonal(const Vector &v)Set the diagonal elements from a Vector Require that vector implements SVector::kSize since a check (...Definition SMatrix.icc:770; ROOT::Math::SMatrix::operator!=bool operator!=(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:327; ROOT::Math::SMatrix::iteratorT * iteratorSTL iterator interface.Definition SMatrix.h:112; ROOT::Math::SMatrix::const_iteratorconst T * const_iteratorSTL const_iterator interface.Definition SMatrix.h:115; ROOT::Math::SMatrix::operator+=SMatrix< T, D1, D2, R > & operator+=(const T &rhs)addition with a scalarDefinition SMatrix.icc:197; ROOT::Math::SMatrix::InvertCholbool InvertChol()Inversion of a symmetric positive defined Matrix using Choleski decomposition.Definition SMatrix.icc:446; ROOT::Math::SMatrix::Invertbool Invert()Invert a square Matrix ( this method changes the current matrix).Definition SMatrix.icc:412; ROOT::Math::SMatrix::IsInUsebool IsInUse(const T *p) constFunction to check if a matrix is sharing same memory location of the passed pointer This function is ...Definition SMatrix.icc:895; ROOT::Math::SMatrix::rep_typeR rep_typestorage representation typeDefinition SMatrix.h:109; ROOT::Math::SMatrix::kCols@ kColsreturn no. of matrix columnsDefinition SMatrix.h:238; ROOT::Math::SMatrix::kRows@ kRowsreturn no. of matrix rowsDefinition SMatrix.h:236; ROOT::Math::SMatrix::kSize@ kSizereturn no of elements: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SMatrix_8h_source.html:30381,interface,interface,30381,doc/master/SMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html,1,['interface'],['interface']
Integrability," : ␛[1mH e l p f o r M V A m e t h o d [ FDA_GA ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The function discriminant analysis (FDA) is a classifier suitable ; : to solve linear or simple nonlinear discrimination problems.; : ; : The user provides the desired function with adjustable parameters; : via the configuration option string, and FDA fits the parameters to; : it, requiring the signal (background) function value to be as close; : as possible to 1 (0). Its advantage over the more involved and; : automatic nonlinear discriminators is the simplicity and transparency ; : of the discrimination expression. A shortcoming is that FDA will; : underperform for involved problems with complicated, phase space; : dependent nonlinear correlations.; : ; : Please consult the Users Guide for the format of the formula string; : and the allowed parameter ranges:; : documentation/tmva/UsersGuide/TMVAUsersGuide.pdf; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : The FDA performance depends on the complexity and fidelity of the; : user-defined discriminator function. As a general rule, it should; : be able to reproduce the discrimination power of any linear; : discriminant analysis. To reach into the nonlinear domain, it is; : useful to inspect the correlation profiles of the input variables,; : and add quadratic and higher polynomial terms between variables as; : necessary. Comparison with more involved nonlinear classifiers can; : be used as a guide.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : Depending on the function used, the choice of ""FitMethod"" is; : crucial for getting valuable solutions with FDA. As a guideline it; : is recommended to start with ""FitMethod=MINUIT"". When more complex; : functions are used where MINUIT does not converge to reasonable; : results, the user should switch to non-gradient FitMethods such; : as GeneticAlgorithm (GA) or Monte Carlo (MC). It might prove to be; : useful to combine GA (or MC) with MINUIT by se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:39254,depend,depends,39254,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['depend'],['depends']
Integrability," ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 85 of file TPSocket.h. ◆ IsValid(). Bool_t TPSocket::IsValid ; (; ); const. inlineoverridevirtual . Reimplemented from TSocket.; Definition at line 79 of file TPSocket.h. ◆ operator=(). void TPSocket::operator= ; (; const TPSocket & ; ). privatedelete . ◆ Recv() [1/4]. Int_t TPSocket::Recv ; (; char * ; str, . Int_t ; max . ). inlineoverridevirtual . Receive a character string message of maximum max length. ; The expected message must be of type kMESS_STRING. Returns length of received string (can be 0 if otherside of connection is closed) or -1 in case of error or -4 in case a non-blocking socket would block (i.e. there is nothing to be read). ; Reimplemented from TSocket.; Definition at line 75 of file TPSocket.h. ◆ Recv() [2/4]. Int_t TPSocket::Recv ; (; char * ; str, . Int_t ; max, . Int_t & ; kind . ). inlineoverridevirtual . Receive a character string message of maximum max length. ; Returns in kind the message type. Returns length of received string+4 (can be 0 if other side of connection is closed) or -1 in case of error or -4 in case a non-blocking socket would block (i.e. there is nothing to be read). ; Reimplemented from TSocket.; Definition at line 76 of file TPSocket.h. ◆ Recv() [3/4]. Int_t TPSocket::Recv ; (; Int_t & ; status, . Int_t & ; kind . ). inlineoverridevirtual . Receives a status and a message type. ; Returns length of received integers, 2*sizeof(Int_t) (can be 0 if other side of connection is closed) or -1 in case of error or -4 in case a non-blocking socket would block (i.e. there is nothing to be read). ; Reimplemented from TSocket.; Definition at line 74 of file TPSocket.h. ◆ Recv() [4/4]. Int_t TPSocket::Recv ; (; TMessage *& ; mess). overridevirtual . Receive a TMessage object. ; The user must delete the TMessage object. Returns length of message in bytes (can be 0 if other side of connection is closed) or -1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPSocket.html:26576,message,message,26576,doc/master/classTPSocket.html,https://root.cern,https://root.cern/doc/master/classTPSocket.html,1,['message'],['message']
Integrability," ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file OptimizeConfigParameters.h. Member Data Documentation. ◆ fAlreadyTrainedParCombination. std::map< std::vector<Double_t> , Double_t> TMVA::OptimizeConfigParameters::fAlreadyTrainedParCombination. private . save parameters for which the FOM is already known (GA seems to evaluate the same parameters several times) ; Definition at line 86 of file OptimizeConfigParameters.h. ◆ fFOMType. TString TMVA::OptimizeConfigParameters::fFOMType. private . the FOM type (Separation, ROC integra.. whatever you implemented.. ; Definition at line 87 of file OptimizeConfigParameters.h. ◆ fFOMvsIter. std::vector<Float_t> TMVA::OptimizeConfigParameters::fFOMvsIter. private . graph showing the development of the Figure Of Merit values during the fit ; Definition at line 83 of file OptimizeConfigParameters.h. ◆ fLogger. MsgLogger* TMVA::OptimizeConfigParameters::fLogger. mutableprivate . ! message logger ; Definition at line 97 of file OptimizeConfigParameters.h. ◆ fMethod. MethodBase* const TMVA::OptimizeConfigParameters::fMethod. private . The MVA method to be evaluated. ; Definition at line 82 of file OptimizeConfigParameters.h. ◆ fMvaBkg. TH1D* TMVA::OptimizeConfigParameters::fMvaBkg. private . MVA distribution for bakgr. events, used for spline fit. ; Definition at line 90 of file OptimizeConfigParameters.h. ◆ fMvaBkgFineBin. TH1D* TMVA::OptimizeConfigParameters::fMvaBkgFineBin. private . MVA distribution for bakgr. events. ; Definition at line 93 of file OptimizeConfigParameters.h. ◆ fMvaSig. TH1D* TMVA::OptimizeConfigParameters::fMvaSig. private . MVA distribution for signal events, used for spline fit. ; Definition at line 89 of file OptimizeConfigParameters.h. ◆ fMvaSigFineBin. TH1D* TMVA::OptimizeConfigParameters::fMvaSigFineBin. private . MVA distribution for signal events. ; Definition at line 92 of file OptimizeConfigParameters.h. ◆ fNotDoneYet. Bool_t TMVA::OptimizeConfigParameters::fNotDone",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html:10959,message,message,10959,doc/master/classTMVA_1_1OptimizeConfigParameters.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1OptimizeConfigParameters.html,1,['message'],['message']
Integrability," ; (; const char * ; bname, . void * ; add, . TClass * ; realClass, . EDataType ; datatype, . bool ; isptr . ). overridevirtual . Check if bname is already in the status list, and if not, create a TChainElement object and set its address. ; See TTree::CheckBranchAddressType for the semantic of the return value.; Note: See the comments in TBranchElement::SetAddress() for a more detailed discussion of the meaning of the add parameter. ; Reimplemented from TTree.; Definition at line 2571 of file TChain.cxx. ◆ SetBranchStatus(). void TChain::SetBranchStatus ; (; const char * ; bname, . bool ; status = true, . UInt_t * ; found = nullptr . ). overridevirtual . Set branch status to Process or DoNotProcess. ; Parameters. [in]bnameis the name of a branch. if bname=""*"", apply to all branches. ; [in]status= 1 branch will be processed, = 0 branch will not be processed ; [out]found. See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented from TTree.; Definition at line 2613 of file TChain.cxx. ◆ SetCacheSize(). Int_t TChain::SetCacheSize ; (; Long64_t ; cacheSize = -1). overridevirtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented from TTree.; Definition at line 2441 of file TChain.cxx. ◆ SetDirectory(). void TChain::SetDirectory ; (; TDirectory * ; dir). overridevirtual . Remove reference to this chain from current directory and add reference to new directory dir. ; dir can be 0 in which case the chain does not belong to any directory. ; Reimplemented from TTree.; Definition at line 2640 of file TChain.cxx. ◆ SetEntryList(). void TChain::SetEntryLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:96572,message,message,96572,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['message'],['message']
Integrability," ; (; const char * ; bname, . void * ; add, . TClass * ; realClass, . EDataType ; datatype, . bool ; isptr . ). overridevirtual . Check if bname is already in the status list, and if not, create a TChainElement object and set its address. ; See TTree::CheckBranchAddressType for the semantic of the return value.; Note: See the comments in TBranchElement::SetAddress() for a more detailed discussion of the meaning of the add parameter. ; Reimplemented from TTree.; Definition at line 2597 of file TChain.cxx. ◆ SetBranchStatus(). void TChain::SetBranchStatus ; (; const char * ; bname, . bool ; status = true, . UInt_t * ; found = nullptr . ). overridevirtual . Set branch status to Process or DoNotProcess. ; Parameters. [in]bnameis the name of a branch. if bname=""*"", apply to all branches. ; [in]status= 1 branch will be processed, = 0 branch will not be processed ; [out]found. See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented from TTree.; Definition at line 2639 of file TChain.cxx. ◆ SetCacheSize(). Int_t TChain::SetCacheSize ; (; Long64_t ; cacheSize = -1). overridevirtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented from TTree.; Definition at line 2467 of file TChain.cxx. ◆ SetDirectory(). void TChain::SetDirectory ; (; TDirectory * ; dir). overridevirtual . Remove reference to this chain from current directory and add reference to new directory dir. ; dir can be 0 in which case the chain does not belong to any directory. ; Reimplemented from TTree.; Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:97126,message,message,97126,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['message'],['message']
Integrability," ; (; unsigned int ; i); const. inline . read-only access of vector elements with check on index. Index starts from 0. ; Definition at line 596 of file SVector.icc. ◆ begin() [1/2]. template<class T , unsigned int D> . T * ROOT::Math::SVector< T, D >::begin. inline . STL iterator interface. ; Definition at line 550 of file SVector.icc. ◆ begin() [2/2]. template<class T , unsigned int D> . const T * ROOT::Math::SVector< T, D >::begin. inline . STL const_iterator interface. ; Definition at line 553 of file SVector.icc. ◆ Dim(). template<class T , unsigned int D> . static unsigned int ROOT::Math::SVector< T, D >::Dim ; (; ). inlinestatic . return dimension \(D\) ; Definition at line 179 of file SVector.h. ◆ end() [1/2]. template<class T , unsigned int D> . T * ROOT::Math::SVector< T, D >::end. inline . STL iterator interface. ; Definition at line 556 of file SVector.icc. ◆ end() [2/2]. template<class T , unsigned int D> . const T * ROOT::Math::SVector< T, D >::end. inline . STL const_iterator interface. ; Definition at line 559 of file SVector.icc. ◆ IsInUse(). template<class T , unsigned int D> . bool ROOT::Math::SVector< T, D >::IsInUse ; (; const T * ; p); const. Function to check if a vector is sharing same memory location of the passed pointer This function is used by the expression templates to avoid the alias problem during expression evaluation. ; When the vector is in use, for example in operations like V = M * V, where M is a mtrix, a temporary object storing the intermediate result is automatically created when evaluating the expression. ; Definition at line 628 of file SVector.icc. ◆ operator!=() [1/3]. template<class T , unsigned int D> . bool ROOT::Math::SVector< T, D >::operator!= ; (; const SVector< T, D > & ; rhs); const. inline . element wise comparison ; Definition at line 266 of file SVector.icc. ◆ operator!=() [2/3]. template<class T , unsigned int D> . bool ROOT::Math::SVector< T, D >::operator!= ; (; const T & ; rhs); const. inline . element wise",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html:14504,interface,interface,14504,doc/master/classROOT_1_1Math_1_1SVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html,1,['interface'],['interface']
Integrability," ; 1942Int_t TColor::GetColor(Float_t r, Float_t g, Float_t b, Float_t a); 1943{; 1944 return GetColor(Int_t(r * 255), Int_t(g * 255), Int_t(b * 255), a);; 1945}; 1946 ; 1947////////////////////////////////////////////////////////////////////////////////; 1948/// Static method returning color number for color specified by; 1949/// system dependent pixel value. Pixel values can be obtained, e.g.,; 1950/// from the GUI color picker.; 1951///; 1952/// The color retrieval is done using a threshold defined by SetColorThreshold.; 1953 ; 1954 ; 1955Int_t TColor::GetColor(ULong_t pixel); 1956{; 1957 Int_t r, g, b;; 1958 ; 1959 Pixel2RGB(pixel, r, g, b);; 1960 ; 1961 return GetColor(r, g, b);; 1962}; 1963 ; 1964////////////////////////////////////////////////////////////////////////////////; 1965/// This method specifies the color threshold used by GetColor to retrieve a color.; 1966///; 1967/// \param[in] t Color threshold. By default is equal to 1./31. or 1./255.; 1968/// depending on the number of available color planes.; 1969///; 1970/// When GetColor is called, it scans the defined colors and compare them to the; 1971/// requested color.; 1972/// If the Red Green and Blue values passed to GetColor are Rr Gr Br; 1973/// and Rd Gd Bd the values of a defined color. These two colors are considered equal; 1974/// if (abs(Rr-Rd) < t & abs(Br-Bd) < t & abs(Br-Bd) < t). If this test passes,; 1975/// the color defined by Rd Gd Bd is returned by GetColor.; 1976///; 1977/// To make sure GetColor will return a color having exactly the requested; 1978/// R G B values it is enough to specify a nul :; 1979/// ~~~ {.cpp}; 1980/// TColor::SetColorThreshold(0.);; 1981/// ~~~; 1982///; 1983/// To reset the color threshold to its default value it is enough to do:; 1984/// ~~~ {.cpp}; 1985/// TColor::SetColorThreshold(-1.);; 1986/// ~~~; 1987 ; 1988void TColor::SetColorThreshold(Float_t t); 1989{; 1990 gColorThreshold = t;; 1991}; 1992 ; 1993/////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:70317,depend,depending,70317,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['depend'],['depending']
Integrability," ; 198 /// clone (required by the interface); 199 WrappedMemMultiFunction * Clone() const override {; 200 return new WrappedMemMultiFunction(*fObj,fMemFunc,fDim);; 201 }; 202 ; 203 ; 204 unsigned int NDim() const override { return fDim; }; 205 ; 206private:; 207 ; 208 double DoEval (const double * x) const override {; 209 return ((*fObj).*fMemFunc)( x );; 210 }; 211 ; 212 ; 213 FuncObj * fObj;; 214 MemFuncPtr fMemFunc;; 215 unsigned int fDim;; 216 ; 217 ; 218}; // WrappedMemMultiFunction; 219 ; 220 ; 221} // namespace Math; 222} // namespace ROOT; 223 ; 224 ; 225 ; 226#endif // ROOT_Math_WrappedFunction; IFunction.h; f#define f(i)Definition RSha256.hxx:104; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::WrappedFunctionTemplate class to wrap any C++ callable object which takes one argument i.e.Definition WrappedFunction.h:45; ROOT::Math::WrappedFunction::DoEvaldouble DoEval(double x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition WrappedFunction.h:68; ROOT::Math::WrappedFunction::fFuncFunc fFuncDefinition WrappedFunction.h:73; ROOT::Math::WrappedFunction::CloneWrappedFunction * Clone() const overrideclone (required by the interface)Definition WrappedFunction.h:60; ROOT::Math::WrappedFunction::WrappedFunctionWrappedFunction(Func f)construct from the pointer to the object and the member functionDefinition WrappedFunction.h:53; ROOT::Math::WrappedMemFunctionTemplate class to wrap any member function of a class taking a double and returning a double in a 1D ...Definition WrappedFunction.h:95; ROOT::Math::WrappedMemFunction::DoEvaldouble DoEval(double x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition WrappedF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/WrappedFunction_8h_source.html:6151,wrap,wrap,6151,doc/master/WrappedFunction_8h_source.html,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html,1,['wrap'],['wrap']
Integrability, ; 257 } // end namespace Math; 258 ; 259} // end namespace ROOT; 260 ; 261#endif; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; ROOT::Math::IOptionsGeneric interface for defining configuration options of a numerical algorithm.Definition IOptions.h:28; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; ROOT::Math::MinimizerOptions::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition MinimizerOptions.h:213; ROOT::Math::MinimizerOptions::SetStrategyvoid SetStrategy(int stra)set the strategyDefinition MinimizerOptions.h:225; ROOT::Math::MinimizerOptions::operator=MinimizerOptions & operator=(const MinimizerOptions &opt)assignment operatorsDefinition MinimizerOptions.cxx:151; ROOT::Math::MinimizerOptions::DefaultPrintLevelstatic int DefaultPrintLevel()Definition MinimizerOptions.cxx:97; ROOT::Math::MinimizerOptions::DefaultPrecisionstatic double DefaultPrecision()Definition MinimizerOptions.cxx:93; ROOT::Math::MinimizerOptions::Defaultstatic ROOT::Math::IOptions & Default(const char *name)Retrieve extra options for a given minimizer name.Definition MinimizerOptions.cxx:234; ROOT::,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MinimizerOptions_8h_source.html:11703,interface,interface,11703,doc/master/MinimizerOptions_8h_source.html,https://root.cern,https://root.cern/doc/master/MinimizerOptions_8h_source.html,1,['interface'],['interface']
Integrability," ; 5206 TClingClassInfo cl(GetInterpreterImpl(), name);; 5207 if (!cl.IsValid()) {; 5208 return ;; 5209 }; 5210 if (full) {; 5211 cl.FullName(output,*fNormalizedCtxt);; 5212 return;; 5213 }; 5214 // Well well well, for backward compatibility we need to act a bit too; 5215 // much like CINT.; 5216 TClassEdit::TSplitType splitname( cl.Name(), TClassEdit::kDropStd );; 5217 splitname.ShortType(output, TClassEdit::kDropStd );; 5218 ; 5219 return;; 5220}; 5221 ; 5222////////////////////////////////////////////////////////////////////////////////; 5223/// Execute a global function with arguments params.; 5224///; 5225/// FIXME: The cint-based version of this code does not check if the; 5226/// SetFunc() call works, and does not do any real checking; 5227/// for errors from the Exec() call. It did fetch the most; 5228/// recent cint security error and return that in error, but; 5229/// this does not really translate well to cling/clang. We; 5230/// should enhance these interfaces so that we can report; 5231/// compilation and runtime errors properly.; 5232 ; 5233void TCling::Execute(const char* function, const char* params, int* error); 5234{; 5235 R__LOCKGUARD_CLING(gInterpreterMutex);; 5236 if (error) {; 5237 *error = TInterpreter::kNoError;; 5238 }; 5239 TClingClassInfo cl(GetInterpreterImpl());; 5240 Longptr_t offset = 0L;; 5241 TClingCallFunc func(GetInterpreterImpl());; 5242 func.SetFunc(&cl, function, params, &offset);; 5243 func.Exec(nullptr);; 5244}; 5245 ; 5246////////////////////////////////////////////////////////////////////////////////; 5247/// Execute a method from class cl with arguments params.; 5248///; 5249/// FIXME: The cint-based version of this code does not check if the; 5250/// SetFunc() call works, and does not do any real checking; 5251/// for errors from the Exec() call. It did fetch the most; 5252/// recent cint security error and return that in error, but; 5253/// this does not really translate well to cling/clang. We; 5254/// should enhance the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:203449,interface,interfaces,203449,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['interface'],['interfaces']
Integrability," ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxyRooAbsHiddenReal::_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooUnblindCPAsymVar.html:33552,integrat,integrator,33552,root/html532/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html532/RooUnblindCPAsymVar.html,2,['integrat'],['integrator']
Integrability," ; Definition at line 376 of file TUnuran.cxx. ◆ GetDistType(). int TUnuran::GetDistType ; (; ); const. Return the type of the distribution. ; See documentation of unuran_distr_get_type for the possible types of distributions. ; Definition at line 383 of file TUnuran.cxx. ◆ GetGenId(). std::string TUnuran::GetGenId ; (; ); const. Return an ID string about the unuran generator method. ; Definition at line 369 of file TUnuran.cxx. ◆ GetInfo(). std::string TUnuran::GetInfo ; (; bool ; extended = false). Return an information string about the used Unuran generator method. ; Parameters. extended: if true return some helper information about the existing options of the method. . Definition at line 362 of file TUnuran.cxx. ◆ GetRandom(). TRandom * TUnuran::GetRandom ; (; ). inline . Return instance of the random engine used. ; Definition at line 223 of file TUnuran.h. ◆ Init() [1/5]. bool TUnuran::Init ; (; const std::string & ; distr, . const std::string & ; method . ). Initialize with Unuran string API interface. ; See https://statmath.wu.ac.at/unuran/doc/unuran.html#StringAPI; Parameters. distr: UNU.RAN distribution string ; method: UNU.RAN method string. Here is an example using the string API: Tunuran unr;; unr.Init(""normal(3.,0.75); domain = (0,inf)"", ""method = tdr; c = 0"");. Definition at line 62 of file TUnuran.cxx. ◆ Init() [2/5]. bool TUnuran::Init ; (; const TUnuranContDist & ; distr, . const std::string & ; method = ""auto"" . ). Initialize method for continuous one-dimensional distribution. ; User must provide a distribution object (which is copied inside) and a string for a method. For the list of available method for 1D cont. distribution see the UnuRan doc. A re-initialization is needed whenever distribution parameters have been changed. Note that the method string can contain in addition to the method name all the specific method parameters specified using the UNURAN method string API. For example a valid string can be ""method=arou; max_segments=1000; max_sqh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnuran.html:6934,interface,interface,6934,doc/master/classTUnuran.html,https://root.cern,https://root.cern/doc/master/classTUnuran.html,1,['interface'],['interface']
Integrability," ; Definition at line 784 of file TUDPSocket.cxx. ◆ RecvProcessIDs(). Bool_t TUDPSocket::RecvProcessIDs ; (; TMessage * ; mess). protected . Receive a message containing process ids. ; In case the message contains process ids they are imported, the message will be deleted and the method returns kTRUE. ; Definition at line 945 of file TUDPSocket.cxx. ◆ RecvRaw(). Int_t TUDPSocket::RecvRaw ; (; void * ; buffer, . Int_t ; length, . ESendRecvOptions ; opt = kDefault . ). virtual . Receive a raw buffer of specified length bytes. ; Using option kPeek one can peek at incoming data. Returns number of received bytes. Returns -1 in case of error. In case of opt == kOob: -2 means EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock) -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Definition at line 867 of file TUDPSocket.cxx. ◆ RecvStreamerInfos(). Bool_t TUDPSocket::RecvStreamerInfos ; (; TMessage * ; mess). protected . Receive a message containing streamer infos. ; In case the message contains streamer infos they are imported, the message will be deleted and the method returns kTRUE. ; Definition at line 898 of file TUDPSocket.cxx. ◆ Select(). Int_t TUDPSocket::Select ; (; Int_t ; interest = kRead, . Long_t ; timeout = -1 . ). virtual . Waits for this socket to change status. ; If interest=kRead, the socket will be watched to see if characters become available for reading; if interest=kWrite the socket will be watched to see if a write will not block. The argument 'timeout' specifies a maximum time to wait in millisec. Default no timeout. Returns 1 if a change of status of interest has been detected within timeout; 0 in case of timeout; < 0 if an error occured. ; Definition at line 407 of file TUDPSocket.cxx. ◆ Send() [1/4]. Int_t TUDPSocket::Send ; (; const char * ; str, . Int_t ; kind = kMESS_STRING . ). virtual . Send a character string buffer. ; Use kind to set the TMessage ""what"" field. Returns the number of bytes in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUDPSocket.html:28487,message,message,28487,doc/master/classTUDPSocket.html,https://root.cern,https://root.cern/doc/master/classTUDPSocket.html,1,['message'],['message']
Integrability," ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development Run the tests. Running the ROOT battery of tests; Running all ROOT tests on at least a platform before sending a PR or before pushing anything to the ROOT repository is mandatory.; The ROOT continuous integration infrastructure allows to automatically check the PR also on a battery of platform, for example including macos and linux boxes.; In order to be able to run all tests, the simple steps below need to be followed; Prepare your development area and build ROOT; mkdir RootDevelopment; cd RootDevelopment; git clone https://github.com/root-project/root; git clone https://github.com/root-project/roottest; mkdir build; cd build; echo Note the cmake options; cmake -DCMAKE_BUILD_TYPE=Debug -Dtesting=ON -Droottest=ON ../root. Inspect and run the tests; From within the build directory. List all tests: ctest -N; List all test matching a regex: ctest -N -R myregex; Run all tests on N cores: ctest -j N. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/run-tests.html:2063,integrat,integration,2063,d/run-tests.html,https://root.cern,https://root.cern/d/run-tests.html,1,['integrat'],['integration']
Integrability," ; Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. ; RooRealIntegral and RooAbsPdf use this class in the (normalization) integral configuration interface ; Definition at line 25 of file RooNumIntConfig.h. Public Member Functions;  RooNumIntConfig ();  Constructor. ;  ;  RooNumIntConfig (const RooNumIntConfig &other);  Copy constructor. ;  ;  ~RooNumIntConfig () override;  Destructor. ;  ; bool addConfigSection (std::string const &name, const RooArgSet &inDefaultConfig, bool canIntegrate1D, bool canIntegrate2D, bool canIntegrateND, bool canIntegrateOpenEnded);  Add a configuration section for a particular integrator. ;  ; StyleOption defaultPrintStyle (Option_t *opt) const override;  ; double epsAbs () const;  ; double epsRel () const;  ; RooArgSet & getConfigSection (const char *name);  Return section with configuration parameters for integrator with given (class) name. ;  ; const RooArgSet & getConfigSection (const char *name) const;  Retrieve configuration information specific to integrator with given name. ;  ; TClass * IsA () const override;  ; RooCategory & method1D ();  ; const RooCategory & method1D () const;  ; RooCategory & method1DOpen ();  ; const RooCategory & method1DOpen () const;  ; RooCategory & method2D ();  ; const RooCategory & method2D () const;  ; RooCategory & method2DOpen ();  ; const RooCategory & method2DOpen () const;  ; RooCategory & methodND ();  ; const RooCategory & methodND () const;  ; RooCategory & methodNDOpen ();  ; const RooCategory & methodNDOpen () const;  ; RooNumIntConfig & operator= (const RooNumIntConfig &other);  Assignment operator from other RooNumIntConfig. ;  ; void Print (Option_t *options=nullptr) const override;  This method must be overridden when a class wants to print itself. ;  ; bool printEvalCounter () const;  ; void printMultiline (std::ostream &os, Int_t content, bool verbose, TString indent="""") const override;  Detailed printing interface. ;  ; void setEpsAbs (d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumIntConfig.html:1348,integrat,integrator,1348,doc/master/classRooNumIntConfig.html,https://root.cern,https://root.cern/doc/master/classRooNumIntConfig.html,1,['integrat'],['integrator']
Integrability," ; If doReplace is true any existing class code saved in the workspace is replaced ; Definition at line 1112 of file RooWorkspace.cxx. ◆ importClassCode() [2/2]. bool RooWorkspace::importClassCode ; (; TClass * ; theClass, . bool ; doReplace = false . ). Definition at line 1099 of file RooWorkspace.cxx. ◆ IsA(). TClass * RooWorkspace::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 282 of file RooWorkspace.h. ◆ loadSnapshot(). bool RooWorkspace::loadSnapshot ; (; const char * ; name). Load the values and attributes of the parameters in the snapshot saved with the given name. ; Definition at line 1182 of file RooWorkspace.cxx. ◆ makeDir(). bool RooWorkspace::makeDir ; (; ). Create transient TDirectory representation of this workspace. ; This directory will appear as a subdirectory of the directory that contains the workspace and will have the name of the workspace suffixed with ""Dir"". The TDirectory interface is read-only. Any attempt to insert objects into the workspace directory representation will result in an error message. Note that some ROOT object like TH1 automatically insert themselves into the current directory when constructed. This will give error messages when done in a workspace directory. ; Definition at line 1887 of file RooWorkspace.cxx. ◆ merge(). void RooWorkspace::merge ; (; const RooWorkspace & ; ). inline . Definition at line 102 of file RooWorkspace.h. ◆ obj(). TObject * RooWorkspace::obj ; (; RooStringView ; name); const. Return any type of object (RooAbsArg, RooAbsData or generic object) with given name) ; Definition at line 2007 of file RooWorkspace.cxx. ◆ pdf(). RooAbsPdf * RooWorkspace::pdf ; (; RooStringView ; name); const. Retrieve p.d.f (RooAbsPdf) with given name. A null pointer is returned if not found. ; Definition at line 1214 of file RooWorkspace.cxx. ◆ Print(). void RooWorkspace::Print ; (; Option_t * ; opts = nullptr); const. overridevirtual . Pri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace.html:44834,interface,interface,44834,doc/master/classRooWorkspace.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace.html,1,['interface'],['interface']
Integrability," ; If the bit kClearAfterCR has been set for this pad, the Clear function will execute only after having pressed a CarriageReturn Set the bit with mypad->SetBit(TPad::kClearAfterCR) ; Implements TVirtualPad.; Definition at line 722 of file TPad.cxx. ◆ Clip() [1/2]. Int_t TPad::Clip ; (; Double_t * ; x, . Double_t * ; y, . Double_t ; xclipl, . Double_t ; yclipb, . Double_t ; xclipr, . Double_t ; yclipt . ). overridevirtual . Clipping routine: Cohen Sutherland algorithm. ; - If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. Parameters. [in,out]x[],y[]Segment coordinates (2 points) ; [in]xclipl,yclipb,xclipr,ycliptClipping boundary . Implements TVirtualPad.; Definition at line 830 of file TPad.cxx. ◆ Clip() [2/2]. Int_t TPad::Clip ; (; Float_t * ; x, . Float_t * ; y, . Float_t ; xclipl, . Float_t ; yclipb, . Float_t ; xclipr, . Float_t ; yclipt . ). virtual . Clipping routine: Cohen Sutherland algorithm. . If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. Parameters. [in,out]x[],y[]Segment coordinates (2 points) ; [in]xclipl,yclipb,xclipr,ycliptClipping boundary . Definition at line 768 of file TPad.cxx. ◆ ClippingCode(). Int_t TPad::ClippingCode ; (; Double_t ; x, . Double_t ; y, . Double_t ; xcl1, . Double_t ; ycl1, . Double_t ; xcl2, . Double_t ; ycl2 . ). virtual . Compute the endpoint codes for TPad::Clip. ; Definition at line 901 of file TPad.cxx. ◆ ClipPolygon(). Int_t TPad::ClipPolygon ; (; Int_t ; n, . Double_t * ; x, . Double_t * ; y, . Int_t ; nn, . Double_t * ; xc, . Double_t * ; yc, . Double_t ; xclipl, . Double_t ; yclipb, . Double_t ; xclipr, . Double_t ; yclipt . ). virtual . Clip polygon using the Sutherland-Hodgman algorithm. ; Parameters. [in]nNumber of points in the polygon to be clipped ; [in]x,yPolygon x[n], y[n] do be clipped vertic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:61971,rout,routine,61971,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['rout'],['routine']
Integrability," ; Implements RooStats::IntervalCalculator.; Definition at line 104 of file BayesianCalculator.h. ◆ SetData(). void RooStats::BayesianCalculator::SetData ; (; RooAbsData & ; ). inlineoverridevirtual . Set the DataSet ( add to the workspace if not already there ?) ; Implements RooStats::IntervalCalculator.; Definition at line 72 of file BayesianCalculator.h. ◆ SetGlobalObservables(). virtual void RooStats::BayesianCalculator::SetGlobalObservables ; (; const RooArgSet & ; set). inlinevirtual . set the global observables which will be used when creating the NLL so the constraint pdf's will be normalized correctly on the global observables when computing the NLL ; Definition at line 96 of file BayesianCalculator.h. ◆ SetIntegrationType(). void RooStats::BayesianCalculator::SetIntegrationType ; (; const char * ; type). set the integration type (possible type are) : . 1D integration ( used when only one nuisance and when the posterior is scanned): adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration The parameter numIters (settable with SetNumIters) is the max number of function calls. It can be reduced to make the integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC: evaluate posterior by generating toy MC for the nuisance parameters. It is a MC integration, where the function is sampled according to the nuisance. It is convenient to use when all the nuisance are uncorrelated and it is efficient to generate them The toy are generated by default for each poi v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html:30408,integrat,integration,30408,doc/master/classRooStats_1_1BayesianCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html,2,['integrat'],['integration']
Integrability," ; Parameters. [in]rectspecifies the rectangle ; [in]srcspecifies the source region to be used ; [in]destreturns the destination region . Reimplemented from TVirtualX. ◆ UnionRegion(). void TGWin32VirtualXProxy::UnionRegion ; (; Region_t ; rega, . Region_t ; regb, . Region_t ; result . ). overridevirtual . Computes the union of two regions. ; Parameters. [in]rega,regbspecify the two regions with which you want to perform the computation ; [in]resultreturns the result of the computation . Reimplemented from TVirtualX. ◆ UnmapWindow(). void TGWin32VirtualXProxy::UnmapWindow ; (; Window_t ; id). overridevirtual . Unmaps the specified window ""id"". ; If the specified window is already unmapped, this function has no effect. Any child window will no longer be visible (but they are still mapped) until another map call is made on the parent. ; Reimplemented from TVirtualX. ◆ Update(). void TGWin32VirtualXProxy::Update ; (; Int_t ; mode = 0). overridevirtual . Flushes (mode = 0, default) or synchronizes (mode = 1) X output buffer. ; Flush flushes output buffer. Sync flushes buffer and waits till all requests have been processed by X server. ; Reimplemented from TVirtualX. ◆ UpdateWindow(). void TGWin32VirtualXProxy::UpdateWindow ; (; Int_t ; mode). overridevirtual . Updates or synchronises client and server once (not permanent). ; according to ""mode"".; Parameters. [in]modeupdate mode.; mode = 1 update; mode = 0 sync . Reimplemented from TVirtualX. ◆ Warp(). void TGWin32VirtualXProxy::Warp ; (; Int_t ; ix, . Int_t ; iy, . Window_t ; id = 0 . ). overridevirtual . Sets the pointer position. ; Parameters. [in]ixnew X coordinate of pointer ; [in]iynew Y coordinate of pointer ; [in]idwindow identifier. Coordinates are relative to the origin of the window id or to the origin of the current window if id == 0. ; Reimplemented from TVirtualX. ◆ WMDeleteNotify(). void TGWin32VirtualXProxy::WMDeleteNotify ; (; Window_t ; id). overridevirtual . Tells WM to send message when window is clos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:123388,synchroniz,synchronizes,123388,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['synchroniz'],['synchronizes']
Integrability," ; Parameters. absToldesired absolute Error ; relToldesired relative Error ; sizemaximum number of sub-intervals . Definition at line 77 of file GSLIntegrator.cxx. ◆ GSLIntegrator() [2/5]. ROOT::Math::GSLIntegrator::GSLIntegrator ; (; const Integration::Type ; type, . double ; absTol = 1.E-9, . double ; relTol = 1E-6, . size_t ; size = 1000 . ). constructor of GSL Integrator. ; In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; Parameters. typetype of integration. The possible types are defined in the Integration::Type enumeration ; absToldesired absolute Error ; relToldesired relative Error ; sizemaximum number of sub-intervals . Definition at line 95 of file GSLIntegrator.cxx. ◆ GSLIntegrator() [3/5]. ROOT::Math::GSLIntegrator::GSLIntegrator ; (; const Integration::Type ; type, . const Integration::GKRule ; rule, . double ; absTol = 1.E-9, . double ; relTol = 1E-6, . size_t ; size = 1000 . ). generic constructor for GSL Integrator ; Parameters. typetype of integration. The possible types are defined in the Integration::Type enumeration ; ruleGauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration ; absToldesired absolute Error ; relToldesired relative Error ; sizemaximum number of sub-intervals . Definition at line 56 of file GSLIntegrator.cxx. ◆ GSLIntegrator() [4/5]. ROOT::Math::GSLIntegrator::GSLIntegrator ; (; const char * ; type, . int ; rule, . double ; absTol, . double ; relTol, . size_t ; size . ). constructor of GSL Integrator. ; In the case of Adaptive integration the Gauss-Krond rule of 31 points is used This is used by the plug-in manager (need a char * instead of enumerations); Parameters. typetype of integration. The possible types are defined in the Integration::Type enumeration ; ruleGauss-Kronrod rule (from 1 to 6) ; absToldesired absolute Error ; relToldesired relative Error ; sizemaximum number of sub-intervals . Definition at line 114 o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLIntegrator.html:8834,integrat,integration,8834,doc/master/classROOT_1_1Math_1_1GSLIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLIntegrator.html,1,['integrat'],['integration']
Integrability," ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TGMsgBox Class Reference. . Definition at line 52 of file TGMsgBox.h. Public Member Functions;  TGMsgBox (const TGWindow *p, const TGWindow *main, const char *title, const char *msg, EMsgBoxIcon icon, Int_t buttons=kMBDismiss, Int_t *ret_code=nullptr, UInt_t options=kVerticalFrame, Int_t text_align=kTextCenterX|kTextCenterY);  Create a message dialog box with the following parameters:. ;  ;  TGMsgBox (const TGWindow *p=nullptr, const TGWindow *main=nullptr, const char *title=nullptr, const char *msg=nullptr, const TGPicture *icon=nullptr, Int_t buttons=kMBDismiss, Int_t *ret_code=nullptr, UInt_t options=kVerticalFrame, Int_t text_align=kTextCenterX|kTextCenterY);  Create a message dialog box. ;  ;  ~TGMsgBox () override;  Destroy message dialog box. ;  ; void CloseWindow () override;  Close dialog box. ;  ; Bool_t HandleKey (Event_t *event) override;  Handle enter and escape keys (used as Ok and Cancel for now). ;  ; TClass * IsA () const override;  ; Bool_t ProcessMessage (Longptr_t msg, Longptr_t parm1, Longptr_t parm2) override;  Process message dialog box event. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGTransientFrame;  TGTransientFrame (const TGWindow *p=nullptr, const TGWindow *main=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=kVerticalFrame);  Create a transient window. ;  ; virtual void CenterOnParent (Bool_t croot=kTRUE, EPlacement pos=kCenter);  Position transient frame centered relative to the parent frame. ;  ; const TGWindow * GetMain () const;  ; TClass * IsA () const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGMsgBox.html:1043,message,message,1043,doc/master/classTGMsgBox.html,https://root.cern,https://root.cern/doc/master/classTGMsgBox.html,1,['message'],['message']
Integrability, ; Reflex::NewDelFunctions ; Reflex::NullType ; Reflex::Object ; Reflex::PrivateClass ; Reflex::PrivateEnum ; Reflex::PrivateStruct ; Reflex::PrivateUnion ; Reflex::ProtectedClass ; Reflex::ProtectedEnum ; Reflex::ProtectedStruct ; Reflex::ProtectedUnion ; Reflex::RuntimeError ; Reflex::Scope ; Reflex::Selection::AUTOSELECT ; Reflex::Selection::NODEFAULT ; Reflex::Selection::NO_SELF_AUTOSELECT ; Reflex::Selection::TRANSIENT ; Reflex::Tools ; Reflex::Type ; Reflex::TypeTemplate ; Reflex::TypedefBuilderImpl ; Reflex::UnionBuilderImpl ; Reflex::UnknownType ; Reflex::UnnamedClass ; Reflex::UnnamedEnum ; Reflex::UnnamedNamespace ; Reflex::UnnamedStruct ; Reflex::UnnamedUnion ; Reflex::VariableBuilder ; Reflex::VariableBuilderImpl ; Rgl ; Roo1DTable 1-dimensional table; Roo2DKeysPdf Two-dimensional kernel estimation p.d.f.; RooAICRegistry Registry for analytical integration codes; RooAbsAnaConvPdf Abstract Composite Convoluted PDF; RooAbsArg Abstract variable; RooAbsBinning Abstract base class for binning specification; RooAbsCache Base class for cache managers ; RooAbsCacheElement Base class for cache elements; RooAbsCachedPdf Abstract base class for cached p.d.f.s; RooAbsCachedReal Abstract base class for cached p.d.f.s; RooAbsCategory Abstract discrete variable; RooAbsCategoryLValue Abstract modifiable index variable ; RooAbsCollection Collection of RooAbsArg objects; RooAbsData Abstract data collection; RooAbsDataStore Abstract Data Storage class; RooAbsFunc Abstract real-valued function interface; RooAbsGenContext Abstract context for generating a dataset from a PDF; RooAbsHiddenReal Abstract hidden real-valued variable; RooAbsIntegrator Abstract interface for real-valued function integrators; RooAbsLValue Abstract variable; RooAbsMCStudyModule Monte Carlo study manager add-on module; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with norma,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:23238,integrat,integration,23238,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,4,['integrat'],['integration']
Integrability," ; Returns in kind the message type. Returns length of received string+4 (can be 0 if other side of connection is closed) or -1 in case of error or -4 in case a non-blocking socket would block (i.e. there is nothing to be read). ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 756 of file TSocket.cxx. ◆ Recv() [3/4]. Int_t TSocket::Recv ; (; Int_t & ; status, . Int_t & ; kind . ). virtual . Receives a status and a message type. ; Returns length of received integers, 2*sizeof(Int_t) (can be 0 if other side of connection is closed) or -1 in case of error or -4 in case a non-blocking socket would block (i.e. there is nothing to be read). ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 789 of file TSocket.cxx. ◆ Recv() [4/4]. Int_t TSocket::Recv ; (; TMessage *& ; mess). virtual . Receive a TMessage object. ; The user must delete the TMessage object. Returns length of message in bytes (can be 0 if other side of connection is closed) or -1 in case of error or -4 in case a non-blocking socket would block (i.e. there is nothing to be read) or -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 818 of file TSocket.cxx. ◆ RecvProcessIDs(). Bool_t TSocket::RecvProcessIDs ; (; TMessage * ; mess). protected . Receive a message containing process ids. ; In case the message contains process ids they are imported, the message will be deleted and the method returns kTRUE. ; Definition at line 975 of file TSocket.cxx. ◆ RecvRaw(). Int_t TSocket::RecvRaw ; (; void * ; buffer, . Int_t ; length, . ESendRecvOptions ; opt = kDefault . ). virtual . Receive a raw buffer of specified length bytes. ; Using option kPeek one can peek at incoming data. Returns number of received bytes. Returns -1 in case of error. In case of opt == kOob: -2 means EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock) -4 means EWO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:32635,message,message,32635,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['message'],['message']
Integrability," ; Returns the key object or 0 in case key was not found. If map is the owner of values, the value is deleted. ; Implements TCollection.; Definition at line 296 of file TMap.cxx. ◆ RemoveEntry(). TPair * TMap::RemoveEntry ; (; TObject * ; key). Remove (key,value) pair with key from the map. ; Returns the pair object or 0 in case the key was not found. It is caller's responsibility to delete the pair and, eventually, the key and value objects. ; Definition at line 320 of file TMap.cxx. ◆ SetOwnerKeyValue(). void TMap::SetOwnerKeyValue ; (; Bool_t ; ownkeys = kTRUE, . Bool_t ; ownvals = kTRUE . ). virtual . Set ownership for keys and values. ; Definition at line 352 of file TMap.cxx. ◆ SetOwnerValue(). void TMap::SetOwnerValue ; (; Bool_t ; enable = kTRUE). virtual . Set whether this map is the owner (enable==true) of its values. ; If it is the owner of its contents, these objects will be deleted whenever the collection itself is deleted. The objects might also be deleted or destructed when Clear is called (depending on the collection). ; Definition at line 341 of file TMap.cxx. ◆ Streamer(). void TMap::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all key/value pairs in the map to or from the I/O buffer. ; Reimplemented from TCollection.; Definition at line 361 of file TMap.cxx. ◆ StreamerNVirtual(). void TMap::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 90 of file TMap.h. ◆ Write() [1/2]. Int_t TMap::Write ; (; const char * ; name = nullptr, . Int_t ; option = 0, . Int_t ; bsize = 0 . ); const. overridevirtual . Write all objects in this map. ; By default all objects in the collection are written individually (each object gets its own key). Note, this is recursive, i.e. objects in collections in the collection are also written individually. To write all objects using a single key specify a name and set option to TObject::kSingleKey (i.e. 1). ; Reimplemented from TCollection.; Definition at line 405 of file TMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMap.html:24754,depend,depending,24754,doc/master/classTMap.html,https://root.cern,https://root.cern/doc/master/classTMap.html,1,['depend'],['depending']
Integrability," ; TMVA::Config::VariablePlotting ; TMVA::Configurable Virtual base class for all TMVA method; TMVA::CostComplexityPruneTool ; TMVA::CrossEntropy Implementation of the CrossEntropy as separation criterion; TMVA::DecisionTree implementation of a Decision Tree; TMVA::DecisionTreeNode Node for the Decision Tree ; TMVA::Event ; TMVA::Factory The factory creates all MVA methods, and performs their training and testing; TMVA::FitterBase Baseclass for fitters; TMVA::GeneticAlgorithm Genetic algorithm controller; TMVA::GeneticFitter Fitter using a Genetic Algorithm; TMVA::GeneticGenes Genes definition for genetic algorithm; TMVA::GeneticPopulation Population definition for genetic algorithm; TMVA::GeneticRange Range definition for genetic algorithm; TMVA::GiniIndex Implementation of the GiniIndex as separation criterion; TMVA::GiniIndexWithLaplace Implementation of the GiniIndexWithLaplace as separation criterion; TMVA::IFitterTarget base class for a fitter ""target""; TMVA::IMethod Method Interface; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::LogInterval Interval definition, continous and discrete; TMVA::MCFitter Fitter using Monte Carlo sampling of parameters ; TMVA::MethodANNBase Base class for TMVA ANNs; TMVA::MethodBDT Analysis of Boosted Decision Trees; TMVA::MethodBase Virtual base class for all TMVA method; TMVA::MethodBayesClassifier Friedman's BayesClassifier method ; TMVA::MethodBoost ; TMVA::MethodCFMlpANN Interface for Clermond-Ferrand artificial neural network; TMVA::MethodCFMlpANN_Utils Implementation of Clermond-Ferrand artificial neural network; TMVA::MethodCategory ; TMVA::MethodCompositeBase ; TMVA::MethodCuts Multivariate optimisation of signal efficiency; TMVA::MethodDT Analysis of Decision Trees ; TMVA::MethodFDA Function Discriminant Analysis; TMVA::MethodFisher Analysis of Fisher discriminant (Fisher or Mahalanobis approach) ; TMVA::MethodHMatrix H-Matrix method, a simple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:105437,Interface,Interface,105437,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,1,['Interface'],['Interface']
Integrability," ; TMVA::ROCCalc Class ReferenceTMVA. . Definition at line 20 of file ROCCalc.h. Public Member Functions;  ROCCalc (TH1 *mvaS, TH1 *mvaB);  ;  ~ROCCalc ();  destructor ;  ; void ApplySignalAndBackgroundStyle (TH1 *sig, TH1 *bkg, TH1 *any=nullptr);  ; Double_t GetEffSForEffBof (Double_t effBref, Double_t &effSerr);  get the signal efficiency for a particular background efficiency that will be the value of the efficiency retured (does not affect the efficiency-vs-bkg plot which is done anyway. ;  ; TH1 * GetMvaBpdf ();  ; TH1 * GetMvaSpdf ();  ; TH1 * GetPurity (Int_t nStot, Int_t nBtot);  ; TH1D * GetROC ();  get the ROC curve ;  ; Double_t GetROCIntegral ();  code to compute the area under the ROC ( rej-vs-eff ) curve ;  ; Double_t GetSignalReferenceCut ();  ; TH1 * GetSignificance (Int_t nStot, Int_t nBtot);  ; Bool_t GetStatus ();  ; void ResetStatus ();  . Private Member Functions; Double_t GetEffForRoot (Double_t theCut);  returns efficiency as function of cut ;  ; MsgLogger & Log () const;  message logger ;  ; Double_t Root (Double_t);  Root finding using Brents algorithm; taken from CERNLIB function RZERO. ;  . Private Attributes; TH1D * effBvsS;  ; Double_t fAbsTol;  absolute tolerance deviation ;  ; Int_t fCutOrientation;  +1 if larger mva value means more signal like, -1 otherwise ;  ; MsgLogger * fLogger;  ; Int_t fMaxIter;  maximum number of iterations ;  ; TH1 * fmvaB;  the input mva distributions ;  ; TH1 * fmvaBcumul;  ; TH1 * fmvaBpdf;  the normalized (and rebinned) input mva distributions ;  ; TH1 * fmvaS;  ; TH1 * fmvaScumul;  ; TH1 * fmvaSpdf;  ; UInt_t fNbins;  ; Int_t fnBtot;  ; Double_t fNevtS;  number of signal events (used in error calculation) ;  ; Int_t fnStot;  ; TH1 * fPurity;  ; Double_t fSignalCut;  MVA cut value for last demanded background rejection or signal efficiency. ;  ; TH1 * fSignificance;  ; TSpline * fSplB;  ; TSpline * fSpleffBvsS;  ; TSpline * fSplmvaCumB;  spline of cumulated mva distributions ;  ; TSpline * fSplmvaCumS;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ROCCalc.html:1250,message,message,1250,doc/master/classTMVA_1_1ROCCalc.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ROCCalc.html,1,['message'],['message']
Integrability," ; This interface kept for back compatibility It is recommended to use the other interface where one can specify also epsabs and the maximum number of points ; Definition at line 2798 of file TF1.cxx. ◆ IntegralMultiple() [2/3]. Double_t TF1::IntegralMultiple ; (; Int_t ; n, . const Double_t * ; a, . const Double_t * ; b, . Int_t ; maxpts, . Double_t ; epsrel, . Double_t ; epsabs, . Double_t & ; relerr, . Int_t & ; nfnevl, . Int_t & ; ifail . ). virtual . This function computes, to an attempted specified accuracy, the value of the integral. ; Parameters. [in]nNumber of dimensions [2,15] ; [in]a,bOne-dimensional arrays of length >= N . On entry A[i], and B[i], contain the lower and upper limits of integration, respectively. ; [in]maxptsMaximum number of function evaluations to be allowed. maxpts >= 2^n +2*n*(n+1) +1 if maxpts<minpts, maxpts is set to 10*minpts ; [in]epsrelSpecified relative accuracy. ; [in]epsabsSpecified absolute accuracy. The integration algorithm will attempt to reach either the relative or the absolute accuracy. In case the maximum function called is reached the algorithm will stop earlier without having reached the desired accuracy; [out]relerrContains, on exit, an estimation of the relative accuracy of the result. ; [out]nfnevlnumber of function evaluations performed. ; [out]ifail0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the specified value of maxpts.; 3 n<2 or n>15 . Method:; The default method used is the Genz-Mallik adaptive multidimensional algorithm using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator() to different integrators. Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class Possible methods are ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:99711,integrat,integration,99711,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['integrat'],['integration']
Integrability," ; voidTProofServ::Interrupt(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static Bool_tTProofServ::IsActive(); virtual Bool_tTApplication::IsCmdThread(); Bool_tTProofServ::IsEndMaster() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTProofServ::IsMaster() const; Bool_tTObject::IsOnHeap() const; Bool_tTProofServ::IsParallel() const; Bool_tTApplication::IsRunning() const; virtual Bool_tTObject::IsSortable() const; Bool_tTProofServ::IsTopMaster() const; Bool_tTObject::IsZombie() const; virtual voidTApplication::KeyPressed(Int_t key)SIGNAL ; virtual voidTApplication::LineProcessed(const char* line)SIGNAL ; voidTProofServ::LogToMaster(Bool_t on = kTRUE); virtual voidTApplication::Lower(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTApplication::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; static voidTApplication::NeedGraphicsLibs(); Bool_tTApplication::NoLogoOpt() const; Bool_tTApplication::NoLogOpt() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidTApplication::Open(); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TProofServLite&operator=(const TProofServLite&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTProofServ::Print(Option_t* option = """") const; virtual Long_tTApplication",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServLite.html:9729,Message,Message,9729,root/html602/TProofServLite.html,https://root.cern,https://root.cern/root/html602/TProofServLite.html,2,['Message'],['Message']
Integrability," ; voidTProofServ::Interrupt(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static Bool_tTProofServ::IsActive(); virtual Bool_tTApplication::IsCmdThread(); Bool_tTProofServ::IsEndMaster() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTProofServ::IsMaster() const; Bool_tTObject::IsOnHeap() const; Bool_tTProofServ::IsParallel() const; Bool_tTApplication::IsRunning() const; virtual Bool_tTObject::IsSortable() const; Bool_tTProofServ::IsTopMaster() const; Bool_tTObject::IsZombie() const; virtual voidTApplication::KeyPressed(Int_t key)SIGNAL ; virtual voidTApplication::LineProcessed(const char* line)SIGNAL ; voidTProofServ::LogToMaster(Bool_t on = kTRUE); virtual voidTApplication::Lower(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTApplication::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; static voidTApplication::NeedGraphicsLibs(); Bool_tTApplication::NoLogoOpt() const; Bool_tTApplication::NoLogOpt() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidTApplication::Open(); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TXProofServ&operator=(const TXProofServ&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTProofServ::Print(Option_t* option = """") const; virtual Long_tTApplication::Proc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXProofServ.html:9640,Message,Message,9640,root/html602/TXProofServ.html,https://root.cern,https://root.cern/root/html602/TXProofServ.html,2,['Message'],['Message']
Integrability," ;  ; TH1D & operator= (const TH1D &h1);  Operator =. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TH1;  ~TH1 () override;  Histogram default destructor. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Double_t &advalue) const;  Same function as above but returning also the test statistic value. ;  ; virtual Double_t AndersonDarlingTest (const TH1 *h2, Option_t *option="""") const;  Statistical test of compatibility in shape between this histogram and h2, using the Anderson-Darling 2 sample test. ;  ; void Browse (TBrowser *b) override;  Browse the Histogram object. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;  ; virtual void ClearUnderflowAndOverflow ();  Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ;  ; TObject * Clone (const char *newname="""") const override;  Make a complete copy of the underlying object. ;  ; virtual Double_t ComputeIntegral (Bool_t onlyPositive=false);  Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile.html:12012,rout,routine,12012,doc/master/classTProfile.html,https://root.cern,https://root.cern/doc/master/classTProfile.html,1,['rout'],['routine']
Integrability," ;  ; bool fUsedOnce;  Bool value to check if the function was at least called once. ;  . Private Member Functions; void CalcGaussLegendreSamplingPoints ();  Type: unsafe but fast interface filling the arrays x and w (static method) ;  ; double DoIntegral (double a, double b, const IGenFunction *func) override;  Integration surrogate method. ;  . Additional Inherited Members;  Static Protected Attributes inherited from ROOT::Math::GaussIntegrator; static bool fgAbsValue = false;  AbsValue used for the calculation of the integral. ;  . #include <Math/GaussLegendreIntegrator.h>. Inheritance diagram for ROOT::Math::GaussLegendreIntegrator:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ GaussLegendreIntegrator(). ROOT::Math::GaussLegendreIntegrator::GaussLegendreIntegrator ; (; int ; num = 10, . double ; eps = 1e-12 . ). Basic constructor of GaussLegendreIntegrator. ; @param num Number of desired points to calculate the integration. @param eps Desired relative error. ; Definition at line 23 of file GaussLegendreIntegrator.cxx. ◆ ~GaussLegendreIntegrator(). ROOT::Math::GaussLegendreIntegrator::~GaussLegendreIntegrator ; (; ). override . Default Destructor. ; Definition at line 34 of file GaussLegendreIntegrator.cxx. Member Function Documentation. ◆ CalcGaussLegendreSamplingPoints(). void ROOT::Math::GaussLegendreIntegrator::CalcGaussLegendreSamplingPoints ; (; ). private . Type: unsafe but fast interface filling the arrays x and w (static method) ; Given the number of sampling points this routine fills the arrays x and w of length num, containing the abscissa and weight of the Gauss-Legendre n-point quadrature formula.; Gauss-Legendre: W(x)=1 -1<x<1 (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}; num is the number of sampling points (>0) x and w are arrays of size num eps is the relative precision; If num<=0 or eps<=0 no action is done.; Reference: Numerical Recipes in C, Second Edition ; Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html:4956,integrat,integration,4956,doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html,1,['integrat'],['integration']
Integrability," ;  ; double getError () const;  ; double getErrorHi () const;  ; double getErrorLo () const;  ; double getValV (const RooArgSet *nset=nullptr) const override;  Return value of variable. ;  ; bool hasAsymError (bool allowZero=true) const;  ; bool hasBinning (const char *name) const override;  Returns true if variable has a binning named 'name'. ;  ; bool hasError (bool allowZero=true) const;  ; TClass * IsA () const override;  ; bool isDerived () const override;  Does value or shape of this arg depend on any other arg? ;  ; bool isFundamental () const override;  Is this object a fundamental type that can be added to a dataset? Fundamental-type subclasses override this method to return true. ;  ; virtual RooAbsArg & operator= (double newValue);  Assignment operator from a double. ;  ; void printExtras (std::ostream &os) const override;  Print extras of variable: (asymmetric) error, constant flag, limits and binning. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Detailed printing interface. ;  ; void printValue (std::ostream &os) const override;  Print value of variable. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from given stream. ;  ; void removeAsymError ();  ; void removeError ();  ; void removeMax (const char *name=nullptr);  Remove upper range limit for binning with given name. Empty name means default range. ;  ; void removeMin (const char *name=nullptr);  Remove lower range limit for binning with given name. Empty name means default range. ;  ; void removeRange (const char *name=nullptr);  Remove range limits for binning with given name. Empty name means default range. ;  ; void setAsymError (double lo, double hi);  ; void setBinning (const RooAbsBinning &binning, const char *name=nullptr);  Add given binning under name 'name' with this variable. ;  ; void setBins (Int_t nBins, const char *name=nullptr);  Create a uniform binn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:3748,interface,interface,3748,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['interface'],['interface']
Integrability, ;  ; file  rf312_multirangefit.C;   Multidimensional models: performing fits in multiple (disjoint) ranges in one or more dimensions ;  ; file  rf312_multirangefit.py;   Multidimensional models: performing fits in multiple (disjoint) ranges in one or more dimensions ;  ; file  rf313_paramranges.C;   Multidimensional models: working with parametrized ranges to define non-rectangular regions for fitting and integration ;  ; file  rf313_paramranges.py;   Multidimensional models: working with parameterized ranges to define non-rectangular regions for fitting and integration ;  ; file  rf314_paramfitrange.C;   Multidimensional models: working with parametrized ranges in a fit. ;  ; file  rf314_paramfitrange.py;   Multidimensional models: working with parameterized ranges in a fit. ;  ; file  rf315_projectpdf.C;   Multidimensional models: marginizalization of multi-dimensional pdfs through integration ;  ; file  rf315_projectpdf.py;   Multidimensional models: marginizalization of multi-dimensional pdfs through integration ;  ; file  rf316_llratioplot.C;   Multidimensional models: using the likelihood ratio technique to construct a signal enhanced one-dimensional projection of a multi-dimensional pdf ;  ; file  rf316_llratioplot.py;   Multidimensional models: using the likelihood ratio technique to construct a signal enhanced one-dimensional projection of a multi-dimensional pdf ;  ; file  rf401_importttreethx.C;   Data and categories: advanced options for importing data from ROOT TTree and THx histograms ;  ; file  rf401_importttreethx.py;   'DATA AND CATEGORIES' RooFit tutorial macro #401 ;  ; file  rf402_datahandling.C;   Data and categories: tools for manipulation of (un)binned datasets ;  ; file  rf402_datahandling.py;   Data and categories: tools for manipulation of (un)binned datasets ;  ; file  rf403_weightedevts.C;   Data and categories: using weights in unbinned datasets ;  ; file  rf403_weightedevts.py;   'DATA AND CATEGORIES' RooFit tutorial macro #403 ;  ; fi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roofit.html:9841,integrat,integration,9841,doc/master/group__tutorial__roofit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roofit.html,1,['integrat'],['integration']
Integrability, ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Attributes; Int_t _coefIdx;  Index code of the coefficient. ;  ; RooRealProxy _convPdf;  RooAbsAnaConv object implementing our coefficient. ;  ; RooSetProxy _varSet;  Not used anymore? ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _cl,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooConvCoefVar.html:48117,integrat,integration,48117,doc/master/classRooConvCoefVar.html,https://root.cern,https://root.cern/doc/master/classRooConvCoefVar.html,1,['integrat'],['integration']
Integrability," ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Attributes; RooLinkedList _configSets;  List of configuration sets for individual integration methods. ;  ; double _epsAbs;  Absolute precision. ;  ; double _epsRel;  Relative precision. ;  ; RooCategory _method1D;  Selects integration method for 1D integrals. ;  ; RooCategory _method1DOpen;  Selects integration method for open ended 1D integrals. ;  ; RooCategory _method2D;  Selects integration method for 2D integrals. ;  ; RooCategory _method2DOpen;  Selects integration method for open ended 2D integrals. ;  ; RooCategory _methodND;  Selects integration method for ND integrals. ;  ; RooCategory _methodNDOpen;  Selects integration method for open ended ND integrals. ;  ; bool _printEvalCounter;  Flag to control printing of function evaluation counter. ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumIntConfig.html:13067,integrat,integration,13067,doc/master/classRooNumIntConfig.html,https://root.cern,https://root.cern/doc/master/classRooNumIntConfig.html,1,['integrat'],['integration']
Integrability," ;  ; static void GetLocalServer (TString &dsrv);  Extract LOCALDATASERVER info in 'dsrv'. ;  ; static Float_t GetMemHWM ();  MemHWM getter. ;  ; static Float_t GetMemStop ();  MemStop getter. ;  ; static Long_t GetResMemMax ();  ResMemMax getter. ;  ; static Long_t GetVirtMemMax ();  VirtMemMax getter. ;  ; static Bool_t IsActive ();  Static function that returns kTRUE in case we are a PROOF server. ;  ; static Int_t RegisterDataSets (TList *in, TList *out, TDataSetManager *dsm, TString &e);  Register TFileCollections in 'out' as datasets according to the rules in 'in'. ;  ; static void ResolveKeywords (TString &fname, const char *path=0);  Replace <ord>, <user>, <u>, <group>, <stag>, <qnum>, <file>, <rver> and <build> placeholders in fname. ;  ; static FILE * SetErrorHandlerFile (FILE *ferr);  Set the file stream where to log (default stderr). ;  ; static void SetLastEntry (Long64_t lastentry);  Set the last entry before exception. ;  ; static void SetLastMsg (const char *lastmsg);  Set the message to be sent back in case of exceptions. ;  ; static TProofServ * This ();  Static function returning pointer to global object gProofServ. ;  ;  Static Public Member Functions inherited from TApplication; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void CreateApplication ();  Static function used to create a default application environment. ;  ; static const char * DeclFileName ();  ; static Longptr_t ExecuteFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Execute a file containing a C++ macro (static method). ;  ; static TList * GetApplications ();  Static method returning the list of available applications. ;  ; static void NeedGraphicsLibs ();  Static method. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:20252,message,message,20252,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,2,['message'],['message']
Integrability," ;  ; template<class Element1 , class Element2 > ; Bool_t AreCompatible (const TMatrixT< Element1 > &m, const TVectorT< Element2 > &v, Int_t verbose=0);  Check if m and v are both valid and have compatible shapes for M * v. ;  ; template<class Element1 , class Element2 > ; Bool_t AreCompatible (const TMatrixTBase< Element1 > &m1, const TMatrixTBase< Element2 > &m2, Int_t verbose=0);  Check that matrice sm1 and m2 areboth valid and have identical shapes . ;  ; template<class Element1 , class Element2 > ; Bool_t AreCompatible (const TVectorT< Element1 > &v, const TMatrixT< Element2 > &m, Int_t verbose=0);  Check if m and v are both valid and have compatible shapes for v * M. ;  ; template<class Element1 , class Element2 > ; Bool_t AreCompatible (const TVectorT< Element1 > &v1, const TVectorT< Element2 > &v2, Int_t verbose=0);  Check if v1 and v2 are both valid and have the same shape. ;  ; template<class Element > ; void AtMultB (const Element *const ap, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp);  Elementary routine to calculate matrix multiplication A^T*B. ;  ; template<class Element > ; void Compare (const TMatrixTBase< Element > &m1, const TMatrixTBase< Element > &m2);  Compare two matrices and print out the result of the comparison. ;  ; template<class Element > ; void Compare (const TVectorT< Element > &source1, const TVectorT< Element > &source2);  Compare two vectors and print out the result of the comparison. ;  ; template<class Element > ; Element Dot (const TVectorT< Element > &source1, const TVectorT< Element > &source2);  return inner-produvt v1 . v2 ;  ; template<class Element > ; Element E2Norm (const TMatrixTBase< Element > &m1, const TMatrixTBase< Element > &m2);  Square of the Euclidean norm of the difference between two matrices. ;  ; template<class Element > ; TMatrixT< Element > & ElementDiv (TMatrixT< Element > &target, const TMatrixT< Element > &source);  Divide target by the source, element-by-element. ;  ; temp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMatrixTAutoloadOps.html:4057,rout,routine,4057,doc/master/namespaceTMatrixTAutoloadOps.html,https://root.cern,https://root.cern/doc/master/namespaceTMatrixTAutoloadOps.html,1,['rout'],['routine']
Integrability," ;  ; template<class F , class Cond = validMapReturnCond<F>> ; auto MapImpl (F func, unsigned nTimes) -> std::vector< InvokeResult_t< F > >;  Execute a function without arguments several times in parallel. ;  ; void ReplyToFuncResult (TSocket *s);  Reply to a worker who just sent a result. ;  ; void ReplyToIdle (TSocket *s);  Reply to a worker who is idle. ;  ; void Reset ();  Reset TProcessExecutor's state. ;  ;  Private Member Functions inherited from TMPClient;  TMPClient (const TMPClient &)=delete;  ;  TMPClient (unsigned nWorkers=0);  Class constructor. ;  ;  ~TMPClient ();  Class destructor. ;  ; template<class T > ; unsigned Broadcast (unsigned code, const std::vector< T > &objs);  Send a message with a different object to each server. ;  ; template<class T > ; unsigned Broadcast (unsigned code, std::initializer_list< T > &objs);  Send a message with a different object to each server. ;  ; template<class T > ; unsigned Broadcast (unsigned code, T obj, unsigned nMessages=0);  Send a message containing code and obj to each worker, up to a maximum number of nMessages workers. ;  ; unsigned Broadcast (unsigned code, unsigned nMessages=0);  Send a message with the specified code to at most nMessages workers. ;  ; void DeActivate (TSocket *s);  DeActivate a certain socket. ;  ; bool Fork (TMPWorker &server);  This method forks the ROOT session into fNWorkers children processes. ;  ; bool GetIsParent () const;  ; TMonitor & GetMonitor ();  ; unsigned GetNWorkers () const;  ; void HandleMPCode (MPCodeBufPair &msg, TSocket *sender);  Handle messages containing an EMPCode. ;  ; TMPClient & operator= (const TMPClient &)=delete;  ; void ReapWorkers ();  Wait on worker processes and remove their pids from fWorkerPids. ;  ; void Remove (TSocket *s);  Remove a certain socket from the monitor. ;  ; void SetNWorkers (unsigned n);  Set the number of workers that will be spawned by the next call to Fork() ;  . Private Attributes; unsigned fNProcessed;  number of arguments alrea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TProcessExecutor.html:10204,message,message,10204,doc/v632/classROOT_1_1TProcessExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TProcessExecutor.html,2,['message'],['message']
Integrability," ;  ; virtual Color_t GetFillColor () const;  Return the fill area color. ;  ; virtual Style_t GetFillStyle () const;  Return the fill area style. ;  ; virtual Bool_t IsTransparent () const;  ; virtual void Modify ();  Change current fill area attributes if necessary. ;  ; virtual void ResetAttFill (Option_t *option="""");  Reset this fill attributes to default values. ;  ; virtual void SaveFillAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1001);  Save fill attributes as C++ statement(s) on output stream out. ;  ; virtual void SetFillAttributes ();  Invoke the DialogCanvas Fill attributes. ;  ; virtual void SetFillColor (Color_t fcolor);  Set the fill area color. ;  ; virtual void SetFillColorAlpha (Color_t fcolor, Float_t falpha);  Set a transparent fill color. ;  ; virtual void SetFillStyle (Style_t fstyle);  Set the fill area style. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAtt3D;  TAtt3D ();  ; virtual ~TAtt3D ();  ; virtual void Sizeof3D () const;  Set total size of this 3D object (used by X3D interface). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TGeoVolumeAssembly * MakeAssemblyFromVolume (TGeoVolume *vol);  Make a clone of volume VOL but which is an assembly. ;  ;  Static Public Member Functions inherited from TGeoVolume; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void CreateDummyMedium ();  Create a dummy medium. ;  ; static const char * DeclFileName ();  ; static TGeoMedium * DummyMedium ();  ; static TGeoVolume * Import (const char *filename, const char *name="""", Option_t *option="""");  Import a volume from a file. ;  ;  Static Public Member Functions inherited from",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeAssembly.html:24338,interface,interface,24338,doc/master/classTGeoVolumeAssembly.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeAssembly.html,1,['interface'],['interface']
Integrability," ;  ; virtual Color_t GetFillColor () const;  Return the fill area color. ;  ; virtual Style_t GetFillStyle () const;  Return the fill area style. ;  ; virtual Bool_t IsTransparent () const;  ; virtual void Modify ();  Change current fill area attributes if necessary. ;  ; virtual void ResetAttFill (Option_t *option="""");  Reset this fill attributes to default values. ;  ; virtual void SaveFillAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1001);  Save fill attributes as C++ statement(s) on output stream out. ;  ; virtual void SetFillAttributes ();  Invoke the DialogCanvas Fill attributes. ;  ; virtual void SetFillColor (Color_t fcolor);  Set the fill area color. ;  ; virtual void SetFillColorAlpha (Color_t fcolor, Float_t falpha);  Set a transparent fill color. ;  ; virtual void SetFillStyle (Style_t fstyle);  Set the fill area style. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAtt3D;  TAtt3D ();  ; virtual ~TAtt3D ();  ; virtual void Sizeof3D () const;  Set total size of this 3D object (used by X3D interface). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static void PaintH3 (TH1 *h, Option_t *option);  Paint 3-d histogram h with marker3dboxes. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMarker3DBox.html:12354,interface,interface,12354,doc/master/classTMarker3DBox.html,https://root.cern,https://root.cern/doc/master/classTMarker3DBox.html,1,['interface'],['interface']
Integrability," ;  ; virtual Color_t GetFillColor () const;  Return the fill area color. ;  ; virtual Style_t GetFillStyle () const;  Return the fill area style. ;  ; virtual Bool_t IsTransparent () const;  ; virtual void Modify ();  Change current fill area attributes if necessary. ;  ; virtual void ResetAttFill (Option_t *option="""");  Reset this fill attributes to default values. ;  ; virtual void SaveFillAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1001);  Save fill attributes as C++ statement(s) on output stream out. ;  ; virtual void SetFillAttributes ();  Invoke the DialogCanvas Fill attributes. ;  ; virtual void SetFillColor (Color_t fcolor);  Set the fill area color. ;  ; virtual void SetFillColorAlpha (Color_t fcolor, Float_t falpha);  Set a transparent fill color. ;  ; virtual void SetFillStyle (Style_t fstyle);  Set the fill area style. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAtt3D;  TAtt3D ();  ; virtual ~TAtt3D ();  ; virtual void Sizeof3D () const;  Set total size of this 3D object (used by X3D interface). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TGeoVolume; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void CreateDummyMedium ();  Create a dummy medium. ;  ; static const char * DeclFileName ();  ; static TGeoMedium * DummyMedium ();  ; static TGeoVolume * Import (const char *filename, const char *name="""", Option_t *option="""");  Import a volume from a file. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeMulti.html:32032,interface,interface,32032,doc/master/classTGeoVolumeMulti.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeMulti.html,1,['interface'],['interface']
Integrability," ;  ; virtual Color_t GetFillColor () const;  Return the fill area color. ;  ; virtual Style_t GetFillStyle () const;  Return the fill area style. ;  ; virtual Bool_t IsTransparent () const;  ; virtual void Modify ();  Change current fill area attributes if necessary. ;  ; virtual void ResetAttFill (Option_t *option="""");  Reset this fill attributes to default values. ;  ; virtual void SaveFillAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1001);  Save fill attributes as C++ statement(s) on output stream out. ;  ; virtual void SetFillAttributes ();  Invoke the DialogCanvas Fill attributes. ;  ; virtual void SetFillColor (Color_t fcolor);  Set the fill area color. ;  ; virtual void SetFillColorAlpha (Color_t fcolor, Float_t falpha);  Set a transparent fill color. ;  ; virtual void SetFillStyle (Style_t fstyle);  Set the fill area style. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAtt3D;  TAtt3D ();  ; virtual ~TAtt3D ();  ; virtual void Sizeof3D () const;  Set total size of this 3D object (used by X3D interface). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only fl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTShape.html:13685,interface,interface,13685,doc/master/classTShape.html,https://root.cern,https://root.cern/doc/master/classTShape.html,1,['interface'],['interface']
Integrability," ;  ; virtual Color_t GetFillColor () const;  Return the fill area color. ;  ; virtual Style_t GetFillStyle () const;  Return the fill area style. ;  ; virtual Bool_t IsTransparent () const;  ; virtual void Modify ();  Change current fill area attributes if necessary. ;  ; virtual void ResetAttFill (Option_t *option="""");  Reset this fill attributes to default values. ;  ; virtual void SaveFillAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1001);  Save fill attributes as C++ statement(s) on output stream out. ;  ; virtual void SetFillAttributes ();  Invoke the DialogCanvas Fill attributes. ;  ; virtual void SetFillColor (Color_t fcolor);  Set the fill area color. ;  ; virtual void SetFillColorAlpha (Color_t fcolor, Float_t falpha);  Set a transparent fill color. ;  ; virtual void SetFillStyle (Style_t fstyle);  Set the fill area style. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAtt3D;  TAtt3D ();  ; virtual ~TAtt3D ();  ; virtual void Sizeof3D () const;  Set total size of this 3D object (used by X3D interface). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void CreateDummyMedium ();  Create a dummy medium. ;  ; static const char * DeclFileName ();  ; static TGeoMedium * DummyMedium ();  ; static TGeoVolume * Import (const char *filename, const char *name="""", Option_t *option="""");  Import a volume from a file. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:35984,interface,interface,35984,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['interface'],['interface']
Integrability," ;  ; virtual TVirtualIndex * BuildIndex (const TTree *T, const char *majorname, const char *minorname)=0;  ; virtual TTree * CopyTree (const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)=0;  ; virtual Long64_t DrawScript (const char *wrapperPrefix, const char *macrofilename, const char *cutfilename, Option_t *option, Long64_t nentries, Long64_t firstentry)=0;  ; virtual Long64_t DrawSelect (const char *varexp, const char *selection, Option_t *option, Long64_t nentries, Long64_t firstentry)=0;  ; virtual Int_t Fit (const char *formula, const char *varexp, const char *selection, Option_t *option, Option_t *goption, Long64_t nentries, Long64_t firstentry)=0;  ; virtual Int_t GetDimension () const =0;  ; virtual Long64_t GetEntries (const char *)=0;  ; virtual TH1 * GetHistogram () const =0;  ; virtual Int_t GetNfill () const =0;  ; virtual TTreeFormula * GetSelect () const =0;  ; virtual Long64_t GetSelectedRows () const =0;  ; virtual TSelector * GetSelector () const =0;  ; virtual TSelector * GetSelectorFromFile () const =0;  ; virtual Double_t * GetV1 () const =0;  ; virtual Double_t * GetV2 () const =0;  ; virtual Double_t * GetV3 () const =0;  ; virtual Double_t * GetV4 () const =0;  ; virtual Double_t * GetVal (Int_t) const =0;  ; virtual TTreeFormu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualTreePlayer.html:963,wrap,wrapperPrefix,963,doc/master/classTVirtualTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTVirtualTreePlayer.html,1,['wrap'],['wrapperPrefix']
Integrability," ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:39748,message,message,39748,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,4,['message'],['message']
Integrability," ;  ; void Copy (TAttMarker &attmarker) const;  Copy this marker attributes to a new TAttMarker. ;  ; virtual Color_t GetMarkerColor () const;  Return the marker color. ;  ; virtual Size_t GetMarkerSize () const;  Return the marker size. ;  ; virtual Style_t GetMarkerStyle () const;  Return the marker style. ;  ; virtual void Modify ();  Change current marker attributes if necessary. ;  ; virtual void ResetAttMarker (Option_t *toption="""");  Reset this marker attributes to the default values. ;  ; virtual void SaveMarkerAttributes (std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t sizdef=1);  Save line attributes as C++ statement(s) on output stream out. ;  ; virtual void SetMarkerAttributes ();  Invoke the DialogCanvas Marker attributes. ;  ; virtual void SetMarkerColorAlpha (Color_t mcolor, Float_t malpha);  Set a transparent marker color. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAtt3D;  TAtt3D ();  ; virtual ~TAtt3D ();  ; virtual void Sizeof3D () const;  Set total size of this 3D object (used by X3D interface). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TAttBBox;  TAttBBox ();  ; virtual ~TAttBBox ();  ; Float_t * AssertBBox ();  ; Float_t * GetBBox ();  ; Bool_t GetBBoxOK () const;  ; TAttBBox & operator= (const TAttBBox &tab);  ; void ResetBBox ();  ; void SetupBBoxCube (Float_t extent, Float_t x, Float_t y, Float_t z);  Setup bounding box as cube with given extent and center position. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TEvePointSelectorConsumer;  TEvePointSelectorConsumer (ETreeVarType_e cs=kTVT_XYZ);  ; virtual ~TEvePointSelectorConsumer ();  ; ETreeVarType_e GetSourceCS () const;  ; void SetSourceCS (ETreeVarType_e cs);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveLine.html:32434,interface,interface,32434,doc/master/classTEveLine.html,https://root.cern,https://root.cern/doc/master/classTEveLine.html,6,['interface'],['interface']
Integrability," ;  ; void MapSubwindows () override;  map sub windows ;  ; void MapWindow () override;  map window ;  ; void Move (Int_t x, Int_t y) override;  Move frame. ;  ; void MoveResize (Int_t x, Int_t y, UInt_t w=0, UInt_t h=0) override;  Move and/or resize the frame. ;  ; virtual void ProcessedConfigure (Event_t *event);  ; virtual void ProcessedEvent (Event_t *event);  ; virtual void ReallyDelete ();  ; void RemoveInput (UInt_t emask);  Remove events specified in emask from the events the frame should handle. ;  ; void ReparentWindow (const TGWindow *p, Int_t x=0, Int_t y=0) override;  Reparent window, make p the new parent and position the window at position (x,y) in new parent. ;  ; virtual void Resize (TGDimension size);  Resize the frame. ;  ; void Resize (UInt_t w=0, UInt_t h=0) override;  Resize the frame. ;  ; void SaveUserColor (std::ostream &out, Option_t *);  Save a user color in a C++ macro file - used in SavePrimitive(). ;  ; virtual void SendMessage (const TGWindow *w, Longptr_t msg, Longptr_t parm1, Longptr_t parm2);  Send message (i.e. ;  ; void SetDNDSource (Bool_t onoff);  ; void SetDNDTarget (Bool_t onoff);  ; virtual void SetDragType (Int_t type);  SetDragType. ;  ; void SetDrawOption (Option_t *="""") override;  Set drawing option for object. ;  ; virtual void SetDropType (Int_t type);  SetDropType. ;  ; void SetEditable (Bool_t) override;  ; void SetFrameElement (TGFrameElement *fe);  ; virtual void SetHeight (UInt_t h);  ; virtual void SetMaxHeight (UInt_t h);  ; virtual void SetMaxWidth (UInt_t w);  ; virtual void SetMinHeight (UInt_t h);  ; virtual void SetMinWidth (UInt_t w);  ; virtual void SetSize (const TGDimension &s);  ; virtual void SetWidth (UInt_t w);  ; virtual void SetX (Int_t x);  ; virtual void SetY (Int_t y);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UnmapWindow () override;  unmap window ;  ;  Public Member Functions inherited from TGWindow;  TGWindow (const TGWindow *p=nullptr, Int_t x=0, Int_t y=0, UIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEdit.html:20401,message,message,20401,doc/master/classTGTextEdit.html,https://root.cern,https://root.cern/doc/master/classTGTextEdit.html,1,['message'],['message']
Integrability," ;  CBasketInfo;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderA simple, robust and fast interface to read values from ROOT colmnar datasets such as TTree, TChain or TNtuple ;  CIterator_tIterate through the entries of a TTree ;  ►CTTreeReaderArrayAn interface for reading collections stored in ROOT columnar datasets ;  CIterator_tRandom access iterator to the elements of a TTreeReaderArray ;  CTTreeReaderValueAn interface for reading values stored in ROOT columnar datasets ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes into the TreeViewer listview container ;  CTTVRecordI/O classes for TreeViewer session handling ;  CTTVSessionI/O classes for TreeViewer session handling ;  CTUDPSocket;  CTUnfoldAn algorithm to unfold distributions from detector to truth level ;  CTUnfoldBinningBinning schemes for use with the unfolding algorithm TUnfoldDensity ;  CTUnfoldBinningXMLXML interfate to binning schemes, for use with the unfolding algorithm TUnfoldDensity ;  CTUnfoldDensityAn algorithm to unfold distributions from detector to truth level ;  CTUnfoldSysAn algorithm to unfold distributions from detector to truth level, with background subtraction and propagation of systematic uncertainties ;  CTUnixSystem;  CTUnuranTUnuran class ;  CTUnuranBaseDistTUnuranBaseDist,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:218243,interface,interface,218243,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['interface'],['interface']
Integrability," ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ;  CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ;  CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ;  CSamplingSummary;  CSamplingSummaryLookup;  CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step ;  CSimpleIntervalSimpleInterval is a concrete implementation of the ConfInterval interface ;  CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ;  CSPlotThis class calculates sWeights used to create an sPlot ;  CTestStatisticTestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class ;  CTestStatSamplerTestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions ;  CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ;  CToyMCPayload;  CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ;  CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ;  CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ;  CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ;  ►NROOTNamespace for new ROOT classes and functions ;  NCocoaTutorials;  ►NDetail;  ►NRDF;  ►NCustomColExtraArgs;  CNone;  CSlot;  CSlotAndEntry;  CRCustomColumn;  CRCustomColumnBase;  CRFilter;  CRFilterBase;  CRJittedCustomColumnA wrapper around a concrete RCustomColumn, which forwards all calls to it RJittedCustomColumn is a placehol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/namespaces.html:15949,interface,interface,15949,doc/v616/namespaces.html,https://root.cern,https://root.cern/doc/v616/namespaces.html,1,['interface'],['interface']
Integrability," ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ;  CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ;  CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ;  CSamplingSummary;  CSamplingSummaryLookup;  CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step ;  CSimpleIntervalSimpleInterval is a concrete implementation of the ConfInterval interface ;  CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ;  CSPlotThis class calculates sWeights used to create an sPlot ;  CTestStatisticTestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class ;  CTestStatSamplerTestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions ;  CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ;  CToyMCPayload;  CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ;  CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ;  CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ;  CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ;  ►NROOTNamespace for new ROOT classes and functions ;  ►NDetail;  ►NRDF;  CRCustomColumn;  CRCustomColumnBase;  CRFilter;  CRFilterBase;  CRJittedFilterA wrapper around a concrete RFilter, which forwards all calls to it RJittedFilter is the type of the node returned by jitted Filter calls: the concrete filter can be created and set at a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:11583,interface,interface,11583,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['interface'],['interface']
Integrability," ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ;  CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ;  CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ;  CSamplingSummary;  CSamplingSummaryLookup;  CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step ;  CSimpleIntervalSimpleInterval is a concrete implementation of the ConfInterval interface ;  CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ;  CSPlotThis class calculates sWeights used to create an sPlot ;  CTestStatisticTestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class ;  CTestStatSamplerTestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions ;  CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ;  CToyMCPayload;  CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ;  CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ;  CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ;  CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ;  ►NROOTNamespace for new ROOT classes and functions ;  ►NDetail;  ►NRDF;  ►NCustomColExtraArgs;  CNone;  CSlot;  CSlotAndEntry;  CRCustomColumn;  CRCustomColumnBase;  CRFilter;  CRFilterBase;  CRJittedCustomColumnA wrapper around a concrete RCustomColumn, which forwards all calls to it RJittedCustomColumn is a placeholder that is put in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:13049,interface,interface,13049,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['interface'],['interface']
Integrability, ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ;  CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ;  CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ;  CSamplingSummary;  CSamplingSummaryLookup;  CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step ;  CSimpleIntervalSimpleInterval is a concrete implementation of the ConfInterval interface ;  CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ;  CSPlotThis class calculates sWeights used to create an sPlot ;  CTestStatisticTestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class ;  CTestStatSamplerTestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions ;  CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ;  CToyMCPayload;  CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ;  CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ;  CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ;  CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ;  ►NROOTNamespace for new ROOT classes and functions ;  ►NDetail;  ►NTDF;  CTCustomColumn;  CTCustomColumnBase;  CTFilter;  CTFilterBase;  CTLoopManager;  CTRange;  CTRangeBase;  CTBranchProxyBase class for all the proxy object ;  ►CTCollectionProxyInfo;  CAddress;  CEnvironSmall helper to save proxy environment in the event of recursive,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:9837,interface,interface,9837,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['interface'],['interface']
Integrability, ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ;  CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ;  CSamplingDistributionThis class simply holds a sampling distribution of some test statistic ;  CSamplingSummary;  CSamplingSummaryLookup;  CSequentialProposalClass implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step ;  CSimpleIntervalSimpleInterval is a concrete implementation of the ConfInterval interface ;  CSimpleLikelihoodRatioTestStatTestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood ;  CSPlotThis class calculates sWeights used to create an sPlot ;  CTestStatisticTestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class ;  CTestStatSamplerTestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions ;  CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ;  CToyMCPayload;  CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ;  CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ;  CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ;  CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ;  ►NROOTNamespace for new ROOT classes and functions ;  ►NDetail;  ►NTDF;  ►NTCCHelperTypes;  CTNothing;  CTSlot;  CTSlotAndEntry;  CTCustomColumn;  CTCustomColumnBase;  CTFilter;  CTFilterBase;  ►CTLoopManager;  CTCallback;  CTOneTimeCallback;  CTRange;  CTRangeBase;  CTTakeRealTypes;  CCallableTraitsImplExtract types from the signature,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:9837,interface,interface,9837,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['interface'],['interface']
Integrability," ;  CTRFunctionImportThis is a class to pass functions from ROOT to R ;  ►CTRInterface ;  CBinding;  CTRObjectThis is a class to get ROOT's objects from R's objects ;  ►NTF1Helper;  CTGradientParFunctionFunction class representing the derivative with respect a parameter of a given TF1 ;  ►Nv5;  CTF1Data;  CTFormulaThe FORMULA class (ROOT version 5) ;  CTFormulaPrimitiveThe Formula Primitive class ;  CTOperOffset;  CTExecutorThis class defines an interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTGenericClassInfo;  CTPoolManagerA manager for the scheduler behind ROOT multithreading operations ;  CTProcessExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTRWSpinLock;  ►CTSchemaRule;  CTSources;  ►CTSeqA pseudo container class which is a generator of indices ;  Citerator;  CTSpinMutexA spin mutex class which respects the STL interface for mutexes ;  CTThreadedObjectA wrapper to make object instances thread private, lazily ;  CTThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time ;  CTTreeProcessorMPThis class provides an interface to process a TTree dataset in parallel with multi-process technology ;  CTTreeProcessorMTA class to process the entries of a TTree in parallel ;  ►NROOTwriter;  CROOTwriter;  ►NstdSTL namespace ;  ►N__ROOT;  ►Ntest;  Ctest;  ►NTMath;  CLimits;  ►NTMVAAbstract ClassifierFactory template that handles arbitrary types ;  ►NDNN;  CBatchEncapsulates one mini-batch ;  CClassificationSettingsSettings for classificationused to distinguish between different function signatures ;  CLayerLayer defines the layout of a layer ;  CLayerDataLayerData holds the data of one layer ;  CMeanVariance;  CNetNeural net ;  CSettingsSettings for the training of the neural net ;  CSteepestSteepest Gradient Descent a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:67427,interface,interface,67427,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['interface'],['interface']
Integrability," << "" represents a slice in "" << sliceSetTmp << std::endl ;; 1929 }; 1930 sliceSet.add(sliceSetTmp) ;; 1931 }; 1932 } else {; 1933 makeProjectionSet(frame->getPlotVar(),frame->getNormVars(),projectedVars,true) ;; 1934 }; 1935 ; 1936 cxcoutD(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") projectedVars = "" << projectedVars << "" sliceSet = "" << sliceSet << std::endl ;; 1937 ; 1938 ; 1939 RooArgSet* projDataNeededVars = nullptr ;; 1940 // Take out data-projected dependents from projectedVars; 1941 if (o.projData) {; 1942 projDataNeededVars = projectedVars.selectCommon(projDataVars);; 1943 projectedVars.remove(projDataVars,true,true) ;; 1944 }; 1945 ; 1946 // Get the plot variable and remember its original value; 1947 auto* plotVar = static_cast<RooRealVar*>(frame->getPlotVar());; 1948 double oldPlotVarVal = plotVar->getVal();; 1949 ; 1950 // Inform user about projections; 1951 if (!projectedVars.empty()) {; 1952 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 1953 << "" integrates over variables "" << projectedVars; 1954 << (o.projectionRangeName?Form("" in range %s"",o.projectionRangeName):"""") << std::endl;; 1955 }; 1956 if (projDataNeededVars && !projDataNeededVars->empty()) {; 1957 coutI(Plotting) << ""RooAbsReal::plotOn("" << GetName() << "") plot on "" << plotVar->GetName(); 1958 << "" averages using data variables "" << *projDataNeededVars << std::endl ;; 1959 }; 1960 ; 1961 // Create projection integral; 1962 RooArgSet* projectionCompList = nullptr ;; 1963 ; 1964 RooArgSet deps;; 1965 getObservables(frame->getNormVars(), deps) ;; 1966 deps.remove(projectedVars,true,true) ;; 1967 if (projDataNeededVars) {; 1968 deps.remove(*projDataNeededVars,true,true) ;; 1969 }; 1970 deps.remove(*plotVar,true,true) ;; 1971 deps.add(*plotVar) ;; 1972 ; 1973 // Now that we have the final set of dependents, call checkObservables(); 1974 ; 1975 // WVE take out conditional observables; 1976 if (checkObservables(&deps)) {; 1977 coutE(Plotting) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:86256,integrat,integrates,86256,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['integrat'],['integrates']
Integrability," << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFixedProdPdf.html:58220,message,messages,58220,doc/master/classRooFixedProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooFixedProdPdf.html,3,['message'],['messages']
Integrability," << nslots << "" threads"" << std::endl;; auto h1 = df1.DefineSlot(""DNN_Value"", SofieFunctor<7, TMVA_SOFIE_Higgs_trained_model::Session>(nslots),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Histo1D({""h_sig"", """", 100, 0, 1}, ""DNN_Value"");; ; ROOT::RDataFrame df2(""bkg_tree"", inputFile);; nslots = df2.GetNSlots();; auto h2 = df2.DefineSlot(""DNN_Value"", SofieFunctor<7, TMVA_SOFIE_Higgs_trained_model::Session>(nslots),; {""m_jj"", ""m_jjj"", ""m_lv"", ""m_jlv"", ""m_bb"", ""m_wbb"", ""m_wwbb""}); .Histo1D({""h_bkg"", """", 100, 0, 1}, ""DNN_Value"");; ; h1->SetLineColor(kRed);; h2->SetLineColor(kBlue);; ; auto c1 = new TCanvas();; gStyle->SetOptStat(0);; ; h2->DrawClone();; h1->DrawClone(""SAME"");; c1->BuildLegend();; ; }; R__ADD_INCLUDE_PATH#define R__ADD_INCLUDE_PATH(PATH)Definition Rtypes.h:497; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; SOFIEHelpers.hxx; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8C.html:2536,interface,interface,2536,doc/master/TMVA__SOFIE__RDataFrame_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8C.html,1,['interface'],['interface']
Integrability," <CPPAnaIntExpression> is the C++ expression that calculates that; integral. Skeleton code for internal event generation is added; if hasIntGen is true. Bool_t makeFunction(const char* name, const char* realArgNames = 0, const char* catArgNames = 0, const char* expresion = ""1.0"", Bool_t hasAnaInt = kFALSE, const char* intExpression = 0); Write code for a RooAbsReal implementation with class name 'name',; taking RooAbsReal arguments with names listed in argNames and; RooAbsCategory arguments with names listed in catArgNames as; constructor arguments (use a comma separated list for multiple; arguments). The initial value expression is taken to be; 'expression' which can be any one-line C++ expression in terms of; variables that occur in 'vars'. Skeleton code for handling of; analytical integrals is added if hasAnaInt is true. You can add; optional expressions for analytical integrals to be advertised by; your class in the syntax; ""<intObsName>:<CPPAnaIntExpression>;<intObsName,intObsName>:<CPPAnaIntExpression>""; where <intObsName> a name of the observable integrated over and; <CPPAnaIntExpression> is the C++ expression that calculates that; integral. Bool_t makeClass(const char* className, const char* name, const char* realArgNames = 0, const char* catArgNames = 0, const char* expression = ""1.0"", Bool_t hasAnaInt = kFALSE, Bool_t hasIntGen = kFALSE, const char* intExpression = 0); Write code for a 'baseName' implementation with class name 'className',; taking RooAbsReal arguments with names listed in argNames and; RooAbsCategory arguments with names listed in catArgNames as; constructor arguments (use a comma separated list for multiple; arguments). The initial value expression is taken to be; 'expression' which can be any one-line C++ expression in terms of; variables that occur in 'vars'. Skeleton code for handling of; analytical integrals is added if hasAnaInt is true. You can add; optional expressions for analytical integrals to be advertised by; your class in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooClassFactory.html:15621,integrat,integrated,15621,root/html526/RooClassFactory.html,https://root.cern,https://root.cern/root/html526/RooClassFactory.html,5,['integrat'],['integrated']
Integrability," <atomic>; 42 ; 43#include ""RtypesCore.h""; 44 ; 45#include ""TString.h""; 46 ; 47namespace TMVA {; 48 ; 49 typedef UInt_t TMVAVersion_t;; 50 ; 51 class MsgLogger;; 52 ; 53 // message types for MsgLogger; 54 // define outside of Types class to facilite access; 55 enum EMsgType {; 56 kDEBUG = 1,; 57 kVERBOSE = 2,; 58 kINFO = 3,; 59 kWARNING = 4,; 60 kERROR = 5,; 61 kFATAL = 6,; 62 kSILENT = 7,; 63 kHEADER = 8; 64 };; 65 ; 66 enum HistType { kMVAType = 0, kProbaType = 1, kRarityType = 2, kCompareType = 3 };; 67 ; 68 //Variable Importance type; 69 enum VIType {kShort=0,kAll=1,kRandom=2};; 70 ; 71 class Types {; 72 ; 73 public:; 74 ; 75 // available MVA methods; 76 enum EMVA {; 77 kVariable = 0,; 78 kCuts ,; 79 kLikelihood ,; 80 kPDERS ,; 81 kHMatrix ,; 82 kFisher ,; 83 kKNN ,; 84 kCFMlpANN ,; 85 kTMlpANN ,; 86 kBDT ,; 87 kDT ,; 88 kRuleFit ,; 89 kSVM ,; 90 kMLP ,; 91 kBayesClassifier,; 92 kFDA ,; 93 kBoost ,; 94 kPDEFoam ,; 95 kLD ,; 96 kPlugins ,; 97 kCategory ,; 98 kDNN ,; 99 kDL ,; 100 kPyRandomForest ,; 101 kPyAdaBoost ,; 102 kPyGTB ,; 103 kPyKeras ,; 104 kPyTorch ,; 105 kC50 ,; 106 kRSNNS ,; 107 kRSVM ,; 108 kRXGB ,; 109 kCrossValidation,; 110 kMaxMethod; 111 };; 112 ; 113 // available variable transformations; 114 enum EVariableTransform {; 115 kIdentity = 0,; 116 kDecorrelated,; 117 kNormalized,; 118 kPCA,; 119 kRearranged,; 120 kGauss,; 121 kUniform,; 122 kMaxVariableTransform; 123 };; 124 ; 125 // type of analysis; 126 enum EAnalysisType {; 127 kClassification = 0,; 128 kRegression,; 129 kMulticlass,; 130 kNoAnalysisType,; 131 kMaxAnalysisType; 132 };; 133 ; 134 enum ESBType {; 135 kSignal = 0, ///< Never change this number - it is elsewhere assumed to be zero !; 136 kBackground,; 137 kSBBoth,; 138 kMaxSBType,; 139 kTrueType; 140 };; 141 ; 142 enum ETreeType {; 143 kTraining = 0,; 144 kTesting,; 145 kMaxTreeType, ///< also used as temporary storage for trees not yet assigned for testing;training...; 146 kValidation, ///< these are placeholders... currently not us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Types_8h_source.html:1804,message,message,1804,doc/master/tmva_2tmva_2inc_2TMVA_2Types_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Types_8h_source.html,1,['message'],['message']
Integrability," <default>; GA Genetic Algorithm (takes a LONG time). LearningRate <float> NN learning rate parameter; DecayRate <float> Decay rate for learning parameter; TestRate <int> Test for overtraining performed at each #th epochs; BPMode <string> Back-propagation learning mode available values are:; sequential <default>; batch. BatchSize <int> Batch size: number of events/batch, only set if in Batch Mode,; -1 for BatchSize=number_of_events . Reimplemented from TMVA::MethodANNBase.; Definition at line 195 of file MethodMLP.cxx. ◆ DeclFileName(). static const char * TMVA::MethodMLP::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 219 of file MethodMLP.h. ◆ DerivDir(). Double_t TMVA::MethodMLP::DerivDir ; (; TMatrixD & ; Dir). private . Definition at line 825 of file MethodMLP.cxx. ◆ EstimatorFunction(). Double_t TMVA::MethodMLP::EstimatorFunction ; (; std::vector< Double_t > & ; parameters). virtual . interface to the estimate ; Implements TMVA::IFitterTarget.; Definition at line 1385 of file MethodMLP.cxx. ◆ GeneticMinimize(). void TMVA::MethodMLP::GeneticMinimize ; (; ). private . create genetics class similar to GeneticCut give it vector of parameter ranges (parameters = weights) link fitness function of this class to ComputeEstimator instantiate GA (see MethodCuts) run it then this should exist for GA, Minuit and random sampling ; Definition at line 1356 of file MethodMLP.cxx. ◆ GetApproxInvHessian(). void TMVA::MethodMLP::GetApproxInvHessian ; (; TMatrixD & ; InvHessian, . bool ; regulate = true . ). private . rank-1 approximation, neglect 2nd derivatives. //zjh ; Definition at line 1508 of file MethodMLP.cxx. ◆ GetCEErr(). Double_t TMVA::MethodMLP::GetCEErr ; (; const Event * ; ev, . UInt_t ; index = 0 . ). private . zjh ; Definition at line 1020 of file MethodMLP.cxx. ◆ GetDesiredOutput(). Double_t TMVA::MethodMLP::GetDesiredOutput ; (; const Event * ; ev). private . get the desired output of this event ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:42670,interface,interface,42670,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['interface'],['interface']
Integrability," = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TMultiDimFit ();  Empty CTOR. Do not use. ;  ;  TMultiDimFit (Int_t dimension, EMDFPolyType type=kMonomials, Option_t *option="""");  Constructor Second argument is the type of polynomials to use in parameterisation, one of: TMultiDimFit::kMonomials TMultiDimFit::kChebyshev TMultiDimFit::kLegendre. ;  ;  ~TMultiDimFit () override;  Destructor. ;  ; virtual void AddRow (const Double_t *x, Double_t D, Double_t E=0);  Add a row consisting of fNVariables independent variables, the known, dependent quantity, and optionally, the square error in the dependent quantity, to the training sample to be used for the parameterization. ;  ; virtual void AddTestRow (const Double_t *x, Double_t D, Double_t E=0);  Add a row consisting of fNVariables independent variables, the known, dependent quantity, and optionally, the square error in the dependent quantity, to the test sample to be used for the test of the parameterization. ;  ; void Browse (TBrowser *b) override;  Browse the TMultiDimFit object in the TBrowser. ;  ; void Clear (Option_t *option="""") override;  Clear internal structures and variables. ;  ; void Draw (Option_t *=""d"") override;  Default Draw method for all objects. ;  ; virtual Double_t Eval (const Double_t *x, const Double_t *coeff=nullptr) const;  Evaluate parameterization at point x. ;  ; virtual Double_t EvalError (const Double_t *x, const Double_t *coeff=nullptr) const;  Evaluate parameterization error at point x. ;  ; virtual void FindParameterization (Option_t *option="""");  Find the parameterization. ;  ; virtual void Fit (Option_t *option="""");  Try to fit the found parameterisation to the test sample. ;  ; Double_t GetChi2 () const;  ; const TVectorD * GetCoefficients () const;  ; const TVectorD * GetCoefficientsRMS () const;  ; const TMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:19302,depend,dependent,19302,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,2,['depend'],['dependent']
Integrability," = 0 find closest point to target in Y, the object closest to the target which is 3 sigma from the target and has smaller error; if mode = 1 find 2 closest point to target in X and between these two take the one closer to the target; if mode = 2 as in mode = 1 but return the lower point not the closest one; if mode = 3 as in mode = 1 but return the upper point not the closest one . Definition at line 883 of file HypoTestInverterResult.cxx. ◆ FindIndex(). int HypoTestInverterResult::FindIndex ; (; double ; xvalue); const. find the index corresponding at the poi value xvalue If no points is found return -1 Note that a tolerance is used of 10^-12 to find the closest point ; Definition at line 563 of file HypoTestInverterResult.cxx. ◆ FindInterpolatedLimit(). double HypoTestInverterResult::FindInterpolatedLimit ; (; double ; target, . bool ; lowSearch = false, . double ; xmin = 1, . double ; xmax = 0.0 . ). interpolate to find a limit value Use a linear or a spline interpolation depending on the interpolation option ; Definition at line 710 of file HypoTestInverterResult.cxx. ◆ GetAltTestStatDist(). SamplingDistribution * RooStats::HypoTestInverterResult::GetAltTestStatDist ; (; int ; index); const. inline . Definition at line 140 of file HypoTestInverterResult.h. ◆ GetBackgroundTestStatDist(). SamplingDistribution * HypoTestInverterResult::GetBackgroundTestStatDist ; (; int ; index); const. get the background test statistic distribution ; Definition at line 1108 of file HypoTestInverterResult.cxx. ◆ GetExpectedLimit(). double HypoTestInverterResult::GetExpectedLimit ; (; double ; nsig, . bool ; lower, . const char * ; opt = """" . ); const. private . get expected limit (lower/upper) depending on the flag for asymptotic is a special case (the distribution is generated an step in sigma values) distinguish asymptotic looking at the hypotest results if option = ""P"" get expected limit using directly quantiles of p value distribution else (default) find expected limit by obtai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterResult.html:28040,depend,depending,28040,doc/master/classRooStats_1_1HypoTestInverterResult.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HypoTestInverterResult.html,1,['depend'],['depending']
Integrability," = 0 means restore all parameters; - K = 1 means restore the last parameter fixed; - K = -I means restore external parameter I (if possible); - IQ = fix-location where internal parameters were stored; - IR = external number of parameter being restored; - IS = internal number of parameter being restored . Definition at line 3256 of file TMinuit.cxx. ◆ mngrad(). void TMinuit::mngrad ; (; ). virtual . Interprets the SET GRAD command. ; - Called from MNSET; - Interprets the SET GRAD command, which informs MINUIT whether; - the first derivatives of FCN will be calculated by the user; - inside FCN. It can check the user derivative calculation; - by comparing it with a finite difference approximation. . Definition at line 3362 of file TMinuit.cxx. ◆ mnhelp() [1/2]. void TMinuit::mnhelp ; (; const char * ; command = """"). virtual . interface to Minuit help ; Definition at line 3422 of file TMinuit.cxx. ◆ mnhelp() [2/2]. void TMinuit::mnhelp ; (; TString ; comd). virtual . HELP routine for MINUIT interactive commands. . COMD ='*' or """" prints a global help for all commands; COMD =Command_name: print detailed help for one command. Note that at least 3 characters must be given for the command name.; Author: Rene Brun comments extracted from the MINUIT documentation file. . Definition at line 3439 of file TMinuit.cxx. ◆ mnhes1(). void TMinuit::mnhes1 ; (; ). virtual . Calculate first derivatives (GRD) and uncertainties (DGRD) ; and appropriate step sizes GSTEP Called from MNHESS and MNGRAD ; Definition at line 4218 of file TMinuit.cxx. ◆ mnhess(). void TMinuit::mnhess ; (; ). virtual . Calculates the full second-derivative matrix of FCN. ; by taking finite differences. When calculating diagonal elements, it may iterate so that step size is nearly that which gives function change= UP/10. The first derivatives of course come as a free side effect, but with a smaller step size in order to obtain a known accuracy. ; Definition at line 3993 of file TMinuit.cxx. ◆ mnimpr(). void TMinu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:52967,rout,routine,52967,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['rout'],['routine']
Integrability," = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTSQLServer::ClearError(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidTSQLServer::SetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum TSQLServer::ESQLDataTypes { kSQL_NONE; kSQL_CHAR; kSQL_VARCHAR; kSQL_INTEGER; kSQL_FLOAT; kSQL_DOUBLE; kSQL_NUMERIC; kSQL_BINARY; kSQL_TIMESTAMP; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSQLServer::fDBcurrently selected DB; Int_tTSQLServer::fErrorCodeerror code of last operation; TStringTSQLServer::fErrorMsgerror message of last operation; Bool_tTSQLServer::fErrorOutenable error output; TStringTSQLServer::fHosthost to which we are connected; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*TSQLServer::fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. private:. Connection*fConnconnection to Oracle server; Environment*fEnvenvironment of Oracle access; TStringfInfoinfo string with Oracle version information; static const char*fgDatimeFormat! format for converting date and time stamps into string . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TOracleServer(const char* db, const char* uid, const char* pw); Open a connection to a Oracle DB server. The db arguments should be; of the form ""oracle://connection_identifier[/<database>]"", e.g.:; ""oracle://cmscald.fnal.gov/test"". The uid is the username and pw; the password that should be used for the connection. ~TOracleServer(); Clos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TOracleServer.html:8675,message,message,8675,root/html528/TOracleServer.html,https://root.cern,https://root.cern/root/html528/TOracleServer.html,1,['message'],['message']
Integrability," = 1, UInt_t options = kVerticalFrame); Create a top level main frame. A main frame interacts; with the window manager. ~TGMainFrame(); TGMainFrame destructor. Bool_t SaveFrameAsCodeOrImage(); Opens dialog window allowing user to save the frame contents; as a ROOT macro or as an image.; Returns kTRUE if something was saved. This is bound to Ctrl-S by default. Bool_t HandleKey(Event_t* event); Handle keyboard events. Bool_t BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; Bind key to a window. void RemoveBind(const TGWindow* w, Int_t keycode, Int_t modifier) const; Remove key binding. Bool_t HandleButton(Event_t* event); Handle mouse button events. Bool_t HandleMotion(Event_t* event); Handle mouse motion events. Bool_t HandleSelection(Event_t* event); Handle primary selection event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleClientMessage(Event_t* event); Handle client messages sent to this frame. void SendCloseMessage(); Send close message to self. This method should be called from; a button to close this window. void CloseWindow(); Close and delete main frame. We get here in response to ALT+F4 or; a window manager close command. To terminate the application when this; happens override this method and call gApplication->Terminate(0) or; make a connection to this signal (if after the slot this method; should not be called call DontCallClose() in the slot).; By default the window will be deleted. void DontCallClose(); Typically call this method in the slot connected to the CloseWindow(); signal to prevent the calling of the default or any derived CloseWindow(); methods to prevent premature or double deletion of this window. void SetWindowName(const char* name = 0); Set window name. This is typically done via the window manager. void SetIconName(const char* name); Set window icon name. This is typically done via the window manager. const TGPicture * SetIconPixmap(const char* iconName); Set window icon pixm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGMainFrame.html:22815,message,message,22815,root/html530/TGMainFrame.html,https://root.cern,https://root.cern/root/html530/TGMainFrame.html,9,['message'],['message']
Integrability," = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(Element val); Assign val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(Element val); Add val to every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(Element val); Subtract val from every element of the matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator*=(double val); Multiply every element of the matrix with val. TMatrixTSym<Element> &TMatrixTSym<Element> operator+=(const TMatrixTSym<Element> &source); Add the source matrix. TMatrixTSym<Element> &TMatrixTSym<Element> operator-=(const TMatrixTSym<Element> &source); Subtract the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTSym_double_.html:19860,rout,routine,19860,root/html602/TMatrixTSym_double_.html,https://root.cern,https://root.cern/root/html602/TMatrixTSym_double_.html,4,['rout'],['routine']
Integrability," = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:6063,Integrat,Integrator,6063,root/html532/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html,2,['Integrat'],['Integrator']
Integrability," = 1000, unsigned int rule = 3); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000, int rule = 3). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000, int rule = 3). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html:5474,interface,interface,5474,root/html526/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorOneDim.html,1,['interface'],['interface']
Integrability," = 3.8147e-06 , s = 4.00781; [11] h = 9.53674e-07 , s = 3.99609; [12] h = 2.38419e-07 , s = 4.00195; [13] h = 5.96046e-08 , s = 3.99902; [14] h = 1.49012e-08 , s = 4.00049; [15] h = 3.72529e-09 , s = 3.99976; [16] h = 9.31323e-10 , s = 4.00012; [17] h = 2.32831e-10 , s = 3.99994; [18] h = 5.82077e-11 , s = 4.00003; [19] h = 1.45519e-11 , s = 3.99998; [20] h = 3.63798e-12 , s = 4.00001; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x7937fb0 with pdf gx_CONV_model_mean_CACHE_Obs[mean,x]_NORM_mean for nset (mean) with code 0; [#0] WARNING:Eval -- The FFT convolution 'model' will run with 50 bins. A decent accuracy for difficult convolutions is typically only reached with n >= 1000. Suggest to increase the number of bins of the observable 'mean'.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(gx_Int[mean,x]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#1] INFO:NumericIntegration -- RooRealIntegral::init(model_mean_Int[mean]) using numeric integrator RooIntegrator1D to calculate Int(mean); [#0] WARNING:Integration -- RooRombergIntegrator::integral: integral of model_mean over range (-6,6) did not converge after 20 steps; [1] h = 1 , s = 0; [2] h = 0.25 , s = 6; [3] h = 0.0625 , s = 3; [4] h = 0.015625 , s = 4.5; [5] h = 0.00390625 , s = 3.75; [6] h = 0.000976562 , s = 4.125; [7] h = 0.000244141 , s = 3.9375; [8] h = 6.10352e-05 , s = 4.03125; [9] h = 1.52588e-05 , s = 3.98438; [10] h = 3.8147e-06 , s = 4.00781; [11] h = 9.53674e-07 , s = 3.99609; [12] h = 2.38419e-07 , s = 4.00195; [13] h = 5.96046e-08 , s = 3.99902; [14] h = 1.49012e-08 , s = 4.00049; [15] h = 3.72529e-09 , s = 3.99976; [16] h = 9.31323e-10 , s = 4.00012; [17] h = 2.32831e-10 , s = 3.99994; [18] h = 5.82077e-11 , s = 4.00003; [19] h = 1.45519e-11 , s = 3.99998; [20] h = 3.63798e-12 , s = 4.00001; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(model) creating new cache 0x7f45240 with pdf gx_CONV_model_mean_CACHE_Obs[x,mean]_NORM_x_mean for nset (x,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf211__paramconv_8py.html:4067,integrat,integrator,4067,doc/master/rf211__paramconv_8py.html,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8py.html,2,['integrat'],['integrator']
Integrability," = HistFactory ; [#1] INFO:Integration -- RooRealIntegral::ctor(g_Int[x]) Constructing integral of function g over observables(x) with normalization () with range identifier <none>; [#1] INFO:Integration -- g: Observable x is suitable for analytical integration (if supported by p.d.f); [#1] INFO:Integration -- g: Function integrated observables (x) internally with code 1; [#1] INFO:Integration -- g: Observables (x) are analytically integrated with code 1; RooRealIntegral::g_Int[x][ Int gd[Ana](x) ] = 2.50663; Active Message streams; [0] MinLevel = PROGRESS Topic = Generation Minimization Plotting Fitting Integration LinkStateMgmt Eval Caching Optimization ObjectHandling InputArguments Tracing Contents DataHandling NumericIntegration FastEvaluations ; [1] MinLevel = INFO Topic = Minimization Plotting Fitting Integration Eval Caching ObjectHandling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8py.html:5598,synchroniz,synchronize,5598,doc/master/rf506__msgservice_8py.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html,1,['synchroniz'],['synchronize']
Integrability," = Integral(TMath::Power(10, x0), TMath::Power(10, x0 + 0.5 * dx), 0.0) / total;; 2147 else; 2148 r1 = Integral(x0, x0 + 0.5 * dx, 0.0) / total;; 2149 r3 = 2 * r2 - 4 * r1;; 2150 if (TMath::Abs(r3) > 1e-8); 2151 fGamma[i] = r3 / (dx * dx);; 2152 else; 2153 fGamma[i] = 0;; 2154 fBeta[i] = r2 / dx - fGamma[i] * dx;; 2155 fAlpha[i] = x0;; 2156 fGamma[i] *= 2;; 2157 }; 2158 return kTRUE;; 2159}; 2160 ; 2161////////////////////////////////////////////////////////////////////////////////; 2162/// Return a random number following this function shape.; 2163///; 2164/// @param rng Random number generator. By default (or when passing a nullptr) the global gRandom is used; 2165/// @param option Option string which controls the binning used to compute the integral. Default mode is automatic depending of; 2166/// xmax, xmin and Npx (function points).; 2167/// Possible values are:; 2168/// - ""LOG"" to force usage of log scale for tabulating the integral; 2169/// - ""LIN"" to force usage of linear scale when tabulating the integral; 2170///; 2171/// The distribution contained in the function fname (TF1) is integrated; 2172/// over the channel contents.; 2173/// It is normalized to 1.; 2174/// For each bin the integral is approximated by a parabola.; 2175/// The parabola coefficients are stored as non persistent data members; 2176/// Getting one random number implies:; 2177/// - Generating a random number between 0 and 1 (say r1); 2178/// - Look in which bin in the normalized integral r1 corresponds to; 2179/// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; 2180///; 2181/// The user can provide as optional parameter a Random number generator.; 2182/// By default gRandom is used; 2183///; 2184/// If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; 2185/// A log scale for the intergral is also always used if a user specifies the ""LOG"" option; 2186/// Instead if a user requestes a ""LIN"" option the integral binning is never d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:79793,integrat,integrated,79793,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['integrat'],['integrated']
Integrability," = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> MultT(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B^T. void TMatrixT<Element> MultT(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B^T. TMatrixT<Element> &TMatrixT<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, double* data); Use the array data to fill the matrix ([row_lwb..row_upb] x [col_lwb..col_upb]). TMatrixTBase<Element> &TMatrixT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb] x [col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTBase<Element> &TMatrixT<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][col_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][col_lwb..col_lwb+ncols_source];. TMatrixTBase<Element> &TMatrixT<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size of the matrix to nrows x ncols; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixT<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixT_double_.html:18543,depend,depends,18543,root/html528/TMatrixT_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixT_double_.html,1,['depend'],['depends']
Integrability," = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> MultT(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B^T. void TMatrixT<Element> MultT(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B^T. TMatrixT<Element> &TMatrixT<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, double* data); Use the array data to fill the matrix ([row_lwb..row_upb] x [col_lwb..col_upb]). TMatrixTBase<Element> &TMatrixT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb] x [col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb][0..col_upb-col_lwb] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTBase<Element> &TMatrixT<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][col_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][col_lwb..col_lwb+ncols_source];. TMatrixTBase<Element> &TMatrixT<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size of the matrix to nrows x ncols; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixT<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMatrixT_double_.html:18612,depend,depends,18612,root/html530/TMatrixT_double_.html,https://root.cern,https://root.cern/root/html530/TMatrixT_double_.html,9,['depend'],['depends']
Integrability," = TMVA::Experimental::SofieFunctor<7,TMVA_SOFIE_'+modelName+'::Session>(0,""Higgs_trained_model_generated.dat"");'); ; # run inference over input data; inputFile = ""http://root.cern/files/Higgs_data.root""; df1 = ROOT.RDataFrame(""sig_tree"", inputFile); h1 = df1.Define(""DNN_Value"", ""sofie_functor(rdfslot_,m_jj, m_jjj, m_lv, m_jlv, m_bb, m_wbb, m_wwbb)"").Histo1D((""h_sig"", """", 100, 0, 1),""DNN_Value""); ; df2 = ROOT.RDataFrame(""bkg_tree"", inputFile); h2 = df2.Define(""DNN_Value"", ""sofie_functor(rdfslot_,m_jj, m_jjj, m_lv, m_jlv, m_bb, m_wbb, m_wwbb)"").Histo1D((""h_bkg"", """", 100, 0, 1),""DNN_Value""); ; # run over the input data once, combining both RDataFrame graphs.; ROOT.RDF.RunGraphs([h1, h2]);; ; print(""Number of signal entries"",h1.GetEntries()); print(""Number of background entries"",h2.GetEntries()); ; h1.SetLineColor(ROOT.kRed); h2.SetLineColor(ROOT.kBlue); ; c1 = ROOT.TCanvas(); ROOT.gStyle.SetOptStat(0); ; h2.DrawClone(); h1.DrawClone(""SAME""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; Model has not a defined batch size assume is 1 - input shape for tensor dense_input : { 1 , 7 }; //Code generated automatically by TMVA for Inference of Model file [Higgs_trained_model.h5] at [Tue Nov 5 09:33:48 2024] ; ; #ifndef ROOT_TMVA_SOFIE_HIGGS_TRAINED_MODEL; #define ROOT_TMVA_SOFIE_HIGGS_TRAINED_MODEL; ; #include <algorithm>; #include <vector>; #include <cmath>; #include ""TMVA/SOFIE_common.hxx""; #include <fstream>; ; namespace TMVA_SOFIE_Higgs_trained_model{; namespace BLAS{; extern ""C"" void sgemv_(const char * trans, const int * m, const int * n, const float * alpha, const float * A,; const int * lda, const float * X, const int * incx, const float * beta, const float * Y, const int * incy);; extern ""C"" void sgemm_(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8py.html:2302,interface,interface,2302,doc/master/TMVA__SOFIE__RDataFrame_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__SOFIE__RDataFrame_8py.html,1,['interface'],['interface']
Integrability," = Trapezoid, Int_t maxSteps = 0, Double_t eps = 0); Construct integrator on given function binding for given range,; using specified summation rule, maximum number of steps and; conversion tolerance. The integration limits are taken from the; function binding. RooIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Construct integrator on given function binding, using specified; configuration object. The integration limits are taken from the; function binding. RooIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Construct integrator on given function binding, using specified; configuration object and integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Clone integrator with new function binding and configuration. Needed by RooNumIntFactory. Bool_t initialize(); Initialize the integrator. ~RooIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Calculate numeric integral at given set of function binding parameters. Double_t addMidpoints(Int_t n); Calculate the n-th stage of refinement of the Second Euler-Maclaurin; summation rule which has the useful property of not evaluating the; integrand at either of its endpoints but requires more function; evaluations than the trapezoidal rule. This rule can be used with; a suitable change of variables to estimate improper integrals. Double_t addTrapezoids(Int_t n); Calculate the n-th stage of refinement of the extended trapezoidal; summation rule. This is the most efficient rule for a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooIntegrator1D.html:9454,integrat,integration,9454,root/html528/RooIntegrator1D.html,https://root.cern,https://root.cern/root/html528/RooIntegrator1D.html,10,['integrat'],['integration']
Integrability," = false ;; 479 } else {; 480 name.append("","") ;; 481 }; 482 name.append(arg->GetName()) ;; 483 }; 484 name.append(""]"") ;; 485 ; 486 // Create and return profile object; 487 auto out = std::make_unique<RooProfileLL>(name.c_str(),(std::string(""Profile of "") + GetTitle()).c_str(),*this,paramsOfInterest);; 488 return RooFit::makeOwningPtr<RooAbsReal>(std::move(out));; 489}; 490 ; 491 ; 492 ; 493 ; 494 ; 495 ; 496////////////////////////////////////////////////////////////////////////////////; 497/// Create an object that represents the integral of the function over one or more observables listed in `iset`.; 498/// The actual integration calculation is only performed when the returned object is evaluated. The name; 499/// of the integral object is automatically constructed from the name of the input function, the variables; 500/// it integrates and the range integrates over.; 501///; 502/// \note The integral over a PDF is usually not normalised (*i.e.*, it is usually not; 503/// 1 when integrating the PDF over the full range). In fact, this integral is used *to compute*; 504/// the normalisation of each PDF. See the [rf110 tutorial](group__tutorial__roofit.html); 505/// for details on PDF normalisation.; 506///; 507/// The following named arguments are accepted; 508/// | | Effect on integral creation; 509/// |--|-------------------------------; 510/// | `NormSet(const RooArgSet&)` | Specify normalization set, mostly useful when working with PDFs; 511/// | `NumIntConfig(const RooNumIntConfig&)` | Use given configuration for any numeric integration, if necessary; 512/// | `Range(const char* name)` | Integrate only over given range. Multiple ranges may be specified by passing multiple Range() arguments; 513 ; 514RooFit::OwningPtr<RooAbsReal> RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2,; 515 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 516 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:17673,integrat,integrating,17673,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['integrat'],['integrating']
Integrability," = new TCanvas(""rf903_numintcache"", ""rf903_numintcache"", 600, 600);; framex->Draw();; canv->Draw();; ; // Make workspace available on command line after macro finishes; gDirectory->Add(w1);; }; ; RooWorkspace *getWorkspace(Int_t mode); {; // C r e a t e , s a v e o r l o a d w o r k s p a c e w i t h p . d . f .; // -----------------------------------------------------------------------------------; //; // Mode = 0 : Create workspace for plain running (no integral caching); // Mode = 1 : Generate workspace with pre-calculated integral and store it on file; // Mode = 2 : Load previously stored workspace from file; ; RooWorkspace *w(0);; ; if (mode != 2) {; ; // Create empty workspace workspace; w = new RooWorkspace(""w"", 1);; ; // Make a difficult to normalize pdf in 3 dimensions that is integrated numerically.; w->factory(""EXPR::model('1/((x-a)*(x-a)+0.01)+1/((y-a)*(y-a)+0.01)+1/""; ""((z-a)*(z-a)+0.01)',x[-1,1],y[-1,1],z[-1,1],a[-5,5])"");; }; ; if (mode == 1) {; ; // Instruct model to pre-calculate normalization integral that integrate at least; // two dimensions numerically. In this specific case the integral value for; // all values of parameter 'a' are stored in a histogram and available for use; // in subsequent fitting and plotting operations (interpolation is applied); ; // w->pdf(""model"")->setNormValueCaching(3) ;; w->pdf(""model"")->setStringAttribute(""CACHEPARMINT"", ""x:y:z"");; ; // Evaluate pdf once to trigger filling of cache; RooArgSet normSet(*w->var(""x""), *w->var(""y""), *w->var(""z""));; w->pdf(""model"")->getVal(&normSet);; w->writeToFile(""rf903_numintcache.root"");; }; ; if (mode == 2) {; // Load preexisting workspace from file in mode==2; TFile *f = new TFile(""rf903_numintcache.root"");; w = (RooWorkspace *)f->Get(""w"");; }; ; // Return created or loaded workspace; return w;; }; d#define d(i)Definition RSha256.hxx:102; f#define f(i)Definition RSha256.hxx:104; RooDataHist.h; RooDataSet.h; RooExpensiveObjectCache.h; RooGaussian.h; RooPlot.h; RooRealVar.h; RooWorks",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf903__numintcache_8C.html:3491,integrat,integrate,3491,doc/master/rf903__numintcache_8C.html,https://root.cern,https://root.cern/doc/master/rf903__numintcache_8C.html,1,['integrat'],['integrate']
Integrability," = nullptr, . bool ; verbose = false . ); const. overrideprotectedvirtual . Return specialized context to efficiently generate toy events from RooAddPdfs return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. ; Reimplemented from RooAbsPdf.; Definition at line 901 of file RooAddPdf.cxx. ◆ getAnalyticalIntegralWN(). Int_t RooAddPdf::getAnalyticalIntegralWN ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Determine which part (if any) of given integral can be performed analytically. ; If any analytical integration is possible, return integration scenario code; RooAddPdf queries each component PDF for its analytical integration capability of the requested set ('allVars'). It finds the largest common set of variables that can be integrated by all components. If such a set exists, it reconfirms that each component is capable of analytically integrating the common set, and combines the components individual integration codes into a single integration code valid for RooAddPdf. ; Reimplemented from RooAbsReal.; Definition at line 631 of file RooAddPdf.cxx. ◆ getCoefNormalization(). const RooArgSet & RooAddPdf::getCoefNormalization ; (; ); const. Definition at line 335 of file RooAddPdf.cxx. ◆ getCoefRange(). const char * RooAddPdf::getCoefRange ; (; ); const. inline . Definition at line 83 of file RooAddPdf.h. ◆ getNormAndCache(). std::pair< const RooArgSet *, AddCacheElem * > RooAddPdf::getNormAndCache ; (; const RooArgSet * ; nset); const. private . Look up projection cache and per-PDF norm sets. ; If a PDF doesn't have a special norm set, use the defaultNorm. If defaultNorm == nullptr, use the member _normSet. ; Definition at line 458 of file RooAddPdf.cxx. ◆ getProjCache(). AddCacheElem * RooAddPdf::getProjCache ; (; const RooArgSet * ; nset, . const RooArgSet * ; iset = nullptr . ); const. protected . Manager of cache with coefficient projection",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:88519,integrat,integrating,88519,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,6,['integrat'],"['integrating', 'integration']"
Integrability," = selNodes->find(arg->GetName()) != nullptr;; 1488 static_cast<RooAbsReal*>(arg)->selectComp(select);; 1489 }; 1490}; 1491 ; 1492 ; 1493 ; 1494////////////////////////////////////////////////////////////////////////////////; 1495/// Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; 1496/// will show a unit normalized curve in the frame variable, taken at the present value; 1497/// of other observables defined for this PDF.; 1498///; 1499/// \param[in] frame pointer to RooPlot; 1500/// \param[in] arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10 Ordered arguments; 1501///; 1502/// If a PDF is plotted in a frame in which a dataset has already been plotted, it will; 1503/// show a projected curve integrated over all variables that were present in the shown; 1504/// dataset except for the one on the x-axis. The normalization of the curve will also; 1505/// be adjusted to the event count of the plotted dataset. An informational message; 1506/// will be printed for each projection step that is performed.; 1507///; 1508/// This function takes the following named arguments; 1509/// <table>; 1510/// <tr><th><th> Projection control; 1511/// <tr><td> `Slice(const RooArgSet& set)` <td> Override default projection behaviour by omitting observables listed; 1512/// in set from the projection, i.e. by not integrating over these.; 1513/// Slicing is usually only sensible in discrete observables, by e.g. creating a slice; 1514/// of the PDF at the current value of the category observable.; 1515///; 1516/// <tr><td> `Slice(RooCategory& cat, const char* label)` <td> Override default projection behaviour by omitting the specified category; 1517/// observable from the projection, i.e., by not integrating over all states of this category.; 1518/// The slice is positioned at the given label value. To pass multiple Slice() commands, please use the; 1519/// Slice(std::map<RooCategory*, std::string> const&) argument explained below.; 1520///; 1521/// <tr><td>",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:61812,message,message,61812,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['message'],['message']
Integrability," = true); virtual voidUpdateProjection(). protected:. voidSetDepthCommon(Float_t d, TEveElement* el, Float_t* bbox); virtual voidSetDepthLocal(Float_t d). private:. TEveProjected&operator=(const TEveProjected&). Data Members; protected:. Float_tfDepthz coordinate; TEveProjectionManager*fManagermanager; TEveProjectable*fProjectablelink to original object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TEveProjected(); Destructor.; If fProjectable is non-null, *this is removed from its list of; projected replicas. TEveElement* GetProjectedAsElement(); Returns fProjectable dynamic-casted to TEveElement. void SetProjection(TEveProjectionManager* mng, TEveProjectable* model); Sets projection manager and reference in the projectable object. Method called; immediately after default constructor.; See also TEveProjectionManager::ImportElements(). void UnRefProjectable(TEveProjectable* assumed_parent, bool notifyParent = true); Remove reference to projectable. void SetDepth(Float_t d); Set depth coordinate for the element.; Bounding-box should also be updated.; If projection type is 3D, this only sets fDepth member. void SetDepthCommon(Float_t d, TEveElement* el, Float_t* bbox); Utility function to update the z-values of the bounding-box.; As this is an abstract interface, the element and bbox pointers; must be passed from outside. void SetDepthLocal(Float_t d); Base-class implementation -- just sets fDepth. TEveProjectable& operator=(const TEveProjected& ). TEveProjectionManager* GetManager() const; { return fManager; }. TEveProjectable* GetProjectable() const; { return fProjectable; }. Float_t GetDepth() const; { return fDepth; }. void UpdateProjection(). » Last changed: root/eve:$Id: TEveProjectionBases.h 36373 2010-10-19 17:43:35Z matevz $ » Last generated: 2010-10-20 08:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveProjected.html:2496,interface,interface,2496,root/html528/TEveProjected.html,https://root.cern,https://root.cern/root/html528/TEveProjected.html,1,['interface'],['interface']
Integrability," = true); virtual voidUpdateProjection(). protected:. voidSetDepthCommon(Float_t d, TEveElement* el, Float_t* bbox); virtual voidSetDepthLocal(Float_t d). private:. TEveProjected&operator=(const TEveProjected&). Data Members; protected:. Float_tfDepthz coordinate; TEveProjectionManager*fManagermanager; TEveProjectable*fProjectablelink to original object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TEveProjected(); Destructor.; If fProjectable is non-null, *this is removed from its list of; projected replicas. TEveElement* GetProjectedAsElement(); Returns fProjectable dynamic-casted to TEveElement. void SetProjection(TEveProjectionManager* mng, TEveProjectable* model); Sets projection manager and reference in the projectable object. Method called; immediately after default constructor.; See also TEveProjectionManager::ImportElements(). void UnRefProjectable(TEveProjectable* assumed_parent, bool notifyParent = true); Remove reference to projectable. void SetDepth(Float_t d); Set depth coordinate for the element.; Bounding-box should also be updated.; If projection type is 3D, this only sets fDepth member. void SetDepthCommon(Float_t d, TEveElement* el, Float_t* bbox); Utility function to update the z-values of the bounding-box.; As this is an abstract interface, the element and bbox pointers; must be passed from outside. void SetDepthLocal(Float_t d); Base-class implementation -- just sets fDepth. TEveProjectable& operator=(const TEveProjected& ). TEveProjectionManager* GetManager() const; { return fManager; }. TEveProjectable* GetProjectable() const; { return fProjectable; }. Float_t GetDepth() const; { return fDepth; }. void UpdateProjection(). » Last changed: root/eve:$Id: TEveProjectionBases.h 36373 2010-10-19 17:43:35Z matevz $ » Last generated: 2011-07-04 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveProjected.html:2496,interface,interface,2496,root/html530/TEveProjected.html,https://root.cern,https://root.cern/root/html530/TEveProjected.html,1,['interface'],['interface']
Integrability," = true); virtual voidUpdateProjection(). protected:. voidSetDepthCommon(Float_t d, TEveElement* el, Float_t* bbox); virtual voidSetDepthLocal(Float_t d). private:. TEveProjected&operator=(const TEveProjected&). Data Members; protected:. Float_tfDepthz coordinate; TEveProjectionManager*fManagermanager; TEveProjectable*fProjectablelink to original object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TEveProjected(); Destructor.; If fProjectable is non-null, *this is removed from its list of; projected replicas. TEveElement* GetProjectedAsElement(); Returns fProjectable dynamic-casted to TEveElement. void SetProjection(TEveProjectionManager* mng, TEveProjectable* model); Sets projection manager and reference in the projectable object. Method called; immediately after default constructor.; See also TEveProjectionManager::ImportElements(). void UnRefProjectable(TEveProjectable* assumed_parent, bool notifyParent = true); Remove reference to projectable. void SetDepth(Float_t d); Set depth coordinate for the element.; Bounding-box should also be updated.; If projection type is 3D, this only sets fDepth member. void SetDepthCommon(Float_t d, TEveElement* el, Float_t* bbox); Utility function to update the z-values of the bounding-box.; As this is an abstract interface, the element and bbox pointers; must be passed from outside. void SetDepthLocal(Float_t d); Base-class implementation -- just sets fDepth. TEveProjectable& operator=(const TEveProjected& ). TEveProjectionManager* GetManager() const; { return fManager; }. TEveProjectable* GetProjectable() const; { return fProjectable; }. Float_t GetDepth() const; { return fDepth; }. void UpdateProjection(). » Last changed: root/eve:$Id: TEveProjectionBases.h 36373 2010-10-19 17:43:35Z matevz $ » Last generated: 2011-11-03 20:12; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveProjected.html:2496,interface,interface,2496,root/html532/TEveProjected.html,https://root.cern,https://root.cern/root/html532/TEveProjected.html,2,['interface'],['interface']
Integrability," =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  . Public Member Functions;  RooAbsCachedPdf ();  ;  RooAbsCachedPdf (const char *name, const char *title, int ipOrder=0);  Constructor. ;  ;  RooAbsCachedPdf (const RooAbsCachedPdf &other, const char *name=nullptr);  Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implements internal (analytical) integration capabilities. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to offer all our actual observable for internal integration. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertises internal (analytical) integration capabilities. ;  ; RooDataHist * getCacheHist (const RooArgSet &nset) const;  ; RooDataHist * getCacheHist (const RooArgSet *nset=nullptr) const;  Return pointer to RooDataHist cache histogram for given choice of observables. ;  ; RooAbsPdf * getCachePdf (const RooArgSet &nset) const;  ; RooAbsPdf * getCachePdf (const RooArgSet *nset=nullptr) const;  Return pointer to RooHistPdf cache pdf for given choice of observables. ;  ; Int_t getInterpolationOrder () const;  ; double getValV (const RooArgSet *set=nullptr) const override;  Implementation of getVal() overriding default implementation of RooAbsPdf. ;  ; TClass * IsA () const override;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setInterpolationOrder (int order);  Change the interpolation order that is used in RooHistPdf cache represent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:3903,integrat,integration,3903,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,1,['integrat'],['integration']
Integrability," == 0)) {; 13094 acceptedWebSocketSubprotocol =; 13095 subprotocols->subprotocols[idx];; 13096 break;; 13097 }; 13098 }; 13099 } while (sep && !acceptedWebSocketSubprotocol);; 13100 } while (++cnt < nbSubprotocolHeader; 13101 && !acceptedWebSocketSubprotocol);; 13102 ; 13103 conn->request_info.acceptedWebSocketSubprotocol =; 13104 acceptedWebSocketSubprotocol;; 13105 ; 13106 } else if (nbSubprotocolHeader > 0) {; 13107 /* keep legacy behavior */; 13108 const char *protocol = protocols[0];; 13109 ; 13110 /* The protocol is a comma separated list of names. */; 13111 /* The server must only return one value from this list. */; 13112 /* First check if it is a list or just a single value. */; 13113 const char *sep = strrchr(protocol, ',');; 13114 if (sep == NULL) {; 13115 /* Just a single protocol -> accept it. */; 13116 conn->request_info.acceptedWebSocketSubprotocol = protocol;; 13117 } else {; 13118 /* Multiple protocols -> accept the last one. */; 13119 /* This is just a quick fix if the client offers multiple; 13120 * protocols. The handler should have a list of accepted; 13121 * protocols on his own; 13122 * and use it to select one protocol among those the client; 13123 * has; 13124 * offered.; 13125 */; 13126 while (isspace((unsigned char)*++sep)) {; 13127 ; /* ignore leading whitespaces */; 13128 }; 13129 conn->request_info.acceptedWebSocketSubprotocol = sep;; 13130 }; 13131 }; 13132 ; 13133#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13134 websocket_deflate_negotiate(conn);; 13135#endif; 13136 ; 13137 if ((ws_connect_handler != NULL); 13138 && (ws_connect_handler(conn, cbData) != 0)) {; 13139 /* C callback has returned non-zero, do not proceed with; 13140 * handshake.; 13141 */; 13142 /* Note that C callbacks are no longer called when Lua is; 13143 * responsible, so C can no longer filter callbacks for Lua. */; 13144 return;; 13145 }; 13146 }; 13147 ; 13148#if defined(USE_LUA); 13149 /* Step 3: No callback. Check if Lua is responsible. */; 1315",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:382789,protocol,protocols,382789,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['protocol'],['protocols']
Integrability," == 0)) {; 13095 acceptedWebSocketSubprotocol =; 13096 subprotocols->subprotocols[idx];; 13097 break;; 13098 }; 13099 }; 13100 } while (sep && !acceptedWebSocketSubprotocol);; 13101 } while (++cnt < nbSubprotocolHeader; 13102 && !acceptedWebSocketSubprotocol);; 13103 ; 13104 conn->request_info.acceptedWebSocketSubprotocol =; 13105 acceptedWebSocketSubprotocol;; 13106 ; 13107 } else if (nbSubprotocolHeader > 0) {; 13108 /* keep legacy behavior */; 13109 const char *protocol = protocols[0];; 13110 ; 13111 /* The protocol is a comma separated list of names. */; 13112 /* The server must only return one value from this list. */; 13113 /* First check if it is a list or just a single value. */; 13114 const char *sep = strrchr(protocol, ',');; 13115 if (sep == NULL) {; 13116 /* Just a single protocol -> accept it. */; 13117 conn->request_info.acceptedWebSocketSubprotocol = protocol;; 13118 } else {; 13119 /* Multiple protocols -> accept the last one. */; 13120 /* This is just a quick fix if the client offers multiple; 13121 * protocols. The handler should have a list of accepted; 13122 * protocols on his own; 13123 * and use it to select one protocol among those the client; 13124 * has; 13125 * offered.; 13126 */; 13127 while (isspace((unsigned char)*++sep)) {; 13128 ; /* ignore leading whitespaces */; 13129 }; 13130 conn->request_info.acceptedWebSocketSubprotocol = sep;; 13131 }; 13132 }; 13133 ; 13134#if defined(USE_ZLIB) && defined(MG_EXPERIMENTAL_INTERFACES); 13135 websocket_deflate_negotiate(conn);; 13136#endif; 13137 ; 13138 if ((ws_connect_handler != NULL); 13139 && (ws_connect_handler(conn, cbData) != 0)) {; 13140 /* C callback has returned non-zero, do not proceed with; 13141 * handshake.; 13142 */; 13143 /* Note that C callbacks are no longer called when Lua is; 13144 * responsible, so C can no longer filter callbacks for Lua. */; 13145 return;; 13146 }; 13147 }; 13148 ; 13149#if defined(USE_LUA); 13150 /* Step 3: No callback. Check if Lua is responsible. */; 1315",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:382822,protocol,protocols,382822,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['protocol'],['protocols']
Integrability," > &map1, const std::vector< int > &map2, TMatrixDSym &S11, TMatrixD &S12, TMatrixD &S21, TMatrixDSym &S22);  Block decomposition of covI according to given maps of observables. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMultiVarGaussian.html:56923,message,messages,56923,doc/master/classRooMultiVarGaussian.html,https://root.cern,https://root.cern/doc/master/classRooMultiVarGaussian.html,1,['message'],['messages']
Integrability," > >(RooAbsArg* owner, Int_t maxSize = 10); RooCacheManager<vector<double,allocator<double> > >(const RooCacheManager<vector<double,allocator<double> > >& other, RooAbsArg* owner = 0); Int_tsetObj(const RooArgSet* nset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp); virtual voidsterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_t_lastIndexLast slot accessed; Int_t_maxSizeMaximum size; RooNormSetCache*_nsetCache! Normalization/Integration set manager; vector<double,allocator<double> >**_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0). Int_t setObj(const RooArgSet* nset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); Setter function without integration set. return setObj(const RooArgSet* nset, const RooArgSet* iset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0). void reset(). void sterilize(). Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. T* getObjByIndex(In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCacheManager_vector_double___.html:3538,integrat,integration,3538,root/html530/RooCacheManager_vector_double___.html,https://root.cern,https://root.cern/root/html530/RooCacheManager_vector_double___.html,2,['integrat'],['integration']
Integrability," > >;  ; class  RField< std::bitset< N > >;  ; class  RField< std::byte >;  ; class  RField< std::int16_t >;  ; class  RField< std::int32_t >;  ; class  RField< std::int64_t >;  ; class  RField< std::int8_t >;  ; class  RField< std::map< KeyT, ValueT > >;  ; class  RField< std::pair< T1, T2 > >;  ; class  RField< std::set< ItemT > >;  ; class  RField< std::string >;  ; class  RField< std::tuple< ItemTs... > >;  ; class  RField< std::uint16_t >;  ; class  RField< std::uint32_t >;  ; class  RField< std::uint64_t >;  ; class  RField< std::uint8_t >;  ; class  RField< std::unique_ptr< ItemT > >;  ; class  RField< std::unordered_map< KeyT, ValueT > >;  ; class  RField< std::unordered_set< ItemT > >;  ; class  RField< std::variant< ItemTs... > >;  ; class  RField< std::vector< bool > >;  ; class  RField< std::vector< ItemT > >;  ; class  RField< T, typename std::enable_if< IsCollectionProxy< T >::value >::type >;  Classes behaving as a collection of elements that can be queried via the TVirtualCollectionProxy interface The use of a collection proxy for a particular class can be enabled via: ;  ; class  RField< T, typename std::enable_if< std::is_enum_v< T > >::type >;  ; class  RField< void >;  Template specializations for concrete C++ types. More...;  ; class  RFieldBase;  A field translates read and write calls from/to underlying columns to/from tree values. More...;  ; class  RFieldDescriptor;  Meta-data stored for every field of an ntuple. More...;  ; class  RFieldZero;  The container field for an ntuple model, which itself has no physical representation. More...;  ; class  RFile;  A ROOT file. More...;  ; class  RFilePtr;  Points to an object that stores or reads objects in ROOT's binary format. More...;  ; class  RFitPanel;  ; struct  RFitPanelModel;  Data structure for the fit panel. More...;  ; class  RFitResult;  ; class  RFrame;  Holds an area where drawing on user coordinate-system can be performed. More...;  ; class  RFunction;  ; class  RHist;  Histogram class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html:12938,interface,interface,12938,doc/v632/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html,1,['interface'],['interface']
Integrability," > fInsideNotifyDefinition TSystem.h:286; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TSystem::fMaxwfdInt_t fMaxwfdDefinition TSystem.h:282; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::GetHostByNamevirtual TInetAddress GetHostByName(const char *server)Get Internet Protocol (IP) address of host.Definition TSystem.cxx:2291; TSystem::RemoveSignalHandlervirtual TSignalHandler * RemoveSignalHandler(TSignalHandler *sh)Remove a signal handler from list of signal handlers.Definition TSystem.cxx:542; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TSystem::StripOffProtostatic const char * StripOffProto(const char *path, const char *proto)Strip off protocol string from specified path.Definition TSystem.cxx:117; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::IsAsyncBool_t IsAsync() constDefinition TTimer.h:81; TTimer::CheckTimerBool_t CheckTimer(const TTime &now)Check if timer timed out.Definition TTimer.cxx:130; TTimer::IsSyncBool_t IsSync() constDefinition TTimer.h:80; TUnixSystemDefinition TUnixSystem.h:32; TUnixSystem::AddTimervoid AddTimer(TTimer *ti) overrideAdd timer to list of system timers.Definition TUnixSystem.cxx:3009; TUnix",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:200461,protocol,protocol,200461,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['protocol'],['protocol']
Integrability," >(const ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5304,interface,interface,5304,root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,1,['interface'],['interface']
Integrability," >(const ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html:5304,interface,interface,5304,root/html526/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_3_3_-p1MatRepSym_double_3___.html,1,['interface'],['interface']
Integrability," >(const ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html:5304,interface,interface,5304,root/html526/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_4_4_-p1MatRepSym_double_4___.html,1,['interface'],['interface']
Integrability," >(const ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html:5304,interface,interface,5304,root/html526/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_5_5_-p1MatRepSym_double_5___.html,1,['interface'],['interface']
Integrability," >(const ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html:5304,interface,interface,5304,root/html526/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_6_6_-p1MatRepSym_double_6___.html,1,['interface'],['interface']
Integrability," >(const ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<double,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5304,interface,interface,5304,root/html526/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,1,['interface'],['interface']
Integrability," >::Profile2D ; (; const TProfile2DModel & ; model, . std::string_view ; v1Name, . std::string_view ; v2Name, . std::string_view ; v3Name, . std::string_view ; wName . ). inline . Fill and return a two-dimensional profile (lazy action). ; Template Parameters. V1The type of the column used to fill the x axis of the histogram. Inferred if not present. ; V2The type of the column used to fill the y axis of the histogram. Inferred if not present. ; V3The type of the column used to fill the z axis of the histogram. Inferred if not present. ; WThe type of the column used for the weights of the histogram. Inferred if not present. . Parameters. [in]modelThe returned histogram will be constructed using this as a model. ; [in]v1NameThe name of the column that will fill the x axis. ; [in]v2NameThe name of the column that will fill the y axis. ; [in]v3NameThe name of the column that will fill the z axis. ; [in]wNameThe name of the column that will provide the weights. . Returnsthe bidimensional profile wrapped in a RResultPtr.; This action is lazy: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr. Example usage:; // Deduce column types (this invocation needs jitting internally); auto myProf1 = myDf.Profile2D({""profName"", ""profTitle"", 40, -4, 4, 40, -4, 4, 0, 20},; ""xValues"", ""yValues"", ""zValues"", ""weight"");; // Explicit column types; auto myProf2 = myDf.Profile2D<int, float, double, int>({""profName"", ""profTitle"", 40, -4, 4, 40, -4, 4, 0, 20},; ""xValues"", ""yValues"", ""zValues"", ""weight"");; See the first Profile2D() overload for more details. ; Definition at line 2474 of file RInterface.hxx. ◆ Profile2D() [3/3]. template<typename Proxied , typename DataSource = void> . template<typename V1 = RDFDetail::RInferredType, typename V2 = RDFDetail::RInferredType, typename V3 = RDFDetail::RInferredType> . RResultPtr<::TProfile2D > ROOT::RDF::RInterface< Proxied, DataSource >::Profile2D ; (; const TProfile2DModel & ; model, . std::string_view ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:110469,wrap,wrapped,110469,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['wrap'],['wrapped']
Integrability," >;  Execute a function over a sequence of indexes in parallel. ;  ; template<class F , class T , class Cond = validMapReturnCond<F, T>> ; auto MapImpl (F func, std::vector< T > &args) -> std::vector< InvokeResult_t< F, T > >;  Execute a function over the elements of a vector in parallel Implementation of the Map method. ;  ; template<class F , class Cond = validMapReturnCond<F>> ; auto MapImpl (F func, unsigned nTimes) -> std::vector< InvokeResult_t< F > >;  Execute a function without arguments several times in parallel. ;  ; void ReplyToFuncResult (TSocket *s);  Reply to a worker who just sent a result. ;  ; void ReplyToIdle (TSocket *s);  Reply to a worker who is idle. ;  ; void Reset ();  Reset TProcessExecutor's state. ;  ;  Private Member Functions inherited from TMPClient;  TMPClient (const TMPClient &)=delete;  ;  TMPClient (unsigned nWorkers=0);  Class constructor. ;  ;  ~TMPClient ();  Class destructor. ;  ; template<class T > ; unsigned Broadcast (unsigned code, const std::vector< T > &objs);  Send a message with a different object to each server. ;  ; template<class T > ; unsigned Broadcast (unsigned code, std::initializer_list< T > &objs);  Send a message with a different object to each server. ;  ; template<class T > ; unsigned Broadcast (unsigned code, T obj, unsigned nMessages=0);  Send a message containing code and obj to each worker, up to a maximum number of nMessages workers. ;  ; unsigned Broadcast (unsigned code, unsigned nMessages=0);  Send a message with the specified code to at most nMessages workers. ;  ; void DeActivate (TSocket *s);  DeActivate a certain socket. ;  ; bool Fork (TMPWorker &server);  This method forks the ROOT session into fNWorkers children processes. ;  ; bool GetIsParent () const;  ; TMonitor & GetMonitor ();  ; unsigned GetNWorkers () const;  ; void HandleMPCode (MPCodeBufPair &msg, TSocket *sender);  Handle messages containing an EMPCode. ;  ; TMPClient & operator= (const TMPClient &)=delete;  ; void ReapWorkers ();  W",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TProcessExecutor.html:9905,message,message,9905,doc/v632/classROOT_1_1TProcessExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TProcessExecutor.html,2,['message'],['message']
Integrability," > FileMap_t;  . Private Member Functions;  TProof (const TProof &);  ; void Activate (TList *slaves=0);  Activate slave server list. ;  ; void ActivateAsyncInput ();  Activate the a-sync input handler. ;  ; void AskForOutput (TSlave *sl);  Master asks for output from worker sl. ;  ; void AskParallel ();  Ask the for the number of parallel slaves. ;  ; void AskStatistics ();  Ask the for the statistics of the slaves. ;  ; Int_t Broadcast (const char *mess, Int_t kind, TList *slaves);  Broadcast a character string buffer to all slaves in the specified list. ;  ; Int_t Broadcast (const char *mess, Int_t kind=kMESS_STRING, ESlaves list=kActive);  Broadcast a character string buffer to all slaves in the specified list (either all slaves or only the active slaves). ;  ; Int_t Broadcast (const TMessage &mess, ESlaves list=kActive);  Broadcast a message to all slaves in the specified list (either all slaves or only the active slaves). ;  ; Int_t Broadcast (const TMessage &mess, TList *slaves);  Broadcast a message to all slaves in the specified list. ;  ; Int_t Broadcast (Int_t kind, ESlaves list=kActive);  ; Int_t Broadcast (Int_t kind, TList *slaves);  ; Int_t BroadcastFile (const char *file, Int_t opt, const char *rfile, TList *wrks);  Broadcast file to all workers in the specified list. ;  ; Int_t BroadcastFile (const char *file, Int_t opt, const char *rfile=0, ESlaves list=kAllUnique);  Broadcast file to all workers in the specified list. ;  ; Int_t BroadcastGroupPriority (const char *grp, Int_t priority, ESlaves list=kAllUnique);  Broadcast the group priority to all workers in the specified list. ;  ; Int_t BroadcastGroupPriority (const char *grp, Int_t priority, TList *workers);  Broadcast the group priority to all workers in the specified list. ;  ; Int_t BroadcastObject (const TObject *obj, Int_t kind, TList *slaves);  Broadcast an object to all slaves in the specified list. ;  ; Int_t BroadcastObject (const TObject *obj, Int_t kind=kMESS_OBJECT, ESlaves list=kAct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:45859,message,message,45859,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['message'],['message']
Integrability," ? strlen(s1) : 0, s2.Data(), s2.Length()); }. TString & ReplaceAll(const char* s1, const char* s2); { return ReplaceAll(s1, s1 ? strlen(s1) : 0, s2, s2 ? strlen(s2) : 0); }. char & operator()(Ssiz_t i); { Cow(); return fData[i]; }. char operator[](Ssiz_t i) const; { AssertElement(i); return fData[i]; }. char operator()(Ssiz_t i) const; { return fData[i]; }. Ssiz_t Length() const; { return fNchars; }. Ssiz_t Capacity() const; { return fCapacity; }. char * Data() const; { return (char*)(this+1); }. Ssiz_t First(char c) const. Ssiz_t First(const char* cs) const. Ssiz_t Last(char c) const. char & operator()(Ssiz_t i). char operator()(Ssiz_t i) const. Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. TString(const char* a1, Ssiz_t n1, const char* a2, Ssiz_t n2); Special concatenation constructor. TStringRef * Pref() const; { return (((TStringRef*) fData) - 1); }. TString(). TString * ReadString(TBuffer& b, const TClass* clReq). Bool_t Gets(FILE* fp, Bool_t chop = kTRUE); C I/O interface. void Puts(FILE* fp). operator const char*() const; Type conversion. { return fData; }. char & operator()(Ssiz_t i). char operator()(Ssiz_t i) const. Ssiz_t Index(const char* s, Ssiz_t i = 0, TString::ECaseCompare cmp = kExact) const. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const. Ssiz_t Index(const TRegexp& pat, Ssiz_t i = 0) const. Ssiz_t Index(const TRegexp& pat, Ssiz_t* ext, Ssiz_t i = 0) const. Bool_t IsWhitespace() const; { return (Length() == CountChar(' ')); }. istream & ReadFile(istream& str). istream & ReadLine(istream& str, Bool_t skipWhite = kTRUE). istream & ReadToDelim(istream& str, char delim = '\n'). istream & ReadToken(istream& str). TObjArray * Tokenize(const TString& delim) const. » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TString.h 34285 2010-07-01 20:37:52Z rdm $ » Last generated: 2010-12-03 14:59; This page has",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TString.html:21961,interface,interface,21961,root/html528/TString.html,https://root.cern,https://root.cern/root/html528/TString.html,1,['interface'],['interface']
Integrability," @param size maximum number of sub-intervals. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). IntegratorMultiDim(const Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000); Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). virtual ~IntegratorMultiDim(); destructor. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const; return integration error. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IntegratorMultiDim.html:3545,integrat,integration,3545,root/html526/ROOT__Math__IntegratorMultiDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IntegratorMultiDim.html,1,['integrat'],['integration']
Integrability," @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IntegratorMultiDim.html:3644,Integrat,IntegratorMultiDim,3644,root/html532/ROOT__Math__IntegratorMultiDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IntegratorMultiDim.html,8,['Integrat'],"['Integrator', 'IntegratorMultiDim']"
Integrability," A TGraph has the default title and name ""Graph"". To change the default title and name SetTitle and SetName should be called on the TGraph after its creation. TGraph was a light weight object to start with, like TPolyline or TPolyMarker. That’s why it did not have any title and name parameters in the constructors. Example; The picture below gives an example:; {; double x[100], y[100];; int n = 20;; for (int i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; auto g = new TGraph(n,x,y);; g->SetTitle(""Graph title;X title;Y title"");; g->Draw(""AC*"");; }; g#define g(i)Definition RSha256.hxx:105; TGraph::TGraphTGraph()Graph default constructor.Definition TGraph.cxx:108; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16. Default X-Points; If one doesn't specify the points in the x-axis, they will get the default values 0, 1, 2, 3, (etc. depending on the length of the y-points):; {; double y[6] = {3, 8, 1, 10, 5, 7};; auto g = new TGraph(6,y);; g->SetTitle(""A Graph with default X points"");; g->Draw();; }. Definition at line 41 of file TGraph.h. Public Types; enum  EStatusBits { ;   kNoStats = (1ULL << ( 9 )); , kClipFrame = (1ULL << ( 10 )); , kResetHisto = (1ULL << ( 17 )); , kNotEditable = (1ULL << ( 18 )); , ;   kIsSortedX = (1ULL << ( 19 )); , kIsHighlight = (1ULL << ( 20 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:1786,depend,depending,1786,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['depend'],['depending']
Integrability," A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. See an example of a Branch definition in the TTree constructor. Note that in case the data type is an object, this branch can contain; only this object. Note that this function is invoked by TTree::Branch. TBranch(TBranch* parent, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1); Create a Branch as a child of another Branch. See documentation for; TBranch::TBranch(TTree *, const char *, void *, const char *, Int_t, Int_t). void Init(const char* name, const char* leaflist, Int_t compress); Initialization routine called from the constructor. This should NOT be made virtual. ~TBranch(); Destructor. void AddBasket(TBasket& b, Bool_t ondisk, Long64_t startEntry); Add the basket to this branch. void AddLastBasket(Long64_t startEntry); Add the start entry of the write basket (not yet created). void Browse(TBrowser* b); Browser interface. void DeleteBaskets(Option_t* option = """"); Loop on all branch baskets. If the file where branch buffers reside is; writable, free the disk space associated to the baskets of the branch,; then call Reset(). If the option contains ""all"", delete also the baskets; for the subbranches.; The branch is reset.; NOTE that this function must be used with extreme care. Deleting branch baskets; fragments the file and may introduce inefficiencies when adding new entries; in the Tree or later on when reading the Tree. void DropBaskets(Option_t* option = """"); Loop on all branch baskets. Drop all baskets from memory except readbasket.; If the option contains ""all"", drop all baskets including; read- and write-baskets (unless they are not stored individually on disk).; The option ""all"" also lead to DropBaskets being called on the sub-branches. void ExpandBasketArrays(); Increase BasketEntry buffer of a minimum of 10 locations; and a maximum of 50 per cent of current size. Int_t Fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBranch.html:16025,interface,interface,16025,root/html532/TBranch.html,https://root.cern,https://root.cern/root/html532/TBranch.html,8,['interface'],['interface']
Integrability," ACLiC. The filename must have the format:; 2311/// [path/]macro.C[+|++[g|O]][(args)].; 2312/// The possible error codes are defined by TInterpreter::EErrorCode.; 2313/// If padUpdate is true (default) update the current pad.; 2314/// Returns the macro return value.; 2315 ; 2316Longptr_t TROOT::Macro(const char *filename, Int_t *error, Bool_t padUpdate); 2317{; 2318 Longptr_t result = 0;; 2319 ; 2320 if (fInterpreter) {; 2321 TString aclicMode;; 2322 TString arguments;; 2323 TString io;; 2324 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2325 ; 2326 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2327 if (!mac) {; 2328 Error(""Macro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2329 if (error); 2330 *error = TInterpreter::kFatal;; 2331 } else {; 2332 fname = mac;; 2333 fname += aclicMode;; 2334 fname += arguments;; 2335 fname += io;; 2336 result = gInterpreter->ExecuteMacro(fname, (TInterpreter::EErrorCode*)error);; 2337 }; 2338 delete [] mac;; 2339 ; 2340 if (padUpdate && gPad); 2341 gPad->Update();; 2342 }; 2343 ; 2344 return result;; 2345}; 2346 ; 2347////////////////////////////////////////////////////////////////////////////////; 2348/// Process message id called by obj.; 2349 ; 2350void TROOT::Message(Int_t id, const TObject *obj); 2351{; 2352 TIter next(fMessageHandlers);; 2353 TMessageHandler *mh;; 2354 while ((mh = (TMessageHandler*)next())) {; 2355 mh->HandleMessage(id,obj);; 2356 }; 2357}; 2358 ; 2359////////////////////////////////////////////////////////////////////////////////; 2360/// Process interpreter command via TApplication::ProcessLine().; 2361/// On Win32 the line will be processed asynchronously by sending; 2362/// it to the CINT interpreter thread. For explicit synchronous processing; 2363/// use ProcessLineSync(). On non-Win32 platforms there is no difference; 2364/// between ProcessLine() and ProcessLineSync().; 2365/// The possible error codes are defined by TInterpret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:89218,message,message,89218,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['message'],['message']
Integrability," AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TF1*func; RooListProxyolist; RooListProxyplist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTFnBinding.html:31537,integrat,integrator,31537,root/html526/RooTFnBinding.html,https://root.cern,https://root.cern/root/html526/RooTFnBinding.html,2,['integrat'],['integrator']
Integrability," About Previous Developers. The following people have been working on ROOT for some time in their career and ROOT would not be what it is without their contributions:; Andrei Gheata; Andrei works since 2001 in the offline group of the ALICE experiment. He is an experimental nuclear physicist who worked before ALICE on data analysis for heavy-ion experiments in emulsions. In 2000 he started collaborating with the ROOT project and implemented the TreeViewer interface. Andrei is the main developer of the ROOT geometry package. He integrated the geometry in the Virtual Monte Carlo framework by developing interfaces for the GEANT3, GEANT4 and FLUKA particle transport engines.; Anna Kreshuk; Anna was a project associate and contributed to different parts of ROOT, most notably to the fitting machinery, the interface to FFTW, numerous math-related functions, TEntryList container and PROOF GUI.; David Gonzalez Maline; David has been working on improving the performance and correctness of various mathematical algorithms as well as on integrating AI methods for data analysis inside the framework. He has also worked on extending and improving the FitPanel interface.; Diego Marcos Segura; Diego worked as technical student on CINT dictionary optimizations.; Eddy Offermann; Eddy joined the ROOT team during a sabbatical to work on making the ROOT matrix package the fastest and most versatile in the industry.; Ilka Antcheva; Ilka has been working from 2002 to 2008 in the ROOT team. She was responsible for the GUI system and designed many high level user interfaces and widgets, like found in many modern graphics applications: ROOT graphics editor (GED) and various object editors, Fit Panel, Style manager, a tool for automatic C++ code generation of any widget and the capability for widgets to save themselves. In addition Ilka took care of the ROOT Users Guide and contributed the chapter ‘Writing a Graphical User Interface’.; Gerardo Ganis; Gerri was a team member for more than ten ye",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/previous-developers.html:2895,integrat,integrating,2895,d/previous-developers.html,https://root.cern,https://root.cern/d/previous-developers.html,1,['integrat'],['integrating']
Integrability," AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:494; TClass::GetMissingDictionariesForBaseClassesvoid GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)Verify the base classes always.Definition TClass.cxx:3927; TClass::fSchemaRulesROOT::Detail::TSchemaRuleSet * fSchemaRulesPointer to reference proxy if this class represents a reference.Definition TClass.h:281; TClass::fPropertystd::atomic< Long_t > fPropertyDefinition TClass.h:255; TClass::StreamerDefaultstatic void StreamerDefault(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Default streaming in cases where either we have no way to know what to do or if Property() has not ye...Definition TClass.cxx:6873; TClass::SetUnloadedvoid SetUnloaded()Call this method to indicate that the shared library containing this class's code has been removed (u...Definition TClass.cxx:6309; TClass::GetDeleteArrayROOT::DelArrFunc_t GetDeleteArray() constReturn the wrapper around delete [] ThiObject.Definition TClass.cxx:7471; TClass::HasInterpreterInfoInMemoryBool_t HasInterpreterInfoInMemory() constDefinition TClass.h:409; TClass::fClassMenuListTList * fClassMenuListDefinition TClass.h:211; TClass::fConvStreamerFuncClassConvStreamerFunc_t fConvStreamerFuncDefinition TClass.h:242; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2031; TClass::SetRuntimePropertiesvoid SetRuntimeProperties()Internal routine to set calculate the class properties that can only be known at run-time,...Definition TClass.cxx:6194; TClass::BuildEmulatedRealDatavoid BuildEmulatedRealData(const char *name, Longptr_t offset, TClass *cl, Bool_t isTransient=kFALSE)Build the list of real data for an emulated class.Definition TClass.cxx:2112; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:323197,wrap,wrapper,323197,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['wrap'],['wrapper']
Integrability," AddClass(TClass *cl)static: Add a class to the list and map of classes.Definition TClass.cxx:555; TClass::GetMissingDictionariesForBaseClassesvoid GetMissingDictionariesForBaseClasses(TCollection &result, TCollection &visited, bool recurse)Verify the base classes always.Definition TClass.cxx:3994; TClass::fSchemaRulesROOT::Detail::TSchemaRuleSet * fSchemaRulesPointer to reference proxy if this class represents a reference.Definition TClass.h:281; TClass::fPropertystd::atomic< Long_t > fPropertyDefinition TClass.h:255; TClass::StreamerDefaultstatic void StreamerDefault(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Default streaming in cases where either we have no way to know what to do or if Property() has not ye...Definition TClass.cxx:6940; TClass::SetUnloadedvoid SetUnloaded()Call this method to indicate that the shared library containing this class's code has been removed (u...Definition TClass.cxx:6376; TClass::GetDeleteArrayROOT::DelArrFunc_t GetDeleteArray() constReturn the wrapper around delete [] ThiObject.Definition TClass.cxx:7538; TClass::HasInterpreterInfoInMemoryBool_t HasInterpreterInfoInMemory() constDefinition TClass.h:409; TClass::fClassMenuListTList * fClassMenuListDefinition TClass.h:211; TClass::fConvStreamerFuncClassConvStreamerFunc_t fConvStreamerFuncDefinition TClass.h:242; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::SetRuntimePropertiesvoid SetRuntimeProperties()Internal routine to set calculate the class properties that can only be known at run-time,...Definition TClass.cxx:6261; TClass::BuildEmulatedRealDatavoid BuildEmulatedRealData(const char *name, Longptr_t offset, TClass *cl, Bool_t isTransient=kFALSE)Build the list of real data for an emulated class.Definition TClass.cxx:2179; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:325835,wrap,wrapper,325835,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['wrap'],['wrapper']
Integrability," AnnotatedRecordDecl & ; cl, . const clang::CXXRecordDecl * ; decl, . const cling::Interpreter & ; interp, . const TNormalizedCtxt & ; normCtxt, . const RConstructorTypes & ; ctorTypes, . bool & ; needCollectionProxy . ). FIXME: a function of 450+ lines! ; Definition at line 1694 of file TClingUtils.cxx. ◆ WriteNamespaceHeader() [1/2]. int ROOT::TMetaUtils::WriteNamespaceHeader ; (; std::ostream & ; out, . const clang::DeclContext * ; ctxt . ). Write all the necessary opening part of the namespace and return the number of closing brackets needed For example for Space1::Space2 we write: namespace Space1 { namespace Space2 { and return 2. ; Definition at line 2206 of file TClingUtils.cxx. ◆ WriteNamespaceHeader() [2/2]. int ROOT::TMetaUtils::WriteNamespaceHeader ; (; std::ostream & ; out, . const clang::RecordDecl * ; cl . ). Definition at line 2230 of file TClingUtils.cxx. ◆ WritePointersSTL(). void ROOT::TMetaUtils::WritePointersSTL ; (; const AnnotatedRecordDecl & ; cl, . const cling::Interpreter & ; interp, . const TNormalizedCtxt & ; normCtxt . ). Write interface function for STL members. ; Definition at line 2459 of file TClingUtils.cxx. Variable Documentation. ◆ kError. const int ROOT::TMetaUtils::kError = 2000. Definition at line 129 of file TClingUtils.h. ◆ kFatal. const int ROOT::TMetaUtils::kFatal = 4000. Definition at line 131 of file TClingUtils.h. ◆ kInfo. const int ROOT::TMetaUtils::kInfo = 0. Definition at line 126 of file TClingUtils.h. ◆ kMaxLen. const int ROOT::TMetaUtils::kMaxLen = 1024. Definition at line 132 of file TClingUtils.h. ◆ kNote. const int ROOT::TMetaUtils::kNote = 500. Definition at line 127 of file TClingUtils.h. ◆ kSysError. const int ROOT::TMetaUtils::kSysError = 3000. Definition at line 130 of file TClingUtils.h. ◆ kWarning. const int ROOT::TMetaUtils::kWarning = 1000. Definition at line 128 of file TClingUtils.h. ROOTTMetaUtils. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:14:05 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1TMetaUtils.html:52760,interface,interface,52760,doc/v632/namespaceROOT_1_1TMetaUtils.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1TMetaUtils.html,1,['interface'],['interface']
Integrability," Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indice",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:6466,interface,interface,6466,root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,4,['interface'],['interface']
Integrability," Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:6161,interface,interface,6161,root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,9,['interface'],['interface']
Integrability," Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6063,interface,interface,6063,root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,9,['interface'],['interface']
Integrability," Asynchronous Actions; Different threads can work simultaneously with the same object. Some actions can be dangerous. For example, when two threads create a histogram object, ROOT allocates memory and puts them to the same collection. If it happens at the same time, the results are undetermined. To avoid this problem, the user has to synchronize these actions with:; TThread::Lock() // Locking the following part of code; ... // Create an object, etc...; TThread::UnLock() // Unlocking; The code between Lock() and UnLock() will be performed uninterrupted. No other threads can perform actions or access objects/collections while it is being executed. The methods TThread::Lock()and TThread::UnLock() internally use a global TMutex instance for locking.; The user may also define their own TMutex MyMutex instance and may locally protect their asynchronous actions by calling MyMutex.Lock() and MyMutex.UnLock().; 23.2.4.2 Synchronous Actions: TCondition; To synchronize the actions of different threads you can use the TCondition class, which provides a signaling mechanism. The TCondition instance must be accessible by all threads that need to use it, i.e. it should be a global object (or a member of the class which owns the threaded methods, see below). To create a TCondition object, a TMutex instance is required for the Wait and TimedWait locking methods. One can pass the address of an external mutex to the TCondition constructor:; TMutex MyMutex;; TCondition MyCondition(&MyMutex);; If zero is passed, TCondition creates and uses its own internal mutex:; TCondition MyCondition(0);; You can now use the following methods of synchronization:. TCondition::Wait() waits until any thread sends a signal of the same condition instance: MyCondition.Wait() reacts on MyCondition.Signal() or MyCondition.Broadcast(). MyOtherCondition.Signal() has no effect.; If several threads wait for the signal from the same TCondition MyCondition, at MyCondition.Signal() only one thread will react; to act",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1108140,synchroniz,synchronize,1108140,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['synchroniz'],['synchronize']
Integrability," Attributes; TBranch & fParent;  . Friends; class ::TBranch;  . #include <TBranch.h>; Constructor & Destructor Documentation. ◆ TBulkBranchRead(). ROOT::Experimental::Internal::TBulkBranchRead::TBulkBranchRead ; (; TBranch & ; parent). inlineprivate . Definition at line 83 of file TBranch.h. Member Function Documentation. ◆ GetBulkEntries(). Int_t ROOT::Experimental::Internal::TBulkBranchRead::GetBulkEntries ; (; Long64_t ; evt, . TBuffer & ; user_buf . ). inline . See TBranch::GetBulkEntries(Long64_t evt, TBuffer &user_buf);. ; Definition at line 320 of file TBranch.h. ◆ GetEntriesSerialized() [1/2]. Int_t ROOT::Experimental::Internal::TBulkBranchRead::GetEntriesSerialized ; (; Long64_t ; evt, . TBuffer & ; user_buf . ). inline . See TBranch::GetEntriesSerialized(Long64_t evt, TBuffer &user_buf);. ; Definition at line 321 of file TBranch.h. ◆ GetEntriesSerialized() [2/2]. Int_t ROOT::Experimental::Internal::TBulkBranchRead::GetEntriesSerialized ; (; Long64_t ; evt, . TBuffer & ; user_buf, . TBuffer * ; count_buf . ). inline . See TBranch::GetEntriesSerialized(Long64_t evt, TBuffer &user_buf, TBuffer *count_buf);. ; Definition at line 322 of file TBranch.h. ◆ SupportsBulkRead(). bool ROOT::Experimental::Internal::TBulkBranchRead::SupportsBulkRead ; (; ); const. inline . Return true if the branch can be read through the bulk interfaces. ; Definition at line 323 of file TBranch.h. Friends And Related Symbol Documentation. ◆ ::TBranch. friend class ::TBranch. friend . Definition at line 70 of file TBranch.h. Member Data Documentation. ◆ fParent. TBranch& ROOT::Experimental::Internal::TBulkBranchRead::fParent. private . Definition at line 87 of file TBranch.h. Libraries for ROOT::Experimental::Internal::TBulkBranchRead:. [legend]; The documentation for this class was generated from the following file:; tree/tree/inc/TBranch.h. ROOTExperimentalInternalTBulkBranchRead. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1TBulkBranchRead.html:2457,interface,interfaces,2457,doc/master/classROOT_1_1Experimental_1_1Internal_1_1TBulkBranchRead.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1TBulkBranchRead.html,1,['interface'],['interfaces']
Integrability," B; F(3,*) - Z; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceCylindrical(Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in cylindrical coordinates. Input: IORDR - order of variables (0 - Z,PHI, 1 - PHI,Z); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. /*; ; */. void SurfaceSpherical(Int_t ipsdr, Int_t iordr, Int_t na, Int_t nb, const char* chopt); Draw surface in spheric coordinates. Input: IPSDR - pseudo-rapidity flag; IORDR - order of variables (0 - THETA,PHI; 1 - PHI,THETA); NA - number of steps along 1st variable; NB - number of steps along 2nd variable. FUN(IA,IB,F,T) - external routine; IA - cell number for 1st variable; IB - cell number for 2nd variable; F(3,4) - face which corresponds to the cell; F(1,*) - A; F(2,*) - B; F(3,*) - R; T(4) - additional function (for example: temperature). DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - IA; ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPainter3dAlgorithms.html:31220,rout,routine,31220,root/html528/TPainter3dAlgorithms.html,https://root.cern,https://root.cern/root/html528/TPainter3dAlgorithms.html,10,['rout'],['routine']
Integrability," Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wrapper. Bool_t HasMenuBar(); just a wrapper. void Iconify(); just a wrapper. Bool_t IsBatch(); just a wrapper. Bool_t IsRetained(); just a wrapper. void ls(Option_t* option = """"); just a wrapper. void MoveOpaque(Int_t set = 1); just a wrapper. Bool_t OpaqueMoving(); just a wrapper. Bool_t OpaqueResizing(); just a wrapper. void Paint(Option_t* option = """"); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObjLink*& pickobj); just a wrapper. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); just a wrapper. void Resize(Option_t* option = """"); just a wrapper. void ResizeOpaque(Int_t set = 1); just a wrapper. void SaveSource(const char* filename = """", Option_t* option = """"); just a wrapper. void SetCursor(ECursor cursor); just a wrapper. void SetDoubleBuffer(Int_t mode = 1); just a wrapper. void SetWindowPosition(Int_t x, Int_t y); just a wrapper. void SetWindowSize(UInt_t ww, UInt_t wh); just a wrapper. void SetCanvasSize(UInt_t ww, UInt_t wh); just a wrapper. void SetHighLightColor(Color_t col); just a wrapper. void SetSelected(TObject* obj); just a wrapper. void SetSelectedPad(TPad* pad); just a wrapper. void Show(); just a wrapper. void Size(Float_t xsizeuser = 0, Float_t ysizeuser = 0); just a wrapper. void SetBatch(Bool_t batch = kTRUE); just a wrapper. void SetRetained(Bool_t retained = kTRUE); just a wrapper. void SetTit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQRootCanvas.html:6869,wrap,wrapper,6869,root/html528/TQRootCanvas.html,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html,5,['wrap'],['wrapper']
Integrability," Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); LD can handle classification with 2 classes and regression with one regression-target. void Train( void ); compute fSumMatx. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); Returns the MVA classification output. const std::vector< Float_t >& GetRegressionValues(); Calculates the regression output. void InitMatrices( void ); Initializaton method; creates global matrices and vectors. void GetSum( void ); Calculates the matrix transposed(X)*W*X with W being the diagonal weight matrix; and X the coordinates values. void GetSumVal( void ); Calculates the vector transposed(X)*W*Y with Y being the target vector. void GetLDCoeff( void ); Calculates the coeffiecients used for classification/regression. void ReadWeightsFromStream(istream& i); read LD coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description for LD classification and regression; (for arbitrary number of output classes/targets). void ReadWeightsFromXML(void* wghtnode); read coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write LD-specific classifier response. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void DeclareOptions(); MethodLD options. void ProcessOptions(); this is the preparation for training. void PrintCoefficients( void ); Display the classification/regression coefficients for each variable. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". » Author: Krzysztof Danielowski, Kamil Kraszewski, Maciej Kruk, Jan Therhaag » Copyright (c) 2008-2011: *; » Last changed: Sat Mar 14 16:43:54 2015 » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodLD.html:18225,message,message,18225,root/html534/TMVA__MethodLD.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodLD.html,2,['message'],['message']
Integrability," Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooFormulaVar(); RooFormulaVar(const RooFormulaVar& other, const char* name = 0); RooFormulaVar(const char* name, const char* title, const RooArgList& dependents); RooFormulaVar(const char* name, const char* title, const char* formula, const RooArgList& dependents); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFormulaVar.html:23880,depend,dependents,23880,root/html602/RooFormulaVar.html,https://root.cern,https://root.cern/root/html602/RooFormulaVar.html,4,['depend'],['dependents']
Integrability," Bool_t extended = kFALSE); Constructor p.d.f implementing sum_i [ coef_i * func_i ], if N_coef==N_func; or sum_i [ coef_i * func_i ] + (1 - sum_i [ coef_i ] )* func_N if Ncoef==N_func-1. All coefficients and functions are allowed to be negative; but the sum is not, which is enforced at runtime. RooRealSumPdf(const RooRealSumPdf& other, const char* name = 0); Copy constructor. ~RooRealSumPdf(); Destructor. RooAbsPdf::ExtendMode extendMode() const. Double_t evaluate() const; Calculate the current value. Bool_t checkObservables(const RooArgSet* nset) const; Check if FUNC is valid for given normalization set.; Coeffient and FUNC must be non-overlapping, but func-coefficient; pairs may overlap each other. In the present implementation, coefficients may not be observables or derive; from observables. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implement analytical integrations by deferring integration of component; functions to integrators of components. Double_t expectedEvents(const RooArgSet* nset) const. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooRealSumPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. const RooArgList& funcList() const; { return _funcList ; }. const RooArgList& coefList() const; { return _coefList ; }. Double_t expectedEvents(const RooArgSet* nset) const. » Last changed: Mon Jul 4 15:23:52 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealSumPdf.html:42930,integrat,integrations,42930,root/html530/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html530/RooRealSumPdf.html,3,['integrat'],"['integration', 'integrations', 'integrators']"
Integrability," Bool_t fromFile = kFALSE); build network given a layout (number of neurons in each layer); and optional weights array. void BuildLayers(vector<Int_t>* layout, Bool_t from_file = false); build the network layers. void BuildLayer(Int_t numNeurons, TObjArray* curLayer, TObjArray* prevLayer, Int_t layerIndex, Int_t numLayers, Bool_t from_file = false); build a single layer with neurons and synapses connecting this; layer to the previous layer. void AddPreLinks(TMVA::TNeuron* neuron, TObjArray* prevLayer); add synapses connecting a neuron to its preceding layer. void InitWeights(); initialize the synapse weights randomly. void ForceWeights(vector<Double_t>* weights); force the synapse weights. void ForceNetworkInputs(const TMVA::Event* ev, Int_t ignoreIndex = -1); force the input values of the input neurons; force the value for each input neuron. void ForceNetworkCalculations(); calculate input values to each neuron. void PrintMessage(TString message, Bool_t force = kFALSE) const; print messages, turn off printing by setting verbose and debug flag appropriately. void WaitForKeyboard(); wait for keyboard input, for debugging. void PrintNetwork() const; print network representation, for debugging. void PrintLayer(TObjArray* layer) const; print a single layer, for debugging. void PrintNeuron(TMVA::TNeuron* neuron) const; print a neuron, for debugging. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); get the mva value generated by the NN. const std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the NN. const std::vector<Float_t> & GetMulticlassValues(); get the multiclass classification values generated by the NN. void AddWeightsXMLTo(void* parent) const; create XML description of ANN classifier. void ReadWeightsFromXML(void* wghtnode); read MLP from xml weight file. void ReadWeightsFromStream(istream& istr); destroy/clear the network then read it back in from the weights file. const TMVA::Ranking* CreateRanking(); compute ra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodANNBase.html:19962,message,message,19962,root/html528/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodANNBase.html,20,['message'],"['message', 'messages']"
Integrability," Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooXYChi2Var(); RooXYChi2Var(const RooXYChi2Var& other, const char* name = 0); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidRooAbsOptTestStatistic::seal(const char* notice = """"); const char*RooAbsOptTestStatistic::sealNotice() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooXYChi2Var.html:24212,integrat,integrate,24212,root/html602/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html602/RooXYChi2Var.html,4,['integrat'],['integrate']
Integrability," Bool_t rnr_children=kFALSE);  Disable rendering of children and their list contents. ;  ; void DumpSourceObject () const;  Call Dump() on source object. ;  ; virtual void ElementChanged (Bool_t update_scenes=kTRUE, Bool_t redraw=kFALSE);  Call this after an element has been changed so that the state can be propagated around the framework. ;  ; void EnableListElements (Bool_t rnr_self=kTRUE, Bool_t rnr_children=kTRUE);  Enable rendering of children and their list contents. ;  ; List_i EndChildren ();  ; List_ci EndChildren () const;  ; List_i EndParents ();  ; List_ci EndParents () const;  ; virtual void ExpandIntoListTree (TGListTree *ltree, TGListTreeItem *parent);  Populates parent with elements. ;  ; void ExportSourceObjectToCINT (char *var_name) const;  Export source object to CINT with given name for the variable. ;  ; virtual void ExportToCINT (char *var_name);  Export render-element to CINT with variable name var_name. ;  ; virtual void FillImpliedSelectedSet (Set_t &impSelSet);  Populate set impSelSet with derived / dependant elements. ;  ; TEveElement * FindChild (const TString &name, const TClass *cls=nullptr);  Find the first child with given name. ;  ; TEveElement * FindChild (TPRegexp &regexp, const TClass *cls=nullptr);  Find the first child whose name matches regexp. ;  ; Int_t FindChildren (List_t &matches, const TString &name, const TClass *cls=nullptr);  Find all children with given name and append them to matches list. ;  ; Int_t FindChildren (List_t &matches, TPRegexp &regexp, const TClass *cls=nullptr);  Find all children whose name matches regexp and append them to matches list. ;  ; virtual sLTI_i FindItem (TGListTree *ltree);  Find any list-tree-item of this element in list-tree 'ltree'. ;  ; virtual sLTI_i FindItem (TGListTree *ltree, TGListTreeItem *parent_lti);  Find list-tree-item of this element with given parent list-tree-item. ;  ; virtual TGListTreeItem * FindListTreeItem (TGListTree *ltree);  Find any list-tree-item of this element ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveArrow.html:6525,depend,dependant,6525,doc/master/classTEveArrow.html,https://root.cern,https://root.cern/doc/master/classTEveArrow.html,49,['depend'],['dependant']
Integrability," Bool_t valueOnly=kTRUE); Return the observables of _this_ pdf given a set of observables. return getObservables(&set,valueOnly). RooArgSet* getDependents(const RooArgSet& set); --- Obsolete functions for backward compatibility. { return getObservables(set) ; }. RooArgSet* getDependents(const RooAbsData* set); { return getObservables(set) ; }. RooArgSet* getDependents(const RooArgSet* depList); { return getObservables(depList) ; }. Bool_t dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg); { return observableOverlaps(dset,testArg) ; }. Bool_t dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg); { return observableOverlaps(depList, testArg) ; }. Bool_t checkDependents(const RooArgSet* nset) const; { return checkObservables(nset) ; }. Bool_t recursiveCheckDependents(const RooArgSet* nset) const; --- End obsolete functions for backward compatibility. { return recursiveCheckObservables(nset) ; }. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); I/O streaming interface (machine readable). void writeToStream(ostream& os, Bool_t compact) const. void Print(Option_t* options = 0) const; Printing interface (human readable). void printMetaArgs(ostream& ) const; {}. const std::set<std::string>& attributes() const; Returns set of names of boolean attributes defined. const std::map<std::string,std::string>& stringAttributes() const; Returns map<string,string> with all string attributes defined. const std::set<std::string>& transientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Constant' attribute is set. Bool_t IsSortable() const; Object is sortable in ROOT container class. Bool_t operator==(const RooAbsArg& other). Bool_t inRange(const char* ) const; Range management. Bool_t hasRange(const char* ) const; Has this argument a defined range (dummy interface always returns flase). Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsArg.html:38638,interface,interface,38638,root/html526/RooAbsArg.html,https://root.cern,https://root.cern/root/html526/RooAbsArg.html,1,['interface'],['interface']
Integrability," Bool_t zapOnError = kFALSE); TStringgetPunctuation() const; virtual TClass*IsA() const; Bool_tisPunctChar(char c) const; RooStreamParser&operator=(const RooStreamParser&); Bool_treadDouble(Double_t& value, Bool_t zapOnError = kFALSE); Bool_treadInteger(Int_t& value, Bool_t zapOnError = kFALSE); TStringreadLine(); Bool_treadString(TString& value, Bool_t zapOnError = kFALSE); TStringreadToken(); voidsetPunctuation(const TString& punct); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidzapToEnd(Bool_t inclContLines = kFALSE). Data Members; protected:. Bool_t_atEOF; Bool_t_atEOL; istream*_is; TString_prefix; TString_punct. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooStreamParser(istream& is); Construct parser on given input stream. RooStreamParser(istream& is, const TString& errPrefix); Construct parser on given input stream. Use given errorPrefix to; prefix any parsing error messages. ~RooStreamParser(); Destructor. Bool_t atEOL(); If true, parser is at end of line in stream. void setPunctuation(const TString& punct); Change list of characters interpreted as punctuation. Bool_t isPunctChar(char c) const; Check if given char is considered punctuation. TString readToken(); Read one token separated by any of the know punctuation characters; This function recognizes and handles comment lines in the istream (those; starting with '#', quoted strings ("""") the content of which is not tokenized; and '+-.' characters that are part of a floating point numbers and are exempt; from being interpreted as a token separator in case '+-.' are defined as; token separators. TString readLine(); Read an entire line from the stream and return as TString; This method recognizes the use of '\\' in the istream; as line continuation token. void zapToEnd(Bool_t inclContLines = kFALSE); Eat all characters up to and including then end of the; current line. If inclC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStreamParser.html:2544,message,messages,2544,root/html526/RooStreamParser.html,https://root.cern,https://root.cern/root/html526/RooStreamParser.html,1,['message'],['messages']
Integrability," Bool_tIsEqual(const TObject* obj) const; Bool_tIsExecuting() const; virtual Bool_tTCollection::IsFolder() const; Bool_tIsMacro() const; Bool_tTObject::IsOnHeap() const; Bool_tTCollection::IsOwner() const; Bool_tIsRedoing() const; virtual Bool_tIsSetter() const; virtual Bool_tTCollection::IsSortable() const; virtual Bool_tTSeqCollection::IsSorted() const; Bool_tIsUndoing() const; Bool_tTObject::IsZombie() const; virtual TObject*TList::Last() const; Int_tTSeqCollection::LastIndex() const; virtual TObjLink*TList::LastLink() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidls(Option_t* option = """") const; virtual TIterator*TList::MakeIterator(Bool_t dir = kIterForward) const; virtual TIterator*TCollection::MakeReverseIterator() const; voidTObject::MayNotUse(const char* method) const; virtual voidMerge(TQCommand* c); virtual Long64_tMerge(TCollection*, TFileMergeInfo*); virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; static Int_tTSeqCollection::ObjCompare(TObject* a, TObject* b); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject*TCollection::operator()(const char* name) const; TObject&TObject::operator=(const TObject& rhs); virtual voidTCollection::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTCollection::Print(Option_t* option = """") const; virtual voidTCollection::Prin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQCommand.html:11123,Message,Message,11123,root/html532/TQCommand.html,https://root.cern,https://root.cern/root/html532/TQCommand.html,1,['Message'],['Message']
Integrability," Bool_tIsEqual(const TObject* obj) const; Bool_tIsExecuting() const; virtual Bool_tTCollection::IsFolder() const; Bool_tIsMacro() const; Bool_tTObject::IsOnHeap() const; Bool_tTCollection::IsOwner() const; Bool_tIsRedoing() const; virtual Bool_tIsSetter() const; virtual Bool_tTCollection::IsSortable() const; virtual Bool_tTSeqCollection::IsSorted() const; Bool_tIsUndoing() const; Bool_tTObject::IsZombie() const; virtual TObject*TList::Last() const; Int_tTSeqCollection::LastIndex() const; virtual TObjLink*TList::LastLink() const; static voidTQObject::LoadRQ_OBJECT(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidls(Option_t* option = """") const; virtual TIterator*TList::MakeIterator(Bool_t dir = kIterForward) const; virtual TIterator*TCollection::MakeReverseIterator() const; voidTObject::MayNotUse(const char* method) const; virtual voidMerge(TQCommand* c); virtual Long64_tMerge(TCollection*, TFileMergeInfo*); virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; static Int_tTSeqCollection::ObjCompare(TObject* a, TObject* b); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject*TCollection::operator()(const char* name) const; virtual voidTCollection::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTCollection::Print(Option_t* option = """") const; virtual voidTCollection::Print(Option_t* option, Int_t recurse) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQCommand.html:11123,Message,Message,11123,root/html534/TQCommand.html,https://root.cern,https://root.cern/root/html534/TQCommand.html,1,['Message'],['Message']
Integrability," Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,int,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction3Ref<VO,VI1,VI2,VI3> Streamer(TBuffer& ); Custom stream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_double_int_int_.html:37107,integrat,integrator,37107,root/html602/RooCFunction3Binding_double_double_int_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_double_int_int_.html,4,['integrat'],['integrator']
Integrability," Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooCategoryProxy_catAccept/reject categort; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effFuncEfficiency modeling function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooEfficiency.html:40569,integrat,integration,40569,root/html534/RooEfficiency.html,https://root.cern,https://root.cern/root/html534/RooEfficiency.html,2,['integrat'],['integration']
Integrability," Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsSelfCachedReal.html:34353,integrat,integrator,34353,root/html532/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html532/RooAbsSelfCachedReal.html,1,['integrat'],['integrator']
Integrability," Bool_tTGCheckButton::IsDown() const; virtual Bool_tTGFrame::IsEditable() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTGButton::IsExclusiveToggle() const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGWindow::IsMapSubwindows() const; virtual Bool_tTGCheckButton::IsOn() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTGCheckButton::IsToggleButton() const; Bool_tTObject::IsZombie() const; virtual voidTGTextButton::Layout(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGWindow::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGedPatternSelect&operator=(const TGedPatternSelect&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidPatternSelected(Style_t pattern = 0)SIGNAL ; virtual voidTObject::Pop(); virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedPatternSelect.html:11371,Message,Message,11371,root/html602/TGedPatternSelect.html,https://root.cern,https://root.cern/root/html602/TGedPatternSelect.html,2,['Message'],['Message']
Integrability," Bool_tTGCheckButton::IsDown() const; virtual Bool_tTGFrame::IsEditable() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTGButton::IsExclusiveToggle() const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGWindow::IsMapSubwindows() const; virtual Bool_tTGCheckButton::IsOn() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTGCheckButton::IsToggleButton() const; Bool_tTObject::IsZombie() const; virtual voidTGTextButton::Layout(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGWindow::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGedSelect&operator=(const TGedSelect&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTGButton::Pressed()SIGNAL ; virtual voidTGFrame::Print(Option_t* optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedSelect.html:11298,Message,Message,11298,root/html602/TGedSelect.html,https://root.cern,https://root.cern/root/html602/TGedSelect.html,2,['Message'],['Message']
Integrability," Bool_tTGCheckButton::IsDown() const; virtual Bool_tTGFrame::IsEditable() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTGButton::IsExclusiveToggle() const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGWindow::IsMapSubwindows() const; virtual Bool_tTGCheckButton::IsOn() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tTGCheckButton::IsToggleButton() const; Bool_tTObject::IsZombie() const; virtual voidTGTextButton::Layout(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGWindow::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTGButton::Pressed()SIGNAL ; virtual voidTGFrame::Print(Option_t* option = """") const; virtual voidTGFrame::Proce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGColorSelect.html:11409,Message,Message,11409,root/html602/TGColorSelect.html,https://root.cern,https://root.cern/root/html602/TGColorSelect.html,2,['Message'],['Message']
Integrability," Bool_tTGCompositeFrame::IsEditable() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGCompositeFrame::Layout(); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTGCompositeFrame::Print(Option_t* option = """") const; virtual voidTGFrame::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveGTriVecValuator.html:10808,Message,Message,10808,root/html532/TEveGTriVecValuator.html,https://root.cern,https://root.cern/root/html532/TEveGTriVecValuator.html,10,['Message'],['Message']
Integrability," Bool_tTGCompositeFrame::IsEditable() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGCompositeFrame::Layout(); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual voidMoveTable(Int_t rows, Int_t columns); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual voidNextChunk(); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual TGTableCell*operator()(UInt_t row, UInt_t column); virtual voidTObject::Paint(Optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGTable.html:14927,Message,Message,14927,root/html532/TGTable.html,https://root.cern,https://root.cern/root/html532/TGTable.html,1,['Message'],['Message']
Integrability," Bool_tTGCompositeFrame::IsEditable() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGCompositeFrame::Layout(); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual voidTGTable::MoveTable(Int_t rows, Int_t columns); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual voidTGTable::NextChunk(); virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual TGTableCell*TGTable::operator()(UInt_t row, UInt_t column); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGSimpleTable.html:12060,Message,Message,12060,root/html532/TGSimpleTable.html,https://root.cern,https://root.cern/root/html532/TGSimpleTable.html,4,['Message'],['Message']
Integrability," Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; virtual Bool_tisValid() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); const RooArgSet&numIntCatVars() const; const RooArgSet&numIntRealVars() const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:16630,message,message,16630,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,2,['message'],['message']
Integrability," Bool_t Init () override;  Initialize WinNT system interface. ;  ; TClass * IsA () const override;  ; Bool_t IsAbsoluteFileName (const char *dir) override;  Return true if dir is an absolute pathname. ;  ; Bool_t IsPathLocal (const char *path) override;  Returns TRUE if the url in 'path' points to the local file system. ;  ; int Link (const char *from, const char *to) override;  Create a link from file1 to file2. ;  ; int Load (const char *module, const char *entry="""", Bool_t system=kFALSE) override;  Load a shared library. ;  ; int MakeDirectory (const char *name) override;  Make a WinNT file system directory. ;  ; int mkdir (const char *name, Bool_t recursive=kFALSE) override;  Make a file system directory. ;  ; void NotifyApplicationCreated () override;  Hook to tell TSystem that the TApplication object has been created. ;  ; TTime Now () override;  Get current time in milliseconds since 0:00 Jan 1 1995. ;  ; int OpenConnection (const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"") override;  Open a connection to a service on a server. ;  ; void * OpenDirectory (const char *name) override;  Open a directory. Returns 0 if directory does not exist. ;  ; FILE * OpenPipe (const char *shellcmd, const char *mode) override;  Open a pipe. ;  ; const char * PrependPathName (const char *dir, TString &name) override;  Concatenate a directory and a file name. ;  ; Bool_t ProcessEvents () override;  process pending events, i.e. DispatchOneEvent(kTRUE) ;  ; int RecvBuf (int sock, void *buffer, int length) override;  Receive a buffer headed by a length indicator. ;  ; int RecvRaw (int sock, void *buffer, int length, int flag) override;  Receive exactly length bytes into buffer. ;  ; Int_t RedirectOutput (const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr) override;  Redirect standard output (stdout, stderr) to the specified file. ;  ; TFileHandler * RemoveFileHandler (TFileHandler *fh) override;  Remove a file handler from the list of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:9588,protocol,protocol,9588,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['protocol'],['protocol']
Integrability," Bool_t LooseOptionCheckingEnabled () const;  ; void ResetSetFlag ();  resets the IsSet flag for all declare options to be called before options are read from stream ;  ; void WriteOptionsReferenceToFile ();  write complete options to output stream ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; PyObject * fClassifier;  ; PyObject * fLocalNS;  ; PyObject * fModule;  ; PyObject * fPyReturn;  ;  Protected Attributes inherited from TMVA::MethodBase; Types::EAnalysisType fAnalysisType;  ; UInt_t fBackgroundClass;  ; bool fExitFromTraining = false;  ; std::vector< TString > * fInputVars;  ; IPythonInteractive * fInteractive = nullptr;  temporary dataset used when evaluating on a different data (used by MethodCategory::GetMvaValues) ;  ; UInt_t fIPyCurrentIter = 0;  ; UInt_t fIPyMaxIter = 0;  ; std::vector< Float_t > * fMulticlassReturnVal;  ; Int_t fNbins;  ; Int_t fNbinsH;  ; Int_t fNbinsMVAoutput;  ; Ranking * fRanking;  ; std::vector< Float_t > * fRegressionReturnVal;  ; Results * fResults;  ; UInt_t fSignalClass;  ; DataSet * fTmpData = nullptr;  temporary event when testing on a different DataSet than the own one ;  ; const Event * fTmpEvent;  ;  Protected Attributes inherited from TMVA::Configurable; MsgLogger * fLogger;  ! message logger ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static PyObject * fGlobalNS = NULL;  ; static PyObject * fMain = NULL;  ; static PyObject * fModulePickle = NULL;  ; static PyObject * fPickleDumps = NULL;  ; static PyObject * fPickleLoads = NULL;  . Static Private Attributes; static PyObject * fEval = NULL;  ; static PyObject * fModuleBuiltin = NULL;  ; static PyObject * fOpen = NULL;  . Friends; class Factory;  . Additional Inherited Members;  Public Types inherited from TMVA::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PyMethodBase.html:27734,message,message,27734,doc/master/classTMVA_1_1PyMethodBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PyMethodBase.html,1,['message'],['message']
Integrability," Browse(TBrowser* b); Browse the content of this leaf. void FillBasket(TBuffer& b); -- Pack leaf elements in Basket output buffer. TLeaf* GetLeafCounter(Int_t& countval) const; -- Return a pointer to the counter of this leaf. If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, return countval = 1 and the pointer to; the leaf named nelem, otherwise return 0.; If leaf name has the form var[nelem], where nelem is a digit, then; return countval = nelem and a null pointer.; If leaf name has the form of a multi dimenantion array (eg var[nelem][nelem2]; where nelem and nelem2 are digits) then; return countval = product of all dimension size and a null pointer.; If leaf name has the form var[... (and do not match the previous 2; cases) return countval = -1 and null pointer;; Otherwise return countval=1 and a null pointer. Int_t GetLen() const; -- Return the number of effective elements of this leaf. Int_t ResetAddress(void* add, Bool_t destructor = kFALSE); -- Helper routine for TLeafX::SetAddress. The return value is non-zero if we owned the old; value buffer and must delete it now. The size; of the value buffer is recalculated and stored,; and a decision is made whether or not we own the; new value buffer. void SetLeafCount(TLeaf* leaf); -- Set the leaf count of this leaf. void Streamer(TBuffer& b); -- Stream a class object. Double_t GetValue(Int_t i = 0) const; { return 0.0; }. void PrintValue(Int_t i = 0) const; {}. void SetAddress(void* add = 0); {}. void Export(TClonesArray* , Int_t ); {}. TBranch * GetBranch() const; { return fBranch; }. TLeaf * GetLeafCount() const; { return fLeafCount; }. Int_t GetLenStatic() const; { return fLen; }. Int_t GetLenType() const; { return fLenType; }. Int_t GetMaximum() const; { return 0; }. Int_t GetMinimum() const; { return 0; }. Int_t GetNdata() const; { return fNdata; }. Int_t GetOffset() const; { return fOffset; }. void * GetValuePointer() const; { return 0; }. const char * GetTypeName(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TLeaf.html:8584,rout,routine,8584,root/html530/TLeaf.html,https://root.cern,https://root.cern/root/html530/TLeaf.html,1,['rout'],['routine']
Integrability," Browse(TBrowser* b); Calls TTree::Draw on the method if return type is not a class;; otherwise expands returned object's ""folder"". Int_t FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Askes all registered generators to fill their browsables into; the list. The browsables are generated for a given parent,; or (if 0), for a given branch. The branch is passed down to; leaves of TVirtualBranchBrowsable, too, as we need to access; the branch's TTree to be able to traw. TClass* GetCollectionContainedType(const TBranch* b, const TVirtualBranchBrowsable* parent, TClass*& contained); Check whether the branch (or the parent) contains a collection.; If it does, set ""contained"" to the contained type (if we can; retrieve it) and return the TClass for the collection. Set; ""contained"" to the branch's (or parent's) contained object's; class for non-collections, returning 0. Only one of ""branch"" or ""parent"" can ge given (depending on whether; we are creating browsable objects for a branch or for another; browsable object). TList* GetLeaves() const; Return list of leaves. If not set up yet we'll create them. void GetScope(TString& scope) const; Returns the full name for TTree::Draw to draw *this.; Recursively appends, starting at the top TBranch,; all method / object names with proper reference operators (->, .); depending on fTypeIsPointer. void RegisterDefaultGenerators(); Adds the default generators. The user can remove any of them as follows:; TMethodBrowsable::Unregister();; which will cause the browser not to show any methods. void RegisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator); Adds a generator to be called when browsing branches.; Called by the Register method, which should be implemented; for all derived classes (see e.g. TMethodBrowsable::Register()). void UnregisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator); Removes a generator from the list of gene",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualBranchBrowsable.html:10079,depend,depending,10079,root/html528/TVirtualBranchBrowsable.html,https://root.cern,https://root.cern/root/html528/TVirtualBranchBrowsable.html,10,['depend'],['depending']
Integrability," C++ stream. Multiple message streams can write to same c++ stream. The return value is the unique ID code of the defined stream. void deleteStream(Int_t id); Delete stream with given unique ID code. void setStreamStatus(Int_t id, Bool_t active); (De)Activate stream with given unique ID. Bool_t getStreamStatus(Int_t id) const; Get activation status of stream with given unique ID. RooMsgService& instance(); Return reference to singleton instance. void saveState(); Save current state of message service. void restoreState(); Restore last saved state of message service. Bool_t isActive(const RooAbsArg* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Bool_t isActive(const TObject* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Check if logging is active for given object/topic/RooFit::MsgLevel combination. Int_t activeStream(const RooAbsArg* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. Int_t activeStream(const TObject* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. ostream& log(const RooAbsArg* self, RooFit::MsgLevel level, RooFit::MsgTopic topic, Bool_t skipPrefix); Log error message associated with RooAbsArg object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. ostream& log(const TObject* self, RooFit::MsgLevel level, RooFit::MsgTopic topic, Bool_t skipPrefix); Log error message associated with TObject object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. void Print(Option_t* options = 0) const; Print configuration of message service. If ""v"" option is given also; inactive streams are listed. StreamConfig& getStream(Int_t id); { return _streams[id] ; }. Int_t n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMsgService.html:10662,message,message,10662,root/html526/RooMsgService.html,https://root.cern,https://root.cern/root/html526/RooMsgService.html,2,['message'],['message']
Integrability," CEF or Chromium) ; Definition at line 269 of file RWebWindow.hxx. ◆ SetRequireAuthKey(). void ROOT::RWebWindow::SetRequireAuthKey ; (; bool ; on). inline . Configure if authentication key in connection string is required. ; Definition at line 316 of file RWebWindow.hxx. ◆ SetStartDialogFunc(). void RWebWindow::SetStartDialogFunc ; (; std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> ; func). staticprivate . Configure func which has to be used for starting dialog. ; Definition at line 1953 of file RWebWindow.cxx. ◆ SetUseCurrentDir(). void ROOT::RWebWindow::SetUseCurrentDir ; (; bool ; on = true). inline . Configure if window can access local files via currentdir/ path of http server. ; Definition at line 324 of file RWebWindow.hxx. ◆ SetUserArgs(). void RWebWindow::SetUserArgs ; (; const std::string & ; args). Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON code injected into main HTML document into connectWebWindow({}) Must be set before RWebWindow::Show() method is called. ; Parameters. args- arbitrary JSON data which can be provided to client side . Definition at line 1310 of file RWebWindow.cxx. ◆ Show(). unsigned RWebWindow::Show ; (; const RWebDisplayArgs & ; args = """"). Show window in specified location. ; See alsoROOT::RWebWindowsManager::Show for more info ; Returns(future) connection id (or 0 when fails) ; Definition at line 191 of file RWebWindow.cxx. ◆ ShowWindow(). unsigned RWebWindow::ShowWindow ; (; std::shared_ptr< RWebWindow > ; window, . const RWebDisplayArgs & ; args = """" . ). static . Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially can be embed into other windows Soon RWebWindow::Show() method will be done protected. ; Definition at line 1915 of file RWebWindow.cxx. ◆ StartThread(). void RWebWindow::StartThread ; (; ). Start special thread which will be used by the window to handle all callbacks One ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:48424,inject,injected,48424,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['inject'],['injected']
Integrability," CEF or Chromium) ; Definition at line 272 of file RWebWindow.hxx. ◆ SetRequireAuthKey(). void ROOT::RWebWindow::SetRequireAuthKey ; (; bool ; on). inline . Configure if authentication key in connection string is required. ; Definition at line 319 of file RWebWindow.hxx. ◆ SetStartDialogFunc(). void RWebWindow::SetStartDialogFunc ; (; std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)> ; func). staticprivate . Configure func which has to be used for starting dialog. ; Definition at line 1995 of file RWebWindow.cxx. ◆ SetUseCurrentDir(). void ROOT::RWebWindow::SetUseCurrentDir ; (; bool ; on = true). inline . Configure if window can access local files via currentdir/ path of http server. ; Definition at line 327 of file RWebWindow.hxx. ◆ SetUserArgs(). void RWebWindow::SetUserArgs ; (; const std::string & ; args). Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON code injected into main HTML document into connectWebWindow({}) Must be set before RWebWindow::Show() method is called. ; Parameters. args- arbitrary JSON data which can be provided to client side . Definition at line 1352 of file RWebWindow.cxx. ◆ Show(). unsigned RWebWindow::Show ; (; const RWebDisplayArgs & ; args = """"). Show window in specified location. ; See alsoROOT::RWebWindowsManager::Show for more info ; Returns(future) connection id (or 0 when fails) ; Definition at line 191 of file RWebWindow.cxx. ◆ ShowWindow(). unsigned RWebWindow::ShowWindow ; (; std::shared_ptr< RWebWindow > ; window, . const RWebDisplayArgs & ; args = """" . ). static . Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially can be embed into other windows Soon RWebWindow::Show() method will be done protected. ; Definition at line 1957 of file RWebWindow.cxx. ◆ StartThread(). void RWebWindow::StartThread ; (; ). Start special thread which will be used by the window to handle all callbacks One ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:47308,inject,injected,47308,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['inject'],['injected']
Integrability," CINT function. CallFunc_t * CallFunc_Factory() const; Interface to CINT function. CallFunc_t * CallFunc_FactoryCopy(CallFunc_t* func) const; Interface to CINT function. MethodInfo_t * CallFunc_FactoryMethod(CallFunc_t* func) const; Interface to CINT function. void CallFunc_Init(CallFunc_t* func) const; Interface to CINT function. bool CallFunc_IsValid(CallFunc_t* func) const; Interface to CINT function. void CallFunc_ResetArg(CallFunc_t* func) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, Long_t param) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, Double_t param) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, Long64_t param) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, ULong64_t param) const; Interface to CINT function. void CallFunc_SetArgArray(CallFunc_t* func, Long_t* paramArr, Int_t nparam) const; Interface to CINT function. void CallFunc_SetArgs(CallFunc_t* func, const char* param) const; Interface to CINT function. void CallFunc_SetFunc(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* params, Long_t* Offset) const; Interface to CINT function. void CallFunc_SetFunc(CallFunc_t* func, MethodInfo_t* info) const; Interface to CINT function. void CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, Long_t* Offset) const; Interface to CINT function. Long_t ClassInfo_ClassProperty(ClassInfo_t* info) const; Interface to CINT function. void ClassInfo_Delete(ClassInfo_t* info) const; Interface to CINT function. void ClassInfo_Delete(ClassInfo_t* info, void* arena) const; Interface to CINT function. void ClassInfo_DeleteArray(ClassInfo_t* info, void* arena, bool dtorOnly) const; Interface to CINT function. void ClassInfo_Destruct(ClassInfo_t* info, void* arena) const; Interface to CINT function. ClassInfo_t * ClassInfo_Factory() const; Interface to CINT function. ClassInfo_t * ClassInfo_Factory(Cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCint.html:34613,Interface,Interface,34613,root/html532/TCint.html,https://root.cern,https://root.cern/root/html532/TCint.html,1,['Interface'],['Interface']
Integrability," CINT function. const char * BaseClassInfo_Name(BaseClassInfo_t* bcinfo) const; Interface to CINT function. const char * BaseClassInfo_TmpltName(BaseClassInfo_t* bcinfo) const; Interface to CINT function. int DataMemberInfo_ArrayDim(DataMemberInfo_t* dminfo) const; Interface to CINT function. void DataMemberInfo_Delete(DataMemberInfo_t* dminfo) const; Interface to CINT function. DataMemberInfo_t * DataMemberInfo_Factory(ClassInfo_t* clinfo = 0) const; Interface to CINT function. DataMemberInfo_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t* dminfo) const; Interface to CINT function. bool DataMemberInfo_IsValid(DataMemberInfo_t* dminfo) const; Interface to CINT function. int DataMemberInfo_MaxIndex(DataMemberInfo_t* dminfo, Int_t dim) const; Interface to CINT function. int DataMemberInfo_Next(DataMemberInfo_t* dminfo) const; Interface to CINT function. Long_t DataMemberInfo_Offset(DataMemberInfo_t* dminfo) const; Interface to CINT function. Long_t DataMemberInfo_Property(DataMemberInfo_t* dminfo) const; Interface to CINT function. Long_t DataMemberInfo_TypeProperty(DataMemberInfo_t* dminfo) const; Interface to CINT function. int DataMemberInfo_TypeSize(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_TypeName(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_TypeTrueName(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_Name(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_Title(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* dminfo) const; Interface to CINT function. void MethodInfo_Delete(MethodInfo_t* minfo) const; Interface to CINT function. void MethodInfo_CreateSignature(MethodInfo_t* minfo, TString& signature) const; Interface to CINT function. MethodInfo_t * MethodInfo_Factory() const; Interface to CINT function. MethodInfo_t * M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCint.html:39632,Interface,Interface,39632,root/html532/TCint.html,https://root.cern,https://root.cern/root/html532/TCint.html,1,['Interface'],['Interface']
Integrability," CINT function. int DataMemberInfo_Next(DataMemberInfo_t* dminfo) const; Interface to CINT function. Long_t DataMemberInfo_Offset(DataMemberInfo_t* dminfo) const; Interface to CINT function. Long_t DataMemberInfo_Property(DataMemberInfo_t* dminfo) const; Interface to CINT function. Long_t DataMemberInfo_TypeProperty(DataMemberInfo_t* dminfo) const; Interface to CINT function. int DataMemberInfo_TypeSize(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_TypeName(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_TypeTrueName(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_Name(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_Title(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* dminfo) const; Interface to CINT function. void MethodInfo_Delete(MethodInfo_t* minfo) const; Interface to CINT function. void MethodInfo_CreateSignature(MethodInfo_t* minfo, TString& signature) const; Interface to CINT function. MethodInfo_t * MethodInfo_Factory() const; Interface to CINT function. MethodInfo_t * MethodInfo_Factory(ClassInfo_t* ) const; Interface to CINT function. MethodInfo_t * MethodInfo_FactoryCopy(MethodInfo_t* minfo) const; Interface to CINT function. void * MethodInfo_InterfaceMethod(MethodInfo_t* minfo) const; Interface to CINT function. Bool_t MethodInfo_IsValid(MethodInfo_t* minfo) const; Interface to CINT function. int MethodInfo_NArg(MethodInfo_t* minfo) const; Interface to CINT function. int MethodInfo_NDefaultArg(MethodInfo_t* minfo) const; Interface to CINT function. int MethodInfo_Next(MethodInfo_t* minfo) const; Interface to CINT function. Long_t MethodInfo_Property(MethodInfo_t* minfo) const; Interface to CINT function. void * MethodInfo_Type(MethodInfo_t* minfo) const; Interface to CINT function. std::string MethodInfo_TypeNormali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:41253,Interface,Interface,41253,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,1,['Interface'],['Interface']
Integrability," CINT function. int DataMemberInfo_Next(DataMemberInfo_t* dminfo) const; Interface to CINT function. Long_t DataMemberInfo_Offset(DataMemberInfo_t* dminfo) const; Interface to CINT function. Long_t DataMemberInfo_Property(DataMemberInfo_t* dminfo) const; Interface to CINT function. Long_t DataMemberInfo_TypeProperty(DataMemberInfo_t* dminfo) const; Interface to CINT function. int DataMemberInfo_TypeSize(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_TypeName(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_TypeTrueName(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_Name(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_Title(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* dminfo) const; Interface to CINT function. void MethodInfo_Delete(MethodInfo_t* minfo) const; Interface to CINT function. void MethodInfo_CreateSignature(MethodInfo_t* minfo, TString& signature) const; Interface to CINT function. MethodInfo_t * MethodInfo_Factory() const; Interface to CINT function. MethodInfo_t * MethodInfo_FactoryCopy(MethodInfo_t* minfo) const; Interface to CINT function. void * MethodInfo_InterfaceMethod(MethodInfo_t* minfo) const; Interface to CINT function. bool MethodInfo_IsValid(MethodInfo_t* minfo) const; Interface to CINT function. int MethodInfo_NArg(MethodInfo_t* minfo) const; Interface to CINT function. int MethodInfo_NDefaultArg(MethodInfo_t* minfo) const; Interface to CINT function. int MethodInfo_Next(MethodInfo_t* minfo) const; Interface to CINT function. Long_t MethodInfo_Property(MethodInfo_t* minfo) const; Interface to CINT function. void * MethodInfo_Type(MethodInfo_t* minfo) const; Interface to CINT function. const char * MethodInfo_GetMangledName(MethodInfo_t* minfo) const; Interface to CINT function. const char * MethodInfo_G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCint.html:40390,Interface,Interface,40390,root/html532/TCint.html,https://root.cern,https://root.cern/root/html532/TCint.html,1,['Interface'],['Interface']
Integrability," Calculate and return the current value. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. Bool_t checkObservables(const RooArgSet* nset) const; Check if PDF is valid for given normalization set.; Coeffient and PDF must be non-overlapping, but pdf-coefficient; pairs may overlap each other. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Determine which part (if any) of given integral can be performed analytically.; If any analytical integration is possible, return integration scenario code. RooAddPdf queries each component PDF for its analytical integration capability of the requested; set ('allVars'). It finds the largest common set of variables that can be integrated; by all components. If such a set exists, it reconfirms that each component is capable of; analytically integrating the common set, and combines the components individual integration; codes into a single integration code valid for RooAddPdf. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events, which is either the sum of all coefficients; or the sum of the components extended terms, multiplied with the fraction that; is in the current range w.r.t the reference range. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddPdf.html:46265,integrat,integrating,46265,root/html528/RooAddPdf.html,https://root.cern,https://root.cern/root/html528/RooAddPdf.html,27,['integrat'],"['integrating', 'integration']"
Integrability," Calculate and return the current value. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. Bool_t checkObservables(const RooArgSet* nset) const; Check if PDF is valid for given normalization set.; Coeffient and PDF must be non-overlapping, but pdf-coefficient; pairs may overlap each other. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Determine which part (if any) of given integral can be performed analytically.; If any analytical integration is possible, return integration scenario code. RooAddPdf queries each component PDF for its analytical integration capability of the requested; set ('allVars'). It finds the largest common set of variables that can be integrated; by all components. If such a set exists, it reconfirms that each component is capable of; analytically integrating the common set, and combines the components individual integration; codes into a single integration code valid for RooAddPdf. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Double_t expectedEvents(const RooArgSet* nset); Return the number of expected events, which is either the sum of all coefficients; or the sum of the components extended terms, multiplied with the fraction that; is in the current range w.r.t the reference range. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddPdf.html:45508,integrat,integrating,45508,root/html526/RooAddPdf.html,https://root.cern,https://root.cern/root/html526/RooAddPdf.html,3,['integrat'],"['integrating', 'integration']"
Integrability," CallFunc_SetArg(CallFunc_t* func, Long_t param) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, Double_t param) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, Long64_t param) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, ULong64_t param) const; Interface to CINT function. void CallFunc_SetArgArray(CallFunc_t* func, Long_t* paramArr, Int_t nparam) const; Interface to CINT function. void CallFunc_SetArgs(CallFunc_t* func, const char* param) const; Interface to CINT function. void CallFunc_SetFunc(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* params, Long_t* Offset) const; Interface to CINT function. void CallFunc_SetFunc(CallFunc_t* func, MethodInfo_t* info) const; Interface to CINT function. void CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, Long_t* Offset) const; Interface to CINT function. Long_t ClassInfo_ClassProperty(ClassInfo_t* info) const; Interface to CINT function. void ClassInfo_Delete(ClassInfo_t* info) const; Interface to CINT function. void ClassInfo_Delete(ClassInfo_t* info, void* arena) const; Interface to CINT function. void ClassInfo_DeleteArray(ClassInfo_t* info, void* arena, bool dtorOnly) const; Interface to CINT function. void ClassInfo_Destruct(ClassInfo_t* info, void* arena) const; Interface to CINT function. ClassInfo_t * ClassInfo_Factory() const; Interface to CINT function. ClassInfo_t * ClassInfo_Factory(ClassInfo_t* cl) const; Interface to CINT function. ClassInfo_t * ClassInfo_Factory(const char* name) const; Interface to CINT function. ClassInfo_t * ClassInfo_Factory(G__value* ) const; Interface to CINT function. int ClassInfo_GetMethodNArg(ClassInfo_t* info, const char* method, const char* proto) const; Interface to CINT function. Bool_t ClassInfo_HasDefaultConstructor(ClassInfo_t* info) const; Interface to CINT function. Bool_t ClassInfo_HasMethod(ClassInfo_t* info, const char* nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:35944,Interface,Interface,35944,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,1,['Interface'],['Interface']
Integrability," CallFunc_SetArg(CallFunc_t* func, Long_t param) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, Double_t param) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, Long64_t param) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, ULong64_t param) const; Interface to CINT function. void CallFunc_SetArgArray(CallFunc_t* func, Long_t* paramArr, Int_t nparam) const; Interface to CINT function. void CallFunc_SetArgs(CallFunc_t* func, const char* param) const; Interface to CINT function. void CallFunc_SetFunc(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* params, Long_t* Offset) const; Interface to CINT function. void CallFunc_SetFunc(CallFunc_t* func, MethodInfo_t* info) const; Interface to CINT function. void CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, Long_t* Offset) const; Interface to CINT function. Long_t ClassInfo_ClassProperty(ClassInfo_t* info) const; Interface to CINT function. void ClassInfo_Delete(ClassInfo_t* info) const; Interface to CINT function. void ClassInfo_Delete(ClassInfo_t* info, void* arena) const; Interface to CINT function. void ClassInfo_DeleteArray(ClassInfo_t* info, void* arena, bool dtorOnly) const; Interface to CINT function. void ClassInfo_Destruct(ClassInfo_t* info, void* arena) const; Interface to CINT function. ClassInfo_t * ClassInfo_Factory() const; Interface to CINT function. ClassInfo_t * ClassInfo_Factory(ClassInfo_t* cl) const; Interface to CINT function. ClassInfo_t * ClassInfo_Factory(const char* name) const; Interface to CINT function. ClassInfo_t * ClassInfo_Factory(G__value* ) const; Interface to CINT function. int ClassInfo_GetMethodNArg(ClassInfo_t* info, const char* method, const char* proto) const; Interface to CINT function. bool ClassInfo_HasDefaultConstructor(ClassInfo_t* info) const; Interface to CINT function. bool ClassInfo_HasMethod(ClassInfo_t* info, const char* name) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCint.html:35097,Interface,Interface,35097,root/html532/TCint.html,https://root.cern,https://root.cern/root/html532/TCint.html,1,['Interface'],['Interface']
Integrability," Canvas. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQRootCanvas(QWidget* parent = 0, const char* name = 0, TCanvas* c = 0); set defaults. TQRootCanvas(QWidget* parent, QWidget* tabWin, const char* name = 0, TCanvas* c = 0); set defaults. void mouseMoveEvent(QMouseEvent* e); Handle mouse move event. void mousePressEvent(QMouseEvent* e); Handle mouse button press event. void mouseReleaseEvent(QMouseEvent* e); Handle mouse button release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQRootCanvas.html:4870,wrap,wrapper,4870,root/html528/TQRootCanvas.html,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html,5,['wrap'],['wrapper']
Integrability," Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtualPad * GetSelectedPad(); just a wrapper. Bool_t GetShowEventStatus(); just a wrapper. Bool_t GetAutoExec(); just a wrapper. Size_t GetXsizeUser(); just a wrapper. Size_t GetYsizeUser(); just a wrapper. Size_t GetXsizeReal(); just a wrapper. Size_t GetYsizeReal(); just a wrapper. Int_t GetCanvasID(); just a wrapper. Int_t GetWindowTopX(); just a wrapper. Int_t GetWindowTopY(); just a wrapper. UInt_t GetWindowWidth(); just a wrapper. UInt_t GetWindowHeight(); just a wrapper. UInt_t GetWw(); just a wrapper. UInt_t GetWh(); just a wrapper. void GetCanvasPar(Int_t& wtopx, Int_t& wtopy, UInt_t& ww, UInt_t& wh); just a wrapper. void HandleInput(EEventType button, Int_t x, Int_t y); just a wr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQRootCanvas.html:5516,wrap,wrapper,5516,root/html528/TQRootCanvas.html,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html,5,['wrap'],['wrapper']
Integrability, Carlo study manager add-on module; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsProxy Abstract proxy interface; RooAbsReal Abstract real-valued variable; RooAbsRealLValue Abstract modifiable real-valued object; RooAbsRootFinder Abstract interface for 1-dim real-valued function root finders; RooAbsSelfCachedPdf Abstract base class for self-caching p.d.f.s; RooAbsSelfCachedReal Abstract base class for self-caching functions; RooAbsString Abstract string-valued variable; RooAbsTestStatistic Abstract base class for real-valued test statistics; RooAcceptReject Context for generating a dataset from a PDF; RooAdaptiveGaussKronrodIntegrator1D 1-dimensional adaptive Gauss-Kronrod numerical integration engine; RooAdaptiveIntegratorND N-dimensional adaptive integration (interface to MathCore integrator); RooAddGenContext Specialized context for generating a dataset from a RooAddPdf; RooAddModel Resolution model representing a sum of resolution models; RooAddPdf PDF representing a sum of PDFs; RooAddition Sum of RooAbsReal objects; RooArgList Ordered list of RooAbsArg objects; RooArgProxy Abstract proxy for RooAbsArg objects; RooArgSet Set of RooAbsArg objects; RooArgusBG Argus background shape PDF; RooBCPEffDecay B Mixing decay PDF; RooBCPGenDecay B decay time distribution with CP violation; RooBDecay P.d.f of general description of B decay time distribution; RooBMixDecay B Mixing decay PDF; RooBernstein Bernstein polynomial PDF; RooBifurGauss Bifurcated Gaussian PDF; RooBinning Generic binning specification; RooBinningCategory RealVar-to-Category function defined by bin boundaries on input var; RooBlindTools Root implementation of BlindTools; RooBreitWigner Breit Wigner PDF; RooBrentRootFinder Abstract interface for 1-dim real-valued function root finders; RooBukinPdf Variation of Novosibirsk PDF; RooCBShape Cryst,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:25004,integrat,integration,25004,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,4,"['integrat', 'interface']","['integration', 'integrator', 'interface']"
Integrability," Change name of RooFitResult object. void SetNameTitle(const char* name, const char* title); Change name and title of RooFitResult object. void printName(ostream& os) const; Print name of fit result. void printTitle(ostream& os) const; Print title of fit result. void printClassName(ostream& os) const; Print class name of fit result. void printArgs(ostream& os) const; Print arguments of fit result, i.e. the parameters of the fit. void printValue(ostream& os) const; Print the value of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. Int_t defaultPrintContents(Option_t* opt) const; Configure default contents to be printed. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Configure mapping of Print() arguments to RooPrintable print styles. void Streamer(TBuffer& b); Stream an object of class RooFitResult. TObject* Clone(const char* newname = 0) const. TObject* clone() const; { return new RooFitResult(*this); }. void Print(Option_t* options = 0) const; Printing interface. Int_t status() const; Accessors. Int_t covQual() const; Return MINUIT quality code of covariance matrix. Int_t numInvalidNLL() const; Return number of NLL evaluations with problems. Double_t edm() const; Return estimated distance to minimum. Double_t minNll() const; Return minimized -log(L) value. const RooArgList& constPars() const; Return list of constant parameters. const RooArgList& floatParsInit() const; Return list of floating parameters before fit. const RooArgList& floatParsFinal() const; Return list of floarting parameters after fit. Double_t correlation(const RooAbsArg& par1, const RooAbsArg& par2) const; Return correlation between par1 and par2. return correlation(par1.GetName(),par2.GetName()). Double_t globalCorr(const RooAbsArg& par); Global correlation accessors. { return globalCorr(par.GetName()) ; }. RooPlot * plotOn(RooPlot* frame, const RooAbsArg& par1, const RooAbsArg& par2, const char* options = ""ME"") const; Add objects to a 2D plot. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooFitResult.html:16114,interface,interface,16114,root/html528/RooFitResult.html,https://root.cern,https://root.cern/root/html528/RooFitResult.html,2,['interface'],['interface']
Integrability," Change name of RooFitResult object. void SetNameTitle(const char* name, const char* title); Change name and title of RooFitResult object. void printName(ostream& os) const; Print name of fit result. void printTitle(ostream& os) const; Print title of fit result. void printClassName(ostream& os) const; Print class name of fit result. void printArgs(ostream& os) const; Print arguments of fit result, i.e. the parameters of the fit. void printValue(ostream& os) const; Print the value of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. Int_t defaultPrintContents(Option_t* opt) const; Configure default contents to be printed. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Configure mapping of Print() arguments to RooPrintable print styles. void Streamer(TBuffer& b); Stream an object of class RooFitResult. TObject* Clone(const char* newname = 0) const. TObject* clone() const; { return new RooFitResult(*this); }. void Print(Option_t* options = 0) const; Printing interface. Int_t status() const; Accessors. Int_t covQual() const; Return MINUIT quality code of covariance matrix. Int_t numInvalidNLL() const; Return number of NLL evaluations with problems. Double_t edm() const; Return estimated distance to minimum. Double_t minNll() const; Return minimized -log(L) value. const RooArgList& constPars() const; Return list of constant parameters. const RooArgList& floatParsInit() const; Return list of floating parameters before fit. const RooArgList& floatParsFinal() const; Return list of floarting parameters after fit. Double_t correlation(const RooAbsArg& par1, const RooAbsArg& par2); Return correlation between par1 and par2. return correlation(par1.GetName(),par2.GetName()). Double_t globalCorr(const RooAbsArg& par); Global correlation accessors. { return globalCorr(par.GetName()) ; }. RooPlot * plotOn(RooPlot *frame, const RooAbsArg &par1, const RooAbsArg &par2,			 const char *options= ""ME""); Add objects to a 2D plot. void setMi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFitResult.html:16078,interface,interface,16078,root/html526/RooFitResult.html,https://root.cern,https://root.cern/root/html526/RooFitResult.html,1,['interface'],['interface']
Integrability," Change name of RooFitResult object. void SetNameTitle(const char* name, const char* title); Change name and title of RooFitResult object. void printName(ostream& os) const; Print name of fit result. void printTitle(ostream& os) const; Print title of fit result. void printClassName(ostream& os) const; Print class name of fit result. void printArgs(ostream& os) const; Print arguments of fit result, i.e. the parameters of the fit. void printValue(ostream& os) const; Print the value of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. Int_t defaultPrintContents(Option_t* opt) const; Configure default contents to be printed. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Configure mapping of Print() arguments to RooPrintable print styles. void Streamer(TBuffer& b); Stream an object of class RooFitResult. TObject* Clone(const char* newname = 0) const. TObject* clone() const; { return new RooFitResult(*this); }. void Print(Option_t* options = 0) const; Printing interface. Int_t status() const; Accessors. UInt_t numStatusHistory() const; { return _statusHistory.size() ; }. Int_t covQual() const; Return MINUIT quality code of covariance matrix. Int_t numInvalidNLL() const; Return number of NLL evaluations with problems. Double_t edm() const; Return estimated distance to minimum. Double_t minNll() const; Return minimized -log(L) value. const RooArgList& constPars() const; Return list of constant parameters. const RooArgList& floatParsInit() const; Return list of floating parameters before fit. const RooArgList& floatParsFinal() const; Return list of floarting parameters after fit. Double_t correlation(const RooAbsArg& par1, const RooAbsArg& par2) const; Return correlation between par1 and par2. return correlation(par1.GetName(),par2.GetName()). Double_t globalCorr(const RooAbsArg& par); Global correlation accessors. { return globalCorr(par.GetName()) ; }. RooPlot * plotOn(RooPlot* frame, const RooAbsArg& par1, const RooAbsArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFitResult.html:16838,interface,interface,16838,root/html532/RooFitResult.html,https://root.cern,https://root.cern/root/html532/RooFitResult.html,2,['interface'],['interface']
Integrability," Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorMultiDim.html:3321,integrat,integration,3321,root/html528/ROOT__Math__IntegratorMultiDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorMultiDim.html,30,"['integrat', 'interface']","['integration', 'interface']"
Integrability," Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorEntries(TTree* tree = 0, const char* selection = 0); Default, constructor. TSelectorEntries(const char* selection); Constructor. ~TSelectorEntries(); Destructor. void Begin(TTree* tree); The Begin() function is called at the start of the query.; When running with PROOF Begin() is only called on the client.; The tree argument is deprecated (on PROOF 0 is passed). void SlaveBegin(TTree* tree); The SlaveBegin() function is called after the Begin() function.; When running with PROOF SlaveBegin() is called on each slave server.; The tree argument is deprecated (on PROOF 0 is passed). Int_t GetEntry(Long64_t entry, Int_t getall = 0); read entry. void Init(TTree* tree); The Init() function is called when the selector needs to initialize; a new tree or chain. Typically here the branch addresses and branch; pointers of the tree will be set.; It is normaly not necessary to make changes to the generated; code, but the routine can be extended by the user if needed.; Init() will be called many times when running on PROOF; (once per file to be processed). Bool_t Notify(); This function is called at the first entry of a new tree in a chain. Bool_t Process(Long64_t entry); The Process() function is called for each entry in the tree (or possibly; keyed object in the case of PROOF) to be processed. The entry argument; specifies which entry in the currently loaded tree is to be processed.; It can be passed to either TSelectorEntries::GetEntry() or TBranch::GetEntry(); to read either all or the required parts of the data. When processing; keyed objects with PROOF, the object is already loaded and is available; via the fObject pointer. This function should contain the ""body"" of the analysis. It can contain; simple or elaborate selection criteria, run algorithms on the data; of the event and typically fill histograms. The processing can be stopped by calling Abort(). Use fStatus to set the retu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TSelectorEntries.html:8526,rout,routine,8526,root/html604/TSelectorEntries.html,https://root.cern,https://root.cern/root/html604/TSelectorEntries.html,2,['rout'],['routine']
Integrability," Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ ESecurity. enum TAuthenticate::ESecurity. EnumeratorkClear ; kUnsupported ; kKrb5 ; kGlobus ; kSSH ; kRfio . Definition at line 60 of file TAuthenticate.h. Constructor & Destructor Documentation. ◆ TAuthenticate(). TAuthenticate::TAuthenticate ; (; TSocket * ; sock, . const char * ; remote, . const char * ; proto, . const char * ; user = """" . ). Create authentication object. ; Definition at line 164 of file TAuthenticate.cxx. ◆ ~TAuthenticate(). virtual TAuthenticate::~TAuthenticate ; (; ). inlinevirtual . Definition at line 131 of file TAuthenticate.h. Member Function Documentation. ◆ Authenticate(). Bool_t TAuthenticate::Authenticate ; (; ). Authenticate to remote rootd or proofd server. ; Return kTRUE if authentication succeeded. ; Definition at line 369 of file TAuthenticate.cxx. ◆ AuthError(). void TAuthenticate::AuthError ; (; const char * ; where, . Int_t ; error . ). static . Print error string depending on error code. ; Definition at line 1261 of file TAuthenticate.cxx. ◆ AuthExists(). Int_t TAuthenticate::AuthExists ; (; TString ; username, . Int_t ; method, . const char * ; options, . Int_t * ; message, . Int_t * ; rflag, . CheckSecCtx_t ; checksecctx . ). Check if we have a valid established sec context in memory Retrieves relevant info and negotiates with server. ; options = ""Opt,strlen(username),username.Data()"" message = kROOTD_USER, ... ; Definition at line 2276 of file TAuthenticate.cxx. ◆ CatchTimeOut(). void TAuthenticate::CatchTimeOut ; (; ). Called in connection with a timer timeout. ; Definition at line 353 of file TAuthenticate.cxx. ◆ CheckHost(). Bool_t TAuthenticate::CheckHost ; (; const char * ; Host, . const char * ; host . ). staticprivate . Check if 'host' matches 'href': this means either equal or ""containing"" it, even with wild cards * in the first field (in the case 'href' is a name, ie not IP address) Returns kTRUE if the two matches. ; Definition at li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:21664,depend,depending,21664,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['depend'],['depending']
Integrability," Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t siz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLIntegrator.html:1041,integrat,integration,1041,root/html526/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLIntegrator.html,1,['integrat'],['integration']
Integrability," Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GSLIntegrator.html:1041,integrat,integration,1041,root/html528/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GSLIntegrator.html,1,['integrat'],['integration']
Integrability," Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEvePathMarkT<double>. class TEvePathMarkT<double>. TEvePathMark. This class is also known as (typedefs to this class)TEvePathMarkD, TEvePathMarkT<Double_t>. Function Members (Methods); public:. TEvePathMarkT<double>(TEvePathMarkT<double>::EType_e type = kReference); TEvePathMarkT<double>(const TEvePathMarkT<double>&); TEvePathMarkT<double>(TEvePathMarkT<double>::EType_e type, const TEveVectorT<double>& v, double time = 0); TEvePathMarkT<double>(TEvePathMarkT<double>::EType_e type, const TEveVectorT<double>& v, const TEveVectorT<double>& p, double time = 0); TEvePathMarkT<double>(TEvePathMarkT<double>::EType_e type, const TEveVectorT<double>& v, const TEveVectorT<double>& p, const TEveVectorT<double>& e, double time = 0); ~TEvePathMarkT<double>(); static TClass*Class(); TClass*IsA() const; TEvePathMarkT<double>&operator=(const TEvePathMarkT<double>&); voidShowMembers(TMemberInspector&); voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const char*TypeName(). Data Members; public:. enum EType_e { kReference; kDaughter; kDecay; kCluster2D; kLineSegment; };. public:. TEveVectorT<double>fEExtra, meaning depends on fType.; TEveVectorT<double>fPMomentum.; doublefTimeTime.; TEvePathMarkT<double>::EType_efTypeMark-type.; TEveVectorT<double>fVVertex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; template<typename TT> const char* TEvePathMarkT<TT> TypeName(); Return the name of path-mark type. » Author: Matevz Tadel 2010 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEvePathMarkT_double_.html:1408,depend,depends,1408,root/html534/TEvePathMarkT_double_.html,https://root.cern,https://root.cern/root/html534/TEvePathMarkT_double_.html,2,['depend'],['depends']
Integrability," ClearAll( void ); delete and clear all class members. void Train( void ); FDA training. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; display fit parameters; check maximum length of variable name. Double_t EstimatorFunction(vector<Double_t>& ); compute estimator for given parameter set (to be minimised); const Double_t sumOfWeights[] = { fSumOfWeightsSig, fSumOfWeightsBkg, fSumOfWeights };. Double_t InterpretFormula(const TMVA::Event* , vector<double,allocator<double> >::iterator begin, vector<double,allocator<double> >::iterator end); formula interpretation. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). const std::vector<Float_t>& GetMulticlassValues(). void CalculateMulticlassValues(const TMVA::Event*& evt, vector<Double_t>& parameters, vector<Float_t>& values); calculate the values for multiclass. void ReadWeightsFromStream(istream& i); read back the training results from a file (stream). void AddWeightsXMLTo(void* parent) const; create XML description for LD classification and regression; (for arbitrary number of output classes/targets). void ReadWeightsFromXML(void* wghtnode); read coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write FDA-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". const Ranking* CreateRanking(); ranking of input variables. { return 0; }. void CheckSetup(); no check of options at this place. {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005-2010: *; » Last changed: root/tmva $Id: MethodFDA.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodFDA.html:19755,message,message,19755,root/html528/TMVA__MethodFDA.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodFDA.html,1,['message'],['message']
Integrability," Collection of overlay elements to draw/select together.; TGLOvlSelectRecord Standard GL overlay-selection record.; TGLPShapeObj This object wraps TGLPhysicalShape (not a TObject); TGLPShapeObjEditor GUI for editing attributes of a physical-shape.; TGLPShapeRef Reference to a TGLPhysicalShape object.; TGLPadPainter ; TGLPaintDevice Base class for GL widgets and GL off-screen rendering; TGLParametricEquation Equation of parametric surface.; TGLParametricEquationGL GL renderer for TGLParametricEquation; TGLParametricPlot Parametric plot's painter.; TGLPerspectiveCamera Camera for perspective view.; TGLPhysicalShape a physical (placed, global frame) drawable object; TGLPlane GL plane helper/wrapper class; TGLPlot3D Short description.; TGLPlotBox Back box for plot.; TGLPlotCamera Camera for plot-painters.; TGLPlotCoordinates Auxilary class, holds plot dimensions.; TGLPlotPainter Base for gl plots; TGLPolyLine a polyline logical shape; TGLPolyMarker a polymarker logical shape; TGLQuadric GL quadric object; TGLRect GL rect helper/wrapper class; TGLRnrCtx Collection of objects and data passes along all rendering calls.; TGLRotateManip GL rotation manipulator widget; TGLSAFrame GUI frame for standalone viewer; TGLSAViewer Standalone GL viewer.; TGLScaleManip GL scaling manipulator widget; TGLScene Standard ROOT OpenGL scene with logial/physical shapes.; TGLScene::TSceneInfo ; TGLSceneBase Base-class for OpenGL scenes.; TGLSceneInfo Data about a scene within a viewer context.; TGLScenePad GL-scene filled via TPad-TVirtualViewer interface.; TGLSelectBuffer OpenGL select buffer with depth sorting.; TGLSelectRecord Standard GL selection record.; TGLSelectRecordBase Base class for GL selection records.; TGLSelectionBuffer Holds color buffer content for selection; TGLSphere a spherical logical shape; TGLStopwatch a GL stopwatch utility class; TGLSurfacePainter Surface painter.; TGLTF3Painter GL TF3 painter.; TGLTH3Composition Composition of TH3 objects.; TGLTH3CompositionPainter ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:75541,wrap,wrapper,75541,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,10,['wrap'],['wrapper']
Integrability," Composite GUI frame for parallel display of a TGListTree and TEveGedEditor.; TEveGTriVecValuator Composite GUI element for setting three numerical values (label, three number-entries).; TEveGValuator Composite GUI element for single value selection (supports label, number-entry and slider).; TEveGValuatorBase Base class for composite GUI elements for setting of numeric values.; TEveGedEditor Specialization of TGedEditor for proper update propagation to TEveManager.; TEveGedNameFrame Top name-frame used in EVE.; TEveGedNameTextButton Button for GED name-frame.; TEveGeoManagerHolder Exception-safe wrapper for temporary setting of gGeoManager variable.; TEveGeoNode Wrapper for TGeoNode that allows it to be shown in GUI and controlled as a TEveElement.; TEveGeoNodeEditor Editor for TEveGeoNode class.; TEveGeoPolyShape A shape with arbitrary tesselation for visualization of CSG shapes.; TEveGeoShape Wrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for NLT projections).; TEveGeoShapeExtract Globally positioned TGeoShape with rendering attributes and an optional list of daughter shape-extracts.; TEveGeoShapeProjected ; TEveGeoTopNode Top-level TEveGeoNode with a pointer to TGeoManager and controls for steering of TGeoPainter.; TEveGeoTopNodeEditor Editor for TEveGeoTopNode class.; TEveGridStepper Provide discrete position coordinates for placement of objects on regular grids.; TEveGridStepperEditor Editor for TEveGridStepper class.; TEveGridStepperSubEditor Sub-editor for TEveGridStepper class.; TEveHit Monte Carlo hit (also used in VSD).; TEveJetCone Short description.; TEveJetConeEditor GUI editor for TEveJetCone.; TEveJetConeGL GL renderer class for TEveJetCone.; TEveJetConeProjected Projection of TEveJetCone.; TEveJetConeProjectedGL GL renderer class for TEveJetCone.; TEveLegoEventHandler A GL event handler class. Swiches perspective or orthog",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:64840,Wrap,Wrapper,64840,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,3,['Wrap'],['Wrapper']
Integrability," ConfInterval interface. More...;  ; class  SimpleLikelihoodRatioTestStat;  TestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood. More...;  ; class  SPlot;  A class to calculate ""sWeights"" used to create an ""sPlot"". More...;  ; class  TestStatistic;  TestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class. More...;  ; class  TestStatSampler;  TestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions. More...;  ; class  ToyMCImportanceSampler;  ToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling. More...;  ; class  ToyMCPayload;  ; class  ToyMCSampler;  ToyMCSampler is an implementation of the TestStatSampler interface. More...;  ; class  ToyMCStudy;  ToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling. More...;  ; class  UniformProposal;  UniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm. More...;  ; class  UpperLimitMCSModule;  This class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated. More...;  . Enumerations; enum  toysStrategies { EQUALTOYSPERDENSITY; , EXPONENTIALTOYDISTRIBUTION; };  . Functions; double AsimovSignificance (double s, double b, double sigma_b=0.0);  Compute the Asimov Median significance for a Poisson process with s = expected number of signal events, b = expected number of background events and optionally sigma_b = expected uncertainty of background events. ;  ; BranchStore * CreateBranchStore (const RooDataSet &data);  ; void FactorizePdf (const RooArgSet &observables, RooAbsPdf &pdf, RooArgList &obsTerms, RooArgList &constraints);  ; void FactorizePdf (RooStats::ModelConfig &model, RooAbsPdf &pdf, RooArgList &obsTerms, RooArgList &constraints);  ; void FillTree (TTree &myTree, const RooDataSet &data);  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooStats.html:8583,interface,interface,8583,doc/master/namespaceRooStats.html,https://root.cern,https://root.cern/doc/master/namespaceRooStats.html,1,['interface'],['interface']
Integrability," Copy(TObject& axis) const; Copy axis structure to another axis. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to an axis. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when an axis is clicked with the locator. The axis range is set between the position where the mouse is pressed; and the position where it is released.; If the mouse position is outside the current axis range when it is released; the axis is unzoomed with the corresponding proportions.; Note that the mouse does not need to be in the pad or even canvas; when it is released. Int_t FindBin(Double_t x); Find bin number corresponding to abscissa x. If x is underflow or overflow, attempt to rebin histogram; if the TH1::kCanRebin bit is set otherwise return 0 or fNbins+1. Int_t FindBin(const char* label); Find bin number with label.; If the List of labels does not exist create it; If label is not in the list of labels do the following depending on the; bit TH1::kCanRebin of the parent histogram.; - if the bit is set add the new label and if the number of labels exceeds; the number of bins, double the number of bins via TH1::LabelsInflate; - if the bit is not set return 0 (underflow bin). -1 is returned only when the Axis has no parent histogram. Int_t FindFixBin(Double_t x) const; Find bin number corresponding to abscissa x. Identical to TAxis::FindBin except that if x is an underflow/overflow; no attempt is made to rebin the histogram if TH1::kCanRebin bit is set. const char * GetBinLabel(Int_t bin) const; Return label for bin. Int_t GetFirst() const; return first bin on the axis; ie 1 if no range defined; NOTE: in some cases a zero is returned (see TAxis::SetRange). Int_t GetLast() const; return last bin on the axis; ie fNbins if no range defined; NOTE: in some cases a zero is returned (see TAxis::SetRange). Double_t GetBinCenter(Int_t bin) const; Return center of bin. Double_t GetBinCenterLo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TAxis.html:13175,depend,depending,13175,root/html534/TAxis.html,https://root.cern,https://root.cern/root/html534/TAxis.html,2,['depend'],['depending']
Integrability," Copy(TObject& axis) const; Copy axis structure to another axis. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to an axis. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when an axis is clicked with the locator. The axis range is set between the position where the mouse is pressed; and the position where it is released.; If the mouse position is outside the current axis range when it is released; the axis is unzoomed with the corresponding proportions.; Note that the mouse does not need to be in the pad or even canvas; when it is released. Int_t FindBin(Double_t x); Find bin number corresponding to abscissa x. If x is underflow or overflow, attempt to rebin histogram; if the TH1::kCanRebin bit is set otherwise return 0 or fNbins+1. Int_t FindBin(const char* label); Find bin number with label.; If the List of labels does not exist create it; If label is not in the list of labels do the following depending on the; bit TH1::kCanRebin of the parent histogram.; - if the bit is set add the new label and if the number of labels exceeds; the number of bins, double the number of bins via TH1::LabelsInflate; - if the bit is not set return 0 (underflow bin). -1 is returned only when the Axis has no parent histogram. Int_t FindFixBin(Double_t x) const; Find bin number corresponding to abscissa x. const char * GetBinLabel(Int_t bin) const; Return label for bin. Int_t GetFirst() const; return first bin on the axis; ie 1 if no range defined; NOTE: in some cases a zero is returned (see TAxis::SetRange). Int_t GetLast() const; return last bin on the axis; ie fNbins if no range defined; NOTE: in some cases a zero is returned (see TAxis::SetRange). Double_t GetBinCenter(Int_t bin) const; Return center of bin. Double_t GetBinCenterLog(Int_t bin) const; Return center of bin in log; With a log-equidistant binning for a bin with low and up edges, the mean is :; 0.5*(ln low + l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TAxis.html:13016,depend,depending,13016,root/html530/TAxis.html,https://root.cern,https://root.cern/root/html530/TAxis.html,3,['depend'],['depending']
Integrability," Create a TGFileInfo concerning a macro, if it doesn't exist already. void AddToolbar(TGCompositeFrame* p); Add the tool bar to the frame 'p'. void AddTopLevelInterface(TGCompositeFrame* cf); Add the top level interface to the frame 'cf'. This part of the; interface will provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect every widget entry of the editor from its slot. Must be; called before UpdateEditor() to avoid recursive calls. void DoEditor(); Called each time something is changed in the style editor. Thanks to; this method, we can know if the style differs from the original style. void AddEdition(TGCompositeFrame* p); Add the editor to the frame 'p'. It contains the tabs allowing the user; to modify every data member of the current TStyle object. void CreateTabGeneral(TGCompositeFrame* tab); Add the tab 'General' to the editor. void AddGeneralFill(TGCompositeFrame* f); Add the 'Fill' group frame to the 'General' tab. void AddGeneralLine(TGCompositeFrame* f); Add the 'Line' group frame to the 'General' tab. void AddGeneralText(TGCompositeFrame* f); Add the 'Text' group frame to the 'General' tab. void AddGeneralMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleManager.html:50672,interface,interface,50672,root/html528/TStyleManager.html,https://root.cern,https://root.cern/root/html528/TStyleManager.html,10,['interface'],['interface']
Integrability," Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, double* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][row_lwb..row_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb][row_lwb..row_upb]. TMatrixTBase<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTSym<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][col_lwb] in a symmetric fashion, thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetMatrixArray(const double* data, Option_t* option = """"). TMatrixTBase<Element> &TMatrixTSym<Element> Shift(Int_t row_shift, Int_t col_shift). TMatrixTBase<Element> &TMatrixTSym<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set siz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSym_double_.html:15505,depend,depends,15505,root/html528/TMatrixTSym_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSym_double_.html,10,['depend'],['depends']
Integrability," Create a pad painter of specified type. Color_t GetLineColor() const; Line attributes to be set up in TPad. Style_t GetLineStyle() const. Width_t GetLineWidth() const. void SetLineColor(Color_t lcolor). void SetLineStyle(Style_t lstyle). void SetLineWidth(Width_t lwidth). Color_t GetFillColor() const; Fill attributes to be set up in TPad. Style_t GetFillStyle() const. Bool_t IsTransparent() const. void SetFillColor(Color_t fcolor). void SetFillStyle(Style_t fstyle). void SetOpacity(Int_t percent). Short_t GetTextAlign() const; Text attributes. Float_t GetTextAngle() const. Color_t GetTextColor() const. Font_t GetTextFont() const. Float_t GetTextSize() const. Float_t GetTextMagnitude() const. void SetTextAlign(Short_t align = 11). void SetTextAngle(Float_t tangle = 0). void SetTextColor(Color_t tcolor = 1). void SetTextFont(Font_t tfont = 62). void SetTextSize(Float_t tsize = 1). void SetTextSizePixels(Int_t npixels). Int_t CreateDrawable(UInt_t w, UInt_t h); This part is an interface to X11 pixmap management and to save sub-pads off-screens for OpenGL.; Currently, must be implemented only for X11/GDI. void ClearDrawable(). void CopyDrawable(Int_t device, Int_t px, Int_t py). void DestroyDrawable(). void SelectDrawable(Int_t device). These functions are not required by X11/GDI. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Now, drawing primitives. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2). void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode). void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y). void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y). void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y). void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y). void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v). void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y). void DrawPolyMarker(Int_t n, const Float_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualPadPainter.html:4478,interface,interface,4478,root/html528/TVirtualPadPainter.html,https://root.cern,https://root.cern/root/html528/TVirtualPadPainter.html,4,['interface'],['interface']
Integrability," Create a pad painter of specified type. Color_t GetLineColor() const; Line attributes to be set up in TPad. Style_t GetLineStyle() const. Width_t GetLineWidth() const. void SetLineColor(Color_t lcolor). void SetLineStyle(Style_t lstyle). void SetLineWidth(Width_t lwidth). Color_t GetFillColor() const; Fill attributes to be set up in TPad. Style_t GetFillStyle() const. Bool_t IsTransparent() const. void SetFillColor(Color_t fcolor). void SetFillStyle(Style_t fstyle). void SetOpacity(Int_t percent). Short_t GetTextAlign() const; Text attributes. Float_t GetTextAngle() const. Color_t GetTextColor() const. Font_t GetTextFont() const. Float_t GetTextSize() const. Float_t GetTextMagnitude() const. void SetTextAlign(Short_t align = 11). void SetTextAngle(Float_t tangle = 0). void SetTextColor(Color_t tcolor = 1). void SetTextFont(Font_t tfont = 62). void SetTextSize(Float_t tsize = 1). void SetTextSizePixels(Int_t npixels). Int_t CreateDrawable(UInt_t w, UInt_t h); This part is an interface to X11 pixmap management and to save sub-pads off-screens for OpenGL.; Currently, must be implemented only for X11/GDI. void ClearDrawable(). void CopyDrawable(Int_t device, Int_t px, Int_t py). void DestroyDrawable(). void SelectDrawable(Int_t device). void DrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t alphaBlending); TASImage support. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Now, drawing primitives. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2). void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode). void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y). void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y). void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y). void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y). void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v). void DrawPol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPadPainter.html:4837,interface,interface,4837,root/html534/TVirtualPadPainter.html,https://root.cern,https://root.cern/root/html534/TVirtualPadPainter.html,2,['interface'],['interface']
Integrability," Create a pad painter of specified type. Color_t GetLineColor() const; Line attributes to be set up in TPad. Style_t GetLineStyle() const. Width_t GetLineWidth() const. void SetLineColor(Color_t lcolor). void SetLineStyle(Style_t lstyle). void SetLineWidth(Width_t lwidth). Color_t GetFillColor() const; Fill attributes to be set up in TPad. Style_t GetFillStyle() const. Bool_t IsTransparent() const. void SetFillColor(Color_t fcolor). void SetFillStyle(Style_t fstyle). void SetOpacity(Int_t percent). Short_t GetTextAlign() const; Text attributes. Float_t GetTextAngle() const. Color_t GetTextColor() const. Font_t GetTextFont() const. Float_t GetTextSize() const. Float_t GetTextMagnitude() const. void SetTextAlign(Short_t align = 11). void SetTextAngle(Float_t tangle = 0). void SetTextColor(Color_t tcolor = 1). void SetTextFont(Font_t tfont = 62). void SetTextSize(Float_t tsize = 1). void SetTextSizePixels(Int_t npixels). Int_t CreateDrawable(UInt_t w, UInt_t h); This part is an interface to X11 pixmap management and to save sub-pads off-screens for OpenGL.; Currently, must be implemented only for X11/GDI. void ClearDrawable(). void CopyDrawable(Int_t device, Int_t px, Int_t py). void DestroyDrawable(). void SelectDrawable(Int_t device). void DrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableAlphaBlending); TASImage support. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Now, drawing primitives. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2). void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode). void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y). void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y). void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y). void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y). void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v). void D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPadPainter.html:5066,interface,interface,5066,root/html602/TVirtualPadPainter.html,https://root.cern,https://root.cern/root/html602/TVirtualPadPainter.html,4,['interface'],['interface']
Integrability," DataMemberInfo_Name(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_Title(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* dminfo) const; Interface to CINT function. void MethodInfo_Delete(MethodInfo_t* minfo) const; Interface to CINT function. void MethodInfo_CreateSignature(MethodInfo_t* minfo, TString& signature) const; Interface to CINT function. MethodInfo_t * MethodInfo_Factory() const; Interface to CINT function. MethodInfo_t * MethodInfo_FactoryCopy(MethodInfo_t* minfo) const; Interface to CINT function. void * MethodInfo_InterfaceMethod(MethodInfo_t* minfo) const; Interface to CINT function. bool MethodInfo_IsValid(MethodInfo_t* minfo) const; Interface to CINT function. int MethodInfo_NArg(MethodInfo_t* minfo) const; Interface to CINT function. int MethodInfo_NDefaultArg(MethodInfo_t* minfo) const; Interface to CINT function. int MethodInfo_Next(MethodInfo_t* minfo) const; Interface to CINT function. Long_t MethodInfo_Property(MethodInfo_t* minfo) const; Interface to CINT function. void * MethodInfo_Type(MethodInfo_t* minfo) const; Interface to CINT function. const char * MethodInfo_GetMangledName(MethodInfo_t* minfo) const; Interface to CINT function. const char * MethodInfo_GetPrototype(MethodInfo_t* minfo) const; Interface to CINT function. const char * MethodInfo_Name(MethodInfo_t* minfo) const; Interface to CINT function. const char * MethodInfo_TypeName(MethodInfo_t* minfo) const; Interface to CINT function. const char * MethodInfo_Title(MethodInfo_t* minfo) const; Interface to CINT function. void MethodArgInfo_Delete(MethodArgInfo_t* marginfo) const; Interface to CINT function. MethodArgInfo_t * MethodArgInfo_Factory() const; Interface to CINT function. MethodArgInfo_t * MethodArgInfo_FactoryCopy(MethodArgInfo_t* marginfo) const; Interface to CINT function. bool MethodArgInfo_IsValid(MethodArgInfo_t* marginfo) const; Interface to CINT f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCint.html:41068,Interface,Interface,41068,root/html532/TCint.html,https://root.cern,https://root.cern/root/html532/TCint.html,1,['Interface'],['Interface']
Integrability," DataMemberInfo_TypeName(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_TypeTrueName(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_Name(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_Title(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* ) const; {return 0;}. void FuncTempInfo_Delete(FuncTempInfo_t* ) const; Function Template interface. FuncTempInfo_t * FuncTempInfo_Factory(TInterpreter::DeclId_t declid) const. FuncTempInfo_t * FuncTempInfo_FactoryCopy(FuncTempInfo_t* ) const. Bool_t FuncTempInfo_IsValid(FuncTempInfo_t* ) const. UInt_t FuncTempInfo_TemplateNargs(FuncTempInfo_t* ) const. UInt_t FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t* ) const. Long_t FuncTempInfo_Property(FuncTempInfo_t* ) const. void FuncTempInfo_Name(FuncTempInfo_t* , TString& name) const. void FuncTempInfo_Title(FuncTempInfo_t* , TString& title) const. void MethodInfo_CreateSignature(MethodInfo_t* , TString& ) const; MethodInfo interface. {;}. void MethodInfo_Delete(MethodInfo_t* ) const; {;}. MethodInfo_t * MethodInfo_Factory() const; {return 0;}. MethodInfo_t * MethodInfo_Factory(ClassInfo_t* ) const; {return 0;}. MethodInfo_t * MethodInfo_Factory(TInterpreter::DeclId_t declid) const. MethodInfo_t * MethodInfo_FactoryCopy(MethodInfo_t* ) const; {return 0;}. void * MethodInfo_InterfaceMethod(MethodInfo_t* ) const; {return 0;}. Bool_t MethodInfo_IsValid(MethodInfo_t* ) const; {return 0;}. int MethodInfo_NArg(MethodInfo_t* ) const; {return 0;}. int MethodInfo_NDefaultArg(MethodInfo_t* ) const; {return 0;}. int MethodInfo_Next(MethodInfo_t* ) const; {return 0;}. Long_t MethodInfo_Property(MethodInfo_t* ) const. Long_t MethodInfo_ExtraProperty(MethodInfo_t* ) const. TypeInfo_t * MethodInfo_Type(MethodInfo_t* ) const; {return 0;}. EReturnType MethodInfo_MethodCallReturnType(MethodInfo_t* minfo) const. const char * MethodInfo_GetMangledName(MethodInfo_t* ) const; {return 0;}. cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TInterpreter.html:41145,interface,interface,41145,root/html602/TInterpreter.html,https://root.cern,https://root.cern/root/html602/TInterpreter.html,4,['interface'],['interface']
Integrability," Define calls. It must; 819 /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; 820 /// \param[in] inputColumns the names of the columns to be passed to the callable.; 821 /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; 822 /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; 823 ///; 824 /// Vary provides a natural and flexible syntax to define systematic variations that automatically propagate to; 825 /// Filters, Defines and results. RDataFrame usage of columns with attached variations does not change, but for; 826 /// results that depend on any varied quantity, a map/dictionary of varied results can be produced with; 827 /// ROOT::RDF::Experimental::VariationsFor (see the example below).; 828 ///; 829 /// The dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and; 830 /// values for each of the systematic variations that affected the result (via upstream Filters or via direct or; 831 /// indirect dependencies of the column values on some registered variations). The keys will be a composition of; 832 /// variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; 833 ///; 834 /// In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt.; 835 /// We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""):; 836 /// ~~~{.cpp}; 837 /// auto nominal_hx =; 838 /// df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); 839 /// .Filter(""pt > k""); 840 /// .Define(""x"", someFunc, {""pt""}); 841 /// .Histo1D(""x"");; 842 ///; 843 /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; 844 /// hx[""nominal""].Draw();; 845 /// hx[""pt:down""].Draw(""SAME"");; 846 /// hx[""pt:up""].Draw(""SAME"");; 847 /// ~~~; 848 /// RDataFrame computes all variations as part of a single l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:44710,depend,dependencies,44710,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['depend'],['dependencies']
Integrability," Definition at line 170 of file TProofLite.h. ◆ Load(). Int_t TProofLite::Load ; (; const char * ; macro, . Bool_t ; notOnClient = kFALSE, . Bool_t ; uniqueOnly = kTRUE, . TList * ; wrks = 0 . ). overridevirtual . Copy the specified macro in the cache directory. ; The macro file is uploaded if new or updated. If existing, the corresponding header basename(macro).h or .hh, is also uploaded. For the other arguments see TProof::Load(). Returns 0 in case of success and -1 in case of error. ; Reimplemented from TProof.; Definition at line 1539 of file TProofLite.cxx. ◆ MakeQueryResult(). TProofQueryResult * TProofLite::MakeQueryResult ; (; Long64_t ; nent, . const char * ; opt, . Long64_t ; fst, . TDSet * ; dset, . const char * ; selec . ). protected . Create a TProofQueryResult instance for this query. ; Definition at line 1000 of file TProofLite.cxx. ◆ NotifyStartUp(). void TProofLite::NotifyStartUp ; (; const char * ; action, . Int_t ; done, . Int_t ; tot . ). private . Notify setting-up operation message. ; Definition at line 667 of file TProofLite.cxx. ◆ operator=(). void TProofLite::operator= ; (; const TProofLite & ; ). private . ◆ PollForNewWorkers(). Int_t TProofLite::PollForNewWorkers ; (; ). overrideprotectedvirtual . Simulate dynamic addition, for test purposes. ; Here we decide how many workers to add, we create them and set the environment. This call is called regularly by Collect if the opton is enabled. Returns the number of new workers added, or <0 on errors. ; Reimplemented from TProof.; Definition at line 2528 of file TProofLite.cxx. ◆ Print(). void TProofLite::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print status of PROOF-Lite cluster. ; Reimplemented from TProof.; Definition at line 949 of file TProofLite.cxx. ◆ Process() [1/8]. Long64_t TProofLite::Process ; (; const char * ; dsetname, . const char * ; selector, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0, . TObject * ; elist = 0 . ). inlineove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:55591,message,message,55591,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['message'],['message']
Integrability, Definition at line 190 of file AdaptiveIntegratorMultiDim.h. ◆ fFun. const IMultiGenFunction* ROOT::Math::AdaptiveIntegratorMultiDim::fFun. private . Definition at line 195 of file AdaptiveIntegratorMultiDim.h. ◆ fMaxPts. unsigned int ROOT::Math::AdaptiveIntegratorMultiDim::fMaxPts. private . maximum number of function evaluation requested ; Definition at line 184 of file AdaptiveIntegratorMultiDim.h. ◆ fMinPts. unsigned int ROOT::Math::AdaptiveIntegratorMultiDim::fMinPts. private . minimum number of function evaluation requested ; Definition at line 183 of file AdaptiveIntegratorMultiDim.h. ◆ fNEval. int ROOT::Math::AdaptiveIntegratorMultiDim::fNEval. private . number of function evaluation ; Definition at line 192 of file AdaptiveIntegratorMultiDim.h. ◆ fRelError. double ROOT::Math::AdaptiveIntegratorMultiDim::fRelError. private . Relative error. ; Definition at line 191 of file AdaptiveIntegratorMultiDim.h. ◆ fRelTol. double ROOT::Math::AdaptiveIntegratorMultiDim::fRelTol. private . relative tolerance ; Definition at line 187 of file AdaptiveIntegratorMultiDim.h. ◆ fResult. double ROOT::Math::AdaptiveIntegratorMultiDim::fResult. private . last integration result ; Definition at line 189 of file AdaptiveIntegratorMultiDim.h. ◆ fSize. unsigned int ROOT::Math::AdaptiveIntegratorMultiDim::fSize. private . max size of working array (explode with dimension) ; Definition at line 185 of file AdaptiveIntegratorMultiDim.h. ◆ fStatus. int ROOT::Math::AdaptiveIntegratorMultiDim::fStatus. private . status of algorithm (error if not zero) ; Definition at line 193 of file AdaptiveIntegratorMultiDim.h. Libraries for ROOT::Math::AdaptiveIntegratorMultiDim:. [legend]; The documentation for this class was generated from the following files:; math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h; math/mathcore/src/AdaptiveIntegratorMultiDim.cxx. ROOTMathAdaptiveIntegratorMultiDim. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:19 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html:14008,integrat,integration,14008,doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,1,['integrat'],['integration']
Integrability," Definition at line 238 of file HybridPlot.cxx. ◆ GetHistoPvals(). double * HybridPlot::GetHistoPvals ; (; TH1 * ; histo, . double ; percentage . ). Get the ""effective sigmas"" of the histo, call delete [] res to release memory. ; We let an horizontal bar go down and we stop when we have the integral equal to the desired one. ; Definition at line 301 of file HybridPlot.cxx. ◆ GetMedian(). double HybridPlot::GetMedian ; (; TH1 * ; histo). Get the median of an histogram. ; Definition at line 353 of file HybridPlot.cxx. ◆ GetSBCenter(). double RooStats::HybridPlot::GetSBCenter ; (; double ; n_sigmas = 1, . bool ; display = false . ). inline . Get SB histo center. ; Definition at line 80 of file HybridPlot.h. ◆ GetSBhisto(). TH1F * RooStats::HybridPlot::GetSBhisto ; (; ). inline . Get B histo. ; Definition at line 92 of file HybridPlot.h. ◆ GetSBIntExtremes(). double * RooStats::HybridPlot::GetSBIntExtremes ; (; double ; frac). inline . Get SB histo integration extremes to obtain the requested area fraction call delete [] res to release memory. ; Definition at line 88 of file HybridPlot.h. ◆ GetSBmean(). double RooStats::HybridPlot::GetSBmean ; (; ). inline . Get SB histo mean. ; Definition at line 77 of file HybridPlot.h. ◆ GetSBrms(). double RooStats::HybridPlot::GetSBrms ; (; ). inline . Get SB histo RMS. ; Definition at line 84 of file HybridPlot.h. ◆ IsA(). TClass * RooStats::HybridPlot::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 121 of file HybridPlot.h. ◆ Streamer(). void RooStats::HybridPlot::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooStats::HybridPlot::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 121 of file HybridPlot.h. Member Data Documentation. ◆ fB_histo. TH1F* RooStats::HybridPlot::fB_histo. private . The b Histo. ; Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HybridPlot.html:17536,integrat,integration,17536,doc/master/classRooStats_1_1HybridPlot.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HybridPlot.html,1,['integrat'],['integration']
Integrability," Definition at line 28 of file TSSLSocket.h. Public Member Functions;  TSSLSocket (const char *host, const char *service, Int_t tcpwindowsize=-1);  ;  TSSLSocket (const char *sockpath);  ;  TSSLSocket (const char *url, Int_t port, Int_t tcpwindowsize=-1);  ;  TSSLSocket (const TSSLSocket &s);  ;  TSSLSocket (Int_t desc);  ;  TSSLSocket (Int_t desc, const char *sockpath);  ;  TSSLSocket (TInetAddress addr, const char *service, Int_t tcpwindowsize=-1);  ;  TSSLSocket (TInetAddress addr, Int_t port, Int_t tcpwindowsize=-1);  ; virtual ~TSSLSocket ();  Close gracefully the connection, and free SSL structures. ;  ; void Close (Option_t *option="""") override;  Close the SSL connection. ;  ; TClass * IsA () const override;  ; Int_t Recv (char *mess, Int_t max) override;  Receive a character string message of maximum max length. ;  ; Int_t Recv (char *mess, Int_t max, Int_t &kind) override;  Receive a character string message of maximum max length. ;  ; Int_t Recv (Int_t &status, Int_t &kind) override;  Receives a status and a message type. ;  ; Int_t Recv (TMessage *&mess) override;  Receive a TMessage object. ;  ; Int_t RecvRaw (void *buffer, Int_t length, ESendRecvOptions opt=kDefault) override;  Receive a raw buffer of specified length bytes. ;  ; Int_t Send (const char *mess, Int_t kind=kMESS_STRING) override;  Send a character string buffer. ;  ; Int_t Send (const TMessage &mess) override;  Send a TMessage object. ;  ; Int_t Send (Int_t kind) override;  Send a single message opcode. ;  ; Int_t Send (Int_t status, Int_t kind) override;  Send a status and a single message opcode. ;  ; Int_t SendRaw (const void *buffer, Int_t length, ESendRecvOptions opt=kDefault) override;  Send a raw buffer of specified length. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TSocket;  TSocket (const char *host, const char *service, Int_t tcpwindowsiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSSLSocket.html:1395,message,message,1395,doc/master/classTSSLSocket.html,https://root.cern,https://root.cern/doc/master/classTSSLSocket.html,1,['message'],['message']
Integrability," Definition at line 365 of file RLogger.hxx. ◆ R__LOG_ERROR. #define R__LOG_ERROR; (;  ; ...);    R__LOG_TO_CHANNEL(ROOT::Experimental::ELogLevel::kError, __VA_ARGS__). Definition at line 362 of file RLogger.hxx. ◆ R__LOG_FATAL. #define R__LOG_FATAL; (;  ; ...);    R__LOG_TO_CHANNEL(ROOT::Experimental::ELogLevel::kFatal, __VA_ARGS__). Definition at line 361 of file RLogger.hxx. ◆ R__LOG_INFO. #define R__LOG_INFO; (;  ; ...);    R__LOG_TO_CHANNEL(ROOT::Experimental::ELogLevel::kInfo, __VA_ARGS__). Definition at line 364 of file RLogger.hxx. ◆ R__LOG_PRETTY_FUNCTION. #define R__LOG_PRETTY_FUNCTION   __PRETTY_FUNCTION__. Definition at line 326 of file RLogger.hxx. ◆ R__LOG_TO_CHANNEL. #define R__LOG_TO_CHANNEL; (;  ; SEVERITY, .  ; CHANNEL . ). Value: ((SEVERITY < ROOT::Experimental::ELogLevel::kInfo + 0) || \; ROOT::Experimental::Internal::GetChannelOrManager(CHANNEL).GetEffectiveVerbosity( \; ROOT::Experimental::RLogManager::Get()) >= SEVERITY) && \; ROOT::Experimental::Detail::RLogBuilder(SEVERITY, ROOT::Experimental::Internal::GetChannelOrManager(CHANNEL), \; __FILE__, __LINE__, R__LOG_PRETTY_FUNCTION); R__LOG_PRETTY_FUNCTION#define R__LOG_PRETTY_FUNCTIONDefinition RLogger.hxx:326; ROOT::Experimental::RLogChannel::GetEffectiveVerbosityELogLevel GetEffectiveVerbosity(const RLogManager &mgr) constDefinition RLogger.hxx:313; ROOT::Experimental::RLogManager::Getstatic RLogManager & Get()Definition RLogger.cxx:62; ROOT::Experimental::Internal::GetChannelOrManagerRLogChannel & GetChannelOrManager()Definition RLogger.hxx:302; ROOT::Experimental::ELogLevel::kInfo@ kInfoInformational messages; used for instance for tracing. Definition at line 344 of file RLogger.hxx. ◆ R__LOG_WARNING. #define R__LOG_WARNING; (;  ; ...);    R__LOG_TO_CHANNEL(ROOT::Experimental::ELogLevel::kWarning, __VA_ARGS__). Definition at line 363 of file RLogger.hxx. corefoundationincROOTRLogger.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RLogger_8hxx.html:6170,message,messages,6170,doc/master/RLogger_8hxx.html,https://root.cern,https://root.cern/doc/master/RLogger_8hxx.html,1,['message'],['messages']
Integrability," Definition at line 50 of file RooCrystalBall.h. ◆ clone(). TObject * RooCrystalBall::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 26 of file RooCrystalBall.h. ◆ DeclFileName(). static const char * RooCrystalBall::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 50 of file RooCrystalBall.h. ◆ evaluate(). double RooCrystalBall::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 203 of file RooCrystalBall.cxx. ◆ getAnalyticalIntegral(). Int_t RooCrystalBall::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 234 of file RooCrystalBall.cxx. ◆ getMaxVal(). Int_t RooCrystalBall::getMaxVal ; (; const RooArgSet & ; vars); const. overridevirtual . Advertise that we know the maximum of self for given (m0,alpha,n,sigma). ; Reimplemented from RooAbsReal.; Definition at line 287 of file RooCrystalBall.cxx. ◆ IsA(). TClass * RooCrystalBall::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 50 of file RooCrystalBall.h. ◆ maxVal(). double RooCrystalBall::maxVal ; (; Int_t ; code); const. overridevirtual . Return maximum value for set of observables identified by code assigned in getMaxVal. ; Reimplemente",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCrystalBall.html:80199,depend,dependents,80199,doc/master/classRooCrystalBall.html,https://root.cern,https://root.cern/doc/master/classRooCrystalBall.html,2,"['depend', 'integrat']","['dependents', 'integration']"
Integrability," Definition at line 512 of file TGeoManager.h. ◆ GetTrack(). TVirtualGeoTrack * TGeoManager::GetTrack ; (; Int_t ; index). inline . Definition at line 373 of file TGeoManager.h. ◆ GetTrackIndex(). Int_t TGeoManager::GetTrackIndex ; (; Int_t ; id); const. Get index for track id, -1 if not found. ; Definition at line 2228 of file TGeoManager.cxx. ◆ GetTrackOfId(). TVirtualGeoTrack * TGeoManager::GetTrackOfId ; (; Int_t ; id); const. Get track with a given ID. ; Definition at line 2200 of file TGeoManager.cxx. ◆ GetUID(). Int_t TGeoManager::GetUID ; (; const char * ; volname); const. Retrieve unique id for a volume name. Return -1 if name not found. ; Definition at line 2978 of file TGeoManager.cxx. ◆ GetUserPaintVolume(). TGeoVolume * TGeoManager::GetUserPaintVolume ; (; ); const. inline . Definition at line 216 of file TGeoManager.h. ◆ GetVerboseLevel(). Int_t TGeoManager::GetVerboseLevel ; (; ). static . Set verbosity level (static function). . 0 - suppress messages related to geom-painter visibility level; 1 - default value . Definition at line 4066 of file TGeoManager.cxx. ◆ GetVirtualLevel(). Int_t TGeoManager::GetVirtualLevel ; (; ). Find level of virtuality of current overlapping node (number of levels up having the same tracking media. ; Definition at line 2166 of file TGeoManager.cxx. ◆ GetVisDensity(). Double_t TGeoManager::GetVisDensity ; (; ); const. inline . Definition at line 217 of file TGeoManager.h. ◆ GetVisLevel(). Int_t TGeoManager::GetVisLevel ; (; ); const. Returns current depth to which geometry is drawn. ; Definition at line 2149 of file TGeoManager.cxx. ◆ GetVisOption(). Int_t TGeoManager::GetVisOption ; (; ); const. Returns current depth to which geometry is drawn. ; Definition at line 2157 of file TGeoManager.cxx. ◆ GetVolume() [1/2]. TGeoVolume * TGeoManager::GetVolume ; (; const char * ; name); const. Search for a named volume. All trailing blanks stripped. ; Definition at line 2942 of file TGeoManager.cxx. ◆ GetVolume() [2/2]. TGeoVolume *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:104705,message,messages,104705,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['message'],['messages']
Integrability," Definition at line 615 of file TGQuartz.mm. ◆ SetMarkerColor(). void TGQuartz::SetMarkerColor ; (; Color_t ; mcolor). overridevirtual . Set the marker color. ; Reimplemented from TAttMarker.; Definition at line 641 of file TGQuartz.mm. ◆ SetMarkerSize(). void TGQuartz::SetMarkerSize ; (; Float_t ; msize). overridevirtual . Set the marker size. ; Note that the marker styles number 1 6 and 7 (the dots), cannot be scaled. They are meant to be very fast to draw and are always drawn with the same number of pixels; therefore this method does not apply on them. ; Reimplemented from TAttMarker.; Definition at line 649 of file TGQuartz.mm. ◆ SetMarkerStyle(). void TGQuartz::SetMarkerStyle ; (; Style_t ; mstyle). overridevirtual . Set the marker style. ; Reimplemented from TAttMarker.; Definition at line 659 of file TGQuartz.mm. ◆ SetOpacity(). void TGQuartz::SetOpacity ; (; Int_t ; percent). overridevirtual . Sets opacity of the current window. ; This image manipulation routine works by adding to a percent amount of neutral to each pixels RGB. Since it requires quite some additional color map entries is it only supported on displays with more than > 8 color planes (> 256 colors). ; Reimplemented from TVirtualX.; Definition at line 732 of file TGQuartz.mm. ◆ SetTextAlign(). void TGQuartz::SetTextAlign ; (; Short_t ; align = 11). overridevirtual . Set the text alignment. ; Reimplemented from TAttText.; Definition at line 668 of file TGQuartz.mm. ◆ SetTextColor(). void TGQuartz::SetTextColor ; (; Color_t ; tcolor). overridevirtual . Set the text color. ; Reimplemented from TAttText.; Definition at line 679 of file TGQuartz.mm. ◆ SetTextFont() [1/2]. Int_t TGQuartz::SetTextFont ; (; char * ; fontname, . ETextSetMode ; mode . ). overridevirtual . Sets text font to specified name ""fontname"".This function returns 0 if the specified font is found, 1 if it is not. ; Parameters. [in]fontnamefont name ; [in]modeloading flag; mode = 0 search if the font exist (kCheck); mode = 1 search t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGQuartz.html:62874,rout,routine,62874,doc/master/classTGQuartz.html,https://root.cern,https://root.cern/doc/master/classTGQuartz.html,1,['rout'],['routine']
Integrability," Definition at line 62 of file TGEventHandler.h. ◆ IsActive(). Bool_t TGEventHandler::IsActive ; (; ); const. inline . Definition at line 42 of file TGEventHandler.h. ◆ operator=(). TGEventHandler & TGEventHandler::operator= ; (; const TGEventHandler & ; ). privatedelete . ◆ ProcessedEvent(). virtual void TGEventHandler::ProcessedEvent ; (; Event_t * ; event). inlinevirtual . Definition at line 55 of file TGEventHandler.h. ◆ ProcessMessage(). virtual Bool_t TGEventHandler::ProcessMessage ; (; Longptr_t ; , . Longptr_t ; , . Longptr_t ;  . ). inlinevirtual . Definition at line 59 of file TGEventHandler.h. ◆ Repaint(). virtual void TGEventHandler::Repaint ; (; ). inlinevirtual . Reimplemented in TGLEventHandler.; Definition at line 60 of file TGEventHandler.h. ◆ SendMessage(). void TGEventHandler::SendMessage ; (; const TGWindow * ; w, . Longptr_t ; msg, . Longptr_t ; parm1, . Longptr_t ; parm2 . ). virtual . Send message (i.e. ; event) to window w. Message is encoded in one long as message type and up to two long parameters. ; Definition at line 36 of file TGEventHandler.cxx. ◆ Streamer(). void TGEventHandler::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGEventHandler::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 62 of file TGEventHandler.h. Member Data Documentation. ◆ fIsActive. Bool_t TGEventHandler::fIsActive. private . kTRUE if handler is active, kFALSE if not active ; Definition at line 29 of file TGEventHandler.h. ◆ fObject. TObject* TGEventHandler::fObject. private . Definition at line 31 of file TGEventHandler.h. ◆ fWindow. TGWindow* TGEventHandler::fWindow. private . Definition at line 30 of file TGEventHandler.h. Libraries for TGEventHandler:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGEventHandler.h; gui/gui/src/TGEventHandler.cxx. TGEventHandler. ROOT maste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGEventHandler.html:21914,message,message,21914,doc/master/classTGEventHandler.html,https://root.cern,https://root.cern/doc/master/classTGEventHandler.html,1,['message'],['message']
Integrability," Definition at line 87 of file RooBinSamplingPdf.h. ◆ integrate(). double RooBinSamplingPdf::integrate ; (; const RooArgSet * ; normSet, . double ; low, . double ; high . ); const. private . Integrate the wrapped PDF using our current integrator, with given norm set and limits. ; Definition at line 302 of file RooBinSamplingPdf.cxx. ◆ integrator(). std::unique_ptr< ROOT::Math::IntegratorOneDim > & RooBinSamplingPdf::integrator ; (; ); const. Direct access to the unique_ptr holding the integrator that's used to sample the bins. ; This can be used to change options such as sampling accuracy or to entirely exchange the integrator.; Example: Use the 61-point Gauss-Kronrod integration rule; ROOT::Math::IntegratorOneDimOptions intOptions = pdf.integrator()->Options();; intOptions.SetNPoints(6); // 61-point integration rule; intOptions.SetRelTolerance(1.E-9); // Smaller tolerance -> more subdivisions; pdf.integrator()->SetOptions(intOptions);; ROOT::Math::BaseIntegratorOptions::SetRelTolerancevoid SetRelTolerance(double tol)set the relative toleranceDefinition IntegratorOptions.h:80; ROOT::Math::IntegratorOneDimOptionsNumerical one dimensional integration options.Definition IntegratorOptions.h:113; ROOT::Math::IntegratorOneDimOptions::SetNPointsvoid SetNPoints(unsigned int n)Set number of points for active integration rule.Definition IntegratorOptions.h:140; See alsoROOT::Math::IntegratorOneDim::SetOptions for more details on integration options. ; NoteWhen RooBinSamplingPdf is loaded from files, integrator options will fall back to the default values. ; Definition at line 278 of file RooBinSamplingPdf.cxx. ◆ IsA(). TClass * RooBinSamplingPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 134 of file RooBinSamplingPdf.h. ◆ isBinnedDistribution(). bool RooBinSamplingPdf::isBinnedDistribution ; (; const RooArgSet & ; ); const. inlineoverridevirtual . Returns true, since this PDF is meant",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:87107,integrat,integrator,87107,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['integrat'],['integrator']
Integrability," Definition at line 97 of file TProofMgr.h. ◆ ReplaceSubdirs(). void TProofMgr::ReplaceSubdirs ; (; const char * ; fn, . TString & ; fdst, . TList & ; dirph . ). staticprivate . Parse file name extracting the directory subcomponents in dirs, stored as TObjStrings. ; Definition at line 745 of file TProofMgr.cxx. ◆ Reset(). Int_t TProofMgr::Reset ; (; Bool_t ; hard = kFALSE, . const char * ; usr = 0 . ). virtual . Send a cleanup request for the sessions associated with the current user. ; Not supported. ; Definition at line 307 of file TProofMgr.cxx. ◆ Rm(). Int_t TProofMgr::Rm ; (; const char * ; what, . const char * ; = 0, . const char * ; = 0 . ). virtual . Run 'rm' on 'what'. Locally it is just a call to TSystem::Unlink . ; Definition at line 1073 of file TProofMgr.cxx. ◆ SendMsgToUsers(). Int_t TProofMgr::SendMsgToUsers ; (; const char * ; , . const char * ; = 0 . ). virtual . Send a message to connected users. ; Only superusers can do this. The first argument specifies the message or the file from where to take the message. The second argument specifies the user to which to send the message: if empty or null the message is send to all the connected users. return 0 in case of success, -1 in case of error ; Definition at line 295 of file TProofMgr.cxx. ◆ SetAlias(). virtual void TProofMgr::SetAlias ; (; const char * ; alias = """"). inlinevirtual . Definition at line 104 of file TProofMgr.h. ◆ SetInvalid(). virtual void TProofMgr::SetInvalid ; (; ). inlinevirtual . Definition at line 78 of file TProofMgr.h. ◆ SetMssUrl(). virtual void TProofMgr::SetMssUrl ; (; const char * ; mss). inlinevirtual . Definition at line 105 of file TProofMgr.h. ◆ SetROOTVersion(). virtual Int_t TProofMgr::SetROOTVersion ; (; const char * ; ). inlinevirtual . Definition at line 106 of file TProofMgr.h. ◆ SetTXProofMgrHook(). void TProofMgr::SetTXProofMgrHook ; (; TProofMgr_t ; pmh). static . Set hook to TXProofMgr ctor. ; Definition at line 619 of file TProofMgr.cxx. ◆ ShowROOTVersions(). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofMgr.html:25954,message,message,25954,doc/master/classTProofMgr.html,https://root.cern,https://root.cern/doc/master/classTProofMgr.html,2,['message'],['message']
Integrability," Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 206 of file TTreeFormula.h. ◆ operator=(). TTreeFormula & TTreeFormula::operator= ; (; const TTreeFormula & ; ). privatedelete . ◆ ParseWithLeaf(). Int_t TTreeFormula::ParseWithLeaf ; (; TLeaf * ; leaf, . const char * ; subExpression, . bool ; final, . UInt_t ; paran_level, . TObjArray & ; castqueue, . bool ; useLeafCollectionObject, . const char * ; fullExpression . ). protected . Decompose 'expression' as pointing to something inside the leaf Returns: . -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. . Definition at line 764 of file TTreeFormula.cxx. ◆ PrintValue() [1/2]. char * TTreeFormula::PrintValue ; (; Int_t ; mode, . Int_t ; instance, . const char * ; decform = ""9.9"" . ); const. virtual . Return value of variable as a string. . mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). . Definition at line 4840 of file TTreeFormula.cxx. ◆ PrintValue() [2/2]. char * TTreeFormula::PrintValue ; (; Int_t ; mode = 0); const. virtual . Return value of variable as a string. . mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values . Definition at line 4826 of file TTreeFormula.cxx. ◆ RegisterDimensions() [1/5]. Int_t TTreeFormula::RegisterDimensions ; (; const char * ; size, . Int_t ; code . ). protected . This method is used internally to decode t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:46137,message,message,46137,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,2,['message'],['message']
Integrability," Double_t ApplyKernelFunction(Double_t normalized_distance); from the normalized euclidean distance calculate the distance; for a certain kernel. Double_t KernelNormalization(Double_t pdf); Calculating the normalization factor only once (might need a reset at some point.; Can the method be restarted with different params?). Double_t GetNormalizedDistance(const TMVA::Event& base_event, const TMVA::BinarySearchTreeNode& sample_event, Double_t* dim_normalization); We use Euclidian metric here. Might not be best or most efficient. Double_t NormSinc(Double_t x); NormSinc. Double_t LanczosFilter(Int_t level, Double_t x); Lanczos Filter. Float_t GetError(Float_t countS, Float_t countB, Float_t sumW2S, Float_t sumW2B) const; statistical error estimate for RS estimator. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read weight info from file. void WriteWeightsToStream(TFile& rf) const; write training sample (TTree) to file. void ReadWeightsFromStream(TFile& istr); read training sample from file. TMVA::MethodPDERS* ThisPDERS( void ); static pointer to this object. void UpdateThis( void ); update static this pointer. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". BinarySearchTree* GetBinaryTree( void ); accessors. { return fBinaryTree; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Yair Mahalalel, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodPDERS.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodPDERS.html:24419,message,message,24419,root/html528/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html,1,['message'],['message']
Integrability," Double_t&, Double_t&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationfDTSeparationBACKWARDS COMPATIBILITY: split cells according to decision tree logic; Int_tfDimDimension of the integration/simulation space; TMVA::PDEFoamDensityBase*fDistr! distribution of training events; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tfFillFoamWithOrigWeightsBACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights; TMVA::EFoamTypefFoamTypeBACKWARDS COMPATIBILITY: type of foam; TObjArray*fHistEdgHistograms of wt, one for each cell edge; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TMVA::MsgLogger*fLogger! message logger; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tfMaxDepthmaximum depth of cell tree; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Int_tfNCellsMaximum number of cells; UInt_tfNElementsBACKWARDS COMPATIBILITY: number of variables in every cell; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; UInt_tfNminminimal number of events in cell to split cell; Int_tfNoActNumber of active cells; Bool_tfPeekMaxBACKWARDS COMPATIBILITY: peek up cell with max. driver integral for split; TRandom3*fPseRanPointer to user-defined generator of pseudorandom numbers; Double_t*fRvec[fDim] random number vector from r.n. generator fDim+1 maximum elements; TMVA::Timer*fTimer! timer for graphical output; TObjArray*fVariableNamescollection of all variable names; Float_tfVolFracBACKWARDS COMPATIBILITY: volume fraction (with respect to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoam.html:10056,message,message,10056,root/html530/TMVA__PDEFoam.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoam.html,5,['message'],['message']
Integrability," Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization error at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalControl(const Int_t* powers) const; PRIVATE METHOD:; Calculate the control parameter from the passed powers. Double_t EvalFactor(Int_t p, Double_t x) const; PRIVATE METHOD:; Evaluate function with power p at variable value x. void FindParameterization(Option_t* option = """"); Find the parameter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:26441,depend,dependent,26441,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,10,['depend'],['dependent']
Integrability," Double_t*_x! do not persist; Double_t_xmax! Upper integration bound; Double_t_xmin! Lower integration bound. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooIntegrator1D, is parameters and capabilities with RooNumIntFactory. RooIntegrator1D(); Default constructor. RooIntegrator1D(const RooAbsFunc& function, SummationRule rule,				 Int_t maxSteps, Double_t eps); Construct integrator on given function binding, using specified summation; rule, maximum number of steps and conversion tolerance. The integration; limits are taken from the function binding. RooIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, RooIntegrator1D::SummationRule rule = Trapezoid, Int_t maxSteps = 0, Double_t eps = 0); Construct integrator on given function binding for given range,; using specified summation rule, maximum number of steps and; conversion tolerance. The integration limits are taken from the; function binding. RooIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Construct integrator on given function binding, using specified; configuration object. The integration limits are taken from the; function binding. RooIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax,				const RooNumIntConfig& config); Construct integrator on given function binding, using specified; configuration object and integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Clone integrator with new function binding and configuration. Needed by RooNumIntFactory. Bool_t initialize(); Initialize the integrator. ~RooIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooIntegrator1D.html:8618,integrat,integration,8618,root/html526/RooIntegrator1D.html,https://root.cern,https://root.cern/root/html526/RooIntegrator1D.html,1,['integrat'],['integration']
Integrability," Double_tTGeoBBox::fDZZ half-length; Double_tTGeoTube::fDzhalf length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; Double_tTGeoTube::fRmaxouter radius; Double_tTGeoTube::fRmininner radius; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; Double_tfStInStereo angle for inner surface; Double_tfStOutStereo angle for inner surface; TStringTNamed::fTitleobject title. private:. Double_tfTinTangent of stereo angle for inner surface; Double_tfTinsqSquared tangent of stereo angle for inner surface; Double_tfToutTangent of stereo angle for outer surface; Double_tfToutsqSquared tangent of stereo angle for outer surface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHype(); Default constructor. TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying hyperboloid parameters. TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHype.html:13871,rout,rout,13871,root/html528/TGeoHype.html,https://root.cern,https://root.cern/root/html528/TGeoHype.html,4,['rout'],['rout']
Integrability," Double_tTGeoBBox::fDZZ half-length; Double_tTGeoTube::fDzhalf length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; Double_tTGeoTube::fRmaxouter radius; Double_tTGeoTube::fRmininner radius; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; Double_tfStInStereo angle for inner surface; Double_tfStOutStereo angle for inner surface; TStringTNamed::fTitleobject title. private:. Double_tfTinTangent of stereo angle for inner surface; Double_tfTinsqSquared tangent of stereo angle for inner surface; Double_tfToutTangent of stereo angle for outer surface; Double_tfToutsqSquared tangent of stereo angle for outer surface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHype(); Default constructor. TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying hyperboloid parameters. TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHype.html:15084,rout,rout,15084,root/html534/TGeoHype.html,https://root.cern,https://root.cern/root/html534/TGeoHype.html,6,['rout'],['rout']
Integrability," DrawBorder(); Draw frame border. void DoRedraw(); Redraw the frame. Bool_t HandleConfigureNotify(Event_t* event); This event is generated when the frame is resized. Bool_t HandleEvent(Event_t* event); Handle all frame events. Events are dispatched to the specific; event handlers. TGDimension GetDefaultSize() const; std::cout << fWidth << ""x"" << fHeight << std::endl;. void Move(Int_t x, Int_t y); Move frame. void Resize(UInt_t w = 0, UInt_t h = 0); Resize the frame.; If w=0 && h=0 - Resize to deafult size. void Resize(TGDimension size); Resize the frame. void MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); Move and/or resize the frame.; If w=0 && h=0 - Resize to deafult size. void SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); Send message (i.e. event) to window w. Message is encoded in one long; as message type and up to two long parameters. Bool_t HandleClientMessage(Event_t* event); Handle a client message. Client messages are the ones sent via; TGFrame::SendMessage (typically by widgets). ULong_t GetDefaultFrameBackground(); Get default frame background. ULong_t GetDefaultSelectedBackground(); Get default selected frame background. ULong_t GetWhitePixel(); Get white pixel value. ULong_t GetBlackPixel(); Get black pixel value. const TGGC & GetBlackGC(); Get black graphics context. const TGGC & GetWhiteGC(); Get white graphics context. const TGGC & GetHilightGC(); Get highlight color graphics context. const TGGC & GetShadowGC(); Get shadow color graphics context. const TGGC & GetBckgndGC(); Get background color graphics context. Time_t GetLastClick(); Get time of last mouse click. void Print(Option_t* option = """") const; Print window id. void SetDragType(Int_t type); SetDragType. void SetDropType(Int_t type); SetDropType. Int_t GetDragType() const; Returns drag source type.; If frame is not ""draggable"" - return zero. Int_t GetDropType() const; Returns drop target type.; If frame cannot accept drop - return zero. void StartGuiBuil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGFrame.html:18923,message,messages,18923,root/html528/TGFrame.html,https://root.cern,https://root.cern/root/html528/TGFrame.html,4,['message'],['messages']
Integrability," DrawBorder(); Draw frame border. void DoRedraw(); Redraw the frame. Bool_t HandleConfigureNotify(Event_t* event); This event is generated when the frame is resized. Bool_t HandleEvent(Event_t* event); Handle all frame events. Events are dispatched to the specific; event handlers. TGDimension GetDefaultSize() const; std::cout << fWidth << ""x"" << fHeight << std::endl;. void Move(Int_t x, Int_t y); Move frame. void Resize(UInt_t w = 0, UInt_t h = 0); Resize the frame.; If w=0 && h=0 - Resize to default size. void Resize(TGDimension size); Resize the frame. void MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); Move and/or resize the frame.; If w=0 && h=0 - Resize to default size. void SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); Send message (i.e. event) to window w. Message is encoded in one long; as message type and up to two long parameters. Bool_t HandleClientMessage(Event_t* event); Handle a client message. Client messages are the ones sent via; TGFrame::SendMessage (typically by widgets). ULong_t GetDefaultFrameBackground(); Get default frame background. ULong_t GetDefaultSelectedBackground(); Get default selected frame background. ULong_t GetWhitePixel(); Get white pixel value. ULong_t GetBlackPixel(); Get black pixel value. const TGGC & GetBlackGC(); Get black graphics context. const TGGC & GetWhiteGC(); Get white graphics context. const TGGC & GetHilightGC(); Get highlight color graphics context. const TGGC & GetShadowGC(); Get shadow color graphics context. const TGGC & GetBckgndGC(); Get background color graphics context. Time_t GetLastClick(); Get time of last mouse click. void Print(Option_t* option = """") const; Print window id. void SetDragType(Int_t type); SetDragType. void SetDropType(Int_t type); SetDropType. Int_t GetDragType() const; Returns drag source type.; If frame is not ""draggable"" - return zero. Int_t GetDropType() const; Returns drop target type.; If frame cannot accept drop - return zero. void StartGuiBuil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGFrame.html:19042,message,messages,19042,root/html534/TGFrame.html,https://root.cern,https://root.cern/root/html534/TGFrame.html,6,['message'],['messages']
Integrability," DynFindSymbol(module, entry);; 1962 if (f) return 0;; 1963 return -1;; 1964}; 1965 ; 1966///////////////////////////////////////////////////////////////////////////////; 1967/// Load all libraries known to ROOT via the rootmap system.; 1968/// Returns the number of top level libraries successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Find a dynamic library called lib using the system search paths.; 2017/// Appends known extensions if needed. Returned string must be deleted; 2018/// by the user!; 2019 ; 2020char *TSystem::DynamicPathName(const char *lib, Bool_t quiet /*=kFALSE*/); 2021{; 2022 TString sLib(lib);; 2023 if (FindDynamicLibrary(sLib, quiet)); 2024 return St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:64358,depend,dependencies,64358,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['depend'],['dependencies']
Integrability," ETask fTaskType = ETask::kNoTask;  the kind of task that is being executed, if any ;  ; friend TExecutorCRTP;  . Additional Inherited Members;  Protected Types inherited from ROOT::TExecutorCRTP< TProcessExecutor >; using InvokeResult_t = ROOT::TypeTraits::InvokeResult_t< F, Args... >;  ; using validMapReturnCond = std::enable_if_t<!std::is_reference< InvokeResult_t< F, T... > >::value &&!std::is_void< InvokeResult_t< F, T... > >::value >;  type definition used in templated functions for not allowing mapping functions that return references or void. ;  . #include <ROOT/TProcessExecutor.hxx>. Inheritance diagram for ROOT::TProcessExecutor:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ ETask. enum class ROOT::TProcessExecutor::ETask : unsigned char. strongprivate . A collection of the types of tasks that TProcessExecutor can execute. ; It is used to interpret in the right way and properly reply to the messages received (see, for example, TProcessExecutor::HandleInput) . EnumeratorkNoTask no task is being executed . kMap a Map method with no arguments is being executed . kMapWithArg a Map method with arguments is being executed . kMapRed a MapReduce method with no arguments is being executed . kMapRedWithArg a MapReduce method with arguments is being executed . Definition at line 99 of file TProcessExecutor.hxx. Constructor & Destructor Documentation. ◆ TProcessExecutor() [1/2]. ROOT::TProcessExecutor::TProcessExecutor ; (; unsigned ; nWorkers = 0). explicit . Class constructor. ; Parameters. nWorkersNumber of times this ROOT session will be forked, i.e. the number of workers that will be spawned. . Definition at line 90 of file TProcessExecutor.cxx. ◆ ~TProcessExecutor(). ROOT::TProcessExecutor::~TProcessExecutor ; (; ). default . ◆ TProcessExecutor() [2/2]. ROOT::TProcessExecutor::TProcessExecutor ; (; const TProcessExecutor & ; ). delete . Member Function Documentation. ◆ Collect(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TProcessExecutor.html:12307,message,messages,12307,doc/v632/classROOT_1_1TProcessExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TProcessExecutor.html,2,['message'],['messages']
Integrability," Element > & TMatrixTAutoloadOps::AddElemMult ; (; TVectorT< Element > & ; target, . Element ; scalar, . const TVectorT< Element > & ; source1, . const TVectorT< Element > & ; source2 . ). Modify addition: target += scalar * ElementMult(source1,source2) . ; Definition at line 1844 of file TVectorT.cxx. ◆ AddElemMult() [2/2]. template<class Element > . TVectorT< Element > & TMatrixTAutoloadOps::AddElemMult ; (; TVectorT< Element > & ; target, . Element ; scalar, . const TVectorT< Element > & ; source1, . const TVectorT< Element > & ; source2, . const TVectorT< Element > & ; select . ). Modify addition: target += scalar * ElementMult(source1,source2) only for those elements where select[i] != 0.0. ; Definition at line 1877 of file TVectorT.cxx. ◆ AMultB(). template<class Element > . void TMatrixTAutoloadOps::AMultB ; (; const Element *const ; ap, . Int_t ; na, . Int_t ; ncolsa, . const Element *const ; bp, . Int_t ; nb, . Int_t ; ncolsb, . Element * ; cp . ). Elementary routine to calculate matrix multiplication A*B. ; Definition at line 3081 of file TMatrixT.cxx. ◆ AMultBt(). template<class Element > . void TMatrixTAutoloadOps::AMultBt ; (; const Element *const ; ap, . Int_t ; na, . Int_t ; ncolsa, . const Element *const ; bp, . Int_t ; nb, . Int_t ; ncolsb, . Element * ; cp . ). Elementary routine to calculate matrix multiplication A*B^T. ; Definition at line 3128 of file TMatrixT.cxx. ◆ AreCompatible() [1/4]. template<class Element1 , class Element2 > . Bool_t TMatrixTAutoloadOps::AreCompatible ; (; const TMatrixT< Element1 > & ; m, . const TVectorT< Element2 > & ; v, . Int_t ; verbose = 0 . ). Check if m and v are both valid and have compatible shapes for M * v. ; Definition at line 2157 of file TVectorT.cxx. ◆ AreCompatible() [2/4]. template<class Element1 , class Element2 > . Bool_t TMatrixTAutoloadOps::AreCompatible ; (; const TMatrixTBase< Element1 > & ; m1, . const TMatrixTBase< Element2 > & ; m2, . Int_t ; verbose = 0 . ). Check that matrice sm1 and m2 arebot",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMatrixTAutoloadOps.html:20373,rout,routine,20373,doc/master/namespaceTMatrixTAutoloadOps.html,https://root.cern,https://root.cern/doc/master/namespaceTMatrixTAutoloadOps.html,1,['rout'],['routine']
Integrability," Element >::GetRowIndexArray ; (; ); const. inlineoverridevirtual . Implements TMatrixTBase< Element >.; Definition at line 115 of file TMatrixT.h. ◆ GetRowIndexArray() [2/2]. template<class Element > . Int_t * TMatrixT< Element >::GetRowIndexArray ; (; ). inlineoverridevirtual . Implements TMatrixTBase< Element >.; Definition at line 116 of file TMatrixT.h. ◆ GetSub() [1/2]. template<class Element > . TMatrixT< Element > TMatrixT< Element >::GetSub ; (; Int_t ; row_lwb, . Int_t ; row_upb, . Int_t ; col_lwb, . Int_t ; col_upb, . Option_t * ; option = ""S"" . ); const. inline . Definition at line 248 of file TMatrixT.h. ◆ GetSub() [2/2]. template<class Element > . TMatrixTBase< Element > & TMatrixT< Element >::GetSub ; (; Int_t ; row_lwb, . Int_t ; row_upb, . Int_t ; col_lwb, . Int_t ; col_upb, . TMatrixTBase< Element > & ; target, . Option_t * ; option = ""S"" . ); const. overridevirtual . Get submatrix [row_lwb..row_upb] x [col_lwb..col_upb]; The indexing range of the returned matrix depends on the argument option: ; option == ""S"" : return [0..row_upb-row_lwb][0..col_upb-col_lwb] (default) else : return [row_lwb..row_upb][col_lwb..col_upb] ; Implements TMatrixTBase< Element >.; Definition at line 1082 of file TMatrixT.cxx. ◆ Invert(). template<class Element > . TMatrixT< Element > & TMatrixT< Element >::Invert ; (; Double_t * ; det = nullptr). Invert the matrix and calculate its determinant. ; Definition at line 1390 of file TMatrixT.cxx. ◆ InvertFast(). template<class Element > . TMatrixT< Element > & TMatrixT< Element >::InvertFast ; (; Double_t * ; det = nullptr). Invert the matrix and calculate its determinant, however upto (6x6) a fast Cramer inversion is used . ; Definition at line 1404 of file TMatrixT.cxx. ◆ IsA(). template<class Element > . TClass * TMatrixT< Element >::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 215 of file TMatrixT.h. ◆ Memcpy_m(). template<class Element",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixT.html:37281,depend,depends,37281,doc/master/classTMatrixT.html,https://root.cern,https://root.cern/doc/master/classTMatrixT.html,1,['depend'],['depends']
Integrability," Enumerations |; Functions |; Variables ; RooStats Namespace ReferenceRooFit » RooStats » HistFactory | RooFit » RooStats. Namespace for the RooStats classes. ; More... Namespaces; namespace  HistFactory;  ; namespace  NumberCountingUtils;  ; namespace  ROOTDict;  . Classes; class  AcceptanceRegion;  ; class  AsymptoticCalculator;  Hypothesis Test Calculator based on the asymptotic formulae for the profile likelihood ratio. More...;  ; class  BayesianCalculator;  BayesianCalculator is a concrete implementation of IntervalCalculator, providing the computation of a credible interval using a Bayesian method. More...;  ; class  BernsteinCorrection;  BernsteinCorrection is a utility in RooStats to augment a nominal PDF with a polynomial correction term. More...;  ; class  BranchStore;  ; class  CombinedCalculator;  CombinedCalculator is an interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals. More...;  ; class  ConfidenceBelt;  ConfidenceBelt is a concrete implementation of the ConfInterval interface. More...;  ; class  ConfInterval;  ConfInterval is an interface class for a generic interval in the RooStats framework. More...;  ; class  DebuggingSampler;  ; class  DebuggingTestStat;  ; class  DetailedOutputAggregator;  This class is designed to aid in the construction of RooDataSets and RooArgSets, particularly those naturally arising in fitting operations. More...;  ; class  FeldmanCousins;  The FeldmanCousins class (like the Feldman-Cousins technique) is essentially a specific configuration of the more general NeymanConstruction. More...;  ; class  FrequentistCalculator;  Does a frequentist hypothesis test. More...;  ; class  Heaviside;  Represents the Heaviside function. More...;  ; class  HLFactory;  HLFactory is an High Level model Factory allows you to describe your models in a configuration file (datacards) acting as an interface with the RooFactoryWSTool. More...;  ; class  HybridCalculator;  Same purpose as HybridCalculato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooStats.html:1185,interface,interface,1185,doc/master/namespaceRooStats.html,https://root.cern,https://root.cern/doc/master/namespaceRooStats.html,1,['interface'],['interface']
Integrability," EnumeratorkFileIsPipe . Definition at line 109 of file TApplicationServer.h. Constructor & Destructor Documentation. ◆ TASLogHandler() [1/2]. TASLogHandler::TASLogHandler ; (; const char * ; cmd, . TSocket * ; s, . const char * ; pfx = """" . ). Execute 'cmd' in a pipe and handle output messages from the related file. ; Definition at line 137 of file TApplicationServer.cxx. ◆ TASLogHandler() [2/2]. TASLogHandler::TASLogHandler ; (; FILE * ; f, . TSocket * ; s, . const char * ; pfx = """" . ). Handle available message from the open file 'f'. ; Definition at line 162 of file TApplicationServer.cxx. ◆ ~TASLogHandler(). TASLogHandler::~TASLogHandler ; (; ). virtual . Handle available message in the open file. ; Definition at line 179 of file TApplicationServer.cxx. Member Function Documentation. ◆ IsValid(). Bool_t TASLogHandler::IsValid ; (; ). inline . Definition at line 114 of file TApplicationServer.h. ◆ Notify(). Bool_t TASLogHandler::Notify ; (; ). overridevirtual . Handle available message in the open file. ; Implements TSysEvtHandler.; Definition at line 190 of file TApplicationServer.cxx. ◆ ReadNotify(). Bool_t TASLogHandler::ReadNotify ; (; ). inlineoverridevirtual . Notify when something can be read from the descriptor associated with this handler. ; Reimplemented from TFileHandler.; Definition at line 117 of file TApplicationServer.h. ◆ SetDefaultPrefix(). void TASLogHandler::SetDefaultPrefix ; (; const char * ; pfx). static . Static method to set the default prefix. ; Definition at line 221 of file TApplicationServer.cxx. Member Data Documentation. ◆ fFile. FILE* TASLogHandler::fFile. private . Definition at line 104 of file TApplicationServer.h. ◆ fgPfx. TString TASLogHandler::fgPfx = """". staticprivate . Definition at line 107 of file TApplicationServer.h. ◆ fPfx. TString TASLogHandler::fPfx. private . Definition at line 105 of file TApplicationServer.h. ◆ fSocket. TSocket* TASLogHandler::fSocket. private . Definition at line 103 of file TApplicationServer.h. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASLogHandler.html:18392,message,message,18392,doc/master/classTASLogHandler.html,https://root.cern,https://root.cern/doc/master/classTASLogHandler.html,1,['message'],['message']
Integrability, ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; double fErrorTol;  ; bool fForceSum;  ; bool fHasIssuedConvWarning;  ; bool fHasIssuedSumWarning;  ; Int_t fMaxIters;  ; RooRealProxy k;  ; RooRealProxy lambda;  ; RooRealProxy x;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNonCentralChiSquare.html:69410,integrat,integration,69410,doc/master/classRooNonCentralChiSquare.html,https://root.cern,https://root.cern/doc/master/classRooNonCentralChiSquare.html,1,['integrat'],['integration']
Integrability," Event_t::fCount. if non-zero, at least this many more exposes ; Definition at line 183 of file GuiTypes.h. ◆ fFormat. Int_t Event_t::fFormat. Next fields only used by kClientMessageEvent. ; Definition at line 186 of file GuiTypes.h. ◆ fHandle. Handle_t Event_t::fHandle. general resource handle (used for atoms or windows) ; Definition at line 185 of file GuiTypes.h. ◆ fHeight. UInt_t Event_t::fHeight. width and height of exposed area ; Definition at line 182 of file GuiTypes.h. ◆ fSendEvent. Bool_t Event_t::fSendEvent. true if event came from SendEvent ; Definition at line 184 of file GuiTypes.h. ◆ fState. UInt_t Event_t::fState. key or button mask ; Definition at line 181 of file GuiTypes.h. ◆ fTime. Time_t Event_t::fTime. time event event occurred in ms ; Definition at line 177 of file GuiTypes.h. ◆ fType. EGEventType Event_t::fType. of event (see EGEventType) ; Definition at line 175 of file GuiTypes.h. ◆ fUser. Longptr_t Event_t::fUser[5]. 5 longs can be used by client message events NOTE: only [0], [1] and [2] may be used. ; [1] and [2] may contain >32 bit quantities (i.e. pointers on 64 bit machines) ; Definition at line 187 of file GuiTypes.h. ◆ fWidth. UInt_t Event_t::fWidth. Definition at line 182 of file GuiTypes.h. ◆ fWindow. Window_t Event_t::fWindow. window reported event is relative to ; Definition at line 176 of file GuiTypes.h. ◆ fX. Int_t Event_t::fX. Definition at line 178 of file GuiTypes.h. ◆ fXRoot. Int_t Event_t::fXRoot. Definition at line 179 of file GuiTypes.h. ◆ fY. Int_t Event_t::fY. pointer x, y coordinates in event window ; Definition at line 178 of file GuiTypes.h. ◆ fYRoot. Int_t Event_t::fYRoot. coordinates relative to root ; Definition at line 179 of file GuiTypes.h. Collaboration diagram for Event_t:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; core/gui/inc/GuiTypes.h. Event_t. ROOT master - Reference Guide Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structEvent__t.html:2272,message,message,2272,doc/master/structEvent__t.html,https://root.cern,https://root.cern/doc/master/structEvent__t.html,1,['message'],['message']
Integrability," Explicit column type; 2723 /// auto stdDev1 = myDf.StdDev<double>(""values"");; 2724 /// ~~~; 2725 ///; 2726 template <typename T = RDFDetail::RInferredType>; 2727 RResultPtr<double> StdDev(std::string_view columnName = """"); 2728 {; 2729 const auto userColumns = columnName.empty() ? ColumnNames_t() : ColumnNames_t({std::string(columnName)});; 2730 auto stdDeviationV = std::make_shared<double>(0);; 2731 return CreateAction<RDFInternal::ActionTags::StdDev, T>(userColumns, stdDeviationV, stdDeviationV, fProxiedPtr);; 2732 }; 2733 ; 2734 // clang-format off; 2735 ////////////////////////////////////////////////////////////////////////////; 2736 /// \brief Return the sum of processed column values (*lazy action*).; 2737 /// \tparam T The type of the branch/column.; 2738 /// \param[in] columnName The name of the branch/column.; 2739 /// \param[in] initValue Optional initial value for the sum. If not present, the column values must be default-constructible.; 2740 /// \return the sum of the selected column wrapped in a RResultPtr.; 2741 ///; 2742 /// If T is not specified, RDataFrame will infer it from the data and just-in-time compile the correct; 2743 /// template specialization of this method.; 2744 /// If the type of the column is inferred, the return type is `double`, the type of the column otherwise.; 2745 ///; 2746 /// This action is *lazy*: upon invocation of this method the calculation is; 2747 /// booked but not executed. Also see RResultPtr.; 2748 ///; 2749 /// ### Example usage:; 2750 /// ~~~{.cpp}; 2751 /// // Deduce column type (this invocation needs jitting internally); 2752 /// auto sum0 = myDf.Sum(""values"");; 2753 /// // Explicit column type; 2754 /// auto sum1 = myDf.Sum<double>(""values"");; 2755 /// ~~~; 2756 ///; 2757 template <typename T = RDFDetail::RInferredType>; 2758 RResultPtr<RDFDetail::SumReturnType_t<T>>; 2759 Sum(std::string_view columnName = """",; 2760 const RDFDetail::SumReturnType_t<T> &initValue = RDFDetail::SumReturnType_t<T>{}); 2761 {; 2762",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:153349,wrap,wrapped,153349,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['wrap'],['wrapped']
Integrability," Expontial resolution model; RooGamma Gaussian PDF; RooGaussKronrodIntegrator1D 1-dimensional Gauss-Kronrod numerical integration engine; RooGaussModel Gaussian Resolution Model; RooGaussian Gaussian PDF; RooGenCategory Generic category-to-category function based on user supplied mapping function; RooGenContext Universal context for generating toy MC data from any p.d.f; RooGenFitStudy Generate-and-Fit study module; RooGenFunction Export RooAbsReal as functor; RooGenProdProj General form of projected integral of product of PDFs, utility class for RooProdPdf; RooGenericPdf Generic PDF defined by string expression and list of variables; RooGlobalFunc ; RooGrid Utility class for RooMCIntegrator holding a multi-dimensional grid; RooHashTable Hash table; RooHist 1-dimensional histogram with error bars; RooHistConstraint Your description goes here...; RooHistError Utility class for calculating histogram errors; RooHistFunc Histogram based function; RooHistPdf Histogram based PDF; RooImproperIntegrator1D 1-dimensional improper integration engine; RooInt Container class for Int_t; RooIntegralMorph Linear shape interpolation operator p.d.f; RooIntegrator1D 1-dimensional numerical integration engine; RooIntegrator2D 2-dimensional numerical integration engine; RooIntegratorBinding Function binding representing output of numeric integrator; RooInvTransform Function binding returning inverse of other function binding; RooJeffreysPrior Sum of RooAbsReal objects; RooKeysPdf One-dimensional non-parametric kernel estimation p.d.f.; RooLandau Landau Distribution PDF; RooLegendre Legendre polynomial; RooLinTransBinning Linear transformation of binning specification; RooLinearVar Lvalue linear transformation function ; RooLinkedList Doubly linked list for storage of RooAbsArg objects; RooLinkedListElem Element of RooLinkedList container class; RooLinkedListIter Iterator for RooLinkedList container class; RooList TList with extra support for Option_t associations; RooListProxy Proxy clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:37834,integrat,integration,37834,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,2,['integrat'],['integration']
Integrability," Filter(F f, const ColumnNames_t &columns={}, std::string_view name="""")Append a filter to the call graph.Definition RInterface.hxx:219. Definition at line 2792 of file RInterface.hxx. ◆ Snapshot() [1/4]. template<typename Proxied , typename DataSource = void> . template<typename... ColumnTypes> . RResultPtr< RInterface< RLoopManager > > ROOT::RDF::RInterface< Proxied, DataSource >::Snapshot ; (; std::string_view ; treename, . std::string_view ; filename, . const ColumnNames_t & ; columnList, . const RSnapshotOptions & ; options = RSnapshotOptions() . ). inline . Save selected columns to disk, in a new TTree treename in file filename. ; Template Parameters. ColumnTypesvariadic list of branch/column types. . Parameters. [in]treenameThe name of the output TTree. ; [in]filenameThe name of the output TFile. ; [in]columnListThe list of names of the columns/branches to be written. ; [in]optionsRSnapshotOptions struct with extra options to pass to TFile and TTree. . Returnsa RDataFrame that wraps the snapshotted dataset.; Support for writing of nested branches is limited (although RDataFrame is able to read them) and dot ('.') characters in input column names will be replaced by underscores ('_') in the branches produced by Snapshot. When writing a variable size array through Snapshot, it is required that the column indicating its size is also written out and it appears before the array in the columnList.; By default, in case of TTree or TChain inputs, Snapshot will try to write out all top-level branches. For other types of inputs, all columns returned by GetColumnNames() will be written out. If friend trees or chains are present, by default all friend top-level branches that have names that do not collide with names of branches in the main TTree/TChain will be written out. Since v6.24, Snapshot will also write out friend branches with the same names of branches in the main TTree/TChain with names of the form <friendname>_<branchname> in order to differentiate them from th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:123965,wrap,wraps,123965,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['wrap'],['wraps']
Integrability," FindSym(const char* entry) const; Interface to CINT function. void GenericError(const char* error) const; Interface to CINT function. Long_t GetExecByteCode() const; Interface to CINT function. Long_t Getgvp() const; Interface to CINT function. const char * Getp2f2funcname(void* receiver) const; Interface to CINT function. int GetSecurityError() const; Interface to CINT function. int LoadFile(const char* path) const; Interface to CINT function. void LoadText(const char* text) const; Interface to CINT function. const char * MapCppName(const char* ) const; Interface to CINT function. void SetAlloclockfunc(void (*)() ) const; Interface to CINT function. void SetAllocunlockfunc(void (*)() ) const; Interface to CINT function. int SetClassAutoloading(int ) const; Interface to CINT function. void SetErrmsgcallback(void* p) const; Interface to CINT function. void Setgvp(Long_t ) const; Interface to CINT function. void SetRTLD_NOW() const; Interface to CINT function. void SetRTLD_LAZY() const; Interface to CINT function. void SetTempLevel(int val) const; Interface to CINT function. int UnloadFile(const char* path) const; Interface to CINT function. void CallFunc_Delete(void* func) const; Interface to CINT function. void CallFunc_Exec(CallFunc_t* func, void* address) const; Interface to CINT function. Long_t CallFunc_ExecInt(CallFunc_t* func, void* address) const; Interface to CINT function. Long64_t CallFunc_ExecInt64(CallFunc_t* func, void* address) const; Interface to CINT function. Double_t CallFunc_ExecDouble(CallFunc_t* func, void* address) const; Interface to CINT function. CallFunc_t * CallFunc_Factory() const; Interface to CINT function. CallFunc_t * CallFunc_FactoryCopy(CallFunc_t* func) const; Interface to CINT function. MethodInfo_t * CallFunc_FactoryMethod(CallFunc_t* func) const; Interface to CINT function. void CallFunc_Init(CallFunc_t* func) const; Interface to CINT function. Bool_t CallFunc_IsValid(CallFunc_t* func) const; Interface to CINT function. void Cal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:33856,Interface,Interface,33856,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,1,['Interface'],['Interface']
Integrability," FindSym(const char* entry) const; Interface to CINT function. void GenericError(const char* error) const; Interface to CINT function. Long_t GetExecByteCode() const; Interface to CINT function. Long_t Getgvp() const; Interface to CINT function. const char * Getp2f2funcname(void* receiver) const; Interface to CINT function. int GetSecurityError() const; Interface to CINT function. int LoadFile(const char* path) const; Interface to CINT function. void LoadText(const char* text) const; Interface to CINT function. const char * MapCppName(const char* ) const; Interface to CINT function. void SetAlloclockfunc(void (*)() ) const; Interface to CINT function. void SetAllocunlockfunc(void (*)() ) const; Interface to CINT function. int SetClassAutoloading(int ) const; Interface to CINT function. void SetErrmsgcallback(void* p) const; Interface to CINT function. void Setgvp(Long_t ) const; Interface to CINT function. void SetRTLD_NOW() const; Interface to CINT function. void SetRTLD_LAZY() const; Interface to CINT function. void SetTempLevel(int val) const; Interface to CINT function. int UnloadFile(const char* path) const; Interface to CINT function. void CallFunc_Delete(void* func) const; Interface to CINT function. void CallFunc_Exec(CallFunc_t* func, void* address) const; Interface to CINT function. Long_t CallFunc_ExecInt(CallFunc_t* func, void* address) const; Interface to CINT function. Long_t CallFunc_ExecInt64(CallFunc_t* func, void* address) const; Interface to CINT function. Double_t CallFunc_ExecDouble(CallFunc_t* func, void* address) const; Interface to CINT function. CallFunc_t * CallFunc_Factory() const; Interface to CINT function. CallFunc_t * CallFunc_FactoryCopy(CallFunc_t* func) const; Interface to CINT function. MethodInfo_t * CallFunc_FactoryMethod(CallFunc_t* func) const; Interface to CINT function. void CallFunc_Init(CallFunc_t* func) const; Interface to CINT function. bool CallFunc_IsValid(CallFunc_t* func) const; Interface to CINT function. void CallFun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCint.html:33013,Interface,Interface,33013,root/html532/TCint.html,https://root.cern,https://root.cern/root/html532/TCint.html,1,['Interface'],['Interface']
Integrability," Float_t &b);  Convert machine dependent pixel value (obtained via RGB2Pixel or via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet. ;  ; static void Pixel2RGB (ULong_t pixel, Int_t &r, Int_t &g, Int_t &b);  Convert machine dependent pixel value (obtained via RGB2Pixel or via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet. ;  ; static const char * PixelAsHexString (ULong_t pixel);  Convert machine dependent pixel value (obtained via RGB2Pixel or via Number2Pixel() or via TColor::GetPixel()) to a hexadecimal string. ;  ; static void RGB2HLS (Float_t r, Float_t g, Float_t b, Float_t &h, Float_t &l, Float_t &s);  Static method to compute HLS from RGB. ;  ; static void RGB2HLS (Int_t r, Int_t g, Int_t b, Int_t &h, Int_t &l, Int_t &s);  Static method to compute HLS from RGB. ;  ; static void RGB2HSV (Float_t r, Float_t g, Float_t b, Float_t &h, Float_t &s, Float_t &v);  Static method to compute HSV from RGB. ;  ; static ULong_t RGB2Pixel (Float_t r, Float_t g, Float_t b);  Convert r,g,b to graphics system dependent pixel value. ;  ; static ULong_t RGB2Pixel (Int_t r, Int_t g, Int_t b);  Convert r,g,b to graphics system dependent pixel value. ;  ; static void RGBtoHLS (Float_t r, Float_t g, Float_t b, Float_t &h, Float_t &l, Float_t &s);  ; static Bool_t SaveColor (std::ostream &out, Int_t ci);  Save a color with index > 228 as a C++ statement(s) on output stream out. ;  ; static void SetColorThreshold (Float_t t);  This method specifies the color threshold used by GetColor to retrieve a color. ;  ; static void SetGrayscale (Bool_t set=kTRUE);  Set whether all colors should return grayscale values. ;  ; static void SetPalette (Int_t ncolors, Int_t *colors, Float_t alpha=1.);  Static function. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:40475,depend,dependent,40475,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,4,['depend'],['dependent']
Integrability," Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; namechar name[80]Definition TGX11.cxx:110; nentriesint nentriesDefinition THbookFile.cxx:91; TTree.h; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TContextMenuThis class provides an interface to context sensitive popup menus.Definition TContextMenu.h:44; TGButtonA button abstract base class.Definition TGButton.h:68; TGCanvasA frame containing two scrollbars (a horizontal and a vertical) and a viewport.Definition TGCanvas.h:192; TGCheckButtonSelects different options.Definition TGButton.h:264; TGClientWindow client.Definition TGClient.h:37; TGComboBoxA combobox (also known as a drop down listbox) allows the selection of one item out of a list of item...Definition TGComboBox.h:47; TGCompositeFrameThe base class for composite widgets (menu bars, list boxes, etc.).Definition TGFrame.h:287; TGDoubleVSliderDragging the slider will generate the event:Definition TGDoubleSlider.h:170; TGHProgressBarDefinition TGProgressBar.h:94; TGHorizontalFrameA composite frame that layout their children in horizontal way.Definition TGFrame.h:385; TGLabelThis class handles GUI labels.Definition TGLabel.h:24; TGLayoutHintsThis class describes layout hints used by the layout classes.Definit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8h_source.html:11196,interface,interface,11196,doc/master/TTreeViewer_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8h_source.html,1,['interface'],['interface']
Integrability," Float_t xmax, Float_t ymin, Float_t ymax, Float_t zmin, Float_t zmax); Bool_tTGLObject::SetModelCheckClass(TObject* obj, TClass* cls). private:. TEveTextGL&operator=(const TEveTextGL&); TEveTextGL(const TEveTextGL&). Data Members; public:. static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesAll; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesNone; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesX; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesY; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesZ. protected:. TGLBoundingBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; TGLFontfFontFTFont wrapper; TEveText*fMmodel object.; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!); Double_tfX[4][3]3D position of font; static Bool_tTGLLogicalShape::fgIgnoreSizeForCameraInterest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTextGL(); Constructor. Bool_t SetModel(TObject* obj, const Option_t* opt = 0); Set model object. void SetBBox(); Set bounding box. void DirectDraw(TGLRnrCtx& rnrCtx) const; Actual rendering code.; Virtual from TGLLogicalShape. TEveTextGL(const TEveTextGL& ). TEveTextGL& operator=(const TEveTextGL& ). virtual ~TEveTextGL(); {}. » Last changed: root/eve:$Id$ » Last generated: 2015-06-02 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEveTextGL.html:3851,wrap,wrapper,3851,root/html604/TEveTextGL.html,https://root.cern,https://root.cern/root/html604/TEveTextGL.html,2,['wrap'],['wrapper']
Integrability," Float_t xmax, Float_t ymin, Float_t ymax, Float_t zmin, Float_t zmax); Bool_tTGLObject::SetModelCheckClass(TObject* obj, TClass* cls). private:. TEveTextGL&operator=(const TEveTextGL&); TEveTextGL(const TEveTextGL&). Data Members; public:. static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesAll; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesNone; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesX; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesY; static TGLLogicalShape::ELODAxesTGLLogicalShape::kLODAxesZ. protected:. TGLBoundingBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; TGLFontfFontFTFont wrapper; TEveText*fMmodel object.; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!); Double_tfX[4][3]3D position of font; static Bool_tTGLLogicalShape::fgIgnoreSizeForCameraInterest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTextGL(); Constructor. Bool_t SetModel(TObject* obj, const Option_t* opt = 0); Set model object. void SetBBox(); Set bounding box. void DirectDraw(TGLRnrCtx& rnrCtx) const; Actual rendering code.; Virtual from TGLLogicalShape. TEveTextGL(const TEveTextGL& ). TEveTextGL& operator=(const TEveTextGL& ). virtual ~TEveTextGL(); {}. » Last changed: root/eve:$Id$ » Last generated: 2015-06-30 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveTextGL.html:3851,wrap,wrapper,3851,root/html602/TEveTextGL.html,https://root.cern,https://root.cern/root/html602/TEveTextGL.html,2,['wrap'],['wrapper']
Integrability," Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedReal.html:33150,integrat,integrator,33150,root/html526/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedReal.html,2,['integrat'],['integrator']
Integrability," Float_tfScaleSweight for signal events; vector<Float_t>*fShiftvolume center; TMVA::MethodPDERS::EVolumeRangeModefVRangeMode; TStringfVolumeRangeoption volume range; static TMVA::MethodPDERS*fgThisPDERSthis pointer (required by root finder); Int_tfkNNMaxmax number of events in kNN tree; Int_tfkNNMinmin number of events in kNN tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodPDERS(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructor for the PDERS method. MethodPDERS(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); construct MethodPDERS through from file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); PDERS can handle classification with 2 classes and regression with one or more regression-targets. void Init( void ); default initialisation routine called by all constructors. ~MethodPDERS( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; VolumeRangeMode <string> Method to determine volume range; available values are: MinMax; Unscaled; RMS; kNN; Adaptive <default>. KernelEstimator <string> Kernel estimation function; available values are: Box <default>; Sphere; Teepee; Gauss; Sinc3; Sinc5; Sinc7; Sinc9; Sinc11; Lanczos2; Lanczos3; Lanczos5; Lanczos8; Trim. DeltaFrac <float> Ratio of #EventsMin/#EventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodPDERS.html:20423,rout,routine,20423,root/html528/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html,6,['rout'],['routine']
Integrability," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:7967,rout,routine,7967,root/html534/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,122,['rout'],['routine']
Integrability," Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const double& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const double& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const double& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const double& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatrix<T,D1,D2,R> Inverse(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::Invert for the inversion algorithm. bool InvertFast(). Fast Invertion of a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same defult algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:7965,rout,routine,7965,root/html528/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,60,['rout'],['routine']
Integrability," Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Friends |; List of all members ; RooNumConvolution Class ReferenceRooFit » RooFit Core. ; Numeric 1-dimensional convolution operator PDF. ; This class can convolve any PDF with any other PDF This class should not be used blindly as numeric convolution is computing intensive and prone to stability fitting problems. If an analytic convolution can be calculated, you should use that or implement it if not available. RooNumConvolution implements reasonable defaults that should convolve most functions reasonably well, but results strongly depend on the shape of your input PDFS so always check your result.; The default integration engine for the numeric convolution is the adaptive Gauss-Kronrod method, which empirically seems the most robust for this task. You can override the convolution integration settings via the RooNumIntConfig object reference returned by the convIntConfig() member function By default the numeric convolution is integrated from -infinity to +infinity through a x -> 1/x coordinate transformation of the tails. For convolution with a very small bandwidth it may be advantageous (for both CPU consumption and stability) if the integration domain is limited to a finite range. The function setConvolutionWindow(mean,width,scale) allows to set a sliding window around the x value to be calculated taking a RooAbsReal expression for an offset and a width to be taken around the x value. These input expression can be RooFormulaVars or other function objects although the 3d 'scale' argument 'scale' multiplies the width RooAbsReal expression given in the 2nd argument, allowing for an appropriate window definition for most cases without need for a RooFormulaVar object: e.g. a Gaussian resolution PDF do setConvolutionWindow(gaussMean,gaussSigma,5) Note that for a 'wide' Gaussian the -inf to +inf integration may converge more quickly than that over a finite range! The def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvolution.html:1055,integrat,integration,1055,doc/master/classRooNumConvolution.html,https://root.cern,https://root.cern/doc/master/classRooNumConvolution.html,2,['integrat'],"['integrated', 'integration']"
Integrability," Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Attributes; Int_t fExitStatus;  ; THashList fInfoMsgs;  iterator in messages ;  ; TIter fIter;  ; TList fMsgs;  ; Long_t fResMaxMst;  ; Long_t fResMemMax;  ; Long_t fVirtMaxMst;  ; Long_t fVirtMemMax;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <TStatus.h>. Inheritance diagram for TStatus:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EProcStatus. enum TStatus::EProcStatus. EnumeratorkNotOk . Definition at line 35 of file TStatus.h. Constructor & Destructor Documentation. ◆ TStatus(). TStatus::TStatus ; (; ). Default constructor. ; Definition at line 34 of file TStatus.cxx. ◆ ~TStatus(). TStatus::~TStatus ; (; ). inlineover",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStatus.html:11535,message,messages,11535,doc/master/classTStatus.html,https://root.cern,https://root.cern/doc/master/classTStatus.html,1,['message'],['messages']
Integrability," GC components in use: function, plane-mask, fill-style, fill-rule, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask. GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, and tile-stipple-y-origin. (see also the GCValues_t structure) ; Reimplemented from TVirtualX.; Definition at line 2056 of file TGCocoa.mm. ◆ FillPolygonAux(). void TGCocoa::FillPolygonAux ; (; Window_t ; wid, . const GCValues_t & ; gcVals, . const Point_t * ; polygon, . Int_t ; nPoints . ). Definition at line 1984 of file TGCocoa.mm. ◆ FillRectangle(). void TGCocoa::FillRectangle ; (; Drawable_t ; id, . GContext_t ; gc, . Int_t ; x, . Int_t ; y, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . Fills the specified rectangle defined by [x,y] [x+w,y] [x+w,y+h] [x,y+h]. ; using the GC you specify.; GC components in use are: function, plane-mask, fill-style, subwindow-mode, clip-x-origin, clip-y-origin, clip-mask. GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, and tile-stipple-y-origin. (see also the GCValues_t structure) ; Reimplemented from TVirtualX.; Definition at line 1954 of file TGCocoa.mm. ◆ FillRectangleAux(). void TGCocoa::FillRectangleAux ; (; Drawable_t ; wid, . const GCValues_t & ; gcVals, . Int_t ; x, . Int_t ; y, . UInt_t ; w, . UInt_t ; h . ). Definition at line 1889 of file TGCocoa.mm. ◆ FindAtom(). Atom_t TGCocoa::FindAtom ; (; const std::string & ; atomName, . bool ; addIfNotFound . ). private . Definition at line 4495 of file TGCocoa.mm. ◆ FindRWindow(). Window_t TGCocoa::FindRWindow ; (; Window_t ; win, . Window_t ; dragwin, . Window_t ; input, . int ; x, . int ; y, . int ; maxd . ). overridevirtual . Recursively search in the children of Window for a Window which is at location x, y and is DND aware, with a maximum depth of maxd. ; Reimplemented from TVirtualX.; Definition at line 3992 of file TGCocoa.mm. ◆ FlushOpenGLBuffer(). void TGCocoa::FlushOpenGLBuffer ; (; Handle_t ; ctx). overri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:78779,depend,dependent,78779,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['depend'],['dependent']
Integrability," GCC diagnostic ignored ""-Wconversion""; 17006#endif; 17007 /* Data type of linger structure elements may differ,; 17008 * so we don't know what cast we need here.; 17009 * Disable type conversion warnings. */; 17010 ; 17011 linger.l_linger = (linger_timeout + 999) / 1000;; 17012 ; 17013#if defined(GCC_DIAGNOSTIC); 17014#pragma GCC diagnostic pop; 17015#endif; 17016#if defined(_MSC_VER); 17017#pragma warning(pop); 17018#endif; 17019 ; 17020 } else {; 17021 linger.l_onoff = 0;; 17022 linger.l_linger = 0;; 17023 }; 17024 ; 17025 if (linger_timeout < -1) {; 17026 /* Default: don't configure any linger */; 17027 } else if (getsockopt(conn->client.sock,; 17028 SOL_SOCKET,; 17029 SO_ERROR,; 17030#if defined(_WIN32) /* WinSock uses different data type here */; 17031 (char *)&error_code,; 17032#else; 17033 &error_code,; 17034#endif; 17035 &opt_len); 17036 != 0) {; 17037 /* Cannot determine if socket is already closed. This should; 17038 * not occur and never did in a test. Log an error message; 17039 * and continue. */; 17040 mg_cry_internal(conn,; 17041 ""%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s"",; 17042 __func__,; 17043 strerror(ERRNO));; 17044#if defined(_WIN32); 17045 } else if (error_code == WSAECONNRESET) {; 17046#else; 17047 } else if (error_code == ECONNRESET) {; 17048#endif; 17049 /* Socket already closed by client/peer, close socket without linger; 17050 */; 17051 } else {; 17052 ; 17053 /* Set linger timeout */; 17054 if (setsockopt(conn->client.sock,; 17055 SOL_SOCKET,; 17056 SO_LINGER,; 17057 (char *)&linger,; 17058 sizeof(linger)); 17059 != 0) {; 17060 mg_cry_internal(; 17061 conn,; 17062 ""%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s"",; 17063 __func__,; 17064 linger.l_onoff,; 17065 linger.l_linger,; 17066 strerror(ERRNO));; 17067 }; 17068 }; 17069 ; 17070 /* Now we know that our FIN is ACK-ed, safe to close */; 17071 closesocket(conn->client.sock);; 17072 conn->client.sock = INVALID_SOCKET;; 17073}; 17074#endif; 17075 ; 17076 ; 17077static void; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:506002,message,message,506002,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['message'],['message']
Integrability," GCC diagnostic ignored ""-Wconversion""; 17007#endif; 17008 /* Data type of linger structure elements may differ,; 17009 * so we don't know what cast we need here.; 17010 * Disable type conversion warnings. */; 17011 ; 17012 linger.l_linger = (linger_timeout + 999) / 1000;; 17013 ; 17014#if defined(GCC_DIAGNOSTIC); 17015#pragma GCC diagnostic pop; 17016#endif; 17017#if defined(_MSC_VER); 17018#pragma warning(pop); 17019#endif; 17020 ; 17021 } else {; 17022 linger.l_onoff = 0;; 17023 linger.l_linger = 0;; 17024 }; 17025 ; 17026 if (linger_timeout < -1) {; 17027 /* Default: don't configure any linger */; 17028 } else if (getsockopt(conn->client.sock,; 17029 SOL_SOCKET,; 17030 SO_ERROR,; 17031#if defined(_WIN32) /* WinSock uses different data type here */; 17032 (char *)&error_code,; 17033#else; 17034 &error_code,; 17035#endif; 17036 &opt_len); 17037 != 0) {; 17038 /* Cannot determine if socket is already closed. This should; 17039 * not occur and never did in a test. Log an error message; 17040 * and continue. */; 17041 mg_cry_internal(conn,; 17042 ""%s: getsockopt(SOL_SOCKET SO_ERROR) failed: %s"",; 17043 __func__,; 17044 strerror(ERRNO));; 17045#if defined(_WIN32); 17046 } else if (error_code == WSAECONNRESET) {; 17047#else; 17048 } else if (error_code == ECONNRESET) {; 17049#endif; 17050 /* Socket already closed by client/peer, close socket without linger; 17051 */; 17052 } else {; 17053 ; 17054 /* Set linger timeout */; 17055 if (setsockopt(conn->client.sock,; 17056 SOL_SOCKET,; 17057 SO_LINGER,; 17058 (char *)&linger,; 17059 sizeof(linger)); 17060 != 0) {; 17061 mg_cry_internal(; 17062 conn,; 17063 ""%s: setsockopt(SOL_SOCKET SO_LINGER(%i,%i)) failed: %s"",; 17064 __func__,; 17065 linger.l_onoff,; 17066 linger.l_linger,; 17067 strerror(ERRNO));; 17068 }; 17069 }; 17070 ; 17071 /* Now we know that our FIN is ACK-ed, safe to close */; 17072 closesocket(conn->client.sock);; 17073 conn->client.sock = INVALID_SOCKET;; 17074}; 17075#endif; 17076 ; 17077 ; 17078static void; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:506035,message,message,506035,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['message'],['message']
Integrability," GED-frames are constructed during traversal of class hierarchy of the selected object, executed from method TGedEditor::SetModel(). When a new object of a different class is selected, the unneeded GED-frames are cached in memory for potential reuse. The frames are deleted automatically when the editor is closed.; Note: A deep cleanup is assumed for all frames put into the editor. This implies:. do not share the layout-hints among GUI components;; do not delete child widgets in the destructor as this is done automatically. 25.9.2.2 Using Several Tabs; Sometimes you might need to use several tabs to organize properly your class-editor. Each editor tab is a resource shared among all the class-editors. Tabs must be created from the constructor of your editor-class by using the method:; TGVerticalFrame* TGedFrame::CreateEditorTabSubFrame(const Text_t *name),; It returns a pointer to a new tab container frame ready for use in your class. If you need to hide/show this frame depending on the object’s status, you should store it in a data member. See for examples: TH1Editor, TH2Editor.; 25.9.2.3 Base-Class Editors Control; Full control over base-class editors can be achieved by re-implementing virtual method void TGedFrame::ActivateBaseClassEditors(TClass *cl). It is called during each compound editor rebuild and the default implementation simply offers all base-classes to the publishing mechanism.; To prevent inclusion of a base-class into the compound editor, call:; void TGedEditor::ExcludeClassEditor(TClass* class, Bool_t recurse); Pointer to the compound GED-editor is available in TGedFrame‘s data-member:; TGedEditor *fGedEditor; Ordering of base-class editor frames follows the order of the classes in the class hierarchy. This order can be changed by modifying the value of TGedFrame’s data member Int_t fPriority. The default value is 50; smaller values move the frame towards to the top. This priority should be set in the editor constructor.; 25.10 Drag and Drop; Drag an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1225602,depend,depending,1225602,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['depend'],['depending']
Integrability," GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-03-13 19:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLSAViewer.html:27833,message,message,27833,root/html534/TGLSAViewer.html,https://root.cern,https://root.cern/root/html534/TGLSAViewer.html,2,['message'],['message']
Integrability," GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLSAViewer.html:30118,message,message,30118,root/html604/TGLSAViewer.html,https://root.cern,https://root.cern/root/html604/TGLSAViewer.html,2,['message'],['message']
Integrability," GLwidget, it is an error if it is already created.; This is needed for frame-swapping on mac. void DestroyGLWidget(); Destroy the GLwidget, it is an error if it does not exist.; This is needed for frame-swapping on mac. void CreateMenus(); File/Camera/Help menus. void CreateFrames(); Internal frames creation. void SelectionChanged(); Update GUI components for embedded viewer selection change.; Override from TGLViewer. void Show(); Show the viewer. void Close(); Close the viewer - destructed. void DeleteMenuBar(); Delete the menu bar. void DisableCloseMenuEntries(); Deactivate menu entries for closing the GL window and exiting ROOT. void EnableMenuBarHiding(); Enable hiding of menu bar. void DisableMenuBarHiding(); Disable hiding of menu bar. void HandleMenuBarHiding(Event_t* ev); Maybe switch menu-bar / menu-button. void ResetMenuHidingTimer(Bool_t show_menu); Reset the timer for menu-bar hiding. void MenuHidingTimeout(); Action for menu-hiding timeout. void SetMenuHidingTimeout(Long_t timeout); Set global timeout for menu-hiding in mili-seconds.; Static function. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t ); Process GUI message capture by the main GUI frame (TGLSAFrame). void ToggleEditObject(); Toggle state of the 'Edit Object' menu entry. void ToggleOrthoRotate(); Toggle state of the 'Ortho allow rotate' menu entry. void ToggleOrthoDolly(); Toggle state of the 'Ortho allow dolly' menu entry. TGLSAViewer(const TGLSAViewer& ); non-copyable class. const char* GetName() const; { return ""GLViewer""; }. TGCompositeFrame* GetLeftVerticalFrame() const; { return fLeftVerticalFrame; }. TGLFormat* GetFormat() const; { return fFormat; }. » Author: Richard Maunder / Timur Pocheptsov » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLSAViewer.html:29987,message,message,29987,root/html602/TGLSAViewer.html,https://root.cern,https://root.cern/root/html602/TGLSAViewer.html,2,['message'],['message']
Integrability," GRADIENT CALCULATION IN FCN"");; 3386 Printf("" PARAMETER G(IN FCN) G(MINUIT) DG(MINUIT) AGREEMENT"");; 3387 fISW[2] = 1;; 3388 lnone = kFALSE;; 3389 for (lc = 1; lc <= fNpar; ++lc) {; 3390 i = fNexofi[lc-1];; 3391 const char *cwd = ""GOOD"";; 3392 err = fDgrd[lc-1];; 3393 if (TMath::Abs(fGRADgf[lc-1] - fGrd[lc-1]) > err) {; 3394 cwd = "" BAD"";; 3395 fISW[2] = 0;; 3396 }; 3397 if (fGin[i-1] == fUndefi) {; 3398 cwd = ""NONE"";; 3399 lnone = kTRUE;; 3400 fGRADgf[lc-1] = 0;; 3401 fISW[2] = 0;; 3402 }; 3403 Printf("" %5d %10s%12.4e%12.4e%12.4e %s"",i; 3404 ,(const char*)fCpnam[i-1]; 3405 ,fGRADgf[lc-1],fGrd[lc-1],err,cwd);; 3406 }; 3407 if (lnone) {; 3408 Printf("" AGREEMENT=NONE MEANS FCN DID NOT CALCULATE THE DERIVATIVE"");; 3409 }; 3410 if (fISW[2] == 0) {; 3411 Printf("" MINUIT DOES NOT ACCEPT DERIVATIVE CALCULATIONS BY FCN"");; 3412 Printf("" TO FORCE ACCEPTANCE, ENTER *SET GRAD 1*"");; 3413 }; 3414 ; 3415L2000:; 3416 return;; 3417}; 3418 ; 3419////////////////////////////////////////////////////////////////////////////////; 3420/// interface to Minuit help; 3421 ; 3422void TMinuit::mnhelp(const char *command); 3423{; 3424 TString comd = command;; 3425 mnhelp(comd);; 3426}; 3427 ; 3428////////////////////////////////////////////////////////////////////////////////; 3429/// HELP routine for MINUIT interactive commands; 3430///; 3431/// - COMD ='*' or """" prints a global help for all commands; 3432/// - COMD =Command_name: print detailed help for one command.; 3433/// Note that at least 3 characters must be given for the command; 3434/// name.; 3435///; 3436/// Author: Rene Brun; 3437/// comments extracted from the MINUIT documentation file.; 3438 ; 3439void TMinuit::mnhelp(TString comd); 3440{; 3441//______________________________________________________________________________; 3442//; 3443// Global HELP: Summary of all commands; 3444//; 3445 comd.ToUpper();; 3446 if( comd.Length() == 0 || comd[0] == '*' || comd[0] == '?' || comd[0] == 0 || comd==""HELP"" ) {; 3447 Printf("" ==>List o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:107310,interface,interface,107310,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,2,"['interface', 'rout']","['interface', 'routine']"
Integrability," GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). 	evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GSLIntegrator.html:7636,interface,interface,7636,root/html528/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GSLIntegrator.html,4,['interface'],['interface']
Integrability," GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:7638,interface,interface,7638,root/html534/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html,6,['interface'],['interface']
Integrability," GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFixedProdPdf.html:13339,message,messages,13339,doc/master/classRooFixedProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooFixedProdPdf.html,4,['message'],['messages']
Integrability," GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; TF1 * asTF (const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:15398,message,messages,15398,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,3,['message'],['messages']
Integrability," GenSpec configuration object for efficient generation of multiple datasets from identical specification. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Print multi line detailed information of this RooAbsPdf. ;  ; void printValue (std::ostream &os) const override;  Print value of p.d.f, also print normalization integral that was last used, if any. ;  ; virtual void resetErrorCounters (Int_t resetValue=10);  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; void setGeneratorConfig ();  Remove the specialized numeric MC generator configuration associated with this object. ;  ; void setGeneratorConfig (const RooNumGenConfig &config);  Set the given configuration as default numeric MC generator configuration for this object. ;  ; void setNormRange (const char *rangeName);  ; void setNormRangeOverride (const char *rangeName);  ; void setTraceCounter (Int_t value, bool allNodes=false);  Reset trace counter to given value, limiting the number of future trace messages for this pdf to 'value'. ;  ; RooNumGenConfig * specialGeneratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumGenConfig * specialGeneratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:14481,message,messages,14481,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,12,['message'],['messages']
Integrability," Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsPdf.html:67914,integrat,integrated,67914,root/html530/RooAbsPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html,8,['integrat'],['integrated']
Integrability," GetCharacterUp(Float_t& chupx, Float_t& chupy); Return character up vector. QPaintDevice * GetDoubleBuffer(QPaintDevice* dev); Query the pointer to the dev offscreen buffer if any. Int_t GetDoubleBuffer(Int_t wid); Query the double buffer value for the window wd.; return pointer to the off-screen buffer if any. void GetGeometry(Int_t wid, Int_t& x, Int_t& y, UInt_t& w, UInt_t& h); Returns the global cooordinate of the window ""wd"". const char * DisplayName(const char* = 0); { return ""localhost""; }. ULong_t GetPixel(Color_t cindex); Return pixel value associated to specified ROOT color number.; see: GQTGUI.cxx:QtColor() also. void GetRGB(Int_t index, Float_t& r, Float_t& g, Float_t& b); Get rgb values for color ""index"". const QTextCodec * GetTextDecoder(). Float_t GetTextMagnitude(); {return fTextMagnitude;}. void SetTextMagnitude(Float_t mgn); { fTextMagnitude = mgn;}. void GetTextExtent(UInt_t& w, UInt_t& h, char* mess); Return the size of a character string.; iw : text width; ih : text height; mess : message. Int_t GetFontAscent() const; Returns ascent of the current font (in pixels).; The ascent of a font is the distance from the baseline; to the highest position characters extend to. Int_t GetFontDescent() const; Returns the descent of the current font (in pixels.; The descent is the distance from the base line; to the lowest point characters extend to. Bool_t HasTTFonts() const; {return fUseTTF;}. void MoveWindow(Int_t wid, Int_t x, Int_t y); Move the window wd.; wd : Window identifier.; x : x new window position; y : y new window position. void PutByte(Byte_t b). void QueryPointer(Int_t& ix, Int_t& iy); Query pointer position.; ix : X coordinate of pointer; iy : Y coordinate of pointer. Pixmap_t ReadGIF(Int_t x0, Int_t y0, const char* file, Window_t id = 0); If id is NULL - loads the specified gif file at position [x0,y0] in the; current window. Otherwise creates pixmap from gif file. Int_t RequestLocator(Int_t mode, Int_t ctyp, Int_t& x, Int_t& y); deprecated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGQt.html:33396,message,message,33396,root/html602/TGQt.html,https://root.cern,https://root.cern/root/html602/TGQt.html,4,['message'],['message']
Integrability," GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; namechar name[80]Definition TGX11.cxx:110; kIsReferenced@ kIsReferencedDefinition TObject.h:370; kMustCleanup@ kMustCleanupDefinition TObject.h:368; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; protoconst char * protoDefinition civetweb.c:17535; ROOT::Internal::TParBranchProcessingRAIIDefinition TROOT.h:75; ROOT::Internal::TParBranchProcessingRAII::TParBranchProcessingRAIITParBranchProcessingRAII()Definition TROOT.h:77; ROOT::Internal::TParBranchProcessingRAII::~TParBranchProcessingRAII~TParBranchProcessingRAII()Definition TROOT.h:78; TApplicationThis class creates the ROOT Application Environment that interfaces to the windowing system eventloop...Definition TApplication.h:39; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TCanvasThe Canvas class.Definition TCanvas.h:23; TClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized w...Definition TClassGenerator.h:28; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TCollectionCollection abstract base class.Definition TCollection.h:65; TColorThe color creation and management class.Definition TColor.h:21; TDataTypeBasic data type descriptor (datatype information is obtained from CINT).Definition TDataType.h:44; TDirectoryFile::GetFileTFile * GetFile() const overrideDefinition TDirectoryFile.h:92; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:21730,interface,interfaces,21730,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['interface'],['interfaces']
Integrability," GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; namechar name[80]Definition TGX11.cxx:110; kIsReferenced@ kIsReferencedDefinition TObject.h:370; kMustCleanup@ kMustCleanupDefinition TObject.h:368; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; protoconst char * protoDefinition civetweb.c:17536; ROOT::Internal::TParBranchProcessingRAIIDefinition TROOT.h:75; ROOT::Internal::TParBranchProcessingRAII::TParBranchProcessingRAIITParBranchProcessingRAII()Definition TROOT.h:77; ROOT::Internal::TParBranchProcessingRAII::~TParBranchProcessingRAII~TParBranchProcessingRAII()Definition TROOT.h:78; TApplicationThis class creates the ROOT Application Environment that interfaces to the windowing system eventloop...Definition TApplication.h:39; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TCanvasThe Canvas class.Definition TCanvas.h:23; TClassGeneratorObjects following this interface can be passed onto the TROOT object to implement a user customized w...Definition TClassGenerator.h:28; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TCollectionCollection abstract base class.Definition TCollection.h:65; TColorThe color creation and management class.Definition TColor.h:21; TDataTypeBasic data type descriptor (datatype information is obtained from CINT).Definition TDataType.h:44; TDirectoryFile::GetFileTFile * GetFile() const overrideDefinition TDirectoryFile.h:92; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:21731,interface,interfaces,21731,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['interface'],['interfaces']
Integrability," GetNbinsX() constDefinition TH1.h:297; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TIterDefinition TCollection.h:235; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::AtofDouble_t Atof() constReturn floating-point value contained in string.Definition TString.cxx:2054; TString::IsFloatBool_t IsFloat() constReturns kTRUE if string contains a floating point or integer number.Definition TString.cxx:1858; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsDigitBool_t IsDigit() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:70033,message,message,70033,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,1,['message'],['message']
Integrability," GetOnFileClassVersion() const; {return fOnFileClassVersion;}. Int_t GetType(Int_t id) const; {return fComp[id].fType;}. Double_t GetValue(char* pointer, Int_t i, Int_t j, Int_t len) const; { return GetTypedValue<Double_t>(pointer, i, j, len); }. Double_t GetValueClones(TClonesArray* clones, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueClones<Double_t>(clones, i, j, k, eoffset); }. Double_t GetValueSTL(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTL<Double_t>(cont, i, j, k, eoffset); }. Double_t GetValueSTLP(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTLP<Double_t>(cont, i, j, k, eoffset); }. TVirtualStreamerInfo * NewInfo(TClass* cl); {return new TStreamerInfo(cl);}. Int_t ReadBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t ReadBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t eoffset, Bool_t v7 = kTRUE). void SetCheckSum(UInt_t checksum); {fCheckSum = checksum;}. void SetClass(TClass* cl); {fClass = cl;}. void SetClassVersion(Int_t vers); {fClassVersion=vers;}. void SetOnFileClassVersion(Int_t vers); {fOnFileClassVersion=vers;}. Int_t WriteBuffer(TBuffer& b, char* pointer, Int_t first); Try to remove those functions from the public interface. Int_t WriteBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t WriteBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc). Int_t WriteBufferSTLPtrs(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t first, Int_t eoffset). TStreamerElement * GetCurrentElement(). » Author: Rene Brun 12/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-06-30 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStreamerInfo.html:35443,interface,interface,35443,root/html602/TStreamerInfo.html,https://root.cern,https://root.cern/root/html602/TStreamerInfo.html,2,['interface'],['interface']
Integrability," GetOnFileClassVersion() const; {return fOnFileClassVersion;}. Int_t GetType(Int_t id) const; {return fComp[id].fType;}. Double_t GetValue(char* pointer, Int_t i, Int_t j, Int_t len) const; { return GetTypedValue<Double_t>(pointer, i, j, len); }. Double_t GetValueClones(TClonesArray* clones, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueClones<Double_t>(clones, i, j, k, eoffset); }. Double_t GetValueSTL(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTL<Double_t>(cont, i, j, k, eoffset); }. Double_t GetValueSTLP(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTLP<Double_t>(cont, i, j, k, eoffset); }. TVirtualStreamerInfo * NewInfo(TClass* cl); {return new TStreamerInfo(cl);}. Int_t ReadBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t ReadBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t eoffset, Bool_t v7 = kTRUE). void SetCheckSum(UInt_t checksum); {fCheckSum = checksum;}. void SetClass(TClass* cl); {fClass = cl;}. void SetClassVersion(Int_t vers); {fClassVersion=vers;}. void SetOnFileClassVersion(Int_t vers); {fOnFileClassVersion=vers;}. Int_t WriteBuffer(TBuffer& b, char* pointer, Int_t first); Try to remove those functions from the public interface. Int_t WriteBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t WriteBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc). Int_t WriteBufferSTLPtrs(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t first, Int_t eoffset). TStreamerElement * GetCurrentElement(). » Author: Rene Brun 12/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-07-31 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerInfo.html:29071,interface,interface,29071,root/html534/TStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html,2,['interface'],['interface']
Integrability," GetOnFileClassVersion() const; {return fOnFileClassVersion;}. Int_t GetType(Int_t id) const; {return fComp[id].fType;}. Double_t GetValue(char* pointer, Int_t i, Int_t j, Int_t len) const; { return GetTypedValue<Double_t>(pointer, i, j, len); }. Double_t GetValueClones(TClonesArray* clones, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueClones<Double_t>(clones, i, j, k, eoffset); }. Double_t GetValueSTL(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTL<Double_t>(cont, i, j, k, eoffset); }. Double_t GetValueSTLP(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTLP<Double_t>(cont, i, j, k, eoffset); }. TVirtualStreamerInfo * NewInfo(TClass* cl); {return new TStreamerInfo(cl);}. Int_t ReadBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t ReadBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t eoffset, Bool_t v7 = kTRUE). void SetCheckSum(UInt_t checksum); {fCheckSum = checksum;}. void SetClass(TClass* cl); {fClass = cl;}. void SetClassVersion(Int_t vers); {fClassVersion=vers;}. void SetOnFileClassVersion(Int_t vers); {fOnFileClassVersion=vers;}. Int_t WriteBuffer(TBuffer& b, char* pointer, Int_t first); Try to remove those functions from the public interface. Int_t WriteBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t WriteBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc). Int_t WriteBufferSTLPtrs(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t first, Int_t eoffset). TStreamerElement * GetCurrentElement(). » Author: Rene Brun 12/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-07-31 17:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStreamerInfo.html:35389,interface,interface,35389,root/html604/TStreamerInfo.html,https://root.cern,https://root.cern/root/html604/TStreamerInfo.html,2,['interface'],['interface']
Integrability," GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TH2.h; TH3.h; TStyle.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::generateRooFit::OwningPtr< RooDataSet > generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={})See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,...Definition RooAbsPdf.h:57; RooAbsPdf::createProjectionvirtual RooAbsPdf * createProjection(const RooArgSet &iset)Return a p.d.f that represent a projection of this p.d.f integrated over given observables.Definition RooAbsPdf.cxx:2446; RooAbsReal::createHistogramTH1 * createHistogram(RooStringView varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) constCreate and fill a ROOT histogram TH1, TH2 or TH3 with the values of this function for the variables w...Definition RooAbsReal.cxx:1183; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html:5728,integrat,integrated,5728,doc/master/rf608__fitresultaspdf_8C.html,https://root.cern,https://root.cern/doc/master/rf608__fitresultaspdf_8C.html,1,['integrat'],['integrated']
Integrability," Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; RooProdGenContext Class ReferenceRooFit » RooFit Core. ; Efficient implementation of the generator context specific for RooProdPdf PDFs. ; The sim-context owns a list of component generator contexts that are used to generate the dependents for each component PDF sequentially. ; Definition at line 30 of file RooProdGenContext.h. Public Member Functions;  RooProdGenContext (const RooProdPdf &model, const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool _verbose=false);  ;  ~RooProdGenContext () override;  Destructor. Delete all owned subgenerator contexts. ;  ; void attach (const RooArgSet &params) override;  Attach generator to given event buffer. ;  ; TClass * IsA () const override;  ; void printMultiline (std::ostream &os, Int_t content, bool verbose=false, TString indent="""") const override;  Detailed printing interface. ;  ; void setProtoDataOrder (Int_t *lut) override;  Set the traversal order of the prototype dataset by the given lookup table. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsGenContext;  RooAbsGenContext (const RooAbsPdf &model, const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool _verbose=false);  Constructor. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default contents when printing. ;  ; StyleOption defaultPrintStyle (Option_t *opt) const override;  Define default print style. ;  ; virtual RooDataSet * generate (double nEvents=0, bool skipInit=false, bool extendedMode=false);  Generate the specified number of events with nEvents>0 and and return a dataset containing the genera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdGenContext.html:1152,interface,interface,1152,doc/master/classRooProdGenContext.html,https://root.cern,https://root.cern/doc/master/classRooProdGenContext.html,1,['interface'],['interface']
Integrability," HTML; widget. This might happen because the display has changed, or in; response to an expose event. In all cases, though, this routine; is called by an idle handler. void ScheduleRedraw(); Make sure that a call to the Redraw() routine has been queued. Bool_t HandleIdleEvent(TGIdleHandler* i); Handles idle event. void RedrawArea(int left, int top, int right, int bottom); If any part of the screen needs to be redrawn, then call this routine; with the values of a box (in window coordinates) that needs to be; redrawn. This routine will schedule an idle handler to do the redraw. The box coordinates are relative to the clipping window (fCanvas). void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw region defined by [x,y] [w,h]. Bool_t ItemLayout(); Layout html widget. void RedrawBlock(TGHtmlBlock* p); Redraw the TGHtmlBlock given. void RedrawEverything(); Call this routine to force the entire widget to be redrawn. void RedrawText(int y); Call this routine to cause all of the rendered HTML at the; virtual canvas coordinate of Y and beyond to be redrawn. void HClear(); Erase all data from the HTML widget. Bring it back to an empty screen. Bool_t HandleTimer(TTimer* timer); Handle timer event. void FlashCursor(); Flash the insertion cursor. GContext_t GetGC(int color, int font); Return a GC from the cache. As many as N_CACHE_GCs are kept valid; at any one time. They are replaced using an LRU algorithm. A value of FONT_Any (-1) for the font means ""don't care"". GContext_t GetAnyGC(); Retrieve any valid GC. The font and color don't matter since the; GC will only be used for copying. Bool_t HandleFocusChange(Event_t* event); Handle focus change event. TGHtmlInput * GetInputElement(int x, int y); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. Bool_t HandleHtmlInput(TGHtmlInput* pr, Event_t* event); Handle html input (button, chec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGHtml.html:34575,rout,routine,34575,root/html528/TGHtml.html,https://root.cern,https://root.cern/root/html528/TGHtml.html,10,['rout'],['routine']
Integrability," Here are the classes, structs, unions and interfaces with brief descriptions:; [detail level 123456];  ►NBidirMMapPipe_implNamespace for implementation details of BidirMMapPipe ;  CPageChunkClass representing a chunk of pages ;  ►CPagesHandle class for a number of Pages ;  CimplImplementation ;  ►NMemstat;  CSCustomDigest;  CSFind_t;  CTMemStatFAddrContainer;  CTMemStatMng;  CToLower_t;  ►NPyROOT;  ►CMethodProxy;  CMethodInfo_t;  CObjectProxy;  CPropertyProxy;  CPyCallable;  CPyGILRAII;  CPyRootClassType object to hold TClassRef instance (this is only semantically a presentation of PyRootType instances, not in a C++ sense) ;  CTCallContext;  CTClassMethodHolder;  CTConstructorHolder;  CTConverter;  CTCppObjectArrayConverter;  CTCppObjectArrayExecutor;  CTCppObjectBySmartPtrExecutor;  CTCppObjectBySmartPtrPtrExecutor;  CTCppObjectBySmartPtrRefExecutor;  CTCppObjectByValueExecutor;  CTCppObjectConverter;  CTCppObjectExecutor;  CTCppObjectPtrConverter;  CTCppObjectPtrPtrExecutor;  CTCppObjectPtrRefExecutor;  CTCppObjectRefExecutor;  CTCStringConverter;  CTemplateProxyTemplate proxy object to return functions and methods ;  CTExecutor;  CTFunctionHolder;  CTLongLongArrayConverter;  CTMemoryRegulator;  CTMethodHolder;  CTNonConstCStringConverter;  CTNonConstUCStringConverter;  CTNotImplementedConverter;  ►CTParameter;  CValue;  CTPyBufferFactoryFactory for python buffers of non-string type ;  CTPyException;  CTPyROOTApplication;  CTRefCppObjectConverter;  CTRefExecutor;  CTSetItemHolder;  CTSmartPtrCppObjectConverter;  CTSTLIteratorConverter;  CTStrictCppObjectConverter;  CTValueCppObjectConverter;  CTVoidArrayConverter;  CTVoidConverter;  CTVoidPtrPtrConverter;  CTVoidPtrRefConverter;  ►NRcppThis is a class to support deprecated method to pass function to R's Environment, based in Rcpp::InternalFunction ;  ►Ntraits;  CExporter< std::array< T, i > >;  ►NRgl;  ►NFgt;  CTKDEAdapter;  ►NMc;  CTCell;  CTDef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:112,interface,interfaces,112,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,2,['interface'],['interfaces']
Integrability," Here are the classes, structs, unions and interfaces with brief descriptions:; [detail level 123456];  ►NBidirMMapPipe_implNamespace for implementation details of BidirMMapPipe ;  CPageChunkClass representing a chunk of pages ;  ►CPagesHandle class for a number of Pages ;  CimplImplementation ;  ►NclingPrint a TSeq at the prompt: ;  ►Nutils;  ►NMemstat;  CSCustomDigest;  CSFind_t;  CTMemStatFAddrContainer;  CTMemStatMng;  CToLower_t;  ►NPyROOT;  ►CMethodProxy;  CMethodInfo_t;  CObjectProxy;  CPropertyProxy;  CPyCallable;  CPyGILRAII;  CPyRootClassType object to hold TClassRef instance (this is only semantically a presentation of PyRootType instances, not in a C++ sense) ;  CTCallContext;  CTClassMethodHolder;  CTConstructorHolder;  CTConverter;  CTCppObjectArrayConverter;  CTCppObjectArrayExecutor;  CTCppObjectBySmartPtrExecutor;  CTCppObjectBySmartPtrPtrExecutor;  CTCppObjectBySmartPtrRefExecutor;  CTCppObjectByValueExecutor;  CTCppObjectConverter;  CTCppObjectExecutor;  CTCppObjectPtrConverter;  CTCppObjectPtrPtrExecutor;  CTCppObjectPtrRefExecutor;  CTCppObjectRefExecutor;  CTCStringConverter;  CTemplateProxyTemplate proxy object to return functions and methods ;  CTExecutor;  CTFunctionHolder;  CTLongLongArrayConverter;  CTMemoryRegulator;  CTMethodHolder;  CTNonConstCStringConverter;  CTNonConstUCStringConverter;  CTNotImplementedConverter;  ►CTParameter;  CValue;  CTPyBufferFactoryFactory for python buffers of non-string type ;  CTPyException;  CTPyROOTApplication;  CTRefCppObjectConverter;  CTRefExecutor;  CTSetItemHolder;  CTSmartPtrCppObjectConverter;  CTSTLIteratorConverter;  CTStrictCppObjectConverter;  CTValueCppObjectConverter;  CTVoidArrayConverter;  CTVoidConverter;  CTVoidPtrPtrConverter;  CTVoidPtrRefConverter;  ►NRgl;  ►NFgt;  CTKDEAdapter;  ►NMc;  CTCell;  CTDefaultSplitter;  CTF3Adapter;  CTF3EdgeSplitter;  CTGridGeometry;  CTH3Adapter;  CTIsoMesh;  CTMeshBuilder;  CTSlice;  CTS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:112,interface,interfaces,112,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['interface'],['interfaces']
Integrability," Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TMultiDimFit. class TMultiDimFit: public TNamed. /*. Multidimensional Fits in ROOT. Overview. A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable. An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; least squares fitting procedure applied to a representive; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:1113,depend,dependence,1113,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,4,['depend'],['dependence']
Integrability," Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::CCTreeWrapper. class TMVA::CCTreeWrapper. Function Members (Methods); public:. ~CCTreeWrapper(); TMVA::CCTreeWrapperCCTreeWrapper(const TMVA::CCTreeWrapper&); TMVA::CCTreeWrapperCCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); Double_tCheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); TMVA::CCTreeWrapper::CCTreeNode*GetRoot(); voidInitTree(TMVA::CCTreeWrapper::CCTreeNode* t); TMVA::CCTreeWrapper&operator=(const TMVA::CCTreeWrapper&); voidPruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); Double_tTestTreeQuality(const TMVA::CCTreeWrapper::EventList* validationSample); Double_tTestTreeQuality(const TMVA::DataSet* validationSample). Data Members; private:. TMVA::DecisionTree*fDTParent! pointer to underlying DecisionTree; TMVA::SeparationBase*fQualityIndex! pointer to the used quality index calculator; TMVA::CCTreeWrapper::CCTreeNode*fRoot! the root node of the (wrapped) decision Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); constructor. ~CCTreeWrapper(); destructor. void InitTree(TMVA::CCTreeWrapper::CCTreeNode* t); initialize the node t and all its descendants. void PruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); remove the branch rooted at node t. Double_t TestTreeQuality( const EventList* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using an EventList. Double_t TestTreeQuality( const DataSet* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using the DataSet. Double_t CheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); return the decision tree output for an event. CCTreeWrapper(TMVA::DecisionTree* T, TMVA::S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__CCTreeWrapper.html:1164,wrap,wrapped,1164,root/html604/TMVA__CCTreeWrapper.html,https://root.cern,https://root.cern/root/html604/TMVA__CCTreeWrapper.html,2,['wrap'],['wrapped']
Integrability," Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOSTATS; » RooStats::CombinedCalculator. class RooStats::CombinedCalculator: public RooStats::IntervalCalculator, public RooStats::HypoTestCalculator. CombinedCalculator is an interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals. ; The interface currently assumes that any such calculator can be configured by specifying:. a model common model (eg. a family of specific models which includes both the null and alternate),; a data set, ; a set of parameters of which specify the null (including values and const/non-const status), ; a set of parameters of which specify the alternate (including values and const/non-const status),; a set of parameters of nuisance parameters (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface also allows one to pass the model, data, and parameters without a workspace (which is created internally). After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer). The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~CombinedCalculator(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__CombinedCalculator.html:998,interface,interface,998,root/html526/RooStats__CombinedCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__CombinedCalculator.html,1,['interface'],['interface']
Integrability," ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceProperty(Double_t qqa, Double_t qqd, Double_t qqs, Int_t nnqs, Int_t& irep); Set surface property coefficients. Input: QQA - diffusion coefficient for diffused light [0.,1.]; QQD - diffusion coefficient for direct light [0.,1.]; QQS - diffusion coefficient for reflected light [0.,1.]; NNCS - power coefficient for reflected light (.GE.1). --; Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi); --. Output: IREP - reply : 0 - O.K.; -1 - error in cooefficients. void ImplicitFunction(Double_t* rmin, Double_t* rmax, Int_t nx, Int_t ny, Int_t nz, const char* chopt); Draw implicit function FUN(X,Y,Z) = 0 in cartesian coordinates using; hidden surface removal algorithm ""Painter"". Input: FUN - external routine FUN(X,Y,Z); RMIN(3) - min scope coordinates; RMAX(3) - max scope coordinates; NX - number of steps along X; NY - number of steps along Y; NZ - number of steps along Z. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - 1; ICODES(2) - 1; ICODES(3) - 1; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function (lightness). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void MarchingCube(Double_t fiso, Double_t** p, Double_t* f, Double_t** g, Int_t& nnod, Int_t& ntria, Double_t** xyz, Double_t** grad, Int_t** itria); Topological decider for ""Marching Cubes"" algorithm Find set of triangles; aproximating the isosurface F(x,y,z)=Fiso inside the cube; (improved version). Input: FISO - function value for isosurface; P(3,8) - cube vertexes; F(8) - function values at the vertexes; G(3,8) - function gradients at the vertexes. Output: NNOD - number of nodes (maximum 13); NTRIA - number of triangles (maximum 12); XYZ(3,*) - nodes; GRAD(3,*) - node normales (not norm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPainter3dAlgorithms.html:33090,rout,routine,33090,root/html528/TPainter3dAlgorithms.html,https://root.cern,https://root.cern/root/html528/TPainter3dAlgorithms.html,6,['rout'],['routine']
Integrability," ICODES(2) - IB; XYZ(3,*) - coordinates of nodes; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void SurfaceProperty(Double_t qqa, Double_t qqd, Double_t qqs, Int_t nnqs, Int_t& irep); Set surface property coefficients. Input: QQA - diffusion coefficient for diffused light [0.,1.]; QQD - diffusion coefficient for direct light [0.,1.]; QQS - diffusion coefficient for reflected light [0.,1.]; NNCS - power coefficient for reflected light (.GE.1). --; Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi); --. Output: IREP - reply : 0 - O.K.; -1 - error in cooefficients. void ImplicitFunction(Double_t* rmin, Double_t* rmax, Int_t nx, Int_t ny, Int_t nz, const char* chopt); Draw implicit function FUN(X,Y,Z) = 0 in cartesian coordinates using; hidden surface removal algorithm ""Painter"". Input: FUN - external routine FUN(X,Y,Z); RMIN(3) - min scope coordinates; RMAX(3) - max scope coordinates; NX - number of steps along X; NY - number of steps along Y; NZ - number of steps along Z. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; ICODES(1) - 1; ICODES(2) - 1; ICODES(3) - 1; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function (lightness). CHOPT - options: 'BF' - from BACK to FRONT; 'FB' - from FRONT to BACK. void MarchingCube(Double_t fiso, Double_t[8][3] p, Double_t[8] f, Double_t[8][3] g, Int_t& nnod, Int_t& ntria, Double_t[][3] xyz, Double_t[][3] grad, Int_t[][3] itria); Topological decider for ""Marching Cubes"" algorithm Find set of triangles; aproximating the isosurface F(x,y,z)=Fiso inside the cube; (improved version). Input: FISO - function value for isosurface; P(3,8) - cube vertexes; F(8) - function values at the vertexes; G(3,8) - function gradients at the vertexes. Output: NNOD - number of nodes (maximum 13); NTRIA - number of triangles (maximum 12); XYZ(3,*) - nodes; GRAD(3,*) - node",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPainter3dAlgorithms.html:34296,rout,routine,34296,root/html602/TPainter3dAlgorithms.html,https://root.cern,https://root.cern/root/html602/TPainter3dAlgorithms.html,4,['rout'],['routine']
Integrability," If the denominator is equal to 0, an efficiency of 0 is returned.; When \( passed + \alpha < 1 \) or \( total - passed + \beta < 1 \) the above formula for the mode is not valid. In these cases values the estimated efficiency is 0 or 1. . Definition at line 2681 of file TEfficiency.cxx. ◆ GetEfficiencyErrorLow(). Double_t TEfficiency::GetEfficiencyErrorLow ; (; Int_t ; bin); const. Returns the lower error on the efficiency in the given global bin. ; The result depends on the current confidence level fConfLevel and the chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for more details.; Note: If the histograms are filled with weights, only bayesian methods and the normal approximation are supported. ; Definition at line 2732 of file TEfficiency.cxx. ◆ GetEfficiencyErrorUp(). Double_t TEfficiency::GetEfficiencyErrorUp ; (; Int_t ; bin); const. Returns the upper error on the efficiency in the given global bin. ; The result depends on the current confidence level fConfLevel and the chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for more details.; Note: If the histograms are filled with weights, only bayesian methods and the normal approximation are supported. ; Definition at line 2812 of file TEfficiency.cxx. ◆ GetGlobalBin(). Int_t TEfficiency::GetGlobalBin ; (; Int_t ; binx, . Int_t ; biny = 0, . Int_t ; binz = 0 . ); const. Returns the global bin number which can be used as argument for the following functions: . GetEfficiency(bin), GetEfficiencyErrorLow(bin), GetEfficiencyErrorUp(bin); SetPassedEvents(bin), SetTotalEvents(bin). see TH1::GetBin() for conventions on numbering bins ; Definition at line 2890 of file TEfficiency.cxx. ◆ GetListOfFunctions(). TList * TEfficiency::GetListOfFunctions ; (; ). Definition at line 2897 of file TEfficiency.cxx. ◆ GetPaintedGraph(). TGraphAsymmErrors * TEfficiency::GetPaintedGraph ; (; ); const. inline . Definition at line 121 of file TEfficiency.h. ◆ GetPaintedGraph2D(). TGraph2DAsy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEfficiency.html:97355,depend,depends,97355,doc/master/classTEfficiency.html,https://root.cern,https://root.cern/doc/master/classTEfficiency.html,1,['depend'],['depends']
Integrability," If the interpreter encounters Name, check whether that is an object ROOT could retrieve. ; To not re-read objects from disk, cache the name/object pair for a given LookupCtx. ; Definition at line 7714 of file TCling.cxx. ◆ GetPrompt(). char * TCling::GetPrompt ; (; ). inlinefinalvirtual . Implements TInterpreter.; Definition at line 217 of file TCling.h. ◆ GetRootMapFiles(). TObjArray * TCling::GetRootMapFiles ; (; ); const. inlinefinalvirtual . Implements TInterpreter.; Definition at line 223 of file TCling.h. ◆ GetSecurityError(). int TCling::GetSecurityError ; (; ); const. finalvirtual . Interface to cling function. ; Reimplemented from TInterpreter.; Definition at line 7487 of file TCling.cxx. ◆ GetSharedLibDeps(). const char * TCling::GetSharedLibDeps ; (; const char * ; lib, . bool ; useDyld = false . ). finalvirtual . Get the list a libraries on which the specified lib depends. ; The returned string contains as first element the lib itself. Returns 0 in case the lib does not exist or does not have any dependencies. If useDyld is true, we iterate through all available libraries and try to construct the dependency chain by resolving each symbol. ; Implements TInterpreter.; Definition at line 7289 of file TCling.cxx. ◆ GetSharedLibs(). const char * TCling::GetSharedLibs ; (; ). finalvirtual . Return the list of shared libraries loaded into the process. ; Implements TInterpreter.; Definition at line 6989 of file TCling.cxx. ◆ GetSTLIncludePath(). const char * TCling::GetSTLIncludePath ; (; ); const. finalvirtual . Return the directory containing CINT's stl cintdlls. ; Reimplemented from TInterpreter.; Definition at line 7401 of file TCling.cxx. ◆ GetTopLevelMacroName(). const char * TCling::GetTopLevelMacroName ; (; ); const. finalvirtual . Return the file name of the current un-included interpreted file. ; See the documentation for GetCurrentMacroName(). ; Reimplemented from TInterpreter.; Definition at line 5416 of file TCling.cxx. ◆ GetUsingNamespaces(). std:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:105222,depend,dependencies,105222,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['depend'],['dependencies']
Integrability," In case Book is called without specifying column types as template arguments, corresponding typed code will be just-in-time compiled by RDataFrame. In that case the Helper class needs to be known to the ROOT interpreter.; This action is lazy: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr. Examples; See this tutorial for an example implementation of an action helper.; It is also possible to inspect the code used by built-in RDataFrame actions at ActionHelpers.hxx. ; Definition at line 2984 of file RInterface.hxx. ◆ Cache() [1/4]. template<typename Proxied , typename DataSource = void> . template<typename... ColumnTypes> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::Cache ; (; const ColumnNames_t & ; columnList). inline . Save selected columns in memory. ; Template Parameters. ColumnTypesvariadic list of branch/column types. . Parameters. [in]columnListcolumns to be cached in memory. . Returnsa RDataFrame that wraps the cached dataset.; This action returns a new RDataFrame object, completely detached from the originating RDataFrame. The new dataframe only contains the cached columns and stores their content in memory for fast, zero-copy subsequent access.; Use Cache if you know you will only need a subset of the (Filtered) data that fits in memory and that will be accessed many times.; NoteCache will refuse to process columns with names of the form #columnname. These are special columns made available by some data sources (e.g. RNTupleDS) that represent the size of column columnname, and are not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an Alias(): df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""}). Example usage:; Types and columns specified: auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; double; Types inferred and columns specified (this invocation relies on jitting): auto cache_some_co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:42143,wrap,wraps,42143,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['wrap'],['wraps']
Integrability," In case the maximum function called is reached the algorithm will stop earlier without having reached the desired accuracy; [out]relerrContains, on exit, an estimation of the relative accuracy of the result. ; [out]nfnevlnumber of function evaluations performed. ; [out]ifail0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the specified value of maxpts.; 3 n<2 or n>15 . Method:; The default method used is the Genz-Mallik adaptive multidimensional algorithm using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator() to different integrators. Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class Possible methods are : Vegas, Miser or Plain IN case of MC integration the accuracy is determined by the number of function calls, one should be careful not to use a too large value of maxpts ; Definition at line 2851 of file TF1.cxx. ◆ IntegralMultiple() [3/3]. virtual Double_t TF1::IntegralMultiple ; (; Int_t ; n, . const Double_t * ; a, . const Double_t * ; b, . Int_t ; , . Int_t ; maxpts, . Double_t ; epsrel, . Double_t & ; relerr, . Int_t & ; nfnevl, . Int_t & ; ifail . ). inlinevirtual . Definition at line 616 of file TF1.h. ◆ IntegralOneDim(). Double_t TF1::IntegralOneDim ; (; Double_t ; a, . Double_t ; b, . Double_t ; epsrel, . Double_t ; epsabs, . Double_t & ; error . ). virtual . Return Integral of function between a and b using the given parameter values and relative and absolute tolerance. ; The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used If ROOT contains the MathMore library the default integrator is set to be the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:100654,integrat,integrators,100654,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,3,['integrat'],"['integration', 'integrators']"
Integrability," Includes; Libraries. Function documentation; RooNumIntFactory(); Constructor. Register all known integrators by calling; their static registration functions. ~RooNumIntFactory(); Destructor. RooNumIntFactory(const RooNumIntFactory& other); Copy constructor. RooNumIntFactory& instance(); Static method returning reference to singleton instance of factory. void cleanup(); Cleanup routine called by atexit() handler installed by RooSentinel. Bool_t storeProtoIntegrator(RooAbsIntegrator* proto, const RooArgSet& defConfig, const char* depName = """"); Method accepting registration of a prototype numeric integrator along with a RooArgSet of its; default configuration options and an optional list of names of other numeric integrators; on which this integrator depends. Returns true if integrator was previously registered. const RooAbsIntegrator* getProtoIntegrator(const char* name); Return prototype integrator with given (class) name. const char* getDepIntegratorName(const char* name); Get list of class names of integrators needed by integrator named 'name'. RooAbsIntegrator* createIntegrator(RooAbsFunc& func, const RooNumIntConfig& config, Int_t ndim = 0, Bool_t isBinned = kFALSE); Construct a numeric integrator instance that operates on function 'func' and is configured; with 'config'. If ndimPreset is greater than zero that number is taken as the dimensionality; of the integration, otherwise it is queried from 'func'. This function iterators over list; of available prototype integrators and returns an clone attached to the given function of; the first class that matches the specifications of the requested integration considering; the number of dimensions, the nature of the limits (open ended vs closed) and the user; preference stated in 'config'. » Last changed: Tue Jun 2 15:32:45 2015 » Last generated: 2015-06-02 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooNumIntFactory.html:7629,integrat,integrators,7629,root/html604/RooNumIntFactory.html,https://root.cern,https://root.cern/root/html604/RooNumIntFactory.html,12,['integrat'],"['integration', 'integrator', 'integrators']"
Integrability," Includes; Libraries. Function documentation; RooNumIntFactory(); Constructor. Register all known integrators by calling; their static registration functions. ~RooNumIntFactory(); Destructor. RooNumIntFactory(const RooNumIntFactory& other); Copy constructor. RooNumIntFactory& instance(); Static method returning reference to singleton instance of factory. void cleanup(); Cleanup routine called by atexit() handler installed by RooSentinel. Bool_t storeProtoIntegrator(RooAbsIntegrator* proto, const RooArgSet& defConfig, const char* depName = """"); Method accepting registration of a prototype numeric integrator along with a RooArgSet of its; default configuration options and an optional list of names of other numeric integrators; on which this integrator depends. Returns true if integrator was previously registered. const RooAbsIntegrator* getProtoIntegrator(const char* name); Return prototype integrator with given (class) name. const char* getDepIntegratorName(const char* name); Get list of class names of integrators needed by integrator named 'name'. RooAbsIntegrator* createIntegrator(RooAbsFunc& func, const RooNumIntConfig& config, Int_t ndim = 0, Bool_t isBinned = kFALSE); Construct a numeric integrator instance that operates on function 'func' and is configured; with 'config'. If ndimPreset is greater than zero that number is taken as the dimensionality; of the integration, otherwise it is queried from 'func'. This function iterators over list; of available prototype integrators and returns an clone attached to the given function of; the first class that matches the specifications of the requested integration considering; the number of dimensions, the nature of the limits (open ended vs closed) and the user; preference stated in 'config'. » Last changed: Tue Jun 30 14:34:40 2015 » Last generated: 2015-06-30 14:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumIntFactory.html:7629,integrat,integrators,7629,root/html602/RooNumIntFactory.html,https://root.cern,https://root.cern/root/html602/RooNumIntFactory.html,4,['integrat'],"['integrator', 'integrators']"
Integrability," Includes; Libraries. Function documentation; RooNumIntFactory(); Constructor. Register all known integrators by calling; their static registration functions. ~RooNumIntFactory(); Destructor. RooNumIntFactory(const RooNumIntFactory& other); Copy constructor. RooNumIntFactory& instance(); Static method returning reference to singleton instance of factory. void cleanup(); Cleanup routine called by atexit() handler installed by RooSentinel. Bool_t storeProtoIntegrator(RooAbsIntegrator* proto, const RooArgSet& defConfig, const char* depName = """"); Method accepting registration of a prototype numeric integrator along with a RooArgSet of its; default configuration options and an optional list of names of other numeric integrators; on which this integrator depends. Returns true if integrator was previously registered. const RooAbsIntegrator* getProtoIntegrator(const char* name); Return prototype integrator with given (class) name. const char* getDepIntegratorName(const char* name); Get list of class names of integrators needed by integrator named 'name'. RooAbsIntegrator* createIntegrator(RooAbsFunc& func, const RooNumIntConfig& config, Int_t ndim = 0, Bool_t isBinned = kFALSE); Construct a numeric integrator instance that operates on function 'func' and is configured; with 'config'. If ndimPreset is greater than zero that number is taken as the dimensionality; of the integration, otherwise it is queried from 'func'. This function iterators over list; of available prototype integrators and returns an clone attached to the given function of; the first class that matches the specifications of the requested integration considering; the number of dimensions, the nature of the limits (open ended vs closed) and the user; preference stated in 'config'. » Last changed: Tue Mar 10 17:18:17 2015 » Last generated: 2015-03-10 17:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumIntFactory.html:7183,integrat,integrators,7183,root/html534/RooNumIntFactory.html,https://root.cern,https://root.cern/root/html534/RooNumIntFactory.html,4,['integrat'],"['integrator', 'integrators']"
Integrability," Includes; Libraries. Function documentation; void cleanup(); Clear memoery pool on exit to avoid reported memory leaks. void* operator new(size_t bytes); Overloaded new operator guarantees that all RooArgSets allocated with new; have a unique address, a property that is exploited in several places; in roofit to quickly index contents on normalization set pointers.; The memory pool only allocates space for the class itself. The elements; stored in the set are stored outside the pool. void* operator new(size_t bytes, void* ptr); Overloaded new operator with placement does not guarante that all; RooArgSets allocated with new have a unique address, but uses the global; operator. void operator delete(void* ptr); Memory is owned by pool, we need to do nothing to release it. RooArgSet(); Default constructor. RooArgSet(const RooArgList& list); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const RooArgList& list, const RooAbsArg* var1); Constructor from a RooArgList. If the list contains multiple; objects with the same name, only the first is store in the set.; Warning messages will be printed for dropped items. RooArgSet(const char* name); Empty set constructor. RooArgSet(const RooArgSet& set1, const RooArgSet& set2, const char* name = """"); Construct a set from two existing sets. RooArgSet(const RooAbsArg& var1, const char* name = """"); Constructor for set containing 1 initial object. RooArgSet(const RooAbsArg& var1, const RooAbsArg& var2, const char* name = """"); Constructor for set containing 2 initial objects. RooArgSet(const RooAbsArg& var1, const RooAbsArg& var2, const RooAbsArg& var3, const char* name = """"); Constructor for set containing 3 initial objects. RooArgSet(const RooAbsArg& var1, const RooAbsArg& var2, const RooAbsArg& var3, const RooAbsArg& var4, const char* name = """"); Constructor for set containing 4 initial objects.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooArgSet.html:16466,message,messages,16466,root/html602/RooArgSet.html,https://root.cern,https://root.cern/root/html602/RooArgSet.html,4,['message'],['messages']
Integrability," Inferred if not present. . Parameters. [in]modelThe returned histogram will be constructed using this as a model. ; [in]v1NameThe name of the column that will fill the x axis. ; [in]v2NameThe name of the column that will fill the y axis. ; [in]v3NameThe name of the column that will fill the z axis. . Returnsthe tridimensional histogram wrapped in a RResultPtr.; This action is lazy: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr. Example usage:; // Deduce column types (this invocation needs jitting internally); auto myHist1 = myDf.Histo3D({""name"", ""title"", 64u, 0., 128., 32u, -4., 4., 8u, -2., 2.},; ""myValueX"", ""myValueY"", ""myValueZ"");; // Explicit column types; auto myHist2 = myDf.Histo3D<double, double, float>({""name"", ""title"", 64u, 0., 128., 32u, -4., 4., 8u, -2., 2.},; ""myValueX"", ""myValueY"", ""myValueZ"");; NoteDifferently from other ROOT interfaces, the returned histogram is not associated to gDirectory and the caller is responsible for its lifetime (in particular, a typical source of confusion is that if result histograms go out of scope before the end of the program, ROOT might display a blank canvas). ; Definition at line 2049 of file RInterface.hxx. ◆ HistoND() [1/2]. template<typename Proxied , typename DataSource = void> . template<typename FirstColumn , typename... OtherColumns> . RResultPtr<::THnD > ROOT::RDF::RInterface< Proxied, DataSource >::HistoND ; (; const THnDModel & ; model, . const ColumnNames_t & ; columnList . ). inline . Fill and return an N-dimensional histogram (lazy action). ; Template Parameters. FirstColumnThe first type of the column the values of which are used to fill the object. Inferred if not present. ; OtherColumnsA list of the other types of the columns the values of which are used to fill the object. . Parameters. [in]modelThe returned histogram will be constructed using this as a model. ; [in]columnListA list containing the names of the columns that will be passed when calling Fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:96948,interface,interfaces,96948,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['interface'],['interfaces']
Integrability," Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMultiDimFit(); Empty CTOR. Do not use. TMultiDimFit(Int_t dimension, TMultiDimFit::EMDFPolyType type = kMonomials, Option_t* option = """"); Constructor; Second argument is the type of polynomials to use in; parameterisation, one of:; TMultiDimFit::kMonomials; TMultiDimFit::kChebyshev; TMultiDimFit::kLegendre. Options:; K Compute (k)correlation matrix; V Be verbose. Default is no options. ~TMultiDimFit(); Destructor. void AddRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the training sample to be used for the; parameterization.; The mean of the variables and quantity is calculated on the fly,; as outlined in TPrincipal::AddRow.; This sample should be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void AddTestRow(const Double_t* x, Double_t D, Double_t E = 0); Add a row consisting of fNVariables independent variables, the; known, dependent quantity, and optionally, the square error in; the dependent quantity, to the test sample to be used for the; test of the parameterization.; This sample needn't be representive of the problem at hand.; Please note, that if no error is given Poisson statistics is; assumed and the square error is set to the value of dependent; quantity. See also the; class description. void Browse(TBrowser* b); Browse the TMultiDimFit object in the TBrowser. void Clear(Option_t* option = """"); Clear internal structures and variables. Double_t Eval(const Double_t* x, const Double_t* coeff = 0) const; Evaluate parameterization at point x. Optional argument coeff is; a vector of coefficients for the parameterisation, fNCoefficients; elements long. Double_t EvalError",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiDimFit.html:25926,depend,dependent,25926,root/html528/TMultiDimFit.html,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html,10,['depend'],['dependent']
Integrability," Initial values of parameters for an exponential. void InitPolynom(Double_t xmin = 0, Double_t xmax = 0); Compute Initial values of parameters for a polynom. Int_t InsertPoint(); Insert a new point at the mouse position. Double_t Integral(Int_t first = 0, Int_t last = -1) const; Integrate the TGraph data within a given (index) range; Note that this function computes the area of the polygon enclosed by the points of the TGraph.; The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon,; since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point; with the first one. It is clear that the order of the point is essential in defining the polygon.; Also note that the segments should not intersect. NB: if last=-1 (default) last is set to the last point.; if (first <0) the first point (0) is taken. Method:; There are many ways to calculate the surface of a polygon. It all depends on what kind of data; you have to deal with. The most evident solution would be to divide the polygon in triangles and; calculate the surface of them. But this can quickly become complicated as you will have to test; every segments of every triangles and check if they are intersecting with a current polygon's; segment or if it goes outside the polygon. Many calculations that would lead to many problems...; The solution (implemented by R.Brun); Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; segments don't intersect.; It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next; vertex. Then it subtracts from it the result of the y coordinate of the current vertex multiplied; by the x coordinate of the next vertex. Then divide the result by 2 to get the surface/area.; Sources; http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html; http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraph.html:36085,depend,depends,36085,root/html534/TGraph.html,https://root.cern,https://root.cern/root/html534/TGraph.html,6,['depend'],['depends']
Integrability," Inline; Add trivial get or setters directly in the class definition. This improves reading time since one does not have to look for it somewhere else. Add more complex inlines (longer than one line) at the bottom of the .h file. Creating separate .icc files increases the build time, the complexity of the build system and, more importantly, increases the number of files one possibly has to scan to find a piece of code.; Declaration Order; In the class definition we first declare all private data members, followed by the private static members, the private methods and the private static methods. Then the protected members and methods and finally the public methods (no public data members). We put private members first since that is the language default and it gives the developer a quick view on what data members are used in a class.; Avoid raw C types; Avoid the use of raw C types like int, long, float, double when using data that might be written to disk. For example, the sizes of int and long are machine dependent. On 32 bit machines ints and longs are 32 bits, but on 64 bit processors an int can be either 32 or 64 bits and a long 64 bits, depending on the processor. For portability reasons and consistent numerical results use the typedefs provided by ROOT's Rtypes.h for the basic raw C types. E.g.: Double_t, Float_t, Int_t etc.; Exception handling; Don't let every method throw an exception when a simple error return code is often enough.; Namespaces; In ROOT 5 all classes are in the ROOT namespace. Some packages will be in a sub-namespace, e.g. ROOT::Reflex. For backward compatibility with the previous versions of ROOT, where all classes were in the global namespace, we have by default using namespace ROOT; in all headers. However, this can be turned off by defining the USE_ROOT_NAMESPACE macro.; Using comments to document the code; ROOT chose Doxygen for its code documentation: please refer to this how-to for all the details.; Source file layout; Each source file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/coding-conventions.html:4230,depend,dependent,4230,d/coding-conventions.html,https://root.cern,https://root.cern/d/coding-conventions.html,1,['depend'],['dependent']
Integrability," Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *method) const;  Use this method to signal that a method (defined in a base class) may not be called in a derived class (in principle against good design since a child class should not provide less functionality than its parent, however, sometimes it is necessary). ;  ; virtual Bool_t Notify ();  This method must be o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAxis3D.html:11145,message,message,11145,doc/master/classTAxis3D.html,https://root.cern,https://root.cern/doc/master/classTAxis3D.html,3,['message'],['message']
Integrability," Int_t *ipd, Int_t *flag, const Int_t iovflo, Int_t &ncmpa, const Double_t fratio);  Help routine for pivoting setup. ;  ; static void InitPivot_sub2a (const Int_t n, Int_t *ipe, Int_t *iw, const Int_t lw, Int_t &iwfr, Int_t &ncmpa);  Help routine for pivoting setup. ;  ; static void InitPivot_sub3 (const Int_t n, const Int_t nz, Int_t *irn, Int_t *icn, Int_t *perm, Int_t *iw, Int_t *ipe, Int_t *iq, Int_t *flag, Int_t &iwfr, Int_t *icntl, Int_t *info);  Help routine for pivoting setup. ;  ; static void InitPivot_sub4 (const Int_t n, Int_t *ipe, Int_t *iw, const Int_t lw, Int_t &iwfr, Int_t *ips, Int_t *ipv, Int_t *nv, Int_t *flag, Int_t &ncmpa);  Help routine for pivoting setup. ;  ; static void InitPivot_sub5 (const Int_t n, Int_t *ipe, Int_t *nv, Int_t *ips, Int_t *ne, Int_t *na, Int_t *nd, Int_t &nsteps, const Int_t nemin);  Help routine for pivoting setup. ;  ; static void InitPivot_sub6 (const Int_t n, const Int_t nz, Int_t *irn, Int_t *icn, Int_t *perm, Int_t *na, Int_t *ne, Int_t *nd, const Int_t nsteps, Int_t *lstki, Int_t *lstkr, Int_t *iw, Int_t *info, Double_t &ops);  Help routine for pivoting setup. ;  ; static Int_t NonZerosUpperTriang (const TMatrixDSparse &a);  Static function, returning the number of non-zero entries in the upper triangular matrix . ;  ; static void Solve (const Int_t n, TArrayD &Aa, TArrayI &Aiw, TArrayD &Aw, const Int_t maxfrt, TVectorD &b, TArrayI &Aiw1, const Int_t nsteps, Int_t *icntl, Int_t *info);  Main routine for solving Ax=b. ;  ; static void Solve_sub1 (const Int_t n, Double_t *a, Int_t *iw, Double_t *w, Double_t *rhs, Int_t *iw2, const Int_t nblk, Int_t &latop, Int_t *icntl);  Help routine for solving. ;  ; static void Solve_sub2 (const Int_t n, Double_t *a, Int_t *iw, Double_t *w, Double_t *rhs, Int_t *iw2, const Int_t nblk, const Int_t latop, Int_t *icntl);  Help routine for solving. ;  ;  Static Protected Member Functions inherited from TDecompBase; static void DiagProd (const TVectorD &diag, Double_t tol, Double_t &d1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDecompSparse.html:14968,rout,routine,14968,doc/master/classTDecompSparse.html,https://root.cern,https://root.cern/doc/master/classTDecompSparse.html,1,['rout'],['routine']
Integrability," Int_t DirReadKeys(TDirectory*) { return 0; }; 169 virtual void DirWriteKeys(TDirectory*) {}; 170 virtual void DirWriteHeader(TDirectory*) {}; 171 ; 172private:; 173 TFile(const TFile &) = delete; //Files cannot be copied; 174 void operator=(const TFile &) = delete;; 175 ; 176 static void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch &watch);; 177 static TFile *OpenFromCache(const char *name, Option_t * = """",; 178 const char *ftitle = """", Int_t compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault,; 179 Int_t netopt = 0);; 180 ; 181public:; 182 /// TFile status bits. BIT(13) is taken up by TObject; 183 enum EStatusBits {; 184 // Produce files forward compatible with (unpatched) version older than; 185 // v6.30 by recording the internal bits kIsOnHeap and kNotDeleted; Older; 186 // releases were not explicitly setting those bits to the correct value; 187 // but instead used verbatim the value stored in the file.; 188 // Note that to avoid a circular dependency, this value is used; 189 // hard coded in TObject.cxx.; 190 k630forwardCompatibility = BIT(2),; 191 kRecovered = BIT(10),; 192 kHasReferences = BIT(11),; 193 kDevNull = BIT(12),; 194 kWriteError = BIT(14),; 195 kBinaryFile = BIT(15),; 196 kRedirected = BIT(16),; 197 kReproducible = BIT(17); 198 };; 199 enum ERelativeTo { kBeg = 0, kCur = 1, kEnd = 2 };; 200 enum { kStartBigFile = 2000000000 };; 201 /// File type; 202 enum EFileType { kDefault = 0, kLocal = 1, kNet = 2, kWeb = 3, kFile = 4, kMerge = 5 };; 203 ; 204 TFile();; 205 TFile(const char *fname, Option_t *option="""", const char *ftitle="""", Int_t compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);; 206 ~TFile() override;; 207 ; 208 void Close(Option_t *option="""") override; // *MENU*; 209 void Copy(TObject &) const override { MayNotUse(""Copy(TObject &)""); }; 210 virtual Bool_t Cp(const char *dst, Bool_t progressbar = kTRUE,UInt_t buffersize = 1000000);; 211 virtual TKey* CreateKey(TDirectory* mother, const TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8h_source.html:9022,depend,dependency,9022,doc/master/TFile_8h_source.html,https://root.cern,https://root.cern/doc/master/TFile_8h_source.html,1,['depend'],['dependency']
Integrability," Int_t GetLenType() constDefinition TLeaf.h:133; TLeaf::GetTypedValueT GetTypedValue(Int_t i=0) constDefinition TLeaf.h:144; TLeaf::ReadValuevirtual void ReadValue(std::istream &, Char_t=' ')Definition TLeaf.h:156; TLeaf::GetMaximumvirtual Int_t GetMaximum() constDefinition TLeaf.h:134; TLeaf::IsUnsignedvirtual bool IsUnsigned() constDefinition TLeaf.h:150; TLeaf::GetTypeNamevirtual const char * GetTypeName() constDefinition TLeaf.h:139; TLeaf::~TLeaf~TLeaf() overrideDestructor.Definition TLeaf.cxx:140; TLeaf::GetValueLongDoublevirtual LongDouble_t GetValueLongDouble(Int_t i=0) constDefinition TLeaf.h:143; TLeaf::fLenInt_t fLenNumber of fixed length elements in the leaf's data.Definition TLeaf.h:72; TLeaf::fNdataInt_t fNdata! Number of elements in fAddress data buffer.Definition TLeaf.h:71; TLeaf::GetLenvirtual Int_t GetLen() constReturn the number of effective elements of this leaf, for the current entry.Definition TLeaf.cxx:404; TLeaf::ResetAddressInt_t ResetAddress(void *add, bool calledFromDestructor=false)Helper routine for TLeafX::SetAddress.Definition TLeaf.cxx:429; TLeaf::GetLeafCountvirtual TLeaf * GetLeafCount() constIf this leaf stores a variable-sized array or a multi-dimensional array whose last dimension has vari...Definition TLeaf.h:121; TLeaf::Exportvirtual void Export(TClonesArray *, Int_t)Definition TLeaf.h:113; TLeaf::GetDeserializeTypevirtual DeserializeType GetDeserializeType() constDefinition TLeaf.h:117; TLeaf::ReadBasketExportvirtual void ReadBasketExport(TBuffer &, TClonesArray *, Int_t)Definition TLeaf.h:153; TLeaf::IncludeRangevirtual bool IncludeRange(TLeaf *)Definition TLeaf.h:146; TLeaf::operator=TLeaf & operator=(const TLeaf &)Assignment operator.Definition TLeaf.cxx:117; TLeaf::GetLeafCountervirtual TLeaf * GetLeafCounter(Int_t &countval) constReturn a pointer to the counter of this leaf (if any) or store the number of elements that the leaf c...Definition TLeaf.cxx:249; TLeaf::DeserializeTypeDeserializeTypeDefinition TLeaf.h:99; TLea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLeaf_8h_source.html:14198,rout,routine,14198,doc/master/TLeaf_8h_source.html,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html,1,['rout'],['routine']
Integrability," Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; SetMarkerStyleOption_t Option_t SetMarkerStyleDefinition TGWin32VirtualXProxy.cxx:52; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; TGraphAsymmErrors.h; TGraphBentErrors.h; TGraphErrors.h; H1LeastSquareSeqndvoid H1LeastSquareSeqnd(Int_t n, Double_t *a, Int_t idim, Int_t &ifail, Int_t k, Double_t *b)Extracted from CERN Program library routine DSEQN.Definition TH1.cxx:4872; TGraph.h; TH1.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; TMath.h; TPluginManager.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; TSpline.h; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TVectorD.h; TVirtualFitter.h; TVirtualGraphPainter.h; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; ROOT::Fit::DataRangeclass describ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:105084,rout,routine,105084,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['rout'],['routine']
Integrability," Int_t TextWidth(FontStruct_t font, const char* s, Int_t len); Return lenght of the string ""s"" in pixels. Size depends on font. void GetFontProperties(FontStruct_t font, Int_t& max_ascent, Int_t& max_descent); Returns the font properties. void GetGCValues(GContext_t gc, GCValues_t& gval); Returns the components specified by the mask in ""gval"" for the; specified GC ""gc"" (see also the GCValues_t structure). FontStruct_t GetFontStruct(FontH_t fh); Retrieves the associated font structure of the font specified font; handle ""fh"". Free returned FontStruct_t using FreeFontStruct(). void FreeFontStruct(FontStruct_t fs); Frees the font structure ""fs"". The font itself will be freed when; no other resource references it. void ClearWindow(Window_t id); Clears the entire area in the specified window and it is equivalent to; ClearArea(id, 0, 0, 0, 0). Int_t KeysymToKeycode(UInt_t keysym); Converts the ""keysym"" to the appropriate keycode. For example,; keysym is a letter and keycode is the matching keyboard key (which; is dependend on the current keyboard mapping). If the specified; ""keysym"" is not defined for any keycode, returns zero. void FillRectangle(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h); Fills the specified rectangle defined by [x,y] [x+w,y] [x+w,y+h] [x,y+h].; using the GC you specify. GC components in use are: function, plane-mask, fill-style,; subwindow-mode, clip-x-origin, clip-y-origin, clip-mask.; GC mode-dependent components: foreground, background, tile, stipple,; tile-stipple-x-origin, and tile-stipple-y-origin.; (see also the GCValues_t structure). void DrawRectangle(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h); Draws rectangle outlines of [x,y] [x+w,y] [x+w,y+h] [x,y+h]. GC components in use: function, plane-mask, line-width, line-style,; cap-style, join-style, fill-style, subwindow-mode, clip-x-origin,; clip-y-origin, clip-mask.; GC mode-dependent components: foreground, background, tile, stipple,; tile-stipple-x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualX.html:53450,depend,dependend,53450,root/html528/TVirtualX.html,https://root.cern,https://root.cern/root/html528/TVirtualX.html,4,['depend'],['dependend']
Integrability," Int_t TextWidth(FontStruct_t font, const char* s, Int_t len); Return length of the string ""s"" in pixels. Size depends on font. void GetFontProperties(FontStruct_t font, Int_t& max_ascent, Int_t& max_descent); Returns the font properties. void GetGCValues(GContext_t gc, GCValues_t& gval); Returns the components specified by the mask in ""gval"" for the; specified GC ""gc"" (see also the GCValues_t structure). FontStruct_t GetFontStruct(FontH_t fh); Retrieves the associated font structure of the font specified font; handle ""fh"". Free returned FontStruct_t using FreeFontStruct(). void FreeFontStruct(FontStruct_t fs); Frees the font structure ""fs"". The font itself will be freed when; no other resource references it. void ClearWindow(Window_t id); Clears the entire area in the specified window and it is equivalent to; ClearArea(id, 0, 0, 0, 0). Int_t KeysymToKeycode(UInt_t keysym); Converts the ""keysym"" to the appropriate keycode. For example,; keysym is a letter and keycode is the matching keyboard key (which; is dependend on the current keyboard mapping). If the specified; ""keysym"" is not defined for any keycode, returns zero. void FillRectangle(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h); Fills the specified rectangle defined by [x,y] [x+w,y] [x+w,y+h] [x,y+h].; using the GC you specify. GC components in use are: function, plane-mask, fill-style,; subwindow-mode, clip-x-origin, clip-y-origin, clip-mask.; GC mode-dependent components: foreground, background, tile, stipple,; tile-stipple-x-origin, and tile-stipple-y-origin.; (see also the GCValues_t structure). void DrawRectangle(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h); Draws rectangle outlines of [x,y] [x+w,y] [x+w,y+h] [x,y+h]. GC components in use: function, plane-mask, line-width, line-style,; cap-style, join-style, fill-style, subwindow-mode, clip-x-origin,; clip-y-origin, clip-mask.; GC mode-dependent components: foreground, background, tile, stipple,; tile-stipple-x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualX.html:57104,depend,dependend,57104,root/html602/TVirtualX.html,https://root.cern,https://root.cern/root/html602/TVirtualX.html,2,['depend'],['dependend']
Integrability," Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfExitStatusQuery exit status ((Int_t)TVirtualProofPlayer::EExitStatus or -1);; set<string,less<string>,allocator<string> >::iteratorfIter!iterator in messages; set<string>fMsgslist of error messages; Long_tfResMemMaxMax resident memory used by the worker; Long_tfVirtMemMaxMax virtual memory used by the worker. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStatus(); Deafult constructor. void Add(const char* mesg); Add an error message. Int_t Merge(TCollection* list); PROOF Merge() function. void Print(Option_t* option = """") const; Standard print function. void Reset(); Reset the iterator on the messages. const char * NextMesg(); Return the next message or 0. void SetMemValues(Long_t vmem = -1, Long_t rmem = -1); Set max memory values. TStatus(). virtual ~TStatus(); { }. Bool_t IsOk() const; { return fMsgs.empty(); }. Int_t GetExitStatus() const; { return fExitStatus; }. Long_t GetResMemMax() const; { return fResMemMax; }. Long_t GetVirtMemMax() const; { return fVirtMemMax; }. void SetExitStatus(Int_t est); { fExitStatus = est; }. » Author: Maarten Ballintijn 12/03/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TStatus.h 40091 2011-06-30 17:47:56Z ganis $ » Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TStatus.html:6376,message,message,6376,root/html530/TStatus.html,https://root.cern,https://root.cern/root/html530/TStatus.html,1,['message'],['message']
Integrability," Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSocket; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static TSocket * CreateAuthSocket (const char *url, Int_t size=0, Int_t tcpwindowsize=-1, TSocket *s=nullptr, Int_t *err=nullptr);  Creates a socket or a parallel socket and authenticates to the remote server. ;  ; static TSocket * CreateAuthSocket (const char *user, const char *host, Int_t port, Int_t size=0, Int_t tcpwindowsize=-1, TSocket *s=nullptr, Int_t *err=nullptr);  Creates a socket or a parallel socket and authenticates to the remote server specified in 'url' on remote 'port' as 'user'. ;  ; static const char * DeclFileName ();  ; static Int_t GetClientProtocol ();  Static method returning supported client protocol. ;  ; static ULong64_t GetSocketBytesRecv ();  Get total number of bytes received via all sockets. ;  ; static ULong64_t GetSocketBytesSent ();  Get total number of bytes sent via all sockets. ;  ; static void NetError (const char *where, Int_t error);  Print error string depending on error code. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPSocket.html:14712,protocol,protocol,14712,doc/master/classTPSocket.html,https://root.cern,https://root.cern/doc/master/classTPSocket.html,1,['protocol'],['protocol']
Integrability," Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCacheElement(); RooAbsCacheElement(const RooAbsCacheElement&); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static RooAbsCacheElement::ActionFindConstantNodes; static RooAbsCacheElement::ActionOperModeChange; static RooAbsCacheElement::ActionOptimizeCaching. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). RooAbsCacheElement(); Default constructor. virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Jun 2 15:26:53 2015 » Last generated: 2015-06-02 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsCacheElement.html:2258,Interface,Interface,2258,root/html604/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html604/RooAbsCacheElement.html,1,['Interface'],['Interface']
Integrability," Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); RooAbsCacheElement(); RooAbsCacheElement(const RooAbsCacheElement&); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static RooAbsCacheElement::ActionFindConstantNodes; static RooAbsCacheElement::ActionOperModeChange; static RooAbsCacheElement::ActionOptimizeCaching. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). RooAbsCacheElement(); Default constructor. virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Jun 30 14:29:54 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCacheElement.html:2258,Interface,Interface,2258,root/html602/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html602/RooAbsCacheElement.html,1,['Interface'],['Interface']
Integrability," Int_t maxiter, Bool_t logx) const; 1697{; 1698 if (xmin >= xmax) {; 1699 xmin = fXmin;; 1700 xmax = fXmax;; 1701 }; 1702 ; 1703 if (!logx && gPad != nullptr) logx = gPad->GetLogx();; 1704 ; 1705 ROOT::Math::BrentMinimizer1D bm;; 1706 ROOT::Math::WrappedFunction<const TF1 &> wf1(*this);; 1707 bm.SetFunction(wf1, xmin, xmax);; 1708 bm.SetNpx(fNpx);; 1709 bm.SetLogScan(logx);; 1710 bm.Minimize(maxiter, epsilon, epsilon);; 1711 Double_t x;; 1712 x = bm.FValMinimum();; 1713 ; 1714 return x;; 1715}; 1716 ; 1717////////////////////////////////////////////////////////////////////////////////; 1718/// Find the minimum of a function of whatever dimension.; 1719/// While GetMinimum works only for 1D function , GetMinimumNDim works for all dimensions; 1720/// since it uses the minimizer interface; 1721/// vector x at beginning will contained the initial point, on exit will contain the result; 1722 ; 1723Double_t TF1::GetMinMaxNDim(Double_t *x , bool findmax, Double_t epsilon, Int_t maxiter) const; 1724{; 1725 R__ASSERT(x != nullptr);; 1726 ; 1727 int ndim = GetNdim();; 1728 if (ndim == 0) {; 1729 Error(""GetMinimumNDim"", ""Function of dimension 0 - return Eval(x)"");; 1730 return (const_cast<TF1 &>(*this))(x);; 1731 }; 1732 ; 1733 // create minimizer class; 1734 const char *minimName = ROOT::Math::MinimizerOptions::DefaultMinimizerType().c_str();; 1735 const char *minimAlgo = ROOT::Math::MinimizerOptions::DefaultMinimizerAlgo().c_str();; 1736 ROOT::Math::Minimizer *min = ROOT::Math::Factory::CreateMinimizer(minimName, minimAlgo);; 1737 ; 1738 if (min == nullptr) {; 1739 Error(""GetMinimumNDim"", ""Error creating minimizer %s"", minimName);; 1740 return 0;; 1741 }; 1742 ; 1743 // minimizer will be set using default values; 1744 if (epsilon > 0) min->SetTolerance(epsilon);; 1745 if (maxiter > 0) min->SetMaxFunctionCalls(maxiter);; 1746 ; 1747 // create wrapper class from TF1 (cannot use Functor, t.b.i.); 1748 ROOT::Math::WrappedMultiFunction<TF1 &> objFunc(const_cast<TF1 &>(*this), ndi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:62886,interface,interface,62886,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['interface'],['interface']
Integrability," Int_t order=1, double eps=0.001)Return function representing first, second or third order derivative of this function.Definition RooAbsReal.cxx:3987; RooAbsReal::plotOnvirtual RooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) constPlot (project) PDF on specified frame.Definition RooAbsReal.cxx:1611; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooPlotPlot frame and a container for graphics objects within that frame.Definition RooPlot.h:45; RooPlot::framestatic RooPlot * frame(const RooAbsRealLValue &var, double xmin, double xmax, Int_t nBins)Create a new frame for a given variable in x.Definition RooPlot.cxx:225; RooPlot::GetYaxisTAxis * GetYaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf111_derivativesDefinition rf111_derivatives.py:1; RangeTa Range(0, 0, 1, 1); ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(gauss_Int[sigma]) using numeric integrator RooIntegrator1D to calculate Int(sigma); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf111_derivatives.C. tutorialsroofitrf111_derivatives.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf111__derivatives_8C.html:5099,integrat,integrator,5099,doc/master/rf111__derivatives_8C.html,https://root.cern,https://root.cern/doc/master/rf111__derivatives_8C.html,1,['integrat'],['integrator']
Integrability," Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TObjOptLink * findLink(const char* name, const char* caller = 0) const; Find the link corresponding to the named object in this list.; Return 0 if the object is not found or does not have an Option_t; string associated with its link. Also print a warning message; if caller is non-zero. Bool_t moveBefore(const char* before, const char* target, const char* caller = 0); Move the target object immediately before the specified object,; preserving any Option_t associated with the target link. Bool_t moveAfter(const char* after, const char* target, const char* caller = 0); Move the target object immediately after the specified object,; preserving any Option_t associated with the target link. inline RooList(); { }. virtual ~RooList(); {}. » Last changed: Mon Dec 7 13:48:09 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooList.html:10330,message,message,10330,root/html526/RooList.html,https://root.cern,https://root.cern/root/html526/RooList.html,1,['message'],['message']
Integrability," Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TObjOptLink * findLink(const char* name, const char* caller = 0) const; Find the link corresponding to the named object in this list.; Return 0 if the object is not found or does not have an Option_t; string associated with its link. Also print a warning message; if caller is non-zero. Bool_t moveBefore(const char* before, const char* target, const char* caller = 0); Move the target object immediately before the specified object,; preserving any Option_t associated with the target link. Bool_t moveAfter(const char* after, const char* target, const char* caller = 0); Move the target object immediately after the specified object,; preserving any Option_t associated with the target link. inline RooList(); { }. virtual ~RooList(); {}. » Last changed: Mon Jul 4 15:23:15 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooList.html:10523,message,message,10523,root/html530/RooList.html,https://root.cern,https://root.cern/root/html530/RooList.html,1,['message'],['message']
Integrability," Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TObjOptLink * findLink(const char* name, const char* caller = 0) const; Find the link corresponding to the named object in this list.; Return 0 if the object is not found or does not have an Option_t; string associated with its link. Also print a warning message; if caller is non-zero. Bool_t moveBefore(const char* before, const char* target, const char* caller = 0); Move the target object immediately before the specified object,; preserving any Option_t associated with the target link. Bool_t moveAfter(const char* after, const char* target, const char* caller = 0); Move the target object immediately after the specified object,; preserving any Option_t associated with the target link. inline RooList(); { }. virtual ~RooList(); {}. » Last changed: Sat Oct 9 06:58:32 2010 » Last generated: 2010-10-09 06:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooList.html:10404,message,message,10404,root/html528/RooList.html,https://root.cern,https://root.cern/root/html528/RooList.html,1,['message'],['message']
Integrability," Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TObjOptLink * findLink(const char* name, const char* caller = 0) const; Find the link corresponding to the named object in this list.; Return 0 if the object is not found or does not have an Option_t; string associated with its link. Also print a warning message; if caller is non-zero. Bool_t moveBefore(const char* before, const char* target, const char* caller = 0); Move the target object immediately before the specified object,; preserving any Option_t associated with the target link. Bool_t moveAfter(const char* after, const char* target, const char* caller = 0); Move the target object immediately after the specified object,; preserving any Option_t associated with the target link. inline RooList(); { }. virtual ~RooList(); {}. » Last changed: Thu Nov 3 20:08:32 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooList.html:10523,message,message,10523,root/html532/RooList.html,https://root.cern,https://root.cern/root/html532/RooList.html,2,['message'],['message']
Integrability," Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_structureTag==0) makeStructureTag() ; return _structureTag ; }. TNamed* typedStructureTag(); { if (_typedStructureTag==0) makeTypedStructureTag() ; return _typedStructureTag ; }. void clearStructureTags(); { _structureTag=0 ; _typedStructureTag = 0 ; }. » Last changed: Fri Dec 2 14:26:34 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCollection.html:20500,interface,interface,20500,root/html532/RooAbsCollection.html,https://root.cern,https://root.cern/root/html532/RooAbsCollection.html,1,['interface'],['interface']
Integrability," Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooExtendPdf(); Default constructor. RooExtendPdf(const char* name, const char* title, const RooAbsPdf& pdf, const RooAbsReal& norm, const char* rangeName = 0); Constructor. The ExtendedPdf behaves identical to the supplied input pdf,; but adds an extended likelihood term. The expected number of events return; is 'norm'. If a rangename is given, the number of events is interpreted as. RooExtendPdf(const RooExtendPdf& other, const char* name = 0); Copy constructor. ~RooExtendPdf(); Destructor. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events, which is. n / [ Int(xC,yF) pdf(x,y) / Int(xF,yF) pdf(x,y) ]. Where x is the set of dependents with cuts defined; and y are the other dependents. xC is the integration; of x over the cut range, xF is the integration of; x over the full range. TObject* clone(const char* newname) const; { return new RooExtendPdf(*this,newname) ; }. Double_t evaluate() const; { return _pdf ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to input p.d.f. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward calculation of analytical integrals to input p.d.f. Bool_t selfNormalized() const; { return kTRUE ; }. ExtendMode extendMode() const; { return CanBeExtended ; }. Double_t expectedEvents(const RooArgSet* nset) const. » Last changed: Fri Dec 3 14:59:10 2010 » Last generated: 2010-12-03 14:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExtendPdf.html:41981,integrat,integration,41981,root/html528/RooExtendPdf.html,https://root.cern,https://root.cern/root/html528/RooExtendPdf.html,1,['integrat'],['integration']
Integrability," Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooExtendPdf(); Default constructor. RooExtendPdf(const char* name, const char* title, const RooAbsPdf& pdf, const RooAbsReal& norm, const char* rangeName = 0); Constructor. The ExtendedPdf behaves identical to the supplied input pdf,; but adds an extended likelihood term. The expected number of events return; is 'norm'. If a rangename is given, the number of events is interpreted as. RooExtendPdf(const RooExtendPdf& other, const char* name = 0); Copy constructor. ~RooExtendPdf(); Destructor. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events, which is. n / [ Int(xC,yF) pdf(x,y) / Int(xF,yF) pdf(x,y) ]. Where x is the set of dependents with cuts defined; and y are the other dependents. xC is the integration; of x over the cut range, xF is the integration of; x over the full range. TObject* clone(const char* newname) const; { return new RooExtendPdf(*this,newname) ; }. Double_t evaluate() const; { return _pdf ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to input p.d.f. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward calculation of analytical integrals to input p.d.f. Bool_t selfNormalized() const; { return kTRUE ; }. ExtendMode extendMode() const; { return CanBeExtended ; }. Double_t expectedEvents(const RooArgSet* nset) const. » Last changed: Mon Jul 4 15:22:46 2011 » Last generated: 2011-07-04 15:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooExtendPdf.html:42197,integrat,integration,42197,root/html530/RooExtendPdf.html,https://root.cern,https://root.cern/root/html530/RooExtendPdf.html,1,['integrat'],['integration']
Integrability," Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooExtendPdf(); Default constructor. RooExtendPdf(const char* name, const char* title, const RooAbsPdf& pdf, const RooAbsReal& norm, const char* rangeName = 0); Constructor. The ExtendedPdf behaves identical to the supplied input pdf,; but adds an extended likelihood term. The expected number of events return; is 'norm'. If a rangename is given, the number of events is interpreted as. RooExtendPdf(const RooExtendPdf& other, const char* name = 0); Copy constructor. ~RooExtendPdf(); Destructor. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events, which is. n / [ Int(xC,yF) pdf(x,y) / Int(xF,yF) pdf(x,y) ]. Where x is the set of dependents with cuts defined; and y are the other dependents. xC is the integration; of x over the cut range, xF is the integration of; x over the full range. TObject* clone(const char* newname) const; { return new RooExtendPdf(*this,newname) ; }. Double_t evaluate() const; { return _pdf ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to input p.d.f. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward calculation of analytical integrals to input p.d.f. Bool_t selfNormalized() const; { return kTRUE ; }. ExtendMode extendMode() const; { return CanBeExtended ; }. Double_t expectedEvents(const RooArgSet* nset) const. » Last changed: Thu Nov 3 20:08:04 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooExtendPdf.html:42604,integrat,integration,42604,root/html532/RooExtendPdf.html,https://root.cern,https://root.cern/root/html532/RooExtendPdf.html,2,['integrat'],['integration']
Integrability," Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooExtendPdf(); Default constructor. RooExtendPdf(const char* name, const char* title, const RooAbsPdf& pdf, const RooAbsReal& norm, const char* rangeName = 0); Constructor. The ExtendedPdf behaves identical to the supplied input pdf,; but adds an extended likelihood term. The expected number of events return; is 'norm'. If a rangename is given, the number of events is interpreted as. RooExtendPdf(const RooExtendPdf& other, const char* name = 0); Copy constructor. ~RooExtendPdf(); Destructor. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events, which is. n / [ Int(xC,yF) pdf(x,y) / Int(xF,yF) pdf(x,y) ]. Where x is the set of dependents with cuts defined; and y are the other dependents. xC is the integration; of x over the cut range, xF is the integration of; x over the full range. TObject* clone(const char* newname) const; { return new RooExtendPdf(*this,newname) ; }. Double_t evaluate() const; { return _pdf ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to input p.d.f. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward calculation of analytical integrals to input p.d.f. Bool_t selfNormalized() const; { return kTRUE ; }. ExtendMode extendMode() const; { return CanBeExtended ; }. Double_t expectedEvents(const RooArgSet* nset) const. » Last changed: Tue Jun 2 13:09:25 2015 » Last generated: 2015-06-02 13:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExtendPdf.html:46615,integrat,integration,46615,root/html602/RooExtendPdf.html,https://root.cern,https://root.cern/root/html602/RooExtendPdf.html,2,['integrat'],['integration']
Integrability," Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooExtendPdf(); Default constructor. RooExtendPdf(const char* name, const char* title, const RooAbsPdf& pdf, const RooAbsReal& norm, const char* rangeName = 0); Constructor. The ExtendedPdf behaves identical to the supplied input pdf,; but adds an extended likelihood term. The expected number of events return; is 'norm'. If a rangename is given, the number of events is interpreted as. RooExtendPdf(const RooExtendPdf& other, const char* name = 0); Copy constructor. ~RooExtendPdf(); Destructor. Double_t expectedEvents(const RooArgSet* nset) const; Return the number of expected events, which is. n / [ Int(xC,yF) pdf(x,y) / Int(xF,yF) pdf(x,y) ]. Where x is the set of dependents with cuts defined; and y are the other dependents. xC is the integration; of x over the cut range, xF is the integration of; x over the full range. TObject* clone(const char* newname) const; { return new RooExtendPdf(*this,newname) ; }. Double_t evaluate() const; { return _pdf ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; { return kTRUE ; }. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Forward determination of analytical integration capabilities to input p.d.f. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward calculation of analytical integrals to input p.d.f. Bool_t selfNormalized() const; { return kTRUE ; }. ExtendMode extendMode() const; { return CanBeExtended ; }. Double_t expectedEvents(const RooArgSet* nset) const. » Last changed: Tue Jun 2 15:30:41 2015 » Last generated: 2015-06-02 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooExtendPdf.html:46615,integrat,integration,46615,root/html604/RooExtendPdf.html,https://root.cern,https://root.cern/root/html604/RooExtendPdf.html,2,['integrat'],['integration']
Integrability," Int_tRooSegmentedIntegrator1D::_nsegNumber of segments ; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Mon Dec 7 13:48:59 2009 » Last generated: 2009-12-07 13:48; This page has been automatically ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSegmentedIntegrator2D.html:7550,integrat,integration,7550,root/html526/RooSegmentedIntegrator2D.html,https://root.cern,https://root.cern/root/html526/RooSegmentedIntegrator2D.html,1,['integrat'],['integration']
Integrability," Int_tRooSegmentedIntegrator1D::_nsegNumber of segments ; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Mon Jul 4 15:23:56 2011 » Last generated: 2011-07-04 15:23; This page has been automatically ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooSegmentedIntegrator2D.html:7605,integrat,integration,7605,root/html530/RooSegmentedIntegrator2D.html,https://root.cern,https://root.cern/root/html530/RooSegmentedIntegrator2D.html,1,['integrat'],['integration']
Integrability," Int_tRooSegmentedIntegrator1D::_nsegNumber of segments ; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Thu Nov 3 20:09:12 2011 » Last generated: 2011-11-03 20:09; This page has been automatically ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooSegmentedIntegrator2D.html:7605,integrat,integration,7605,root/html532/RooSegmentedIntegrator2D.html,https://root.cern,https://root.cern/root/html532/RooSegmentedIntegrator2D.html,2,['integrat'],['integration']
Integrability," Int_tRooSegmentedIntegrator1D::_nsegNumber of segments ; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Thu Sep 23 20:00:46 2010 » Last generated: 2010-09-23 20:00; This page has been automatically g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSegmentedIntegrator2D.html:7536,integrat,integration,7536,root/html528/RooSegmentedIntegrator2D.html,https://root.cern,https://root.cern/root/html528/RooSegmentedIntegrator2D.html,1,['integrat'],['integration']
Integrability," Int_tRooSegmentedIntegrator1D::_nsegNumber of segments ; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, const RooNumIntConfig& config); Constructor integral on given function binding, with given configuration and; explicit definition of integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Virtual constructor with given function and configuration. Needed by RooNumIntFactory. ~RooSegmentedIntegrator2D(); Destructor. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Bool_t canIntegrate1D() const; { return kFALSE ; }. Bool_t canIntegrate2D() const; { return kTRUE ; }. Bool_t canIntegrateND() const; { return kFALSE ; }. Bool_t canIntegrateOpenEnded() const; { return kFALSE ; }. » Last changed: Tue Mar 10 17:19:03 2015 » Last generated: 2015-03-10 17:19; This page has been automatically g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSegmentedIntegrator2D.html:7624,integrat,integration,7624,root/html534/RooSegmentedIntegrator2D.html,https://root.cern,https://root.cern/root/html534/RooSegmentedIntegrator2D.html,2,['integrat'],['integration']
Integrability," Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPadEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of TPad editor GUI. ~TPadEditor(); Destructor of fill editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Pick up the used fill attributes. void ActivateBaseClassEditors(TClass* cl); Exclude TAttLineEditor from this interface. void DoEditable(Bool_t on); Slot connected to the check box 'Editable'. void DoCrosshair(Bool_t on); Slot connected to the check box 'Crosshair'. void DoFixedAspectRatio(Bool_t on); Slot connected to the check box 'Fixed aspect ratio'. void DoGridX(Bool_t on); Slot connected to the check box 'GridX'. void DoGridY(Bool_t on); Slot connected to the check box 'GridY'. void DoLogX(Bool_t on); Slot connected to the check box 'LogX'. void DoLogY(Bool_t on); Slot connected to the check box 'LogY'. void DoLogZ(Bool_t on); Slot connected to the check box 'LogZ'. void DoTickX(Bool_t on); Slot connected to the check box 'TickX'. void DoTickY(Bool_t on); Slot connected to the check box 'TickY'. void DoBorderMode(); Slot connected to the border mode settings. void DoBorderSize(Int_t size); Slot connected to the border size settings. » Author: Ilka Antcheva 24/06/04 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPadEditor.html:21643,interface,interface,21643,root/html534/TPadEditor.html,https://root.cern,https://root.cern/root/html534/TPadEditor.html,2,['interface'],['interface']
Integrability," Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPadEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of TPad editor GUI. ~TPadEditor(); Destructor of fill editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Pick up the used fill attributes. void ActivateBaseClassEditors(TClass* cl); Exclude TAttLineEditor from this interface. void DoEditable(Bool_t on); Slot connected to the check box 'Editable'. void DoCrosshair(Bool_t on); Slot connected to the check box 'Crosshair'. void DoFixedAspectRatio(Bool_t on); Slot connected to the check box 'Fixed aspect ratio'. void DoGridX(Bool_t on); Slot connected to the check box 'GridX'. void DoGridY(Bool_t on); Slot connected to the check box 'GridY'. void DoLogX(Bool_t on); Slot connected to the check box 'LogX'. void DoLogY(Bool_t on); Slot connected to the check box 'LogY'. void DoLogZ(Bool_t on); Slot connected to the check box 'LogZ'. void DoTickX(Bool_t on); Slot connected to the check box 'TickX'. void DoTickY(Bool_t on); Slot connected to the check box 'TickY'. void DoBorderMode(); Slot connected to the border mode settings. void DoBorderSize(Int_t size); Slot connected to the border size settings. » Author: Ilka Antcheva 24/06/04 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id: ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPadEditor.html:21524,interface,interface,21524,root/html528/TPadEditor.html,https://root.cern,https://root.cern/root/html528/TPadEditor.html,4,['interface'],['interface']
Integrability," Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:17504,interface,interface,17504,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,8,['interface'],['interface']
Integrability," Int_tfNeventsnumber of events per toy (may be ignored depending on settings); Int_tfNtoysnumber of toys to generate; RooArgSet*fNuisParamsRooArgSet specifying nuisance parameters for interval; RooArgSet*fObservablesRooArgSet specifying the observables in the dataset (needed to evaluate the test statistic); Bool_tfOwnsWorkspaceflag if this object owns its workspace; RooArgSet*fPOIRooArgSet specifying parameters of interest for interval; const char*fPdfNamename of common PDF in workspace; TRandom*fRandrandom generator; Double_tfSize; RooStats::TestStatistic*fTestStatpointer to the test statistic that is being sampled; TStringfVarNamename of test statistic; RooWorkspace*fWSa workspace that owns all the components to be used by the calculator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ToyMCSampler(TestStatistic &ts). virtual ~ToyMCSampler(). SamplingDistribution* AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC); Extended interface to append to sampling distribution more samples. SamplingDistribution* GetSamplingDistribution(RooArgSet& allParameters); Main interface to get a SamplingDistribution. RooAbsData* GenerateToyData(RooArgSet& allParameters) const; This method generates a toy dataset for the given parameter point. SetParameters(&allParameters, parameters). string MakeName(RooArgSet& ); helper method to create meaningful names for sampling dist. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& allParameters); Main interface to evaluate the test statistic on a dataset. const RooAbsArg* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetNEventsPerToy(const Int_t nevents). void SetExtended(const Bool_t isExtended). void SetData(RooAbsData& data); Set the DataSet, add to t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__ToyMCSampler.html:4007,interface,interface,4007,root/html526/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html526/RooStats__ToyMCSampler.html,1,['interface'],['interface']
Integrability," Int_t ; x, . Int_t ; y, . UInt_t ; width, . UInt_t ; height, . Bool_t ; readonly = kTRUE . ). Constructor. ; Definition at line 184 of file TWebCanvas.cxx. ◆ ~TWebCanvas(). TWebCanvas::~TWebCanvas ; (; ). override . Destructor. ; Definition at line 214 of file TWebCanvas.cxx. Member Function Documentation. ◆ ActivateInEditor(). void TWebCanvas::ActivateInEditor ; (; TPad * ; pad, . TObject * ; obj . ). Activate object in editor in web browser. ; Definition at line 1368 of file TWebCanvas.cxx. ◆ AddColorsPalette(). void TWebCanvas::AddColorsPalette ; (; TPadWebSnapshot & ; master). protected . Add special canvas objects with list of colors and color palette. ; Definition at line 582 of file TWebCanvas.cxx. ◆ AddCtrlMsg(). void TWebCanvas::AddCtrlMsg ; (; unsigned ; connid, . const std::string & ; key, . const std::string & ; value . ). protected . Add control message for specified connection Same control message can be overwritten many time before it really sends to the client If connid == 0, message will be add to all connections After ctrl message is add to the output, short timer is activated and message send afterwards. ; Definition at line 1167 of file TWebCanvas.cxx. ◆ AddCustomClass(). void TWebCanvas::AddCustomClass ; (; const std::string & ; clname, . bool ; with_derived = false . ). static . Assign custom class. ; Definition at line 475 of file TWebCanvas.cxx. ◆ AddCustomFonts(). void TWebCanvas::AddCustomFonts ; (; TPadWebSnapshot & ; master). protected . Add special canvas objects with custom fonts. ; Definition at line 614 of file TWebCanvas.cxx. ◆ AddFont(). Font_t TWebCanvas::AddFont ; (; const char * ; name, . const char * ; ttffile, . Int_t ; precision = 2 . ). static . Add font to static list of fonts supported by the canvas Name specifies name of the font, second is font file with .ttf or .woff2 extension Only True Type Fonts (ttf) are supported by PDF Returns font index which can be used in auto font_indx = TWebCanvas::AddFont(""test"", ""test.ttf"",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:19233,message,message,19233,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,5,['message'],['message']
Integrability," IntegralLow(b);; 299 }; 300 ; 301 /**; 302 evaluate the Integral of a function f with known singular points over the defined Integral (a,b); 303 @param f integration function. The function type must be a C++ callable object implementing operator()(double x); 304 @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value.; 305 ; 306 */; 307 template<class Function>; 308 double Integral(Function & f, const std::vector<double> & pts );; 309 ; 310 /**; 311 evaluate the Integral of a function f with known singular points over the defined Integral (a,b); 312 @param f integration function. The function type must implement the mathlib::IGenFunction interface; 313 @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value.; 314 ; 315 */; 316 double Integral(const IGenFunction & f, const std::vector<double> & pts ) {; 317 SetFunction(f,false);; 318 return Integral(pts);; 319 }; 320 ; 321 /**; 322 evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; 323 @param f integration function. The function type must be a C++ callable object implementing operator()(double x); 324 @param a lower value of the integration interval; 325 @param b upper value of the integration interval; 326 @param c position of singularity; 327 ; 328 */; 329 template<class Function>; 330 double IntegralCauchy(Function & f, double a, double b, double c);; 331 ; 332 /**; 333 evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; 334 @param f integration function. The function type must implement the mathlib::IGenFunction interface; 335 @par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Integrator_8h_source.html:12779,integrat,integration,12779,doc/master/Integrator_8h_source.html,https://root.cern,https://root.cern/doc/master/Integrator_8h_source.html,1,['integrat'],['integration']
Integrability," Integration::GKRule fRule;  ; size_t fSize;  ; int fStatus;  ; Integration::Type fType;  ; GSLIntegrationWorkspace * fWorkspace;  . #include <Math/GSLIntegrator.h>. Inheritance diagram for ROOT::Math::GSLIntegrator:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ GSLIntegrator() [1/5]. ROOT::Math::GSLIntegrator::GSLIntegrator ; (; double ; absTol = 1.E-9, . double ; relTol = 1E-6, . size_t ; size = 1000 . ). Default constructor of GSL Integrator for Adaptive Singular integration. ; Parameters. absToldesired absolute Error ; relToldesired relative Error ; sizemaximum number of sub-intervals . Definition at line 77 of file GSLIntegrator.cxx. ◆ GSLIntegrator() [2/5]. ROOT::Math::GSLIntegrator::GSLIntegrator ; (; const Integration::Type ; type, . double ; absTol = 1.E-9, . double ; relTol = 1E-6, . size_t ; size = 1000 . ). constructor of GSL Integrator. ; In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; Parameters. typetype of integration. The possible types are defined in the Integration::Type enumeration ; absToldesired absolute Error ; relToldesired relative Error ; sizemaximum number of sub-intervals . Definition at line 95 of file GSLIntegrator.cxx. ◆ GSLIntegrator() [3/5]. ROOT::Math::GSLIntegrator::GSLIntegrator ; (; const Integration::Type ; type, . const Integration::GKRule ; rule, . double ; absTol = 1.E-9, . double ; relTol = 1E-6, . size_t ; size = 1000 . ). generic constructor for GSL Integrator ; Parameters. typetype of integration. The possible types are defined in the Integration::Type enumeration ; ruleGauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration ; absToldesired absolute Error ; relToldesired relative Error ; sizemaximum number of sub-intervals . Definition at line 56 of file GSLIntegrator.cxx. ◆ GSLIntegrator() [4/5]. ROOT::Math::GSLIntegra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLIntegrator.html:8238,integrat,integration,8238,doc/master/classROOT_1_1Math_1_1GSLIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLIntegrator.html,1,['integrat'],['integration']
Integrability," Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char * type, int rule, double absTol, double relTol, size_t size ); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const IGenFunction &f, bool copyFunc = false); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction( GSLFuncPointer f, void * p = 0). Set function from a GSL pointer function type. double Integral(const IGenFunction & f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLIntegrator.html:5927,integrat,integration,5927,root/html526/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLIntegrator.html,1,['integrat'],['integration']
Integrability," IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html:7355,integrat,integration,7355,root/html528/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html,16,['integrat'],['integration']
Integrability," Integrator workspace; Bool_t_useIntegrandLimitsIf true limits of function binding are ued; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; Double_t*_x! do not persist; Double_t_xmax! Upper integration bound; Double_t_xmin! Lower integration bound. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooIntegrator1D, is parameters and capabilities with RooNumIntFactory. RooIntegrator1D(); Default constructor. RooIntegrator1D(const RooAbsFunc& function, RooIntegrator1D::SummationRule rule = Trapezoid, Int_t maxSteps = 0, Double_t eps = 0); Construct integrator on given function binding, using specified summation; rule, maximum number of steps and conversion tolerance. The integration; limits are taken from the function binding. RooIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, RooIntegrator1D::SummationRule rule = Trapezoid, Int_t maxSteps = 0, Double_t eps = 0); Construct integrator on given function binding for given range,; using specified summation rule, maximum number of steps and; conversion tolerance. The integration limits are taken from the; function binding. RooIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Construct integrator on given function binding, using specified; configuration object. The integration limits are taken from the; function binding. RooIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Construct integrator on given function binding, using specified; configuration object and integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Clone integrator with new function binding and configuration. Needed by RooNumIntFactory. Bool_t initialize(); Initialize the integrator. ~RooIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooIntegrator1D.html:8495,integrat,integrator,8495,root/html528/RooIntegrator1D.html,https://root.cern,https://root.cern/root/html528/RooIntegrator1D.html,1,['integrat'],['integrator']
Integrability, IntegratorMultiDim::Type ROOT::Math::IntegratorMultiDimOptions::DefaultIntegratorType ; (; ). static . Definition at line 341 of file IntegratorOptions.cxx. ◆ DefaultNCalls(). unsigned int ROOT::Math::IntegratorMultiDimOptions::DefaultNCalls ; (; ). static . Definition at line 370 of file IntegratorOptions.cxx. ◆ DefaultRelTolerance(). double ROOT::Math::IntegratorMultiDimOptions::DefaultRelTolerance ; (; ). static . Definition at line 368 of file IntegratorOptions.cxx. ◆ DefaultWKSize(). unsigned int ROOT::Math::IntegratorMultiDimOptions::DefaultWKSize ; (; ). static . Definition at line 369 of file IntegratorOptions.cxx. ◆ FindDefault(). IOptions * ROOT::Math::IntegratorMultiDimOptions::FindDefault ; (; const char * ; name). static . find specific options - return 0 if not existing ; Definition at line 378 of file IntegratorOptions.cxx. ◆ Integrator(). std::string ROOT::Math::IntegratorMultiDimOptions::Integrator ; (; ); const. overridevirtual . name of multi-dim integrator ; Implements ROOT::Math::BaseIntegratorOptions.; Definition at line 308 of file IntegratorOptions.cxx. ◆ IntegratorType(). IntegrationMultiDim::Type ROOT::Math::IntegratorMultiDimOptions::IntegratorType ; (; ); const. inline . type of the integrator (return the enumeration type) ; Definition at line 228 of file IntegratorOptions.h. ◆ NCalls(). unsigned int ROOT::Math::IntegratorMultiDimOptions::NCalls ; (; ); const. inline . maximum number of function calls ; Definition at line 222 of file IntegratorOptions.h. ◆ operator=(). IntegratorMultiDimOptions & ROOT::Math::IntegratorMultiDimOptions::operator= ; (; const IntegratorMultiDimOptions & ; rhs). inline . assignment operator ; Definition at line 211 of file IntegratorOptions.h. ◆ Print(). void ROOT::Math::IntegratorMultiDimOptions::Print ; (; std::ostream & ; os = std::cout); const. print all the options ; Definition at line 312 of file IntegratorOptions.cxx. ◆ PrintDefault(). void ROOT::Math::IntegratorMultiDimOptions::PrintDefault ; (; const ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorMultiDimOptions.html:6276,integrat,integrator,6276,doc/master/classROOT_1_1Math_1_1IntegratorMultiDimOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorMultiDimOptions.html,1,['integrat'],['integrator']
Integrability," IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html:7978,integrat,integration,7978,root/html528/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html,10,['integrat'],['integration']
Integrability," Interface for tools setting limits (producing confidence intervals); RooStats::NumEventsTestStat ; RooStats::NumberCountingPdfFactory A factory specific to common number counting problems.; RooStats::NumberCountingUtils ; RooStats::PointSetInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::ProfileLikelihoodCalculator A concrete implementation of CombinedCalculator that uses the ProfileLikelihood ratio.; RooStats::ProfileLikelihoodTestStat implements the profile likelihood ratio as a test statistic to be used with several tools; RooStats::ProposalFunction Interface for the proposal function used with Markov Chain Monte Carlo; RooStats::SPlot Class used for making sPlots; RooStats::SamplingDistPlot Class containing the results of the HybridCalculator; RooStats::SamplingDistribution Class containing the results of the HybridCalculator; RooStats::SamplingSummary A summary of acceptance regions for confidence belt; RooStats::SamplingSummaryLookup A simple class used by ConfidenceBelt; RooStats::SimpleInterval Concrete implementation of ConfInterval for simple 1-D intervals in the form [a,b]; RooStats::TestStatSampler Interface for tools setting limits (producing confidence intervals); RooStats::TestStatistic Interface for tools setting limits (producing confidence intervals); RooStats::ToyMCSampler A simple implementation of the TestStatSampler interface; RooStats::UniformProposal A concrete implementation of ProposalFunction, that uniformly samples the parameter space.; RooStreamParser Utility class that parses iostream data into tokens; RooStringVar String-valued variable ; RooSuperCategory Lvalue product operator for catategory lvalues; RooTFnBinding RooAbsReal binding to ROOT TF[123] functions; RooTFnPdfBinding RooAbsPdf binding to ROOT TF[123] functions; RooTFoamBinding Function binding to RooAbsReal object; RooTObjWrap Container class for Int_t; RooTable Abstract interface for tables; RooThreshEntry Utility class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:44704,interface,interface,44704,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['interface'],['interface']
Integrability," Interface to CINT function. Long_t CallFunc_ExecInt64(CallFunc_t* func, void* address) const; Interface to CINT function. Double_t CallFunc_ExecDouble(CallFunc_t* func, void* address) const; Interface to CINT function. CallFunc_t * CallFunc_Factory() const; Interface to CINT function. CallFunc_t * CallFunc_FactoryCopy(CallFunc_t* func) const; Interface to CINT function. MethodInfo_t * CallFunc_FactoryMethod(CallFunc_t* func) const; Interface to CINT function. void CallFunc_Init(CallFunc_t* func) const; Interface to CINT function. bool CallFunc_IsValid(CallFunc_t* func) const; Interface to CINT function. void CallFunc_ResetArg(CallFunc_t* func) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, Long_t param) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, Double_t param) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, Long64_t param) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, ULong64_t param) const; Interface to CINT function. void CallFunc_SetArgArray(CallFunc_t* func, Long_t* paramArr, Int_t nparam) const; Interface to CINT function. void CallFunc_SetArgs(CallFunc_t* func, const char* param) const; Interface to CINT function. void CallFunc_SetFunc(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* params, Long_t* Offset) const; Interface to CINT function. void CallFunc_SetFunc(CallFunc_t* func, MethodInfo_t* info) const; Interface to CINT function. void CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, Long_t* Offset) const; Interface to CINT function. Long_t ClassInfo_ClassProperty(ClassInfo_t* info) const; Interface to CINT function. void ClassInfo_Delete(ClassInfo_t* info) const; Interface to CINT function. void ClassInfo_Delete(ClassInfo_t* info, void* arena) const; Interface to CINT function. void ClassInfo_DeleteArray(ClassInfo_t* info, void* arena, bool dtorOnly) const; Interface to CINT f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCint.html:34408,Interface,Interface,34408,root/html532/TCint.html,https://root.cern,https://root.cern/root/html532/TCint.html,1,['Interface'],['Interface']
Integrability," Interface to CINT function. int DataMemberInfo_TypeSize(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_TypeName(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_TypeTrueName(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_Name(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_Title(DataMemberInfo_t* dminfo) const; Interface to CINT function. const char * DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* dminfo) const; Interface to CINT function. void MethodInfo_Delete(MethodInfo_t* minfo) const; Interface to CINT function. void MethodInfo_CreateSignature(MethodInfo_t* minfo, TString& signature) const; Interface to CINT function. MethodInfo_t * MethodInfo_Factory() const; Interface to CINT function. MethodInfo_t * MethodInfo_Factory(ClassInfo_t* ) const; Interface to CINT function. MethodInfo_t * MethodInfo_FactoryCopy(MethodInfo_t* minfo) const; Interface to CINT function. void * MethodInfo_InterfaceMethod(MethodInfo_t* minfo) const; Interface to CINT function. Bool_t MethodInfo_IsValid(MethodInfo_t* minfo) const; Interface to CINT function. int MethodInfo_NArg(MethodInfo_t* minfo) const; Interface to CINT function. int MethodInfo_NDefaultArg(MethodInfo_t* minfo) const; Interface to CINT function. int MethodInfo_Next(MethodInfo_t* minfo) const; Interface to CINT function. Long_t MethodInfo_Property(MethodInfo_t* minfo) const; Interface to CINT function. void * MethodInfo_Type(MethodInfo_t* minfo) const; Interface to CINT function. std::string MethodInfo_TypeNormalizedName(MethodInfo_t* minfo) const; Interface to CINT function. const char * MethodInfo_GetMangledName(MethodInfo_t* minfo) const; Interface to CINT function. const char * MethodInfo_GetPrototype(MethodInfo_t* minfo) const; Interface to CINT function. const char * MethodInfo_Name(MethodInfo_t* minfo) const; Interface to CINT function. const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:41610,Interface,Interface,41610,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,1,['Interface'],['Interface']
Integrability, Interface to CINT function. void * MethodInfo_InterfaceMethod(MethodInfo_t* minfo) const; Interface to CINT function. bool MethodInfo_IsValid(MethodInfo_t* minfo) const; Interface to CINT function. int MethodInfo_NArg(MethodInfo_t* minfo) const; Interface to CINT function. int MethodInfo_NDefaultArg(MethodInfo_t* minfo) const; Interface to CINT function. int MethodInfo_Next(MethodInfo_t* minfo) const; Interface to CINT function. Long_t MethodInfo_Property(MethodInfo_t* minfo) const; Interface to CINT function. void * MethodInfo_Type(MethodInfo_t* minfo) const; Interface to CINT function. const char * MethodInfo_GetMangledName(MethodInfo_t* minfo) const; Interface to CINT function. const char * MethodInfo_GetPrototype(MethodInfo_t* minfo) const; Interface to CINT function. const char * MethodInfo_Name(MethodInfo_t* minfo) const; Interface to CINT function. const char * MethodInfo_TypeName(MethodInfo_t* minfo) const; Interface to CINT function. const char * MethodInfo_Title(MethodInfo_t* minfo) const; Interface to CINT function. void MethodArgInfo_Delete(MethodArgInfo_t* marginfo) const; Interface to CINT function. MethodArgInfo_t * MethodArgInfo_Factory() const; Interface to CINT function. MethodArgInfo_t * MethodArgInfo_FactoryCopy(MethodArgInfo_t* marginfo) const; Interface to CINT function. bool MethodArgInfo_IsValid(MethodArgInfo_t* marginfo) const; Interface to CINT function. int MethodArgInfo_Next(MethodArgInfo_t* marginfo) const; Interface to CINT function. Long_t MethodArgInfo_Property(MethodArgInfo_t* marginfo) const; Interface to CINT function. const char * MethodArgInfo_DefaultValue(MethodArgInfo_t* marginfo) const; Interface to CINT function. const char * MethodArgInfo_Name(MethodArgInfo_t* marginfo) const; Interface to CINT function. const char * MethodArgInfo_TypeName(MethodArgInfo_t* marginfo) const; Interface to CINT function. void TypeInfo_Delete(TypeInfo_t* tinfo) const; Interface to CINT function. TypeInfo_t * TypeInfo_Factory() const; Interface t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCint.html:41678,Interface,Interface,41678,root/html532/TCint.html,https://root.cern,https://root.cern/root/html532/TCint.html,1,['Interface'],['Interface']
Integrability," Interface to CINT function. void SetAllocunlockfunc(void (*)() ) const; Interface to CINT function. int SetClassAutoloading(int ) const; Interface to CINT function. void SetErrmsgcallback(void* p) const; Interface to CINT function. void Setgvp(Long_t ) const; Interface to CINT function. void SetRTLD_NOW() const; Interface to CINT function. void SetRTLD_LAZY() const; Interface to CINT function. void SetTempLevel(int val) const; Interface to CINT function. int UnloadFile(const char* path) const; Interface to CINT function. void CallFunc_Delete(void* func) const; Interface to CINT function. void CallFunc_Exec(CallFunc_t* func, void* address) const; Interface to CINT function. Long_t CallFunc_ExecInt(CallFunc_t* func, void* address) const; Interface to CINT function. Long64_t CallFunc_ExecInt64(CallFunc_t* func, void* address) const; Interface to CINT function. Double_t CallFunc_ExecDouble(CallFunc_t* func, void* address) const; Interface to CINT function. CallFunc_t * CallFunc_Factory() const; Interface to CINT function. CallFunc_t * CallFunc_FactoryCopy(CallFunc_t* func) const; Interface to CINT function. MethodInfo_t * CallFunc_FactoryMethod(CallFunc_t* func) const; Interface to CINT function. void CallFunc_Init(CallFunc_t* func) const; Interface to CINT function. Bool_t CallFunc_IsValid(CallFunc_t* func) const; Interface to CINT function. void CallFunc_ResetArg(CallFunc_t* func) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, Long_t param) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, Double_t param) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, Long64_t param) const; Interface to CINT function. void CallFunc_SetArg(CallFunc_t* func, ULong64_t param) const; Interface to CINT function. void CallFunc_SetArgArray(CallFunc_t* func, Long_t* paramArr, Int_t nparam) const; Interface to CINT function. void CallFunc_SetArgs(CallFunc_t* func, const char* param) const; Interface to CINT function.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:34493,Interface,Interface,34493,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,1,['Interface'],['Interface']
Integrability," Interface to CINT function. void TypeInfo_Delete(TypeInfo_t* tinfo) const; Interface to CINT function. TypeInfo_t * TypeInfo_Factory() const; Interface to CINT function. TypeInfo_t * TypeInfo_Factory(G__value* ) const; Interface to CINT function. TypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t* ) const; Interface to CINT function. void TypeInfo_Init(TypeInfo_t* tinfo, const char* funcname) const; Interface to CINT function. bool TypeInfo_IsValid(TypeInfo_t* tinfo) const; Interface to CINT function. const char * TypeInfo_Name(TypeInfo_t* ) const; Interface to CINT function. Long_t TypeInfo_Property(TypeInfo_t* tinfo) const; Interface to CINT function. int TypeInfo_RefType(TypeInfo_t* ) const; Interface to CINT function. int TypeInfo_Size(TypeInfo_t* tinfo) const; Interface to CINT function. const char * TypeInfo_TrueName(TypeInfo_t* tinfo) const; Interface to CINT function. void TypedefInfo_Delete(TypedefInfo_t* tinfo) const; Interface to CINT function. TypedefInfo_t * TypedefInfo_Factory() const; Interface to CINT function. TypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t* tinfo) const; Interface to CINT function. TypedefInfo_t TypedefInfo_Init(TypedefInfo_t* tinfo, const char* funcname) const; Interface to CINT function. bool TypedefInfo_IsValid(TypedefInfo_t* tinfo) const; Interface to CINT function. Long_t TypedefInfo_Property(TypedefInfo_t* tinfo) const; Interface to CINT function. int TypedefInfo_Size(TypedefInfo_t* tinfo) const; Interface to CINT function. const char * TypedefInfo_TrueName(TypedefInfo_t* tinfo) const; Interface to CINT function. const char * TypedefInfo_Name(TypedefInfo_t* tinfo) const; Interface to CINT function. const char * TypedefInfo_Title(TypedefInfo_t* tinfo) const; Interface to CINT function. TCint(); { }. TCint(const TCint& ). TCint & operator=(const TCint& ). void Execute(TMethod* , TObjArray* , int* = 0); { }. Int_t GetExitCode() const; { return fExitCode; }. TEnv * GetMapfile() const; { return fMapfile; }. Int_t GetMore() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCint.html:43518,Interface,Interface,43518,root/html532/TCint.html,https://root.cern,https://root.cern/root/html532/TCint.html,1,['Interface'],['Interface']
Integrability," Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. void setParameterizeIntegral(const RooArgSet& paramVars). Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. Double_t getVal(const RooArgSet& set) const; { return _fast ? _value : getValV(&set) ; }. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. Bool_t getForceNumInt() const; { return _forceNumInt ; }. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create integral over observables in iset in range named rangeName. return createIntegral(iset,0,0,rangeName). RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName = 0) const; Create integral over observables in iset in range nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:82016,integrat,integration,82016,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,9,"['Interface', 'integrat']","['Interface', 'integration']"
Integrability," It also takes; into account the option to generate a binned data set (ie RooDataHist). SamplingDistribution* AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC). void ClearCache(); clear the cache obtained from the pdf used for speeding the toy and global observables generation; needs to be called every time the model pdf (fPdf) changes. ToyMCSampler(). void SetUseMultiGen(Bool_t flag); { fUseMultiGen = flag ; }. void AddTestStatistic(RooStats::TestStatistic* t = __null); The pdf can be NULL in which case the density from SetPdf(); is used. The snapshot and TestStatistic is also optional. RooAbsData* GenerateToyData(RooArgSet& paramPoint, RooAbsPdf& pdf) const; generates toy data; without weight. return GenerateToyData(paramPoint, weight, pdf). RooAbsData* GenerateToyData(RooArgSet& paramPoint) const; with weight. { return GenerateToyData(paramPoint,*fPdf); }. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& nullPOI, int i); Main interface to evaluate the test statistic on a dataset. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& nullPOI); { return EvaluateTestStatistic( data,nullPOI, 0 ); }. TestStatistic* GetTestStatistic(unsigned int i) const. TestStatistic* GetTestStatistic(unsigned int i) const; { return GetTestStatistic(0); }. Double_t ConfidenceLevel() const; { return 1. - fSize; }. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); { return fNToys; }. void SetNToys(const Int_t ntoy); { fNToys = ntoy; }. void SetNEventsPerToy(const Int_t nevents); Forces n events even for extended PDFs. Set NEvents=0 to; use the Poisson distributed events from the extended PDF. void SetParametersForTestStat(const RooArgSet& nullpoi); Set the Pdf, add to the the workspace if not already there. void SetPdf(RooAbsPdf& pdf); { fPdf = &pdf; ClearCache(); }. void SetPriorNuisance(RooAbsPdf* pdf); How to randomize the prior. Set to NULL to deactivate randomization. void SetNuisanceParameters(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__ToyMCSampler.html:8512,interface,interface,8512,root/html602/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html602/RooStats__ToyMCSampler.html,4,['interface'],['interface']
Integrability," L\) functions of \( N\) variables, and \( L \leq M\). That is, \( f_{jl}\) is the term (or function) numbered \( l\) evaluated at the data point \( j\). We have to normalise \(\mathbf{x}_j\) to \( [-1,1]\) for this to succeed [5] (TMultiDimFit::MakeNormalized). We then define a matrix \(\mathsf{W}\) of which the columns \(\mathbf{w}_j\) are given by ; \begin{eqnarray*}; \mathbf{w}_1 &=& \mathbf{f}_1 = F_1\left(\mathbf x_1\right)\\; \mathbf{w}_l &=& \mathbf{f}_l - \sum^{l-1}_{k=1} \frac{\mathbf{f}_l \bullet; \mathbf{w}_k}{\mathbf{w}_k^2}\mathbf{w}_k\,.; \end{eqnarray*}. and \(\mathbf{w}_{l}\) is the component of \(\mathbf{f}_{l} \) orthogonal to \(\mathbf{w}_{1}, \ldots, \mathbf{w}_{l-1}\). Hence we obtain [3], ; \[; \mathbf{w}_k\bullet\mathbf{w}_l = 0\quad\mbox{if}~k \neq l\quad.; \]. We now take as a new model \(\mathsf{W}\mathbf{a}\). We thus want to minimize ; \[; S\equiv \left(\mathbf{D} - \mathsf{W}\mathbf{a}\right)^2\quad,; \]. where \(\mathbf{D} = \left(D_1,\ldots,D_M\right)\) is a vector of the dependent quantity in the sample. Differentiation with respect to \( a_j\) gives, using 6, ; \[; \mathbf{D}\bullet\mathbf{w}_l - a_l\mathbf{w}_l^2 = 0; \]. or ; \[; a_l = \frac{\mathbf{D}_l\bullet\mathbf{w}_l}{\mathbf{w}_l^2}; \]. Let \( S_j\) be the sum of squares of residuals when taking \( j\) functions into account. Then ; \[; S_l = \left[\mathbf{D} - \sum^l_{k=1} a_k\mathbf{w}_k\right]^2; = \mathbf{D}^2 - 2\mathbf{D} \sum^l_{k=1} a_k\mathbf{w}_k; + \sum^l_{k=1} a_k^2\mathbf{w}_k^2; \]. Using 9, we see that ; \begin{eqnarray*}; S_l &=& \mathbf{D}^2 - 2 \sum^l_{k=1} a_k^2\mathbf{w}_k^2 +; \sum^j_{k=1} a_k^2\mathbf{w}_k^2\nonumber\\; &=& \mathbf{D}^2 - \sum^l_{k=1} a_k^2\mathbf{w}_k^2\nonumber\\; &=& \mathbf{D}^2 - \sum^l_{k=1} \frac{\left(\mathbf D\bullet \mathbf; w_k\right)}{\mathbf w_k^2}; \end{eqnarray*}. So for each new function \( F_l\) included in the model, we get a reduction of the sum of squares of residuals of \(a_l^2\mathbf{w}_l^2\), where \(\mathbf{w}_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:7596,depend,dependent,7596,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['depend'],['dependent']
Integrability," Libraries. Function documentation; RooAbsNumGenerator(const RooAbsReal& func, const RooArgSet& genVars, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0); Initialize an accept-reject generator for the specified distribution function,; which must be non-negative but does not need to be normalized over the; variables to be generated, genVars. The function and its dependents are; cloned and so will not be disturbed during the generation process. ~RooAbsNumGenerator(); Destructor. void attachParameters(const RooArgSet& vars); Reattach original parameters to function clone. void printName(ostream& os) const; Print name of the generator. void printTitle(ostream& os) const; Print the title of the generator. void printClassName(ostream& os) const; Print the class name of the generator. void printArgs(ostream& os) const; Print the arguments of the generator. RooAbsNumGenerator(); {}. RooAbsNumGenerator(const RooAbsReal& func, const RooArgSet& genVars, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0). RooAbsNumGenerator* clone(const RooAbsReal& , const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; If true, generator is in a valid state. void setVerbose(Bool_t verbose = kTRUE); If flag is true, verbose messaging will be active during generation. Bool_t isVerbose() const; Return status of verbose messaging flag. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio). Double_t getFuncMax(); { return 0 ; }. void Print(Option_t* options = 0) const; ascii printing interface. Bool_t canSampleCategories() const; Advertisement of capabilities. { return kFALSE ; }. Bool_t canSampleConditional() const; { return kFALSE ; }. » Last changed: Tue Jun 30 14:30:14 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsNumGenerator.html:10945,interface,interface,10945,root/html602/RooAbsNumGenerator.html,https://root.cern,https://root.cern/root/html602/RooAbsNumGenerator.html,2,['interface'],['interface']
Integrability," Libraries. Function documentation; TGNumberEntry(const TGWindow* parent = 0, Double_t val = 0, Int_t digitwidth = 5, Int_t id = -1, TGNumberFormat::EStyle style = kNESReal, TGNumberFormat::EAttribute attr = kNEAAnyNumber, TGNumberFormat::ELimit limits = kNELNoLimits, Double_t min = 0, Double_t max = 1); Constructs a numeric entry widget. ~TGNumberEntry(); Destructs a numeric entry widget. void Associate(const TGWindow* w); Make w the window that will receive the generated messages. void SetLogStep(Bool_t on = kTRUE); Set log steps. void SetState(Bool_t enable = kTRUE); Set the active state. void SetButtonToNum(Bool_t state); Send button messages to the number field (true) or parent widget (false).; When the message is sent to the parent widget, it is responsible to change; the numerical value accordingly. This can be useful to implement cursors; which move from data point to data point. For the message being sent; see ProcessMessage(). Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process the up/down button messages. If fButtonToNum is false the; following message is sent: kC_COMMAND, kCM_BUTTON, widget id, param; param % 100 is the step size; param % 10000 / 100 != 0 indicates log step; param / 10000 != 0 indicates button down. TGLayoutManager * GetLayoutManager() const; Return layout manager. void ValueChanged(Long_t val); Emit ValueChanged(Long_t) signal. This signal is emitted when; fButtonToNum is false. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void ValueSet(Long_t val); Emit ValueSet(Long_t) signal. This signal is emitted when the; number entry value is changed. The val has the following meaning:; val % 100 is the step size; val % 10000 / 100 != 0 indicates log step; val / 10000 != 0 indicates button down. void SavePrimitive(ostream& out, Option_t* = """"); Save a number entry widget as a C++ statement(s) on output stream out. void SetNumbe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGNumberEntry.html:25724,message,messages,25724,root/html528/TGNumberEntry.html,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html,10,['message'],['messages']
Integrability," Libraries. Function documentation; ~RooAbsString(); Destructor. const char* getVal() const; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); Copy cache of another RooAbsArg to our cache. Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. void fillTreeBranch(TTree& t); Fill tree branch associated with this object. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooStringVar fundamental object with our properties. TString evaluate() const; { return """" ; }. void attachToVStore(RooVectorDataStore& ); {}. » Last changed: Tue Mar 10 17:14:14 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsString.html:21938,wrap,wrapper,21938,root/html534/RooAbsString.html,https://root.cern,https://root.cern/root/html534/RooAbsString.html,2,['wrap'],['wrapper']
Integrability," LikelihoodIntervalPlot.h. ◆ fFillStyle. Style_t RooStats::LikelihoodIntervalPlot::fFillStyle = 4050. private . fill style for contours, half transparent by default ; Definition at line 73 of file LikelihoodIntervalPlot.h. ◆ fInterval. LikelihoodInterval* RooStats::LikelihoodIntervalPlot::fInterval = nullptr. private . Definition at line 86 of file LikelihoodIntervalPlot.h. ◆ fLineColor. Color_t RooStats::LikelihoodIntervalPlot::fLineColor = 0. private . line color for the interval (1D) or for other contours (2D) ; Definition at line 74 of file LikelihoodIntervalPlot.h. ◆ fMaximum. double RooStats::LikelihoodIntervalPlot::fMaximum = -1. private . function maximum ; Definition at line 78 of file LikelihoodIntervalPlot.h. ◆ fNdimPlot. Int_t RooStats::LikelihoodIntervalPlot::fNdimPlot = 0. private . Definition at line 75 of file LikelihoodIntervalPlot.h. ◆ fNPoints. Int_t RooStats::LikelihoodIntervalPlot::fNPoints = 0. private . number of points used to scan the PL, default depends if 1D or 2D ; Definition at line 76 of file LikelihoodIntervalPlot.h. ◆ fParamsPlot. RooArgSet* RooStats::LikelihoodIntervalPlot::fParamsPlot = nullptr. private . Definition at line 88 of file LikelihoodIntervalPlot.h. ◆ fPlotObject. TObject* RooStats::LikelihoodIntervalPlot::fPlotObject = nullptr. private . plotted object ; Definition at line 89 of file LikelihoodIntervalPlot.h. ◆ fPrecision. double RooStats::LikelihoodIntervalPlot::fPrecision = -1. private . RooCurve precision, use default in case of -1. ; Definition at line 84 of file LikelihoodIntervalPlot.h. ◆ fXmax. double RooStats::LikelihoodIntervalPlot::fXmax = -1. private . Definition at line 81 of file LikelihoodIntervalPlot.h. ◆ fXmin. double RooStats::LikelihoodIntervalPlot::fXmin = 0. private . Definition at line 80 of file LikelihoodIntervalPlot.h. ◆ fYmax. double RooStats::LikelihoodIntervalPlot::fYmax = -1. private . Definition at line 83 of file LikelihoodIntervalPlot.h. ◆ fYmin. double RooStats::LikelihoodIntervalPlot::fYm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1LikelihoodIntervalPlot.html:23514,depend,depends,23514,doc/master/classRooStats_1_1LikelihoodIntervalPlot.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1LikelihoodIntervalPlot.html,1,['depend'],['depends']
Integrability," Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLStatement. class TSQLStatement: public TObject. TSQLStatement. Abstract base class defining SQL statements, which can be submitted; in bulk to DB server. This is alternative to TSQLServer::Query() method, which allows only pure; text queries and pure text result in TSQLResult classes.; TSQLStatement is designed to support following features:; - usage of basic data types (like int or double) as parameters; in SQL statements; - bulk operation when inserting/updating/selecting data in database; - uasge of basic data types when accessing result set of executed query. 1. Creation of statement. To create an instance of the TSQLStatement class, the TSQLServer::Statement() method; should be used. Depending on the driver used for an ODBC connection,; the appropriate object instance will be created. For the moment there are; six different implementations of the TSQLStatement class: for MySQL,; Oracle, SAPDB, PostgreSQL, SQLite3 and ODBC. Hopefully, support of ODBC will allow usage of; statements for most existing RDBMS. // first, connect to the database; TSQLServer* serv = TSQLServer::Connect(""mysql://hostname.domain:3306/test"",; ""user"", ""pass"");; // check if connection is ok; if ((serv!=0) && serv->IsConnected()) {; // create instance of sql-statement; TSQLStatement* stmt = serv->Statement(""CREATE TABLE TESTTABLE (ID1 INT, ID2 INT, FFIELD VARCHAR(255), FVALUE VARCHAR(255))"";; // process statement; stmt->Process();; // destroy object; delete stmt;; }; delete serv;. 2. Insert data to data base. There is a special syntax of SQL queries which allows to use values; provided as parameters. For instance, to insert one row into the TESTTABLE created; with the previous example, one can simply execute a query like:. serv->Query(""INSERT IN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLStatement.html:972,Depend,Depending,972,root/html602/TSQLStatement.html,https://root.cern,https://root.cern/root/html602/TSQLStatement.html,2,['Depend'],['Depending']
Integrability," List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » About Previous Developers. The following people have been working on ROOT for some time in their career and ROOT would not be what it is without their contributions:; Andrei Gheata; Andrei works since 2001 in the offline group of the ALICE experiment. He is an experimental nuclear physicist who worked before ALICE on data analysis for heavy-ion experiments in emulsions. In 2000 he started collaborating with the ROOT project and implemented the TreeViewer interface. Andrei is the main developer of the ROOT geometry package. He integrated the geometry in the Virtual Monte Carlo framework by developing interfaces for the GEANT3, GEANT4 and FLUKA particle transport engines.; Anna Kreshuk; Anna was a project associate and contributed to different parts of ROOT, most notably to the fitting machinery, the interface to FFTW, numerous math-related functions, TEntryList container and PROOF GUI.; David Gonzalez Maline; David has been working on improving the performance and correctness of various mathematical algorithms as well as on integrating AI methods for data analysis inside the framework. He has also worked on extending and improving the FitPanel interface.; Diego Marcos Segura; Diego worked as technical student on CINT dictionary optimizations.; Eddy Offermann; Eddy joined the ROOT team during a sabbatical to work on making the ROOT matrix package the fastest and most versatile in the industry.; Ilka ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/previous-developers.html:2315,interface,interface,2315,d/previous-developers.html,https://root.cern,https://root.cern/d/previous-developers.html,1,['interface'],['interface']
Integrability," Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. TStringfAuthProtoUsed to specific the auth protocol; TStringfDiskServerCASTOR remote disk server; TStringfInternalPathCASTOR internal path; Bool_tfIsCastortrue if internal path is valid; Bool_tfWrittenTotrue if data has been written to file. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCastorFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Create a TCastorFile. A TCastorFile is like a normal TNetFile except; that it obtains the remote node (disk server) via the CASTOR API, once; the disk server and the local file path are determined, the file will; be accessed via the rootd daemon. File names have to be specified like:; castor:/castor/cern.ch/user/r/rdm/bla.root.; The other arguments are the same as for TNetFile and TFile. void FindServerAndPath(); Find the CASTOR disk server and internal file path. Int_t SysClose(Int_t fd); Close currently open file. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. void Con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TCastorFile.html:23787,protocol,protocol,23787,root/html530/TCastorFile.html,https://root.cern,https://root.cern/root/html530/TCastorFile.html,3,['protocol'],['protocol']
Integrability," Long64_tfRestartAtrestart transmission at specified offset; TSocket*fSocket! connection to rootd; TStringfUserremote user; Int_tfWindowSizetcp window size used; static Long64_tfgBytesReadnumber of bytes received by all TFTP objects; static Long64_tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFTP.html:8407,message,message,8407,root/html528/TFTP.html,https://root.cern,https://root.cern/root/html528/TFTP.html,10,['message'],['message']
Integrability," M parameters; Differently to the version of M there is no limit on the number of parameters, variable or non-variable. Memory allocation is done dynamically according to the actual needs and “on demand”. There is no protection against an upper limit on the number of parameters, however the “technological” limitations of M can be seen around a maximum of 15 free parameters at a time.; 3.6 Interference with other packages; The new M has been designed to interfere as little as possible with other programs or packages which may be loaded at the same time. M is thread safe by default. Optionally the user can select a different way of dynamically allocating memory in the class StackAllacator for M , in which case (and after an entire recompilation of the whole library) the thread safety is lost.; 3.7 Floating-point precision; [install:epsmac]; M is entirely based on double precision. The actual floating point precision of double precision (32–bit or 64–bit) is platform dependent and can even vary on the same platform, depending on whether a floating point number is read from memory a CPU register.; The argument of the user’s implementation of FCNBase::operator() is therefore a std:vector\(<\)double\(>\). M expects that the calculations inside \(\mbox{FCN}\) will be performed approximately to the same accuracy.; The accuracy M expects is called machine precision (MnMachinePrecision, see [api:epsmac]) and can be printed on demand using std::cout. If the user fools M by making internal \(\mbox{FCN}\) computations in single precision, M will interpret roundoff noise as significant and will usually either fail to find a minimum, or give incorrect values for the parameter errors.; It is therefore recommended to make sure that all computations in \(\mbox{FCN}\), as well as all methods and functions called by \(\mbox{FCN}\), are done in double precision. If for some reason the computations cannot be done to a precision comparable with that expected by M , the user must inform M ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:27950,depend,dependent,27950,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,4,['depend'],"['dependent', 'depending']"
Integrability," Matches. Namespaces ; rf506_msgservice.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; Organization and simultaneous fits: tuning and customizing the ROOT.RooFit message logging facility ; ; import ROOT; ; # Create pdf; # --------------------; ; # Construct gauss(x,m,s); x = ROOT.RooRealVar(""x"", ""x"", -10, 10); m = ROOT.RooRealVar(""m"", ""m"", 0, -10, 10); s = ROOT.RooRealVar(""s"", ""s"", 1, -10, 10); gauss = ROOT.RooGaussian(""g"", ""g"", x, m, s); ; # Construct poly(x,p0); p0 = ROOT.RooRealVar(""p0"", ""p0"", 0.01, 0.0, 1.0); poly = ROOT.RooPolynomial(""p"", ""p"", x, [p0]); ; # model = f*gauss(x) + (1-f)*poly(x); f = ROOT.RooRealVar(""f"", ""f"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [gauss, poly], [f]); ; data = model.generate({x}, 10); ; # Print configuration of message service; # ------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Adding integration topic to existing INFO stream; # ---------------------------------------------------; ; # Print streams configuration; ROOT.RooMsgService.instance().Print(); ; # Add Integration topic to existing INFO stream; ROOT.RooMsgService.instance().getStream(1).addTopic(ROOT.RooFit.Integration); ; # Construct integral over gauss to demonstrate message stream; igauss = gauss.createIntegral({x}); igauss.Print(); ; # Print streams configuration in verbose, also shows inactive streams; ROOT.RooMsgService.instance().Print(); ; # Remove stream; ROOT.RooMsgService.instance().getStream(1).removeTopic(ROOT.RooFit.Integration); ; # Examples of pdf value tracing; # -----------------------------------------------------------------------; ; # Show DEBUG level message on function tracing, ROOT.RooGaussian only; ROOT.RooMsgService.instance().addStream(ROOT.RooFit.DEBUG, Topic=ROOT.RooFit.Tracing, ClassName=""RooGaussian""); ; # Perform a fit to generate some tracing messages; model.fitTo(data, Verbose=True); ; # Reset message service to default stream confi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8py.html:1074,integrat,integration,1074,doc/master/rf506__msgservice_8py.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8py.html,1,['integrat'],['integration']
Integrability," Matrix_t &weights);  Perform a single optimization step on a given batch. ;  ; template<typename Net_t > ; Scalar_t StepLoss (Net_t &net, Matrix_t &input, const Matrix_t &output, const Matrix_t &weights);  Same as Step(...) but also evaluate the loss on the given training data. ;  ; template<typename Net_t > ; auto StepLoss (Net_t &net, Matrix_t &input, const Matrix_t &output, const Matrix_t &weights) -> Scalar_t;  ; template<typename Net_t > ; void StepMomentum (Net_t &master, std::vector< Net_t > &nets, std::vector< TBatch< Architecture_t > > &batches, Scalar_t momentum);  Same as the Step(...) method for multiple batches but uses momentum. ;  ; template<typename Net_t > ; void StepNesterov (Net_t &master, std::vector< Net_t > &nets, std::vector< TBatch< Architecture_t > > &batches, Scalar_t momentum);  Same as the Step(...) method for multiple batches but uses Nesterov momentum. ;  ; template<typename Net_t > ; void StepReducedWeights (Net_t &net, Matrix_t &input, const Matrix_t &output);  Does not evaluate the loss and therefore not trigger a possible synchronization with the device. ;  ; template<typename Net_t > ; Scalar_t StepReducedWeightsLoss (Net_t &net, Matrix_t &input, const Matrix_t &output, const Matrix_t &weights);  Similar to StepReducedWeights(...) but also evaluates the loss. ;  ; template<typename Net_t > ; auto StepReducedWeightsLoss (Net_t &net, Matrix_t &input, const Matrix_t &output, const Matrix_t &weights) -> Scalar_t;  ; template<typename Data_t , typename Net_t > ; auto Train (const Data_t &trainingData, size_t nTrainingSamples, const Data_t &testData, size_t nTestSamples, Net_t &net, size_t nThreads) -> Scalar_t;  ; template<typename Data_t , typename Net_t > ; Scalar_t Train (const Data_t &TrainingDataIn, size_t nTrainingSamples, const Data_t &TestDataIn, size_t nTestSamples, Net_t &net, size_t nThreads=1);  Train the given net using the given training input data (events), training output data (labels), test input data (events), test ou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html:2937,synchroniz,synchronization,2937,doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,1,['synchroniz'],['synchronization']
Integrability," Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<vector<double,allocator<double> >*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(nset,0,sterileIndex,isetRangeName). Int_t setObj(const RooArgSet* nset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); Setter function without integration set. return setObj(const RooArgSet* nset, const RooArgSet* iset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0). T* getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeName). void reset(). void sterilize(). Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. T* getObjByIndex(Int_t index) const. const RooNameSet* nameSet1ByIndex(Int_t index) const. const RooNameSet* nameSet2ByIndex(Int_t index) const. void insertObjectHook(vector<double,allocator<double> >& ); Interface function to perform post-insert operations on cached object. void wireCache(). » Last changed: Sat Jun 20 16:42:23 2015 » Last generated: 2015-06-20 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCacheManager_vector_double___.html:4511,Interface,Interface,4511,root/html534/RooCacheManager_vector_double___.html,https://root.cern,https://root.cern/root/html534/RooCacheManager_vector_double___.html,4,['Interface'],['Interface']
Integrability," Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, normalization observables and the integration range name. ;  ; bool isValid () const override;  Check if current value is valid. ;  ; void makeProjectionSet (const RooAbsArg *plotVar, const RooArgSet *allVars, RooArgSet &projectedVars, bool silent) const;  Utility function for plotOn() that constructs the set of observables to project when plotting ourselves as function of 'plotVar'. ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a, const RooArgProxy &b) const;  Utility function for use in getAnalyticalIntegral(). ;  ; bool matchArgs (const RooArgSet &allDeps, RooArgSet &numDeps, const RooArgProxy &a, const RooArgProxy &b, const RooArgProxy &c) const;  Utility function for use in getAnalyticalIntegral().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooErrorVar.html:58883,integrat,integrated,58883,doc/master/classRooErrorVar.html,https://root.cern,https://root.cern/doc/master/classRooErrorVar.html,4,['integrat'],"['integrated', 'integration']"
Integrability," Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from TMVA::IFitterTarget; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Private Member Functions; MsgLogger & Log () const;  . Private Attributes; std::vector< Float_t > fAchievableEff;  ; std::vector< Float_t > fAchievablePur;  ; std::vector< std::vector< Double_t > > fBestCuts;  ; std::vector< Float_t > fClassSumWeights;  ; UInt_t fClassToOptimize;  ; std::vector< UInt_t > fEventClasses;  ; std::vector< Float_t > fEventWeights;  ; MsgLogger * fLogger;  ! message logger ;  ; std::vector< std::vector< Float_t > > fMultiClassValues;  mva values (Results) ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ResultsMulticlass.html:12180,message,message,12180,doc/master/classTMVA_1_1ResultsMulticlass.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ResultsMulticlass.html,1,['message'],['message']
Integrability, Member Functions |; List of all members ; ROOT::Math::IntegratorOneDimOptions Class ReferenceMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Numerical one dimensional integration options. ; Definition at line 113 of file IntegratorOptions.h. Public Member Functions;  IntegratorOneDimOptions (const IntegratorOneDimOptions &rhs);  copy constructor ;  ;  IntegratorOneDimOptions (IOptions *extraOpts=nullptr);  constructor using the default options can pass a pointer to extra options (N.B. ;  ;  ~IntegratorOneDimOptions () override;  ; std::string Integrator () const override;  name of 1D integrator ;  ; IntegrationOneDim::Type IntegratorType () const;  type of the integrator (return the enumeration type) ;  ; unsigned int NPoints () const;  Number of points used by current integration rule. ;  ; IntegratorOneDimOptions & operator= (const IntegratorOneDimOptions &rhs);  assignment operator ;  ; void Print (std::ostream &os=std::cout) const;  print all the options ;  ; void SetIntegrator (const char *name);  set 1D integrator name ;  ; void SetNPoints (unsigned int n);  Set number of points for active integration rule. ;  ;  Public Member Functions inherited from ROOT::Math::BaseIntegratorOptions;  BaseIntegratorOptions (const BaseIntegratorOptions &opt);  ; virtual ~BaseIntegratorOptions ();  protected constructor to avoid user creating this class ;  ; double AbsTolerance () const;  non-static methods for retrieving options ;  ; IOptions * ExtraOptions () const;  return extra options ;  ; BaseIntegratorOptions & operator= (const BaseIntegratorOptions &opt);  assignment operators ;  ; double RelTolerance () const;  absolute tolerance ;  ; void SetAbsTolerance (double tol);  non-static methods for setting options ;  ; void SetExtraOptions (const IOptions &opt);  set extra options (in this case pointer is cloned) ;  ; void SetRelTolerance (double tol);  set the relative tolerance ;  ; void SetWKSize (unsigned int size);  set workspace siz,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDimOptions.html:1267,integrat,integrator,1267,doc/master/classROOT_1_1Math_1_1IntegratorOneDimOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IntegratorOneDimOptions.html,2,['integrat'],"['integration', 'integrator']"
Integrability," Members; Includes; Libraries. Function documentation; TGeoMaterial(); Default constructor. TGeoMaterial(const char* name); constructor. TGeoMaterial(const char* name, Double_t a, Double_t z, Double_t rho, Double_t radlen = 0, Double_t intlen = 0); constructor. TGeoMaterial(const char* name, Double_t a, Double_t z, Double_t rho, TGeoMaterial::EGeoMaterialState state, Double_t temperature = STP_temperature, Double_t pressure = STP_pressure); Constructor with state, temperature and pressure. TGeoMaterial(const char* name, TGeoElement* elem, Double_t rho); constructor. TGeoMaterial(const TGeoMaterial& ); copy constructor. TGeoMaterial& operator=(const TGeoMaterial& ); assignment operator. ~TGeoMaterial(); Destructor. void SetUserExtension(TGeoExtension* ext); Connect user-defined extension to the material. The material ""grabs"" a copy, so; the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for user extensions and is guaranteed not; to be used by TGeo. void SetFWExtension(TGeoExtension* ext); Connect framework defined extension to the material. The material ""grabs"" a copy,; so the original object can be released by the producer. Release the previously; connected extension if any. NOTE: This interface is intended for the use by TGeo and the users should; NOT connect extensions using this method. TGeoExtension * GrabUserExtension() const; Get a copy of the user extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). TGeoExtension * GrabFWExtension() const; Get a copy of the framework extension pointer. The user must call Release() on; the copy pointer once this pointer is not needed anymore (equivalent to; delete() after calling new()). char * GetPointerName() const; Provide a pointer name containing uid. void SetRadLen(Double_t radlen, Double_t intlen = 0.); Set radiation/absorbtion lengt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoMaterial.html:10005,interface,interface,10005,root/html534/TGeoMaterial.html,https://root.cern,https://root.cern/root/html534/TGeoMaterial.html,6,['interface'],['interface']
Integrability," MethodInfo_Next(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9083; TCling::SetAutoLoadCallBackvoid * SetAutoLoadCallBack(void *cb) finalDefinition TCling.h:199; TCling::ClassInfo_ClassPropertyLong_t ClassInfo_ClassProperty(ClassInfo_t *info) const finalDefinition TCling.cxx:8176; TCling::MethodInfo_Deletevoid MethodInfo_Delete(MethodInfo_t *minfo) const finalInterface to cling function.Definition TCling.cxx:9002; TCling::fIsShuttingDownbool fIsShuttingDownDefinition TCling.h:187; TCling::MethodArgInfo_Deletevoid MethodArgInfo_Delete(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9241; TCling::DataMemberInfo_FactoryDataMemberInfo_t * DataMemberInfo_Factory(ClassInfo_t *clinfo, TDictionary::EMemberSelection selection) const finalDefinition TCling.cxx:8599; TCling::ClassInfo_Destructvoid ClassInfo_Destruct(ClassInfo_t *info, void *arena) const finalDefinition TCling.cxx:8207; TCling::GetClassTClass * GetClass(const std::type_info &typeinfo, Bool_t load) const finalDemangle the name (from the typeinfo) and then request the class via the usual name based interface (...Definition TCling.cxx:6110; TCling::UnloadAllSharedLibraryMapsInt_t UnloadAllSharedLibraryMaps() finalUnload the library map entries coming from all the loaded shared libraries.Definition TCling.cxx:5998; TCling::ClassInfo_Initvoid ClassInfo_Init(ClassInfo_t *info, const char *funcname) const finalDefinition TCling.cxx:8269; TCling::GetModTClassesstd::set< TClass * > & GetModTClasses()Definition TCling.h:579; TCling::BaseClassInfo_ClassInfoClassInfo_t * BaseClassInfo_ClassInfo(BaseClassInfo_t *) const finalDefinition TCling.cxx:8537; TCling::fClingCallbacksTClingCallbacks * fClingCallbacksDefinition TCling.h:139; TCling::CallFunc_ExecInt64Long64_t CallFunc_ExecInt64(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7893; TCling::ClassInfo_PropertyLong_t ClassInfo_Property(ClassInfo_t *info) const finalDefinition TCling.cxx:8392; TCling::ClassInfo_GetBaseOffsetLongptr_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:65847,interface,interface,65847,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['interface'],['interface']
Integrability," Minus Operation Class. More...;  ; struct  MinusEquals;  Evaluate the expression performing a -= operation Need to check whether creating a temporary object with the expression result (like in op: A -= A * B ) More...;  ; struct  MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >;  Specialization for symmetrix -= general : NOT Allowed operation. More...;  ; struct  MinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >;  Specialization for symmetric matrices. More...;  ; struct  MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; class  MixMaxEngine;  MixMaxEngine is a wrapper class for the MIXMAX Random number generator. More...;  ; class  MixMaxEngineImpl;  ; class  MixMaxEngineImpl< ROOT_MM_N >;  ; class  MulOp;  Multiplication (element-wise) Operation Class. More...;  ; class  MultiDimParamFunctionAdapter;  MultiDimParamFunctionAdapter class to wrap a one-dimensional parametric function in a multi dimensional parametric function interface This is used typically in fitting where internally the function is stored as multidimensional. More...;  ; class  MultiDimParamGradFunctionAdapter;  MultiDimParamGradFunctionAdapter class to wrap a one-dimensional parametric gradient function in a multi dimensional parametric gradient function interface This is used typically in fitting where internally the function is stored as multidimensional. More...;  ; class  MultiGenFunctionFitness;  ; class  MultiNumGradFunction;  MultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) More...;  ; struct  MultPolicy;  matrix-matrix multiplication policy More...;  ; struct  NullTypeFunc1D;  ; class  OneDimMultiFunctionAdapter;  OneDimMultiFunctionAdapter class to wrap a multidimensional function in one dimensional one. More...;  ; class  OneDimParamFunctionAdapter;  OneDimParamFunct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:22603,wrap,wrap,22603,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,4,"['interface', 'wrap']","['interface', 'wrap']"
Integrability," Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactoryA factory for building PDFs and data for a number counting combination ;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspectorUtility class to plot conditional MLE of nuisance parameters vs ;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ;  CSamplingDistPlotThis class provides simple and straightforward utilities to plot SamplingDistribution objects ;  CSamplingDistributionThis class simply holds a sampling di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:8130,interface,interface,8130,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,5,['interface'],['interface']
Integrability," More...;  ; class  GSLError;  class to change GSL Error handler to use ROOT one. More...;  ; class  GSLFunctionAdapter;  Class for adapting any C++ functor class to C function pointers used by GSL. More...;  ; class  GSLFunctionDerivWrapper;  class to wrap a gsl_function_fdf (with derivatives) More...;  ; class  GSLFunctionWrapper;  Wrapper class to the gsl_function C structure. More...;  ; class  GSLIntegrationWorkspace;  ; class  GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  GSLInterpolator;  Interpolation class based on GSL interpolation functions. More...;  ; class  GSLMCIntegrationWorkspace;  ; class  GSLMCIntegrator;  ; class  GSLMinimizer;  GSLMinimizer class. More...;  ; class  GSLMinimizer1D;  Minimizer for arbitrary one dimensional functions. More...;  ; class  GSLMiserIntegrationWorkspace;  Workspace for MISER. More...;  ; struct  GSLMonteFunctionAdapter;  ; class  GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; class  GSLMultiFit;  GSLMultiFit, internal class for implementing GSL non linear least square GSL fitting. More...;  ; class  GSLMultiFitFunctionAdapter;  Class for adapting a C++ functor class to C function pointers used by GSL MultiFit Algorithm The templated C++ function class must implement: More...;  ; class  GSLMultiFitFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  GSLMultiMinDerivFunctionWrapper;  Wrapper for a multi-dimensional function with derivatives used in GSL multidim minimization algorithm. More...;  ; struct  GSLMultiMinFunctionAdapter;  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MultiMin algorithms. More...;  ; class  GSLMultiMinFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:10137,wrap,wrapper,10137,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,4,"['integrat', 'wrap']","['integration', 'wrapper']"
Integrability," More...;  ; class  TChainElement;  A TChainElement describes a component of a TChain. More...;  ; class  TCollectionMethodBrowsable;  TCollectionMethodBrowsable extends TCollectionPropertyBrowsable by showing all methods of the collection itself. More...;  ; class  TCollectionPropertyBrowsable;  A tiny browser helper object (and its generator) for adding a virtual (as in ""not actually part of the class"", not in C++ virtual) ""@size()"" method to a collection. More...;  ; class  TCut;  A specialized string object used for TTree selections. More...;  ; class  TEntryList;  A List of entry numbers in a TTree or TChain. More...;  ; class  TEntryListArray;  A list of entries and subentries in a TTree or TChain. More...;  ; class  TEntryListBlock;  Used by TEntryList to store the entry numbers. More...;  ; class  TEntryListFromFile;  Manages entry lists from different files, when they are not loaded in memory at the same time. More...;  ; class  TEventList;   Legacy Code TEventList is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TEventList might still be a valid solution. More...;  ; class  TFriendElement;  A TFriendElement TF describes a TTree object TF in a file. More...;  ; class  ROOT::TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TLeaf;  A TLeaf describes individual elements of a TBranch See TBranch structure in TTree. More...;  ; class  TLeafB;  A TLeaf for an 8 bit Integer data type. More...;  ; class  TLeafC;  A TLeaf for a variable length string. More...;  ; class  TLeafD;  A TLeaf for a 64 bit floating point data type. More...;  ; class  TLeafD32;  A TLeaf for a 24 bit truncated floating point data type. More...;  ; class  TLeafElement;  A TLeaf for the general case when using the branches created via a TStreamerInfo (i.e. More...;  ; cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tree.html:3074,interface,interface,3074,doc/master/group__tree.html,https://root.cern,https://root.cern/doc/master/group__tree.html,1,['interface'],['interface']
Integrability," Multivariate optimisation of signal efficiency; TMVA::MethodDT Analysis of Decision Trees; TMVA::MethodFDA Function Discriminant Analysis; TMVA::MethodFisher Analysis of Fisher discriminant (Fisher or Mahalanobis approach); TMVA::MethodHMatrix H-Matrix method, a simple comparison of chi-squared estimators for signal and background; TMVA::MethodKNN k Nearest Neighbour classifier; TMVA::MethodLD Linear discriminant analysis; TMVA::MethodLikelihood Likelihood analysis (""non-parametric approach""); TMVA::MethodMLP Multi-layer perceptron implemented specifically for TMVA; TMVA::MethodPDEFoam Multi-dimensional probability density estimator using TFoam (PDE-Foam); TMVA::MethodPDERS Multi-dimensional probability density estimator range search (PDERS) method; TMVA::MethodRuleFit Friedman's RuleFit method; TMVA::MethodSVM Support Vector Machine; TMVA::MethodTMlpANN Implementation of interface for TMultiLayerPerceptron; TMVA::MinuitFitter Fitter using a Genetic Algorithm; TMVA::MinuitWrapper Wrapper around TMinuit; TMVA::MisClassificationError Implementation of the MisClassificationError as separation criterion; TMVA::MsgLogger Ostringstream derivative to redirect and format logging output; TMVA::Node Node for the BinarySearch or Decision Trees; TMVA::OptimizeConfigParameters Interface to different separation critiera used in training algorithms; TMVA::PDEFoam Tree of PDEFoamCells; TMVA::PDEFoamCell Single cell of FOAM; TMVA::PDEFoamDecisionTree Decision tree like PDEFoam; TMVA::PDEFoamDecisionTreeDensity Class for decision tree like PDEFoam density; TMVA::PDEFoamDensityBase PDEFoam event density interface; TMVA::PDEFoamDiscriminant Tree of PDEFoamCells; TMVA::PDEFoamDiscriminantDensity Class for Discriminant density; TMVA::PDEFoamEvent Tree of PDEFoamCells; TMVA::PDEFoamEventDensity Class for Event density; TMVA::PDEFoamKernelBase PDEFoam kernel interface; TMVA::PDEFoamKernelGauss Gaussian PDEFoam kernel estimator; TMVA::PDEFoamKernelLinN next neighbor PDEFoam kernel estimato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:102890,Wrap,Wrapper,102890,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['Wrap'],['Wrapper']
Integrability," NDim() const; {; return 2;; }. ROOT::Math::IParametricGradFunctionMultiDim* Clone() const; {; return new MyParametricGradFunction();; }. const double* Parameters() const; {; return pars;; }. void SetParameters(const double* p); {; pars = p;; }. unsigned int NPar() const; {; return 2;; }. double DoParameterDerivative(const double* x, const double* p,; unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]) + p[1];; else; return p[0] * x[0] + x[1] * cos(x[1]) + p[1];; }; };; 13.7.4 Wrapper Functions; To facilitate the user to insert their own type of function in the needed function interface, helper classes, wrapping the user interface in the ROOT::Math function interfaces are provided. this will avoid the user to re-implement dedicated function classes, following the code example shown in the previous paragraphs.; There is one possible wrapper for every interface explained in the previous section. The following table indicates the wrapper for the most basic ones:. Interface; Function Wrapper. ROOT::Math::IBaseFunctionOneDim; ROOT::Math::Functor1D. ROOT::Math::IGradientFunctionOneDim; ROOT::Math::GradFunctor1D. ROOT::Math::IBaseFunctionMultiDim; ROOT::Math::Functor. ROOT::Math::IGradientFunctionMultiDim; ROOT::Math::GradFunctor. Thee functor wrapper are defined in the header file Math/Functor.h.; 13.7.4.1 Wrapping One Dimensional Functions; The ROOT::Math::Functor1D is used to wrap one-dimensional functions It can wrap all the following types: * A free C function of type double ()(double ). * Any C++ callable object implementation double operator()( double ). * A class member function with the correct signature like double Foo::Eval(double ). In this case one pass the object pointer and a pointer to the member function (&Foo::Eval).; Example:; #include ""Math/Functor.h"". class MyFunction1D {. public:. double operator()(double x) const {; return x*x;; }. double Eval(double x) const { return x+x; }; };. double freeFunction1D(double x ) {; return 2*x;; }. int main",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:694169,Interface,Interface,694169,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,"['Interface', 'Wrap']","['Interface', 'Wrapper']"
Integrability," Namespaces |; Macros |; Typedefs |; Functions |; Variables ; RooLagrangianMorphFunc.cxx File Reference. #include ""Riostream.h""; #include ""RooAbsCollection.h""; #include ""RooArgList.h""; #include ""RooArgProxy.h""; #include ""RooArgSet.h""; #include ""RooBinning.h""; #include ""RooDataHist.h""; #include ""RooFormulaVar.h""; #include ""RooHistFunc.h""; #include ""RooLagrangianMorphFunc.h""; #include ""RooLinearCombination.h""; #include ""RooParamHistFunc.h""; #include ""RooProduct.h""; #include ""RooRealVar.h""; #include ""RooWorkspace.h""; #include ""RooFactoryWSTool.h""; #include ""ROOT/StringUtils.hxx""; #include ""TFile.h""; #include ""TFolder.h""; #include ""TH1.h""; #include ""TMap.h""; #include ""TParameter.h""; #include ""TRandom3.h""; #include <algorithm>; #include <array>; #include <cmath>; #include <cstddef>; #include <iostream>; #include <limits>; #include <map>; #include <memory>; #include <sstream>; #include <stdexcept>; #include <type_traits>; #include <typeinfo>; #include ""TDecompLU.h"". Include dependency graph for RooLagrangianMorphFunc.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  RooLagrangianMorphFunc::CacheElem;  ; struct  is_specialization< Test, Ref >;  ; struct  is_specialization< Ref< Args... >, Ref >;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Macros; #define NaN   std::numeric_limits<double>::quiet_NaN();  . Typedefs; typedef TMatrixD Matrix;  . Functions; Matrix diagMatrix (size_t n);  create a new diagonal matrix of size n ;  ; double invertMatrix (const Matrix &matrix, Matrix &inverse);  ; TMatrixD makeRootMatrix (const Matrix &in);  convert a matrix into a TMatrixD ;  ; Matrix makeSuperMatrix (const TMatrixD &in);  convert a TMatrixD into a Matrix ;  ; void printMatrix (const TMatrixD &mat);  write a matrix ;  ; template<class MatrixT > ; size_t size (const MatrixT &mat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooLagrangianMorphFunc_8cxx.html:1143,depend,dependency,1143,doc/master/RooLagrangianMorphFunc_8cxx.html,https://root.cern,https://root.cern/doc/master/RooLagrangianMorphFunc_8cxx.html,2,['depend'],['dependency']
Integrability," Namespaces; namespace  ExtraArgsForDefine;  . Classes; class  RActionImpl;  Base class for action helpers, see RInterface::Book() for more information. More...;  ; struct  RCallCleanUpTask;  A RAII object that calls RLoopManager::CleanUpTask at destruction. More...;  ; class  RColumnReaderBase;  ; class  RDefaultValueFor;  The implementation of the DefaultValueFor transformation. More...;  ; class  RDefine;  ; class  RDefineBase;  ; class  RDefinePerSample;  ; class  RFilter;  ; class  RFilterBase;  ; class  RFilterWithMissingValues;  implementation of FilterAvailable and FilterMissing operations More...;  ; struct  RInferredType;  ; class  RJittedDefine;  A wrapper around a concrete RDefine, which forwards all calls to it RJittedDefine is a placeholder that is put in the collection of custom columns in place of a RDefine that will be just-in-time compiled. More...;  ; class  RJittedFilter;  A wrapper around a concrete RFilter, which forwards all calls to it RJittedFilter is the type of the node returned by jitted Filter calls: the concrete filter can be created and set at a later time, from jitted code. More...;  ; class  RLoopManager;  The head node of a RDF computation graph. More...;  ; class  RMergeableCount;  Specialization of RMergeableValue for the Count action. More...;  ; class  RMergeableFill;  Specialization of RMergeableValue for histograms and statistics. More...;  ; class  RMergeableMax;  ; class  RMergeableMean;  Specialization of RMergeableValue for the Mean action. More...;  ; class  RMergeableMin;  ; class  RMergeableStdDev;  Specialization of RMergeableValue for the StdDev action. More...;  ; class  RMergeableSum;  ; class  RMergeableValue;  A result of an RDataFrame execution, that knows how to merge with other results of the same type. More...;  ; class  RMergeableValueBase;  Base class of RMergeableValue. More...;  ; class  RMergeableVariations;  A container for variation names and variation results that knows how to merge with others of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Detail_1_1RDF.html:1111,wrap,wrapper,1111,doc/master/namespaceROOT_1_1Detail_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Detail_1_1RDF.html,1,['wrap'],['wrapper']
Integrability," Neff ); 7549 Double_t stddev = GetStdDev(axis-10);; 7550 Double_t neff = GetEffectiveEntries();; 7551 return ( neff > 0 ? stddev/TMath::Sqrt(neff) : 0. );; 7552 }; 7553}; 7554 ; 7555////////////////////////////////////////////////////////////////////////////////; 7556/// Return standard error of mean of this histogram along the X axis.; 7557///; 7558/// Note that the mean value/StdDev is computed using the bins in the currently; 7559/// defined range (see TAxis::SetRange). By default the range includes; 7560/// all bins from 1 to nbins included, excluding underflows and overflows.; 7561/// To force the underflows and overflows in the computation, one must; 7562/// call the static function TH1::StatOverflows(kTRUE) before filling; 7563/// the histogram.; 7564///; 7565/// Also note, that although the definition of standard error doesn't include the; 7566/// assumption of normality, many uses of this feature implicitly assume it.; 7567///; 7568/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7569/// are calculated. By default, if no range has been set, the returned value is; 7570/// the (unbinned) one calculated at fill time. If a range has been set, however,; 7571/// the value is calculated using the bins in range, as described above; THIS; 7572/// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; 7573/// the range. To ensure that the returned value (and all other statistics) is; 7574/// always that of the binned data stored in the histogram, call TH1::ResetStats.; 7575/// See TH1::GetStats.; 7576 ; 7577Double_t TH1::GetMeanError(Int_t axis) const; 7578{; 7579 return GetMean(axis+10);; 7580}; 7581 ; 7582////////////////////////////////////////////////////////////////////////////////; 7583/// Returns the Standard Deviation (Sigma).; 7584/// The Sigma estimate is computed as; 7585/// \f[; 7586/// \sqrt{\frac{1}{N}(\sum(x_i-x_{mean})^2)}; 7587/// \f]; 7588/// For axis = 1,2 or 3 returns the Sigma value of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:295253,depend,depends,295253,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['depend'],['depends']
Integrability," Number, Double_t *Stops, Double_t *Red, Double_t *Green, Double_t *Blue, UInt_t NColors, Float_t alpha=1., Bool_t setPalette=kTRUE);  Static function creating a color table with several connected linear gradients. ;  ; static const char * DeclFileName ();  ; static Bool_t DefinedColors (Int_t set_always_on=0);  Static method returning kTRUE if some new colors have been defined after initialisation or since the last call to this method. ;  ; static Int_t GetColor (const char *hexcolor);  Static method returning color number for color specified by hex color string of form: ""#rrggbb"", where rr, gg and bb are in hex between [0,FF], e.g. ;  ; static Int_t GetColor (Float_t r, Float_t g, Float_t b, Float_t a=1.);  Static method returning color number for color specified by r, g and b. ;  ; static Int_t GetColor (Int_t r, Int_t g, Int_t b, Float_t a=1.);  Static method returning color number for color specified by r, g and b. ;  ; static Int_t GetColor (ULong_t pixel);  Static method returning color number for color specified by system dependent pixel value. ;  ; static Int_t GetColorBright (Int_t color);  Static function: Returns the bright color number corresponding to n If the TColor object does not exist, it is created at a free color index. ;  ; static Int_t GetColorByName (const char *colorname);  Static method returning color index for a color specified by name. ;  ; static Int_t GetColorDark (Int_t color);  Static function: Returns the dark color number corresponding to n If the TColor object does not exist, it is created at a free color index. ;  ; static Int_t GetColorPalette (Int_t i);  Static function returning the color number i in current palette. ;  ; static Int_t GetColorTransparent (Int_t color, Float_t a);  Static function: Returns the transparent color number corresponding to n. ;  ; static Int_t GetFirstFreeColorIndex ();  Static function: Returns the first free color greater in the list of colors. ;  ; static Int_t GetFreeColorIndex ();  Static functio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:36655,depend,dependent,36655,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,4,['depend'],['dependent']
Integrability," Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__MCIntegration.html:1270,integrat,integration,1270,doc/master/group__MCIntegration.html,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html,1,['integrat'],['integration']
Integrability," One could configure argument(s) for the command. For that one should use %arg1, %arg2 and so on identifiers. Like:; serv->RegisterCommand(""/DoSomething"", ""SomeFunction(%arg1%,%arg2%)"");; User will be requested to enter arguments values, when command element clicked in the browser. Example of the command which executes arbitrary string in application via ProcessLine looks like:; serv->RegisterCommand(""/Process"", ""%arg1%"");; When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"", ""rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.5 Customize user interface; JSROOT is used to implement UI for the THttpServer. Default webpage shows list of registered objects on the left side and drawing area on the right side - see example. JSROOT allows to configure different parameters via URL - like monitoring interval or name of displayed items item=Files/job1.root/hpxpy&opt=colz&monitoring=1000.; Some of such parameters can be configured already on the server:; serv->SetItemField(""/"", ""_monitoring"", ""1000""); // monitoring interval in ms; serv->SetItemField(""/"", ""_drawitem"", ""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; In such case URL parameters are not required - specified item will be displayed automatically when web page is opened. One also can configure to display several items at once. For that one also can configure layout of the drawing area:; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; ser",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:6023,interface,interface,6023,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,2,['interface'],['interface']
Integrability," Operation Class ;  CAddPolicyMatrix addition policy ;  CAddPolicy< T, D1, D2, MatRepSym< T, D1 >, MatRepSym< T, D1 > >;  CAssignStructure to assign from an expression based to general matrix to general matrix ;  CAssign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepStd< T, D1, D2 > >Dummy Structure which flags an error to avoid assigment from expression based on a general matrix to a symmetric matrix ;  CAssign< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Structure to assign from an expression based to symmetric matrix to symmetric matrix ;  CAssignItrStructure for assignment to a general matrix from iterator ;  CAssignItr< T, D1, D2, MatRepSym< T, D1 > >Specialized structure for assignment to a symmetrix matrix from iterator ;  CAssignSymForce Expression evaluation from general to symmetric ;  CAxisAngleAxisAngle class describing rotation represented with direction axis (3D Vector) and an angle of rotation around that axis ;  CBaseIntegratorOptionsBase class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user ;  CBasicFitMethodFunctionFitMethodFunction class Interface for objective functions (like chi2 and likelihood used in the fit) In addition to normal function interface provide interface for calculating each data contrinution to the function which is required by some algorithm (like Fumili) ;  CBasicMinimizerBase Minimizer class, which defines the basic funcionality of various minimizer implementations (apart from Minuit and Minuit2) It provides support for storing parameter values, step size, parameter transofrmation etc ;  CBinaryOpBinaryOperation class A class representing binary operators in the parse tree ;  CBinaryOpCopyLBinary Operation class with value storage for the left argument ;  CBinaryOpCopyRBinary Operation class with value storage for the right argument ;  CBoostLorentz boost class with the (4D) transformation represented internally by a 4x4 orthos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:25216,integrat,integration,25216,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,8,['integrat'],['integration']
Integrability," Option_t* opt = """"); Override of virtual TVirtualViewer3D::ObjectPaint().; Special handling of 2D/3D histograms to activate Timur's; histo-painters. void PadPaintFromViewer(TGLViewer* viewer); Entry point for requesting update of scene's contents from; gl-viewer. void PadPaint(TVirtualPad* pad); Entry point for updating scene contents via VirtualViewer3D; interface.; For now this is handled by TGLViewer as it remains; the 'Viewer3D' of given pad. void BeginScene(); Start building of the scene.; Old contents is dropped, unless smart-refresh is in active. Then; the object supporting it are kept in a cache and possibly reused. TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void EndScene(); End building of the scene.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the viewer, using internal physical IDs; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Int_t AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an object to the scene, using an external physical ID; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. Bool_t OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); Open new composite container.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void CloseComposite(); Close composite container; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. void AddCompositeOp(UInt_t operation); Add composite operation used to combine objects added via AddObject; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx; for description of viewer architecture. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLScenePad.html:14234,interface,interface,14234,root/html528/TGLScenePad.html,https://root.cern,https://root.cern/root/html528/TGLScenePad.html,10,['interface'],['interface']
Integrability," Option_t* opt = 0); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. static voidGetPrefix(const char* url, TString& pfx). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TStringfPrefixprefix to prepend to requests; TNetSystem*fSysteminstance of the admin interface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void GetPrefix(const char* url, TString& pfx). TNetFileStager(const char* stager = """"). virtual ~TNetFileStager(). Bool_t IsStaged(const char* path). Int_t Locate(const char* path, TString& endpath). Bool_t Matches(const char* s). Bool_t IsValid() const; { return (fSystem ? kTRUE : kFALSE); }. void Print(Option_t* option = """") const. » Author: G. Ganis Feb 2011 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/netx:$Id: TNetFileStager.h 38220 2011-02-25 10:14:53Z rdm $ » Last generated: 2011-07-04 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TNetFileStager.html:6131,interface,interface,6131,root/html530/TNetFileStager.html,https://root.cern,https://root.cern/root/html530/TNetFileStager.html,1,['interface'],['interface']
Integrability," Option_t* opt = 0); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. static voidGetPrefix(const char* url, TString& pfx). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TStringfPrefixprefix to prepend to requests; TNetSystem*fSysteminstance of the admin interface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void GetPrefix(const char* url, TString& pfx). TNetFileStager(const char* stager = """"). virtual ~TNetFileStager(). Bool_t IsStaged(const char* path). Int_t Locate(const char* path, TString& endpath). Bool_t Matches(const char* s). Bool_t IsValid() const; { return (fSystem ? kTRUE : kFALSE); }. void Print(Option_t* option = """") const. » Author: G. Ganis Feb 2011 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/netx:$Id: TNetFileStager.h 38220 2011-02-25 10:14:53Z rdm $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNetFileStager.html:6131,interface,interface,6131,root/html532/TNetFileStager.html,https://root.cern,https://root.cern/root/html532/TNetFileStager.html,2,['interface'],['interface']
Integrability," PDEFoamDensityBase * GetDistr () const;  ; void Grow ();  Internal subprogram used by Create. ;  ; void InitCells ();  Internal subprogram used by Create. ;  ; void MakeAlpha ();  Internal subprogram used by Create. ;  ; void OutputGrow (Bool_t finished=false);  Overridden function of PDEFoam to avoid native foam output. ;  ; Long_t PeekMax ();  Internal subprogram used by Create. ;  ; void SetCellElement (PDEFoamCell *cell, UInt_t i, Double_t value);  Set cell element i of cell to value. ;  ; template<typename T > ; T Sqr (T x) const;  ; void Varedu (Double_t[5], Int_t &, Double_t &, Double_t &);  Internal subprogram used by Create. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; UInt_t fClass;  ;  Protected Attributes inherited from TMVA::PDEFoam; Double_t * fAlpha;  [fDim] Internal parameters of the hyperrectangle ;  ; PDEFoamCell ** fCells;  [fNCells] Array of ALL cells ;  ; Int_t fDim;  Dimension of the integration/simulation space. ;  ; PDEFoamDensityBase * fDistr;  ! distribution of training events ;  ; EDTSeparation fDTSeparation;  BACKWARDS COMPATIBILITY: split cells according to decision tree logic. ;  ; Int_t fEvPerBin;  Maximum number of effective (wt=1) events per bin. ;  ; Bool_t fFillFoamWithOrigWeights;  BACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights. ;  ; EFoamType fFoamType;  BACKWARDS COMPATIBILITY: type of foam. ;  ; TObjArray * fHistEdg;  Histograms of wt, one for each cell edge. ;  ; Int_t * fInhiDiv;  ! [fDim] Flags for inhibiting cell division ;  ; Int_t fLastCe;  Index of the last cell. ;  ; MsgLogger * fLogger;  ! message logger ;  ; Int_t * fMaskDiv;  ! [fDim] Dynamic Mask for cell division ;  ; UInt_t fMaxDepth;  maximum depth of cell tree ;  ; TString fName;  Name of a given instance of the FOAM class. ;  ; Int_t fNBin;  No. of bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDEFoamDiscriminant.html:16093,integrat,integration,16093,doc/master/classTMVA_1_1PDEFoamDiscriminant.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDEFoamDiscriminant.html,1,['integrat'],['integration']
Integrability," PDEFoamDensityBase * GetDistr () const;  ; void Grow ();  Internal subprogram used by Create. ;  ; void InitCells ();  Internal subprogram used by Create. ;  ; void MakeAlpha ();  Internal subprogram used by Create. ;  ; void OutputGrow (Bool_t finished=false);  Overridden function of PDEFoam to avoid native foam output. ;  ; Long_t PeekMax ();  Internal subprogram used by Create. ;  ; void SetCellElement (PDEFoamCell *cell, UInt_t i, Double_t value);  Set cell element i of cell to value. ;  ; template<typename T > ; T Sqr (T x) const;  ; void Varedu (Double_t[5], Int_t &, Double_t &, Double_t &);  Internal subprogram used by Create. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; UInt_t fTarget;  ;  Protected Attributes inherited from TMVA::PDEFoam; Double_t * fAlpha;  [fDim] Internal parameters of the hyperrectangle ;  ; PDEFoamCell ** fCells;  [fNCells] Array of ALL cells ;  ; Int_t fDim;  Dimension of the integration/simulation space. ;  ; PDEFoamDensityBase * fDistr;  ! distribution of training events ;  ; EDTSeparation fDTSeparation;  BACKWARDS COMPATIBILITY: split cells according to decision tree logic. ;  ; Int_t fEvPerBin;  Maximum number of effective (wt=1) events per bin. ;  ; Bool_t fFillFoamWithOrigWeights;  BACKWARDS COMPATIBILITY: fill the foam with boost or orig. weights. ;  ; EFoamType fFoamType;  BACKWARDS COMPATIBILITY: type of foam. ;  ; TObjArray * fHistEdg;  Histograms of wt, one for each cell edge. ;  ; Int_t * fInhiDiv;  ! [fDim] Flags for inhibiting cell division ;  ; Int_t fLastCe;  Index of the last cell. ;  ; MsgLogger * fLogger;  ! message logger ;  ; Int_t * fMaskDiv;  ! [fDim] Dynamic Mask for cell division ;  ; UInt_t fMaxDepth;  maximum depth of cell tree ;  ; TString fName;  Name of a given instance of the FOAM class. ;  ; Int_t fNBin;  No. of bi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1PDEFoamTarget.html:16542,integrat,integration,16542,doc/master/classTMVA_1_1PDEFoamTarget.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1PDEFoamTarget.html,1,['integrat'],['integration']
Integrability," Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copt ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally speci",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUrl.html:7923,protocol,protocols,7923,root/html528/TUrl.html,https://root.cern,https://root.cern/root/html528/TUrl.html,8,['protocol'],['protocols']
Integrability," Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copy ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally speci",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUrl.html:8051,protocol,protocols,8051,root/html534/TUrl.html,https://root.cern,https://root.cern/root/html534/TUrl.html,12,['protocol'],['protocols']
Integrability," PiecewiseInterpolation(). PiecewiseInterpolation(const char* name, const char* title, const RooAbsReal& nominal, const RooArgList& lowSet, const RooArgList& highSet, const RooArgList& paramSet, Bool_t takeOwnerShip = kFALSE); Constructor with two set of RooAbsReals. The value of the function will be. A = sum_i lowSet(i)*highSet(i). If takeOwnership is true the PiecewiseInterpolation object will take ownership of the arguments in sumSet. PiecewiseInterpolation(const PiecewiseInterpolation& other, const char* name = 0); Copy constructor. ~PiecewiseInterpolation(); Destructor. Double_t evaluate() const; Calculate and return current value of self. Bool_t setBinIntegrator(RooArgSet& allVars). Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implement analytical integrations by doing appropriate weighting from component integrals; functions to integrators of components. void setInterpCode(RooAbsReal& param, int code). void setAllInterpCodes(int code). void printAllInterpCodes(). std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; WVE note: assumes nominal and alternates have identical structure, must add explicit check. Bool_t isBinnedDistribution(const RooArgSet& obs) const; WVE note: assumes nominal and alternates have identical structure, must add explicit check. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const. void Streamer(TBuffer& ); Stream an object of class PiecewiseInterpolation. TObject* clone(const char* newname) const; { return new PiecewiseInterpolation(*this, newname); }. const RooArgList& lowList() const; virtual Double_t defaultErrorLevel() const ;; void printMetaArgs(std::ostream& os) const ;. { return _lowSet ; }. const RooArgList& highList(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/PiecewiseInterpolation.html:37350,integrat,integrations,37350,root/html534/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html534/PiecewiseInterpolation.html,12,['integrat'],"['integrations', 'integrators']"
Integrability," PiecewiseInterpolation(). PiecewiseInterpolation(const char* name, const char* title, const RooAbsReal& nominal, const RooArgList& lowSet, const RooArgList& highSet, const RooArgList& paramSet, Bool_t takeOwnerShip = kFALSE); Constructor with two set of RooAbsReals. The value of the function will be. A = sum_i lowSet(i)*highSet(i). If takeOwnership is true the PiecewiseInterpolation object will take ownership of the arguments in sumSet. PiecewiseInterpolation(const PiecewiseInterpolation& other, const char* name = 0); Copy constructor. ~PiecewiseInterpolation(); Destructor. Double_t evaluate() const; Calculate and return current value of self. Bool_t setBinIntegrator(RooArgSet& allVars). Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertise that all integrals can be handled internally. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implement analytical integrations by doing appropriate weighting from component integrals; functions to integrators of components. void setInterpCode(RooAbsReal& param, int code). void setAllInterpCodes(int code). void printAllInterpCodes(). std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; WVE note: assumes nominal and alternates have identical structure, must add explicit check. Bool_t isBinnedDistribution(const RooArgSet& obs) const; WVE note: assumes nominal and alternates have identical structure, must add explicit check. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const. void Streamer(TBuffer& b); Stream an object of class PiecewiseInterpolation. TObject* clone(const char* newname) const; { return new PiecewiseInterpolation(*this, newname); }. const RooArgList& lowList() const; virtual Double_t defaultErrorLevel() const ;; void printMetaArgs(ostream& os) const ;. { return _lowSet ; }. const RooArgList& highList() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/PiecewiseInterpolation.html:35489,integrat,integrations,35489,root/html532/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html532/PiecewiseInterpolation.html,2,['integrat'],"['integrations', 'integrators']"
Integrability, Polynomial function; RooPolynomial Polynomial PDF; RooPrintable Interface for printable objects; RooProdGenContext Context for efficient generation of a a dataset from a RooProdPdf; RooProdPdf PDF representing a product of PDFs; RooProduct Product of RooAbsReal and/or RooAbsCategory terms; RooProfileLL Real-valued function representing profile likelihood of external (likelihood) function; RooProjectedPdf Operator p.d.f calculating projection of another p.d.f; RooProofDriverSelector ; RooPullVar Calculation of pull of measurement w.r.t a truth value; RooQuasiRandomGenerator Quasi-random number generator; RooRandom Random number generator interface; RooRandomizeParamMCSModule MCStudy module to vary one or more input parameters during fit/generation cycle; RooRangeBinning Binning that only defines the total range; RooRealAnalytic Function binding to an analytical integral of a RooAbsReal; RooRealBinding Function binding to RooAbsReal object; RooRealConstant RooRealVar constants factory; RooRealIntegral Real-valued function representing an integral over a RooAbsReal object; RooRealMPFE Multi-process front-end for parallel calculation of a real valued function ; RooRealProxy Proxy for a RooAbsReal object; RooRealSumPdf PDF constructed from a sum of (non-pdf) functions; RooRealVar Real-valued variable ; RooRealVarSharedProperties Shared properties of a RooRealVar clone set; RooRecursiveFraction Recursive fraction formula f1*(1-f2)*(1-f3) etc...; RooRefCountList RooLinkedList with reference counting; RooResolutionModel Abstract Resolution Model; RooScaledFunc Function binding applying scaling to another function binding; RooSegmentedIntegrator1D 1-dimensional piece-wise numerical integration engine; RooSegmentedIntegrator2D 2-dimensional piece-wise numerical integration engine; RooSentinel ; RooSetPair Utility class holding a pair of RooArgSet pointers; RooSetProxy Proxy class for a RooArgSet; RooSharedProperties Abstract interface for shared property implementations; RooS,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:39839,interface,interface,39839,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['interface'],['interface']
Integrability," Prohibit server redirects -- Debugging tool; RooObjCacheManager_projCacheMgrManager of cache with coefficient projections and transformations; Bool_t_projectCoefsIf true coefficients need to be projected for use in evaluate(); TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; RooSetProxy_refCoefNorm! Reference observable set for coefficient interpretation; TNamed*_refCoefRangeName! Reference range name for coefficient interpreation; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooArgList*_snormList! List of supplemental normalization factors; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddModel.html:43067,integrat,integrator,43067,root/html532/RooAddModel.html,https://root.cern,https://root.cern/root/html532/RooAddModel.html,1,['integrat'],['integrator']
Integrability," Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsSelfCachedReal(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Fill cache with sampling of function as defined by the evaluate() implementation. RooArgSet* actualObservables(const RooArgSet& nset) const; Defines observables to be cached, given a set of user defined observables; Returns the subset of nset that are observables this p.d.f. RooArgSet* actualParameters(const RooArgSet& nset) const; Defines parameters on which cache contents depends. Returns; subset of variables of self that is not contained in the; supplied nset. const char* inputBaseName() const; Use own name as base name for caches. » Last changed: Thu Sep 23 19:58:19 2010 » Last generated: 2010-09-23 19:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsSelfCachedReal.html:34674,depend,depends,34674,root/html528/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html528/RooAbsSelfCachedReal.html,1,['depend'],['depends']
Integrability," Protected Attributes; std::map< Int_t, AnaIntConfig > _anaIntMap;  ! Map for analytical integration codes ;  ; RooAICRegistry _anaReg;  ! Registry for analytical integration codes ;  ; RooObjCacheManager _cacheMgr;  ; Int_t _ipOrder;  The cache manager. ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:73009,integrat,integration,73009,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,1,['integrat'],['integration']
Integrability," Public Member Functions; virtual ~TSQLStatement ()=default;  ; virtual void Close (Option_t *="""");  ; virtual void EnableErrorOutput (Bool_t on=kTRUE);  ; virtual Bool_t GetBinary (Int_t, void *&, Long_t &);  ; virtual Int_t GetBufferLength () const =0;  ; virtual Bool_t GetDate (Int_t, Int_t &, Int_t &, Int_t &);  ; TDatime GetDatime (Int_t);  return value of parameter in form of TDatime Be aware, that TDatime does not allow dates before 1995-01-01 ;  ; virtual Bool_t GetDatime (Int_t, Int_t &, Int_t &, Int_t &, Int_t &, Int_t &, Int_t &);  ; Int_t GetDay (Int_t);  return day value for parameter (if applicable) ;  ; virtual Double_t GetDouble (Int_t);  ; virtual Int_t GetErrorCode () const;  returns error code of last operation if res==0, no error Each specific implementation of TSQLStatement provides its own error coding ;  ; virtual const char * GetErrorMsg () const;  returns error message of last operation if no errors, return 0 Each specific implementation of TSQLStatement provides its own error messages ;  ; virtual const char * GetFieldName (Int_t)=0;  ; Int_t GetHour (Int_t);  return hours value for parameter (if applicable) ;  ; virtual Int_t GetInt (Int_t);  ; virtual Bool_t GetLargeObject (Int_t col, void *&mem, Long_t &size);  ; virtual Long_t GetLong (Int_t);  ; virtual Long64_t GetLong64 (Int_t);  ; Int_t GetMinute (Int_t);  return minutes value for parameter (if applicable) ;  ; Int_t GetMonth (Int_t);  return month value for parameter (if applicable) ;  ; virtual Int_t GetNumAffectedRows ();  ; virtual Int_t GetNumFields ()=0;  ; virtual Int_t GetNumParameters ()=0;  ; Int_t GetSecond (Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLStatement.html:1266,message,message,1266,doc/master/classTSQLStatement.html,https://root.cern,https://root.cern/doc/master/classTSQLStatement.html,1,['message'],['message']
Integrability," R >::Array. inline . return read-only pointer to internal array ; Definition at line 630 of file SMatrix.icc. ◆ At() [1/2]. template<class T , unsigned int D1, unsigned int D2, class R > . T & ROOT::Math::SMatrix< T, D1, D2, R >::At ; (; unsigned int ; i, . unsigned int ; j . ). inline . read/write access to matrix element with indices starting from 0. ; Function will check index values and it will assert if they are wrong ; Definition at line 660 of file SMatrix.icc. ◆ At() [2/2]. template<class T , unsigned int D1, unsigned int D2, class R > . const T & ROOT::Math::SMatrix< T, D1, D2, R >::At ; (; unsigned int ; i, . unsigned int ; j . ); const. inline . read only access to matrix element, with indices starting from 0. ; Function will check index values and it will assert if they are wrong ; Definition at line 653 of file SMatrix.icc. ◆ begin() [1/2]. template<class T , unsigned int D1, unsigned int D2, class R > . T * ROOT::Math::SMatrix< T, D1, D2, R >::begin. inline . STL iterator interface. ; Definition at line 670 of file SMatrix.icc. ◆ begin() [2/2]. template<class T , unsigned int D1, unsigned int D2, class R > . const T * ROOT::Math::SMatrix< T, D1, D2, R >::begin. inline . STL const_iterator interface. ; Definition at line 680 of file SMatrix.icc. ◆ Col(). template<class T , unsigned int D1, unsigned int D2, class R > . SVector< T, D1 > ROOT::Math::SMatrix< T, D1, D2, R >::Col ; (; unsigned int ; thecol); const. return a full Matrix column as a vector (copy the content in a new vector) ; Definition at line 590 of file SMatrix.icc. ◆ Det(). template<class T , unsigned int D1, unsigned int D2, class R > . bool ROOT::Math::SMatrix< T, D1, D2, R >::Det ; (; T & ; det). inline . determinant of square Matrix via Dfact. ; Return true when the calculation is successful. Parameters. detwill contain the calculated determinant value Note: this will destroy the contents of the Matrix! . Definition at line 466 of file SMatrix.icc. ◆ Det2(). template<class T , unsigne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html:19697,interface,interface,19697,doc/master/classROOT_1_1Math_1_1SMatrix.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html,1,['interface'],['interface']
Integrability," R package for ROOT. ;  ; namespace  RDF;  ; namespace  TF1Helper;  ; namespace  TMetaUtils;  ; namespace  TreeUtils;  ; namespace  TThreadedObjectUtils;  ; namespace  TypeTraits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV's and other data formats. More...;  ; class  ROpaqueTaskArena;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TGenericClassInfo;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:2150,interface,interfaces,2150,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['interface'],['interfaces']
Integrability," RDFDetail::RInferredType, typename V2 = RDFDetail::RInferredType, typename V3 = RDFDetail::RInferredType> . RResultPtr<::TH3D > ROOT::RDF::RInterface< Proxied, DataSource >::Histo3D ; (; const TH3DModel & ; model, . std::string_view ; v1Name = """", . std::string_view ; v2Name = """", . std::string_view ; v3Name = """" . ). inline . Fill and return a three-dimensional histogram (lazy action). ; Template Parameters. V1The type of the column used to fill the x axis of the histogram. Inferred if not present. ; V2The type of the column used to fill the y axis of the histogram. Inferred if not present. ; V3The type of the column used to fill the z axis of the histogram. Inferred if not present. . Parameters. [in]modelThe returned histogram will be constructed using this as a model. ; [in]v1NameThe name of the column that will fill the x axis. ; [in]v2NameThe name of the column that will fill the y axis. ; [in]v3NameThe name of the column that will fill the z axis. . Returnsthe tridimensional histogram wrapped in a RResultPtr.; This action is lazy: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr. Example usage:; // Deduce column types (this invocation needs jitting internally); auto myHist1 = myDf.Histo3D({""name"", ""title"", 64u, 0., 128., 32u, -4., 4., 8u, -2., 2.},; ""myValueX"", ""myValueY"", ""myValueZ"");; // Explicit column types; auto myHist2 = myDf.Histo3D<double, double, float>({""name"", ""title"", 64u, 0., 128., 32u, -4., 4., 8u, -2., 2.},; ""myValueX"", ""myValueY"", ""myValueZ"");; NoteDifferently from other ROOT interfaces, the returned histogram is not associated to gDirectory and the caller is responsible for its lifetime (in particular, a typical source of confusion is that if result histograms go out of scope before the end of the program, ROOT might display a blank canvas). ; Definition at line 2049 of file RInterface.hxx. ◆ HistoND() [1/2]. template<typename Proxied , typename DataSource = void> . template<typename FirstColumn , ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:96385,wrap,wrapped,96385,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['wrap'],['wrapped']
Integrability," ROOFIT; » ROOSTATS; » RooStats::IntervalCalculator. class RooStats::IntervalCalculator. IntervalCalculator is an interface class for a tools which produce RooStats ConfIntervals. ; The interface currently assumes that any interval calculator can be configured by specifying:. a model,; a data set, ; a set of parameters of interest,; a set of nuisance parameters (eg. parameters on which the model depends, but are not of interest), and ; a confidence level or size of the test (eg. rate of Type I error). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface will be extended so that one does not need to use a workspace. After configuring the calculator, one only needs to ask GetInterval, which will return a ConfInterval pointer. The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IntervalCalculator(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual RooStats::ConfInterval*GetInterval() const; RooStats::IntervalCalculatorIntervalCalculator(); RooStats::IntervalCalculatorIntervalCalculator(const RooStats::IntervalCalculator&); virtual TClass*IsA() const; RooStats::IntervalCalculator&operator=(const RooStats::IntervalCalculator&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); virtual voidSetModel(const RooStats::ModelConfig&); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp) const; virtual Double_tSize() const; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__IntervalCalculator.html:1258,interface,interface,1258,root/html602/RooStats__IntervalCalculator.html,https://root.cern,https://root.cern/root/html602/RooStats__IntervalCalculator.html,4,['interface'],['interface']
Integrability," ROOFIT; » ROOSTATS; » RooStats::IntervalCalculator. class RooStats::IntervalCalculator. IntervalCalculator is an interface class for a tools which produce RooStats ConfIntervals. ; The interface currently assumes that any interval calculator can be configured by specifying:. a model,; a data set, ; a set of parameters of interest,; a set of nuisance parameters (eg. parameters on which the model depends, but are not of interest), and ; a confidence level or size of the test (eg. rate of Type I error). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface will be extended so that one does not need to use a workspace. After configuring the calculator, one only needs to ask GetInterval, which will return a ConfInterval pointer. The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IntervalCalculator(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual RooStats::ConfInterval*GetInterval() const; virtual TClass*IsA() const; RooStats::IntervalCalculator&operator=(const RooStats::IntervalCalculator&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); virtual voidSetModel(const RooStats::ModelConfig&); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function docume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__IntervalCalculator.html:1256,interface,interface,1256,root/html528/RooStats__IntervalCalculator.html,https://root.cern,https://root.cern/root/html528/RooStats__IntervalCalculator.html,4,['interface'],['interface']
Integrability," ROOFIT; » ROOSTATS; » RooStats::IntervalCalculator. class RooStats::IntervalCalculator. IntervalCalculator is an interface class for a tools which produce RooStats ConfIntervals. ; The interface currently assumes that any interval calculator can be configured by specifying:. a model,; a data set, ; a set of parameters of interest,; a set of nuisance parameters (eg. parameters on which the model depends, but are not of interest), and ; a confidence level or size of the test (eg. rate of Type I error). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface will be extended so that one does not need to use a workspace. After configuring the calculator, one only needs to ask GetInterval, which will return a ConfInterval pointer. The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IntervalCalculator(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual RooStats::ConfInterval*GetInterval() const; virtual TClass*IsA() const; RooStats::IntervalCalculator&operator=(const RooStats::IntervalCalculator&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); virtual voidSetModel(const RooStats::ModelConfig&); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual Double_tSize() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__IntervalCalculator.html:1256,interface,interface,1256,root/html526/RooStats__IntervalCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__IntervalCalculator.html,1,['interface'],['interface']
Integrability," ROOFIT; » ROOSTATS; » RooStats::IntervalCalculator. class RooStats::IntervalCalculator. IntervalCalculator is an interface class for a tools which produce RooStats ConfIntervals. ; The interface currently assumes that any interval calculator can be configured by specifying:. a model,; a data set, ; a set of parameters of interest,; a set of nuisance parameters (eg. parameters on which the model depends, but are not of interest), and ; a confidence level or size of the test (eg. rate of Type I error). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface will be extended so that one does not need to use a workspace. After configuring the calculator, one only needs to ask GetInterval, which will return a ConfInterval pointer. The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IntervalCalculator(); static TClass*Class(); virtual Double_tConfidenceLevel() const; virtual RooStats::ConfInterval*GetInterval() const; virtual TClass*IsA() const; RooStats::IntervalCalculator&operator=(const RooStats::IntervalCalculator&); virtual voidSetConfidenceLevel(Double_t cl); virtual voidSetData(RooAbsData&); virtual voidSetModel(const RooStats::ModelConfig&); virtual voidSetTestSize(Double_t size); virtual voidShowMembers(TMemberInspector&); virtual Double_tSize() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Librari",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__IntervalCalculator.html:1258,interface,interface,1258,root/html534/RooStats__IntervalCalculator.html,https://root.cern,https://root.cern/root/html534/RooStats__IntervalCalculator.html,2,['interface'],['interface']
Integrability," ROOT Users Guide and contributed the chapter ‘Writing a Graphical User Interface’.; Gerardo Ganis; Gerri was a team member for more than ten years; among many other contributions he was in charge of PROOF for many years.; Jan Iwaszkiewicz; Jan was working in the context of a Ph.D. on scheduling and load-balancing of distributed processing in the Parallel ROOT Facility (PROOF).; Leandro Franco; Leo worked a Marie-Curie fellow in the ROOT team from 2005-2008. He worked on a number of widely different topics, from parallel sockets, I/O read-ahead, CINT dictionary, etc.; Maarten Ballintijn; Maarten's initial dab into ROOT was porting it to Linux in 1995. Later he worked on the PROOF system, bringing into production for the RHIC experiments in Brookhaven.; Marek Biskup; Marek worked as technical student on various aspects of PROOF, notably integrating the TChain::Draw() command into PROOF.; Masaharu Goto; Masa is the father of CINT. Without the indefatigable support by Masa we would never have succeeded with the tight integration of CINT in ROOT. Masa is now managing a large division in Agilent and cannot spend as much time on CINT as he would like.; Matevž Tadel; Matevž Tadel is the main developer of 3D graphics and event-visualization packages. He holds a Ph.D. in experimental high-energy physics, obtained in 2001 for his work on electron reconstruction in the ATLAS experiment. Before joining the ROOT team in 2005, he worked on Gled - an advanced ROOT-based system for distributed computing and dynamic visualisation.; Nenad Buncic; Nenad was one of the first people joining the initial ROOT team in 1996. He developed the first version of the HTML documentation system (THtml) and worked on the first version of the 3D graphics system. Nenad left in 1997.; Paul Russo; Paul joined the ROOT team at Fermilab in 2005 and has been focusing on support and developing CINT.; Pere Mato; Pere Mato was the project leader from 2014 to 2017. He was the driving force behind ROOT's migra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/previous-developers.html:4741,integrat,integration,4741,d/previous-developers.html,https://root.cern,https://root.cern/d/previous-developers.html,1,['integrat'],['integration']
Integrability," ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. rf902_numgenconfig.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Numeric algorithm tuning: configuration and customization of how MC sampling algorithms on specific pdfs are executed ; ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooChebychev.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""RooNumGenConfig.h""; #include ""RooArgSet.h""; #include <iomanip>; using namespace RooFit;; ; void rf902_numgenconfig(); {; ; // A d j u s t g l o b a l MC s a m p l i n g s t r a t e g y; // ------------------------------------------------------------------; ; // Example pdf for use below; RooRealVar x(""x"", ""x"", 0, 10);; RooChebychev model(""model"", ""model"", x, RooArgList(0, 0.5, -0.1));; ; // Change global strategy for 1D sampling problems without conditional observable; // (1st false) and without discrete observable (2nd false) from RooFoamGenerator,; // ( an interface to the TFoam MC generator with adaptive subdivisioning strategy ) to RooAcceptReject,; // a plain accept/reject sampling algorithm [ RooFit default before ROOT 5.23/04 ]; RooAbsPdf::defaultGeneratorConfig()->method1D(false, false).setLabel(""RooAcceptReject"");; ; // Generate 10Kevt using RooAcceptReject; std::unique_ptr<RooDataSet> data_ar{model.generate(x, 10000, Verbose(true))};; data_ar->Print();; ; // A d j u s t i n g d e f a u l t c o n f i g f o r a s p e c i f i c p d f; // -------------------------------------------------------------------------------------; ; // Another possibility: associate custom MC sampling configuration as default for object 'model'; // The true argument will install a clone of the default configuration as specialized configuration; // for this model if none existed so far; model.specialGeneratorConfig(true)->method1D(false, false).setLabel(""RooFoamGenerator"");; ; // A d j u s t i n g p a r a m e t e r s o f a s p e c i f i c t e c h n i q ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf902__numgenconfig_8C.html:1068,interface,interface,1068,doc/master/rf902__numgenconfig_8C.html,https://root.cern,https://root.cern/doc/master/rf902__numgenconfig_8C.html,1,['interface'],['interface']
Integrability," ROOT.Fit.BinData(opt, rangeB); ROOT.Fit.FillData(dataB, hB); ; rangeSB = ROOT.Fit.DataRange(); rangeSB.SetRange(10, 50); dataSB = ROOT.Fit.BinData(opt, rangeSB); ROOT.Fit.FillData(dataSB, hSB); ; chi2_B = ROOT.Fit.Chi2Function(dataB, wfB); chi2_SB = ROOT.Fit.Chi2Function(dataSB, wfSB); ; globalChi2 = GlobalChi2(chi2_B, chi2_SB); ; fitter = ROOT.Fit.Fitter(); ; Npar = 6; par0 = np.array([5, 5, -0.1, 100, 30, 10]); ; # create before the parameter settings in order to fix or set range on them; fitter.Config().SetParamsSettings(6, par0); # fix 5-th parameter; fitter.Config().ParSettings(4).Fix(); # set limits on the third and 4-th parameter; fitter.Config().ParSettings(2).SetLimits(-10, -1.0e-4); fitter.Config().ParSettings(3).SetLimits(0, 10000); fitter.Config().ParSettings(3).SetStepSize(5); ; fitter.Config().MinimizerOptions().SetPrintLevel(0); fitter.Config().SetMinimizer(""Minuit2"", ""Migrad""); ; # we can't pass the Python object globalChi2 directly to FitFCN.; # It needs to be wrapped in a ROOT::Math::Functor.; globalChi2Functor = ROOT.Math.Functor(globalChi2, 6); ; # fit FCN function; # (specify optionally data size and flag to indicate that is a chi2 fit); fitter.FitFCN(globalChi2Functor, 0, dataB.Size() + dataSB.Size(), True); result = fitter.Result(); result.Print(ROOT.std.cout); ; c1 = ROOT.TCanvas(""Simfit"", ""Simultaneous fit of two histograms"", 10, 10, 700, 700); c1.Divide(1, 2); c1.cd(1); ROOT.gStyle.SetOptFit(1111); ; fB.SetFitResult(result, iparB); fB.SetRange(rangeB().first, rangeB().second); fB.SetLineColor(ROOT.kBlue); hB.GetListOfFunctions().Add(fB); hB.Draw(); ; c1.cd(2); fSB.SetFitResult(result, iparSB); fSB.SetRange(rangeSB().first, rangeSB().second); fSB.SetLineColor(ROOT.kRed); hSB.GetListOfFunctions().Add(fSB); hSB.Draw(); ; c1.SaveAs(""combinedFit.png""); ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::Chi2FCNChi2FCN class for binned fits ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/combinedFit_8py.html:3080,wrap,wrapped,3080,doc/master/combinedFit_8py.html,https://root.cern,https://root.cern/doc/master/combinedFit_8py.html,1,['wrap'],['wrapped']
Integrability," ROOT::Fit::BinData&LogTransform(); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const DataOption",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__BinData.html:5179,wrap,wrapper,5179,root/html526/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__BinData.html,1,['wrap'],['wrapper']
Integrability," ROOT::Fit::BinData&LogTransform(); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__BinData.html:5258,wrap,wrapper,5258,root/html528/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__BinData.html,4,['wrap'],['wrapper']
Integrability," ROOT::Math::GSLRngGFSR4 Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; List of all members ; ROOT::Math::GSLRngGFSR4 Class ReferenceMath » MathCore » Interface classes for Random number generation. ; Lagged Fibonacci generator by Ziff see here ; Definition at line 441 of file GSLRndmEngines.h. Public Types; typedef GSLRandomEngine BaseType;  . Public Member Functions;  GSLRngGFSR4 ();  ;  Public Member Functions inherited from ROOT::Math::GSLRandomEngine;  GSLRandomEngine ();  default constructor. ;  ;  GSLRandomEngine (const GSLRandomEngine &eng);  Copy constructor : clone the contained GSL generator. ;  ;  GSLRandomEngine (GSLRngWrapper *rng);  create from an existing rng. ;  ; virtual ~GSLRandomEngine ();  call Terminate() ;  ; void Initialize ();  initialize the generator If no rng is present the default one based on Mersenne and Twister is created ;  ; unsigned long IntRndm () const;  Generate an integer number between [0,max_generator-1] (including 0 and max-1) if max is larger than available range of algorithm an error message is printed and zero is returned. ;  ; unsigned long MaxInt () const;  return the maximum integer +1 a generator can handle ;  ; unsigned long MinInt () const;  return the minimum integer a generator can handle typically this value is 0 ;  ; std::string Name () const;  return name of generator ;  ; double operator() () const;  Generate a random number between ]0,1] 0 is excluded and 1 is included. ;  ; GSLRandomEngine & operator= (const GSLRandomEngine &eng);  Assignment operator : make a deep copy of the contained GSL generator. ;  ; void RandomArray (double *begin, double *end) const;  Generate an array of random numbers The iterators points to the random numbers. ;  ; template<class Iterator > ; void RandomArray (Iterator begin, Iterator end) const;  Generate an array of random numbers. ;  ; double Rndm () const;  Gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRngGFSR4.html:1167,message,message,1167,doc/master/classROOT_1_1Math_1_1GSLRngGFSR4.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRngGFSR4.html,1,['message'],['message']
Integrability," ROOT::Math::GSLRngMT Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; List of all members ; ROOT::Math::GSLRngMT Class ReferenceMath » MathCore » Interface classes for Random number generation. ; Mersenne-Twister generator gsl_rng_mt19937 from here ; Definition at line 341 of file GSLRndmEngines.h. Public Types; typedef GSLRandomEngine BaseType;  . Public Member Functions;  GSLRngMT ();  ;  Public Member Functions inherited from ROOT::Math::GSLRandomEngine;  GSLRandomEngine ();  default constructor. ;  ;  GSLRandomEngine (const GSLRandomEngine &eng);  Copy constructor : clone the contained GSL generator. ;  ;  GSLRandomEngine (GSLRngWrapper *rng);  create from an existing rng. ;  ; virtual ~GSLRandomEngine ();  call Terminate() ;  ; void Initialize ();  initialize the generator If no rng is present the default one based on Mersenne and Twister is created ;  ; unsigned long IntRndm () const;  Generate an integer number between [0,max_generator-1] (including 0 and max-1) if max is larger than available range of algorithm an error message is printed and zero is returned. ;  ; unsigned long MaxInt () const;  return the maximum integer +1 a generator can handle ;  ; unsigned long MinInt () const;  return the minimum integer a generator can handle typically this value is 0 ;  ; std::string Name () const;  return name of generator ;  ; double operator() () const;  Generate a random number between ]0,1] 0 is excluded and 1 is included. ;  ; GSLRandomEngine & operator= (const GSLRandomEngine &eng);  Assignment operator : make a deep copy of the contained GSL generator. ;  ; void RandomArray (double *begin, double *end) const;  Generate an array of random numbers The iterators points to the random numbers. ;  ; template<class Iterator > ; void RandomArray (Iterator begin, Iterator end) const;  Generate an array of random numbers. ;  ; double Rndm () const;  Gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRngMT.html:1167,message,message,1167,doc/master/classROOT_1_1Math_1_1GSLRngMT.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRngMT.html,1,['message'],['message']
Integrability," ROOT::Math::GaussLegendreIntegrator:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ GaussLegendreIntegrator(). ROOT::Math::GaussLegendreIntegrator::GaussLegendreIntegrator ; (; int ; num = 10, . double ; eps = 1e-12 . ). Basic constructor of GaussLegendreIntegrator. ; @param num Number of desired points to calculate the integration. @param eps Desired relative error. ; Definition at line 23 of file GaussLegendreIntegrator.cxx. ◆ ~GaussLegendreIntegrator(). ROOT::Math::GaussLegendreIntegrator::~GaussLegendreIntegrator ; (; ). override . Default Destructor. ; Definition at line 34 of file GaussLegendreIntegrator.cxx. Member Function Documentation. ◆ CalcGaussLegendreSamplingPoints(). void ROOT::Math::GaussLegendreIntegrator::CalcGaussLegendreSamplingPoints ; (; ). private . Type: unsafe but fast interface filling the arrays x and w (static method) ; Given the number of sampling points this routine fills the arrays x and w of length num, containing the abscissa and weight of the Gauss-Legendre n-point quadrature formula.; Gauss-Legendre: W(x)=1 -1<x<1 (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}; num is the number of sampling points (>0) x and w are arrays of size num eps is the relative precision; If num<=0 or eps<=0 no action is done.; Reference: Numerical Recipes in C, Second Edition ; Definition at line 98 of file GaussLegendreIntegrator.cxx. ◆ DoIntegral(). double ROOT::Math::GaussLegendreIntegrator::DoIntegral ; (; double ; a, . double ; b, . const IGenFunction * ; func . ). overrideprivatevirtual . Integration surrogate method. ; Return integral of passed function in interval [a,b] Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints ; Reimplemented from ROOT::Math::GaussIntegrator.; Definition at line 60 of file GaussLegendreIntegrator.cxx. ◆ GetNumberPoints(). int ROOT::Math::GaussLegendreIntegrator::GetNumberPoints ; (; ); const. inline . Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html:5439,interface,interface,5439,doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GaussLegendreIntegrator.html,2,"['interface', 'rout']","['interface', 'routine']"
Integrability," ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 9.9999999999999998E-13); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::GaussLegendreIntegrator&operator=(const ROOT::Math::GaussLegendreIntegrator&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::GaussIntegrator::SetFunction(const ROOT::Math::IGenFunction&); voidSetNumberPoints(int num); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intROOT::Math::GaussIntegrator::Status() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const; ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(); ROOT::Math::VirtualIntegratorROOT::Math::VirtualIntegrator::VirtualIntegrator(const ROOT::Math::VirtualIntegrator&); ROOT::Math::VirtualIntegratorOneDimROOT::Math::VirtualIntegratorOneDim::VirtualIntegratorOneDim(); ROOT::Math::VirtualIntegratorOneDimROOT::Math::VirtualIntegratorOneDim::VirtualIntegratorOneDim(const ROOT::Math::VirtualIntegratorOneDim&). private:. voidCalcGaussLegendreSamplingPoints(); virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GaussLegendreIntegrator.html:1831,Integrat,IntegratorOneDimOptionsOptions,1831,root/html602/ROOT__Math__GaussLegendreIntegrator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GaussLegendreIntegrator.html,6,['Integrat'],"['IntegrationOneDim', 'IntegratorOneDimOptions', 'IntegratorOneDimOptionsOptions']"
Integrability," ROOT::Math::GradFunctor is used to wrap in a very C++ callable object to make gradient functions. It can be constructed in three different way: * From an object implementing both double operator()( const double * ) for the function evaluation and double Derivative(const double *, int icoord) for the partial derivatives. * From an object implementing any member function like Foo::XXX(const double *) for the function evaluation and any member function like Foo::XXX(const double *, int icoord) for the partial derivatives. * From an function object implementing double operator()( const double * ) for the function evaluation and another function object implementing double operator() (const double *, int icoord) for the partial derivatives.; The function dimension is required when constructing the functor.; 13.7.4.5 Special case: Wrapping TF1 objects in Parametric Function interfaces; In many cases, the user works with the TF1 class. The mathematical library in ROOT provides some solutions to wrap these into the interfaces needed by other methods. If the desired interface to wrap is one-dimensional, the class to use is ROOT::Math::WrappedTF1. The default constructor takes a TF1 reference as an argument, that will be wrapped with the interfaces of a ROOT::Math::IParametricGradFunctionOneDim. Example:; #include ""TF1.h""; #include ""Math/WrappedTF1.h"". int main(); {. TF1 f(""Sin Function"", ""sin(x)+y"",0,3);. ROOT::Math::WrappedTF1 wf1(f);. cout << f(1) << endl;; cout << wf1(1) << endl;. return 0;; }; For a TF1 defining a multidimensional function or in case we need to wrap in a multi-dimensional function interface, the class to use is ROOT::Math::WrappedMultiTF1. Following the usual procedure, setting the TF1 though the constructor, will wrap it into a ROOT::Math::IParametricGradFunctionMultiDim. Example:; #include ""TF1.h""; #include ""Math/WrappedMultiTF1.h"". int main(); {. TF2 f(""Sin Function"", ""sin(x) + y"",0,3,0,2);. ROOT::Math::WrappedMultiTF1 wf1(f);. double x[] = {1,2};. co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:698604,wrap,wrap,698604,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,"['interface', 'wrap']","['interfaces', 'wrap']"
Integrability," ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>. class ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>: public ROOT::Math::IParametricGradFunctionOneDim. Base template class for all Parametric Functions.; The template argument is the type of parameteric function interface is implementing like; Parameteric 1D, Multi-Dim or gradient parametric. A parameteric function is a Generic Function with parameters, so; it is a function object which carries a state, the parameters.; The parameters are described with a standard vector of doubles. This class contains the default implementations for the methods defined in the; IParamFunction interface for dealing with parameters; Specific parameteric function classes should derive from this class if they want to profit from; default implementations for the abstract methods.; The derived classes need to implement only the DoEvalPar( x, p) and Clone() methods for non-gradient; parameteric functions or DoParameterDerivative(x,p,ipar) for gradient par functions. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::ParamFunction<IParamGradFunction>, ROOT::Math::Polynomial::ParFunc. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intNPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html:957,interface,interface,957,root/html528/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html,1,['interface'],['interface']
Integrability," ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHMORE; » ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>. class ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>: public ROOT::Math::IParametricGradFunctionOneDim. Base template class for all Parametric Functions.; The template argument is the type of parameteric function interface is implementing like; Parameteric 1D, Multi-Dim or gradient parametric. A parameteric function is a Generic Function with parameters, so; it is a function object which carries a state, the parameters.; The parameters are described with a standard vector of doubles. This class contains the default implementations for the methods defined in the; IParamFunction interface for dealing with parameters; Specific parameteric function classes should derive from this class if they want to profit from; default implementations for the abstract methods.; The derived classes need to implement only the DoEvalPar( x, p) and Clone() methods for non-gradient; parameteric functions or DoParameterDerivative(x,p,ipar) for gradient par functions. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::Polynomial::ParFunc, ROOT::Math::ParamFunction<IParamGradFunction>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intNPar() const; doubleROOT::Math::IParametricFunctionOneDim::operator()(double x, const double* p) const; doubleROOT::Math::IParametricFunctionOneDim::operator()(const double* x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html:957,interface,interface,957,root/html526/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__ParamFunction_-p1IParametricGradFunctionOneDim_.html,1,['interface'],['interface']
Integrability," RResultPtr.; If T is not specified, RDataFrame will infer it from the data and just-in-time compile the correct template specialization of this method.; This action is lazy: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr. Example usage:; // Deduce column type (this invocation needs jitting internally); auto meanVal0 = myDf.Mean(""values"");; // Explicit column type; auto meanVal1 = myDf.Mean<double>(""values"");. Definition at line 2699 of file RInterface.hxx. ◆ Min(). template<typename Proxied , typename DataSource = void> . template<typename T = RDFDetail::RInferredType> . RResultPtr< RDFDetail::MinReturnType_t< T > > ROOT::RDF::RInterface< Proxied, DataSource >::Min ; (; std::string_view ; columnName = """"). inline . Return the minimum of processed column values (lazy action). ; Template Parameters. TThe type of the branch/column. . Parameters. [in]columnNameThe name of the branch/column to be treated. . Returnsthe minimum value of the selected column wrapped in a RResultPtr.; If T is not specified, RDataFrame will infer it from the data and just-in-time compile the correct template specialization of this method. If the type of the column is inferred, the return type is double, the type of the column otherwise.; This action is lazy: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr. Example usage:; // Deduce column type (this invocation needs jitting internally); auto minVal0 = myDf.Min(""values"");; // Explicit column type; auto minVal1 = myDf.Min<double>(""values"");. Definition at line 2640 of file RInterface.hxx. ◆ operator RNode(). template<typename Proxied , typename DataSource = void> . ROOT::RDF::RInterface< Proxied, DataSource >::operator RNode ; (; ); const. inline . Cast any RDataFrame node to a common type ROOT::RDF::RNode. ; Different RDataFrame methods return different C++ types. All nodes, however, can be cast to this common type at the cost of a small performance p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:102540,wrap,wrapped,102540,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['wrap'],['wrapped']
Integrability," Rademakers 12/11/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TObjString; 13#define ROOT_TObjString; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TObjString //; 19// //; 20// Collectable string class. This is a TObject containing a TString. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TObject.h""; 25#include ""TString.h""; 26 ; 27 ; 28class TObjString : public TObject {; 29 ; 30private:; 31 TString fString; // wrapped TString; 32 ; 33public:; 34 TObjString(const char *s = """") : fString(s) { }; 35 ~TObjString();; 36 Int_t Compare(const TObject *obj) const override;; 37 TString CopyString() const { return fString; }; 38 const char *GetName() const override { return fString; }; 39 ULong_t Hash() const override { return fString.Hash(); }; 40 void FillBuffer(char *&buffer) { fString.FillBuffer(buffer); }; 41 void Print(Option_t *) const override { Printf(""TObjString = %s"", (const char*)fString); }; 42 Bool_t IsSortable() const override { return kTRUE; }; 43 Bool_t IsEqual(const TObject *obj) const override;; 44 void ReadBuffer(char *&buffer) { fString.ReadBuffer(buffer); }; 45 void SetString(const char *s) { fString = s; }; 46 const TString &GetString() const { return fString; }; 47 Int_t Sizeof() const { return fString.Sizeof(); }; 48 TString &String() { return fString; }; 49 ; 50 ClassDefOverride(TObjString,1) //Collectable string class; 51};; 52 ; 53#endif; 54 ; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; kT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObjString_8h_source.html:1108,wrap,wrapped,1108,doc/master/TObjString_8h_source.html,https://root.cern,https://root.cern/doc/master/TObjString_8h_source.html,1,['wrap'],['wrapped']
Integrability," ReadFastArray(ULong64_t* l, Int_t n); read array of ULong64_t from buffer. void ReadFastArray(Float_t* f, Int_t n); read array of Float_t from buffer. void ReadFastArray(Double_t* d, Int_t n); read array of Double_t from buffer. void ReadFastArrayFloat16(Float_t* f, Int_t n, TStreamerElement* ele = 0); read array of Float16_t from buffer. void ReadFastArrayWithFactor(Float_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Float16_t from buffer. void ReadFastArrayWithNbits(Float_t* ptr, Int_t n, Int_t nbits); read array of Float16_t from buffer. void ReadFastArrayDouble32(Double_t* d, Int_t n, TStreamerElement* ele = 0); read array of Double32_t from buffer. void ReadFastArrayWithFactor(Double_t* ptr, Int_t n, Double_t factor, Double_t minvalue); read array of Double32_t from buffer. void ReadFastArrayWithNbits(Double_t* ptr, Int_t n, Int_t nbits); read array of Double32_t from buffer. void ReadFastArray(void* start, const TClass* cl, Int_t n = 1, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void ReadFastArray(void** startp, const TClass* cl, Int_t n = 1, Bool_t isPreAlloc = kFALSE, TMemberStreamer* s = 0, const TClass* onFileClass = 0); redefined here to avoid warning message from gcc. void WriteArray(const Bool_t* b, Int_t n); Write array of Bool_t to buffer. void WriteArray(const Char_t* c, Int_t n); Write array of Char_t to buffer. void WriteArray(const UChar_t* c, Int_t n); Write array of UChar_t to buffer. void WriteArray(const Short_t* h, Int_t n); Write array of Short_t to buffer. void WriteArray(const UShort_t* h, Int_t n); Write array of UShort_t to buffer. void WriteArray(const Int_t* i, Int_t n); Write array of Int_ to buffer. void WriteArray(const UInt_t* i, Int_t n); Write array of UInt_t to buffer. void WriteArray(const Long_t* l, Int_t n); Write array of Long_t to buffer. void WriteArray(const ULong_t* l, Int_t n); Write array of ULong_t to buffer. void WriteArray(const Lon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:32623,message,message,32623,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,12,['message'],['message']
Integrability," ReadLeaves1Impl(TBuffer &b)Read one leaf without the overhead of a loop.Definition TBranch.cxx:2479; TBranch::GetBulkEntriesInt_t GetBulkEntries(Long64_t, TBuffer &)Read a basket of events into the given buffer with byte swapping.Definition TBranch.cxx:1472; TBranch::SetFilevirtual void SetFile(TFile *file=nullptr)Set file where this branch writes/reads its buffers.Definition TBranch.cxx:2863; TBranch::GetEntryExportvirtual Int_t GetEntryExport(Long64_t entry, Int_t getall, TClonesArray *list, Int_t n)Read all leaves of an entry and export buffers to real objects in a TClonesArray list.Definition TBranch.cxx:1762; TBranch::SetAutoDeletevirtual void SetAutoDelete(bool autodel=true)Set the automatic delete bit.Definition TBranch.cxx:2716; TBranch::fZipBytesLong64_t fZipBytesTotal number of bytes in all leaves after compression.Definition TBranch.h:137; TBranch::fIOFeaturesTIOFeatures fIOFeaturesIO features for newly-created baskets.Definition TBranch.h:123; TBranch::Browsevoid Browse(TBrowser *b) overrideBrowser interface.Definition TBranch.cxx:699; TBranch::SetCompressionAlgorithmvoid SetCompressionAlgorithm(Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal)Set compression algorithm.Definition TBranch.cxx:2763; TBranch::SetEntryOffsetLenvirtual void SetEntryOffsetLen(Int_t len, bool updateSubBranches=false)Update the default value for the branch's fEntryOffsetLen if and only if it was already non zero (and...Definition TBranch.cxx:2821; TBranch::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find the leaf corresponding to the name 'searchname'.Definition TBranch.cxx:1081; TBranch::fCacheInfoCacheInfo_t fCacheInfo! Hold info about which basket are in the cache and if they have been retrieved from the cache.Definition TBranch.h:158; TBranch::GetListOfBasketsTObjArray * GetListOfBaskets()Definition TBranch.h:245; TBranch::SetBufferAddressvirtual void SetBufferAddress(TBuffer *entryBuffer)Set address of this branch directly from a TBuffer to avoid stre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:134276,interface,interface,134276,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['interface'],['interface']
Integrability," Reconnect(); Try reconnection after failure. Int_t GetLowSocket() const; Auxilliary. { return (fConn ? fConn->GetLowSocket() : -1); }. Int_t GetClientID() const; { return -1; }. Int_t GetClientIDSize() const; { return 1; }. Int_t GetLogConnID() const; { return (fConn ? fConn->GetLogConnID() : -1); }. Int_t GetOpenError() const; { return (fConn ? fConn->GetOpenError() : -1); }. Int_t GetServType() const; { return (fConn ? fConn->GetServType() : -1); }. Int_t GetSessionID() const; { return (fConn ? fConn->GetSessionID() : -1); }. Int_t GetXrdProofdVersion() const; { return fXrdProofdVersion; }. Bool_t IsValid() const; { return (fConn ? (fConn->IsValid()) : kFALSE); }. void RemoveClientID(); { }. void SetClientID(Int_t ); { }. void SetSendOpt(ESendRecvOptions o); { fSendOpt = o; }. Int_t Send(const TMessage& mess); Send interfaces. Int_t Send(Int_t kind); { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Recv(TMessage*& mess); Recv interfaces. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. void SetInterrupt(Bool_t i = kTRUE); Interrupt the low level socket. Bool_t IsInterrupt(); Set / Check async msg queue waiting status. { R__LOCKGUARD(fAMtx); return fRDInterrupt; }. void SetAWait(Bool_t w = kTRUE); { R__LOCKGUARD(fAMtx); fAWait = w; }. Bool_t IsAWait(); { R__LOCKGUARD(fAMtx); return fAWait; }. Int_t SetOption(ESockOptions , Int_t ); Standard options cannot be set. { return 0; }. void DisableTimeout(); Disable / Enable read timeout. { fDontTimeout = kTRUE; }. void EnableTimeout(); { fDontTimeout = kFALSE; }. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSocket.html:19458,interface,interfaces,19458,root/html602/TXSocket.html,https://root.cern,https://root.cern/root/html602/TXSocket.html,2,['interface'],['interfaces']
Integrability," Reconnect(); Try reconnection after failure. Int_t GetLowSocket() const; Auxilliary. { return (fConn ? fConn->GetLowSocket() : -1); }. Int_t GetClientID() const; { return -1; }. Int_t GetClientIDSize() const; { return 1; }. Int_t GetLogConnID() const; { return (fConn ? fConn->GetLogConnID() : -1); }. Int_t GetOpenError() const; { return (fConn ? fConn->GetOpenError() : -1); }. Int_t GetServType() const; { return (fConn ? fConn->GetServType() : -1); }. Int_t GetSessionID() const; { return (fConn ? fConn->GetSessionID() : -1); }. Int_t GetXrdProofdVersion() const; { return fXrdProofdVersion; }. Bool_t IsValid() const; { return (fConn ? (fConn->IsValid()) : kFALSE); }. void RemoveClientID(); { }. void SetClientID(Int_t ); { }. void SetSendOpt(ESendRecvOptions o); { fSendOpt = o; }. Int_t Send(const TMessage& mess); Send interfaces. Int_t Send(Int_t kind); { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Recv(TMessage*& mess); Recv interfaces. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. void SetInterrupt(Bool_t i = kTRUE); Interrupt the low level socket. Bool_t IsInterrupt(); Set / Check async msg queue waiting status. { R__LOCKGUARD(fAMtx); return fRDInterrupt; }. void SetAWait(Bool_t w = kTRUE); { R__LOCKGUARD(fAMtx); fAWait = w; }. Bool_t IsAWait(); { R__LOCKGUARD(fAMtx); return fAWait; }. Int_t SetOption(ESockOptions , Int_t ); Standard options cannot be set. { return 0; }. void DisableTimeout(); Disable / Enable read timeout. { fDontTimeout = kTRUE; }. void EnableTimeout(); { fDontTimeout = kFALSE; }. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXSocket.html:19376,interface,interfaces,19376,root/html604/TXSocket.html,https://root.cern,https://root.cern/root/html604/TXSocket.html,2,['interface'],['interfaces']
Integrability," ReferenceRooFit » RooFit Core. ; Numeric 1-dimensional convolution operator PDF. ; This class can convolve any PDF with any other PDF using a straightforward numeric calculation of the convolution integral This class should be used as last resort as numeric convolution calculated this way is computationally intensive and prone to stability fitting problems. The preferred way to compute numeric convolutions is RooFFTConvPdf, which calculates convolutions using Fourier Transforms (requires external free FFTW3 package) RooNumConvPdf implements reasonable defaults that should convolve most functions reasonably well, but results strongly depend on the shape of your input PDFS so always check your result. The default integration engine for the numeric convolution is the adaptive Gauss-Kronrod method, which empirically seems the most robust for this task. You can override the convolution integration settings via the RooNumIntConfig object reference returned by the convIntConfig() member function By default the numeric convolution is integrated from -infinity to +infinity through a x -> 1/x coordinate transformation of the tails. For convolution with a very small bandwidth it may be advantageous (for both CPU consumption and stability) if the integration domain is limited to a finite range. The function setConvolutionWindow(mean,width,scale) allows to set a sliding window around the x value to be calculated taking a RooAbsReal expression for an offset and a width to be taken around the x value. These input expression can be RooFormulaVars or other function objects although the 3d 'scale' argument 'scale' multiplies the width RooAbsReal expression given in the 2nd argument, allowing for an appropriate window definition for most cases without need for a RooFormulaVar object: e.g. a Gaussian resolution PDF do setConvolutionWindow(gaussMean,gaussSigma,5) Note that for a 'wide' Gaussian the -inf to +inf integration may converge more quickly than that over a finite range! The def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvPdf.html:1205,integrat,integration,1205,doc/master/classRooNumConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooNumConvPdf.html,2,['integrat'],"['integrated', 'integration']"
Integrability," Reimplemented from RooAbsArg.; Reimplemented in RooRealIntegral.; Definition at line 445 of file RooAbsReal.h. ◆ isValidReal(). virtual bool RooAbsReal::isValidReal ; (; double ; , . bool ; printError = false . ); const. inlineprotectedvirtual . Interface function to check if given value is a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 447 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3464 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:120268,message,messages,120268,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['message'],['messages']
Integrability," Reimplemented from RooAbsArg.; Reimplemented in RooRealIntegral.; Definition at line 452 of file RooAbsReal.h. ◆ isValidReal(). virtual bool RooAbsReal::isValidReal ; (; double ; , . bool ; printError = false . ); const. inlineprotectedvirtual . Interface function to check if given value is a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 454 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3545 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:121598,message,messages,121598,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['message'],['messages']
Integrability," Reimplemented from RooAbsReal.; Definition at line 107 of file RooChebychev.cxx. ◆ evalAnaInt(). double RooChebychev::evalAnaInt ; (; const double ; a, . const double ; b . ); const. private . ◆ evaluate(). double RooChebychev::evaluate ; (; ); const. overrideprivatevirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 78 of file RooChebychev.cxx. ◆ getAnalyticalIntegral(). Int_t RooChebychev::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 122 of file RooChebychev.cxx. ◆ IsA(). TClass * RooChebychev::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 55 of file RooChebychev.h. ◆ selectNormalizationRange(). void RooChebychev::selectNormalizationRange ; (; const char * ; rangeName = nullptr, . bool ; force = false . ). overridevirtual . Interface function to force use of a given normalization range to interpret function value. ; Needed for functions or p.d.f.s whose shape depends on the choice of normalization such as RooAddPdf ; Reimplemented from RooAbsReal.; Definition at line 66 of file RooChebychev.cxx. ◆ Streamer(). void RooChebychev::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooChebychev::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChebychev.html:77264,integrat,integration,77264,doc/master/classRooChebychev.html,https://root.cern,https://root.cern/doc/master/classRooChebychev.html,1,['integrat'],['integration']
Integrability," Reimplemented in TSQLFile, and TXMLFile.; Definition at line 1698 of file TFile.cxx. ◆ Print(). void TFile::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print all objects in the file. ; Reimplemented from TDirectory.; Reimplemented in TSQLFile, TXMLFile, TNetFile, TXNetFile, and TMemFile.; Definition at line 1706 of file TFile.cxx. ◆ ReadBuffer() [1/2]. Bool_t TFile::ReadBuffer ; (; char * ; buf, . Int_t ; len . ). virtual . Read a buffer from the file. ; This is the basic low level read operation. Returns kTRUE in case of failure. ; Reimplemented in TSQLFile, TXMLFile, TDavixFile, TXNetFile, TDCacheFile, TNetFile, TWebFile, and TNetXNGFile.; Definition at line 1770 of file TFile.cxx. ◆ ReadBuffer() [2/2]. Bool_t TFile::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Read a buffer from the file at the offset 'pos' in the file. ; Returns kTRUE in case of failure. Compared to ReadBuffer(char*, Int_t), this routine does not change the cursor on the physical file representation (fD) if the data is in this TFile's cache. ; Reimplemented in TSQLFile, TXMLFile, TDavixFile, TXNetFile, TDCacheFile, TNetFile, TWebFile, and TNetXNGFile.; Definition at line 1720 of file TFile.cxx. ◆ ReadBufferAsync(). Bool_t TFile::ReadBufferAsync ; (; Long64_t ; offs, . Int_t ; len . ). virtual . Reimplemented in TDavixFile, and TXNetFile.; Definition at line 5208 of file TFile.cxx. ◆ ReadBuffers(). Bool_t TFile::ReadBuffers ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). virtual . Read the nbuf blocks described in arrays pos and len. ; The value pos[i] is the seek position of block i of length len[i]. Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer. This function is overloaded by TNetFile, TWebFile, etc. Returns kTRUE in case of failure. ; Reimplemented in TDavixFile, TXNetFile, TDCacheFile, TNetFile, TS3WebFile, TWebFile, and TNetXNGFile.; Definition at line 1821 of file TFile.cxx. ◆ ReadBufferViaCa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:86430,rout,routine,86430,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,1,['rout'],['routine']
Integrability," Removes a feature from the TIOFeatures object; emits an Error message if the IO feature is not supported by this version of ROOT. ; Definition at line 69 of file TIOFeatures.cxx. ◆ GetFeatures(). UChar_t TIOFeatures::GetFeatures ; (; ); const. private . Definition at line 250 of file TIOFeatures.cxx. ◆ Print(). void TIOFeatures::Print ; (; ); const. Print a human-readable representation of the TIOFeatures to stdout. ; Prints a string with the names of all enabled IO features. ; Definition at line 197 of file TIOFeatures.cxx. ◆ Set() [1/4]. bool TIOFeatures::Set ; (; const std::string & ; value). Given a IO feature string, set the corresponding feature. ; Parameters. [in]valueFeature name to test. This allows one to set a feature given a specific string from the TBasket::EIOBits enum.; NOTE this function is quite slow and users are strongly encouraged to use the type-safe Set version instead. This has been added for better CLI interfaces.; Returns true only if a new feature was set; otherwise emits an error message and returns false. ; Definition at line 172 of file TIOFeatures.cxx. ◆ Set() [2/4]. bool TIOFeatures::Set ; (; EIOFeatures ; input_bits). Set a specific IO feature. ; Parameters. [in]input_bitsThe specific feature to enable. Sets a feature in the TIOFeatures object; emits an Error message if the IO feature is not supported by this version of ROOT.; If the feature is supported by ROOT, this function returns true; otherwise, it returns false. ; Definition at line 139 of file TIOFeatures.cxx. ◆ Set() [3/4]. bool TIOFeatures::Set ; (; Experimental::EIOFeatures ; input_bits). Set a specific IO feature. ; Parameters. [in]input_bitsThe specific feature to enable. Sets a feature in the TIOFeatures object; emits an Error message if the IO feature is not supported by this version of ROOT.; If the feature is supported by ROOT, this function returns true; otherwise, it returns false. ; Definition at line 125 of file TIOFeatures.cxx. ◆ Set() [4/4]. void ROOT::TIOFeatur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TIOFeatures.html:5123,message,message,5123,doc/v632/classROOT_1_1TIOFeatures.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TIOFeatures.html,2,['message'],['message']
Integrability," Rescale(Double_t factor) -- Apply global rescaling factor to histogram. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisible(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). RooDataSet * read(const char* filename, const RooArgList& variables, const char* opts = """", const char* commonPath = """", const char* indexCatName = 0); Read given list of ascii files, and construct a data set, using the given; ArgList as structure definition. Multiple file names in fileList should be comma separated. Each; file is optionally prefixed with 'commonPath' if such a path is; provided. The arglist specifies the dimensions of the dataset to be built; and describes the order in which these dimensions appear in the; ascii files to be read. Each line in the ascii file should contain N white space separated; tokens, with N the number of args in 'variables'. Any text beyond; N tokens will be ignored with a warning message.; [ NB: This format is written by RooArgList::writeToStream() ]. If the value of any of the variables on a given line exceeds the; fit range associated with that dimension, the entire line will be; ignored. A warning message is printed in each case, unless the; 'Q' verbose option is given. (Option 'D' will provide additional; debugging information) The number of events read and skipped; is always summarized at the end. When multiple files are read, a RooCategory arg in 'variables' can; optionally be designated to hold information about the source file; of each data point. This feature is enabled by giving the name; of the (already existing) category variable in 'indexCatName'. If no further information is given a label name 'fileNNN' will; be assigned to each event, where NNN is the sequential number of; the source file in 'fileList'. Alternatively it is possible to override the default label names; of the index category by specifying them in the fileLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataSet.html:30830,message,message,30830,root/html526/RooDataSet.html,https://root.cern,https://root.cern/root/html526/RooDataSet.html,11,['message'],['message']
Integrability," ReturnsTClass describing current object ; Reimplemented from TMVA::Results.; Definition at line 82 of file ResultsRegression.h. ◆ Log(). MsgLogger & TMVA::ResultsRegression::Log ; (; ); const. inlineprivate . Definition at line 79 of file ResultsRegression.h. ◆ operator[](). const std::vector< Float_t > & TMVA::ResultsRegression::operator[] ; (; Int_t ; ievt); const. inlineoverridevirtual . Implements TMVA::Results.; Definition at line 67 of file ResultsRegression.h. ◆ QuadraticDeviation(). TH1F * TMVA::ResultsRegression::QuadraticDeviation ; (; UInt_t ; tgtNum, . Bool_t ; truncate = false, . Double_t ; truncvalue = 0. . ). Definition at line 75 of file ResultsRegression.cxx. ◆ Resize(). void TMVA::ResultsRegression::Resize ; (; Int_t ; entries). inline . Definition at line 60 of file ResultsRegression.h. ◆ SetValue(). void TMVA::ResultsRegression::SetValue ; (; std::vector< Float_t > & ; value, . Int_t ; ievt . ). Definition at line 67 of file ResultsRegression.cxx. ◆ Streamer(). void TMVA::ResultsRegression::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TMVA::Results. ◆ StreamerNVirtual(). void TMVA::ResultsRegression::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 82 of file ResultsRegression.h. Member Data Documentation. ◆ fLogger. MsgLogger* TMVA::ResultsRegression::fLogger. mutableprivate . ! message logger ; Definition at line 78 of file ResultsRegression.h. ◆ fRegValues. std::vector<std::vector<Float_t> > TMVA::ResultsRegression::fRegValues. mutableprivate . mva values (Results) ; Definition at line 77 of file ResultsRegression.h. Libraries for TMVA::ResultsRegression:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/ResultsRegression.h; tmva/tmva/src/ResultsRegression.cxx. TMVAResultsRegression. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:41 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ResultsRegression.html:15786,message,message,15786,doc/master/classTMVA_1_1ResultsRegression.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ResultsRegression.html,1,['message'],['message']
Integrability," ReturnsVersion of this class ; Definition at line 233 of file TEveCaloData.h. ◆ DataChanged(). void TEveCaloData::DataChanged ; (; ). virtual . Tell users (TEveCaloViz instances using this data) that data has changed and they should update the limits/scales etc. ; This is done by calling TEveCaloViz::DataChanged(). ; Reimplemented in TEveCaloDataVec, and TEveCaloDataHist.; Definition at line 382 of file TEveCaloData.cxx. ◆ DeclFileName(). static const char * TEveCaloData::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 233 of file TEveCaloData.h. ◆ Empty(). Bool_t TEveCaloData::Empty ; (; ); const. inline . Definition at line 216 of file TEveCaloData.h. ◆ EtaToTheta(). Float_t TEveCaloData::EtaToTheta ; (; Float_t ; eta). static . Definition at line 411 of file TEveCaloData.cxx. ◆ FillImpliedSelectedSet(). void TEveCaloData::FillImpliedSelectedSet ; (; Set_t & ; impSelSet). overridevirtual . Populate set impSelSet with derived / dependant elements. ; Reimplemented from TEveElement.; Definition at line 178 of file TEveCaloData.cxx. ◆ GetCellData(). virtual void TEveCaloData::GetCellData ; (; const CellId_t & ; id, . CellData_t & ; data . ); const. pure virtual . Implemented in TEveCaloDataVec, and TEveCaloDataHist. ◆ GetCellList(). virtual void TEveCaloData::GetCellList ; (; Float_t ; etaMin, . Float_t ; etaMax, . Float_t ; phi, . Float_t ; phiRng, . vCellId_t & ; out . ); const. pure virtual . Implemented in TEveCaloDataVec, and TEveCaloDataHist. ◆ GetCellsHighlighted(). vCellId_t & TEveCaloData::GetCellsHighlighted ; (; ). inline . Definition at line 189 of file TEveCaloData.h. ◆ GetCellsSelected(). vCellId_t & TEveCaloData::GetCellsSelected ; (; ). inline . Definition at line 188 of file TEveCaloData.h. ◆ GetEps(). virtual Float_t TEveCaloData::GetEps ; (; ); const. inlinevirtual . Definition at line 224 of file TEveCaloData.h. ◆ GetEtaBins(). virtual TAxis * TEveCaloData::GetEtaBins ; (; ); const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCaloData.html:36398,depend,dependant,36398,doc/master/classTEveCaloData.html,https://root.cern,https://root.cern/doc/master/classTEveCaloData.html,1,['depend'],['dependant']
Integrability, RooAICRegistry Registry for analytical integration codes; RooAbsAnaConvPdf Abstract Composite Convoluted PDF; RooAbsArg Abstract variable; RooAbsBinning Abstract base class for binning specification; RooAbsCache Base class for cache managers; RooAbsCacheElement Base class for cache elements; RooAbsCachedPdf Abstract base class for cached p.d.f.s; RooAbsCachedReal Abstract base class for cached p.d.f.s; RooAbsCategory Abstract discrete variable; RooAbsCategoryLValue Abstract modifiable index variable; RooAbsCollection Collection of RooAbsArg objects; RooAbsData Abstract data collection; RooAbsDataStore Abstract Data Storage class; RooAbsFunc Abstract real-valued function interface; RooAbsGenContext Abstract context for generating a dataset from a PDF; RooAbsHiddenReal Abstract hidden real-valued variable; RooAbsIntegrator Abstract interface for real-valued function integrators; RooAbsLValue Abstract variable; RooAbsMCStudyModule Monte Carlo study manager add-on module; RooAbsMoment Abstract representation of moment in a RooAbsReal in a given RooRealVar; RooAbsNumGenerator Abstract base class for numeric event generator algorithms; RooAbsOptTestStatistic Abstract base class for optimized test statistics; RooAbsPdf Abstract PDF with normalization support; RooAbsPdf::GenSpec Generation specification; RooAbsProxy Abstract proxy interface; RooAbsReal Abstract real-valued variable; RooAbsRealLValue Abstract modifiable real-valued object; RooAbsRootFinder Abstract interface for 1-dim real-valued function root finders; RooAbsSelfCachedPdf Abstract base class for self-caching p.d.f.s; RooAbsSelfCachedReal Abstract base class for self-caching functions; RooAbsString Abstract string-valued variable; RooAbsStudy Abstract base class for RooStudyManager modules; RooAbsTestStatistic Abstract base class for real-valued test statistics; RooAcceptReject Context for generating a dataset from a PDF; RooAdaptiveGaussKronrodIntegrator1D 1-dimensional adaptive Gauss-Kronrod numerical inte,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:24839,interface,interface,24839,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,20,"['integrat', 'interface']","['integrators', 'interface']"
Integrability," RooAbsArg &other) const override;  Equality operator when comparing to another RooAbsArg. ;  ; bool operator== (double value) const;  Equality operator comparing to a double. ;  ; virtual std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to stream (dummy for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:28681,integrat,integration,28681,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,2,['integrat'],['integration']
Integrability," RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; Bool_tRooResolutionModel::isConvolved(); virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGaussModel.html:20254,message,message,20254,root/html528/RooGaussModel.html,https://root.cern,https://root.cern/root/html528/RooGaussModel.html,6,['message'],['message']
Integrability," RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; Bool_tRooResolutionModel::isConvolved(); virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; virtual Bool_tTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGaussModel.html:20192,message,message,20192,root/html526/RooGaussModel.html,https://root.cern,https://root.cern/root/html526/RooGaussModel.html,3,['message'],['message']
Integrability," RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStringVar.html:3171,depend,dependsOn,3171,root/html532/RooStringVar.html,https://root.cern,https://root.cern/root/html532/RooStringVar.html,2,['depend'],['dependsOn']
Integrability," RooAbsArg.h:294; RooAbsArg::cloneTreevirtual RooAbsArg * cloneTree(const char *newname=nullptr) constClone tree expression of objects.Definition RooAbsArg.cxx:2293; RooAddPdfEfficient implementation of a sum of PDFs of the form.Definition RooAddPdf.h:33; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooMsgService::instancestatic RooMsgService & instance()Return reference to singleton instance.Definition RooMsgService.cxx:345; RooMsgService::getStreamStreamConfig & getStream(Int_t id)Definition RooMsgService.h:161; RooMsgService::resetvoid reset()Definition RooMsgService.cxx:113; RooMsgService::Printvoid Print(Option_t *options=nullptr) const overridePrint configuration of message service.Definition RooMsgService.cxx:486; RooMsgService::addStreamInt_t addStream(RooFit::MsgLevel level, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={})Add a message logging stream for message with given RooFit::MsgLevel or higher.Definition RooMsgService.cxx:177; RooPolynomialRooPolynomial implements a polynomial p.d.f of the form.Definition RooPolynomial.h:25; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooFit::ClassNameRooCmdArg ClassName(const char *name)Definition RooGlobalFunc.cxx:1004; RooFit::TopicRooCmdArg Topic(Int_t topic)Definition RooGlobalFunc.cxx:996; RooFit::OutputFileRooCmdArg OutputFile(const char *fileName)Definition RooGlobalFunc.cxx:517; RooFit::VerboseRooCmdArg Verbose(bool flag=true)Definition RooGlobalFunc.cxx:645; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf506_msgserviceDefinition rf506_msgservice.py:1; RooMsgService::StreamConfig::addTopicvoid addTopic(RooFit::MsgTopi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8C.html:5309,message,message,5309,doc/master/rf506__msgservice_8C.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html,2,['message'],['message']
Integrability," RooAbsPdf. Numeric 1-dimensional convolution operator PDF. This class can convolve any PDF; with any other PDF using a straightforward numeric calculation of the; convolution integral; ; This class should be used as last resort as numeric convolution calculated; this way is computationally intensive and prone to stability fitting problems. ; The preferred way to compute numeric convolutions is RooFFTConvPdf,; which calculates convolutions using Fourier Transforms (requires external free; FFTW3 package); ; RooNumConvPdf implements reasonable defaults that should convolve most; functions reasonably well, but results strongly depend on the shape of your; input PDFS so always check your result.; ; The default integration engine for the numeric convolution is the; adaptive Gauss-Kronrod method, which empirically seems the most robust; for this task. You can override the convolution integration settings via; the RooNumIntConfig object reference returned by the convIntConfig() member; function; ; By default the numeric convolution is integrated from -infinity to; +infinity through a x -> 1/x coordinate transformation of the; tails. For convolution with a very small bandwidth it may be; advantageous (for both CPU consumption and stability) if the; integration domain is limited to a finite range. The function; setConvolutionWindow(mean,width,scale) allows to set a sliding; window around the x value to be calculated taking a RooAbsReal; expression for an offset and a width to be taken around the x; value. These input expression can be RooFormulaVars or other; function objects although the 3d 'scale' argument 'scale'; multiplies the width RooAbsReal expression given in the 2nd; argument, allowing for an appropriate window definition for most; cases without need for a RooFormulaVar object: e.g. a Gaussian; resolution PDF do setConvolutionWindow(gaussMean,gaussSigma,5); Note that for a 'wide' Gaussian the -inf to +inf integration; may converge more quickly than that over a fini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:1189,integrat,integration,1189,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,22,['integrat'],"['integrated', 'integration']"
Integrability," RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); Int_tRooAbsAnaConvPdf::declareBasis(const char* expression, const RooArgList& params); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPEffDecay.html:8997,depend,dependentOverlaps,8997,root/html528/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPEffDecay.html,324,['depend'],"['dependentOverlaps', 'dependsOn', 'dependsOnValue']"
Integrability," RooAbsReal; RooRealBinding Function binding to RooAbsReal object; RooRealConstant RooRealVar constants factory; RooRealIntegral Real-valued function representing an integral over a RooAbsReal object; RooRealMPFE Multi-process front-end for parallel calculation of a real valued function ; RooRealProxy Proxy for a RooAbsReal object; RooRealSumPdf PDF constructed from a sum of (non-pdf) functions; RooRealVar Real-valued variable ; RooRealVarSharedProperties Shared properties of a RooRealVar clone set; RooRecursiveFraction Recursive fraction formula f1*(1-f2)*(1-f3) etc...; RooRefCountList RooLinkedList with reference counting; RooResolutionModel Abstract Resolution Model; RooScaledFunc Function binding applying scaling to another function binding; RooSegmentedIntegrator1D 1-dimensional piece-wise numerical integration engine; RooSegmentedIntegrator2D 2-dimensional piece-wise numerical integration engine; RooSentinel ; RooSetPair Utility class holding a pair of RooArgSet pointers; RooSetProxy Proxy class for a RooArgSet; RooSharedProperties Abstract interface for shared property implementations; RooSharedPropertiesList Manager for shared properties among clones of certain RooAbsArg-derived types; RooSimGenContext Context for efficiently generating a dataset from a RooSimultaneous PDF; RooSimPdfBuilder RooSimultaneous PDF Builder (obsolete); RooSimWSTool Workspace oriented tool for customized cloning of p.d.f. into a simultaneous p.d.f; RooSimWSTool::BuildConfig Build configuration object for RooSimWSTool; RooSimWSTool::MultiBuildConfig Build configuration object for RooSimWSTool with multiple prototype p.d.f.; RooSimWSTool::ObjBuildConfig Validated RooSimWSTool build configuration; RooSimWSTool::ObjSplitRule Validated RooSimWSTool split rule; RooSimWSTool::SplitRule Split rule specification for prototype p.d.f; RooSimultaneous Simultaneous operator p.d.f, functions like C++ 'switch()' on input p.d.fs operating on index category5A; RooSpHarmonic SpHarmonic polynomial; Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:42164,integrat,integration,42164,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,6,"['integrat', 'interface']","['integration', 'interface']"
Integrability," RooAbsReal; RooRealBinding Function binding to RooAbsReal object; RooRealConstant RooRealVar constants factory; RooRealIntegral Real-valued function representing an integral over a RooAbsReal object; RooRealMPFE Multi-process front-end for parallel calculation of a real valued function ; RooRealProxy Proxy for a RooAbsReal object; RooRealSumPdf PDF constructed from a sum of (non-pdf) functions; RooRealVar Real-valued variable ; RooRealVarSharedProperties Shared properties of a RooRealVar clone set; RooRecursiveFraction Recursive fraction formula f1*(1-f2)*(1-f3) etc...; RooRefCountList RooLinkedList with reference counting; RooResolutionModel Abstract Resolution Model; RooScaledFunc Function binding applying scaling to another function binding; RooSegmentedIntegrator1D 1-dimensional piece-wise numerical integration engine; RooSegmentedIntegrator2D 2-dimensional piece-wise numerical integration engine; RooSentinel ; RooSetPair Utility class holding a pair of RooArgSet pointers; RooSetProxy Proxy class for a RooArgSet; RooSharedProperties Abstract interface for shared property implementations; RooSharedPropertiesList Manager for shared properties among clones of certain RooAbsArg-derived types; RooSimGenContext Context for efficiently generating a dataset from a RooSimultaneous PDF; RooSimPdfBuilder RooSimultaneous PDF Builder (obsolete); RooSimWSTool Workspace oriented tool for customized cloning of p.d.f. into a simultaneous p.d.f; RooSimWSTool::BuildConfig Build configuration object for RooSimWSTool; RooSimWSTool::MultiBuildConfig Build configuration object for RooSimWSTool with multiple prototype p.d.f.; RooSimWSTool::ObjBuildConfig Validated RooSimWSTool build configuration; RooSimWSTool::ObjSplitRule Validated RooSimWSTool split rule; RooSimWSTool::SplitRule Split rule specification for prototype p.d.f; RooSimultaneous Simultaneous operator p.d.f, functions like C++ 'switch()' on input p.d.fs operating on index category5A; RooStats ; RooStats::AcceptanceRegion A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:40375,integrat,integration,40375,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,6,"['integrat', 'interface']","['integration', 'interface']"
Integrability," RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooObjCacheManager _cacheMgr;  ! The cache manager ;  ; RooArgList _ownedList;  List of owned components. ;  ; RooListProxy _set;  set of terms to be summed ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddition.html:55257,integrat,integration,55257,doc/master/classRooAddition.html,https://root.cern,https://root.cern/doc/master/classRooAddition.html,1,['integrat'],['integration']
Integrability," RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); Int_tdeclareBasis(const char* expression, const RooArgList& params); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsAnaConvPdf.html:10166,depend,dependentOverlaps,10166,root/html530/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsAnaConvPdf.html,48,['depend'],"['dependentOverlaps', 'dependsOn', 'dependsOnValue']"
Integrability," RooArgSet& obs, RooArgSet& orderedObs) const; 3695{; 3696 // Dummy implementation, do nothing; 3697 orderedObs.removeAll() ;; 3698 orderedObs.add(obs) ;; 3699}; 3700 ; 3701 ; 3702 ; 3703////////////////////////////////////////////////////////////////////////////////; 3704/// Calls createRunningIntegral(const RooArgSet&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&, const RooCmdArg&); 3705 ; 3706RooFit::OwningPtr<RooAbsReal> RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset); 3707{; 3708 return createRunningIntegral(iset,RooFit::SupNormSet(nset)) ;; 3709}; 3710 ; 3711 ; 3712 ; 3713////////////////////////////////////////////////////////////////////////////////; 3714/// Create an object that represents the running integral of the function over one or more observables listed in iset, i.e.; 3715/// \f[; 3716/// \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; 3717/// \f]; 3718///; 3719/// The actual integration calculation is only performed when the return object is evaluated. The name; 3720/// of the integral object is automatically constructed from the name of the input function, the variables; 3721/// it integrates and the range integrates over. The default strategy to calculate the running integrals is; 3722///; 3723/// - If the integrand (this object) supports analytical integration, construct an integral object; 3724/// that calculate the running integrals value by calculating the analytical integral each; 3725/// time the running integral object is evaluated; 3726///; 3727/// - If the integrand (this object) requires numeric integration to construct the running integral; 3728/// create an object of class RooNumRunningInt which first samples the entire function and integrates; 3729/// the sampled function numerically. This method has superior performance as there is no need to; 3730/// perform a full (numeric) integration for each evaluation of the running in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:158650,integrat,integration,158650,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['integrat'],['integration']
Integrability," RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&RooAbsOptTestStatistic::data(); const RooAbsData&RooAbsOptTestStatistic::data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooDataWeightedAverage.html:9416,depend,dependentOverlaps,9416,root/html530/RooDataWeightedAverage.html,https://root.cern,https://root.cern/root/html530/RooDataWeightedAverage.html,54,['depend'],"['dependentOverlaps', 'dependsOn', 'dependsOnValue']"
Integrability," RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_double_double_.html:44787,integrat,integrator,44787,root/html602/RooCFunction3PdfBinding_double_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_double_double_.html,4,['integrat'],['integrator']
Integrability," RooBinSamplingPdf.h. ◆ isDirectGenSafe(). bool RooBinSamplingPdf::isDirectGenSafe ; (; const RooAbsArg & ; arg); const. inlineoverridevirtual . Forwards to the PDF's implementation. ; Reimplemented from RooAbsPdf.; Definition at line 91 of file RooBinSamplingPdf.h. ◆ maxVal(). double RooBinSamplingPdf::maxVal ; (; Int_t ; code); const. inlineoverridevirtual . Return maximum value for set of observables identified by code assigned in getMaxVal. ; Reimplemented from RooAbsReal.; Definition at line 96 of file RooBinSamplingPdf.h. ◆ minTrialSamples(). Int_t RooBinSamplingPdf::minTrialSamples ; (; const RooArgSet & ; arGenObs); const. inlineoverridevirtual . Reimplemented from RooAbsReal.; Definition at line 97 of file RooBinSamplingPdf.h. ◆ observable(). const RooAbsReal & RooBinSamplingPdf::observable ; (; ); const. inline . Definition at line 111 of file RooBinSamplingPdf.h. ◆ operator()(). double RooBinSamplingPdf::operator() ; (; double ; x); const. private . Binding used by the integrator to evaluate the PDF. ; Definition at line 294 of file RooBinSamplingPdf.cxx. ◆ pdf(). const RooAbsPdf & RooBinSamplingPdf::pdf ; (; ); const. inline . Definition at line 110 of file RooBinSamplingPdf.h. ◆ plotSamplingHint(). std::list< double > * RooBinSamplingPdf::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. overridevirtual . Return a list of all bin edges, so the PDF is plotted as a step function. ; Parameters. [in]obsObservable to generate the sampling hint for. ; [in]xloBeginning of range to create sampling hint for. ; [in]xhiEnd of range to create sampling hint for. . ReturnsPointer to a list to be deleted by caller. ; Reimplemented from RooAbsReal.; Definition at line 237 of file RooBinSamplingPdf.cxx. ◆ selfNormalized(). bool RooBinSamplingPdf::selfNormalized ; (; ); const. inlineoverridevirtual . Forwards to the PDF's implementation. ; Reimplemented from RooAbsPdf.; Definition at line 69 of file RooBinSamplingPdf.h. ◆ Streamer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:89269,integrat,integrator,89269,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['integrat'],['integrator']
Integrability," RooBinSamplingPdf::getMaxVal ; (; const RooArgSet & ; vars); const. inlineoverridevirtual . Advertise capability to determine maximum value of function for given set of observables. ; If no direct generator method is provided, this information will assist the accept/reject generator to operate more efficiently as it can skip the initial trial sampling phase to empirically find the function maximum ; Reimplemented from RooAbsReal.; Definition at line 95 of file RooBinSamplingPdf.h. ◆ initGenerator(). void RooBinSamplingPdf::initGenerator ; (; Int_t ; code). inlineoverridevirtual . Forwards to the PDF's implementation. ; Reimplemented from RooAbsPdf.; Definition at line 87 of file RooBinSamplingPdf.h. ◆ integrate(). double RooBinSamplingPdf::integrate ; (; const RooArgSet * ; normSet, . double ; low, . double ; high . ); const. private . Integrate the wrapped PDF using our current integrator, with given norm set and limits. ; Definition at line 302 of file RooBinSamplingPdf.cxx. ◆ integrator(). std::unique_ptr< ROOT::Math::IntegratorOneDim > & RooBinSamplingPdf::integrator ; (; ); const. Direct access to the unique_ptr holding the integrator that's used to sample the bins. ; This can be used to change options such as sampling accuracy or to entirely exchange the integrator.; Example: Use the 61-point Gauss-Kronrod integration rule; ROOT::Math::IntegratorOneDimOptions intOptions = pdf.integrator()->Options();; intOptions.SetNPoints(6); // 61-point integration rule; intOptions.SetRelTolerance(1.E-9); // Smaller tolerance -> more subdivisions; pdf.integrator()->SetOptions(intOptions);; ROOT::Math::BaseIntegratorOptions::SetRelTolerancevoid SetRelTolerance(double tol)set the relative toleranceDefinition IntegratorOptions.h:80; ROOT::Math::IntegratorOneDimOptionsNumerical one dimensional integration options.Definition IntegratorOptions.h:113; ROOT::Math::IntegratorOneDimOptions::SetNPointsvoid SetNPoints(unsigned int n)Set number of points for active integration rule.Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:86532,integrat,integrator,86532,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['integrat'],['integrator']
Integrability," RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const;  Plot (project) PDF on specified frame. ;  ; virtual RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const;  Internal back-end function of plotOn() with named arguments. ;  ; virtual std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constructor. ;  ;  RooAbsArg (const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:27459,integrat,integration,27459,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['integrat'],['integration']
Integrability," RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which shoul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:66856,integrat,integration,66856,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,18,['integrat'],"['integrates', 'integration']"
Integrability," RooDataSet. ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the specialized integrator configuration for this RooAbsReal. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsArg;  RooAbsArg ();  Default constructor. ;  ;  RooAbsArg (const char *name, const char *title);  Create an object with the specified name and descriptive title. ;  ;  RooAbsArg (const RooAbsArg &other, const char *name=nullptr);  Copy constructor transfers all boolean and string properties of the original object. ;  ;  ~RooAbsArg () override;  Destructor. ;  ; bool addOwnedComponents (const RooAbsCollection &comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooAbsCollection &&comps);  Take ownership of the contents of 'comps'. ;  ; bool addOwnedComponents (RooArgList &&comps);  Take ownership of the contents of 'comps'. ;  ; template<typename... Args_t> ; bool addOwnedComponents (std::unique_ptr< Args_t >... comps);  ; virtual void applyWeightSquared (bool flag);  Disab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:28199,integrat,integrator,28199,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['integrat'],['integrator']
Integrability, RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAb,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:38914,integrat,integrated,38914,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,1,['integrat'],['integrated']
Integrability, RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRoo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:39344,integrat,integrated,39344,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,1,['integrat'],['integrated']
Integrability, RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCachedPdf.html:39813,integrat,integrated,39813,root/html530/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html,1,['integrat'],['integrated']
Integrability," RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. Int_t activeStream(const TObject* self, RooFit::MsgTopic facility, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. ostream& log(const RooAbsArg* self, RooFit::MsgLevel level, RooFit::MsgTopic facility, Bool_t forceSkipPrefix = kFALSE); Log error message associated with RooAbsArg object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. ostream& log(const TObject* self, RooFit::MsgLevel level, RooFit::MsgTopic facility, Bool_t forceSkipPrefix = kFALSE); Log error message associated with TObject object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. void Print(Option_t* options = 0) const; Print configuration of message service. If ""v"" option is given also; inactive streams are listed. StreamConfig& getStream(Int_t id); { return _streams[id] ; }. Int_t numStreams() const; { return _streams.size() ; }. void reset(); { cleanup() ; }. void setGlobalKillBelow(RooFit::MsgLevel level); { _globMinLevel = level ; }. RooFit::MsgLevel globalKillBelow() const; { return _globMinLevel ; }. void showPid(Bool_t flag); { _showPid = flag ; }. Bool_t silentMode() const; Print level support for RooFit-related messages that are not routed through RooMsgService (such as Minuit printouts). { return _silentMode ; }. void setSilentMode(Bool_t flag); { _silentMode = flag ; }. Int_t errorCount() const; { return _errorCount ; }. void clearErrorCount(); { _errorCount = 0 ; }. Int_t& debugCode(); { return _debugCode ; }. RooMsgService(); Private ctor -- singleton class. » Last changed: Fri Dec 10 17:05:04 2010 » Last generated: 2010-12-10 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMsgService.html:12134,message,messages,12134,root/html528/RooMsgService.html,https://root.cern,https://root.cern/root/html528/RooMsgService.html,2,"['message', 'rout']","['messages', 'routed']"
Integrability," RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. Int_t activeStream(const TObject* self, RooFit::MsgTopic facility, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. ostream& log(const RooAbsArg* self, RooFit::MsgLevel level, RooFit::MsgTopic facility, Bool_t forceSkipPrefix = kFALSE); Log error message associated with RooAbsArg object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. ostream& log(const TObject* self, RooFit::MsgLevel level, RooFit::MsgTopic facility, Bool_t forceSkipPrefix = kFALSE); Log error message associated with TObject object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. void Print(Option_t* options = 0) const; Print configuration of message service. If ""v"" option is given also; inactive streams are listed. StreamConfig& getStream(Int_t id); { return _streams[id] ; }. Int_t numStreams() const; { return _streams.size() ; }. void reset(); { cleanup() ; }. void setGlobalKillBelow(RooFit::MsgLevel level); { _globMinLevel = level ; }. RooFit::MsgLevel globalKillBelow() const; { return _globMinLevel ; }. void showPid(Bool_t flag); { _showPid = flag ; }. Bool_t silentMode() const; Print level support for RooFit-related messages that are not routed through RooMsgService (such as Minuit printouts). { return _silentMode ; }. void setSilentMode(Bool_t flag); { _silentMode = flag ; }. Int_t errorCount() const; { return _errorCount ; }. void clearErrorCount(); { _errorCount = 0 ; }. Int_t& debugCode(); { return _debugCode ; }. RooMsgService(); Private ctor -- singleton class. » Last changed: Tue Jun 30 14:34:06 2015 » Last generated: 2015-06-30 14:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMsgService.html:12679,message,messages,12679,root/html602/RooMsgService.html,https://root.cern,https://root.cern/root/html602/RooMsgService.html,4,"['message', 'rout']","['messages', 'routed']"
Integrability," RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. Int_t activeStream(const TObject* self, RooFit::MsgTopic facility, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. ostream& log(const RooAbsArg* self, RooFit::MsgLevel level, RooFit::MsgTopic facility, Bool_t forceSkipPrefix = kFALSE); Log error message associated with RooAbsArg object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. ostream& log(const TObject* self, RooFit::MsgLevel level, RooFit::MsgTopic facility, Bool_t forceSkipPrefix = kFALSE); Log error message associated with TObject object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. void Print(Option_t* options = 0) const; Print configuration of message service. If ""v"" option is given also; inactive streams are listed. StreamConfig& getStream(Int_t id); { return _streams[id] ; }. Int_t numStreams() const; { return _streams.size() ; }. void reset(); { cleanup() ; }. void setGlobalKillBelow(RooFit::MsgLevel level); { _globMinLevel = level ; }. RooFit::MsgLevel globalKillBelow() const; { return _globMinLevel ; }. void showPid(Bool_t flag); { _showPid = flag ; }. Bool_t silentMode() const; Print level support for RooFit-related messages that are not routed through RooMsgService (such as Minuit printouts). { return _silentMode ; }. void setSilentMode(Bool_t flag); { _silentMode = flag ; }. Int_t errorCount() const; { return _errorCount ; }. void clearErrorCount(); { _errorCount = 0 ; }. Int_t& debugCode(); { return _debugCode ; }. RooMsgService(); Private ctor -- singleton class. » Last changed: Tue Mar 10 17:17:55 2015 » Last generated: 2015-03-10 17:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMsgService.html:12222,message,messages,12222,root/html534/RooMsgService.html,https://root.cern,https://root.cern/root/html534/RooMsgService.html,4,"['message', 'rout']","['messages', 'routed']"
Integrability," RooFormula::getTFormula ; (; ); const. inline . Definition at line 72 of file RooFormula.h. ◆ installFormulaOrThrow(). void RooFormula::installFormulaOrThrow ; (; const std::string & ; formulaa). private . Check that the formula compiles, and also fulfills the assumptions. ; Definition at line 493 of file RooFormula.cxx. ◆ ok(). bool RooFormula::ok ; (; ); const. inline . Definition at line 50 of file RooFormula.h. ◆ operator=() [1/2]. RooFormula & RooFormula::operator= ; (; const RooFormula & ; other). delete . ◆ operator=() [2/2]. RooFormula & RooFormula::operator= ; (; RooFormula && ; other). delete . ◆ Print(). void RooFormula::Print ; (; Option_t * ; option = nullptr); const. inlineoverridevirtual . This method must be overridden when a class wants to print itself. ; Reimplemented from TObject.; Definition at line 65 of file RooFormula.h. ◆ printArgs(). void RooFormula::printArgs ; (; std::ostream & ; os); const. overridevirtual . Print arguments of formula, i.e. dependents that are actually used. ; Reimplemented from RooPrintable.; Definition at line 480 of file RooFormula.cxx. ◆ printClassName(). void RooFormula::printClassName ; (; std::ostream & ; os); const. overridevirtual . Print class name of formula. ; Reimplemented from RooPrintable.; Definition at line 471 of file RooFormula.cxx. ◆ printMultiline(). void RooFormula::printMultiline ; (; std::ostream & ; os, . Int_t ; contents, . bool ; verbose = false, . TString ; indent = """" . ); const. overridevirtual . Printing interface. ; Reimplemented from RooPrintable.; Definition at line 430 of file RooFormula.cxx. ◆ printName(). void RooFormula::printName ; (; std::ostream & ; os); const. overridevirtual . Print name of formula. ; Reimplemented from RooPrintable.; Definition at line 453 of file RooFormula.cxx. ◆ printTitle(). void RooFormula::printTitle ; (; std::ostream & ; os); const. overridevirtual . Print title of formula. ; Reimplemented from RooPrintable.; Definition at line 462 of file RooFormula.cxx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFormula.html:21860,depend,dependents,21860,doc/master/classRooFormula.html,https://root.cern,https://root.cern/doc/master/classRooFormula.html,1,['depend'],['dependents']
Integrability," RooFormulaVar(); RooFormulaVar(const RooFormulaVar& other, const char* name = 0); RooFormulaVar(const char* name, const char* title, const RooArgList& dependents); RooFormulaVar(const char* name, const char* title, const char* formula, const RooArgList& dependents); virtual~RooFormulaVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFormulaVar.html:1373,depend,dependents,1373,root/html534/RooFormulaVar.html,https://root.cern,https://root.cern/root/html534/RooFormulaVar.html,4,['depend'],['dependents']
Integrability," RooFormulaVar(); RooFormulaVar(const RooFormulaVar& other, const char* name = 0); RooFormulaVar(const char* name, const char* title, const RooArgList& dependents); RooFormulaVar(const char* name, const char* title, const char* formula, const RooArgList& dependents); virtual~RooFormulaVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooFormulaVar.html:1358,depend,dependents,1358,root/html528/RooFormulaVar.html,https://root.cern,https://root.cern/root/html528/RooFormulaVar.html,8,['depend'],['dependents']
Integrability," RooFormulaVar(); RooFormulaVar(const RooFormulaVar& other, const char* name = 0); RooFormulaVar(const char* name, const char* title, const RooArgList& dependents); RooFormulaVar(const char* name, const char* title, const char* formula, const RooArgList& dependents); virtual~RooFormulaVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFormulaVar.html:1358,depend,dependents,1358,root/html526/RooFormulaVar.html,https://root.cern,https://root.cern/root/html526/RooFormulaVar.html,2,['depend'],['dependents']
Integrability," RooGenericPdf(); RooGenericPdf(const RooGenericPdf& other, const char* name = 0); RooGenericPdf(const char* name, const char* title, const RooArgList& dependents); RooGenericPdf(const char* name, const char* title, const char* formula, const RooArgList& dependents); virtual~RooGenericPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGenericPdf.html:1260,depend,dependents,1260,root/html528/RooGenericPdf.html,https://root.cern,https://root.cern/root/html528/RooGenericPdf.html,12,['depend'],['dependents']
Integrability," RooGenericPdf(); RooGenericPdf(const RooGenericPdf& other, const char* name = 0); RooGenericPdf(const char* name, const char* title, const RooArgList& dependents); RooGenericPdf(const char* name, const char* title, const char* formula, const RooArgList& dependents); virtual~RooGenericPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenericPdf.html:1260,depend,dependents,1260,root/html526/RooGenericPdf.html,https://root.cern,https://root.cern/root/html526/RooGenericPdf.html,2,['depend'],['dependents']
Integrability," RooIntegrator1D(const RooAbsFunc& function, const RooNumIntConfig& config); Construct integrator on given function binding, using specified; configuration object. The integration limits are taken from the; function binding. RooIntegrator1D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, const RooNumIntConfig& config); Construct integrator on given function binding, using specified; configuration object and integration range. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; Clone integrator with new function binding and configuration. Needed by RooNumIntFactory. Bool_t initialize(); Initialize the integrator. ~RooIntegrator1D(); Destructor. Bool_t setLimits(Double_t* xmin, Double_t* xmax); Change our integration limits. Return kTRUE if the new limits are; ok, or otherwise kFALSE. Always returns kFALSE and does nothing; if this object was constructed to always use our integrand's limits. Bool_t checkLimits() const; Check that our integration range is finite and otherwise return kFALSE.; Update the limits from the integrand if requested. Double_t integral(const Double_t* yvec = 0); Calculate numeric integral at given set of function binding parameters. Double_t addMidpoints(Int_t n); Calculate the n-th stage of refinement of the Second Euler-Maclaurin; summation rule which has the useful property of not evaluating the; integrand at either of its endpoints but requires more function; evaluations than the trapezoidal rule. This rule can be used with; a suitable change of variables to estimate improper integrals. Double_t addTrapezoids(Int_t n); Calculate the n-th stage of refinement of the extended trapezoidal; summation rule. This is the most efficient rule for a well behaved; integrand that can be evaluated over its entire range, including the; endpoints. void extrapolate(Int_t n); Extrapolate result to final value. RooIntegrator1D(). Bool_t setUseIntegrandLimits(Bool_t flag); {_useIntegrandLimits = flag ; return kTRU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooIntegrator1D.html:9687,integrat,integration,9687,root/html528/RooIntegrator1D.html,https://root.cern,https://root.cern/root/html528/RooIntegrator1D.html,10,['integrat'],['integration']
Integrability," RooMCStudy(const RooAbsPdf& genModel, const RooAbsPdf& fitModel, const RooArgSet& dependents, const char* genOptions = """", const char* fitOptions = """", const RooDataSet* genProtoData = 0, const RooArgSet& projDeps = RooArgSet()); RooMCStudy(const RooAbsPdf& model, const RooArgSet& observables, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual~RooMCStudy(); voidTObject::AbstractMethod(const char* method) const; Bool_taddFitResult(const RooFitResult& fr); voidaddModule(RooAbsMCStudyModule& module); virtual voidTObject::AppendPad(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMCStudy.html:1303,depend,dependents,1303,root/html526/RooMCStudy.html,https://root.cern,https://root.cern/root/html526/RooMCStudy.html,1,['depend'],['dependents']
Integrability," RooMCStudy(const RooAbsPdf& genModel, const RooAbsPdf& fitModel, const RooArgSet& dependents, const char* genOptions = """", const char* fitOptions = """", const RooDataSet* genProtoData = 0, const RooArgSet& projDeps = RooArgSet()); RooMCStudy(const RooAbsPdf& model, const RooArgSet& observables, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual~RooMCStudy(); voidTObject::AbstractMethod(const char* method) const; Bool_taddFitResult(const RooFitResult& fr); voidaddModule(RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMCStudy.html:1303,depend,dependents,1303,root/html528/RooMCStudy.html,https://root.cern,https://root.cern/root/html528/RooMCStudy.html,6,['depend'],['dependents']
Integrability," RooPlot *frame = x.frame(40);; data->plotOn(frame);; modelx->plotOn(frame);; ; // Make 2D histogram of model(x,y); TH1 *hh = model.createHistogram(""x,y"");; hh->SetLineColor(kBlue);; ; TCanvas *c = new TCanvas(""rf315_projectpdf"", ""rf315_projectpdf"", 800, 400);; c->Divide(2);; c->cd(1);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; c->cd(2);; gPad->SetLeftMargin(0.20);; hh->GetZaxis()->SetTitleOffset(2.5);; hh->Draw(""surf"");; }; c#define c(i)Definition RSha256.hxx:101; e#define e(i)Definition RSha256.hxx:103; RooDataHist.h; RooGaussian.h; RooNumIntConfig.h; RooPlot.h; RooPolyVar.h; RooProdPdf.h; RooRealVar.h; kBlue@ kBlueDefinition Rtypes.h:66; TAxis.h; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TH1.h; gPad#define gPadDefinition TVirtualPad.h:308; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::plotOnRooPlot * plotOn(RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const overrideHelper calling plotOn(RooPlot*, RooLinkedList&) const.Definition RooAbsPdf.h:124; RooAbsPdf::fitToRooFit::OwningPtr< RooFitResult > fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)Fit PDF to given dataset.Definition RooAbsPdf.h:157; RooAbsPdf::generateBinnedvirtual RooFit::OwningPtr< RooDataHist > generateBinned(const RooArgSet &whatVars, double nEvents, const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}) constAs RooAbsPdf::generateBinned(const RooArgSet&, const RooCmdArg&,const RooCmdArg&, const RooCmdArg&,...Definition RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf315__projectpdf_8C.html:3192,interface,interface,3192,doc/master/rf315__projectpdf_8C.html,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8C.html,1,['interface'],['interface']
Integrability," RooProjectedPdf(const RooProjectedPdf& other, const char* name = 0); Copy constructor. Double_t getVal(const RooArgSet* set = 0) const; Special version of getVal() overrides RooAbsReal::getVal() to save value of current normalization set. Double_t evaluate() const; Evaluate projected p.d.f. const RooAbsReal* getProjection(const RooArgSet* iset, const RooArgSet* nset, const char* rangeName, int& code) const; Retrieve object representing projection integral of input p.d.f; over observables iset, while normalizing over observables; nset. The code argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const RooArgSet& iset); Special version of RooAbsReal::createProjection that deals with; projections of projections. Instead of integrating twice, a new; RooProjectedPdf is returned that is configured to perform the; complete integration in one step. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to relegate integration of all observables to internal logic. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Mark all requested variables as internally integrated. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral represent by appropriate element of projection cache. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; No internal generator is implemented. void generateEvent(Int_t code); No internal generator is implemented. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t , Bool_t , Bool_t ); Intercept a server redirection all and update list of dependents if necessary; Specifically update the set proxy 'deps' which introduces the dependency; on server value dirty flags of ourselves. void printMetaArgs(ostream& os) const; Customized print",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProjectedPdf.html:41463,integrat,integration,41463,root/html526/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html526/RooProjectedPdf.html,3,['integrat'],['integration']
Integrability," RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobian; TIterator*_jacListIter! Iterator over lvalue observables with Jacobian; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_mode; static Int_tRooPrintable::_nameLength; TNamed*RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealIntegral.html:34232,integrat,integration,34232,root/html534/RooRealIntegral.html,https://root.cern,https://root.cern/root/html534/RooRealIntegral.html,2,['integrat'],['integration']
Integrability, RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effFuncEfficiency modeling function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumbe,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooEfficiency.html:37049,integrat,integration,37049,root/html526/RooEfficiency.html,https://root.cern,https://root.cern/root/html526/RooEfficiency.html,1,['integrat'],['integration']
Integrability, RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effFuncEfficiency modeling function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooEfficiency.html:37431,integrat,integration,37431,root/html528/RooEfficiency.html,https://root.cern,https://root.cern/root/html528/RooEfficiency.html,4,['integrat'],['integration']
Integrability, RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet! Current normalization set; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; TVectorD*_mref; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfI,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMomentMorph.html:37283,integrat,integration,37283,root/html526/RooMomentMorph.html,https://root.cern,https://root.cern/root/html526/RooMomentMorph.html,1,['integrat'],['integration']
Integrability, RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet! Current normalization set; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; TVectorD*_mref; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state pr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMomentMorph.html:37665,integrat,integration,37665,root/html528/RooMomentMorph.html,https://root.cern,https://root.cern/root/html528/RooMomentMorph.html,4,['integrat'],['integration']
Integrability," RooWorkspace*_debugWorkspace; ostream*_devnull; Int_t_errorCount; map<string,ostream*>_files; RooFit::MsgLevel_globMinLevel; static RooMsgService*_instance; RooFit::MsgLevel_lastMsgLevel; Bool_t_showPid; Bool_t_silentMode; vector<RooMsgService::StreamConfig>_streams; stack<vector<RooMsgService::StreamConfig> >_streamsSaved. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup function called by atexit() handler installed by RooSentinel; to delete all global object upon program termination. RooMsgService(); Constructor. Defines names of message levels; and mapping of topic codes to topic names; Install default message streams. ~RooMsgService(); Destructor. Bool_t anyDebug(); Returns true if any debug level stream is active. RooWorkspace* debugWorkspace(). Int_t addStream(RooFit::MsgLevel level, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg()); Add a message logging stream for message with given RooFit::MsgLevel or higher (i.e. more severe); This method accepts the following arguments to configure the stream. Output Style options. Prefix(Bool_t flag=kTRUE) -- Prefix all messages in this stream with Topic/Originator information. Filtering options. Topic(const char*) -- Restrict stream to messages on given topic; ObjectName(const char*) -- Restrict stream to messages from object with given name; ClassName(const char*) -- Restrict stream to messages from objects with given class name; BaseClassName(const char*)-- Restrict stream to messages from objects with given base class name; LabelName(const chat*) -- Restrict stream to messages from objects setAtrribute(const char*) tag with given name. Output redirection options. OutputFile(const char*) -- Send output to file with given name. Multiple streams can write to same file.; OutputStream(os",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMsgService.html:9354,message,message,9354,root/html602/RooMsgService.html,https://root.cern,https://root.cern/root/html602/RooMsgService.html,8,['message'],['message']
Integrability," RooXYChi2Var(); RooXYChi2Var(const RooXYChi2Var& other, const char* name = 0); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); virtual~RooXYChi2Var(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooXYChi2Var.html:956,integrat,integrate,956,root/html528/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html528/RooXYChi2Var.html,24,['integrat'],['integrate']
Integrability," RooXYChi2Var(); RooXYChi2Var(const RooXYChi2Var& other, const char* name = 0); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE); virtual~RooXYChi2Var(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooXYChi2Var.html:956,integrat,integrate,956,root/html526/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html526/RooXYChi2Var.html,4,['integrat'],['integrate']
Integrability," SaveSelf();; 1558 ; 1559 // recursively save all sub-directories; 1560 if (fList && fList->FirstLink()) {; 1561 auto lnk = fList->FirstLink()->shared_from_this();; 1562 while (lnk) {; 1563 TObject *idcur = lnk->GetObject();; 1564 if (idcur && idcur->InheritsFrom(TDirectoryFile::Class())) {; 1565 TDirectoryFile *dir = (TDirectoryFile *)idcur;; 1566 dir->Save();; 1567 }; 1568 lnk = lnk->NextSP();; 1569 }; 1570 }; 1571}; 1572 ; 1573////////////////////////////////////////////////////////////////////////////////; 1574/// Save object in filename.; 1575///; 1576/// If filename is `nullptr` or """", a file with ""<objectname>.root"" is created.; 1577/// The name of the key is the object name.; 1578/// By default new file will be created. Using option ""a"", one can append object; 1579/// to the existing ROOT file.; 1580/// If the operation is successful, it returns the number of bytes written to the file; 1581/// otherwise it returns 0.; 1582/// By default a message is printed. Use option ""q"" to not print the message.; 1583/// If filename contains "".json"" extension, JSON representation of the object; 1584/// will be created and saved in the text file. Such file can be used in; 1585/// JavaScript ROOT (https://root.cern/js/) to display object in web browser; 1586/// When creating JSON file, option string may contain compression level from 0 to 3 (default 0); 1587 ; 1588Int_t TDirectoryFile::SaveObjectAs(const TObject *obj, const char *filename, Option_t *option) const; 1589{; 1590 // option can contain single letter args: ""a"" for append, ""q"" for quiet in any combinations; 1591 ; 1592 if (!obj) return 0;; 1593 TString fname, opt = option;; 1594 if (filename && *filename); 1595 fname = filename;; 1596 else; 1597 fname.Form(""%s.root"", obj->GetName());; 1598 opt.ToLower();; 1599 ; 1600 Int_t nbytes = 0;; 1601 if (fname.Index("".json"") > 0) {; 1602 nbytes = TBufferJSON::ExportToFile(fname, obj, option);; 1603 } else {; 1604 TContext ctxt; // The TFile::Open will change the current dire",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:53826,message,message,53826,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['message'],['message']
Integrability," Scalar_t > &weights_candidate, const TMatrixT< Scalar_t > &weights_reset_state, const TMatrixT< Scalar_t > &weights_update_state, const TMatrixT< Scalar_t > &weights_candidate_state, const TMatrixT< Scalar_t > &input, TMatrixT< Scalar_t > &input_gradient);  Backward pass for GRU Network. ;  ; static void ScaleAdd (TMatrixT< Scalar_t > &A, const TMatrixT< Scalar_t > &B, Scalar_t beta=1.0);  Adds a the elements in matrix B scaled by c to the elements in the matrix A. ;  ; static void Copy (TMatrixT< Scalar_t > &A, const TMatrixT< Scalar_t > &B);  ; template<typename AMatrix_t > ; static void CopyDiffArch (TMatrixT< Scalar_t > &A, const AMatrix_t &B);  ; static void ScaleAdd (std::vector< TMatrixT< Scalar_t > > &A, const std::vector< TMatrixT< Scalar_t > > &B, Scalar_t beta=1.0);  Above functions extended to vectors. ;  ; static void Copy (std::vector< TMatrixT< Scalar_t > > &A, const std::vector< TMatrixT< Scalar_t > > &B);  ; template<typename AMatrix_t > ; static void CopyDiffArch (std::vector< TMatrixT< Scalar_t > > &A, const std::vector< AMatrix_t > &B);  ; Activation Functions; For each activation function, the low-level interface contains two routines.; One that applies the activation function to a matrix and one that evaluate the derivatives of the activation function at the elements of a given matrix and writes the results into the result matrix. . static void Identity (TMatrixT< AReal > &B);  ; static void IdentityDerivative (TMatrixT< AReal > &B, const TMatrixT< AReal > &A);  ; static void Relu (TMatrixT< AReal > &B);  ; static void ReluDerivative (TMatrixT< AReal > &B, const TMatrixT< AReal > &A);  ; static void Sigmoid (TMatrixT< AReal > &B);  ; static void SigmoidDerivative (TMatrixT< AReal > &B, const TMatrixT< AReal > &A);  ; static void Tanh (TMatrixT< AReal > &B);  ; static void TanhDerivative (TMatrixT< AReal > &B, const TMatrixT< AReal > &A);  ; static void FastTanh (Tensor_t &B);  ; static void FastTanhDerivative (Tensor_t &B, const Tensor_t &A);  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html:9075,interface,interface,9075,doc/master/classTMVA_1_1DNN_1_1TReference.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html,2,"['interface', 'rout']","['interface', 'routines']"
Integrability," ScanNone(); 3735/// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; 3736/// granularity for the scanning technique can be controlled with the ScanParameters technique; 3737/// which allows to specify the number of samples to be taken, and to which order the resulting; 3738/// running integral should be interpolated. The default values are 1000 samples and 2nd order; 3739/// interpolation.; 3740///; 3741/// The following named arguments are accepted; 3742/// | | Effect on integral creation; 3743/// |-|-------------------------------; 3744/// | `SupNormSet(const RooArgSet&)` | Observables over which should be normalized _in addition_ to the integration observables; 3745/// | `ScanParameters(Int_t nbins, Int_t intOrder)` | Parameters for scanning technique of making CDF: number of sampled bins and order of interpolation applied on numeric cdf; 3746/// | `ScanNum()` | Apply scanning technique if cdf integral involves numeric integration; 3747/// | `ScanAll()` | Always apply scanning technique; 3748/// | `ScanNone()` | Never apply scanning technique; 3749 ; 3750RooFit::OwningPtr<RooAbsReal> RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2,; 3751 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 3752 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 3753{; 3754 // Define configuration for this method; 3755 RooCmdConfig pc(""RooAbsReal::createRunningIntegral("" + std::string(GetName()) + "")"");; 3756 pc.defineSet(""supNormSet"",""SupNormSet"",0,nullptr) ;; 3757 pc.defineInt(""numScanBins"",""ScanParameters"",0,1000) ;; 3758 pc.defineInt(""intOrder"",""ScanParameters"",1,2) ;; 3759 pc.defineInt(""doScanNum"",""ScanNum"",0,1) ;; 3760 pc.defineInt(""doScanAll"",""ScanAll"",0,0) ;; 3761 pc.defineInt(""doScanNon"",""ScanNone"",0,0) ;; 3762 pc.defineMutex(""ScanNum"",""ScanAll"",""ScanNone"") ;; 3763 ; 3764 // Process & check varargs; 3765 pc.process(arg1,arg2,arg3,arg4,a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:160608,integrat,integration,160608,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,['integrat'],['integration']
Integrability," Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TTreePlayer Class Reference. ; Implement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc). ; Definition at line 37 of file TTreePlayer.h. Public Member Functions;  TTreePlayer ();  Default Tree constructor. ;  ;  ~TTreePlayer () override;  Tree destructor. ;  ; TVirtualIndex * BuildIndex (const TTree *T, const char *majorname, const char *minorname) override;  Build the index for the tree (see TTree::BuildIndex) ;  ; TTree * CopyTree (const char *selection, Option_t *option, Long64_t nentries, Long64_t firstentry) override;  Copy a Tree with selection, make a clone of this Tree header, then copy the selected entries. ;  ; Long64_t DrawScript (const char *wrapperPrefix, const char *macrofilename, const char *cutfilename, Option_t *option, Long64_t nentries, Long64_t firstentry) override;  Draw the result of a C++ script. ;  ; Long64_t DrawSelect (const char *varexp, const char *selection, Option_t *option, Long64_t nentries, Long64_t firstentry) override;  Draw expression varexp for specified entries that matches the selection. ;  ; Int_t Fit (const char *formula, const char *varexp, const char *selection, Option_t *option, Option_t *goption, Long64_t nentries, Long64_t firstentry) override;  Fit a projected item(s) from a Tree. ;  ; Int_t GetDimension () const override;  ; Long64_t GetEntries (const char *selection) override;  Return the number of entries matching the selection. ;  ; virtual Long64_t GetEntriesToProcess (Long64_t firstentry, Long64_t nentries) const;  return the number of entries to be processed this function checks that nentries is not bigger than the number of entries in the Tree or in the associated TEventlist ;  ; TH1 * GetHistogram () const override;  ; Int_t GetNfill () const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:1027,wrap,wrapperPrefix,1027,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['wrap'],['wrapperPrefix']
Integrability," Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Special handling of integral of integral, return RooRealIntegral that represents integral over all dimensions in one pass. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. TObject* clone(const char* newname) const; { ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:35625,integrat,integration,35625,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,2,['integrat'],['integration']
Integrability," Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Special handling of integral of integral, return RooRealIntegral that represents integral over all dimensions in one pass. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global swit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealIntegral.html:36460,integrat,integration,36460,root/html530/RooRealIntegral.html,https://root.cern,https://root.cern/root/html530/RooRealIntegral.html,1,['integrat'],['integration']
Integrability," Set bin content. void SetShowProjectionX(Int_t nbins = 1); When the mouse is moved in a pad containing a 2-d view of this histogram; a second canvas shows the projection along X corresponding to the; mouse position along Y.; To stop the generation of the projections, delete the canvas; containing the projection. void SetShowProjectionY(Int_t nbins = 1); When the mouse is moved in a pad containing a 2-d view of this histogram; a second canvas shows the projection along Y corresponding to the; mouse position along X.; To stop the generation of the projections, delete the canvas; containing the projection. TH1 * ShowBackground(Int_t niter = 20, Option_t* option = ""same""); This function calculates the background spectrum in this histogram.; The background is returned as a histogram.; to be implemented (may be). Int_t ShowPeaks(Double_t sigma = 2, Option_t* option = """", Double_t threshold = 0.050000000000000003); Interface to TSpectrum2::Search; the function finds peaks in this histogram where the width is > sigma; and the peak maximum greater than threshold*maximum bin content of this.; for more detauils see TSpectrum::Search.; note the difference in the default value for option compared to TSpectrum2::Search; option="""" by default (instead of ""goff""). void Smooth(Int_t ntimes = 1, Option_t* option = """"); Smooth bin contents of this 2-d histogram using kernel algorithms; similar to the ones used in the raster graphics community.; Bin contents in the active range are replaced by their smooth values.; If Errors are defined via Sumw2, they are also scaled and computed.; However, note the resulting errors will be correlated between different-bins, so; the errors should not be used blindly to perform any calculation involving several bins,; like fitting the histogram. One would need to compute also the bin by bin correlation matrix. 3 kernels are proposed k5a, k5b and k3a.; k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j); k5b is a bit more stronger in smoothi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2.html:56618,Interface,Interface,56618,root/html602/TH2.html,https://root.cern,https://root.cern/root/html602/TH2.html,2,['Interface'],['Interface']
Integrability," SetBarWidth(Float_t width=0.5)Set the width of bars as fraction of the bin width for drawing mode ""B"".Definition TH1.h:365; TH1::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH2::ProjectionYTH1D * ProjectionY(const char *name=""_py"", Int_t firstxbin=0, Int_t lastxbin=-1, Option_t *option="""") constProject a 2-D histogram into a 1-D histogram along Y.Definition TH2.cxx:2476; TH2::ProjectionXTH1D * ProjectionX(const char *name=""_px"", Int_t firstybin=0, Int_t lastybin=-1, Option_t *option="""") constProject a 2-D histogram into a 1-D histogram along X.Definition TH2.cxx:2436; TH2::Classstatic TClass * Class(); TH3The 3-D histogram classes derived from the 1-D histogram classes.Definition TH3.h:31; TH3::Classstatic TClass * Class(); TH3::Project3Dvirtual TH1 * Project3D(Option_t *option=""x"") constProject a 3-d histogram into 1 or 2-d histograms depending on the option parameter,...Definition TH3.cxx:2409; THStackThe Histogram stack class.Definition THStack.h:40; THStack::beginTIter begin() constGet an iterator over internal hists list.Definition THStack.cxx:1099; THStack::IsATClass * IsA() const overrideDefinition THStack.h:93; THStack::~THStack~THStack() overrideTHStack destructor.Definition THStack.cxx:323; THStack::THStackTHStack()Definition THStack.h:57; THStack::BuildAndPaintvoid BuildAndPaint(Option_t *chopt, Bool_t paint, Bool_t rebuild_stack=kFALSE)Create all additional objects and stack (if specified).Definition THStack.cxx:715; THStack::GetMinimumvirtual Double_t GetMinimum(Option_t *option="""", Double_t minval=-std::numeric_limits< Double_t >::max())Returns the minimum of all added histograms larger than minval.Definition THStack.cxx:549; THStack::lsvoid ls(Option_t *option="""") const overrideList histograms in the stack.Definition THStack.cxx:658; THStack::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THStack_8cxx_source.html:43889,depend,depending,43889,doc/master/THStack_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THStack_8cxx_source.html,1,['depend'],['depending']
Integrability," SetData(data);; 223 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 224 }; 225 /**; 226 Un-binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 227 Default is NOT extended; 228 */; 229 bool LikelihoodFit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 230 SetData(data);; 231 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 232 }; 233 ; 234 /**; 235 Likelihood fit given a data set (Binned or Un-binned) using any generic model function.; 236 This interface copies the input data and the model function object; 237 */; 238 template < class Data , class Function>; 239 bool LikelihoodFit( const Data & data, const Function & func, bool extended) {; 240 SetFunction(func);; 241 return LikelihoodFit(data, extended);; 242 }; 243 ; 244 /**; 245 Do a linear fit copying the input data; 246 */; 247 bool LinearFit(const BinData & data) {; 248 SetData(data);; 249 return DoLinearFit();; 250 }; 251 /**; 252 Do a linear fit using a `shared_ptr` for NOT copying the input data; 253 */; 254 bool LinearFit(const std::shared_ptr<BinData> & data) {; 255 SetData(data);; 256 return DoLinearFit();; 257 }; 258 ; 259 /**; 260 Fit using the a generic FCN function as a C++ callable object implementing; 261 double () (const double *); 262 Note that the function dimension (i.e. the number of parameter) is needed in this case; 263 For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..); 264 */; 265 template <class Function>; 266 bool FitFCN(unsigned int npar, Function & fcn, const double * params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 267 ; 268 /**; 269 Set a generic FCN function as a C++ callable object implementing; 270 double () (const double *); 271 Note that the function dimension (i.e. the number of parameter) is needed in this case; 272 For the options see documentation for following methods Fit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:8872,interface,interface,8872,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['interface'],['interface']
Integrability," SetFitDaughters(Bool_t x); Set daughter creation point fitting and rebuild tracks. void SetFitReferences(Bool_t x); Set track-reference fitting and rebuild tracks. void SetFitDecay(Bool_t x); Set decay fitting and rebuild tracks. void SetFitLineSegments(Bool_t x); Set line segment fitting and rebuild tracks. void SetFitCluster2Ds(Bool_t x); Set 2D-cluster fitting and rebuild tracks. void SetRnrDecay(Bool_t x); Set decay rendering and rebuild tracks. void SetRnrCluster2Ds(Bool_t x); Set rendering of 2D-clusters and rebuild tracks. void SetRnrDaughters(Bool_t x); Set daughter rendering and rebuild tracks. void SetRnrReferences(Bool_t x); Set track-reference rendering and rebuild tracks. void SetRnrFV(Bool_t x); Set first-vertex rendering and rebuild tracks. void SetProjTrackBreaking(UChar_t x); Set projection break-point mode and rebuild tracks. void SetRnrPTBMarkers(Bool_t x); Set projection break-point rendering and rebuild tracks. void StepRungeKutta(Double_t step, Double_t* vect, Double_t* vout); Wrapper to step with method RungeKutta. Bool_t IsOutsideBounds(const TEveVectorD& point, Double_t maxRsqr, Double_t maxZ). Bool_t PointOverVertex(const TEveVector4D& v0, const TEveVector4D& v, Double_t* p = 0). TEveTrackPropagator(const TEveTrackPropagator& ). TEveTrackPropagator& operator=(const TEveTrackPropagator& ). void SetStepper(TEveTrackPropagator::EStepper_e s); { fStepper = s; }. void SetMagField(Double_t bX, Double_t bY, Double_t bZ). void SetEditPathMarks(Bool_t x); { fEditPathMarks = x; }. TEveVectorD GetMagField(Double_t x, Double_t y, Double_t z); { return fMagFieldObj->GetField(x, y, z); }. EStepper_e GetStepper() const; { return fStepper;}. Double_t GetMaxR() const; { return fMaxR; }. Double_t GetMaxZ() const; { return fMaxZ; }. Double_t GetMaxOrbs() const; { return fMaxOrbs; }. Double_t GetMaxAng() const; { return fH.fMaxAng; }. Double_t GetMaxStep() const; { return fH.fMaxStep; }. Double_t GetDelta() const; { return fH.fDelta; }. Bool_t GetEditPathMark",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveTrackPropagator.html:32712,Wrap,Wrapper,32712,root/html534/TEveTrackPropagator.html,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html,3,['Wrap'],['Wrapper']
Integrability," Short integer 2 bytes; UShort_t Unsigned Short integer 2 bytes; Int_t Signed integer 4 bytes; UInt_tUnsigned integer 4 bytes; Long64_t Portable signed long integer 8 bytes; ULong64_t Portable unsigned long integer 8 bytes; Float_t Float 4 bytes; Double_t Float 8 bytes; Double32_t Double 8 bytes in memory, written as a Float 4 bytes; Bool_t Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use int or Int_t, the result will be the same and the interpreter or the compiler will treat them in exactly the same way.; 2.5.3 TObject; In ROOT, almost all classes inherit from a common base class called TObject. This kind of architecture is also used in the Java language. The TObject class provides default behavior and protocol for all objects in the ROOT system. The main advantage of this approach is that it enforces the common behavior of the derived classes and consequently it ensures the consistency of the whole system. See “The Role of TObject”.; TObject provides protocol, i.e. (abstract) member functions, for:. Object I/O (Read(), Write()); Error handling (Warning(), Error(), SysError(), Fatal()); Sorting (IsSortable(), Compare(), IsEqual(), Hash()); Inspection (Dump(), Inspect()); Printing (Print()); Drawing (Draw(), Paint(), ExecuteEvent()); Bit handling (SetBit(), TestBit()); Memory allocation (operatornew and delete, IsOnHeap()); Access to meta information (IsA(), InheritsFrom()); Object browsing (Browse(), IsFolder()). 2.6 Global Variables; ROOT has a set of global variables that apply to the session. For example, gDirectory always holds the current directory, and gStyle holds the current style.; All global variables begin with “g” followed by a capital letter.; 2.6.1 gROOT; The single instance of TROOT is accessible via the global gROOT and holds information relative to the current session. By using the gROOT pointer, you get the access to every object created in a ROOT program. The TROOT object has several lists pointing to the main ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:59050,protocol,protocol,59050,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['protocol'],['protocol']
Integrability," Storage Representation;  Matrix and Vector classesClasses representing Matrices and Vectors of arbitrary type and dimension ;  Unuran;  VecOps;  ▼Monte CarloThe Monte Carlo related packages ;  EGParticle Data Group interface ;  Pythia6The Pythia6 interface ;  Pythia8The Pythia8 interface ;  VMCVirtual Monte Carlo ;  ▼PROOFClasses defining the Parallel ROOT Facility, PROOF, a framework for parallel analysis of ROOT TTrees ;  PROOF kernel LibrariesThe PROOF kernel libraries (libProof, libProofPlayer, libProofDraw) contain the classes defining the kernel of the PROOF facility, i.e ;  PROOF benchmark utilitiesSet of utilities to benchmark a PROOF facility ;  XProofD client LibraryThe XProofD client library, libProofx, contain the classes providing the client to interact with the XRootD-based xproofd daemon ;  TMVAThe Multi Variate Analysis package ;  ▼RoofitRooFit toolkit classes ;  RoofitcoreCore RooFit classes ;  ►RoostatsRooStats toolkit classes ;  HistFactoryFactory classes to create RooFit workspaces from histograms ;  DataFrameROOT's RDataFrame allows to analyse data stored in TTrees with a high level interface ;  Tree LibraryTo store large quantities of same-class objects, ROOT provides the TTree and TNtuple classes ;  ▼TutorialsA collection of macros helping to learn ROOT by example ;  Tutorials specific to Mac/CocoaVarious examples showing graphics done with the Mac graphics system Cocoa. These examples run only on Mac/Os ;  Containers tutorialsExamples showing the ""containers' classes"" usage. ;  Data Frame tutorialsThese examples show the functionalities of RDataFrame: ROOT's declarative analysis interface ;  Event display tutorialsExamples showing the ""Event display classes"" usage. ;  Fast Fourier Transforms tutorialsExample showing the Fast Fourier Transforms interface in ROOT ;  Fit TutorialsThese tutorials illustrate the main fitting features. Their names are related to the aspect which is treated in the code ;  FITS files interface tutorialsExamples showi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/modules.html:8878,interface,interface,8878,doc/v616/modules.html,https://root.cern,https://root.cern/doc/v616/modules.html,1,['interface'],['interface']
Integrability," Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0). EFisherMethod GetFisherMethod( void ); { return fFisherMethod; }. » Author: Andreas Hoecker, Xavier Prudent, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodFisher.html:23346,message,message,23346,root/html604/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodFisher.html,2,['message'],['message']
Integrability," Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0). EFisherMethod GetFisherMethod( void ); { return fFisherMethod; }. » Author: Andreas Hoecker, Xavier Prudent, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodFisher.html:23338,message,message,23338,root/html602/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodFisher.html,2,['message'],['message']
Integrability," Sum-of-weights for weighted data; NumCPU() -- Activate parallel processing feature; Range() -- Fit only selected region; SumCoefRange() -- Set the range in which to interpret the coefficients of RooAddPdf components; SplitRange() -- Fit range is split by index catory of simultaneous PDF; ConditionalObservables() -- Define projected observables. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a p.d.f. and a dataset. void printValue(ostream& os) const; Print value of p.d.f, also print normalization integral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print multi line detailed information of this RooAbsPdf. RooAbsGenContext* binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; Return a binned generator context. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Interface function to create a generator context from a p.d.f. This default; implementation returns a 'standard' context that works for any p.d.f. RooAbsGenContext* autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The call",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:61749,Interface,Interface,61749,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,3,['Interface'],['Interface']
Integrability," SysError(""GetPeerName"", ""getpeername failed"");; 3149 return ia;; 3150 }; 3151 ; 3152 if (addr.sa_family != AF_INET) return ia; // only IPv4; 3153 ia.fFamily = addr.sa_family;; 3154 struct sockaddr_in *addrin = (struct sockaddr_in *)&addr;; 3155 ia.fPort = ntohs(addrin->sin_port);; 3156 ia.fAddresses[0] = ntohl(addrin->sin_addr.s_addr);; 3157 ; 3158 char hbuf[NI_MAXHOST];; 3159 if (getnameinfo(&addr, sizeof(struct sockaddr), hbuf, sizeof(hbuf), nullptr, 0, 0) != 0) {; 3160 Error(""GetPeerName"", ""getnameinfo failed"");; 3161 ia.fHostname = ""????"";; 3162 } else; 3163 ia.fHostname = hbuf;; 3164 ; 3165 return ia;; 3166}; 3167 ; 3168////////////////////////////////////////////////////////////////////////////////; 3169/// Get port # of internet service.; 3170 ; 3171int TUnixSystem::GetServiceByName(const char *servicename); 3172{; 3173 struct servent *sp;; 3174 ; 3175 if ((sp = getservbyname(servicename, kProtocolName)) == nullptr) {; 3176 Error(""GetServiceByName"", ""no service \""%s\"" with protocol \""%s\""\n"",; 3177 servicename, kProtocolName);; 3178 return -1;; 3179 }; 3180 return ntohs(sp->s_port);; 3181}; 3182 ; 3183////////////////////////////////////////////////////////////////////////////////; 3184/// Get name of internet service.; 3185 ; 3186char *TUnixSystem::GetServiceByPort(int port); 3187{; 3188 struct servent *sp;; 3189 ; 3190 if ((sp = getservbyport(htons(port), kProtocolName)) == nullptr) {; 3191 //::Error(""GetServiceByPort"", ""no service \""%d\"" with protocol \""%s\"""",; 3192 // port, kProtocolName);; 3193 return Form(""%d"", port);; 3194 }; 3195 return sp->s_name;; 3196}; 3197 ; 3198////////////////////////////////////////////////////////////////////////////////; 3199/// Connect to service servicename on server servername.; 3200 ; 3201int TUnixSystem::ConnectService(const char *servername, int port,; 3202 int tcpwindowsize, const char *protocol); 3203{; 3204 if (!strcmp(servername, ""unix"")) {; 3205 return UnixUnixConnect(port);; 3206 } else if (!gSystem->AccessPathNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:100975,protocol,protocol,100975,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['protocol'],['protocol']
Integrability," T , class Cond > . auto ROOT::TProcessExecutor::MapImpl ; (; F ; func, . std::vector< T > & ; args . ); -> std::vector<InvokeResult_t<F, T>>. private . Execute a function over the elements of a vector in parallel Implementation of the Map method. ; Parameters. funcFunction to be executed on the elements of the vector passed as second parameter. ; argsVector of elements passed as an argument to func. . ReturnsA vector with the results of the function calls. ; Definition at line 160 of file TProcessExecutor.hxx. ◆ MapImpl() [4/4]. template<class F , class Cond > . auto ROOT::TProcessExecutor::MapImpl ; (; F ; func, . unsigned ; nTimes . ); -> std::vector<InvokeResult_t<F>>. private . Execute a function without arguments several times in parallel. ; Implementation of the Map method.; Parameters. funcFunction to be executed. ; nTimesNumber of times function should be called. . ReturnsA vector with the results of the function calls. Functions that take arguments can be executed (with fixed arguments) by wrapping them in a lambda or with std::bind. ; Definition at line 119 of file TProcessExecutor.hxx. ◆ MapReduce() [1/3]. template<class F , class T , class R , class Cond > . auto ROOT::TProcessExecutor::MapReduce ; (; F ; func, . const std::vector< T > & ; args, . R ; redfunc . ); -> InvokeResult_t<F, T>. Execute a function in parallel over the elements of an immutable vector (Map) and accumulate the results into a single value (Reduce). ; Benefits from partial reduction into nChunks intermediate results.; Benefits from partial reduction into nChunks intermediate results if the execution policy is multithreaded. Otherwise, it ignores the nChunks argument and performs a normal MapReduce operation.; Parameters. funcFunction to be executed. Must take an element of the sequence passed assecond argument as a parameter. ; argsImmutable vector, whose elements are passed as an argument to func. ; redfuncReduction function to combine the results of the calls to func into partial ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TProcessExecutor.html:16425,wrap,wrapping,16425,doc/v632/classROOT_1_1TProcessExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TProcessExecutor.html,2,['wrap'],['wrapping']
Integrability," T, D1 >, MatRepStd< T, D1, D2 > >Specialization for symmetrix -= general : NOT Allowed operation ;  CMinusEquals< T, D1, D2, A, MatRepSym< T, D1 >, MatRepSym< T, D1 > >Specialization for symmetric matrices ;  CMiserParametersStructures collecting parameters for MISER multidimensional integration ;  CMixMaxEngineMIXMAX Random number generator ;  CMulOpMultiplication (element-wise) Operation Class ;  CMultiDimParamFunctionAdapterMultiDimParamFunctionAdapter class to wrap a one-dimensional parametric function in a multi dimensional parameteric function interface This is used typically in fitting where internally the function is stored as multidimension ;  CMultiDimParamGradFunctionAdapterMultiDimParamGradFunctionAdapter class to wrap a one-dimensional parametric gradient function in a multi dimensional parameteric gradient function interface This is used typically in fitting where internally the function is stored as multidimension ;  CMultiNumGradFunctionMultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) ;  CMultPolicyMatrix-matrix multiplication policy ;  CNullTypeFunc1D;  COneDimMultiFunctionAdapterOneDimMultiFunctionAdapter class to wrap a multidimensional function in one dimensional one ;  COneDimParamFunctionAdapterOneDimParamFunctionAdapter class to wrap a multi-dim parameteric function in one dimensional one ;  CParamFunctionBase template class for all Parametric Functions ;  CParamFunctionBaseClass defining the signature for multi-dim parametric functions ;  CParamFunctorParam Functor class for Multidimensional functions ;  ►CParamFunctorHandlerParamFunctor Handler class is responsible for wrapping any other functor and pointer to free C functions ;  CFuncEvaluator;  CFuncEvaluator< F * >;  CFuncEvaluator< F *const >;  CParamMemFunHandlerParamFunctor Handler to Wrap pointers to member functions ;  CPlaceExpr;  CPlaceExpr< T, D1, D2,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:39057,wrap,wrap,39057,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['wrap'],['wrap']
Integrability," TASImagePlugin::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TASImagePlugin::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TASImagePlugin::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 39 of file TASImagePlugin.h. ◆ DeclFileName(). static const char * TASImagePlugin::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 39 of file TASImagePlugin.h. ◆ File2ASImage(). virtual ASImage * TASImagePlugin::File2ASImage ; (; const char * ; ). inlinevirtual . Reimplemented in TASPluginGS.; Definition at line 36 of file TASImagePlugin.h. ◆ Hash(). ULong_t TASImagePlugin::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TASImagePlugin::HashULong_t Hash() const overrideReturn hash value for this object.Definition TASImagePlugin.h:32; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid Recursiv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImagePlugin.html:12282,rout,routine,12282,doc/master/classTASImagePlugin.html,https://root.cern,https://root.cern/doc/master/classTASImagePlugin.html,1,['rout'],['routine']
Integrability," TASPaletteEditor.cxx. ◆ InvertPalette(). void TASPaletteEditor::InvertPalette ; (; ). protected . The palette is inverted. ; It is called by the invert - button. Protected method. ; Definition at line 645 of file TASPaletteEditor.cxx. ◆ IsA(). TClass * TASPaletteEditor::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TPaletteEditor.; Definition at line 108 of file TASPaletteEditor.h. ◆ LinPalette(). void TASPaletteEditor::LinPalette ; (; ). protected . The anchor points are rescaled to be linar. ; It is called by the lin - button. Protected method. ; Definition at line 620 of file TASPaletteEditor.cxx. ◆ LogPalette(). void TASPaletteEditor::LogPalette ; (; ). protected . The anchor points are rescaled by a log operation. ; It is called by the log - button. Protected method. ; Definition at line 582 of file TASPaletteEditor.cxx. ◆ NewPalette(). void TASPaletteEditor::NewPalette ; (; Long_t ; id). protected . A new palette is created, depending on the id. ; It is called by the combo box. Protected method. ; Definition at line 670 of file TASPaletteEditor.cxx. ◆ Open(). void TASPaletteEditor::Open ; (; ). protected . Opens either a ROOT file or an ASCII file and reads a palette. ; It is called by the Open - button. Protected method. ; Definition at line 457 of file TASPaletteEditor.cxx. ◆ ProcessMessage(). Bool_t TASPaletteEditor::ProcessMessage ; (; Longptr_t ; msg, . Longptr_t ; param1, . Longptr_t ; param2 . ). overridevirtual . Process all editor mouse events. ; Reimplemented from TGFrame.; Definition at line 294 of file TASPaletteEditor.cxx. ◆ Save(). void TASPaletteEditor::Save ; (; ). protected . Saves the current palette either into a ROOT file or in an ASCII file. ; It is called by the Save - button. Protected method. ; Definition at line 420 of file TASPaletteEditor.cxx. ◆ SetRamp(). void TASPaletteEditor::SetRamp ; (; Long_t ; ramp). protected . The palette is repeated up to 4 times. ; This is called by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASPaletteEditor.html:40552,depend,depending,40552,doc/master/classTASPaletteEditor.html,https://root.cern,https://root.cern/doc/master/classTASPaletteEditor.html,1,['depend'],['depending']
Integrability," TAuthenticate(const TAuthenticate&); TAuthenticate(TSocket* sock, const char* remote, const char* proto, const char* user = """"); virtual~TAuthenticate(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAuthenticate(); static voidAuthError(const char* where, Int_t error); Int_tAuthExists(TString User, Int_t method, const char* Options, Int_t* Message, Int_t* Rflag, CheckSecCtx_t funcheck); virtual voidTObject::Browse(TBrowser* b); voidCatchTimeOut(); Bool_tCheckNetrc(TString& user, TString& passwd); Bool_tCheckNetrc(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); static Bool_tCheckProofAuth(Int_t cSec, TString& det); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static Int_tDecodeRSAPublic(const char* rsapubexport, rsa_NUMBER& n, rsa_NUMBER& d, char** rsassl = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TAuthenticate.html:845,Message,Message,845,root/html532/TAuthenticate.html,https://root.cern,https://root.cern/root/html532/TAuthenticate.html,2,['Message'],['Message']
Integrability, TBasket the TBranch buffers; TBasketSQL the TBranch buffers; TBenchmark ROOT utility to help benchmarking applications; TBinomialEfficiencyFitter Binomial Fitter for the division of two histograms; TBits Bit container; TBits::TReference ; TBox Box class; TBranch Branch descriptor; TBranchClones Branch in case of an array of clone objects; TBranchElement Branch in case of an object; TBranchObject Branch in case of an object; TBranchRef to support referenced objects on other branches; TBranchSTL Branch handling STL collection of pointers; TBrowser ROOT Object Browser; TBrowserImp ABC describing browser implementation protocol; TBrowserPlugin basic plugin description class; TBtree A B-tree; TBtreeIter B-tree iterator; TBuffer Buffer base class used for serializing objects; TBuffer3D 3D primitives description; TBufferFile concrete implementation of TBuffer for writing/reading to/from a ROOT file or socket.; TBufferSQL Implementation of TBuffer to load and write to a SQL database; TBufferXML a specialized TBuffer to read/write to XML files; TButton A user interface button.; TCL C++ replacement for CERNLIB matrix / triangle matrix packages: F110 and F112; TCONE CONE shape; TCONS CONS shape; TCTUB The Cut Tube shape; TCanvas Graphics canvas; TCanvasImp ABC describing main window protocol; TChain A chain of TTrees; TChainElement A chain element; TChainIndex A Tree Index with majorname and minorname.; TChainIndex::TChainIndexEntry ; TChair A base class to provide a user custom interface to TTable class objects; TCint Interface to CINT C/C++ interpreter; TClass Dictionary containing class information; TClassDocInfo info cache for class documentation; TClassDocOutput generates documentation web pages for a class; TClassEdit ; TClassGenerator interface for TClass generators; TClassMenuItem One element of the class context menu; TClassRef ; TClassStreamer ; TClassTable Table of known classes; TClassTree Manager class to draw classes inheritance tree and relations; TClonesArray A,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:50641,interface,interface,50641,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,2,['interface'],['interface']
Integrability," TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool canComputeBatchWithCuda () const override;  ; void doEval (RooFit::EvalContext &) const override;  Compute multiple values of D*-D0 mass difference distribution. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *frame, PlotOpt o) const override;  Plot oneself on 'frame'. ;  ; Int_t * randomizeProtoOrder (Int_t nProto, Int_t nGen, bool resample=false) const;  Return lookup table with randomized order for nProto prototype events. ;  ; bool redirectServersHook (const RooAbsCollection &newServerList, bool mustReplaceAll, bool nameChange, bool isRecursiveStep) override;  The cache manager. ;  ; virtual bool syncNormalizatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDstD0BG.html:59483,rout,routine,59483,doc/master/classRooDstD0BG.html,https://root.cern,https://root.cern/doc/master/classRooDstD0BG.html,1,['rout'],['routine']
Integrability," TClass * IsA () const override;  ; template<class T > ; bool isActive (T self, RooFit::MsgTopic topic, RooFit::MsgLevel level);  Check if logging is active for given object/topic/RooFit::MsgLevel combination. ;  ; std::ostream & log (const RooAbsArg *self, RooFit::MsgLevel level, RooFit::MsgTopic facility, bool forceSkipPrefix=false);  Log error message associated with RooAbsArg object self at given level and topic. ;  ; std::ostream & log (const TObject *self, RooFit::MsgLevel level, RooFit::MsgTopic facility, bool forceSkipPrefix=false);  Log error message associated with TObject object self at given level and topic. ;  ; std::ostream & log (std::nullptr_t, RooFit::MsgLevel level, RooFit::MsgTopic facility, bool forceSkipPrefix=false);  ; Int_t numStreams () const;  ; void Print (Option_t *options=nullptr) const override;  Print configuration of message service. ;  ; void reset ();  ; void restoreState ();  Restore last saved state of message service. ;  ; void saveState ();  Save current state of message service. ;  ; void setGlobalKillBelow (RooFit::MsgLevel level);  ; void setSilentMode (bool flag);  ; void setStreamStatus (Int_t id, bool active);  (De)Activate stream with given unique ID ;  ; void showPid (bool flag);  ; bool silentMode () const;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMsgService.html:4267,message,message,4267,doc/master/classRooMsgService.html,https://root.cern,https://root.cern/doc/master/classRooMsgService.html,1,['message'],['message']
Integrability," TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:61757,wrap,wrapper,61757,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,4,['wrap'],['wrapper']
Integrability," TClass::GetClass(#name); return sIsA; } \; 304 static const char *Class_Name() { return #name; } \; 305 virtual_keyword Bool_t CheckTObjectHashConsistency() const overrd { return true; } \; 306 static Version_t Class_Version() { return id; } \; 307 static TClass *Dictionary() { return 0; } \; 308 virtual_keyword TClass *IsA() const overrd { return name::Class(); } \; 309 virtual_keyword void ShowMembers(TMemberInspector&insp) const overrd { ::ROOT::Class_ShowMembers(name::Class(), this, insp); } \; 310 virtual_keyword void Streamer(TBuffer&) overrd { ::Error(""Streamer"", ""Cannot stream interpreted class.""); } \; 311 void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { name::Streamer(ClassDef_StreamerNVirtual_b); } \; 312 static const char *DeclFileName() { return __FILE__; } \; 313 static int ImplFileLine() { return 0; } \; 314 static const char *ImplFileName() { return __FILE__; }; 315)ICF"";; 316}; 317R__EXTERN int optind;; 318 ; 319// The functions are used to bridge cling/clang/llvm compiled with no-rtti and; 320// ROOT (which uses rtti); 321 ; 322////////////////////////////////////////////////////////////////////////////////; 323/// Print a StackTrace!; 324 ; 325extern ""C""; 326void TCling__PrintStackTrace() {; 327 gSystem->StackTrace();; 328}; 329 ; 330////////////////////////////////////////////////////////////////////////////////; 331/// Load a library.; 332 ; 333extern ""C"" int TCling__LoadLibrary(const char *library); 334{; 335 return gSystem->Load(library, """", false);; 336}; 337 ; 338////////////////////////////////////////////////////////////////////////////////; 339/// Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.; 340 ; 341extern ""C"" void TCling__RestoreInterpreterMutex(void *delta); 342{; 343 ((TCling*)gCling)->ApplyToInterpreterMutex(delta);; 344}; 345 ; 346////////////////////////////////////////////////////////////////////////////////; 347/// Lookup libraries in LD_LIBRARY_PATH and DYLD_LIBRARY_PATH with mangled_na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:11154,bridg,bridge,11154,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['bridg'],['bridge']
Integrability," TCling.cxx:233; TCling__AutoLoadCallbackint TCling__AutoLoadCallback(const char *className)Definition TCling.cxx:623; LoadModulestatic bool LoadModule(const std::string &ModuleName, cling::Interpreter &interp)Definition TCling.cxx:1030; RegisterCxxModulesstatic void RegisterCxxModules(cling::Interpreter &clingInterp)Definition TCling.cxx:1183; ConstructorNamestatic void ConstructorName(std::string &name, const clang::Decl *decl, cling::Interpreter &interp, const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt)Definition TCling.cxx:8739; TCling__PrintStackTracevoid TCling__PrintStackTrace()Print a StackTrace!Definition TCling.cxx:326; HandleInterpreterExceptionstatic int HandleInterpreterException(cling::MetaProcessor *metaProcessor, const char *input_line, cling::Interpreter::CompilationResult &compRes, cling::Value *result)Let cling process a command line.Definition TCling.cxx:2423; GetSharedLibImmediateDepsSlowstatic std::string GetSharedLibImmediateDepsSlow(std::string lib, cling::Interpreter *interp, bool skipLoadedLibs=true)This interface returns a list of dependent libraries in the form: lib libA.so libB....Definition TCling.cxx:7161; TCling__DEBUG__printNamevoid TCling__DEBUG__printName(clang::Decl *D)Definition TCling.cxx:236; FindTemplateInNamespacestatic clang::ClassTemplateDecl * FindTemplateInNamespace(clang::Decl *decl)Find a template decl within N nested namespaces, 0<=N<inf Assumes 1 and only 1 template present and 1...Definition TCling.cxx:680; PrintDlErrorstatic void PrintDlError(const char *dyLibName, const char *modulename)Definition TCling.cxx:1964; CreateInterpreterTInterpreter * CreateInterpreter(void *interpLibHandle, const char *argv[])Definition TCling.cxx:608; GetClassSharedLibsForModulestatic std::string GetClassSharedLibsForModule(const char *cls, cling::LookupHelper &LH, bool skipCore)Definition TCling.cxx:6996; fantomlineconst char * fantomlineDefinition TCling.cxx:841; TCling__LibraryLoadedRTTIvoid TCling__LibraryLoadedRTTI(const void *dyL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:382791,interface,interface,382791,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,"['depend', 'interface']","['dependent', 'interface']"
Integrability," TCling.cxx:8584; TCling::MethodArgInfo_TypeInfoTypeInfo_t * MethodArgInfo_TypeInfo(MethodArgInfo_t *marginfo) constDefinition TCling.cxx:9328; TCling::DataMemberInfo_FactoryCopyDataMemberInfo_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8618; TCling::HandleNewTransactionBool_t HandleNewTransaction(const cling::Transaction &T)Helper function to increase the internal Cling count of transactions that change the AST.Definition TCling.cxx:3665; TCling::ReadRootmapFileint ReadRootmapFile(const char *rootmapfile, TUniqueString *uniqueString=nullptr)Read and parse a rootmapfile in its new format, and return 0 in case of success, -1 if the file has a...Definition TCling.cxx:5528; TCling::fSpecialObjectMapsstd::map< SpecialObjectLookupCtx_t, SpecialObjectMap_t > fSpecialObjectMapsDefinition TCling.h:153; TCling::ClassInfo_Nextint ClassInfo_Next(ClassInfo_t *info) const finalDefinition TCling.cxx:8352; TCling::SetErrmsgcallbackvoid SetErrmsgcallback(void *p) const finalSet a callback to receive error messages.Definition TCling.cxx:7606; TCling::MethodArgInfo_IsValidbool MethodArgInfo_IsValid(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9272; TCling::TypeInfo_Sizeint TypeInfo_Size(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9412; TCling::DeleteGlobalInt_t DeleteGlobal(void *obj) finalDelete obj from Cling symbol table so it cannot be accessed anymore.Definition TCling.cxx:3783; TCling::GetSecurityErrorint GetSecurityError() const finalInterface to cling function.Definition TCling.cxx:7487; TCling::SetTempLevelvoid SetTempLevel(int val) const finalCreate / close a scope for temporaries.Definition TCling.cxx:7642; TCling::fPayloadsstd::set< size_t > fPayloadsDefinition TCling.h:122; TCling::FuncTempInfo_TemplateNargsUInt_t FuncTempInfo_TemplateNargs(FuncTempInfo_t *) const finalReturn the maximum number of template arguments of the function template described by ft_info.Definition TCling.cxx:8849; TCling::GetFunc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:428937,message,messages,428937,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['message'],['messages']
Integrability," TColor object does not exist, it is created.; The convention is that the bright color nb = n+150; ; . Int_t GetColorDark(Int_t color). Static function: Returns the dark color number corresponding to n; If the TColor object does not exist, it is created.; The convention is that the dark color nd = n+100; ; . ULong_t Number2Pixel(Int_t ci). Static method that given a color index number, returns the corresponding; pixel value. This pixel value can be used in the GUI classes. This call; does not work in batch mode since it needs to communicate with the; graphics system.; ; . ULong_t RGB2Pixel(Float_t r, Float_t g, Float_t b). Convert r,g,b to graphics system dependent pixel value.; The r,g,b triplet must be [0,1].; ; . ULong_t RGB2Pixel(Int_t r, Int_t g, Int_t b). Convert r,g,b to graphics system dependent pixel value.; The r,g,b triplet must be [0,255].; ; . void Pixel2RGB(ULong_t pixel, Float_t &r, Float_t &g, Float_t &b). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,1].; ; . void Pixel2RGB(ULong_t pixel, Int_t &r, Int_t &g, Int_t &b). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,255].; ; . const char * PixelAsHexString(ULong_t pixel). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to a hexidecimal string.; This string can be directly passed to, for example,; TGClient::GetColorByName(). String will be reused so copy immediately; if needed.; ; . void SaveColor(ostream& out, Int_t ci). Save a color with index > 228 as a C++ statement(s) on output stream out.; ; . Bool_t IsGrayscale(). Return whether all colors return grayscale values.; ; . void SetGrayscale(Bool_t set = kTRUE). Set whether all colors should return grayscale values.; ; . Int_t CreateGradientColorTable(UInt_t Numbe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TColor.html:21714,depend,dependent,21714,root/html526/TColor.html,https://root.cern,https://root.cern/root/html526/TColor.html,1,['depend'],['dependent']
Integrability," TColor object does not exist, it is created.; The convention is that the bright color nb = n+150; ; . Int_t GetColorDark(Int_t color). Static function: Returns the dark color number corresponding to n; If the TColor object does not exist, it is created.; The convention is that the dark color nd = n+100; ; . ULong_t Number2Pixel(Int_t ci). Static method that given a color index number, returns the corresponding; pixel value. This pixel value can be used in the GUI classes. This call; does not work in batch mode since it needs to communicate with the; graphics system.; ; . ULong_t RGB2Pixel(Float_t r, Float_t g, Float_t b). Convert r,g,b to graphics system dependent pixel value.; The r,g,b triplet must be [0,1].; ; . ULong_t RGB2Pixel(Int_t r, Int_t g, Int_t b). Convert r,g,b to graphics system dependent pixel value.; The r,g,b triplet must be [0,255].; ; . void Pixel2RGB(ULong_t pixel, Float_t& r, Float_t& g, Float_t& b). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,1].; ; . void Pixel2RGB(ULong_t pixel, Int_t& r, Int_t& g, Int_t& b). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,255].; ; . const char * PixelAsHexString(ULong_t pixel). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to a hexadecimal string.; This string can be directly passed to, for example,; TGClient::GetColorByName(). String will be reused so copy immediately; if needed.; ; . void SaveColor(ostream& out, Int_t ci). Save a color with index > 228 as a C++ statement(s) on output stream out.; ; . Bool_t IsGrayscale(). Return whether all colors return grayscale values.; ; . void SetGrayscale(Bool_t set = kTRUE). Set whether all colors should return grayscale values.; ; . Int_t CreateGradientColorTable(UInt_t Numbe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TColor.html:21784,depend,dependent,21784,root/html532/TColor.html,https://root.cern,https://root.cern/root/html532/TColor.html,2,['depend'],['dependent']
Integrability," TColor object does not exist, it is created.; The convention is that the bright color nb = n+150; ; . Int_t GetColorDark(Int_t color). Static function: Returns the dark color number corresponding to n; If the TColor object does not exist, it is created.; The convention is that the dark color nd = n+100; ; . ULong_t Number2Pixel(Int_t ci). Static method that given a color index number, returns the corresponding; pixel value. This pixel value can be used in the GUI classes. This call; does not work in batch mode since it needs to communicate with the; graphics system.; ; . ULong_t RGB2Pixel(Float_t r, Float_t g, Float_t b). Convert r,g,b to graphics system dependent pixel value.; The r,g,b triplet must be [0,1].; ; . ULong_t RGB2Pixel(Int_t r, Int_t g, Int_t b). Convert r,g,b to graphics system dependent pixel value.; The r,g,b triplet must be [0,255].; ; . void Pixel2RGB(ULong_t pixel, Float_t& r, Float_t& g, Float_t& b). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,1].; ; . void Pixel2RGB(ULong_t pixel, Int_t& r, Int_t& g, Int_t& b). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; The r,g,b triplet will be [0,255].; ; . const char * PixelAsHexString(ULong_t pixel). Convert machine dependent pixel value (obtained via RGB2Pixel or; via Number2Pixel() or via TColor::GetPixel()) to a hexidecimal string.; This string can be directly passed to, for example,; TGClient::GetColorByName(). String will be reused so copy immediately; if needed.; ; . void SaveColor(ostream& out, Int_t ci). Save a color with index > 228 as a C++ statement(s) on output stream out.; ; . Bool_t IsGrayscale(). Return whether all colors return grayscale values.; ; . void SetGrayscale(Bool_t set = kTRUE). Set whether all colors should return grayscale values.; ; . Int_t CreateGradientColorTable(UInt_t Numbe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TColor.html:21737,depend,dependent,21737,root/html528/TColor.html,https://root.cern,https://root.cern/root/html528/TColor.html,2,['depend'],['dependent']
Integrability," TF1 *f1 = new TF1(""f1"", ""[0] +[1]*x +gaus(2)"", 0, 5);; f1->SetParameters(6, -1,5, 3, 0.2);; TH1F *h = new TH1F(""h"", ""background + signal"", 100, 0, 5);; h->FillRandom(""f1"", 2000);; TF1 *fline = new TF1(""fline"", fline, 0, 5, 2);; fline->SetParameters(2, -1);; h->Fit(""fline"", ""l"");; }. Warning when using the option ""0"". When selecting the option ""0"", the fitted function is added to; the list of functions of the histogram, but it is not drawn.; You can undo what you disabled in the following way:; h.Fit(""myFunction"", ""0""); // fit, store function but do not draw; h.Draw(); function is not drawn; const Int_t kNotDraw = 1<<9;; h.GetFunction(""myFunction"")->ResetBit(kNotDraw);; h.Draw(); // function is visible again. Access to the Minimizer information during fitting. This function calls, the ROOT::Fit::FitObject function implemented in HFitImpl.cxx; which uses the ROOT::Fit::Fitter class. The Fitter class creates the objective fuction; (e.g. chi2 or likelihood) and uses an implementation of the Minimizer interface for minimizing; the function.; The default minimizer is Minuit (class TMinuitMinimizer which calls TMinuit).; The default can be set in the resource file in etc/system.rootrc. For example; Root.Fitter: Minuit2; A different fitter can also be set via ROOT::Math::MinimizerOptions::SetDefaultMinimizer; (or TVirtualFitter::SetDefaultFitter).; For example ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");; will set the usdage of the BFGS algorithm of the GSL multi-dimensional minimization; (implemented in libMathMore). ROOT::Math::MinimizerOptions can be used also to set other; default options, like maximum number of function calls, minimization tolerance or print; level. See the documentation of this class. For fitting linear functions (containing the ""++"" sign"" and polN functions,; the linear fitter is automatically initialized. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void FitPanel(); -*-*-*-*-*Display a panel ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:80858,interface,interface,80858,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['interface'],['interface']
Integrability," TF1 *f1 = new TF1(""f1"", ""[0] +[1]*x +gaus(2)"", 0, 5);; f1->SetParameters(6, -1,5, 3, 0.2);; TH1F *h = new TH1F(""h"", ""background + signal"", 100, 0, 5);; h->FillRandom(""f1"", 2000);; TF1 *fline = new TF1(""fline"", fline, 0, 5, 2);; fline->SetParameters(2, -1);; h->Fit(""fline"", ""l"");; }. Warning when using the option ""0"". When selecting the option ""0"", the fitted function is added to; the list of functions of the histogram, but it is not drawn.; You can undo what you disabled in the following way:; h.Fit(""myFunction"", ""0""); // fit, store function but do not draw; h.Draw(); function is not drawn; const Int_t kNotDraw = 1<<9;; h.GetFunction(""myFunction"")->ResetBit(kNotDraw);; h.Draw(); // function is visible again. Access to the Minimizer information during fitting. This function calls, the ROOT::Fit::FitObject function implemented in HFitImpl.cxx; which uses the ROOT::Fit::Fitter class. The Fitter class creates the objective fuction; (e.g. chi2 or likelihood) and uses an implementation of the Minimizer interface for minimizing; the function.; The default minimizer is Minuit (class TMinuitMinimizer which calls TMinuit).; The default can be set in the resource file in etc/system.rootrc. For example; Root.Fitter: Minuit2; A different fitter can also be set via ROOT::Math::MinimizerOptions::SetDefaultMinimizer; (or TVirtualFitter::SetDefaultFitter).; For example ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");; will set the usdage of the BFGS algorithm of the GSL multi-dimensional minimization; (implemented in libMathMore). ROOT::Math::MinimizerOptions can be used also to set other; default options, like maximum number of function calls, minimization tolerance or print; level. See the documentation of this class. For fitting linear functions (containing the ""++"" sign"" and polN functions,; the linear fitter is automatically initialized. void FitPanel(); Display a panel with all histogram fit options. See class TFitPanel for example. TH1 * GetAsymmetry(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:89093,interface,interface,89093,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,4,['interface'],['interface']
Integrability," TF3 objects can also be generated. For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x) you can do : TF1; *f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10); double r = f1->GetRandom(); ; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TF11-Dim function classDefinition TF1.h:233; TF1::GetRandomvirtual Double_t GetRandom(TRandom *rng=nullptr, Option_t *opt=nullptr)Return a random number following this function shape.Definition TF1.cxx:2192; f1TF1 * f1Definition legend1.C:11; or you can use the UNURAN package. You need in this case to initialize UNURAN to the function you would like to generate. TUnuran u;; u.Init(TUnuranDistrCont(f1));; double r = u.Sample();; TUnuranTUnuran class.Definition TUnuran.h:79; TUnuran::Initbool Init(const std::string &distr, const std::string &method)Initialize with Unuran string API interface.Definition TUnuran.cxx:62; TUnuran::Sampledouble Sample()Sample 1D distribution.Definition TUnuran.cxx:414; The techniques of using directly a TF1,2 or 3 function is powerful and can be used to generate numbers in the defined range of the function. Getting a number from a TF1,2,3 function is also quite fast. UNURAN is a powerful and flexible tool which contains various methods for generate random numbers for continuous distributions of one and multi-dimension. It requires some set-up (initialization) phase and can be very fast when the distribution parameters are not changed for every call.; The following table shows some timings (in nanosecond/call) for basic functions, TF1 functions and using UNURAN obtained running the tutorial math/testrandom.C Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running Linux SLC4 64 bit and compiled with gcc 3.4; Distribution nanoseconds/call; TRandom TRand",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRandom.html:6490,interface,interface,6490,doc/master/classTRandom.html,https://root.cern,https://root.cern/doc/master/classTRandom.html,1,['interface'],['interface']
Integrability," TFdSetDefinition TMacOSXSystem.mm:90; TFileHandlerDefinition TSysEvtHandler.h:65; TInetAddressThis class represents an Internet Protocol (IP) address.Definition TInetAddress.h:36; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TProcessEventTimerDefinition TSystem.h:257; TProcessEventTimer::ProcessEventsBool_t ProcessEvents()Process events if timer did time out.Definition TSystem.cxx:92; TProcessEventTimer::NotifyBool_t Notify() overrideThis method must be overridden to handle object notification (the base implementation is no-op).Definition TSystem.h:260; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSignalHandlerDefinition TSysEvtHandler.h:127; TStdExceptionHandlerDefinition TSysEvtHandler.h:172; TStringBasic string class.Definition TString.h:139; TSystemAbstract base class defining a generic interface to the underlying Operating System.Definition TSystem.h:266; TSystem::fListPathsTString fListPathsDefinition TSystem.h:310; TSystem::NotifyApplicationCreatedvirtual void NotifyApplicationCreated()Hook to tell TSystem that the TApplication object has been created.Definition TSystem.cxx:311; TSystem::GetBuildNodevirtual const char * GetBuildNode() constReturn the build node name.Definition TSystem.cxx:3907; TSystem::Umaskvirtual int Umask(Int_t mask)Set the process file creation mode mask.Definition TSystem.cxx:1517; TSystem::SendBufvirtual int SendBuf(int sock, const void *buffer, int length)Send a buffer headed by a length indicator.Definition TSystem.cxx:2427; TSystem::GetServiceByNamevirtual int GetServiceByName(const char *service)Get port # of internet service.Definition TSystem.cxx:2318; TSystem::IsFileInIncludePathvirtual Bool_t IsFileInIncludePath(const char *name, char **fullpath=nullptr)Return true if 'name' is a file that can be found in the ROOT include path or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:35046,interface,interface,35046,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['interface'],['interface']
Integrability," TFitParametersDialog Fit function parameters dialog; TFitResult Class holding the result of the fit ; TFitResultPtr indirection to TFitResult; TFitter The ROOT standard fitter based on TMinuit; TFitterFumili Fitter based on new Fumili method (Fumili2); TFitterMinuit The ROOT fitter based on new Minuit (Minuit2); TFoam General purpose self-adapting Monte Carlo event generator; TFoamCell Single cell of FOAM; TFoamIntegrand n-dimensional real positive integrand of FOAM; TFoamMaxwt Controlling of the MC weight (maximum weight); TFoamVect n-dimensional vector with dynamical allocation; TFolder Describe a folder: a list of objects and folders; TFormula The formula base class f(x,y,z,par); TFormulaPrimitive The primitive formula ; TFractionFitter Fits MC fractions to data histogram; TFrame Pad graphics frame; TFrameEditor editor of TFrame objects; TFree Description of free segments on a file; TFriendElement A friend element of another TTree; TFumili The FUMILI Minimization package; TFumiliMinimizer Implementation of Minimizer interface using TFumili ; TFunction Dictionary for global function; TFunctionParametersDialog Function parameters dialog; TG16ColorSelector 16 color cells; TG4RootNavMgr Class crreating a G4Navigator based on ROOT geometry; TGApplication GUI application singleton; TGButton Button widget abstract base class; TGButtonGroup Organizes TGButtons in a group; TGCanvas A canvas with two scrollbars and a viewport; TGCheckButton A check button widget; TGClient Class making connection to display server; TGColorDialog Color selection dialog; TGColorFrame Frame for color cell; TGColorPalette Color palette widget; TGColorPick Color picker widget; TGColorPopup Color selector popup; TGColorSelect Color selection checkbutton; TGColumnLayout Column layout manager; TGComboBox Combo box widget; TGComboBoxPopup Combobox popup window; TGCommandPlugin Command (I/O redirection) plugin for the new ROOT Browser; TGCompositeFrame Base class for composite widgets (menubars, etc.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:69195,interface,interface,69195,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['interface'],['interface']
Integrability," TGDNDManager.cxx. ◆ GetDNDVersion(). Atom_t TGDNDManager::GetDNDVersion ; (; ). static . Definition at line 282 of file TGDNDManager.cxx. ◆ GetMainFrame(). TGFrame * TGDNDManager::GetMainFrame ; (; ); const. inline . Definition at line 161 of file TGDNDManager.h. ◆ GetRootProxy(). Window_t TGDNDManager::GetRootProxy ; (; ). protected . Get root window proxy. ; Definition at line 368 of file TGDNDManager.cxx. ◆ GetSource(). Window_t TGDNDManager::GetSource ; (; ); const. inline . Definition at line 174 of file TGDNDManager.h. ◆ GetTarget(). Window_t TGDNDManager::GetTarget ; (; ); const. inline . Definition at line 175 of file TGDNDManager.h. ◆ GetTypeList(). Atom_t * TGDNDManager::GetTypeList ; (; ); const. inline . Definition at line 176 of file TGDNDManager.h. ◆ GetXCDNDData(). Atom_t TGDNDManager::GetXCDNDData ; (; ). static . Definition at line 291 of file TGDNDManager.cxx. ◆ HandleClientMessage(). Bool_t TGDNDManager::HandleClientMessage ; (; Event_t * ; event). Handle DND related client messages. ; Definition at line 417 of file TGDNDManager.cxx. ◆ HandleDNDDrop(). Bool_t TGDNDManager::HandleDNDDrop ; (; Window_t ; src, . Time_t ; timestamp . ). protected . Handle DND drop event. ; Definition at line 774 of file TGDNDManager.cxx. ◆ HandleDNDEnter(). Bool_t TGDNDManager::HandleDNDEnter ; (; Window_t ; src, . long ; vers, . Atom_t ; dataTypes[3] . ). protected . Handle DND enter event. ; Definition at line 630 of file TGDNDManager.cxx. ◆ HandleDNDFinished(). Bool_t TGDNDManager::HandleDNDFinished ; (; Window_t ; target). protected . Handle DND finished event. ; Definition at line 798 of file TGDNDManager.cxx. ◆ HandleDNDLeave(). Bool_t TGDNDManager::HandleDNDLeave ; (; Window_t ; src). protected . Handle DND leave event. ; Definition at line 681 of file TGDNDManager.cxx. ◆ HandleDNDPosition(). Bool_t TGDNDManager::HandleDNDPosition ; (; Window_t ; src, . int ; x_root, . int ; y_root, . Atom_t ; action, . Time_t ; timestamp . ). protected . Handle DND position e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDNDManager.html:20176,message,messages,20176,doc/master/classTGDNDManager.html,https://root.cern,https://root.cern/doc/master/classTGDNDManager.html,1,['message'],['messages']
Integrability," TGLEventHandler Base-class and default implementation of event-handler for TGLViewer.; TGLFBO Frame-buffer object.; TGLFaceSet a faceset logical shape; TGLFaderHelper ; TGLFont A wrapper class for FTFont.; TGLFontManager A FreeType GL font manager.; TGLFormat Describes GL buffer format.; TGLHistPainter Proxy class for GL hist painters.; TGLIsoPainter Iso option for TH3.; TGLLegoPainter Lego painter; TGLLightSet A set of OpenGL lights.; TGLLightSetEditor Editor for TGLLightSet.; TGLLightSetSubEditor Sub-editor for TGLLightSet.; TGLLine3 GL line wrapper class; TGLLockable Lock for viewers and scenes.; TGLLogicalShape a logical (non-placed, local frame) drawable object; TGLManager Interface for OpenGL manager; TGLManip abstract base GL manipulator widget; TGLManipSet A collection of available manipulators.; TGLMatrix GL matrix helper/wrapper class; TGLObject Base-class for direct OpenGL renderers; TGLOrthoCamera Camera for orthographic view.; TGLOutput Wrapper class for GL capture & output routines; TGLOverlayButton GL-overlay button.; TGLOverlayElement Base class for GL overlay elements.; TGLOverlayList Collection of overlay elements to draw/select together.; TGLOvlSelectRecord Standard GL overlay-selection record.; TGLPShapeObj This object wraps TGLPhysicalShape (not a TObject); TGLPShapeObjEditor GUI for editing attributes of a physical-shape.; TGLPShapeRef Reference to a TGLPhysicalShape object.; TGLPadPainter ; TGLPaintDevice Base class for GL widgets and GL off-screen rendering; TGLParametricEquation Equation of parametric surface.; TGLParametricEquationGL GL renderer for TGLParametricEquation; TGLParametricPlot Parametric plot's painter.; TGLPerspectiveCamera Camera for perspective view.; TGLPhysicalShape a physical (placed, global frame) drawable object; TGLPlane GL plane helper/wrapper class; TGLPlot3D Short description.; TGLPlotBox Back box for plot.; TGLPlotCamera Camera for plot-painters.; TGLPlotCoordinates Auxilary class, holds plot dimensions.; TGLPlotPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:74385,rout,routines,74385,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['rout'],['routines']
Integrability," TGTextButton*fGrepButtongrep button; TGTextEntry*fGrepTexttext to grep for in the logs; TGNumberEntry*fLinesFromstarting line; TGNumberEntry*fLinesToending line; TGListBox*fLogListlist of workers; TGTextButton*fLogNewdisplay logs button; TProofLog*fProofLogthe log; TGCheckButton*fRawLinesdisplay raw lines button; TGTextButton*fSavesave button; TGNumberEntry*fSessNumrelative index of the session to get; Int_tfSessionIdx; TStringfSessionUrl; TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display the logs. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressLog.html:23476,message,messages,23476,root/html528/TProofProgressLog.html,https://root.cern,https://root.cern/root/html528/TProofProgressLog.html,4,['message'],['messages']
Integrability," TGedNameFrame used in EVE. More...;  ; class  TEveGedNameTextButton;  Specialization of TGTextButton for EVE name frame. More...;  ; class  TEveGeoManagerHolder;  Exception safe wrapper for setting gGeoManager. More...;  ; class  TEveGeoNode;  Wrapper for TGeoNode that allows it to be shown in GUI and controlled as a TEveElement. More...;  ; class  TEveGeoNodeEditor;  Editor for TEveGeoNode class. More...;  ; class  TEveGeoPolyShape;  Description of TEveGeoPolyShape. More...;  ; class  TEveGeoShape;  Wrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for non-linear projections). More...;  ; class  TEveGeoShapeExtract;  Globally positioned TGeoShape with rendering attributes and an optional list of daughter shape-extracts. More...;  ; class  TEveGeoShapeProjected;  A 3D projected TEveGeoShape. More...;  ; class  TEveGeoTopNode;  A wrapper over a TGeoNode, possibly displaced with a global trasformation stored in TEveElement. More...;  ; class  TEveGeoTopNodeEditor;  Editor for TEveGeoTopNode class. More...;  ; class  TEveGListTreeEditorFrame;  Composite GUI frame for parallel display of a TGListTree and TEveGedEditor. More...;  ; class  TEveGridStepper;  Provide discrete position coordinates for placement of objects on regular grids. More...;  ; class  TEveGridStepperEditor;  Editor for TEveGridStepper class. More...;  ; class  TEveGridStepperSubEditor;  Sub-editor for TEveGridStepper class. More...;  ; class  TEveGTriVecValuator;  Composite GUI element for setting three numerical values (label, three number-entries). More...;  ; class  TEveGValuator;  Composite GUI element for single value selection (supports label, number-entry and slider). More...;  ; class  TEveGValuatorBase;  Base class for composite GUI elements for setting of numeric values. More...;  ; class  TEveJetCone;  Draws a jet cone with leading particle is specified in (eta,phi)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__TEve.html:7808,wrap,wrapper,7808,doc/master/group__TEve.html,https://root.cern,https://root.cern/doc/master/group__TEve.html,1,['wrap'],['wrapper']
Integrability," TGenPhaseSpace.h. ◆ GetWtMax(). Double_t TGenPhaseSpace::GetWtMax ; (; ); const. inline . Definition at line 37 of file TGenPhaseSpace.h. ◆ IsA(). TClass * TGenPhaseSpace::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 39 of file TGenPhaseSpace.h. ◆ operator=(). TGenPhaseSpace & TGenPhaseSpace::operator= ; (; const TGenPhaseSpace & ; gen). Assignment operator. ; Definition at line 76 of file TGenPhaseSpace.cxx. ◆ PDK(). Double_t TGenPhaseSpace::PDK ; (; Double_t ; a, . Double_t ; b, . Double_t ; c . ). private . The PDK function. ; Definition at line 35 of file TGenPhaseSpace.cxx. ◆ SetDecay(). Bool_t TGenPhaseSpace::SetDecay ; (; TLorentzVector & ; P, . Int_t ; nt, . const Double_t * ; mass, . Option_t * ; opt = """" . ). Input: . TLorentzVector &P: decay particle (Momentum, Energy units are Gev/C, GeV); Int_t nt: number of decay products; Double_t *mass: array of decay product masses; Option_t *opt: default -> constant cross section ""Fermi"" -> Fermi energy dependence Return value:; kTRUE: the decay is permitted by kinematics; kFALSE: the decay is forbidden by kinematics . Definition at line 193 of file TGenPhaseSpace.cxx. ◆ Streamer(). void TGenPhaseSpace::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGenPhaseSpace::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 39 of file TGenPhaseSpace.h. Member Data Documentation. ◆ fBeta. Double_t TGenPhaseSpace::fBeta[3]. private . Definition at line 19 of file TGenPhaseSpace.h. ◆ fDecPro. TLorentzVector TGenPhaseSpace::fDecPro[18]. private . Definition at line 22 of file TGenPhaseSpace.h. ◆ fMass. Double_t TGenPhaseSpace::fMass[18]. private . Definition at line 18 of file TGenPhaseSpace.h. ◆ fNt. Int_t TGenPhaseSpace::fNt. private . Definition at line 17 of file TGenPhaseSpace.h. ◆ fTeCmTm. Double_t TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenPhaseSpace.html:14294,depend,dependence,14294,doc/master/classTGenPhaseSpace.html,https://root.cern,https://root.cern/doc/master/classTGenPhaseSpace.html,1,['depend'],['dependence']
Integrability," TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGeoShape::AfterStreamer(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoHype.html:1500,rout,rout,1500,root/html534/TGeoHype.html,https://root.cern,https://root.cern/root/html534/TGeoHype.html,4,['rout'],['rout']
Integrability," TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoHype.html:1500,rout,rout,1500,root/html528/TGeoHype.html,https://root.cern,https://root.cern/root/html528/TGeoHype.html,8,['rout'],['rout']
Integrability," TH1.cxx:6206; TH1::GetContourLevelvirtual Double_t GetContourLevel(Int_t level) constReturn value of contour number level.Definition TH1.cxx:8430; TH1::SetContourvirtual void SetContour(Int_t nlevels, const Double_t *levels=nullptr)Set the number and values of contour levels.Definition TH1.cxx:8483; TH1::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF2_8cxx_source.html:54213,message,message,54213,doc/master/TF2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF2_8cxx_source.html,1,['message'],['message']
Integrability," TH3D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow Reallocate bin contents array.Definition TH3.cxx:4763; TH3D::Copyvoid Copy(TObject &hnew) const overrideCopy this 3-D histogram structure to newth3.Definition TH3.cxx:4742; TH3D::AddBinContentvoid AddBinContent(Int_t bin) overrideIncrement bin content by 1.Definition TH3.h:380; TH3::fTsumwyDouble_t fTsumwyTotal Sum of weight*Y.Definition TH3.h:34; TH3::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH3.h:35; TH3::DoProject2Dvirtual TH2D * DoProject2D(const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) constinternal method performing the projection to a 2D histogram called from TH3::Project3DDefinition TH3.cxx:2103; TH3::fTsumwxzDouble_t fTsumwxzTotal Sum of weight*X*Z.Definition TH3.h:39; TH3::Project3DProfilevirtual TProfile2D * Project3DProfile(Option_t *option=""xy"") constProject a 3-d histogram into a 2-d profile histograms depending on the option parameter option may co...Definition TH3.cxx:2806; TH3::fTsumwz2Double_t fTsumwz2Total Sum of weight*Z*Z.Definition TH3.h:38; TH3::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH3.h:36; TH3::fTsumwzDouble_t fTsumwzTotal Sum of weight*Z.Definition TH3.h:37; TH3::fTsumwyzDouble_t fTsumwyzTotal Sum of weight*Y*Z.Definition TH3.h:40; TH3::GetBinInt_t GetBin(Int_t binx, Int_t biny, Int_t binz) const overrideSee comments in TH1::GetBin.Definition TH3.cxx:1117; TH3::PutStatsvoid PutStats(Double_t *stats) overrideReplace current statistics with the values in array stats.Definition TH3.cxx:2889; THLimitsFinder::GetLimitsFinderstatic THLimitsFinder * GetLimitsFinder()Return pointer to the current finder.Definition THLimitsFinder.cxx:153; THLimitsFinder::FindGoodLimitsvirtual Int_t FindGoodLimits(TH1 *h, Double_t xmin, Double_t xmax)Compute the best axis limits for the X axis.Definition THLimitsFinder.cxx:53; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:60506,depend,depending,60506,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['depend'],['depending']
Integrability," THbookFile.cxx:95; TList.h; TMath.h; charalstatic const char charal[29]Definition TMinuit.cxx:339; InteractiveFCNmvoid InteractiveFCNm(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag)Static function called when SetFCN is called in interactive mode.Definition TMinuit.cxx:928; gMinuitTMinuit * gMinuitDefinition TMinuit.cxx:337; TMinuit.h; gMinuitR__EXTERN TMinuit * gMinuitDefinition TMinuit.h:271; TPluginManager.h; TROOT.h; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; gROOT#define gROOTDefinition TROOT.h:406; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; snprintf#define snprintfDefinition civetweb.c:1540; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMinuitDefinition TMinuit.h:27; TMinuit::mnderivirtual void mnderi()Calculates the first derivatives of FCN (GRD)Definition TMinuit.cxx:2178; TMinuit::mnvertvirtual void mnvert(Double_t *a, Int_t l, Int_t m, Int_t n, Int_t &ifail)Inverts a symmetric matrix.Definition TMinuit.cxx:7696; TMinuit::GetParametervirtual Int_t GetParameter(Int_t parNo, Double_t &currentValue, Double_t &currentError) constreturn parameter value and errorDefinition TMinuit.cxx:841; TMinuit::fXDouble_t * fXDefinition TMinuit.h:75; TMinuit::fPrhoDouble_t * fPrhoDefinition TMinuit.h:95; TMinuit::FixParametervirtual Int_t FixParameter(Int_t parNo)fix a parameterDefinition TMinuit.cxx:827; TMinuit::mnbinsvirtual void mnbins(Double_t a1, Double_t a2, Int_t naa, Double_t &bl, Double_t &bh, Int_t &nb, Double_t &bwid)Compute reasonable histogram intervals.Definition TMinuit.cxx:997; TMinuit::fMaxcptInt_t fMaxcptDefinition TMinuit.h:45; TMinuit::GetNumParsvirtual Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:256743,interface,interface,256743,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['interface'],['interface']
Integrability," THilbertMatrixTSym<double> Template of Symmetric Hilbert Matrix class; THilbertMatrixTSym<float> Template of Symmetric Hilbert Matrix class; THistPainter Helper class to draw histograms; THnSparse Interfaces of sparse n-dimensional histogram; THnSparseArrayChunk chunks of linearized bins; THnSparseT<TArrayC> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayD> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayF> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayI> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayL> Sparse n-dimensional histogram with templated content; THnSparseT<TArrayS> Sparse n-dimensional histogram with templated content; THostAuth Class providing host specific authentication information; THtml Convert class(es) into HTML file(s); THtml::TFileDefinition helper class to determine a class's source files; THtml::TFileSysDB instance of file system data; THtml::TFileSysDir an directory of the local file system; THtml::TFileSysEntry an entry of the local file system; THtml::TFileSysRoot an root directory of the local file system; THtml::THelperBase a helper object's base class; THtml::TModuleDefinition helper class to determine a class's module; THtml::TPathDefinition helper class to determine directory layouts; TImage Abstract image class; TImageDump create image in batch mode; TImagePalette Color Palette for value -> color conversion; TImagePlugin base class for different image format handlers(plugins); TIndArray ; TIndexTable ""Index"" array for TTable object; TIndexTable::iterator ; TInetAddress Represents an Internet Protocol (IP) address; TInspectCanvas The canvas Inspector; TInspectorImp GUI independent inspector abc; TInterpreter ABC defining interface to generic interpreter; TIsAProxy ; TIter Iterator wrapper; TIterator Iterator abstract base class; TKDTree<int,double> KD tree; TKDTree<int,float> KD tree; TKey Header description of a logical record on file.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:93153,interface,interface,93153,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability," THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension ;  statsEditing.C Edit statistics box ;  testSmooth.C Histogram smoothing ;  th2polyBoxes.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly) ;  th2polyEurope.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it ;  th2polyHoneycomb.C This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly) ;  th2polyUSA.C This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option ;  thstack2palettecolor.C Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color) ;  thstackpalettecolor.C Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  tprofile2polyRealistic.C Different charges depending on region ;  tprofile2polyRealisticModuleError.C Simulate faulty detector panel w.r.t ;  transpad.C Example of a canvas showing two histograms with different scales ;  twoscales.C Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad ;  twoscales.py Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad ;  xyplot.C Example showing how to produce a plot with an orthogonal axis system centered at (0,0) ;  ► histfactory;  example.C;  example.py;  makeExample.C;  makeQuickModel.py;  ModifyInterpolation.C;  ► html;  MakeTutorials.C;  ► http;  custom.CThis program creates and fills one and two dimensional histogram Macro used to demonstrate usage of custom HTML page in custom.htm One can use plain JavaScript to assign different actions with HTML buttons ;  histfitserver.CThis program demonstrates simultaneous update of histogram and fitted function ;  httpaccess.CThis program demonstrates access control",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:125578,depend,depending,125578,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['depend'],['depending']
Integrability," THnT<float> multi-dimensional histogram with templated storage; THnT<int> multi-dimensional histogram with templated storage; THnT<long> multi-dimensional histogram with templated storage; THnT<short> multi-dimensional histogram with templated storage; THnT<unsigned int> multi-dimensional histogram with templated storage; THnT<unsigned long> multi-dimensional histogram with templated storage; THnT<unsigned short> multi-dimensional histogram with templated storage; THostAuth Class providing host specific authentication information; THtml Convert class(es) into HTML file(s); THtml::TFileDefinition helper class to determine a class's source files; THtml::TFileSysDB instance of file system data; THtml::TFileSysDir an directory of the local file system; THtml::TFileSysEntry an entry of the local file system; THtml::TFileSysRoot an root directory of the local file system; THtml::THelperBase a helper object's base class; THtml::TModuleDefinition helper class to determine a class's module; THtml::TPathDefinition helper class to determine directory layouts; THttpCallArg Arguments for single HTTP call; THttpEngine abstract class which should provide http-based protocol for server; THttpServer HTTP server for ROOT analysis; TImage Abstract image class; TImageDump create image in batch mode; TImagePalette Color Palette for value -> color conversion; TImagePlugin base class for different image format handlers(plugins); TIndArray ; TIndexTable ""Index"" array for TTable object; TIndexTable::iterator ; TInetAddress Represents an Internet Protocol (IP) address; TInspectCanvas The canvas Inspector; TInspectorImp GUI independent inspector abc; TInterpreter ABC defining interface to generic interpreter; TIsAProxy ; TIter Iterator wrapper; TIterator Iterator abstract base class; TKDE One dimensional semi-parametric Kernel Density Estimation; TKDTree<int,double> ; TKDTree<int,float> ; TKDTreeBinning ; TKSocket General kerberized socket; TKey Header description of a logical record on file.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:97054,protocol,protocol,97054,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,14,"['Protocol', 'interface', 'protocol', 'wrap']","['Protocol', 'interface', 'protocol', 'wrapper']"
Integrability," THttpServer.cxx. ◆ ReadFileContent() [1/2]. char * THttpServer::ReadFileContent ; (; const char * ; filename, . Int_t & ; len . ). static . Reads content of file from the disk. ; Reads file content.; Deprecated:; Definition at line 1557 of file THttpServer.cxx. ◆ ReadFileContent() [2/2]. std::string THttpServer::ReadFileContent ; (; const std::string & ; filename). static . Reads content of file from the disk, use std::string in return value. ; Reads file content, using std::string as container. ; Definition at line 1583 of file THttpServer.cxx. ◆ Register(). Bool_t THttpServer::Register ; (; const char * ; subfolder, . TObject * ; obj . ). Register object in subfolder. ; Register object in folders hierarchy.; See TRootSniffer::RegisterObject() for more details ; Definition at line 1243 of file THttpServer.cxx. ◆ RegisterCommand(). Bool_t THttpServer::RegisterCommand ; (; const char * ; cmdname, . const char * ; method, . const char * ; icon = nullptr . ). Register command which can be executed from web interface. ; As method one typically specifies string, which is executed with gROOT->ProcessLine() method. For instance: serv->RegisterCommand(""Invoke"",""InvokeFunction()"");; Or one could specify any method of the object which is already registered to the server. For instance: serv->Register(""/"", hpx);; serv->RegisterCommand(""/ResetHPX"", ""/hpx/->Reset()"");; Here symbols '/->' separates item name from method to be executed; One could specify additional arguments in the command with syntax like arg1%, arg2% and so on. For example: serv->RegisterCommand(""/ResetHPX"", ""/hpx/->SetTitle(\""%arg1%\"")"");; serv->RegisterCommand(""/RebinHPXPY"", ""/hpxpy/->Rebin2D(%arg1%,%arg2%)"");; Such parameter(s) will be requested when command clicked in the browser.; Once command is registered, one could specify icon which will appear in the browser: serv->SetIcon(""/ResetHPX"", ""rootsys/icons/ed_execute.png"");; One also can set extra property '_fastcmd', that command appear as tool button on the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:30562,interface,interface,30562,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['interface'],['interface']
Integrability," TList*GetListOfMethodArgs(); virtual const char*TFunction::GetMangledName() const; virtual const char*TNamed::GetName() const; Int_tTFunction::GetNargs() const; Int_tTFunction::GetNargsOpt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TFunction::GetPrototype() const; const char*TFunction::GetReturnTypeName() const; const char*TFunction::GetSignature(); virtual const char*Getter() const; virtual TMethodCall*GetterMethod(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; void*TFunction::InterfaceMethod() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; EMenuItemKindIsMenuItem() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMethod&operator=(const TMethod& rhs); virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMethod.html:3369,Interface,InterfaceMethod,3369,root/html532/TMethod.html,https://root.cern,https://root.cern/root/html532/TMethod.html,1,['Interface'],['InterfaceMethod']
Integrability," TMath, classes for random number generators, TRandom, class for complex numbers, TComplex, common interfaces for function evaluation and numerical algorithms. Basic implementations of some of the numerical algorithms such as integration or derivation, are also provided by MathCore. together with the core classes needed to fit any generic data set.; MathMore: a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library (GSL). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL.; Minimization and Fitting Libraries Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; Fumili: library providing the implementation of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Math.html:1302,interface,interface,1302,doc/master/group__Math.html,https://root.cern,https://root.cern/doc/master/group__Math.html,2,['interface'],['interface']
Integrability," TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSym_double_.html:18137,rout,routine,18137,root/html528/TMatrixTSym_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSym_double_.html,6,['rout'],['routine']
Integrability," TMemberInspector& insp) const; Emulated a call ShowMembers() on the obj of this class type, passing insp and parent. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; If newname is specified, this will be the name of the new object. Bool_t CompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete); Return True if the current StreamerInfo in cl or info is equivalent to this TStreamerInfo.; 'Equivalent' means the same number of persistent data member which the same actual C++ type and; the same name.; if 'warn' is true, Warning message are printed to explicit the differences.; if 'complete' is false, stop at the first error, otherwise continue until all members have been checked. void ComputeSize(); Compute total size of all persistent elements of the class. void ForceWriteInfo(TFile* file, Bool_t force = kFALSE); -- Recursively mark streamer infos for writing to a file. Will force this TStreamerInfo to the file and also; all the dependencies. If argument force > 0 the loop on class dependencies is forced. This function is called when streaming a class that contains; a null pointer. In this case, the TStreamerInfo for the class; with the null pointer must be written to the file and also all; the TStreamerInfo of all the classes referenced by the class. --; We must be given a file to write to. TClass * GetActualClass(const void* obj) const; Assuming that obj points to (the part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be called if the class decribed by this; StreamerInfo is 'emulated'. UInt_t GetCheckSum(UInt_t code) const; Recalculate the checksum of this TStreamerInfo based on its code. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The che",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStreamerInfo.html:15850,depend,dependencies,15850,root/html528/TStreamerInfo.html,https://root.cern,https://root.cern/root/html528/TStreamerInfo.html,4,['depend'],['dependencies']
Integrability," TMemberInspector& insp, Bool_t isTransient); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeTClass::IsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTClass::IsFolder() const; Bool_tTClass::IsFolder(void* obj) const; Bool_tTClass::IsForeign() const; Bool_tTClass::IsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTClass::IsStartingWithTObject() const; Bool_tTClass::IsTObject() const; Bool_tTClass::IsVersioned() const; Bool_tTObject::IsZombie() const; static TClass*TClass::Load(TBuffer& b); static TClass*TClass::LoadClass(const char* requestedname, Bool_t silent); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTClass::ls(Option_t* opt = """") const; voidTClass::MakeCustomMenuList(); Bool_tTClass::MatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; voidTClass::Move(void* arenaFrom, void* arenaTo) const; void*TClass::New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; void*TClass::New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*TClass::NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*TClass::NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:13996,Message,Message,13996,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,2,['Message'],['Message']
Integrability," TMethod.h:38; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::DoErrorvirtual void DoError(int level, const char *location, const char *fmt, va_list va) constInterface to ErrorHandler (protected).Definition TObject.cxx:954; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TROOT::GetBinDirstatic const TString & GetBinDir()Get the binary directory in the installation. Static utility function.Definition TROOT.cxx:2993; TRootHelpDialogA TRootHelpDialog is used to display help text (or any text in a dialog window).Definition TRootHelpDialog.h:22; TRootHelpDialog::SetTextvoid SetText(const char *helpText)Set help text from helpText buffer in TGTextView.Definition TRootHelpDialog.cxx:77; TRootHelpDial",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:133307,message,message,133307,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['message'],['message']
Integrability," TMinuit.cxx:1132; TMinuit::fAminDouble_t fAminDefinition TMinuit.h:49; TMinuit::Contourvirtual TObject * Contour(Int_t npoints=10, Int_t pa1=0, Int_t pa2=1)Creates a TGraph object describing the n-sigma contour of a TMinuit fit.Definition TMinuit.cxx:653; TMinuit::fEDMDouble_t fEDMDefinition TMinuit.h:51; TMinuit::fDgrdDouble_t * fDgrdDefinition TMinuit.h:85; TMinuit::mnparmvirtual void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t &ierflg)Implements one parameter definition.Definition TMinuit.cxx:5665; TMinuit::fMNOTwDouble_t * fMNOTwDefinition TMinuit.h:114; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Executevirtual void Execute(const char *method, const char *params, Int_t *error=nullptr)Execute method on this object with the given parameter string, e.g.Definition TObject.cxx:364; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Resizevoid Resize(Ssiz_t n)Resize the string. Truncate or add blanks as necessary.Definition TString.cxx:1152; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:275768,message,message,275768,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['message'],['message']
Integrability," TMinuitMinimizer Implementation of Minimizer interface using TMinuit; TMixture Mixtures used in the Geometry Shapes; TModuleDocInfo documentation for a group of classes; TMonitor Monitor activity on a set of TSocket objects; TMultiDimFit Multi dimensional fit class; TMultiGraph A collection of TGraph objects; TMultiLayerPerceptron a Neural Network; TMutex Mutex lock class; TMutexImp Mutex lock implementation ABC; TMySQLResult MySQL query result; TMySQLRow One row of MySQL query result; TMySQLServer Connection to MySQL server; TMySQLStatement SQL statement class for MySQL DB; TNDArray Base for n-dimensional array; TNDArrayRef<Long64_t> ; TNDArrayRef<ULong64_t> ; TNDArrayRef<char> ; TNDArrayRef<double> ; TNDArrayRef<float> ; TNDArrayRef<int> ; TNDArrayRef<long> ; TNDArrayRef<short> ; TNDArrayRef<unsigned int> ; TNDArrayRef<unsigned long> ; TNDArrayRef<unsigned short> ; TNDArrayT<Long64_t> N-dimensional array; TNDArrayT<ULong64_t> N-dimensional array; TNDArrayT<char> N-dimensional array; TNDArrayT<double> N-dimensional array; TNDArrayT<float> N-dimensional array; TNDArrayT<int> N-dimensional array; TNDArrayT<long> N-dimensional array; TNDArrayT<short> N-dimensional array; TNDArrayT<unsigned int> N-dimensional array; TNDArrayT<unsigned long> N-dimensional array; TNDArrayT<unsigned short> N-dimensional array; TNamed The basis for a named object (name, title); TNetFile A ROOT file that reads/writes via a rootd server; TNetFileStager Implementation for a 'rootd' backend; TNetSystem Directory handler for NetSystem; TNetXNGFile ROOT class definition; TNetXNGFileStager ! Interface to a 'XRD' staging; TNetXNGSystem ROOT class definition; TNeuron Neuron for MultiLayerPerceptrons; TNewChainDlg New chain dialog; TNewQueryDlg New query dialog; TNode Description of parameters to position a 3-D geometry object; TNodeDiv Description of parameters to divide a 3-D geometry object; TNonSplitBrowsable Helper object to browse unsplit objects; TNtuple A simple tree with branches of floats.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:110469,Interface,Interface,110469,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['Interface'],['Interface']
Integrability," TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVarIndex(unsigned int ivar) const; check index of Variable (assume fMinuit exists). bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a lower limited variable; since is not supported in TMinuit , just use a artificial large value. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set a upper limited variable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMinuitMinimizer.html:7855,interface,interface,7855,root/html534/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html534/TMinuitMinimizer.html,2,['interface'],['interface']
Integrability," TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuitMinimizer.html:7327,interface,interface,7327,root/html528/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html528/TMinuitMinimizer.html,4,['interface'],['interface']
Integrability," TMinuitMinimizer& ); Implementation of copy constructor (it is private). bool UseStaticMinuit(bool on = true); static method to control usage of global TMinuit instance. void InitTMinuit(int ndim). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Minuit; Here a TMinuit instance is created since only at this point we know the number of parameters. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Minuit. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set a lower limited variable; since is not supported in TMinuit , just use a artificial large value. bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set a upper limited variable; since is not supported in TMinuit , just use a artificial large negative value. bool CheckMinuitInstance() const; check instance of fMinuit. bool CheckVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMinuitMinimizer.html:7918,interface,interface,7918,root/html602/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html602/TMinuitMinimizer.html,4,['interface'],['interface']
Integrability," TMultiDimFit Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Static Private Attributes |; List of all members ; TMultiDimFit Class ReferenceHistogram Library. ; Multidimensional Fits in ROOT. . Overview; A common problem encountered in different fields of applied science is to find an expression for one physical quantity in terms of several others, which are directly measurable.; An example in high energy physics is the evaluation of the momentum of a charged particle from the observation of its trajectory in a magnetic field. The problem is to relate the momentum of the particle to the observations, which may consists of positional measurements at intervals along the particle trajectory.; The exact functional relationship between the measured quantities (e.g., the space-points) and the dependent quantity (e.g., the momentum) is in general not known, but one possible way of solving the problem, is to find an expression which reliably approximates the dependence of the momentum on the observations.; This explicit function of the observations can be obtained by a least squares fitting procedure applied to a representative sample of the data, for which the dependent quantity (e.g., momentum) and the independent observations are known. The function can then be used to compute the quantity of interest for new observations of the independent variables.; This class TMultiDimFit implements such a procedure in ROOT. It is largely based on the CERNLIB MUDIFI package 2. Though the basic concepts are still sound, and therefore kept, a few implementation details have changed, and this class can take advantage of MINUIT 4 to improve the errors of the fitting, thanks to the class TMinuit.; In 5 and 6 H. Wind demonstrates the utility of this procedure in the context of tracking, m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:1010,depend,dependent,1010,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['depend'],['dependent']
Integrability," TMultiGraph::IsInsidevirtual Int_t IsInside(Double_t x, Double_t y) constReturn 1 if the point (x,y) is inside one of the graphs 0 otherwise.Definition TMultiGraph.cxx:989; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::CompareToint CompareTo(const char *cs, ECaseCompare cmp=kExact) constCompare a string to char *cs2.Definition TString.cxx:457; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:76784,message,message,76784,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['message'],['message']
Integrability," TMultigraph is still active. void Add(TMultiGraph* multigraph, Option_t* chopt = """"); add all the graphs in ""multigraph"" to the list of graphs. void Browse(TBrowser* b); Browse multigraph. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to each graph. void Draw(Option_t* chopt = """"); Draw this multigraph with its current attributes. Options to draw a graph are described in TGraph::PainGraph. The drawing option for each TGraph may be specified as an optional; second argument of the Add function. You can use GetGraphDrawOption; to return this option.; If a draw option is specified, it will be used to draw the graph,; otherwise the graph will be drawn with the option specified in; TMultiGraph::Draw. Use GetDrawOption to return the option specified; when drawin the TMultiGraph. TFitResultPtr Fit(const char* formula, Option_t* option = """", Option_t* goption = """", Axis_t xmin = 0, Axis_t xmax = 0); Fit this graph with function with name fname. interface to TF1::Fit(TF1 *f1... TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """", Axis_t rxmin = 0, Axis_t rxmax = 0); Fit this multigraph with function f1. In this function all graphs of the multigraph are fitted simultaneously. f1 is an already predefined function created by TF1.; Predefined functions such as gaus, expo and poln are automatically; created by ROOT. The list of fit options is given in parameter option.; option = ""W"" Set all errors to 1; = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"",""expo"",""poln"",""landau"".; = ""R"" Use the Range specified in the function range; = ""N"" Do not store the graphics function, do not draw; = ""0"" Do not plot the result of the fit. By default the fitted function; is drawn unless the option""N"" above is specified.; = ""+"" Add this new fitt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiGraph.html:9020,interface,interface,9020,root/html528/TMultiGraph.html,https://root.cern,https://root.cern/root/html528/TMultiGraph.html,1,['interface'],['interface']
Integrability," TNDArrayT<unsigned long> N-dimensional array; TNDArrayT<unsigned short> N-dimensional array; TNamed The basis for a named object (name, title); TNetFile A ROOT file that reads/writes via a rootd server; TNetFileStager Implementation for a 'rootd' backend; TNetSystem Directory handler for NetSystem; TNetXNGFile ROOT class definition; TNetXNGFileStager ! Interface to a 'XRD' staging; TNetXNGSystem ROOT class definition; TNeuron Neuron for MultiLayerPerceptrons; TNewChainDlg New chain dialog; TNewQueryDlg New query dialog; TNode Description of parameters to position a 3-D geometry object; TNodeDiv Description of parameters to divide a 3-D geometry object; TNonSplitBrowsable Helper object to browse unsplit objects; TNtuple A simple tree with branches of floats.; TNtupleD A simple tree with branches of floats.; TObjArray An array of objects; TObjArrayIter Object array iterator; TObjString Collectable string class; TObject Basic ROOT object; TObjectRefSpy Spy object reference for deletion; TObjectSet TDataSet wrapper for TObject class objects; TObjectSpy Spy object pointer for deletion; TObjectTable Table of active objects; TOptionListItem Element in the list of options.; TOrdCollection An ordered collection; TOrdCollectionIter Ordered collection iterator; TOutputListSelectorDataMap Converter from output list to TSelector data members; TPARA PARA shape; TPBHandleDSType Streamable PBHandleDSType; TPBHistType Streamable PBHistType; TPBReadType Streamable PBReadType; TPCON PCON shape; TPDF PDF driver; TPGON PGON shape; TPMERegexp Wrapper for Perl-like regular expression matching.; TPRegexp Perl Compatible Regular Expression Class; TPServerSocket Parallel server socket; TPSocket Parallel client socket; TPackageDescription Package description; TPacketizer Generate work packets for parallel processing; TPacketizerAdaptive Generate work packets for parallel processing; TPacketizerFile Generate work packets for parallel processing; TPacketizerMulti Generate work packets for paral",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:111133,wrap,wrapper,111133,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,4,['wrap'],['wrapper']
Integrability," TNamed*_typedStructureTag! Typed structure tag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCollection(); Default constructor. RooAbsCollection(const char* name); Empty collection constructor. RooAbsCollection(const RooAbsCollection& other, const char* name = """"); Copy constructor. Note that a copy of a collection is always non-owning,; even the source collection is owning. To create an owning copy of; a collection (owning or not), use the snaphot() method. ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCollection.html:12031,depend,dependents,12031,root/html602/RooAbsCollection.html,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html,12,['depend'],['dependents']
Integrability," TObjArray.h:31; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::RecursiveRemovevirtual void RecursiveRemove(TObject *obj)Recursively remove this object from a list.Definition TObject.cxx:665; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPRegexpDefinition TPRegexp.h:36; TPluginHandlerDefinition TPluginManager.h:103; TQObject::Emitvoid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:100167,message,message,100167,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['message'],['message']
Integrability," TObject * fParent;  ; ReAllocCharFun_t fReAllocFunc;  ; Int_t fVersion;  ;  Static Protected Attributes inherited from TBufferIO; static Int_t fgMapSize = kMapSize;  Default map size for all TBuffer objects. ;  . #include <TMessage.h>. Inheritance diagram for TMessage:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TMessage() [1/3]. TMessage::TMessage ; (; const TMessage & ; ). private . ◆ TMessage() [2/3]. TMessage::TMessage ; (; void * ; buf, . Int_t ; bufsize . ). protected . Create a TMessage object for reading objects. ; The objects will be read from buf. Use the What() method to get the message type. ; Definition at line 71 of file TMessage.cxx. ◆ TMessage() [3/3]. TMessage::TMessage ; (; UInt_t ; what = kMESS_ANY, . Int_t ; bufsiz = TBuffer::kInitialSize . ). Create a TMessage object for storing objects. ; The ""what"" integer describes the type of message. Predefined ROOT system message types can be found in MessageTypes.h. Make sure your own message types are unique from the ROOT defined message types (i.e. 0 - 10000 are reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message will wait for an acknowledgment from the remote side. This makes the sending process synchronous. In case you OR ""what"" with kMESS_ZIP, the message will be compressed in TSocket using the zip algorithm (only if message is > 256 bytes). ; Definition at line 46 of file TMessage.cxx. ◆ ~TMessage(). TMessage::~TMessage ; (; ). virtual . Destructor. ; Definition at line 106 of file TMessage.cxx. Member Function Documentation. ◆ Class(). static TClass * TMessage::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMessage::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMessage::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 96 of file TMessag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMessage.html:40941,message,message,40941,doc/master/classTMessage.html,https://root.cern,https://root.cern/doc/master/classTMessage.html,1,['message'],['message']
Integrability," TObject* obj) const; Used to sort slaves by performance index. void Print(Option_t* option = """") const; Printf info about slave. void SetInputHandler(TFileHandler* ih); Adopt and register input handler for this slave. Handler will be deleted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t nwk = 1); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator. Only meaningful when there is one,; i.e. in XPD framework. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. void SetTXSlaveHook(TSlave_t xslavehook); Set hook to TXSlave ctor. TSlave(const TSlave& s); { }. void operator=(const TSlave& ); { }. void FlushSocket(); { }. Int_t SendGroupPriority(const char* , Int_t ); { return 0; }. void SetSocket(TSocket* s); { fSocket = s; }. void SetStatus(Int_t st); { fStatus = st; }. Bool_t IsSortable() const; { return kTRUE; }. const char * GetName() const; { return fName; }. const char * GetImage() const; { return fImage; }. const char * GetProofWorkDir() const; { return fProofWorkDir; }. const char * GetWorkDir() const; { return fWorkDir; }. const char * GetUser() const; { return fUser; }. const char * GetGroup() const; { return fGroup; }. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSlave.html:11040,message,message,11040,root/html602/TSlave.html,https://root.cern,https://root.cern/root/html602/TSlave.html,4,['message'],['message']
Integrability," TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tisIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tisOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidlogEvalError(const char* message, const char* serverValueString = 0) const; static voidlogEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*mean(RooRealVar& obs); RooAbsMoment*mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tminTrialSamples(const RooArgSet&) const; RooAbsMoment*moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tnumEvalErrorItems(); static Int_tnumEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:16885,message,message,16885,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,6,['message'],['message']
Integrability," TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategory.html:3397,depend,dependsOn,3397,root/html526/RooAbsCategory.html,https://root.cern,https://root.cern/root/html526/RooAbsCategory.html,3,['depend'],['dependsOn']
Integrability," TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; Bool_tdefineType(const char* label); Bool_tdefineType(const char* label, Int_t index); virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCategory.html:3292,depend,dependentOverlaps,3292,root/html532/RooCategory.html,https://root.cern,https://root.cern/root/html532/RooCategory.html,1,['depend'],['dependentOverlaps']
Integrability," TObject::(anonymous)TObject::kZombie. protected:. TMonitor*fAllMonitormonitor activity on all valid slave sockets; TList*fAvailablePackageslist of available packages; TList*fBadSlavesdead slaves (subset of all slaves); Long64_tfBytesReadynumber of bytes staged; Int_tfCollectTimeoutTimeout for (some) collect actions; TStringfConfDirdirectory containing cluster config information; TStringfConfFilefile containing config information; TStringfDataPoolUrldefault data pool entry point URL; Bool_tfDataReadytrue if data is ready to be analyzed; Bool_tfDynamicStartupare the workers started dynamically?; TList*fEnabledPackageslist of enabled packages; TStringfImagemaster's image name; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TProofMgr*fManagermanager to which this session belongs (if any); Bool_tfMasterServtrue if we are a master server; TStringTNamed::fNameobject identifier; Float_tfPrepTimePreparation time; Int_tfProtocolremote PROOF server protocol version number; TProof::EQueryModefQueryModedefault query mode; TStopwatchfQuerySTWStopwatch to measure query times; TList*fRunningDSetsTemporary datasets used for async running; TSelector*fSelectorSelector to be processed, if any; TProofMgr::EServTypefServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*fSlaveslist of all slave servers as in config file; TList*fTerminatedSlaveInfoslist of unique infos of terminated slaves; TStringTNamed::fTitleobject title; Long64_tfTotalBytesnumber of bytes to be analyzed; TUrlfUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*fgSemaphoresemaphore to control no of parallel startup threads; static TProof::ESlaveskActive; static TProof::ESlaveskAll; static TProof::ESlaveskAllUnique; static TProof::ESlaveskUnique. private:. TMonitor*fActiveMonitormonitor activity",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProof.html:29366,protocol,protocol,29366,root/html604/TProof.html,https://root.cern,https://root.cern/root/html604/TProof.html,2,['protocol'],['protocol']
Integrability," TObject::Class() as the first parameter and the exact numerical value in the pointer 'o'.; In other word, inside the global IsA function. it is safe to C-style cast the value of 'obj' into a pointer to the class described by 'cl'. ; Definition at line 6300 of file TClass.cxx. ◆ SetImplFileName(). void TClass::SetImplFileName ; (; const char * ; implFileName). inline . Definition at line 560 of file TClass.h. ◆ SetLastReadInfo(). void TClass::SetLastReadInfo ; (; TVirtualStreamerInfo * ; info). inline . Definition at line 445 of file TClass.h. ◆ SetMemberStreamer(). void TClass::SetMemberStreamer ; (; const char * ; name, . MemberStreamerFunc_t ; strm . ). Install a new member streamer (p will be copied). ; Definition at line 6744 of file TClass.cxx. ◆ SetMerge(). void TClass::SetMerge ; (; ROOT::MergeFunc_t ; mergeFunc). Install a new wrapper around 'Merge'. ; Definition at line 6969 of file TClass.cxx. ◆ SetNew(). void TClass::SetNew ; (; ROOT::NewFunc_t ; newFunc). Install a new wrapper around 'new'. ; Definition at line 6985 of file TClass.cxx. ◆ SetNewArray(). void TClass::SetNewArray ; (; ROOT::NewArrFunc_t ; newArrayFunc). Install a new wrapper around 'new []'. ; Definition at line 6993 of file TClass.cxx. ◆ SetResetAfterMerge(). void TClass::SetResetAfterMerge ; (; ROOT::ResetAfterMergeFunc_t ; resetFunc). Install a new wrapper around 'ResetAfterMerge'. ; Definition at line 6977 of file TClass.cxx. ◆ SetRuntimeProperties(). void TClass::SetRuntimeProperties ; (; ). private . Internal routine to set calculate the class properties that can only be known at run-time, for example whether the Hash member function and the destructor are consistent. ; Definition at line 6194 of file TClass.cxx. ◆ SetStreamerFunc(). void TClass::SetStreamerFunc ; (; ClassStreamerFunc_t ; strm). Set a wrapper/accessor function around this class custom streamer. ; Definition at line 6922 of file TClass.cxx. ◆ SetStreamerImpl(). void TClass::SetStreamerImpl ; (; ). private . Internal r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:118365,wrap,wrapper,118365,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['wrap'],['wrapper']
Integrability," TObject::Class() as the first parameter and the exact numerical value in the pointer 'o'.; In other word, inside the global IsA function. it is safe to C-style cast the value of 'obj' into a pointer to the class described by 'cl'. ; Definition at line 6367 of file TClass.cxx. ◆ SetImplFileName(). void TClass::SetImplFileName ; (; const char * ; implFileName). inline . Definition at line 560 of file TClass.h. ◆ SetLastReadInfo(). void TClass::SetLastReadInfo ; (; TVirtualStreamerInfo * ; info). inline . Definition at line 445 of file TClass.h. ◆ SetMemberStreamer(). void TClass::SetMemberStreamer ; (; const char * ; name, . MemberStreamerFunc_t ; strm . ). Install a new member streamer (p will be copied). ; Definition at line 6811 of file TClass.cxx. ◆ SetMerge(). void TClass::SetMerge ; (; ROOT::MergeFunc_t ; mergeFunc). Install a new wrapper around 'Merge'. ; Definition at line 7036 of file TClass.cxx. ◆ SetNew(). void TClass::SetNew ; (; ROOT::NewFunc_t ; newFunc). Install a new wrapper around 'new'. ; Definition at line 7052 of file TClass.cxx. ◆ SetNewArray(). void TClass::SetNewArray ; (; ROOT::NewArrFunc_t ; newArrayFunc). Install a new wrapper around 'new []'. ; Definition at line 7060 of file TClass.cxx. ◆ SetResetAfterMerge(). void TClass::SetResetAfterMerge ; (; ROOT::ResetAfterMergeFunc_t ; resetFunc). Install a new wrapper around 'ResetAfterMerge'. ; Definition at line 7044 of file TClass.cxx. ◆ SetRuntimeProperties(). void TClass::SetRuntimeProperties ; (; ). private . Internal routine to set calculate the class properties that can only be known at run-time, for example whether the Hash member function and the destructor are consistent. ; Definition at line 6261 of file TClass.cxx. ◆ SetStreamerFunc(). void TClass::SetStreamerFunc ; (; ClassStreamerFunc_t ; strm). Set a wrapper/accessor function around this class custom streamer. ; Definition at line 6989 of file TClass.cxx. ◆ SetStreamerImpl(). void TClass::SetStreamerImpl ; (; ). private . Internal r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:118366,wrap,wrapper,118366,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['wrap'],['wrapper']
Integrability," TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooIntegrator1D**RooSegmentedIntegrator1D::_arrayArray of segment integrators; RooNumIntConfigRooSegmentedIntegrator1D::_config; const RooAbsFunc*RooAbsIntegrator::_functionPointer to function binding of integrand; Int_tRooSegmentedIntegrator1D::_nsegNumber of segments; Bool_tRooAbsIntegrator::_printEvalCounterIf true print number of function evaluation required for integration; Double_tRooSegmentedIntegrator1D::_range; Bool_tRooSegmentedIntegrator1D::_useIntegrandLimits; Bool_tRooSegmentedIntegrator1D::_valid; Bool_tRooAbsIntegrator::_validIs integrator in valid state?; RooSegmentedIntegrator1D*_xIntegrator; RooAbsFunc*_xint; Double_tRooSegmentedIntegrator1D::_xmax; Double_tRooSegmentedIntegrator1D::_xmin. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void registerIntegrator(RooNumIntFactory& fact); Register RooSegmentedIntegrator2D, its parameters, dependencies and capabilities with RooNumIntFactory. RooSegmentedIntegrator2D(); Default constructor. RooSegmentedIntegrator2D(const RooAbsFunc& function, const RooNumIntConfig& config); Constructor of integral on given function binding and with given configuration. The; integration limits are taken from the definition in the function binding. RooSegmentedIntegrator2D(const RooAbsFunc& function, Double_t xmin, Double_t xmax, Double_t ymin, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSegmentedIntegrator2D.html:7051,integrat,integrators,7051,root/html602/RooSegmentedIntegrator2D.html,https://root.cern,https://root.cern/root/html602/RooSegmentedIntegrator2D.html,12,['integrat'],"['integration', 'integrator', 'integrators']"
Integrability," TObject::SetObjectStatstatic void SetObjectStat(Bool_t stat)Turn on/off tracking of objects in the TObjectTable.Definition TObject.cxx:1068; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:439; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:207; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:973; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:403; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:780; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1015; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPluginManagerThis class implements a plugin library manager.Definition TPluginManager.h:258; TPluginManager::LoadHandlersFromEnvvoid LoadHandlersFromEnv(TEnv *env)Load plugin handlers specified in config file, like:Definition TPluginManager.cxx:391; TProcessID::Cleanupstatic void Cleanup()static function (called by TROOT destructor) to delete all TProcessIDsDefinition TProcessID.cxx:204; TProcessID::AddProcessIDstatic TProcessID * AddProcessID()Static function to add a new TProcessID to the list of PIDs.Definition TProcessID.cxx:116; TProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs.Definition TProcessUUID.h:32; TQObject::BlockAllSignalsstatic Bool_t BlockAllSignals(Bool_t b)Block or unblock",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:142350,message,message,142350,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['message'],['message']
Integrability," TObject::SetObjectStatstatic void SetObjectStat(Bool_t stat)Turn on/off tracking of objects in the TObjectTable.Definition TObject.cxx:1074; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPluginManagerThis class implements a plugin library manager.Definition TPluginManager.h:258; TPluginManager::LoadHandlersFromEnvvoid LoadHandlersFromEnv(TEnv *env)Load plugin handlers specified in config file, like:Definition TPluginManager.cxx:391; TProcessID::Cleanupstatic void Cleanup()static function (called by TROOT destructor) to delete all TProcessIDsDefinition TProcessID.cxx:204; TProcessID::AddProcessIDstatic TProcessID * AddProcessID()Static function to add a new TProcessID to the list of PIDs.Definition TProcessID.cxx:116; TProcessUUIDThis class is a specialized TProcessID managing the list of UUIDs.Definition TProcessUUID.h:32; TQObject::BlockAllSignalsstatic Bool_t BlockAllSignals(Bool_t b)Block or unblock",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:142526,message,message,142526,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['message'],['message']
Integrability," TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; Double_t GetDensityFactor (EDensityMode densityMode, Int_t iBin) const;  density correction factor for a given bin ;  ; TString GetOutputBinName (Int_t iBinX) const override;  Get bin name of an outpt bin. ;  ; void RegularizeDistributionRecursive (const TUnfoldBinning *binning, ERegMode regmode, EDensityMode densityMode, const char *distribution, const char *axisSteering);  recursively add regularisation conditions for this node and its children ;  ; void RegularizeOneDistribution (const TUnfoldBinning *binning, ERegMode regmode, EDensityMode densityMode, const char *axisSteering);  regularize the distribution fof the given node ;  ;  Protected Member Functions inherited from TUnfoldSys; void ClearResults (void) override;  Clear all data members which depend on the unfolding results. ;  ; void DoBackgroundSubtraction (void);  perform background subtraction ;  ; void GetEmatrixFromVyy (const TMatrixDSparse *vyy, TH2 *ematrix, const Int_t *binMap, Bool_t clearEmat);  propagate an error matrix on the input vector to the unfolding result ;  ; TMatrixDSparse * GetSummedErrorMatrixXX (void);  determine total error matrix on the vector x ;  ; TMatrixDSparse * GetSummedErrorMatrixYY (void);  determine total error matrix on the vector Ax ;  ; virtual TMatrixDSparse * PrepareCorrEmat (const TMatrixDSparse *m1, const TMatrixDSparse *m2, const TMatrixDSparse *dsys);  propagate correlated systematic shift to an output vector ;  ; virtual void PrepareSysError (void);  Matrix calculations ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:32074,depend,depend,32074,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['depend'],['depend']
Integrability," TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; RooListProxy _gamma;  ; RooListProxy _nominal;  ; bool _relParam;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot bins. ;  ; double _plotMax = 0.0;  Maximum of plot range. ;  ; double _plotMin = 0.0;  Minimum of plot range. ;  ; bool _selectComp = true;  A buffer for reading values from trees. ;  ; std::unique_ptr< RooNumIntConfig > _specIntegratorConfig;  ; TreeReadBuffer * _treeReadBuffer = nullptr;  ; TString _unit;  Unit for objects value. ;  ; double _value = 0.0;  Cache for current value of object. ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistConstraint.html:68453,integrat,integration,68453,doc/master/classRooHistConstraint.html,https://root.cern,https://root.cern/doc/master/classRooHistConstraint.html,1,['integrat'],['integration']
Integrability," TProfile2D, TH2Poly, and TProfile2Poly.; Definition at line 93 of file TH2.h. ◆ GetBinContent() [5/5]. Double_t TH2::GetBinContent ; (; Int_t ; binx, . Int_t ; biny, . Int_t ;  . ); const. inlineoverridevirtual . Reimplemented from TH1.; Reimplemented in TProfile2D, TH2Poly, and TProfile2Poly.; Definition at line 94 of file TH2.h. ◆ GetBinErrorLow() [1/2]. Double_t TH1::GetBinErrorLow ; (; Int_t ; bin); const. virtual . Return lower error associated to bin number bin. ; The error will depend on the statistic option used will return the binContent - lower interval value ; Reimplemented from TH1.; Definition at line 271 of file TH1.cxx. ◆ GetBinErrorLow() [2/2]. virtual Double_t TH2::GetBinErrorLow ; (; Int_t ; binx, . Int_t ; biny . ). inlinevirtual . Definition at line 97 of file TH2.h. ◆ GetBinErrorUp() [1/2]. Double_t TH1::GetBinErrorUp ; (; Int_t ; bin); const. virtual . Return upper error associated to bin number bin. ; The error will depend on the statistic option used will return the binContent - upper interval value ; Reimplemented from TH1.; Definition at line 272 of file TH1.cxx. ◆ GetBinErrorUp() [2/2]. virtual Double_t TH2::GetBinErrorUp ; (; Int_t ; binx, . Int_t ; biny . ). inlinevirtual . Definition at line 98 of file TH2.h. ◆ GetBinWithContent2(). Double_t TH2::GetBinWithContent2 ; (; Double_t ; c, . Int_t & ; binx, . Int_t & ; biny, . Int_t ; firstxbin = 1, . Int_t ; lastxbin = -1, . Int_t ; firstybin = 1, . Int_t ; lastybin = -1, . Double_t ; maxdiff = 0 . ); const. virtual . compute first cell (binx,biny) in the range [firstxbin,lastxbin][firstybin,lastybin] for which diff = abs(cell_content-c) <= maxdiff In case several cells in the specified range with diff=0 are found the first cell found is returned in binx,biny. ; In case several cells in the specified range satisfy diff <=maxdiff the cell with the smallest difference is returned in binx,biny. In all cases the function returns the smallest difference.; NOTE1: if firstxbin < 0, firstxbin is set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:83214,depend,depend,83214,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,1,['depend'],['depend']
Integrability," TProof.cxx. ◆ RemoveDynamicPath(). Int_t TProof::RemoveDynamicPath ; (; const char * ; libpath, . Bool_t ; onClient = kFALSE . ). Remove 'libpath' from the lib path search. ; Multiple paths can be specified at once separating them with a comma or a blank. Return 0 on success, -1 otherwise ; Definition at line 8933 of file TProof.cxx. ◆ RemoveFeedback(). void TProof::RemoveFeedback ; (; const char * ; name). Remove object from feedback list. ; Definition at line 10000 of file TProof.cxx. ◆ RemoveIncludePath(). Int_t TProof::RemoveIncludePath ; (; const char * ; incpath, . Bool_t ; onClient = kFALSE . ). Remove 'incpath' from the inc path search. ; Multiple paths can be specified at once separating them with a comma or a blank. Return 0 on success, -1 otherwise ; Definition at line 8967 of file TProof.cxx. ◆ RemoveWorkers(). Int_t TProof::RemoveWorkers ; (; TList * ; workerList). protected . Used for shuting down the workres after a query is finished. ; Sends each of the workers from the workerList, a kPROOF_STOP message. If the workerList == 0, shutdown all the workers. ; Definition at line 1597 of file TProof.cxx. ◆ RequestStagingDataSet(). Bool_t TProof::RequestStagingDataSet ; (; const char * ; dataset). virtual . Allows users to request staging of a particular dataset. ; Requests are saved in a special dataset repository and must be honored by the endpoint. ; Reimplemented in TProofLite.; Definition at line 11020 of file TProof.cxx. ◆ Reset(). void TProof::Reset ; (; const char * ; url, . Bool_t ; hard = kFALSE . ). static . Wrapper around TProofMgr::Reset(...). ; Definition at line 11736 of file TProof.cxx. ◆ ResetEnvVars(). void TProof::ResetEnvVars ; (; ). static . Clear the list of environment variables passed to proofserv on the master and slaves. ; Definition at line 11796 of file TProof.cxx. ◆ ResetMergePrg(). void TProof::ResetMergePrg ; (; ). private . Reset the merge progress notificator. ; Definition at line 2465 of file TProof.cxx. ◆ ResetMergers(). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:133324,message,message,133324,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['message'],['message']
Integrability," TQObject.cxx:527; TQObject::ConnectToClassstatic Bool_t ConnectToClass(TQObject *sender, const char *signal, TClass *receiver_class, void *receiver, const char *slot)Create connection between sender and receiver.Definition TQObject.cxx:563; TQObject::IsAvirtual TClass * IsA() constDefinition TQObject.h:229; TQObject::LowPriorityvirtual void LowPriority(const char *signal_name, const char *slot_name=nullptr)Definition TQObject.cxx:504; TQObject::DisconnectBool_t Disconnect(const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr)Disconnects signal of this object from slot of receiver.Definition TQObject.cxx:1027; TQObject::AreAllSignalsBlockedstatic Bool_t AreAllSignalsBlocked()Returns true if all signals are blocked.Definition TQObject.cxx:1049; TQObject::HighPriorityvirtual void HighPriority(const char *signal_name, const char *slot_name=nullptr)Definition TQObject.cxx:477; TQObject::Classstatic TClass * Class(); TQObject::Connectedvirtual void Connected(const char *)Definition TQObject.h:194; TStringTokenProvides iteration through tokens of a given string.Definition TPRegexp.h:143; TStringToken::AtEndBool_t AtEnd() constDefinition TPRegexp.h:156; TStringToken::NextTokenBool_t NextToken()Get the next token, it is stored in this TString.Definition TPRegexp.cxx:1066; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; int; Cppyy::GetMethodRPY_EXPORTED TCppMethod_t GetMethod(TCppScope_t scope, TCppIndex_t imeth)Definition clingwrapper.cxx:1550; mTMarker mDefinition textangle.C:8. corebasesrcTQObject.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:07 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8cxx_source.html:47954,interface,interface,47954,doc/master/TQObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html,1,['interface'],['interface']
