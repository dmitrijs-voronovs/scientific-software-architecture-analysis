quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Deployability,"simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum proce",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2291,integrat,integrate,2291,docs/4.7/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html,2,['integrat'],['integrate']
Deployability,"simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. from qutip.states import qutrit_basis; from numpy import array. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of three level operators. '''; one, two, three = qutrit_basis(); # Note that the three level operators are different; # from the qutrit operators. A three level atom only; # has transitions 1 <-> 2 <-> 3, so we define the; # operators seperately from the qutrit code; sig11 = one * one.dag(); sig22 = two * two.dag(); sig33 = three * three.dag(); sig12 = one * two.dag(); sig32 = three * two.dag(); return array([sig11, sig22, sig33, sig12, sig32], dtype=object). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/three_level_atom.html:4055,update,updated,4055,docs/4.5/modules/qutip/three_level_atom.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/three_level_atom.html,1,['update'],['updated']
Deployability,"sing task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 3.01s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.01s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.02s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.02s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.02s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.03s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.03s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.03s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.04s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.04s. Est. time left: 00:00:00:00; Total run time: 25.07s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-parfor.html:6809,configurat,configurations,6809,docs/4.3/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-parfor.html,2,"['configurat', 'update']","['configurations', 'updated']"
Deployability,"sing:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), destroy(10)). In [23]: sm = tensor(destroy(2), qeye(10)). In [24]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [25]: data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 0.60s. Est. time left: 00:00:00:05; 20.0%. Run time: 1.13s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html:16674,configurat,configuration,16674,docs/4.2/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html,1,['configurat'],['configuration']
Deployability,"sing:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), destroy(10)). In [23]: sm = tensor(destroy(2), qeye(10)). In [24]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [25]: data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 0.62s. Est. time left: 00:00:00:05; 20.0%. Run time: 1.17s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-monte.html:16670,configurat,configuration,16670,docs/4.1/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-monte.html,1,['configurat'],['configuration']
Deployability,"sing:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), destroy(10)). In [23]: sm = tensor(destroy(2), qeye(10)). In [24]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [25]: data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 1.20s. Est. time left: 00:00:00:10; 20.0%. Run time: 2.49s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html:12996,configurat,configuration,12996,docs/3.1.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html,1,['configurat'],['configuration']
Deployability,"sing:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), destroy(10)). In [23]: sm = tensor(destroy(2), qeye(10)). In [24]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [25]: data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 1.78s. Est. time left: 00:00:00:15; 20.0%. Run time: 3.93s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:16540,configurat,configuration,16540,docs/4.3/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html,1,['configurat'],['configuration']
Deployability,"sing:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), destroy(10)). In [23]: sm = tensor(destroy(2), qeye(10)). In [24]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [25]: data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 6.57s. Est. time left: 00:00:00:59; 20.0%. Run time: 15.65",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-monte.html:16700,configurat,configuration,16700,docs/4.0.2/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-monte.html,1,['configurat'],['configuration']
Deployability,"sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe.; *Examples*; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; By default, a cubic spline interpolation will be used for the coefficient; at time t.; If the coefficients are to be treated as step function, use the arguments; args = {""_step_func_coeff"": True}; *Examples*; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). args is a dict of (name:object). The name must be a valid variables string.; Some solvers support arguments that update at each call:; sesolve, mesolve, mcsolve:; state can be obtained with:; ""state_vec"":psi0, args[""state_vec""] = state as 1D np.ndarray; ""state_mat"":psi0, args[""state_mat""] = state as 2D np.ndarray; ""state"":psi0, args[""state""] = state as Qobj. This Qobj is the initial value. expectation values:; ""expect_op_n"":0, args[""expect_op_n""] = expect(e_ops[int(n)], state); expect is <phi|O|psi> or tr(state * O) depending on state dimensions. mcsolve:; collapse can be obtained with:; ""collapse"":list => args[name] == list of collapse; each collapse will be appended to the list as (time, which c_ops). Mixing the formats is possible, but not recommended.; Mixing tlist will cause problem. Parameters; ----------; QobjEvo(Q_object=[], args={}, tlist=None). Q_object : array_like; Data for vector/matrix representation of the quantum object. args : dictionary that contain the arguments for. tlist : array_like; List of times at which the numpy-array coefficients are applied. Times; must be equidistant and start from 0. Attributes; ----------; cte :",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:8101,update,update,8101,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['update'],['update']
Deployability,"sinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelit",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:25394,update,update,25394,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['update'],['update']
Deployability,"sinstance(self.args[key], StateArgs):; self.dynamics_args += [(key, *self.args[key]())]; self.args[key] = 0. def _check_old_with_state(self):; add_vec = False; for op in self.ops:; if op.type == ""func"":; try:; op.get_coeff(0., self.args); except TypeError as e:; nfunc = _StateAsArgs(self.coeff); op = EvoElement((op.qobj, nfunc, nfunc, ""func"")); add_vec = True; if add_vec:; self.dynamics_args += [(""_state_vec"", ""vec"", None)]. def __del__(self):; for file_ in self.coeff_files:; try:; os.remove(file_); except:; pass. def __call__(self, t, data=False, state=None, args={}):; """"""; Return a single :obj:`~Qobj` at the given time ``t``.; """"""; try:; t = float(t); except Exception as e:; raise TypeError(""Time must be a real scalar."") from e. if state is not None:; self._dynamics_args_update(t, state). if args:; if not isinstance(args, dict):; raise TypeError(""The new args must be in a dict""); old_args = self.args.copy(); old_compiled = self.compiled; self.compiled = False; self.args.update(args); op_t = self.__call__(t, data=data); self.args = old_args; self.compiled = old_compiled; elif self.const:; if data:; op_t = self.cte.data.copy(); else:; op_t = self.cte.copy(); elif self.compiled and self.compiled.split()[0] != ""dense"":; op_t = self.compiled_qobjevo.call(t, data); elif data:; op_t = self.cte.data.copy(); for part in self.ops:; op_t += part.qobj.data * part.get_coeff(t, self.args); else:; op_t = self.cte.copy(); for part in self.ops:; op_t += part.qobj * part.get_coeff(t, self.args). return op_t. def _dynamics_args_update(self, t, state):; if isinstance(state, Qobj):; for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state.full().ravel(""F""); elif what == ""mat"":; self.args[name] = state.full(); elif what == ""Qobj"":; self.args[name] = state; elif what == ""expect"":; self.args[name] = op.expect(t, state). elif isinstance(state, np.ndarray) and state.ndim == 1:; s1 = self.cte.shape[1]; for name, what, op in self.dynamics_args:; if what == ""vec"":",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:19010,update,update,19010,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,2,['update'],['update']
Deployability,"sionality of the underlaying distribution.; Parameters:. fig; : matplotlib Figure instanceIf given, use this figure instance for the visualization,; ax; : matplotlib Axes instanceIf given, render the visualization using this axis instance.; figsize; : tupleSize of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style; : stringType of visualization: ‘colormap’ (default) or ‘surface’. Returns:fig, ax – A tuple of matplotlib figure and axes instances. Return type:tuple. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. update(state)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:50954,update,update,50954,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['update'],['update']
Deployability,"site repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:17703,Update,Updates,17703,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['Update'],['Updates']
Deployability,"site repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:11916,update,updates,11916,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['update'],['updates']
Deployability,"site, http://qutip.org/tutorials.html. Useful PIQS functions.¶. Operators; Command; Description. Collective spin algebra \(J_x,\ J_y,\ J_z\); jspin(N); The collective spin algebra \(J_x,\ J_y,\ J_z\) for \(N\) TLSs. Collective spin \(J_x\); jspin(N, ""x""); The collective spin operator \(Jx\). Requires \(N\) number of TLSs. Collective spin \(J_y\); jspin(N, ""y""); The collective spin operator \(J_y\). Requires \(N\) number of TLSs. Collective spin \(J_z\); jspin(N, ""z""); The collective spin operator \(J_z\). Requires \(N\) number of TLSs. Collective spin \(J_+\); jspin(N, ""+""); The collective spin operator \(J_+\). Collective spin \(J_-\); jspin(N, ""-""); The collective spin operator \(J_-\). Collective spin \(J_z\) in uncoupled basis; jspin(N, ""z"", basis='uncoupled'); The collective spin operator \(J_z\) in the uncoupled basis of dimension \(2^N\). Dicke state \(|j,m\rangle\) density matrix; dicke(N, j, m); The density matrix for the Dicke state given by \(|j,m\rangle\). Excited-state density matrix in Dicke basis; excited(N); The excited state in the Dicke basis. Excited-state density matrix in uncoupled basis; excited(N, basis=""uncoupled""); The excited state in the uncoupled basis. Ground-state density matrix in Dicke basis; ground(N); The ground state in the Dicke basis. GHZ-state density matrix in the Dicke basis; ghz(N); The GHZ-state density matrix in the Dicke (default) basis for N number of TLS. Collapse operators of the ensemble; Dicke.c_ops(); The collapse operators for the ensemble can be called by the c_ops method of the Dicke class. More functions relative to the qutip.piqs module can be found at API documentation. Attributes to the qutip.piqs.Dicke and qutip.piqs.Pim class can also be found there. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-piqs.html:6360,update,updated,6360,docs/4.4/guide/dynamics/dynamics-piqs.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-piqs.html,1,['update'],['updated']
Deployability,"sket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state,; spmvpy_csr); from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup. from qutip.ui.progressbar import BaseProgressBar; from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:3350,integrat,integrating,3350,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,1,['integrat'],['integrating']
Deployability,"slist of ints, optionalSpecifies a list of targets “qubit” indices on which to apply the; measurement using qutip.qip.gates.expand_operator to expand op; into full dimension. Returns. eigenvalues: list of floatThe list of eigenvalues of the measurement operator. eigenstates_or_projectors: list of QobjIf the state was a ket, return the eigenstates of the measurement; operator. Otherwise return the projectors onto the eigenstates. probabilities: list of floatThe probability of measuring the state as being in the corresponding; eigenstate (and the measurement result being the corresponding; eigenvalue). Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of :obj:`Qobj and; coefficient, QObjEvo, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo’s; description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opslist of Qobj or callback function, optionalSingle operator or list of ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:74821,integrat,integrating,74821,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['integrat'],['integrating']
Deployability,"so include the Fortran-based Monte Carlo solver:; pip install qutip --install-option=--with-f90mc. More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way to install QuTiP in Ubuntu (14.04 and later) is to use the QuTiP PPA; sudo add-apt-repository ppa:jrjohansson/qutip-releases; sudo apt-get update; sudo apt-get install python-qutip. A Python 3 version is also available, and can be installed using:; sudo apt-get install python3-qutip. With this method the most important dependencies are installed automatically, and when a new version of QuTiP is released it can be upgraded through the standard package management system. In addition to the required dependencies, it is also strongly recommended that you install the texlive-latex-extra package:; sudo apt-get install texlive-latex-extra. Manual installation of dependencies¶; First install the required dependencies using:; sudo apt-get install python-dev cython py",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:4674,install,install,4674,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['install'],['install']
Deployability,"solve() (in module qutip.stochastic). state_index_number() (in module qutip.states). state_number_enumerate() (in module qutip.states). state_number_index() (in module qutip.states). state_number_qobj() (in module qutip.states). steadystate() (in module qutip.steadystate). StochasticSolverOptions (class in qutip.stochastic). super_tensor() (in module qutip.tensor). swap() (in module qutip.qip.gates). swapalpha() (in module qutip.qip.gates). T. tensor() (in module qutip.tensor). tensor_contract() (in module qutip.tensor). thermal_dm() (in module qutip.states). three_level_basis() (in module qutip.three_level_atom). three_level_ops() (in module qutip.three_level_atom). tidyup() (eseries method). (Qobj method). to_choi() (in module qutip.superop_reps). to_kraus() (in module qutip.superop_reps). to_super() (in module qutip.superop_reps). toffoli() (in module qutip.qip.gates). tr() (Qobj method). tracedist() (in module qutip.metrics). trans() (Qobj method). transform() (Qobj method). TwoModeQuadratureCorrelation (class in qutip.distributions). U. unit() (Qobj method). update() (HarmonicOscillatorProbabilityFunction method). (HarmonicOscillatorWaveFunction method). (TwoModeQuadratureCorrelation method). update_ctrl_amps() (Dynamics method). update_psi() (TwoModeQuadratureCorrelation method). update_rho() (TwoModeQuadratureCorrelation method). V. value() (eseries method). variance() (in module qutip.expect). vector_mutation (Bloch attribute). vector_style (Bloch attribute). vector_to_operator() (in module qutip.superoperator). vector_width (Bloch attribute). version_table() (in module qutip.ipynbtools). visualize() (Distribution method). W. weighted_bipartite_matching() (in module qutip.graph). wigner() (in module qutip.wigner). wigner_covariance_matrix() (in module qutip.continuous_variables). WignerDistribution (class in qutip.distributions). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/genindex.html:15548,update,update,15548,docs/3.1.0/genindex.html,https://qutip.org,https://qutip.org/docs/3.1.0/genindex.html,2,['update'],"['update', 'updated']"
Deployability,"solve(H, rho0, tlist, c_op_list, [], args, options,; _safe_mode=False); for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output.states[k].full()).T; progress_bar.finished(). if len(tlist) == 2:; if unitary_mode == 'batch':; return Qobj(u[-1], dims=dims); else:; return Qobj(u[:, :, 1], dims=dims); else:; if unitary_mode == 'batch':; return np.array([Qobj(u[k], dims=dims); for k in range(len(tlist))], dtype=object); else:; return np.array([Qobj(u[:, :, k], dims=dims); for k in range(len(tlist))], dtype=object). def _get_min_and_index(lst):; """"""; Private function for obtaining min and max indicies.; """"""; minval, minidx = lst[0], 0; for i, v in enumerate(lst[1:]):; if v < minval:; minval, minidx = v, i + 1; return minval, minidx. [docs]def propagator_steadystate(U):; """"""Find the steady state for successive applications of the propagator; :math:`U`. Parameters; ----------; U : qobj; Operator representing the propagator. Returns; -------; a : qobj; Instance representing the steady-state density matrix. """""". evals, evecs = la.eig(U.full()); ; shifted_vals = np.abs(evals - 1.0); ev_idx = np.argmin(shifted_vals); ev_min = shifted_vals[ev_idx]; evecs = evecs.T; rho = Qobj(vec2mat(evecs[ev_idx]), dims=U.dims[0]); rho = rho * (1.0 / rho.tr()); rho = 0.5 * (rho + rho.dag()) # make sure rho is herm; rho.isherm = True; return rho. def _parallel_sesolve(n, N, H, tlist, args, options):; psi0 = basis(N, n); output = sesolve(H, psi0, tlist, [], args, options, _safe_mode=False); return output. def _parallel_mesolve(n, N, H, tlist, c_op_list, args, options):; col_idx, row_idx = np.unravel_index(n, (N, N)); rho0 = Qobj(sp.csr_matrix(([1], ([row_idx], [col_idx])),; shape=(N,N), dtype=complex)); output = mesolve(H, rho0, tlist, c_op_list, [], args, options,; _safe_mode=False); return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/propagator.html:10410,update,updated,10410,docs/4.3/modules/qutip/propagator.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/propagator.html,1,['update'],['updated']
Deployability,"solve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by printing a text representation:; In [18]: es; Out[18]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = (-1+0j); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[-1. 0.]; [ 0. 1.]]; Exponent #1 = 0j; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. or by evaluating it and arbitrary points in time (here at 0.0 and 1.0):; In [19]: es.value([0.0, 1.0]); Out[19]: ; array([Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.]; [0. 1.]],; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.63212056 0. ]; [0. 0.36787944]]], dtype=object). and the expectation value of the exponential series can be calculated using the qutip.expect function:; In [20]: es_expect = expect(sigmaz(), es). The result es_expect is now an exponential series with c-numbers as amplitudes, which easily can be evaluated at arbitrary times:; In [21]: es_expect.value([0.0, 1.0, 2.0, 3.0]); Out[21]: array([-1. , 0.26424112, 0.72932943, 0.90042586]). In [22]: times = linspace(0.0, 10.0, 100). In [23]: sz_expect = es_expect.value(times). In [24]: from pylab import *. In [25]: plot(times, sz_expect, lw=2);. In [26]: xlabel(""Time"", fontsize=16); ....: ylabel(""Expectation value of sigma-z"", fontsize=16);; ....: . In [27]: title(""The expectation value of the $\sigma_{z}$ operator"", fontsize=16);. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-eseries.html:8215,update,updated,8215,docs/4.5/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-eseries.html,1,['update'],['updated']
Deployability,"solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list / callback function, optionalA list of operators as Qobj and/or callable functions (can be mixed); or a single callable function. For operators, the result’s expect will; be computed by qutip.expect. For callable functions, they are; called as f(t, state) and return the expectation value.; A single callback’s expectation value can be any type, but a callback; part of a list must return a number as the expectation value. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:85023,integrat,integrator,85023,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['integrat'],['integrator']
Deployability,"solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip.Optionswith options for the solver. progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectatio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:80399,integrat,integrator,80399,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['integrat'],['integrator']
Deployability,"source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971). unitarity(oper)[source]¶; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map’s superoperator representation. Parameters. operQobjQuantum map under consideration. Returns. ufloatUnitarity of oper. Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters. basislistList of operators that defines the basis for the correlation matrix. rhoQobjDensity matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns. corr_matndarrayA 2-dimensional array of correlation values or operators. correlation_matrix_field(a1, a2, rho=None)[source]¶; Calculates the correlation matrix for given field operators \(a_1\) and; \(a_2\). If a density matrix is given the expectation values are; calculated, otherwise a matrix with operators is returned. Parameters. a1QobjField operator for mode 1. a2QobjField operator for mode 2. rhoQobjDensity matrix for which to calculate the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:67165,continuous,continuous,67165,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,3,"['Continuous', 'continuous']","['Continuous', 'continuous']"
Deployability,"source]¶; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The C",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:155351,configurat,configuration,155351,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,4,['configurat'],['configuration']
Deployability,"space(0.0, 20 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; linspace(0, T, 500 + 1), H, T, args). # solve the floquet-markov master equation; output = fmmesolve(H, psi0, tlist, [sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = zeros(shape(tlist), dtype=complex); for idx, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); p_ex[idx] = expect(num(2), output.states[idx].transform(f_modes_t, True)). # For reference: calculate the same thing with mesolve; output = mesolve(H, psi0, tlist, [sqrt(gamma1) * sigmax()], [num(2)], args); p_ex_ref = output.expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'r--', tlist, 1-real(p_ex), 'b--'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code, png, hires.png, pdf). Alternatively, we can let the qutip.floquet.fmmesolve function transform the density matrix at each time step back to the computational basis, and calculating the expectation values for us, but using:; output = fmmesolve(H, psi0, tlist, [sigmax()], [num(2)], [noise_spectrum], T, args); p_ex = output.expect[0]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-floquet.html:19021,update,updated,19021,docs/4.5/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-floquet.html,1,['update'],['updated']
Deployability,"specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. use_umfpack : bool {False, True}. Use umfpack solver instead of SuperLU. For SciPy 0.14+, this option; requires installing scikits.umfpack. x0 : ndarray, optional. ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000. ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-9. ITERATIVE ONLY. Tolerance used for terminating solver. permc_spec : str, optional, default=’COLAMD’. ITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precond : bool optional, default = False. ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional. ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramati",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:90683,install,installing,90683,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['install'],['installing']
Deployability,"sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing.; MAJOR FEATURE: Added a photon scattering module (by Ben Bartlett) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides.; Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed.; Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors.; Computing Q.overlap() [inner product] is now ~30x faster.; Added projector method to Qobj class.; Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/changelog.html:7293,configurat,configuration,7293,docs/4.5/changelog.html,https://qutip.org,https://qutip.org/docs/4.5/changelog.html,3,['configurat'],['configuration']
Deployability,"sponds to the control pulse sequence for; one Hamiltonian. Notes; -----; ``len(tlist) - 1 = coeffs.shape[1]`` since tlist gives the beginning; and the end of the pulses.; """"""; if setting_args is None:; setting_args = {}; if isinstance(qc, QubitCircuit):; props = qc.propagators(); gates = [g.name for g in qc.gates]; elif isinstance(qc, Iterable):; props = qc; gates = None # using list of Qobj, no gates name; else:; raise ValueError(; ""qc should be a ""; ""QubitCircuit or a list of Qobj""); if merge_gates: # merge all gates/Qobj into one Qobj; props = [gate_sequence_product(props)]; gates = None. time_record = [] # a list for all the gates; coeff_record = []; last_time = 0. # used in concatenation of tlist; for prop_ind, U_targ in enumerate(props):; U_0 = identity(U_targ.dims[0]). # If qc is a QubitCircuit and setting_args is not empty,; # we update the kwargs for each gate.; # keyword arguments in setting_arg have priority; if gates is not None and setting_args:; kwargs.update(setting_args[gates[prop_ind]]). full_drift_ham = self.drift.get_ideal_qobjevo(self.dims).cte; full_ctrls_hams = [pulse.get_ideal_qobj(self.dims); for pulse in self.pulses]; result = cpo.optimize_pulse_unitary(; full_drift_ham, full_ctrls_hams, U_0, U_targ, **kwargs). if result.fid_err > min_fid_err:; warnings.warn(; ""The fidelity error of gate {} is higher ""; ""than required limit. Use verbose=True to see""; ""the more detailed information."".format(prop_ind)). time_record.append(result.time[1:] + last_time); last_time += result.time[-1]; coeff_record.append(result.final_amps.T). if verbose:; print(""********** Gate {} **********"".format(prop_ind)); print(""Final fidelity error {}"".format(result.fid_err)); print(""Final gradient normal {}"".format(; result.grad_norm_final)); print(""Terminated due to {}"".format(result.termination_reason)); print(""Number of iterations {}"".format(result.num_iter)). tlist = np.hstack([[0.]] + time_record); for i in range(len(self.pulses)):; self.pulses[i].tlist = tlist; coeff",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html:7505,update,update,7505,docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,4,['update'],['update']
Deployability,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:5315,update,updated,5315,docs/4.0.2/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html,1,['update'],['updated']
Deployability,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:5315,update,updated,5315,docs/4.2/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html,1,['update'],['updated']
Deployability,"spose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/partial_transpose.html:5315,update,updated,5315,docs/4.1/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/partial_transpose.html,1,['update'],['updated']
Deployability,"ssion.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['brmesolve', 'bloch_redfield_solve', 'bloch_redfield_tensor']. import numpy as np; import scipy.integrate; import scipy.sparse as sp; from qutip.qobj import Qobj, isket; from qutip.superoperator import spre, spost, vec2mat, mat2vec, vec2mat_index; from qutip.expect import expect; from qutip.solver import Options, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.solver import Result; from qutip.superoperator import liouvillian; from qutip.cy.spconvert import arr_coo2fast. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops, e_ops=[], spectra_cb=[], c_ops=[],; args={}, options=Options(),; _safe_mode=True):; """"""; Solve the dynamics for a system using the Bloch-Redfield master equation. .. note::. This solver does not currently support time-dependent Hamiltonians. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. rho0 / psi0: :class:`qutip.Qobj`; Initial density matrix or state",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/bloch_redfield.html:2180,integrat,integrate,2180,docs/4.0.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/bloch_redfield.html,2,['integrat'],['integrate']
Deployability,"st Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # ------------------------------------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:20706,integrat,integrator,20706,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['integrat'],['integrator']
Deployability,"st version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, suc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:8505,integrat,integration,8505,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,2,['integrat'],['integration']
Deployability,"st)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, args). return H * psi. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, psi, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, psi, args). return H * psi. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); L = -1.0j * H; ; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/sesolve.html:8860,integrat,integrator,8860,docs/4.1/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/sesolve.html,1,['integrat'],['integrator']
Deployability,"st)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, args). return H * psi. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, psi, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, psi, args). return H * psi. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(cy_ode_rhs); L = -1.0j * H; r.set_f_params(L.data.data, L.data.indices, L.data.indptr) # cython RHS; r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:8563,integrat,integrator,8563,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['integrat'],['integrator']
Deployability,"st)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, args). return H * psi. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, psi, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, psi, args). return H * psi. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(cy_ode_rhs); L = -1.0j * H; r.set_f_params(L.data.data, L.data.indices, L.data.indptr) # cython RHS; r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, norm, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:9656,integrat,integrator,9656,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['integrat'],['integrator']
Deployability,"stance between two density matrices A & B. Parameters:; A : qobj; Density matrix or state vector. B : qobj; Density matrix or state vector with same dimensions as A. Returns:; dist : float; Hilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). average_gate_fidelity(oper, target=None)[source]¶; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters:; A : Qobj; Quantum object representing a superoperator. target : Qobj; Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns:; fid : float; Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary. process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters:; basis : list; List of operators that defines the basis for the correlation matrix. rho : Qobj; Density matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns:; corr_mat : ndarray; A 2-dimensional array of correlation values or operators. covariance_matrix(basis, rho, symmetrized=True)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the covariance; matrix:. \[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle\]; or, if of the optional argument symmetrized=False,. \[V_{mn} = \langle a_m a_n\rangle -; \langle a_m \rangle \langle a_n\ra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:48955,continuous,continuous,48955,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['continuous'],['continuous']
Deployability,"stance(H[0], list) else H[0]; else:; H0 = H. if len(c_op_list) == 0 and H0.isoper:; # calculate propagator for the wave function. N = H0.shape[0]; dims = H0.dims; u = np.zeros([N, N, len(tlist)], dtype=complex). progress_bar.start(N); for n in range(0, N):; progress_bar.update(n); psi0 = basis(N, n); output = sesolve(H, psi0, tlist, [], args, options); for k, t in enumerate(tlist):; u[:, n, k] = output.states[k].full().T; progress_bar.finished(). # todo: evolving a batch of wave functions:; # psi_0_list = [basis(N, n) for n in range(N)]; # psi_t_list = mesolve(H, psi_0_list, [0, t], [], [], args, options); # for n in range(0, N):; # u[:,n] = psi_t_list[n][1].full().T. elif len(c_op_list) == 0 and H0.issuper:; # calculate the propagator for the vector representation of the; # density matrix (a superoperator propagator). N = H0.shape[0]; dims = H0.dims. u = np.zeros([N, N, len(tlist)], dtype=complex). progress_bar.start(N); for n in range(0, N):; progress_bar.update(n); psi0 = basis(N, n); rho0 = Qobj(vec2mat(psi0.full())); output = mesolve(H, rho0, tlist, [], [], args, options); for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output.states[k].full()).T; progress_bar.finished(). else:; # calculate the propagator for the vector representation of the; # density matrix (a superoperator propagator). N = H0.shape[0]; dims = [H0.dims, H0.dims]. u = np.zeros([N * N, N * N, len(tlist)], dtype=complex). if sparse:; progress_bar.start(N * N); for n in range(N * N):; progress_bar.update(n); psi0 = basis(N * N, n); psi0.dims = [dims[0], 1]; rho0 = vector_to_operator(psi0); output = mesolve(H, rho0, tlist, c_op_list, [], args, options); for k, t in enumerate(tlist):; u[:, n, k] = operator_to_vector(; output.states[k]).full(squeeze=True); progress_bar.finished(). else:; progress_bar.start(N * N); for n in range(N * N):; progress_bar.update(n); psi0 = basis(N * N, n); rho0 = Qobj(vec2mat(psi0.full())); output = mesolve(H, rho0, tlist, c_op_list, [], args, options); for k, t in e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/propagator.html:6471,update,update,6471,docs/3.1.0/modules/qutip/propagator.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/propagator.html,1,['update'],['update']
Deployability,"stance(c_ops[ii], list):; if isinstance(c_ops[ii][0], Qobj):; _temp_state = c_ops[ii][0]; elif isinstance(c_ops[ii][0], tuple):; do_tests = False; for kk in range(len(c_ops[ii][0])):; _temp_state = c_ops[ii][0][kk]; _structure_check(Hdims, Htype, _temp_state); else:; raise Exception('Invalid td-list element.'); if do_tests:; _structure_check(Hdims, Htype, _temp_state). if isinstance(e_ops, list):; for ii in range(len(e_ops)):; if isinstance(e_ops[ii], Qobj):; _temp_state = e_ops[ii]; elif isinstance(e_ops[ii], list):; _temp_state = e_ops[ii][0]; else:; raise Exception('Invalid td-list element.'); _structure_check(Hdims,Htype,_temp_state); elif isinstance(e_ops, FunctionType):; pass; else:; raise Exception('Invalid e_ops specification.'). def _structure_check(Hdims, Htype, state):; if state is not None:; # Input state is a ket vector; if state.type == 'ket':; # Input is Hamiltonian; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operator and ket do not '; 'share same structure.'); # Input is super and state is ket; elif Htype == 'super':; if Hdims[1][1] != state.dims[0]:; raise Exception('Input operator and ket do not '; 'share same structure.'); else:; raise Exception('Invalid input operator.'); # Input state is a density matrix; elif state.type == 'oper':; # Input is Hamiltonian and state is density matrix; if Htype == 'oper':; if Hdims[1] != state.dims[0]:; raise Exception('Input operators do not '; 'share same structure.'); # Input is super op. and state is density matrix; elif Htype == 'super':; if Hdims[1] != state.dims:; raise Exception('Input operators do not '; 'share same structure.'). #; # create a global instance of the SolverConfiguration class; #; config = SolverConfiguration(). # for backwards compatibility; Odeoptions = Options; Odedata = Result. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/solver.html:28343,update,updated,28343,docs/4.7/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html,2,['update'],['updated']
Deployability,"state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object at 0x2b225f631c18>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters. waveguide_emission_indiceslist or tupleList of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]]. n_time_binsintNumber of time bins; the range over which each index can vary. Returns. temporal_basis_vector:class: qutip.QobjA basis vector representing photon scattering at the specified indices.; If there are W waveguides, T times, and N photon emissions, then the; basis vector has dimensionality (W*T)^N. temporal",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:112012,configurat,configuration,112012,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['configurat'],['configuration']
Deployability,"state.isket:; out = _qfunc_iterative_single(state.full().ravel(), alpha_grid, g); out /= np.pi; return out; # We don't use Qobj.eigenstates() to avoid building many unnecessary CSR; # versions of dense matrices.; values, vectors = eigh(state.full()); vectors = vectors.T; out = values[0] * _qfunc_iterative_single(vectors[0], alpha_grid, g); for value, vector in zip(values[1:], vectors[1:]):; out += value * _qfunc_iterative_single(vector, alpha_grid, g); out /= np.pi; return out. # -----------------------------------------------------------------------------; # PSEUDO DISTRIBUTION FUNCTIONS FOR SPINS; #; [docs]def spin_q_function(rho, theta, phi):; r""""""The Husimi Q function for spins is defined as ``Q(theta, phi) =; SCS.dag() * rho * SCS`` for the spin coherent state ``SCS = spin_coherent(; j, theta, phi)`` where j is the spin length.; The implementation here is more efficient as it doesn't; generate all of the SCS at theta and phi (see references). The spin Q function is normal when integrated over the surface of the; sphere. .. math:: \frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1. Parameters; ----------; state : qobj; A state vector or density matrix for a spin-j quantum system.; theta : array_like; Polar (colatitude) angle at which to calculate the Husimi-Q function.; phi : array_like; Azimuthal angle at which to calculate the Husimi-Q function. Returns; -------; Q, THETA, PHI : 2d-array; Values representing the spin Husimi Q function at the values specified; by THETA and PHI. References; ----------; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. """""". if rho.type == 'bra':; rho = rho.dag(). if rho.type == 'ket':; rho = ket2dm(rho). J = rho.shape[0]; j = (J - 1) / 2. THETA, PHI = meshgrid(theta, phi). Q = np.zeros_like(THETA, dtype=complex). for m1 in arange(-j, j + 1):; Q += binom(2 * j, j + m1) * cos(THETA / 2) ** (2 * (j + m1)) * \; sin(THETA / 2) ** (2 * (j - m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:28228,integrat,integrated,28228,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,4,['integrat'],['integrated']
Deployability,"stem (into any combination of; waveguides).; c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zero_state : :class: qutip.Qobj; State representing zero excitations in the system. Defaults to; `basis(systemDims, 0)`.; construct_effective_hamiltonian : bool; Whether an effective Hamiltonian should be constructed from H and c_ops:; :math:`H_{eff} = H - \\frac{i}{2} \\sum_n \\sigma_n^\\dagger \\sigma_n`; Default: True. Returns; -------; scattering_prob : float; The probability of scattering n photons from the system over the time; range specified.; """"""; phi_n = temporal_scattered_state(H, psi0, n_emissions, c_ops, tlist,; system_zero_state,; construct_effective_hamiltonian); T = len(tlist); W = len(c_ops). # Compute <omega_tau> for all combinations of tau; all_emission_indices = combinations_with_replacement(range(T), n_emissions); probs = np.zeros([T] * n_emissions). # Project scattered state onto temporal basis; for emit_indices in all_emission_indices:; # Consider unique emission time partitionings; partition = tuple(set(set_partition(emit_indices, W))); # wg_indices_list = list(set_partition(indices, W)); for wg_indices in partition:; projector = temporal_basis_vector(wg_indices, T); amplitude = (projector.dag() * phi_n).full().item(); probs[emit_indices] += np.real(amplitude.conjugate() * amplitude). # Iteratively integrate to obtain single value; while probs.shape != ():; probs = np.trapz(probs, x = tlist); return np.abs(probs). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/scattering.html:13316,integrat,integrate,13316,docs/4.4/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/scattering.html,2,"['integrat', 'update']","['integrate', 'updated']"
Deployability,"stic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.general_stochastic function. Stochastic Schrodinger Equation¶; The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]). (2)¶\[d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\frac{e_n}{2} S_n; + \frac{e_n^2}{8} \right) \psi(t) dt; + \sum_n \left( S_n - \frac{e_n}{2} \right) \psi(t) dW_n,\]; where \(H\) is the Hamiltonian, \(S_n\) a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:1404,continuous,continuous,1404,docs/4.7/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html,2,['continuous'],['continuous']
Deployability,"stribution¶; Finally, one can also use the Anaconda CE package to install all of the QuTiP. Installation on Windows¶; QuTiP is primarily developed for Unix-based platforms such as Linux an Mac OS X, but it can also be used on Windows. We have limited experience and ability to help troubleshoot problems on Windows, but the following installation steps have been reported to work:. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32. [build_ext]; compiler = mingw32. The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above. Obtain the QuTiP source code and installed it following the instructions given above. Note; In some cases, to get the dynamic compilation of Cython code to work, it; might be necessary to edit the PATH variable and make sure that; C:\MinGW32-xy\bin appears either first in the PATH list, or possibly; right after C:\Python27\Lib\site-packages\PyQt4. This is to make sure; that the right version of the MinGW compiler is used if more than one; is installed (not uncommon under Windows, since many packages are; distributed and installed with their own version of all dependencies). Optional Installation Options¶. UMFPACK Linear Solver¶; As of SciPy 0.14+, the umfpack linear solver routines for solving large-scale sparse linear systems have been replaced due to licensing restrictions. The default method for all sparse linear problems is now the SuperLU library. However, scipy still includes the ability to call the umfpack li",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:9289,install,installed,9289,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,1,['install'],['installed']
Deployability,"stribution¶; Finally, one can also use the Anaconda CE package to install all of the QuTiP. Installation on Windows¶; QuTiP is primarily developed for Unix-based platforms such as Linux an Mac OS X, but it can also be used on Windows. We have limited experience and ability to help troubleshoot problems on Windows, but the following installation steps have been reported to work:. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32. [build_ext]; compiler = mingw32. The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above. Obtain the QuTiP source code and installed it following the instructions given above. Note; In some cases, to get the dynamic compilation of Cython code to work, it; might be necessary to edit the PATH variable and make sure that; C:\MinGW32-xy\bin appears either first in the PATH list, or possibly; right after C:\Python27\Lib\site-packages\PyQt4. This is to make sure; that the right version of the MinGW compiler is used if more than one; is installed (not uncommon under Windows, since many packages are; distributed and installed with their own version of all dependencies). Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If su",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:9197,install,installed,9197,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,1,['install'],['installed']
Deployability,"string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. # -----------------------------------------------------------------------------; # Master equation solver for python-function time-dependence.; #; def _mesolve_func_td(L_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3])",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:21507,integrat,integrator,21507,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['integrat'],['integrator']
Deployability,"sub-class and concatenate; the compiled pulses. Parameters; ----------; N: int; The number of the component systems. params: dict, optional; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optional; A map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; ``(pulse_label, coeff)``, instead of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling routine saved under the attributes ``gate_compiler``. Attributes; ----------; gate_compiler: dict; The Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dict; Arguments for individual compiling routines.; It adds more flexibility in customizing compiler.; """"""; def __init__(self, N, params=None, pulse_dict=None):; self.gate_compiler = {}; self.N = N; self.params = params if params is not None else {}; self.pulse_dict = pulse_dict if pulse_dict is not None else {}; self.gate_compiler = {""GLOBALPHASE"": self.globalphase_compiler}; self.args = {""params"": self.params}; self.global_phase = 0. [docs] def globalphase_compiler(self, gate, args):; """"""; Compiler for the GLOBALPHASE gate; """"""; pass. [docs] def compile(self, circuit, schedule_mode=None, args=None):; """"""; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters; ----------; circuit: :class:`.QubitCircuit` or list of; :class:`.Gate`; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in `gate_compiler`. s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:3480,continuous,continuous,3480,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,4,['continuous'],['continuous']
Deployability,"subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:9614,release,release,9614,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['release'],['release']
Deployability,"success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:13706,deploy,deployment,13706,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,4,['deploy'],['deployment']
Deployability,"success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:8958,deploy,deployment,8958,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,4,['deploy'],['deployment']
Deployability,"sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way to install QuTiP in Ubuntu (14.04 and later) is to use the QuTiP PPA; sudo add-apt-repository ppa:jrjohansson/qutip-releases; sudo apt-get update; sudo apt-get install python-qutip. A Python 3 version is also available, and can be installed using:; sudo apt-get install python3-qutip. With this method the most important dependencies are installed automatically, and when a new version of QuTiP is released it can be upgraded through the standard package management system. In addition to the required dependencies, it is also strongly recommended that you install the texlive-latex-extra package:; sudo apt-get install texlive-latex-extra. Manual installation of dependencies¶; First install the required dependencies using:; sudo apt-get install python-dev cython python-setuptools python-nose; sudo apt-get install python-numpy python-scipy python-matplotlib. Then install QuTiP from source following the instructions given above.; Alternatively (or additionally), to install a Python 3 environment, use:; sudo apt-get install python3-dev cython python3-setuptools python3-nose; sudo apt-get install python3-numpy python3-scipy python3-matplotlib. and then do the installation from source using python3 instead of python.; Optional, but recommended, dependencies can be installed using:; sudo apt-get install texlive-latex-extra # recommended; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.6+)¶; If you have not done so already, install the Apple Xcode developer tools from the Apple App Store. After installation, open Xcode and go to: Preferences -> Downloads, and install the ‘Command Line Tools’. Setup Using Macports¶; On the Mac OS, we recommended that you install the required libraries via MacP",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:5688,install,install,5688,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,1,['install'],['install']
Deployability,"sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way to install QuTiP in Ubuntu (14.04 and later) is to use the QuTiP PPA; sudo add-apt-repository ppa:jrjohansson/qutip-releases; sudo apt-get update; sudo apt-get install python-qutip. A Python 3 version is also available, and can be installed using:; sudo apt-get install python3-qutip. With this method the most important dependencies are installed automatically, and when a new version of QuTiP is released it can be upgraded through the standard package management system. In addition to the required dependencies, it is also strongly recommended that you install the texlive-latex-extra package:; sudo apt-get install texlive-latex-extra. Manual installation of dependencies¶; First install the required dependencies using:; sudo apt-get install python-dev cython python-setuptools python-nose; sudo apt-get install python-numpy python-scipy python-matplotlib. Then install QuTiP from source following the instructions given above.; Alternatively (or additionally), to install a Python 3 environment, use:; sudo apt-get install python3-dev cython3 python3-setuptools python3-nose; sudo apt-get install python3-numpy python3-scipy python3-matplotlib. and then do the installation from source using python3 instead of python.; Optional, but recommended, dependencies can be installed using:; sudo apt-get install texlive-latex-extra # recommended for plotting; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install liblapack-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.8+)¶. Setup Using Homebrew¶; The latest version of QuTiP can be quickly installed on OS X using Homebrew and the automated installation shell scripts. Python 2.7 installation script; Python 3.4 installation script. Havi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:5777,install,install,5777,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['install'],['install']
Deployability,"sults; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html:1414,continuous,continuous,1414,docs/4.6/guide/dynamics/dynamics-photocurrent.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html,2,['continuous'],['continuous']
Deployability,"systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {‘propagator’, ‘mesolve’}; Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options : qutip.solver.Options; Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : qutip.Qobj; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : qutip.Qobj; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:29229,integrat,integrator,29229,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['integrat'],['integrator']
Deployability,"t 2 eigvals are degenerate; eigvecs_array[inds] = degen(; tol, eigvecs_array[inds],; np.array([ops[kk] for kk in range(1, num_ops)])); k = max(inds) + 1; eigvals_out = np.zeros((num_ops, len(ds)), dtype=float); kets_out = np.array([Qobj(eigvecs_array[j] / la.norm(eigvecs_array[j]),; dims=[ops[0].dims[0], [1]],; shape=[ops[0].shape[0], 1]); for j in range(len(ds))]); if not evals:; return kets_out; else:; for kk in range(num_ops):; for j in range(len(ds)):; eigvals_out[kk, j] = np.real(np.dot(; eigvecs_array[j].conj().T,; ops[kk].data * eigvecs_array[j])); return eigvals_out, kets_out. def degen(tol, in_vecs, ops):; """"""; Private function that finds eigen vals and vecs for degenerate matrices..; """"""; n = len(ops); if n == 0:; return in_vecs; A = ops[0]; vecs = np.column_stack(in_vecs); eigvals, eigvecs = la.eig(np.dot(vecs.conj().T, A.data.dot(vecs))); zipped = list(zip(-eigvals, range(len(eigvals)))); zipped.sort(); ds, perm = zip(*zipped); ds = -np.real(np.array(ds)); perm = np.array(perm); vecsperm = np.zeros(eigvecs.shape, dtype=complex); for kk in range(len(perm)): # matrix with sorted eigvecs in columns; vecsperm[:, kk] = eigvecs[:, perm[kk]]; vecs_new = np.dot(vecs, vecsperm); vecs_out = np.array(; [np.zeros((A.shape[0], 1), dtype=complex) for k in range(len(ds))]); for kk in range(len(perm)): # matrix with sorted eigvecs in columns; vecs_out[kk][:, 0] = vecs_new[:, kk]; k = 0; rng = np.arange(len(ds)); while k < len(ds):; inds = np.array(abs(ds - ds[k]) < max(; tol, tol * abs(ds[k]))) # get indicies of degenerate eigvals; inds = rng[inds]; if len(inds) > 1: # if at least 2 eigvals are degenerate; vecs_out[inds] = degen(tol, vecs_out[inds],; np.array([ops[jj] for jj in range(1, n)])); k = max(inds) + 1; return vecs_out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/simdiag.html:5736,update,updated,5736,docs/4.4/modules/qutip/simdiag.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/simdiag.html,1,['update'],['updated']
Deployability,"t = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list / dictionary; The optional additional argument to the ``task`` function.; task_kwargs : list / dictionary; The optional additional keyword argument to the ``task`` function.; progress_bar : ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(); pool.join(); raise e. progress_bar.finished(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/parallel.html:7915,update,update,7915,docs/4.6/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/parallel.html,4,['update'],"['update', 'updated']"
Deployability,"t Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide.html:3522,update,updated,3522,docs/4.6/guide/guide.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide.html,2,['update'],['updated']
Deployability,"t against these libraries, then QuTiP will take advantage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that your have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; Paul D. Nation & Robert J. Johansson. ('QuTiP Version: ', '3.0.1'); ('Numpy Version: ', '1.8.0'); ('Scipy Version: ', '0.13.3'); ('Cython Version: ', '0.20.1post0'); ('Matplotlib Version: ', '1.3.1'); ('Fortran mcsolver: ', 'True'); ('scikits.umfpack: ', 'False'); ('Python Version: ', '2.7.6'); ('Platform Info: ', 'Linux', '(x86_64)'); (). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:11891,install,installed,11891,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,1,['install'],['installed']
Deployability,"t angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b=Bloch(); b.vector_color = ['r']; b.view=[-40,30]; for i in xrange(len(sx)):; b.clear(); b.add_vectors([sin(theta),0,cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere=Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([sin(theta),0,cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=True, repeat=False); ani.save('bloch_sphere.mp4', fps=20, clear_temp=True). The resulting movie may be viewed here: Bloch_Decay.mp4. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-bloch.html:16374,install,install,16374,docs/3.0.1/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-bloch.html,2,"['install', 'update']","['install', 'updated']"
Deployability,"t angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b=Bloch(); b.vector_color = ['r']; b.view=[-40,30]; for i in xrange(len(sx)):; b.clear(); b.add_vectors([sin(theta),0,cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -r 20 -b 1800 -i bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg. While either choice works on linux, it is best to choose ffmpeg when running on the Mac. If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows:; from pylab import *; import matplotlib.animation as animation; from mpl_toolkits.mplot3d import Axes3D. fig = figure(); ax = Axes3D(fig,azim=-40,elev=30); sphere=Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([sin(theta),0,cos(theta)]); sphere.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=True, repeat=False); ani.save('bloch_sphere.mp4', fps=20, clear_temp=True). The resulting movie may be viewed here: Bloch_Decay.mp4. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-bloch.html:16312,install,install,16312,docs/3.0.0/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html,2,"['install', 'update']","['install', 'updated']"
Deployability,"t can be called like a normal function with a; single or array of input points at which to evaluate; the interplating function.; ; Habermann & Kindermann, ""Multidimensional Spline Interpolation: ; Theory and Applications"", Comput Econ 30, 153 (2007). ; ; '''; ; def __init__(self, a, b, y, alpha=0, beta=0):; y = np.asarray(y); n = y.shape[0] - 1; h = (b - a)/n. coeff = np.zeros(n + 3, dtype=y.dtype); # Solutions to boundary coeffcients of spline; coeff[1] = 1/6. * (y[0] - (alpha * h**2)/6) #C2 in paper; coeff[n + 1] = 1/6. * (y[n] - (beta * h**2)/6) #cn+2 in paper. # Compressed tridiagonal matrix ; ab = np.ones((3, n - 1), dtype=float); ab[0,0] = 0 # Because top row is upper diag with one less elem; ab[1, :] = 4; ab[-1,-1] = 0 # Because bottom row is lower diag with one less elem; ; B = y[1:-1].copy() #grabs elements y[1] - > y[n-2] for reduced array; B[0] -= coeff[1]; B[-1] -= coeff[n + 1]. coeff[2:-2] = la.solve_banded((1, 1), ab, B, overwrite_ab=True, ; overwrite_b=True, check_finite=False). coeff[0] = alpha * h**2/6. + 2 * coeff[1] - coeff[2]; coeff[-1] = beta * h**2/6. + 2 * coeff[-2] - coeff[-3]. self.a = a # Lower-bound of domain; self.b = b # Uppser-bound of domain; self.coeffs = coeff # Spline coefficients; self.is_complex = (y.dtype == complex) #Tells which dtype solver to use; ; def __call__(self, pnts, *args):; #If requesting a single return value; if isinstance(pnts, (int, float, complex)):; if self.is_complex:; return zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return interp(pnts, self.a, self.b, self.coeffs); #If requesting multiple return values from array_like; elif isinstance(pnts, (np.ndarray,list)):; pnts = np.asarray(pnts); if self.is_complex:; return arr_zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return arr_interp(pnts, self.a, self.b, self.coeffs). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/interpolate.html:3085,update,updated,3085,docs/4.7/modules/qutip/interpolate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/interpolate.html,2,['update'],['updated']
Deployability,"t deepcopy; import numpy as np. __all__ = ['Instruction']. [docs]class Instruction():; """"""; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters; ----------; gate: :class:`.Gate`; The quantum gate.; duration: list, optional; The execution time needed for the instruction.; tlist: array_like, optional; A list of time at which the time-dependent coefficients are; applied. See :class:`.Pulse` for detailed information`; pulse_info: list, optional; A list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes; ----------; targets: list, optional; The target qubits.; controls: list, optional; The control qubits.; used_qubits: set; Union of the control and target qubits.; """"""; def __init__(; self, gate, tlist=None,; pulse_info=(), duration=1):; self.gate = deepcopy(gate); self.used_qubits = set(); if self.targets is not None:; self.targets.sort() # Used when comparing the instructions; self.used_qubits |= set(self.targets); if self.controls is not None:; self.controls.sort(); self.used_qubits |= set(self.controls); self.tlist = tlist; if self.tlist is not None:; if np.isscalar(self.tlist):; self.duration = self.tlist; elif abs(self.tlist[0]) > 1.e-8:; raise ValueError(""Pulse time sequence must start from 0""); else:; self.duration = self.tlist[-1]; else:; self.duration = duration; self.pulse_info = pulse_info. @property; def name(self):; return self.gate.name. @property; def targets(self):; return self.gate.targets. @property; def controls(self):; return self.gate.controls. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/instruction.html:4046,update,updated,4046,docs/4.6/modules/qutip/qip/compiler/instruction.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/instruction.html,2,['update'],['updated']
Deployability,"t fit the initial state""); else:; if shape_op[0] != l_vec or shape_op[1] != l_vec:; raise Exception(""The size of the e_ops does ""; ""not fit the initial state""). if sso.m_ops is not None:; for op in sso.m_ops:; shape_op = op.shape; if sso.me:; if shape_op[0]**2 != l_vec or shape_op[1]**2 != l_vec:; raise Exception(""The size of the m_ops does ""; ""not fit the initial state""); else:; if shape_op[0] != l_vec or shape_op[1] != l_vec:; raise Exception(""The size of the m_ops does ""; ""not fit the initial state""). def _sesolve_generic(sso, options, progress_bar):; """"""; Internal function. See smesolve.; """"""; res = Result(); res.times = sso.times; res.expect = np.zeros((len(sso.e_ops), len(sso.times)), dtype=complex); res.ss = np.zeros((len(sso.e_ops), len(sso.times)), dtype=complex); res.measurement = []; res.solver = sso.solver_name; res.ntraj = sso.ntraj; res.num_expect = len(sso.e_ops). nt = sso.ntraj; task = _single_trajectory; map_kwargs = {'progress_bar': sso.progress_bar}; map_kwargs.update(sso.map_kwargs); task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs); noise = []; for result in results:; states_list, dW, m, expect = result; if options.average_states or options.store_states:; res.states.append(states_list); noise.append(dW); res.measurement.append(m); res.expect += expect; res.ss += expect * expect; res.noise = np.stack(noise). if sso.store_all_expect:; paths_expect = []; for result in results:; paths_expect.append(result[3]); res.runs_expect = np.stack(paths_expect). # average density matrices (vectorized maybe); # ajgpitch 2019-10-25: np.any(res.states) seems to error; # I guess there may be a potential exception if there are no states?; # store individual trajectory states; if options.store_states:; res.traj_states = res.states; else:; res.traj_states = None; res.avg_states = None; if options.average_states:; avg_states_list = []; for n in range(len(res.times)):; if res.states[0][n].sh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/stochastic.html:39657,update,update,39657,docs/4.7/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html,2,['update'],['update']
Deployability,t gradient methods). num_fidelity_func_calls; (integer) Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls; (integer) Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute; (integer) Number of time the timeslot evolution is recomputed (It is only computed if any amplitudes changed since the last call). num_fidelity_computes; (integer) Number of time the fidelity is computed (It is only computed if any amplitudes changed since the last call). num_grad_computes; (integer) Number of time the gradient is computed (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates; (integer) Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter; (float) Mean number of control amplitude updates per iteration. num_timeslot_changes; (integer) Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update; (float) Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes; (integer) Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update; (float) Mean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class; Attributes. level. parent; (some control object (Dynamics or Optimizer)) aka the host. Object that generates the data that is dumped and is host to this dump object. dump_dir; (str) directory where files (if any) will be written out the path and be relative or absolute use ~/ to specify user home directory Note: files are only written when write_to_file is True of writeout is called explicitly Defaults to,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:109771,update,update,109771,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['update'],['update']
Deployability,"t is not a quantum operator'). S = Qobj(isherm=A.isherm, superrep='super'); S.dims = [[A.dims[0], A.dims[1]], [A.dims[0], A.dims[1]]]; S.data = zcsr_kron(A.data.T,; fast_identity(np.prod(A.shape[0]))); return S. [docs]def spre(A):; """"""Superoperator formed from pre-multiplication by operator A. Parameters; ----------; A : Qobj or QobjEvo; Quantum operator for pre-multiplication. Returns; --------; super :Qobj or QobjEvo; Superoperator formed from input quantum object.; """"""; if isinstance(A, QobjEvo):; return A.apply(spre). if not isinstance(A, Qobj):; raise TypeError('Input is not a quantum object'). if not A.isoper:; raise TypeError('Input is not a quantum operator'). S = Qobj(isherm=A.isherm, superrep='super'); S.dims = [[A.dims[0], A.dims[1]], [A.dims[0], A.dims[1]]]; S.data = zcsr_kron(fast_identity(np.prod(A.shape[1])), A.data); return S. def _drop_projected_dims(dims):; """"""; Eliminate subsystems that has been collapsed to only one state due to; a projection.; """"""; return [d for d in dims if d != 1]. [docs]def sprepost(A, B):; """"""Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters; ----------; A : Qobj or QobjEvo; Quantum operator for pre-multiplication. B : Qobj or QobjEvo; Quantum operator for post-multiplication. Returns; --------; super : Qobj or QobjEvo; Superoperator formed from input quantum objects.; """"""; if isinstance(A, QobjEvo) or isinstance(B, QobjEvo):; return spre(A) * spost(B). else:; dims = [[_drop_projected_dims(A.dims[0]),; _drop_projected_dims(B.dims[1])],; [_drop_projected_dims(A.dims[1]),; _drop_projected_dims(B.dims[0])]]; data = zcsr_kron(B.data.T, A.data); return Qobj(data, dims=dims, superrep='super'). from qutip.qobjevo import QobjEvo. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/superoperator.html:10563,update,updated,10563,docs/4.5/modules/qutip/superoperator.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/superoperator.html,1,['update'],['updated']
Deployability,"t stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way to install QuTiP in Ubuntu (14.04 and later) is to use the QuTiP PPA; sudo add-apt-repository ppa:jrjohansson/qutip-releases; sudo apt-get update; sudo apt-get install python-qutip. A Python 3 version is also available, and can be installed using:; sudo apt-get install python3-qutip. With this method the most important dependencies are installed automatically, and when a new version of QuTiP is released it can be upgraded through the standard package management system. In addition to the required dependencies, it is also strongly recommended that you install the texlive-latex-extra package:; sudo apt-get install texlive-latex-extra. Manual installation of dependencies¶; First install the required dependencies using:; sudo apt-get install python-dev cython python-setuptools python-nose; sudo apt-get install python-numpy python-scipy python-matplotlib. Then install QuTiP from source following the instructions given above.; Alternatively (or additionally), to install a Python 3 environment, use:; sudo apt-get install python3-dev cython python3-setuptools python3-nose; sudo apt-get install python3-numpy python3-scipy python3-matplotlib. and then do the installation from source using python3 instead of python.; Optiona",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:5051,install,installed,5051,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,2,['install'],"['install', 'installed']"
Deployability,"t stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way to install QuTiP in Ubuntu (14.04 and later) is to use the QuTiP PPA; sudo add-apt-repository ppa:jrjohansson/qutip-releases; sudo apt-get update; sudo apt-get install python-qutip. A Python 3 version is also available, and can be installed using:; sudo apt-get install python3-qutip. With this method the most important dependencies are installed automatically, and when a new version of QuTiP is released it can be upgraded through the standard package management system. In addition to the required dependencies, it is also strongly recommended that you install the texlive-latex-extra package:; sudo apt-get install texlive-latex-extra. Manual installation of dependencies¶; First install the required dependencies using:; sudo apt-get install python-dev cython python-setuptools python-nose; sudo apt-get install python-numpy python-scipy python-matplotlib. Then install QuTiP from source following the instructions given above.; Alternatively (or additionally), to install a Python 3 environment, use:; sudo apt-get install python3-dev cython3 python3-setuptools python3-nose; sudo apt-get install python3-numpy python3-scipy python3-matplotlib. and then do the installation from source using python3 instead of python.; Option",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:5140,install,installed,5140,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,2,['install'],"['install', 'installed']"
Deployability,"t the intial state""); else:; if shape_op[0] != l_vec or shape_op[1] != l_vec:; raise Exception(""The size of the e_ops does ""; ""not fit the intial state""). if sso.m_ops is not None:; for op in sso.m_ops:; shape_op = op.shape; if sso.me:; if shape_op[0]**2 != l_vec or shape_op[1]**2 != l_vec:; raise Exception(""The size of the m_ops does ""; ""not fit the intial state""); else:; if shape_op[0] != l_vec or shape_op[1] != l_vec:; raise Exception(""The size of the m_ops does ""; ""not fit the intial state""). def _sesolve_generic(sso, options, progress_bar):; """"""; Internal function. See smesolve.; """"""; data = Result(); data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), len(sso.times)), dtype=complex); data.ss = np.zeros((len(sso.e_ops), len(sso.times)), dtype=complex); data.measurement = []; data.solver = sso.solver_name; data.ntraj = sso.ntraj; data.num_expect = len(sso.e_ops). nt = sso.ntraj; task = _single_trajectory; map_kwargs = {'progress_bar': sso.progress_bar}; map_kwargs.update(sso.map_kwargs); task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs); noise = []; for result in results:; states_list, dW, m, expect = result; data.states.append(states_list); noise.append(dW); data.measurement.append(m); data.expect += expect; data.ss += expect * expect; data.noise = np.stack(noise). if sso.store_all_expect:; paths_expect = []; for result in results:; paths_expect.append(result[3]); data.runs_expect = np.stack(paths_expect). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[mm][n] for mm in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:40098,update,update,40098,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,1,['update'],['update']
Deployability,"t the qutip-<major>.<minor>.X branch on qutip/qutip you just created.; You can call this branch whatever you like because it is not going to the main repository, for example git checkout -b prepare-qutip-4.7.0. Change the VERSION file to contain the new version number exactly, removing the .dev suffix.; For example, if you are releasing the first release of the minor 4.7 track, set VERSION to contain the string 4.7.0.; (Special circumstances: if you are making an alpha, beta or release candidate release, append a .a<n>, .b<n> or .rc<n> to the version string, where <n> is an integer starting from 0 that counts how many of that pre-release track there have been.); Edit setup.cfg by changing the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes (git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""), and then push them to your fork (git push -u origin prepare-qutip-4.7.0). Using GitHub, make a pull request to the release branch (e.g. qutip-4.7.X) using this branch that you just created.; You will need to change the “base branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have changed, and should be; Development Status :: 2 - Pre-Alpha. because master is never directly released. You should now have a branch that you can see on the GitHub website that is called qutip-4.7.X (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; master should look pretty similar, except the VERSION will be higher and have a .dev suffi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:5619,release,release,5619,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['release'],['release']
Deployability,"t this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. .. note::. On using callback function: mesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. mesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : None / *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : None / :class:`qutip.Options`; with options for the solver. progress_bar : None / BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/mesolve.html:6882,integrat,integrator,6882,docs/4.5/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/mesolve.html,1,['integrat'],['integrator']
Deployability,"t this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. .. note::. On using callback function: mesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. mesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.Result`. An i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:7389,integrat,integrator,7389,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,3,['integrat'],['integrator']
Deployability,"t this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. .. note::. On using callback function: mesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. mesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the solver. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------. result: :class:`qutip.Result`. An in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:8305,integrat,integrator,8305,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,3,['integrat'],['integrator']
Deployability,"t to; ``False`` and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns; --------; eigs : tuple; Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. """"""; if not ops:; raise ValueError(""No input matrices.""); N = ops[0].shape[0]; num_ops = len(ops) if safe_mode else 0; for jj in range(num_ops):; A = ops[jj]; shape = A.shape; if shape[0] != shape[1]:; raise TypeError('Matricies must be square.'); if shape[0] != N:; raise TypeError('All matrices. must be the same shape'); if not A.isherm:; raise TypeError('Matricies must be Hermitian'); for kk in range(jj):; B = ops[kk]; if (A * B - B * A).norm() / (A * B).norm() > tol:; raise TypeError('Matricies must commute.'). eigvals, eigvecs = la.eigh(ops[0].full()); perm = np.argsort(eigvals); eigvecs = eigvecs[:, perm]; eigvals = eigvals[perm]. k = 0; while k < N:; # find degenerate eigenvalues, get indicies of degenerate eigvals; ttol = max(tol, tol * abs(eigvals[k])); inds, = np.where(abs(eigvals - eigvals[k]) < ttol); if len(inds) > 1: # if at least 2 eigvals are degenerate; eigvecs[:, inds] = _degen(tol, eigvecs[:, inds], ops, 1); k = inds[-1] + 1. for k in range(N):; eigvecs[:, k] = eigvecs[:, k] / la.norm(eigvecs[:, k]). kets_out = [; Qobj(eigvecs[:, j],; dims=[ops[0].dims[0], [1]], shape=[ops[0].shape[0], 1]); for j in range(N); ]; eigvals_out = np.zeros((len(ops), N), dtype=np.float64); if not evals:; return kets_out; else:; for kk in range(len(ops)):; for j in range(N):; eigvals_out[kk, j] = ops[kk].matrix_element(kets_out[j],; kets_out[j]).real; return eigvals_out, kets_out. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/simdiag.html:5563,update,updated,5563,docs/4.6/modules/qutip/simdiag.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/simdiag.html,2,['update'],['updated']
Deployability,"t type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-number> is the expected version number of the release. Make a pull request on the main qutip/qutip repository with this changelog, and get other members of the admin team to approve it.; Merge this into master. Now jump to release if you are making a major or minor release, or bugfix if you are only fixing bugs in a previous release. Create a New Minor or Major Release¶; This involves making a new branch to hold the release and adding some commits to set the code into “release” mode.; This release should be done by branching directly off the master branch at its current head. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; This should at least involve fetching the changelog PR that you just made.; Now create a new branch off a commit in master that has the state of the code you want to release.; The command is git checkout -b qutip-<major>.<minor>.X, for example qutip-4.7.X.; This branch name will be public, and must follow this format.; Push the new branch (with no commits in it relative to master) to the main qutip/qutip repository (git push upstream qutip-4.7.X).; Creating a branch is one of the only situations in which it is ok to push to qutip/qutip without making a pull request.; Create a second new branch, which will be pushed to your fork and used to make a pull request against the qutip-<major>.<minor>.X branch on qutip/qutip you just created.; You can call this branch whatever you like because it is not going to the main repository, for example git checkout -b prepare-qutip-4.7.0. Change the VERSION file to contain the new version number exactly, removing the .dev suffix.; For example, if you are releasing the first release of the minor 4.7 track, set VERSION to contain the string 4.7.0.; (Special circumstances: if ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:4099,release,release,4099,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['release'],['release']
Deployability,"t(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html:16922,integrat,integration,16922,docs/4.4/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html,3,['integrat'],['integration']
Deployability,"t(0.1) * a], [a.dag() * a, sm.dag() * sm], options=opts); 10.0%. Run time: 2.35s. Est. time left: 00:00:00:21; 20.0%. Run time: 4.75s. Est. time left: 00:00:00:18; 30.0%. Run time: 7.11s. Est. time left: 00:00:00:16; 40.0%. Run time: 9.34s. Est. time left: 00:00:00:14; 50.0%. Run time: 11.66s. Est. time left: 00:00:00:11; 60.0%. Run time: 15.27s. Est. time left: 00:00:00:10; 70.0%. Run time: 17.38s. Est. time left: 00:00:00:07; 80.0%. Run time: 19.55s. Est. time left: 00:00:00:04; 90.0%. Run time: 24.72s. Est. time left: 00:00:00:02; 100.0%. Run time: 30.86s. Est. time left: 00:00:00:00; Total run time: 30.92s. In [31]: figure(); Out[31]: <Figure size 640x480 with 0 Axes>. In [32]: plot(times, data1.expect[0], times, data1.expect[1], lw=2); Out[32]: ; [<matplotlib.lines.Line2D at 0x1a25b90080>,; <matplotlib.lines.Line2D at 0x1a25b905c0>]. In [33]: plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); Out[33]: ; [<matplotlib.lines.Line2D at 0x1a25c97d30>,; <matplotlib.lines.Line2D at 0x1a25c97128>]. In [34]: title('Monte Carlo time evolution'); Out[34]: Text(0.5,1,'Monte Carlo time evolution'). In [35]: xlabel('Time', fontsize=14); Out[35]: Text(0.5,0,'Time'). In [36]: ylabel('Expectation values', fontsize=14); Out[36]: Text(0,0.5,'Expectation values'). In [37]: legend((""cavity photon number"", ""atom excitation probability"")); Out[37]: <matplotlib.legend.Legend at 0x1a25cc3b70>. In [38]: show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-monte.html:15876,update,updated,15876,docs/4.5/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-monte.html,1,['update'],['updated']
Deployability,"t(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_scale - 1)*nrowin),; A.indptr)); elif insertrow > 0 and insertrow < row_scale - 1:; A.indptr = np.concatenate((np.array([0]*insertrow*nrowin), A.indptr,; np.array([A.indptr[-1]]*(row_scale - insertrow - 1)*nrowin))); else:; raise ValueError(""insertrow must be >= 0 and < row_scale""). return A. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/nonmarkov/heom.html:18694,update,updated,18694,docs/4.0.2/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/nonmarkov/heom.html,1,['update'],['updated']
Deployability,"t(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_scale - 1)*nrowin),; A.indptr)); elif insertrow > 0 and insertrow < row_scale - 1:; A.indptr = np.concatenate((np.array([0]*insertrow*nrowin), A.indptr,; np.array([A.indptr[-1]]*(row_scale - insertrow - 1)*nrowin))); else:; raise ValueError(""insertrow must be >= 0 and < row_scale""). return A. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html:18694,update,updated,18694,docs/4.2/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/heom.html,1,['update'],['updated']
Deployability,"t(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_scale - 1)*nrowin),; A.indptr)); elif insertrow > 0 and insertrow < row_scale - 1:; A.indptr = np.concatenate((np.array([0]*insertrow*nrowin), A.indptr,; np.array([A.indptr[-1]]*(row_scale - insertrow - 1)*nrowin))); else:; raise ValueError(""insertrow must be >= 0 and < row_scale""). return A. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html:18694,update,updated,18694,docs/4.1/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html,1,['update'],['updated']
Deployability,"t(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/fidcomp.html:22680,update,updated,22680,docs/4.7/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/fidcomp.html,2,['update'],['updated']
Deployability,"t(self.num_onwd_prop_step_computes)). def report(self):; """"""; Print a report of the stats to the console; """""". print(""\n------------------------------------""; ""\n---- Control optimisation stats ----""); self.report_timings(); self.report_func_calls(); self.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/stats.html:13937,update,update,13937,docs/4.1/modules/qutip/control/stats.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/stats.html,10,['update'],['update']
Deployability,"t(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); Out[31]: ; [<matplotlib.lines.Line2D at 0x1096d45d0>,; <matplotlib.lines.Line2D at 0x1096d47d0>]. In [32]: title('Monte Carlo time evolution'); Out[32]: <matplotlib.text.Text at 0x107db4790>. In [33]: xlabel('Time', fontsize=14); Out[33]: <matplotlib.text.Text at 0x1078fcd10>. In [34]: ylabel('Expectation values', fontsize=14); Out[34]: <matplotlib.text.Text at 0x107df7150>. In [35]: legend((""cavity photon number"", ""atom excitation probability"")); Out[35]: <matplotlib.legend.Legend at 0x107a31b90>. In [36]: show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has enhanced performance for systems with small Hilbert space dimensionality. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstration; In [37]: data1 = mcsolve_f90(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a list of trajectories to ntraj. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html:16534,install,installed,16534,docs/3.1.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html,1,['install'],['installed']
Deployability,"t):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:15804,integrat,integrate,15804,docs/4.7/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html,4,"['integrat', 'update']","['integrate', 'updated']"
Deployability,"t); f = open(os.path.join(dump.dump_dir, fname), 'wb'); closef = True; for dg in self.dyn_gen:; f.write(asbytes(""Evolution from {} to end\n"".format(k))); np.savetxt(f, self.fwd_evo[k], delimiter=dump.data_sep); k += 1; if closef: f.close(). # onto evolution; if not self.onto_evo is None:; k = 0; if fall:; f = fall; f.write(asbytes(""Onto evolution\n"")); else:; fname = ""{}-onto_evo.{}"".format(fnbase,; dump.dump_file_ext); f = open(os.path.join(dump.dump_dir, fname), 'wb'); closef = True; for dg in self.dyn_gen:; f.write(asbytes(""Evolution from {} onto target\n"".format(k))); np.savetxt(f, self.fwd_evo[k], delimiter=dump.data_sep); k += 1; if closef: f.close(). if closefall:; fall.close(). [docs]class DumpSummaryItem:; """"""; A summary of the most recent iteration. Abstract class only. Attributes; ----------; idx : int; Index in the summary list in which this is stored; """"""; min_col_width = 11; summary_property_names = (). summary_property_fmt_type = (). summary_property_fmt_prec = (). @classmethod; def get_header_line(cls, sep=' '):; if sep == ' ':; line = ''; i = 0; for a in cls.summary_property_names:; if i > 0:; line += sep; i += 1; line += format(a, str(max(len(a), cls.min_col_width)) + 's'); else:; line = sep.join(cls.summary_property_names); return line. def reset(self):; self.idx = 0. def get_value_line(self, sep=' '):; line = """"; i = 0; for a in zip(self.summary_property_names,; self.summary_property_fmt_type,; self.summary_property_fmt_prec):; if i > 0:; line += sep; i += 1; v = getattr(self, a[0]); w = max(len(a[0]), self.min_col_width); if v is not None:; fmt = ''; if sep == ' ':; fmt += str(w); else:; fmt += '0'; if a[2] > 0:; fmt += '.' + str(a[2]); fmt += a[1]; line += format(v, fmt); else:; if sep == ' ':; line += format('None', str(w) + 's'); else:; line += 'None'. return line. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/dump.html:24244,update,updated,24244,docs/4.7/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/dump.html,2,['update'],['updated']
Deployability,"t. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:14348,release,release,14348,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['release'],['release']
Deployability,"t. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:20677,integrat,integrate,20677,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,2,"['integrat', 'update']","['integrate', 'updated']"
Deployability,"t.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, sin(w*tlist)], [H1, sin(2*w*tlist)]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args). In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in super-operator for it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:H : qutip.Qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.Qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.Qobj. single collapse operator, or list of collapse operators. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with option",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:37765,integrat,integrator,37765,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['integrat'],['integrator']
Deployability,"t.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]). if opt.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if (not opt.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. # -----------------------------------------------------------------------------; # Old style API below.; # -----------------------------------------------------------------------------. # -----------------------------------------------------------------------------; # Master equation solver: deprecated in 2.0.0. No support for time-dependent; # collapse operators. Only used by the deprecated odesolve function.; #; def _mesolve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:29545,integrat,integrate,29545,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,4,['integrat'],['integrate']
Deployability,"t.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this comm",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:4968,install,installation,4968,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,8,['install'],['installation']
Deployability,"t; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/development.html:1247,release,release,1247,docs/4.6/development/development.html,https://qutip.org,https://qutip.org/docs/4.6/development/development.html,2,['release'],['release']
Deployability,"t=[[-5, 5], [-5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. update(state)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, input_states=None, output_states=None, reverse_states=True)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:; name : String; Gate name. start : Integer; Starting location of qubits. end : Integer; Last qubit for the gate. qubits : List; Specific qubits for applying gates. arg_value : Float; Argument value(phi). arg_label : String; Label for gate representation. add_circuit(qc, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:56972,update,update,56972,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['update'],['update']
Deployability,"t=[[-5, 5], [-5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. update(state)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, input_states=None, output_states=None, reverse_states=True)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:name : String. Gate name. start : Integer. Starting location of qubits. end : Integer. Last qubit for the gate. qubits : List. Specific qubits for applying gates. arg_value : Float. Argument value(phi). arg_label : String. Label for gate representation. add_circuit(qc, st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:48354,update,update,48354,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,1,['update'],['update']
Deployability,"t=[[-5, 5], [-5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. update(state)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_states=True)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:; name (String) – Gate name.; start (Integer) – Starting location of qubits.; end (Integer) – Last qubit for the gate.; qubits (List) – Specific qubits for applying gates.; arg_value (Float) – Argument value(phi).; arg_label (String) – Label for gate representation. add_circuit(qc, start=0)[source]¶; Adds a bl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:51653,update,update,51653,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['update'],['update']
Deployability,"t=[[-5, 5], [-5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. update(state)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_states=True)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:name : String. Gate name. start : Integer. Starting location of qubits. end : Integer. Last qubit for the gate. qubits : List. Specific qubits for applying gates. arg_value : Float. Argument value(phi). arg_label : String. Label for gate representation. add_circuit(qc, start=0)[source]¶; Adds a block of a qubi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/classes.html:48194,update,update,48194,docs/4.1/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/classes.html,1,['update'],['update']
Deployability,"t=pulse_dict); self.gate_compiler.update({; ""ISWAP"": self.iswap_compiler,; ""SQRTISWAP"": self.sqrtiswap_compiler,; ""RZ"": self.rz_compiler,; ""RX"": self.rx_compiler,; ""GLOBALPHASE"": self.globalphase_compiler; }); self.global_phase = global_phase. [docs] def rz_compiler(self, gate, args):; """"""; Compiler for the RZ gate; """"""; targets = gate.targets; g = self.params[""sz""][targets[0]]; coeff = np.sign(gate.arg_value) * g; tlist = abs(gate.arg_value) / (2 * g); pulse_info = [(""sz"" + str(targets[0]), coeff)]; return [Instruction(gate, tlist, pulse_info)]. [docs] def rx_compiler(self, gate, args):; """"""; Compiler for the RX gate; """"""; targets = gate.targets; g = self.params[""sx""][targets[0]]; coeff = np.sign(gate.arg_value) * g; tlist = abs(gate.arg_value) / (2 * g); pulse_info = [(""sx"" + str(targets[0]), coeff)]; return [Instruction(gate, tlist, pulse_info)]. [docs] def iswap_compiler(self, gate, args):; """"""; Compiler for the ISWAP gate; """"""; targets = gate.targets; q1, q2 = min(targets), max(targets); g = self.params[""sxsy""][q1]; coeff = -g; tlist = np.pi / (4 * g); if self.N != 2 and q1 == 0 and q2 == self.N - 1:; pulse_name = ""g"" + str(q2); else:; pulse_name = ""g"" + str(q1); pulse_info = [(pulse_name, coeff)]; return [Instruction(gate, tlist, pulse_info)]. [docs] def sqrtiswap_compiler(self, gate, args):; """"""; Compiler for the SQRTISWAP gate; """"""; targets = gate.targets; q1, q2 = min(targets), max(targets); g = self.params[""sxsy""][q1]; coeff = -g; tlist = np.pi / (8 * g); if self.N != 2 and q1 == 0 and q2 == self.N - 1:; pulse_name = ""g"" + str(q2); else:; pulse_name = ""g"" + str(q1); pulse_info = [(pulse_name, coeff)]; return [Instruction(gate, tlist, pulse_info)]. [docs] def globalphase_compiler(self, gate, args):; """"""; Compiler for the GLOBALPHASE gate; """"""; self.global_phase += gate.arg_value. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/spinchaincompiler.html:4079,update,updated,4079,docs/4.7/modules/qutip/qip/compiler/spinchaincompiler.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/spinchaincompiler.html,2,['update'],['updated']
Deployability,"t_coord_info = _get_coord_info_new. def _truncate_colormap(cmap, minval=0.0, maxval=1.0, n=100):; """"""; truncates portion of a colormap and returns the new one; """"""; if isinstance(cmap, str):; cmap = plt.get_cmap(cmap); new_cmap = mpl.colors.LinearSegmentedColormap.from_list(; 'trunc({n},{a:.2f},{b:.2f})'.format(; n=cmap.name, a=minval, b=maxval),; cmap(np.linspace(minval, maxval, n))); return new_cmap. def _stick_to_planes(stick, azim, ax, M, spacing):; """"""adjusts xlim and ylim in way that bars will; Stick to xz and yz planes; """"""; if stick is True:; azim = azim % 360; if 0 <= azim <= 90:; ax.set_ylim(1 - .5,); ax.set_xlim(1 - .5,); elif 90 < azim <= 180:; ax.set_ylim(1 - .5,); ax.set_xlim(0, M.shape[0] + (.5 - spacing)); elif 180 < azim <= 270:; ax.set_ylim(0, M.shape[1] + (.5 - spacing)); ax.set_xlim(0, M.shape[0] + (.5 - spacing)); elif 270 < azim < 360:; ax.set_ylim(0, M.shape[1] + (.5 - spacing)); ax.set_xlim(1 - .5,). def _update_yaxis(spacing, M, ax, ylabels):; """"""; updates the y-axis; """"""; ytics = [x + (1 - (spacing / 2)) for x in range(M.shape[1])]; if parse_version(mpl.__version__) >= parse_version(""3.8""):; ax.axes.yaxis.set_major_locator(plt.FixedLocator(ytics)); else:; ax.axes.w_yaxis.set_major_locator(plt.FixedLocator(ytics)); if ylabels:; nylabels = len(ylabels); if nylabels != len(ytics):; raise ValueError(f""got {nylabels} ylabels but needed {len(ytics)}""); ax.set_yticklabels(ylabels); else:; ax.set_yticklabels([str(y + 1) for y in range(M.shape[1])]); ax.set_yticklabels([str(i) for i in range(M.shape[1])]); ax.tick_params(axis='y', labelsize=14); ax.set_yticks([y + (1 - (spacing / 2)) for y in range(M.shape[1])]). def _update_xaxis(spacing, M, ax, xlabels):; """"""; updates the x-axis; """"""; xtics = [x + (1 - (spacing / 2)) for x in range(M.shape[1])]; if parse_version(mpl.__version__) >= parse_version(""3.8""):; ax.axes.xaxis.set_major_locator(plt.FixedLocator(xtics)); else:; ax.axes.w_xaxis.set_major_locator(plt.FixedLocator(xtics)). if xlabels:; nxlabel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/visualization.html:13446,update,updates,13446,docs/4.7/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html,2,['update'],['updates']
Deployability,"t_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; The underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:51691,configurat,configuration,51691,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['configurat'],['configuration']
Deployability,"t_pulses(; self, title=None, figsize=(12, 6), dpi=None,; show_axis=False, rescale_pulse_coeffs=True,; num_steps=1000):; """"""; Plot the ideal pulse coefficients. Parameters; ----------; title: str, optional; Title for the plot. figsize: tuple, optional; The size of the figure. dpi: int, optional; The dpi of the figure. show_axis: bool, optional; If the axis are shown. rescale_pulse_coeffs: bool, optional; Rescale the hight of each pulses. num_steps: int, optional; Number of time steps in the plot. Returns; -------; fig: matplotlib.figure.Figure; The `Figure` object for the plot. ax: matplotlib.axes._subplots.AxesSubplot; The axes for the plot. Notes; -----; ``plot_pulses`` only works for array_like coefficients; """"""; import matplotlib.pyplot as plt; import matplotlib.gridspec as gridspec; color_list = plt.rcParams['axes.prop_cycle'].by_key()['color']. # create a axis for each pulse; fig = plt.figure(figsize=figsize, dpi=dpi); grids = gridspec.GridSpec(len(self.pulses), 1); grids.update(wspace=0., hspace=0.). tlist = np.linspace(0., self.get_full_tlist()[-1], num_steps); dt = tlist[1] - tlist[0]. # make sure coeffs start and end with zero, for ax.fill; tlist = np.hstack(([-dt*1.e-20], tlist, [tlist[-1] + dt*1.e-20])); coeffs = []; for pulse in self.pulses:; coeffs.append(_pulse_interpolate(pulse, tlist)). pulse_ind = 0; axis = []; for i, label_group in enumerate(self.get_operators_labels()):; for j, label in enumerate(label_group):; grid = grids[pulse_ind]; ax = plt.subplot(grid); axis.append(ax); ax.fill(tlist, coeffs[pulse_ind], color_list[i], alpha=0.7); ax.plot(tlist, coeffs[pulse_ind], color_list[i]); if rescale_pulse_coeffs:; ymax = np.max(np.abs(coeffs[pulse_ind])) * 1.1; else:; ymax = np.max(np.abs(coeffs)) * 1.1; if ymax != 0.:; ax.set_ylim((-ymax, ymax)). # disable frame and ticks; if not show_axis:; ax.set_xticks([]); ax.spines['bottom'].set_visible(False); ax.spines['top'].set_visible(False); ax.spines['right'].set_visible(False); ax.spines['left'].set_visi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:23689,update,update,23689,docs/4.6/modules/qutip/qip/device/processor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html,4,['update'],['update']
Deployability,"ta). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:20213,integrat,integrate,20213,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['integrat'],['integrate']
Deployability,"tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On GitHub in the PR screen, you will need to change the “Base” branch to qutip-4.6.X (or whatever version), because GitHub will default to making it against master.; It should be quite clear if you have forgotten to do this, because there will probably be many merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and D",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:9930,release,release,9930,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['release'],['release']
Deployability,"tage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that your have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; Paul D. Nation & Robert J. Johansson. ('QuTiP Version: ', '3.0.1'); ('Numpy Version: ', '1.8.0'); ('Scipy Version: ', '0.13.3'); ('Cython Version: ', '0.20.1post0'); ('Matplotlib Version: ', '1.3.1'); ('Fortran mcsolver: ', 'True'); ('scikits.umfpack: ', 'False'); ('Python Version: ', '2.7.6'); ('Platform Info: ', 'Linux', '(x86_64)'); (). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:11971,install,installed,11971,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,3,"['install', 'update']","['installed', 'updated']"
Deployability,"tall all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:6409,install,installed,6409,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['install'],['installed']
Deployability,"tall python-dev cython python-setuptools python-nose; sudo apt-get install python-numpy python-scipy python-matplotlib. Then install QuTiP from source following the instructions given above.; Alternatively (or additionally), to install a Python 3 environment, use:; sudo apt-get install python3-dev cython python3-setuptools python3-nose; sudo apt-get install python3-numpy python3-scipy python3-matplotlib. and then do the installation from source using python3 instead of python.; Optional, but recommended, dependencies can be installed using:; sudo apt-get install texlive-latex-extra # recommended; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.6+)¶; If you have not done so already, install the Apple Xcode developer tools from the Apple App Store. After installation, open Xcode and go to: Preferences -> Downloads, and install the ‘Command Line Tools’. Setup Using Macports¶; On the Mac OS, we recommended that you install the required libraries via MacPorts. After installation, the necessary “ports” for QuTiP may be installed via; sudo port install py34-scipy; sudo port install py34-matplotlib +latex; sudo port install py34-cython; sudo port install py34-ipython +notebook+parallel. Optional, but highly recommended ports include; sudo port install vtk5 +python27 #used for the Bloch3d class; sudo port install py27-mayavi #used for the Bloch3d class. Now, we want to tell OSX which Python and iPython we are going to use; sudo port select python python34; sudo port select ipython ipython34. To install QuTiP from Macports, run; sudo port install py-qutip. Finally, we want to set the macports compiler to the vanilla GCC version. From the command line type:; port select gcc. which will bring up a list of installed compilers, such as:; Available versions for gcc:; mp-gcc48; none (active). W",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:6517,install,installation,6517,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,2,['install'],"['install', 'installation']"
Deployability,"tall python-dev cython python-setuptools python-nose; sudo apt-get install python-numpy python-scipy python-matplotlib. Then install QuTiP from source following the instructions given above.; Alternatively (or additionally), to install a Python 3 environment, use:; sudo apt-get install python3-dev cython python3-setuptools python3-nose; sudo apt-get install python3-numpy python3-scipy python3-matplotlib. and then do the installation from source using python3 instead of python.; Optional, but recommended, dependencies can be installed using:; sudo apt-get install texlive-latex-extra # recommended; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.6+)¶; If you have not done so already, install the Apple Xcode developer tools from the Apple App Store. After installation, open Xcode and go to: Preferences -> Downloads, and install the ‘Command Line Tools’. Setup Using Macports¶; On the Mac OS, we recommended that you install the required libraries via MacPorts. After installation, the necessary “ports” for QuTiP may be installed via; sudo port install py34-scipy; sudo port install py34-matplotlib +latex; sudo port install py34-cython; sudo port install py34-ipython +notebook+parallel. Optional, but highly recommended ports include; sudo port install vtk5 +python27 #used for the Bloch3d class; sudo port install py27-mayavi #used for the Bloch3d class. Now, we want to tell OSX which Python and iPython we are going to use; sudo port select python python34; sudo port select ipython ipython34. To install QuTiP from Macports, run; sudo port install py-qutip. Note; The next step is optional, but is necessary if you plan to use the string (Cython) based time-dependent format. See Solving Problems with Time-dependent Hamiltonians. Finally, we want to set the macports compiler to the vanilla GC",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:6195,install,installation,6195,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,2,['install'],"['install', 'installation']"
Deployability,"tallation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Python Module Index. q.  . q. qutip.    ; qutip.bloch_redfield.    ; qutip.continuous_variables.    ; qutip.correlation.    ; qutip.entropy.    ; qutip.essolve.    ; qutip.expect.    ; qutip.fileio.    ; qutip.floquet.    ; qutip.fortran.mcsolve_f90.    ; qutip.graph.    ; qutip.ipynbtools.    ; qutip.mcsolve.    ; qutip.mesolve.    ; qutip.metrics.    ; qutip.operators.    ; qutip.partial_transpose.    ; qutip.propagator.    ; qutip.qip.algorithms.qft.    ; qutip.qip.gates.    ; qutip.qip.qubits.    ; qutip.random_objects.    ; qutip.sesolve.    ; qutip.states.    ; qutip.steadystate.    ; qutip.stochastic.    ; qutip.superop_reps.    ; qutip.superoperator.    ; qutip.tensor.    ; qutip.three_level_atom.    ; qutip.tomography.    ; qutip.utilities.    ; qutip.visualization.    ; qutip.wigner. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/py-modindex.html:2304,update,updated,2304,docs/3.0.0/py-modindex.html,https://qutip.org,https://qutip.org/docs/3.0.0/py-modindex.html,1,['update'],['updated']
Deployability,"tance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:18597,configurat,configuration,18597,docs/4.3/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html,7,['configurat'],['configuration']
Deployability,"targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CNOT"", targets=[1], controls=0); qc.add_measurement(""M0"", targets=[0], classical_store=0); qc.add_measurement(""M0"", targets=[1], classical_store=0); qc.add_measurement(""M0"", targets=[2], classical_store=0); sim = CircuitSimulator(qc, mode=""density_matrix_simulator""); print(sim.run(zero_state).get_final_states()[0]). Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0.33333257 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0.33333257 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0.33333486 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]]. We are left with a mixed state. Import and export quantum circuits¶; QuTiP supports importation and exportation of quantum circuit in the OpenQASM 2 format; through the functions read_qasm and save_qasm.; We demonstrate this using the w-state generation circuit.; The following code is in OpenQASM format:; // Name of Experiment: W-state v1. OPENQASM 2.0;; include ""qelib1.inc"";. qreg q[4];; creg c[3];; gate cH a,b {; h b;; sdg b;; cx a,b;; h b;; t b;; cx a,b;; t b;; h b;; s b;; x b;; s a;; }. u3(1.91063,0,0) q[0];; cH q[0],q[1];; ccx q[0],q[1],q[2];; x q[0];; x q[1];; cx q[0],q[1];. measure q[0] -> c[0];; measure q[1] -> c[1];; measure q[2] -> c[2];. One can save it in a .qasm file and import it using the following code:; from qutip.qip.qasm import read_qasm; qc = read_qasm(""guide/qip/w-state.qasm""). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-simulator.html:10263,update,updated,10263,docs/4.6/guide/qip/qip-simulator.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-simulator.html,2,['update'],['updated']
Deployability,"tate or oper; #; if psi0.isket:; initial_vector = psi0.full().ravel(); oper_evo = False; elif psi0.isunitary:; initial_vector = psi0.full().ravel('F'); oper_evo = True; else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L = -1j * h; L_list.append([L.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; if oper_evo:; initial_vector = psi0.full().ravel('F'); if opt.rhs_with_state:; r = scipy.integrate.ode(oper_list_td_with_state); else:; r = scipy.integrate.ode(oper_list_td); else:; initial_vector = psi0.full().ravel(); if opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td_with_state); else:; r = scipy.integrate.ode(psi_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, L_List_and_args):. L_List = L_List_and_args[0]; args = L_List_and_args[1]. L = L_List[0][0]; tdfunc = L_List[0][1]; out = np.zeros(psi.shape[0],dtype=complex); spmvpy_csr(L.data, L.indices, L.indptr, psi, tdfunc(t, args), out); f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:8339,integrat,integrate,8339,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['integrat'],['integrate']
Deployability,"tate],; dtype=complex); else:; raise TypeError('Arguments must be quantum objects or eseries'). def _single_qobj_expect(oper, state):; """"""; Private function used by expect to calculate expectation values of Qobjs.; """"""; if isoper(oper):; if oper.dims[1] != state.dims[0]:; raise Exception('Operator and state do not have same tensor ' +; 'structure: %s and %s' %; (oper.dims[1], state.dims[0])). if state.type == 'oper':; # calculates expectation value via TR(op*rho); return cy_spmm_tr(oper.data, state.data,; oper.isherm and state.isherm). elif state.type == 'ket':; # calculates expectation value via <psi|op|psi>; return expect_csr_ket(oper.data, state.data,; oper.isherm); else:; raise TypeError('Invalid operand types'). def _single_eseries_expect(oper, state):; """"""; Private function used by expect to calculate expectation values for; eseries.; """""". out = eseries(). if isoper(state.ampl[0]):; out.rates = state.rates; out.ampl = np.array([expect(oper, a) for a in state.ampl]). else:; out.rates = np.array([]); out.ampl = np.array([]). for m in range(len(state.rates)):; op_m = state.ampl[m].data.conj().T * oper.data. for n in range(len(state.rates)):; a = op_m * state.ampl[n].data. if isinstance(a, sp.spmatrix):; a = a.todense(). out.rates = np.append(out.rates, state.rates[n] -; state.rates[m]); out.ampl = np.append(out.ampl, a). return out. [docs]def variance(oper, state):; """"""; Variance of an operator for the given state vector or density matrix. Parameters; ----------; oper : qobj; Operator for expectation value. state : qobj/list; A single or `list` of quantum states or density matrices.. Returns; -------; var : float; Variance of operator 'oper' for given state. """"""; return expect(oper ** 2, state) - expect(oper, state) ** 2. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/expect.html:5619,update,updated,5619,docs/4.4/modules/qutip/expect.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/expect.html,1,['update'],['updated']
Deployability,"tates and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Time Evolution and Quantum System Dynamics. « Using Tensor Pro... Dynamics Simulat... ». Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Setting Options for the Dynamics Solvers. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-dynamics.html:2557,update,updated,2557,docs/3.1.0/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-dynamics.html,1,['update'],['updated']
Deployability,"tates:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html:8192,update,updated,8192,docs/4.5/modules/qutip/nonmarkov/transfertensor.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/nonmarkov/transfertensor.html,1,['update'],['updated']
Deployability,"tation values:; >>> plot(times, expt0, times, expt1); >>> show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_result.times; plot(times, expt0, times, expt1); show(). Also see Saving QuTiP Objects and Data Sets for more information on saving quantum objects, as well as arrays for use in other programs. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-data.html:6617,update,updated,6617,docs/4.5/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-data.html,1,['update'],['updated']
Deployability,"tations that attempts to maximize the product; of the ABS values of the diagonal elements in a nonsingular square CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular. This function looks at both the structure and ABS values of the underlying; matrix. Parameters; ----------; A : csc_matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutation to generate. Returns; -------; perm : array; Array of row or column permutations. Notes; -----; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method. References; ----------; I. S. Duff and J. Koster, ""The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices"", SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997).; """"""; _deprecate(); nrows = A.shape[0]; if A.shape[0] != A.shape[1]:; raise ValueError('weighted_bfs_matching requires a square matrix.'); if sp.isspmatrix_csr(A) or sp.isspmatrix_coo(A):; A = A.tocsc(); elif not sp.isspmatrix_csc(A):; raise TypeError(""matrix must be in CSC, CSR, or COO format.""). if perm_type == 'column':; A = A.transpose().tocsc(); perm = _weighted_bipartite_matching(; np.asarray(np.abs(A.data), dtype=float),; A.indices, A.indptr, nrows); if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'); return perm. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/graph.html:7931,update,updated,7931,docs/4.7/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/graph.html,2,['update'],['updated']
Deployability,"tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(_cy_rhs_func); ODE.set_f_params(config.h_data, config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:24652,integrat,integrate,24652,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['integrat'],['integrate']
Deployability,"te Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; pip install qutip. Or, optionally, to also include the Fortran-based Monte Carlo solver:; pip install qutip --install-option=--with-f90mc. More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:3808,install,installation,3808,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['install'],['installation']
Deployability,"te expectation values. options : :class:`qutip.Qdeoptions`; Options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); for t_idx, _ in enumerate(tlist):. if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). return result_list. # -----------------------------------------------------------------------------; # Functions for ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/bloch_redfield.html:6214,integrat,integrate,6214,docs/4.0.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/bloch_redfield.html,2,['integrat'],['integrate']
Deployability,"te their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:11612,install,installation,11612,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,4,['install'],['installation']
Deployability,"te):; self.funclist = funclist; self.args = args; self.dynamics_args = dynamics_args; self.dims = cte.dims; self.shape = cte.shape. def set_args(self, args, dynamics_args):; self.args = args; self.dynamics_args = dynamics_args. def dyn_args(self, t, state, shape):; # 1d array are to F ordered; mat = state.reshape(shape, order=""F""); for name, what, op in self.dynamics_args:; if what == ""vec"":; self.args[name] = state; elif what == ""mat"":; self.args[name] = mat; elif what == ""Qobj"":; if self.shape[1] == shape[1]: # oper; self.args[name] = Qobj(mat, dims=self.dims); elif shape[1] == 1: # ket; self.args[name] = Qobj(mat, dims=[self.dims[1], [1]]); else: # rho; self.args[name] = Qobj(mat, dims=self.dims[1]); elif what == ""expect"":; if shape[1] == op.cte.shape[1]: # same shape as object; self.args[name] = op.mul_mat(t, mat).trace(); else:; self.args[name] = op.expect(t, state). def __call__(self, t, args={}):; if args:; now_args = self.args.copy(); now_args.update(args); else:; now_args = self.args; out = []; for func in self.funclist:; out.append(func(t, now_args)); return out. def get_args(self):; return self.args. class _Norm2():; def __init__(self, f):; self.func = f. def __call__(self, t, args):; return self.func(t, args)*np.conj(self.func(t, args)). class _Shift():; def __init__(self, f):; self.func = f. def __call__(self, t, args):; return np.conj(self.func(t + args[""_t0""], args)). class _Conj():; def __init__(self, f):; self.func = f. def __call__(self, t, args):; return np.conj(self.func(t, args)). class _Prod():; def __init__(self, f, g):; self.func_1 = f; self.func_2 = g. def __call__(self, t, args):; return self.func_1(t, args)*self.func_2(t, args). class _Add():; def __init__(self, fs):; self.funcs = fs. def __call__(self, t, args):; return np.sum([f(t, args) for f in self.funcs]). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:50393,update,updated,50393,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,2,['update'],['updated']
Deployability,"te],; dtype=complex); else:; raise TypeError('Arguments must be quantum objects or eseries'). def _single_qobj_expect(oper, state):; """"""; Private function used by expect to calculate expectation values of Qobjs.; """"""; if isoper(oper):; if oper.dims[1] != state.dims[0]:; raise Exception('Operator and state do not have same tensor ' +; 'structure: %s and %s' %; (oper.dims[1], state.dims[0])). if state.type == 'oper':; # calculates expectation value via TR(op*rho); return cy_spmm_tr(oper.data, state.data,; oper.isherm and state.isherm). elif state.type == 'ket':; # calculates expectation value via <psi|op|psi>; return expect_csr_ket(oper.data, state.data,; oper.isherm); else:; raise TypeError('Invalid operand types'). def _single_eseries_expect(oper, state):; """"""; Private function used by expect to calculate expectation values for; eseries.; """""". out = eseries(). if isoper(state.ampl[0]):; out.rates = state.rates; out.ampl = np.array([expect(oper, a) for a in state.ampl]). else:; out.rates = np.array([]); out.ampl = np.array([]). for m in range(len(state.rates)):; op_m = state.ampl[m].data.conj().T * oper.data. for n in range(len(state.rates)):; a = op_m * state.ampl[n].data. if isinstance(a, sp.spmatrix):; a = a.todense(). out.rates = np.append(out.rates, state.rates[n] -; state.rates[m]); out.ampl = np.append(out.ampl, a). return out. [docs]def variance(oper, state):; """"""; Variance of an operator for the given state vector or density matrix. Parameters; ----------; oper : qobj; Operator for expectation value. state : qobj/list; A single or `list` of quantum states or density matrices.. Returns; -------; var : float; Variance of operator 'oper' for given state. """"""; return expect(oper ** 2, state) - expect(oper, state) ** 2. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/expect.html:5632,update,updated,5632,docs/4.5/modules/qutip/expect.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/expect.html,1,['update'],['updated']
Deployability,"ted during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-control.html:17555,configurat,configuration,17555,docs/4.5/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-control.html,2,"['configurat', 'update']","['configuration', 'updated']"
Deployability,"ted with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html:4323,configurat,configuration,4323,docs/4.1/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html,10,['configurat'],['configuration']
Deployability,"tems. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Kha05. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/biblio.html:3750,update,updated,3750,docs/4.4/biblio.html,https://qutip.org,https://qutip.org/docs/4.4/biblio.html,1,['update'],['updated']
Deployability,"tensor(basis(2, 1), basis(2, 1)); elif state == '01':; Bell_state = tensor(; basis(2), basis(2))-tensor(basis(2, 1), basis(2, 1)); elif state == '10':; Bell_state = tensor(; basis(2), basis(2, 1))+tensor(basis(2, 1), basis(2)); elif state == '11':; Bell_state = tensor(; basis(2), basis(2, 1))-tensor(basis(2, 1), basis(2)). return Bell_state.unit(). [docs]def singlet_state():; """"""; Returns the two particle singlet-state:. |S>=1/sqrt(2)*[|0>|1>-|1>|0>]. that is identical to the fourth bell state. Returns; -------; Bell_state : qobj; |B11> Bell state. """"""; return bell_state('11'). def triplet_states():; """"""; Returns the two particle triplet-states:. |T>= |1>|1>; = 1 / sqrt(2)*[|0>|1>-|1>|0>]; = |0>|0>; that is identical to the fourth bell state. Returns; -------; trip_states : list; 2 particle triplet states. """"""; trip_states = []; trip_states.append(tensor(basis(2, 1), basis(2, 1))); trip_states.append(; (tensor(basis(2), basis(2, 1)) + tensor(basis(2, 1), basis(2))).unit(); ); trip_states.append(tensor(basis(2), basis(2))); return trip_states. def w_state(N=3):; """"""; Returns the N-qubit W-state. Parameters; ----------; N : int (default=3); Number of qubits in state. Returns; -------; W : qobj; N-qubit W-state. """"""; inds = np.zeros(N, dtype=int); inds[0] = 1; state = tensor([basis(2, x) for x in inds]); for kk in range(1, N):; perm_inds = np.roll(inds, kk); state += tensor([basis(2, x) for x in perm_inds]); return state.unit(). [docs]def ghz_state(N=3):; """"""; Returns the N-qubit GHZ-state. Parameters; ----------; N : int (default=3); Number of qubits in state. Returns; -------; G : qobj; N-qubit GHZ-state. """"""; state = (tensor([basis(2) for k in range(N)]) +; tensor([basis(2, 1) for k in range(N)])); return state/np.sqrt(2). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/states.html:31264,update,updated,31264,docs/4.5/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/states.html,1,['update'],['updated']
Deployability,"terials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['qubit_states']. from qutip.tensor import tensor; from numpy import sqrt; from qutip.states import basis. [docs]def qubit_states(N=1, states=[0]):; """"""; Function to define initial state of the qubits. Parameters; ----------; N : Integer; Number of qubits in the register.; states : List; Initial state of each qubit. Returns; ----------; qstates : Qobj; List of qubits. """"""; state_list = []; for i in range(N):; if N > len(states) and i >= len(states):; state_list.append(0); else:; state_list.append(states[i]). return tensor([alpha * basis(2, 1) + sqrt(1 - alpha**2) * basis(2, 0); for alpha in state_list]). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qip/qubits.html:2837,update,updated,2837,docs/4.4/modules/qutip/qip/qubits.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qip/qubits.html,1,['update'],['updated']
Deployability,"test release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:3057,release,release,3057,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['release'],['release']
Deployability,"test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modif",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:10015,install,install,10015,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,2,['install'],['install']
Deployability,"tetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video controls src=""data:video/x-m4v;base64,{0}"">'.format(; video_encoded); return HTML(video_tag). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/ipynbtools.html:11978,update,update,11978,docs/4.5/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/ipynbtools.html,3,['update'],"['update', 'updated']"
Deployability,"th:`t`. c_op_list : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. Returns; -------; output :array; Expectation values of wavefunctions/density matrices; for the times specified by `tlist`. Notes; -----; On using callback function: odesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. odesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator to scipy who will raise an NotImplemented; exception. Deprecated in QuTiP 2.0.0. Use :func:`mesolve` instead. """""". warnings.warn(""odesolve is deprecated since 2.0.0. Use mesolve instead."",; DeprecationWarning). if debug:; print(inspect.stack()[0][3]). if options is None:; options = Options(). if (c_op_list and len(c_op_list) > 0) or not isket(rho0):; if isinstance(H, list):; output = _mesolve_list_td(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); if isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; output = _mesolve_func_td(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); else:; output = _mesolve_const(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); else:; if isinstance(H, list):; output = _sesolve_list_td(H, rho0, tlist, e_ops, args, options,; BaseProgressBar()); if isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; output = _sesolve_func_td(H, rho0, tlis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:35434,integrat,integrator,35434,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['integrat'],['integrator']
Deployability,"that point in time. `args` is a list of parameters that is; passed to the callback function `H` (only used for time-dependent; Hamiltonians). Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. Returns; -------; output :array; Expectation values of wavefunctions/density matrices; for the times specified by `tlist`. Notes; -----; On using callback function: odesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. odesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator to scipy who will raise an NotImplemented; exception. Deprecated in QuTiP 2.0.0. Use :func:`mesolve` instead. """""". warnings.warn(""odesolve is deprecated since 2.0.0. Use mesolve instead."",; DeprecationWarning). if debug:; print(inspect.stack()[0][3]). if options is None:; options = Options(). if (c_op_list and len(c_op_list) > 0) or not isket(rho0):; if isinstance(H, list):; output = _mesolve_list_td(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); if isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; output = _mesolve_func_td(H, rho0, tlist,; c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:35065,integrat,integrator,35065,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['integrat'],['integrator']
Deployability,"that same ket is returned and evaluated at 'e_ops', if provided.; """""". if len(tlist) == 0:; warnings.warn(; ""Input 'tlist' contains a single element. If 'e_ops' were provided""; "", return its corresponding expectation values at 'psi0', else ""; ""return 'psi0'.""; ). progress_bar.start(1). res, expt_callback, options, n_expt_op = _e_ops_outputs(; res, e_ops, n_tlist_steps, options; ). if options.store_states:; res.states = [psi0]. e_0 = None; if expt_callback:; # use callback method; e_0 = e_ops(0, psi0); res.expect.append(e_0). e_m_0 = []; for m in range(n_expt_op):; op = e_ops[m]. if not isinstance(op, Qobj) and callable(op):; e_m_0.append(op(0, psi0)); res.expect[m][0] = e_m_0[m]; continue. e_m_0.append(expect(op, psi0)); res.expect[m][0] = e_m_0[m]. if happy_breakdown:; res = _happy_breakdown(; tlist,; options,; res,; psi0,; expt_callback,; e_0,; n_expt_op,; e_ops,; e_m_0,; ). if (options.store_final_state) and (not options.store_states):; res.states = [psi0]. progress_bar.update(1); progress_bar.finished(); return res. def _happy_breakdown(; tlist, options, res, psi0, expt_callback, e_0, n_expt_op, e_ops, e_m_0; ):; """"""; Dummy evolves the system if a happy breakdown of an eigenstate occurs.; """"""; for i in range(1, len(tlist)):; if options.store_states:; res.states.append(psi0); if expt_callback:; res.expect.append(e_0). for m in range(n_expt_op):; op = e_ops[m]; res.expect[m][i] = e_m_0[m]; return res. def _optimize_lanczos_timestep_size(T, krylov_basis, tlist, options):; """"""; Solves the equation defined to optimize the number of Lanczos; iterations to be performed inside Krylov's algorithm.; """""". f = _lanczos_error_equation_to_optimize_delta_t(; T,; krylov_basis=krylov_basis,; t0=tlist[0],; tf=tlist[-1],; target_tolerance=options.atol,; ). # To avoid the singularity at t0, we add a small epsilon value; t_min = (tlist[-1] - tlist[0]) / options.nsteps + tlist[0]; bracket = [t_min, tlist[-1]]. if (np.sign(f(bracket[0])) == -1) and (np.sign(f(bracket[-1])) == -1):; de",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:13655,update,update,13655,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,2,['update'],['update']
Deployability,"that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns; --------; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. """""". html = ""<table>""; html += ""<tr><th>Software</th><th>Version</th></tr>"". packages = [(""QuTiP"", qutip.__version__),; (""Numpy"", numpy.__version__),; (""SciPy"", scipy.__version__),; (""matplotlib"", matplotlib.__version__),; (""Cython"", Cython.__version__),; (""Number of CPUs"", available_cpu_count()),; (""BLAS Info"", _blas_info()),; (""IPython"", IPython.__version__),; (""Python"", sys.version),; (""OS"", ""%s [%s]"" % (os.name, sys.platform)); ]. for name, version in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, version). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></tr>""; qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); html += (""<tr><td>Installation path</td><td>%s</td></tr>"" %; qutip_install_path); try:; import getpass; html += (""<tr><td>User</td><td>%s</td></tr>"" %; getpass.getuser()); except:; pass. html += ""<tr><td colspan='2'>%s</td></tr>"" % time.strftime(; '%a %b %d %H:%M:%S %Y %Z'); html += ""</table>"". return HTML(html). class HTMLProgressBar(BaseProgressBar):; """"""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(n); compute_with_n(n); """""". def __init__(self, iterations=0, chunk_size=1.0):; self.divid = str(uuid.uuid4()); self.textid = str(uuid.uuid4()); self.pb = HTML(""""""\; <div style=""border: 2px solid grey; width: 600px"">; <div id=""%s"" \; style=""background-color: rgba(121,195,106,0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html:4356,Install,Installation,4356,docs/4.6/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/ipynbtools.html,2,['Install'],['Installation']
Deployability,"the ABS values of the diagonal elements in; a nonsingular square CSC sparse matrix. Such a permutation is; always possible provided that the matrix is nonsingular. This function looks at both the structure and ABS values of the; underlying matrix. Parameters; ----------; A : csc_matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutation to generate. Returns; -------; perm : array; Array of row or column permutations. Notes; -----; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and; are traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method. References; ----------; I. S. Duff and J. Koster, ""The design and use of algorithms for; permuting large entries to the diagonal of sparse matrices"", SIAM J.; Matrix Anal. and Applics. 20, no. 4, 889 (1997). """""". nrows = A.shape[0]; if A.shape[0] != A.shape[1]:; raise ValueError('weighted_bfs_matching requires a square matrix.'). if sp.isspmatrix_csr(A) or sp.isspmatrix_coo(A):; A = A.tocsc(); elif not sp.isspmatrix_csc(A):; raise TypeError(""matrix must be in CSC, CSR, or COO format.""). if perm_type == 'column':; A = A.transpose().tocsc(). perm = _weighted_bipartite_matching(; np.asarray(np.abs(A.data), dtype=float),; A.indices, A.indptr, nrows). if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'). return perm. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/graph.html:9474,update,updated,9474,docs/4.4/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/graph.html,1,['update'],['updated']
Deployability,"the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-basics.html:1819,install,installation,1819,docs/3.0.1/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-basics.html,1,['install'],['installation']
Deployability,"the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing; Changelog Generation. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; Solver data layer integration; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. Completed Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; QIP migration; HEOM revamp. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Changelog; Create a New Minor or Major Release; Create a Bug Fix Release. Build Release Distribution and Deploy; Build and Deploy; Download Built Files; Monitoring Progress (optional). Getting the Built Documentation; Making a Release on GitHub; Website; Copying New Files; HTML File Updates. Conda Forge. Next ; Previous. © Copyrigh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/development.html:1326,release,release,1326,docs/4.7/development/development.html,https://qutip.org,https://qutip.org/docs/4.7/development/development.html,2,['release'],['release']
Deployability,"the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes (git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""), and then push them to your fork (git push -u origin prepare-qutip-4.7.0). Using GitHub, make a pull request to the release branch (e.g. qutip-4.7.X) using this branch that you just created.; You will need to change the “base branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have changed, and should be; Development Status :: 2 - Pre-Alpha. because master is never directly released. You should now have a branch that you can see on the GitHub website that is called qutip-4.7.X (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull requests to the release branch to fix it.; master should look pretty similar, except the VERSION will be higher and have a .dev suffix, and the “Development Status” in setup.cfg will be different.; You are now ready to actually perform the release.; Go to deploy. Create a Bug Fix Release¶; In this you will modify an already-released branch by “cherry-picking” one or more pull requests that have been merged to master (including your new changelog), and bump the “patch” part of the version number. On your machine, make sure your copy of master is up-to-date (git checkout master; git pull upstream master).; In particular, make sure the changelog you wrote in the first step is visible.; Find the branch of the release that you will be modifying.; This should already exist on the qutip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:6371,release,release,6371,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,4,['release'],['release']
Deployability,"the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,; ax : matplotlib Axes instance; If given, render the visualization using this axis instance.; figsize : tuple; Size of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style : string; Type of visualization: ‘colormap’ (default) or ‘surface’. Returns:fig, ax : tuple. A tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)¶; Methods. update(state)¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)¶; Methods. update(psi)¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)¶; Methods. update(rho)¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_states=True)¶; Representation of a quantum p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:33184,update,update,33184,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,2,['update'],['update']
Deployability,"the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. kmax : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). # time steps for integration of coupling operator; nT = int(np.max([20 * kmax, 100])); dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, nT + 1), H, T,; args). for t in tlist:; # TODO: repeated invocations of floquet_modes_t is; # inefficient... make a and b outer loops and use the mesolve; # instead of the propagator. f_modes_t = np.hstack([f.full() for f in floquet_modes_t_lookup(; f_modes_table_t, t, T)]); FF = f_modes_t.T.conj() @ c_op.full() @ f_modes_t; phi = exp(-1j * np.arange(-kmax, kmax+1) * omega * t); X += (dT / T) * np.einsum(""ij,k->ijk"", FF, phi). Heaviside = lambda x: ((np.sign(x) + 1) / 2.0); for a in range(N):; for b in range(N):; k_idx = 0; for k in range(-kmax, kmax + 1, 1):; Delta[a, b, k_idx] = f_energies[a] - f_energies[b] + k * omega; Gamma[a, b, k_idx] = 2 * pi * Heaviside(Delta[a, b, k_idx]) * \; J_cb(Delta[a, b, k_idx]) * abs(X[a, b, k_idx]) ** 2; k_idx += 1. for a in range(N):; fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:15724,integrat,integration,15724,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['integrat'],['integration']
Deployability,"the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶. The level of data dumping that will occur during the optimisation; NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:78751,update,update,78751,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['update'],['update']
Deployability,"the real and imaginary parts, so instead we could use the numtype=”real” option:; In [26]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [27]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.2109553666,0.3689771549,0.0185002867; 1.0101010101,2.6754598872,0.1298251132,-0.3303672956; 2.0202020202,2.2743186810,-0.2106241300,-0.2623894277; 3.0303030303,1.9726633457,-0.3037311621,0.0397330921. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [28]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [29]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,3.2109553666e+00,3.6897715490e-01,1.8500286728e-02; 1.0101010101e+00,2.6754598872e+00,1.2982511320e-01,-3.3036729565e-01; 2.0202020202e+00,2.2743186810e+00,-2.1062412999e-01,-2.6238942773e-01; 3.0303030303e+00,1.9726633457e+00,-3.0373116210e-01,3.9733092145e-02. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [30]: input_data = file_data_read('expect.dat'). In [31]: shape(input_data); Out[31]: (100, 4). In [32]: plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-saving.html:8950,update,updated,8950,docs/4.5/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-saving.html,1,['update'],['updated']
Deployability,"the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing.; MAJOR FEATURE: Added a photon scattering module (by Ben Bartlett) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides.; Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed.; Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors.; Computing Q.overlap() [inner product] is now ~30x faster.; Added projector method to Qobj class.; Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/changelog.html:2446,install,installed,2446,docs/4.3/changelog.html,https://qutip.org,https://qutip.org/docs/4.3/changelog.html,5,['install'],['installed']
Deployability,"the system.; targets : int or list of int; The indices of qubits that are acted on.; dims : list, optional; A list of integer for the dimension of each composite system.; E.g ``[2, 2, 2, 2, 2]`` for 5 qubits system. If None, qubits system; will be the default option.; cyclic_permutation : boolean, optional; Expand for all cyclic permutation of the targets.; E.g. if ``N=3`` and `oper` is a 2-qubit operator,; the result will be a list of three operators,; each acting on qubits 0 and 1, 1 and 2, 2 and 0. Returns; -------; expanded_oper : :class:`qutip.Qobj`; The expanded qubits operator acting on a system with N qubits. Notes; -----; This is equivalent to gate_expand_1toN, gate_expand_2toN,; gate_expand_3toN in ``qutip.qip.gate.py``, but works for any dimension.; """"""; if dims is None:; dims = [2] * N; targets = _targets_to_list(targets, oper=oper, N=N); _check_qubits_oper(oper, dims=dims, targets=targets). # Call expand_operator for all cyclic permutation of the targets.; if cyclic_permutation:; oper_list = []; for i in range(N):; new_targets = np.mod(np.array(targets)+i, N); oper_list.append(; expand_operator(oper, N=N, targets=new_targets, dims=dims)); return oper_list. # Generate the correct order for qubits permutation,; # eg. if N = 5, targets = [3,0], the order is [1,2,3,0,4].; # If the operator is cnot,; # this order means that the 3rd qubit controls the 0th qubit.; new_order = [0] * N; for i, t in enumerate(targets):; new_order[t] = i; # allocate the rest qutbits (not targets) to the empty; # position in new_order; rest_pos = [q for q in list(range(N)) if q not in targets]; rest_qubits = list(range(len(targets), N)); for i, ind in enumerate(rest_pos):; new_order[ind] = rest_qubits[i]; id_list = [identity(dims[i]) for i in rest_pos]; return tensor([oper] + id_list).permute(new_order). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/operations/gates.html:40540,update,updated,40540,docs/4.7/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/operations/gates.html,2,['update'],['updated']
Deployability,"the time array is as follows:; import numpy as np; from qutip import sigmaz; from qutip.qip.device import Processor. processor = Processor(2); processor.add_control(sigmaz(), cyclic_permutation=True) # sigmaz for all qubits; processor.pulses[0].coeffs = np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); processor.pulses[0].tlist = np.array([0.1, 0.2, 0.4, 0.5]). It defines a \(\sigma_z\) operator on both qubits and a pulse that acts on the first qubit.; An equivalent approach is using the add_pulse method.; from qutip.qip.pulse import Pulse. processor = Processor(2); coeff=np.array([0.1, 0.2, 0.4, 0.5]); tlist=np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); pulse = Pulse(sigmaz(), targets=0, coeff=coeff, tlist=tlist); processor.add_pulse(pulse). One can also use choose the pulse_mode attribute of Processor; between ""discrete"" and ""continuous"". Note; If the coefficients represent dicrete pulse, the length of each array is 1 element shorter than tlist. If it is supposed to be a continuous function, the length should be the same as tlist. The above example shows the framework and the most essential part of the simulator’s API. So far, it looks like just a wrapper for the open system solvers. However, based on this, we can implement different physical realizations. They differ mainly in how to find the control pulse for a quantum circuit, which gives birth to different sub-classes:. Processor; ├── ModelProcessor; │ ├── DispersiveCavityQED; │ └── SpinChain; └── OptPulseProcessor. In general, there are two ways to find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED mode",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:3306,continuous,continuous,3306,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,4,['continuous'],['continuous']
Deployability,"the two parameters and the third is the index of the; occupied bands. The fourth dimension holds the eigenfunctions. Returns; -------; b_curv : numpy ndarray; A two dimensional array of the discretized Berry curvature defined for; the values of the two parameters defined in the eigfs.; """"""; nparam0 = eigfs.shape[0]; nparam1 = eigfs.shape[1]; nocc = eigfs.shape[2]; b_curv = np.zeros((nparam0-1, nparam1-1), dtype=float). for i in range(nparam0-1):; for j in range(nparam1-1):; rect_prd = np.identity(nocc, dtype=complex); innP0 = np.zeros([nocc, nocc], dtype=complex); innP1 = np.zeros([nocc, nocc], dtype=complex); innP2 = np.zeros([nocc, nocc], dtype=complex); innP3 = np.zeros([nocc, nocc], dtype=complex). for k in range(nocc):; for l in range(nocc):; wf0 = eigfs[i, j, k, :]; wf1 = eigfs[i+1, j, l, :]; innP0[k, l] = np.dot(wf0.conjugate(), wf1). wf1 = eigfs[i+1, j, k, :]; wf2 = eigfs[i+1, j+1, l, :]; innP1[k, l] = np.dot(wf1.conjugate(), wf2). wf2 = eigfs[i+1, j+1, k, :]; wf3 = eigfs[i, j+1, l, :]; innP2[k, l] = np.dot(wf2.conjugate(), wf3). wf3 = eigfs[i, j+1, k, :]; wf0 = eigfs[i, j, l, :]; innP3[k, l] = np.dot(wf3.conjugate(), wf0). rect_prd = np.dot(rect_prd, innP0); rect_prd = np.dot(rect_prd, innP1); rect_prd = np.dot(rect_prd, innP2); rect_prd = np.dot(rect_prd, innP3). dett = np.linalg.det(rect_prd); curl_z = np.angle(dett); b_curv[i, j] = curl_z. return b_curv. [docs]def plot_berry_curvature(eigfs):; """"""Plots the discretized Berry curvature on the two dimensional grid; of parameters. The function works well for cases with no band mixing.""""""; b_curv = berry_curvature(eigfs); fig, ax = plt.subplots(); ax.imshow(b_curv, origin=""lower""); ax.set_title(""Berry curvature""); ax.set_xlabel(r""$Parameter0$""); ax.set_ylabel(r""$Parameter1$""); fig.tight_layout(); fig.savefig(""berry_curvature.pdf""). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/topology.html:2773,update,updated,2773,docs/4.7/modules/qutip/topology.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/topology.html,2,['update'],['updated']
Deployability,"the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:79423,integrat,integration,79423,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['integrat'],['integration']
Deployability,"they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html:8099,update,update,8099,docs/4.1/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html,9,['update'],['update']
Deployability,"this case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=”real” option:; In [26]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [27]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,4.6283109309,-0.7139985949,-1.9302925449; 1.0101010101,3.7394716905,-1.5795745709,-0.2887283809; 2.0202020202,3.0806355195,-0.8933912070,1.0022231476; 3.0303030303,2.5873637218,0.3268461698,1.0991113962. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [28]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [29]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,4.6283109309e+00,-7.1399859487e-01,-1.9302925449e+00; 1.0101010101e+00,3.7394716905e+00,-1.5795745709e+00,-2.8872838088e-01; 2.0202020202e+00,3.0806355195e+00,-8.9339120701e-01,1.0022231476e+00; 3.0303030303e+00,2.5873637218e+00,3.2684616978e-01,1.0991113962e+00. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [30]: input_data = file_data_read('expect.dat'). In [31]: shape(input_data); Out[31]: (100, 4). In [32]: plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-saving.html:8897,update,updated,8897,docs/4.2/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-saving.html,1,['update'],['updated']
Deployability,"this case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=”real” option:; In [27]: file_data_store('expect.dat', output_data.T, numtype=""real""). In [28]: !head -n5 expect.dat; # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,5.6885201844,1.8969583115,-0.7610878745; 1.0101010101,4.4922228586,0.1636458173,-1.6411357401; 2.0202020202,3.6464536329,-1.1039557484,-0.8507373294; 3.0303030303,3.0175130081,-1.1224844139,0.4154688442. and if we prefer scientific notation we can request that using the numformat=”exp” option; In [29]: file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). In [30]: !head -n 5 expect.dat; # Generated by QuTiP: 100x4 real matrix in exp format [',' separated values].; 0.0000000000e+00,5.6885201844e+00,1.8969583115e+00,-7.6108787447e-01; 1.0101010101e+00,4.4922228586e+00,1.6364581733e-01,-1.6411357401e+00; 2.0202020202e+00,3.6464536329e+00,-1.1039557484e+00,-8.5073732939e-01; 3.0303030303e+00,3.0175130081e+00,-1.1224844139e+00,4.1546884424e-01. Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; In [31]: input_data = file_data_read('expect.dat'). In [32]: shape(input_data); Out[32]: (100, 4). In [33]: from pylab import *. In [34]: plot(input_data[:,0], input_data[:,1]); # plot the data; Out[34]: [<matplotlib.lines.Line2D at 0x2b1237fcc7d0>]. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=”_” if _ is the deliminator). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-saving.html:9642,update,updated,9642,docs/3.0.1/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-saving.html,1,['update'],['updated']
Deployability,"this example, the a_ops list would be:; In [33]: a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; In [34]: N = 10. In [35]: w0 = 1.0 * 2 * np.pi. In [36]: g = 0.05 * w0. In [37]: kappa = 0.15. In [38]: times = np.linspace(0, 25, 1000). In [39]: a = destroy(N). In [40]: H = w0 * a.dag() * a + g * (a + a.dag()). In [41]: psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). In [42]: a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. In [43]: e_ops = [a.dag() * a, a + a.dag()]. In [44]: res_brme = brmesolve(H, psi0, times, a_ops, e_ops). In [45]: plt.figure(); Out[45]: <Figure size 640x480 with 0 Axes>. In [46]: plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:19973,update,updated,19973,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,1,['update'],['updated']
Deployability,"this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list / callback function, optional; A list of operators as `Qobj` and/or callable functions (can be mixed); or a single callable function. For operators, the result's expect will; be computed by :func:`qutip.expect`. For callable functions, they are; called as ``f(t, state)`` and return the expectation value.; A single callback's expectation value can be any type, but a callback; part of a list must return a number as the expectation value. args : None / *dictionary*; dictio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/mesolve.html:5117,integrat,integrator,5117,docs/4.7/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html,2,['integrat'],['integrator']
Deployability,"this way, and the `store_states` and; `store_final_state` options can be used to store states even though; expectation values are requested via the `e_ops` argument. .. note::. If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. .. note::. On using callback functions: mesolve transforms all :class:`qutip.Qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.Qobj` objects that are used in constructing the; Hamiltonian via `args`. mesolve will check for :class:`qutip.Qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.Qobj` objects that are not passed via `args` will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : None / list of :class:`qutip.Qobj`; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : None / list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : None / *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : None / :class:`qutip.Options`; with options for the solver. progress_bar : None / BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mesolve.html:6852,integrat,integrator,6852,docs/4.6/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html,2,['integrat'],['integrator']
Deployability,"thon 2.7 on Windows. The ‘MS Visual C for Python 2.7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/installation.html:8353,install,installing,8353,docs/4.2/installation.html,https://qutip.org,https://qutip.org/docs/4.2/installation.html,6,"['install', 'update']","['installation', 'installed', 'installing', 'updated']"
Deployability,"thon 2.7 on Windows. The ‘MS Visual C for Python 2.7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:8253,install,installing,8253,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,6,"['install', 'update']","['installation', 'installed', 'installing', 'updated']"
Deployability,"thon programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/frontmatter.html:4636,release,release,4636,docs/4.0.2/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.0.2/frontmatter.html,2,"['release', 'update']","['release', 'updated']"
Deployability,"thon programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/frontmatter.html:4639,release,release,4639,docs/4.1/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.1/frontmatter.html,2,"['release', 'update']","['release', 'updated']"
Deployability,"thon setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way to install QuTiP in Ubuntu (14.04 and later) is to use the QuTiP PPA; sudo add-apt-repository ppa:jrjohansson/qutip-releases; sudo apt-get update; sudo apt-get install python-qutip. A Python 3 version is also available, and can be installed using:; sudo apt-get install python3-qutip. With this method the most important dependencies are installed automatically, and when a new version of QuTiP is released it can be upgraded through the standard package management system. In addition to the required dependencies, it is also strongly recommended that you install the texlive-latex-extra package:; sudo apt-get install texlive-latex-extra. Manual installation of dependencies¶; First install the required dependencies using:; sudo apt-get install python-dev cython python-setuptools python-nose; sudo apt-get install python-numpy python-scipy python-matplotlib. Then install QuTiP from source following the instructions given above.; Alternatively (or additionally), to install a Python 3 environment, use:; sudo apt-get install python3-dev cython python3-setuptools python3-nose; sudo apt-get install python3-numpy python3-scipy python3-matplotlib. and then do the installation from source using python3 instead of python.; Optional, but recommended, dependencies can be installed using:; sudo apt-get install texlive-latex-extra # recommended; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.6+)¶; If you have not done so already, install the Apple Xcode developer tools from the Apple App Store. After installation, open Xcode and go to: Preferences -> Dow",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:5468,install,installation,5468,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,4,['install'],"['install', 'installation']"
Deployability,"thon setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way to install QuTiP in Ubuntu (14.04 and later) is to use the QuTiP PPA; sudo add-apt-repository ppa:jrjohansson/qutip-releases; sudo apt-get update; sudo apt-get install python-qutip. A Python 3 version is also available, and can be installed using:; sudo apt-get install python3-qutip. With this method the most important dependencies are installed automatically, and when a new version of QuTiP is released it can be upgraded through the standard package management system. In addition to the required dependencies, it is also strongly recommended that you install the texlive-latex-extra package:; sudo apt-get install texlive-latex-extra. Manual installation of dependencies¶; First install the required dependencies using:; sudo apt-get install python-dev cython python-setuptools python-nose; sudo apt-get install python-numpy python-scipy python-matplotlib. Then install QuTiP from source following the instructions given above.; Alternatively (or additionally), to install a Python 3 environment, use:; sudo apt-get install python3-dev cython3 python3-setuptools python3-nose; sudo apt-get install python3-numpy python3-scipy python3-matplotlib. and then do the installation from source using python3 instead of python.; Optional, but recommended, dependencies can be installed using:; sudo apt-get install texlive-latex-extra # recommended for plotting; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install liblapack-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.8+)¶. Setup Using Homebrew¶; The latest version of QuTiP can be quickly ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:5557,install,installation,5557,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,4,['install'],"['install', 'installation']"
Deployability,"thon; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dyn",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-basics.html:1102,install,installation,1102,docs/4.5/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-basics.html,1,['install'],['installation']
Deployability,"thon; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing; Changelog Generation. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; Solver data layer integration; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. Completed Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; QIP migration; HEOM revamp. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Changelog; Create a New Minor or Major Release; Create a Bug Fix Release. Build Relea",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/development.html:1033,integrat,integration,1033,docs/4.7/development/development.html,https://qutip.org,https://qutip.org/docs/4.7/development/development.html,2,['integrat'],['integration']
Deployability,"those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and z",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:11539,release,release,11539,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['release'],['release']
Deployability,"those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and z",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:17326,release,release,17326,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['release'],['release']
Deployability,"ticSolverOptions attribute). (TTMSolverOptions attribute). TimeslotComputer (class in qutip.control.tslotcomp). to_choi() (in module qutip.superop_reps). to_kraus() (in module qutip.superop_reps). to_super() (in module qutip.superop_reps). toffoli() (in module qutip.qip.gates). total_time (Stats attribute). tr() (Qobj method), [1]. tracedist() (in module qutip.metrics). trans() (Qobj method), [1]. transform() (Qobj method), [1]. trunc_neg() (Qobj method), [1]. tslot_computer (Dynamics attribute). TSlotCompUpdateAll (class in qutip.control.tslotcomp). ttmsolve() (in module qutip.nonmarkov.transfertensor). TTMSolverOptions (class in qutip.nonmarkov.transfertensor). tunneling() (in module qutip.operators). TwoModeQuadratureCorrelation (class in qutip.distributions). type (Qobj attribute). U. ubound (PulseGen attribute). unit() (Qobj method), [1]. unitarity_check() (Dynamics method). unitarity_check_level (Dynamics attribute). unitarity_tol (Dynamics attribute). update() (HarmonicOscillatorProbabilityFunction method). (HarmonicOscillatorWaveFunction method). (TwoModeQuadratureCorrelation method). update_ctrl_amps() (Dynamics method). update_fid_err_log() (OptimDump method). update_grad_log() (OptimDump method). update_grad_norm_log() (OptimDump method). update_psi() (TwoModeQuadratureCorrelation method). update_rho() (TwoModeQuadratureCorrelation method). uses_onto_evo (FidelityComputer attribute). uses_onwd_evo (FidelityComputer attribute). V. value() (eseries method), [1]. variance() (in module qutip.expect). vector_color (Bloch attribute). (Bloch3d attribute). vector_mutation (Bloch attribute), [1]. vector_style (Bloch attribute), [1]. vector_to_operator() (in module qutip.superoperator). vector_width (Bloch attribute), [1]. (Bloch3d attribute). version_table() (in module qutip.ipynbtools). view (Bloch attribute). (Bloch3d attribute). visualize() (Distribution method). W. wall_time (OptimIterSummary attribute). (OptimResult attribute). wall_time_dyn_gen_compute (Stats",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/genindex.html:31060,update,update,31060,docs/4.0.2/genindex.html,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html,1,['update'],['update']
Deployability,"tically equal to zero. The number of nonzero elements is called the density and can be controlled by calling any of the random state/operator generators with a second argument between 0 and 1. By default, the density for the operators is 0.75 where as ket vectors are completely dense (1). For example:; In [4]: rand_dm(5, 0.5); Out[4]: ; Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = True; Qobj data =; [[ 0.16777653+0.j 0.00000000+0.j 0.00000000+0.j; 0.00000000+0.j 0.00000000+0.j ]; [ 0.00000000+0.j 0.48109101+0.j 0.07516889-0.09787062j; 0.15916938-0.11843809j 0.00000000+0.j ]; [ 0.00000000+0.j 0.07516889+0.09787062j 0.05114957+0.j; 0.07911797+0.02241975j 0.00000000+0.j ]; [ 0.00000000+0.j 0.15916938+0.11843809j 0.07911797-0.02241975j; 0.13220636+0.j 0.00000000+0.j ]; [ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j; 0.00000000+0.j 0.16777653+0.j ]]. has rougly half nonzero elements, or equivalently a density of 0.5. Important; In the case of a density matrix, setting the density too low will result in not enough diagonal elements to satisfy \(Tr(\rho)=1\). Composite random objects¶; In many cases, one is interested in generating random quantum objects that correspond to composite systems generated using the qutip.tensor.tensor function. Specifying the tensor structure of a quantum object is done using the dims keyword argument in the same fashion as one would do for a qutip.Qobj object:; In [5]: rand_dm(4, 0.5, dims=[[2,2], [2,2]]); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j; 0.00000000+0.j ]; [ 0.00000000+0.j 0.10052169+0.j 0.00000000+0.j; 0.28287538-0.01714619j]; [ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j; 0.00000000+0.j ]; [ 0.00000000+0.j 0.28287538+0.01714619j 0.00000000+0.j; 0.89947831+0.j ]]. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-random.html:5180,update,updated,5180,docs/3.0.1/guide/guide-random.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-random.html,1,['update'],['updated']
Deployability,"tifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly rele",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:4256,release,release,4256,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,4,['release'],['release']
Deployability,"tim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:17561,configurat,configuration,17561,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,5,['configurat'],['configuration']
Deployability,"time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks listed above. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [9]. It has since been restructured and extended for flexibility and compatibility within QuTiP. Merging the GRAPE implementations is part of the near future plans. An implementation of the ‘dressed’ CRAB algorithm is also planned for the near future.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:13513,integrat,integrated,13513,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['integrat'],['integrated']
Deployability,"ting QuTiP. Improvements¶. Added a “Citing QuTiP” section to the README, containing a link to the QuTiP papers. (#1554); Added entropy_relative which returns the quantum relative entropy between two density matrices. (#1553). Bug Fixes¶. Fixed Bloch sphere distortion when using Matplotlib >= 3.3.0. (#1496); Removed use of integer-like floats in math.factorial since it is deprecated as of Python 3.9. (#1550); Simplified call to ffmpeg used in the the Bloch sphere animation tutorial to work with recent versions of ffmpeg. (#1557); Removed blitting in Bloch sphere FuncAnimation example. (#1558); Added a version checking condition to handle specific functionalities depending on the matplotlib version. (#1556); Fixed mesolve handling of time-dependent Hamiltonian with a custom tlist and c_ops. (#1561). Developer Changes¶. Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021)¶; This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4.; It also adds the [full] pip install target so that pip install qutip[full]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:10301,release,release,10301,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,4,"['install', 'release']","['installed', 'release']"
Deployability,"ting States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-dynamics.html:2134,update,updated,2134,docs/4.1/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-dynamics.html,1,['update'],['updated']
Deployability,"ting an operator in the Kraus decomposition of the given map. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to Kraus representation. If; ``q_oper`` is ``type=""oper""``, then it is taken to act by conjugation,; such that ``to_kraus(A) == to_kraus(sprepost(A, A.dag())) == [A]``. tol : Float; Optional threshold parameter for eigenvalues/Kraus ops to be discarded.; The default is to=1e-9. Returns; -------; kraus_ops : list of Qobj; A list of quantum objects, each representing a Kraus operator in the; decomposition of ``q_oper``. Raises; ------; TypeError: if the given quantum object is not a map, or cannot be; decomposed into Kraus operators.; """"""; if q_oper.type == 'super':; if q_oper.superrep in (""super"", ""chi""):; return to_kraus(to_choi(q_oper), tol); elif q_oper.superrep == 'choi':; return choi_to_kraus(q_oper, tol); elif q_oper.type == 'oper': # Assume unitary; return [q_oper]; else:; raise TypeError(; ""Conversion of Qobj with type = {0.type} ""; ""and superrep = {0.superrep} to Kraus decomposition not ""; ""supported."".format(q_oper); ). [docs]def to_stinespring(q_oper):; r""""""; Converts a Qobj representing a quantum map $\Lambda$ to a pair of partial isometries; $A$ and $B$ such that $\Lambda(X) = \Tr_2(A X B^\dagger)$ for all inputs $X$, where; the partial trace is taken over a a new index on the output dimensions of $A$ and $B$. For completely positive inputs, $A$ will always equal $B$ up to precision errors. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to a Stinespring pair. Returns; -------; A, B : Qobj; Quantum objects representing each of the Stinespring matrices for the input Qobj.; """"""; return choi_to_stinespring(to_choi(q_oper)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:19107,update,updated,19107,docs/4.6/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html,2,['update'],['updated']
Deployability,"ting function.; ; Habermann & Kindermann, ""Multidimensional Spline Interpolation: ; Theory and Applications"", Comput Econ 30, 153 (2007). ; ; '''; ; def __init__(self, a, b, y, alpha=0, beta=0):; y = np.asarray(y); n = y.shape[0] - 1; h = (b - a)/n. coeff = np.zeros(n + 3, dtype=y.dtype); # Solutions to boundary coeffcients of spline; coeff[1] = 1/6. * (y[0] - (alpha * h**2)/6) #C2 in paper; coeff[n + 1] = 1/6. * (y[n] - (beta * h**2)/6) #cn+2 in paper. # Compressed tridiagonal matrix ; ab = np.ones((3, n - 1), dtype=float); ab[0,0] = 0 # Because top row is upper diag with one less elem; ab[1, :] = 4; ab[-1,-1] = 0 # Because bottom row is lower diag with one less elem; ; B = y[1:-1].copy() #grabs elements y[1] - > y[n-2] for reduced array; B[0] -= coeff[1]; B[-1] -= coeff[n + 1]. coeff[2:-2] = la.solve_banded((1, 1), ab, B, overwrite_ab=True, ; overwrite_b=True, check_finite=False). coeff[0] = alpha * h**2/6. + 2 * coeff[1] - coeff[2]; coeff[-1] = beta * h**2/6. + 2 * coeff[-2] - coeff[-3]. self.a = a # Lower-bound of domain; self.b = b # Uppser-bound of domain; self.coeffs = coeff # Spline coefficients; self.is_complex = (y.dtype == complex) #Tells which dtype solver to use; ; def __call__(self, pnts, *args):; #If requesting a single return value; if isinstance(pnts, (int, float, complex)):; if self.is_complex:; return zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return interp(pnts, self.a, self.b, self.coeffs); #If requesting multiple return values from array_like; elif isinstance(pnts, (np.ndarray,list)):; pnts = np.asarray(pnts); if self.is_complex:; return arr_zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return arr_interp(pnts, self.a, self.b, self.coeffs); ; . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/interpolate.html:4890,update,updated,4890,docs/4.6/modules/qutip/interpolate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/interpolate.html,2,['update'],['updated']
Deployability,"ting the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/frontmatter.html:4540,release,release,4540,docs/4.5/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.5/frontmatter.html,2,"['release', 'update']","['release', 'updated']"
Deployability,"tion uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:224861,configurat,configuration,224861,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['configurat'],['configuration']
Deployability,"tion uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If No",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:105591,configurat,configuration,105591,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['configurat'],['configuration']
Deployability,"tion. Returns; -------; Q, THETA, PHI : 2d-array; Values representing the spin Q function at the values specified; by THETA and PHI. """""". if rho.type == 'bra':; rho = rho.dag(). if rho.type == 'ket':; rho = ket2dm(rho). J = rho.shape[0]; j = int((J - 1) / 2). THETA, PHI = meshgrid(theta, phi). Q = np.zeros_like(THETA, dtype=complex). for m1 in range(-j, j+1):. Q += binom(2*j, j+m1) * cos(THETA/2) ** (2*(j-m1)) * sin(THETA/2) ** (2*(j+m1)) * \; rho.data[int(j-m1), int(j-m1)]. for m2 in range(m1+1, j+1):. Q += (sqrt(binom(2*j, j+m1)) * sqrt(binom(2*j, j+m2)) *; cos(THETA/2) ** (2*j-m1-m2) * sin(THETA/2) ** (2*j+m1+m2)) * \; (exp(1j * (m2-m1) * PHI) * rho.data[int(j-m1), int(j-m2)] +; exp(1j * (m1-m2) * PHI) * rho.data[int(j-m2), int(j-m1)]). return Q.real, THETA, PHI. def _rho_kq(rho, j, k, q):; v = 0j. for m1 in range(-j, j+1):; for m2 in range(-j, j+1):; v += (-1)**(j - m1 - q) * clebsch(j, j, k, m1, -m2,; q) * rho.data[m1 + j, m2 + j]. return v. [docs]def spin_wigner(rho, theta, phi):; """"""Wigner function for spins on the Bloch sphere. Parameters; ----------; state : qobj; A state vector or density matrix for a spin-j quantum system.; theta : array_like; theta-coordinates at which to calculate the Q function.; phi : array_like; phi-coordinates at which to calculate the Q function. Returns; -------; W, THETA, PHI : 2d-array; Values representing the spin Wigner function at the values specified; by THETA and PHI. Notes; -----; Experimental. """""". if rho.type == 'bra':; rho = rho.dag(). if rho.type == 'ket':; rho = ket2dm(rho). J = rho.shape[0]; j = int((J - 1) / 2). THETA, PHI = meshgrid(theta, phi). W = np.zeros_like(THETA, dtype=complex). for k in range(int(2 * j)+1):; for q in range(-k, k+1):; W += _rho_kq(rho, j, k, q) * sph_harm(q, k, PHI, THETA). return W, THETA, PHI. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/wigner.html:16492,update,updated,16492,docs/4.2/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/wigner.html,1,['update'],['updated']
Deployability,"tion; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:2606,release,release,2606,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['release'],['release']
Deployability,"tion_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_names = (; ""idx"", ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""fid_err"", ""grad_norm"", ""wall_time""; ). summary_property_fmt_type = (; 'd', 'd', 'd', 'd',; 'g', 'g', 'g'; ). summary_property_fmt_prec = (; 0, 0, 0, 0,; 4, 4, 2; ). def __init__(self):; self.reset(). def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.fid_err = None; self.grad_norm = None; self.wall_time = 0.0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html:41204,update,updated,41204,docs/4.0.2/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/optimizer.html,1,['update'],['updated']
Deployability,"tion_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_names = (; ""idx"", ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""fid_err"", ""grad_norm"", ""wall_time""; ). summary_property_fmt_type = (; 'd', 'd', 'd', 'd',; 'g', 'g', 'g'; ). summary_property_fmt_prec = (; 0, 0, 0, 0,; 4, 4, 2; ). def __init__(self):; self.reset(). def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.fid_err = None; self.grad_norm = None; self.wall_time = 0.0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html:41204,update,updated,41204,docs/4.2/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/optimizer.html,1,['update'],['updated']
Deployability,"tion_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_names = (; ""idx"", ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""fid_err"", ""grad_norm"", ""wall_time""; ). summary_property_fmt_type = (; 'd', 'd', 'd', 'd',; 'g', 'g', 'g'; ). summary_property_fmt_prec = (; 0, 0, 0, 0,; 4, 4, 2; ). def __init__(self):; self.reset(). def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.fid_err = None; self.grad_norm = None; self.wall_time = 0.0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:41204,update,updated,41204,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,1,['update'],['updated']
Deployability,"tions for the ODE solver. Returns; -------; output :array; Expectation values of wavefunctions/density matrices; for the times specified by `tlist`. Notes; -----; On using callback function: odesolve transforms all :class:`qutip.qobj`; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all :class:`qutip.qobj` objects that are used in constructing the; Hamiltonian via args. odesolve will check for :class:`qutip.qobj` in; `args` and handle the conversion to sparse matrices. All other; :class:`qutip.qobj` objects that are not passed via `args` will be; passed on to the integrator to scipy who will raise an NotImplemented; exception. Deprecated in QuTiP 2.0.0. Use :func:`mesolve` instead. """""". warnings.warn(""odesolve is deprecated since 2.0.0. Use mesolve instead."",; DeprecationWarning). if debug:; print(inspect.stack()[0][3]). if options is None:; options = Options(). if (c_op_list and len(c_op_list) > 0) or not isket(rho0):; if isinstance(H, list):; output = _mesolve_list_td(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); if isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; output = _mesolve_func_td(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); else:; output = _mesolve_const(H, rho0, tlist,; c_op_list, e_ops, args, options,; BaseProgressBar()); else:; if isinstance(H, list):; output = _sesolve_list_td(H, rho0, tlist, e_ops, args, options,; BaseProgressBar()); if isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; output = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; BaseProgressBar()); else:; output = _sesolve_const(H, rho0, tlist, e_ops, args, options,; BaseProgressBar()). if len(e_ops) > 0:; return output.expect; else:; return output.states. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:33485,update,updated,33485,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['update'],['updated']
Deployability,"tions that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from qutip.tensor import tensor. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/operators.html:22080,update,updated,22080,docs/4.3/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/operators.html,1,['update'],['updated']
Deployability,"tions, optionalOptions for the ODE solver. progress_barBaseProgressBar, optionalOptional instance of BaseProgressBar, or a subclass thereof,; for showing the progress of the simulation. Returns. output: ResultAn instance of the class Result, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the times in tlist (if; e_ops is an empty list), or nothing if a callback function was; given inplace of operators for which to calculate the expectation; values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the sec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:77089,integrat,integrating,77089,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['integrat'],['integrating']
Deployability,"tions,; _safe_mode=False); for k, t in enumerate(tlist):; u[:, n, k] = mat2vec(output.states[k].full()).T; progress_bar.finished(). if len(tlist) == 2:; if unitary_mode == 'batch':; return Qobj(u[-1], dims=dims); else:; return Qobj(u[:, :, 1], dims=dims); else:; if unitary_mode == 'batch':; return np.array([Qobj(u[k], dims=dims); for k in range(len(tlist))], dtype=object); else:; return np.array([Qobj(u[:, :, k], dims=dims); for k in range(len(tlist))], dtype=object). def _get_min_and_index(lst):; """"""; Private function for obtaining min and max indicies.; """"""; minval, minidx = lst[0], 0; for i, v in enumerate(lst[1:]):; if v < minval:; minval, minidx = v, i + 1; return minval, minidx. [docs]def propagator_steadystate(U):; """"""Find the steady state for successive applications of the propagator; :math:`U`. Parameters; ----------; U : qobj; Operator representing the propagator. Returns; -------; a : qobj; Instance representing the steady-state density matrix. """""". evals, evecs = la.eig(U.full()). shifted_vals = np.abs(evals - 1.0); ev_idx = np.argmin(shifted_vals); ev_min = shifted_vals[ev_idx]; evecs = evecs.T; rho = Qobj(vec2mat(evecs[ev_idx]), dims=U.dims[0]); rho = rho * (1.0 / rho.tr()); rho = 0.5 * (rho + rho.dag()) # make sure rho is herm; rho.isherm = True; return rho. def _parallel_sesolve(n, N, H, tlist, args, options):; psi0 = basis(N, n); output = sesolve(H, psi0, tlist, [], args, options, _safe_mode=False); return output. def _parallel_mesolve(n, N, H, tlist, c_op_list, args, options):; col_idx, row_idx = np.unravel_index(n, (N, N)); rho0 = Qobj(sp.csr_matrix(([1], ([row_idx], [col_idx])),; shape=(N,N), dtype=complex)); output = mesolve(H, rho0, tlist, c_op_list, [], args, options,; _safe_mode=False); return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/propagator.html:10175,update,updated,10175,docs/4.4/modules/qutip/propagator.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/propagator.html,1,['update'],['updated']
Deployability,"tions.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/frontmatter.html:4626,release,release,4626,docs/4.6/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html,2,['release'],['release']
Deployability,"tion” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:10016,release,release,10016,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,4,['release'],['release']
Deployability,"tip.Qobj`.; """"""; cythonized_dicke = _Dicke(; int(self.N),; float(self.emission),; float(self.dephasing),; float(self.pumping),; float(self.collective_emission),; float(self.collective_dephasing),; float(self.collective_pumping),; ); return cythonized_dicke.lindbladian(). [docs] def liouvillian(self):; """"""Build the total Liouvillian using the Dicke basis. Returns; -------; liouv : :class:`qutip.Qobj`; The Liouvillian matrix for the system.; """"""; lindblad = self.lindbladian(); if self.hamiltonian is None:; liouv = lindblad. else:; hamiltonian = self.hamiltonian; hamiltonian_superoperator = -1j * spre(hamiltonian) + 1j * spost(; hamiltonian; ); liouv = lindblad + hamiltonian_superoperator; return liouv. [docs] def pisolve(self, initial_state, tlist, options=None):; """"""; Solve for diagonal Hamiltonians and initial states faster. Parameters; ==========; initial_state : :class:`qutip.Qobj`; An initial state specified as a density matrix of; `qutip.Qbj` type. tlist: ndarray; A 1D numpy array of list of timesteps to integrate. options : :class:`qutip.solver.Options`; The options for the solver. Returns; =======; result: list; A dictionary of the type `qutip.solver.Result` which holds the; results of the evolution.; """"""; if isdiagonal(initial_state) == False:; msg = ""`pisolve` requires a diagonal initial density matrix. ""; msg += ""In general construct the Liouvillian using ""; msg += ""`piqs.liouvillian` and use qutip.mesolve.""; raise ValueError(msg). if self.hamiltonian and isdiagonal(self.hamiltonian) == False:; msg = ""`pisolve` should only be used for diagonal Hamiltonians. ""; msg += ""Construct the Liouvillian using `piqs.liouvillian` and""; msg += "" use `qutip.mesolve`.""; raise ValueError(msg). if initial_state.full().shape != self.dshape:; msg = ""Initial density matrix should be diagonal.""; raise ValueError(msg). pim = Pim(; self.N,; self.emission,; self.dephasing,; self.pumping,; self.collective_emission,; self.collective_pumping,; self.collective_dephasing,; ); result = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/piqs.html:13787,integrat,integrate,13787,docs/4.5/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/piqs.html,5,['integrat'],['integrate']
Deployability,"tip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. # ------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:10020,integrat,integrate,10020,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['integrat'],['integrate']
Deployability,"tip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(); ; #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; break. rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmeso",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:10341,integrat,integrate,10341,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,4,['integrat'],['integrate']
Deployability,"tiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. 3; https://github.com/qutip/qutip-tensorflow/. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:3440,update,updated,3440,docs/4.7/development/ideas/tensorflow-data-backend.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html,2,['update'],['updated']
Deployability,"tlist()[-1], num_steps); dt = tlist[1] - tlist[0]. # make sure coeffs start and end with zero, for ax.fill; tlist = np.hstack(([-dt*1.e-20], tlist, [tlist[-1] + dt*1.e-20])); coeffs = []; for pulse in self.pulses:; coeffs.append(_pulse_interpolate(pulse, tlist)). pulse_ind = 0; axis = []; for i, label_group in enumerate(self.get_operators_labels()):; for j, label in enumerate(label_group):; grid = grids[pulse_ind]; ax = plt.subplot(grid); axis.append(ax); ax.fill(tlist, coeffs[pulse_ind], color_list[i], alpha=0.7); ax.plot(tlist, coeffs[pulse_ind], color_list[i]); if rescale_pulse_coeffs:; ymax = np.max(np.abs(coeffs[pulse_ind])) * 1.1; else:; ymax = np.max(np.abs(coeffs)) * 1.1; if ymax != 0.:; ax.set_ylim((-ymax, ymax)). # disable frame and ticks; if not show_axis:; ax.set_xticks([]); ax.spines['bottom'].set_visible(False); ax.spines['top'].set_visible(False); ax.spines['right'].set_visible(False); ax.spines['left'].set_visible(False); ax.set_yticks([]); ax.set_ylabel(label, rotation=0); pulse_ind += 1; if i == 0 and j == 0 and title is not None:; ax.set_title(title); fig.tight_layout(); return fig, axis. def _pulse_interpolate(pulse, tlist):; """"""; A function that calls Scipy interpolation routine. Used for plotting.; """"""; if pulse.tlist is None and pulse.coeff is None:; coeff = np.zeros(len(tlist)); return coeff; if isinstance(pulse.coeff, bool):; if pulse.coeff:; coeff = np.ones(len(tlist)); else:; coeff = np.zeros(len(tlist)); return coeff; coeff = pulse.coeff; if len(coeff) == len(pulse.tlist)-1: # for discrete pulse; coeff = np.concatenate([coeff, [0]]). from scipy import interpolate; if pulse.spline_kind == ""step_func"":; kind = ""previous""; else:; kind = ""cubic""; inter = interpolate.interp1d(; pulse.tlist, coeff, kind=kind,; bounds_error=False, fill_value=0.0); return inter(tlist). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/device/processor.html:24185,update,updated,24185,docs/4.7/modules/qutip/qip/device/processor.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/device/processor.html,2,['update'],['updated']
Deployability,"tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if psi0.isunitary:; oper_evo = True; oper_n = dims[0][0]; norm_dim_factor = np.sqrt(oper_n); else:; oper_evo = False; norm_dim_factor = 1.0. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). def get_curr_state_data():; if oper_evo:; return vec2mat(r.y); else:; return r.y. #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). # get the current state / oper data if needed; cdata = None; if opt.store_states or opt.normalize_output or n_expt_op > 0:; cdata = get_curr_state_data(). if opt.normalize_output:; # cdata *= _get_norm_factor(cdata, oper_evo); cdata *= norm_dim_factor / la_norm(cdata); if oper_evo:; r.set_initial_value(cdata.ravel('F'), r.t); else:; r.set_initial_value(cdata, r.t). if opt.store_states:; output.states.append(Qobj(cdata, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(cdata, dims=dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; cdata, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:23347,update,update,23347,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['update'],['update']
Deployability,"tlist, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. .",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:17966,update,update,17966,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['update'],['update']
Deployability,"tlist, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. .",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:19137,update,update,19137,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,1,['update'],['update']
Deployability,"tlist, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y, dims=dims). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. .",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/sesolve.html:18809,update,update,18809,docs/4.1/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/sesolve.html,1,['update'],['update']
Deployability,"tlist: array_like; A NumPy array specifies the time of each coefficient. coeffs: array_like; A 2d NumPy array of the shape (len(ctrls), len(tlist)-1). Each; row corresponds to the control pulse sequence for; one Hamiltonian. Notes; -----; ``len(tlist) - 1 = coeffs.shape[1]`` since tlist gives the beginning; and the end of the pulses.; """"""; if setting_args is None:; setting_args = {}; if isinstance(qc, QubitCircuit):; props = qc.propagators(); gates = [g.name for g in qc.gates]; elif isinstance(qc, Iterable):; props = qc; gates = None # using list of Qobj, no gates name; else:; raise ValueError(; ""qc should be a ""; ""QubitCircuit or a list of Qobj""); if merge_gates: # merge all gates/Qobj into one Qobj; props = [gate_sequence_product(props)]; gates = None. time_record = [] # a list for all the gates; coeff_record = []; last_time = 0. # used in concatenation of tlist; for prop_ind, U_targ in enumerate(props):; U_0 = identity(U_targ.dims[0]). # If qc is a QubitCircuit and setting_args is not empty,; # we update the kwargs for each gate.; # keyword arguments in setting_arg have priority; if gates is not None and setting_args:; kwargs.update(setting_args[gates[prop_ind]]). full_drift_ham = self.drift.get_ideal_qobjevo(self.dims).cte; full_ctrls_hams = [pulse.get_ideal_qobj(self.dims); for pulse in self.pulses]; result = cpo.optimize_pulse_unitary(; full_drift_ham, full_ctrls_hams, U_0, U_targ, **kwargs). if result.fid_err > min_fid_err:; warnings.warn(; ""The fidelity error of gate {} is higher ""; ""than required limit. Use verbose=True to see""; ""the more detailed information."".format(prop_ind)). time_record.append(result.time[1:] + last_time); last_time += result.time[-1]; coeff_record.append(result.final_amps.T). if verbose:; print(""********** Gate {} **********"".format(prop_ind)); print(""Final fidelity error {}"".format(result.fid_err)); print(""Final gradient normal {}"".format(; result.grad_norm_final)); print(""Terminated due to {}"".format(result.termination_reason)); pri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html:7374,update,update,7374,docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,4,['update'],['update']
Deployability,"tly possible. There are no working conda-forge packages for Python 2.7 on Windows. You will have to install via pip or from source in Python 2.7 on Windows. The ‘MS Visual C for Python 2.7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:8144,install,installation,8144,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,4,['install'],['installation']
Deployability,"tly possible. There are no working conda-forge packages for Python 2.7 on Windows. You will have to install via pip or from source in Python 2.7 on Windows. The ‘MS Visual C for Python 2.7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the pytest testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/installation.html:8279,install,installation,8279,docs/4.5/installation.html,https://qutip.org,https://qutip.org/docs/4.5/installation.html,1,['install'],['installation']
Deployability,"to the; maximum and minimum colors in the colorbar (True) or not (False). 'figsize' : tuple of two numbers; The size of the figure. Returns :; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------; ValueError; Input argument is not valid. """""". # default options; default_opts = {'figsize': None, 'cmap': 'jet', 'cmap_min': 0.,; 'cmap_max': 1., 'zticks': None, 'bars_spacing': 0.2,; 'bars_alpha': 1., 'bars_lw': 0.5, 'bars_edgecolor': 'k',; 'shade': False, 'azim': -35, 'elev': 35,; 'proj_type': 'ortho', 'stick': False,; 'cbar_pad': 0.04, 'cbar_to_z': False}. # update default_opts from input options; if options is None:; pass; elif isinstance(options, dict):; # check if keys in options dict are valid; if set(options) - set(default_opts):; raise ValueError(""invalid key(s) found in options: ""; f""{', '.join(set(options) - set(default_opts))}""); else:; # updating default options; default_opts.update(options); else:; raise ValueError(""options must be a dictionary""). if isinstance(M, Qobj):; # extract matrix data from Qobj; M = M.full(). n = np.size(M); xpos, ypos = np.meshgrid(range(M.shape[0]), range(M.shape[1])); xpos = xpos.T.flatten() + 0.5; ypos = ypos.T.flatten() + 0.5; zpos = np.zeros(n); dx = dy = (1 - default_opts['bars_spacing']) * np.ones(n); dz = np.real(M.flatten()). if isinstance(limits, list) and len(limits) == 2:; z_min = limits[0]; z_max = limits[1]; else:; z_min = min(dz); z_max = max(dz); if z_min == z_max:; z_min -= 0.1; z_max += 0.1. if default_opts['cbar_to_z']:; norm = mpl.colors.Normalize(min(dz), max(dz)); else:; norm = mpl.colors.Normalize(z_min, z_max); cmap = _truncate_colormap(default_opts['cmap'],; default_opts['cmap_min'],; default_opts['cmap_max']); colors = cmap(norm(dz)). if ax is None:; fig = plt.figure(figsize=default_opts['figsize']); ax = _axes3D(fig,; azim=default_opts['azim'] % 360,; elev=default_opts['elev'] % 360); ax.set_proj_type(default_opts['proj_type']). ax.bar3d(x",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/visualization.html:18529,update,update,18529,docs/4.7/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html,2,['update'],['update']
Deployability,"to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; J_dat = J.data. Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices, J_dat.indptr),; shape=J_dat.shape). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices, J_dat.indptr),; shape=J_dat.shape); # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/metrics.html:14565,update,updated,14565,docs/4.4/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/metrics.html,1,['update'],['updated']
Deployability,"tonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. H : List of Qobj; The combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'UNIT'; self.drift_ham = None; self.ctrl_ham = None; self.H = None. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.amp_update_mode == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). # set the default fidelity computer; self.fid_computer = fidcomp.FidCompUnitary(self); # set the default propagator computer; self.prop_computer = propcomp.PropCompDiag(self). def initialize_controls(self, amplitudes, init_tslots=True):; # Either the _dyn_gen or _ham names can be used; # This assumes that one or other has been set in the configuration. self._map_dyn_gen_to_ham(); Dynamics.initialize_controls(self, amplitudes, init_tslots=init_tslots); self.H = self.dyn_gen. def _map_dyn_gen_to_ham(self):; if self.drift_dyn_gen is None:; self.drift_dyn_gen = self.drift_ham; else:; self.drift_ham = self.drift_dyn_gen. if self.ctrl_dyn_gen is None:; self.ctrl_dyn_gen = self.ctrl_ham; else:; self.ctrl_ham = self.ctrl_dyn_gen. self._dyn_gen_mapped = True. [docs] def get_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:23546,configurat,configuration,23546,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['configurat'],['configuration']
Deployability,"tran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; sudo pip install qutip. However, when installing QuTiP this way the Fortran-based Monte Carlo solver is not included.; More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:3574,release,releases,3574,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,1,['release'],['releases']
Deployability,"trans() (Qobj method). (QobjEvo method). transform() (Qobj method). triplet_states() (in module qutip.states). trunc_neg() (Qobj method). TSlotCompUpdateAll (class in qutip.control.tslotcomp). ttmsolve() (in module qutip.nonmarkov.transfertensor). TTMSolverOptions (class in qutip.nonmarkov.transfertensor). tunneling() (in module qutip.operators). TwoModeQuadratureCorrelation (class in qutip.distributions). types (BathExponent attribute). U. UnderDampedBath (class in qutip.nonmarkov.heom). unflatten() (in module qutip.dimensions). unit() (Qobj method). unitarity() (in module qutip.metrics). unitarity_check() (Dynamics method). update() (HarmonicOscillatorProbabilityFunction method). (HarmonicOscillatorWaveFunction method). (TwoModeQuadratureCorrelation method). update_ctrl_amps() (Dynamics method). update_fid_err_log() (OptimDump method). update_grad_log() (OptimDump method). update_grad_norm_log() (OptimDump method). update_psi() (TwoModeQuadratureCorrelation method). update_rho() (TwoModeQuadratureCorrelation method). V. value() (eseries method). variance() (in module qutip.expect). vector_mutation (Bloch attribute). vector_style (Bloch attribute). vector_to_operator() (in module qutip.superoperator). vector_width (Bloch attribute). version_table() (in module qutip.ipynbtools). visualize() (Distribution method). W. w_state() (in module qutip.states). weighted_bipartite_matching() (in module qutip.graph). wigner() (in module qutip.wigner). wigner_cmap() (in module qutip.matplotlib_utilities). wigner_covariance_matrix() (in module qutip.continuous_variables). WignerDistribution (class in qutip.distributions). winding_number() (Lattice1d method). writeout() (DynamicsDump method). (EvoCompDumpItem method). (OptimDump method). X. x() (Lattice1d method). Z. zero_ket() (in module qutip.states). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/genindex.html:37089,update,updated,37089,docs/4.7/genindex.html,https://qutip.org,https://qutip.org/docs/4.7/genindex.html,1,['update'],['updated']
Deployability,"tributes. H_S; (qutip.Qobj) System Hamiltonian (can also be a Liouvillian). L1; (qutip.Qobj / list of qutip.Qobj) System operators coupling into the feedback loop. Can be a single operator or a list of operators. L2; (qutip.Qobj / list of qutip.Qobj) System operators coupling out of the feedback loop. Can be a single operator or a list of operators. L2 must have the same length as L1. S_matrix: array; S matrix describing which operators in L1 are coupled to which operators in L2 by the feedback channel. Defaults to an n by n identity matrix where n is the number of elements in L1/L2. c_ops_markov; (qutip.Qobj / list of qutip.Qobj) Decay operators describing conventional Markovian decay channels. Can be a single operator or a list of operators. integrator; (str {‘propagator’, ‘mesolve’}) Integrator method to use. Defaults to ‘propagator’ which tends to be faster for long times (i.e., large Hilbert space). parallel; (bool) Run integrator in parallel if True. Only implemented for ‘propagator’ as the integrator method. options; (qutip.solver.Options) Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:rho0 : qutip.Qobj. initial density matrix or state vector (ket). blist : array_like. List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlist : array_like. list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float. time-delay. c1 : qutip.Qobj. system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : qutip.Qobj. system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns:: complex. expectation value of field ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:28525,integrat,integrator,28525,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['integrat'],['integrator']
Deployability,"tributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]¶; Reset any attributes to default values. run(self, rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:33811,integrat,integrator,33811,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['integrat'],['integrator']
Deployability,"tribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:1817,update,update,1817,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,4,"['deploy', 'update']","['deploying', 'update']"
Deployability,"tring_list.append(""me_cops_obj[%d]"" % k) ; ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list); ; #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=len(Lcoeff), h_tdterms=Lcoeff, ; c_td_splines=me_cops_coeff, ; c_td_spline_flags=me_cops_obj_flags, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/mesolve.html:22479,integrat,integrate,22479,docs/4.3/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mesolve.html,1,['integrat'],['integrate']
Deployability,"trix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes:; H_S : qutip.Qobj; System Hamiltonian (can also be a Liouvillian). L1 : qutip.Qobj / list of qutip.Qobj; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : qutip.Qobj / list of qutip.Qobj; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : qutip.Qobj / list of qutip.Qobj; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {‘propagator’, ‘mesolve’}; Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options : qutip.solver.Options; Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : qutip.Qobj; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:29043,integrat,integrator,29043,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['integrat'],['integrator']
Deployability,"ts; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-dynamics.html:2272,update,updated,2272,docs/4.3/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-dynamics.html,1,['update'],['updated']
Deployability,"ttribute). HEOMSolver (class in qutip.nonmarkov.heom). hilbert_dist() (in module qutip.metrics). hinton() (in module qutip.visualization). homogeneous (StochasticSolverOptions attribute). HSolverDL (class in qutip.nonmarkov.heom). I. identity() (in module qutip.operators). init_coeffs() (PulseGenCrab method). init_comp() (FidCompTraceDiff method). (FidCompUnitary method). (FidelityComputer method). init_freqs() (PulseGenCrabFourier method). init_normalization() (FidCompUnitary method). init_optim() (Optimizer method). (OptimizerCrab method). (OptimizerLBFGSB method). init_pulse() (PulseGen method). (PulseGenCrab method). (PulseGenCrabFourier method). (PulseGenLinear method). (PulseGenPeriodic method). init_timeslots() (Dynamics method). initial (Dynamics attribute). initial_amps (OptimResult attribute). initial_ctrl_offset (Dynamics attribute). initial_ctrl_scaling (Dynamics attribute). initial_fid_err (OptimResult attribute). initialize_controls() (Dynamics method). integrator (MemoryCascade attribute). isbra (Qobj attribute). iscp (Qobj attribute). iscptp (Qobj attribute). isherm (Qobj attribute). ishp (Qobj attribute). isket (Qobj attribute). isoper (Qobj attribute). isoperbra (Qobj attribute). isoperket (Qobj attribute). issuper (Qobj attribute). istp (Qobj attribute). iswap() (in module qutip.qip.gates). iter_num (OptimIterSummary attribute). iter_step_callback_func() (Optimizer method). iter_summary (OptimDump attribute). (Optimizer attribute). J. jmat() (in module qutip.operators). K. ket() (in module qutip.states). ket2dm() (in module qutip.states). L. L1 (MemoryCascade attribute). L2 (MemoryCascade attribute). lbound (PulseGen attribute). learningtimes (TTMSolverOptions attribute). level (Dump attribute), [1]. lindblad_dissipator() (in module qutip.superoperator). LinearSpinChain (class in qutip.qip.models.spinchain). linspace_with() (in module qutip.utilities). liouvillian() (in module qutip.superoperator). load_circuit() (CircuitProcessor method). log_lev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/genindex.html:14149,integrat,integrator,14149,docs/4.0.2/genindex.html,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html,1,['integrat'],['integrator']
Deployability,"tum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-overview.html:1970,update,updated,1970,docs/4.0.2/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-overview.html,1,['update'],['updated']
Deployability,"tum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-overview.html:1970,update,updated,1970,docs/4.1/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-overview.html,1,['update'],['updated']
Deployability,"tum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Tree-diagram of the 306 user accessible functions and classes in QuTiP 3.2. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-overview.html:1970,update,updated,1970,docs/4.2/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-overview.html,1,['update'],['updated']
Deployability,"type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work, but are not supported.; As of QuTiP 4.1, recommended installation on Windows requires Python 3.5+, as well as Visual Studio 2015. With this configuration, one can install QuTiP using any of the above mentioned receipes. Visual Studio 2015 is not required for the install of the conda-forge package, but it is required at runtime for the string format time-dependence solvers. When installing Visual Studio 2015 be sure to select options for the C++ compiler.; The ‘Community’ edition of Visual Studio 2015 is free to download use, however it does require approx 10GB of disk space, much of which does have to be on the system drive. If this is not feasible, then it is possible to run QuTiP under Python 2.7. Windows and Python 2.7¶. Important; Running QuTiP under Python 2.7 on Windows is not recommended or supported. However, it is currently possible. There are no working conda-forge packages for Python 2.7 on Windows. You will have to install via pip or from source in Python 2.7 on Windows. The ‘MS Visual C for Python 2.7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the foll",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:6647,install,installing,6647,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,5,['install'],['installing']
Deployability,"tzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes:; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:26460,integrat,integrate,26460,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['integrat'],['integrate']
Deployability,"uTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Introduction. Introduction¶; The Hierarchical Equations of Motion (HEOM) method was originally developed by; Tanimura and Kubo [TK89] in the context of physical chemistry to; ‘’exactly’’ solve a quantum system in contact with a bosonic environment,; encapsulated in the Hamiltonian:. \[H = H_s + \sum_k \omega_k a_k^{\dagger}a_k + \hat{Q} \sum_k g_k \left(a_k + a_k^{\dagger}\right).\]; As in other solutions to this problem, the properties of the bath are; encapsulated by its temperature and its spectral density,. \[J(\omega) = \pi \sum_k g_k^2 \delta(\omega-\omega_k).\]; In the HEOM, for bosonic baths, one typically chooses a Drude-Lorentz spectral; density:. \[J_D = \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\]; or an under-damped Brownian motion spectral density:. \[J_U = \frac{\alpha^2 \Gamma \omega}{[(\omega_c^2 - \omega^2)^2 + \Gamma^2 \omega^2]}.\]; Given the spectral density, the HEOM requires a decomposition of the bath; correlation functions in terms of exponentials. In Bosonic Environments we describe; how this is done with code examples, and how these expansions are passed to the; solver.; In addition to support for bosonic environments, QuTiP also provides support for; feriomic environments which is described in Fermionic Environments.; Both bosonic and fermionic environments are supported via a single solver,; HEOMSolver, that supports solving for both dynamics and steady-states. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/intro.html:2534,update,updated,2534,docs/4.7/guide/heom/intro.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/intro.html,2,['update'],['updated']
Deployability,"uTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Installation on MS Windows¶; We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work.; QuTiP uses dynamic compilation of C for some of its time-dependant dynamics solvers. Fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:5943,install,installing,5943,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,2,['install'],"['installation', 'installing']"
Deployability,"uTiP is released it can be upgraded through the standard package management system. In addition to the required dependencies, it is also strongly recommended that you install the texlive-latex-extra package:; sudo apt-get install texlive-latex-extra. Manual installation of dependencies¶; First install the required dependencies using:; sudo apt-get install python-dev cython python-setuptools python-nose; sudo apt-get install python-numpy python-scipy python-matplotlib. Then install QuTiP from source following the instructions given above.; Alternatively (or additionally), to install a Python 3 environment, use:; sudo apt-get install python3-dev cython python3-setuptools python3-nose; sudo apt-get install python3-numpy python3-scipy python3-matplotlib. and then do the installation from source using python3 instead of python.; Optional, but recommended, dependencies can be installed using:; sudo apt-get install texlive-latex-extra # recommended; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.6+)¶; If you have not done so already, install the Apple Xcode developer tools from the Apple App Store. After installation, open Xcode and go to: Preferences -> Downloads, and install the ‘Command Line Tools’. Setup Using Macports¶; On the Mac OS, we recommended that you install the required libraries via MacPorts. After installation, the necessary “ports” for QuTiP may be installed via; sudo port install py34-scipy; sudo port install py34-matplotlib +latex; sudo port install py34-cython; sudo port install py34-ipython +notebook+parallel. Optional, but highly recommended ports include; sudo port install vtk5 +python27 #used for the Bloch3d class; sudo port install py27-mayavi #used for the Bloch3d class. Now, we want to tell OSX which Python and iPython we are going to use; sudo port select p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:5771,install,installed,5771,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,10,['install'],"['install', 'installed']"
Deployability,"uTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; T2 Relaxation. Note; Click here; to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(); fig.show(). Total running time of the script: ( 0 minutes 0.136 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html:1943,update,updated,1943,docs/4.7/gallery/build/qip/plot_qip_relaxation.html,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html,2,['update'],['updated']
Deployability,"ualizations. stylestringType of visualization: ‘colormap’ (default) or ‘surface’. Returns. fig, axtupleA tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. update(self, state)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(self, psi)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(self, rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(self, psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(self, rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(*args, **kwargs)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. Parameters. namestringGate name. targetslist or intGate targets. controlslist or intGate controls. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. class QubitCircuit(*args, **kwargs)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. Parameters. NintNumber of qubits in the system. user_gatesdictDefine a dictionary of the custom gates. See examples for detail. input_stateslistA list of string such as 0,’+’, “A”, “Y”. Only used for latex. dimslistA list of integer for the d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:71550,update,update,71550,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['update'],['update']
Deployability,"ualizations. stylestringType of visualization: ‘colormap’ (default) or ‘surface’. Returns. fig, axtupleA tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. update(self, state)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(self, psi)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(self, rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(self, psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(self, rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. Parameters. namestringGate name. targetslist or intGate targets. controlslist or intGate controls. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. class QubitCircuit(N, input_states=None, output_states=None, reverse_states=True, user_gates=None)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. Parameters. NintNumber of qubits in the system. user_gatesdictDefine a dictionary of the custom gates. See examples for detail. i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:61541,update,update,61541,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['update'],['update']
Deployability,"ualizations.; style; : stringType of visualization: ‘colormap’ (default) or ‘surface’. Returns:fig, ax – A tuple of matplotlib figure and axes instances. Return type:tuple. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]¶. update(state)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(psi)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(rho)[source]¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(psi)[source]¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_states=True)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:; name (String) – Gate name.; start (Integer) – Starting location of qubits.; end (Integer) – Last",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:51454,update,update,51454,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['update'],['update']
Deployability,"uantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel¶; bool – Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options¶; qutip.solver.Options – Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket).; blist (array_like) – List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger; tlist (array_like) – list of corresponding times t1,..,tn at which to evaluate the field; operators; tau (float) – time-delay; c1 (qutip.Qobj) – system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element); c2 (qutip.Qobj) – system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has mor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:31643,integrat,integrator,31643,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['integrat'],['integrator']
Deployability,"uare CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular. This function looks at both the structure and ABS values of the underlying; matrix. Parameters; ----------; A : csc_matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutation to generate. Returns; -------; perm : array; Array of row or column permutations. Notes; -----; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method. References; ----------; I. S. Duff and J. Koster, ""The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices"", SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997).; """"""; _deprecate(); nrows = A.shape[0]; if A.shape[0] != A.shape[1]:; raise ValueError('weighted_bfs_matching requires a square matrix.'); if sp.isspmatrix_csr(A) or sp.isspmatrix_coo(A):; A = A.tocsc(); elif not sp.isspmatrix_csc(A):; raise TypeError(""matrix must be in CSC, CSR, or COO format.""). if perm_type == 'column':; A = A.transpose().tocsc(); perm = _weighted_bipartite_matching(; np.asarray(np.abs(A.data), dtype=float),; A.indices, A.indptr, nrows); if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'); return perm. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/graph.html:9775,update,updated,9775,docs/4.6/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/graph.html,2,['update'],['updated']
Deployability,"uate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Qdeoptions. with options for the ODE solver. Returns:output: qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops, e_ops, args={}, options=None, progress_bar=None)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:43953,integrat,integrating,43953,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['integrat'],['integrating']
Deployability,"ub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:14123,update,updated,14123,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,3,"['Update', 'update']","['Update', 'updated']"
Deployability,"ubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: bloch_decay.mp4. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-bloch.html:14476,install,install,14476,docs/4.7/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html,4,"['install', 'update']","['install', 'updated']"
Deployability,"uch better using ndarrays to represent these operators.; However; Attributes. num_ctrls. dyn_gen. prop. prop_grad. fwd_evo. onwd_evo. onto_evo. dumping. log_level; (integer) level of messaging output from the logger. Options are attributes of qutip.logging_utils, in decreasing levels of messaging, are: DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL Anything WARN or above is effectively ‘quiet’ execution, assuming everything runs as expected. The default NOTSET implies that the level will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value Note: attributes are created if they do not exist already, and are overwritten if they do. stats; (Stats) Attributes of which give performance stats for the optimisation set to None to reduce overhead of calculating stats. Note it is (usually) shared with the Optimizer object. tslot_computer; (TimeslotComputer (subclass instance)) Used to manage when the timeslot dynamics generators, propagators, gradients etc are updated. prop_computer; (PropagatorComputer (subclass instance)) Used to compute the propagators and their gradients. fid_computer; (FidelityComputer (subclass instance)) Used to computer the fidelity error and the fidelity error gradient. memory_optimization; (int) Level of memory optimisation. Setting to 0 (default) means that execution speed is prioritized over memory. Setting to 1 means that some memory prioritisation steps will be taken, for instance using Qobj (and hence sparse arrays) as the the internal operator data type, and not caching some operators Potentially further memory saving maybe made with memory_optimization > 1. The options are processed in _set_memory_optimizations, see this for more information. Individual memory saving options can be switched by settting them directly (see below). oper_dtype; (type) Data type for internal dynamics generators, propagators and time evolution operators. This can be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:74138,update,updated,74138,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['update'],['updated']
Deployability,"uch] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status mes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:11949,Continuous,Continuous,11949,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,1,['Continuous'],['Continuous']
Deployability,udes calculating the propagators themselves. wall_time_gradient_compute¶; float – Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls¶; integer – Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls¶; integer – Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute¶; integer – Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes¶; integer – Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes¶; integer – Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates¶; integer – Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter¶; float – Mean number of control amplitude updates per iteration. num_timeslot_changes¶; integer – Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update¶; float – Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes¶; integer – Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update¶; float – Mean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. parent¶; some control object (Dynamics or Optimizer) – aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir¶; str – directory where files (if ,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:113879,update,updates,113879,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['update'],['updates']
Deployability,"ue to; finite numerical precision, for ranks less than full-rank,; zero eigenvalues may become slightly negative, such that the; returned operator is not actually completely positive. Parameters. NintSquare root of the dimension of the superoperator to be returned. enforce_tpboolIf True, the trace-preserving condition of [BCSZ08] is enforced;; otherwise only complete positivity is enforced. rankint or NoneRank of the sampled superoperator. If None, a full-rank; superoperator is generated. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns. rhoQobjA superoperator acting on vectorized dim × dim density operators,; sampled from the BCSZ distribution. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R0be8dcf25d86-1] . R0be8dcf25d86-1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vecto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:34775,configurat,configuration,34775,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['configurat'],['configuration']
Deployability,"ue):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:13000,configurat,configuration,13000,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,3,['configurat'],['configuration']
Deployability,"ue, Nres=None, deltamax=None, epsmax=None, w0=None, wq=None, eps=None, delta=None, g=None)[source]¶; Representation of the physical implementation of a quantum; program/algorithm on a dispersive cavity-QED system. dispersive_gate_correction(qc1, rwa=True)[source]¶; Method to resolve ISWAP and SQRTISWAP gates in a cQED system by adding; single qubit gates to get the correct output matrix. Parameters:; qc (Qobj) – The circular spin chain circuit to be resolved; rwa (Boolean) – Specify if RWA is used or not. Returns:qc – Returns QubitCircuit of resolved gates for the qubit circuit in the; desired basis. Return type:QubitCircuit. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg¶; string – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params¶; Dictionary – options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg¶; bool – Set true to display a converge",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:59491,configurat,configuration,59491,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['configurat'],['configuration']
Deployability,"ue; else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). L = -1j * h; L_list.append([L.data, h_coeff]). L_list_and_args = [L_list, args]. #; # setup integrator; #; if oper_evo:; initial_vector = psi0.full().ravel('F'); if opt.rhs_with_state:; r = scipy.integrate.ode(oper_list_td_with_state); else:; r = scipy.integrate.ode(oper_list_td); else:; initial_vector = psi0.full().ravel(); if opt.rhs_with_state:; r = scipy.integrate.ode(psi_list_td_with_state); else:; r = scipy.integrate.ode(psi_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list_and_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def psi_list_td(t, psi, L_List_and_args):. L_List = L_List_and_args[0]; args = L_List_and_args[1]. L = L_List[0][0]; tdfunc = L_List[0][1]; out = np.zeros(psi.shape[0],dtype=complex); spmvpy_csr(L.data, L.indices, L.indptr, psi, tdfunc(t, args), out); for n in range(1, len(L_List)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; L = L_List",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:8504,integrat,integrate,8504,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['integrat'],['integrate']
Deployability,"ue; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); if oper_evo:; for e in e_ops:; if not isinstance(e, Qobj):; e_ops_data.append(e); elif e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.dag().data); else:; for e in e_ops:; if not isinstance(e, Qobj):; e_ops_data.append(e); elif e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.data); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. if oper_evo:; def get_curr_state_data(r):; return vec2mat(r.y); else:; def get_curr_state_data(r):; return r.y. #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output \; or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/sesolve.html:9999,update,update,9999,docs/4.7/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html,2,['update'],['update']
Deployability,"uffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); Add a default max_step to processors. (#2040). Documentation¶. Add towncrier for managing the changelog. (#1927); Update the version of numpy used to build documentation to 1.22.0. (#1940); Clarify returned objects from bloch_redfield_tensor(). (#1950); Update Floquet Markov solver docs. (#1958); Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous¶. Return TypeError instead of Exception for type error in sesolve argument. (#1924); Add towncrier draft build of changelog to CI tests. (#1946); Add Python 3.11 to builds. (#2041); Simplify version parsing by using packaging.version.Version. (#2043); Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022)¶; This release sees the addition of two new solvers – qutip.krylovsolve based on the Krylov subspace approximation and qutip.nonmarkov.heom that reimplements the BoFiN HEOM solver.; Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options.; Other significant improvements include better scaling of the Floquet solver, support for passing Path objects when saving and loading files, support for passing callable functions as e_ops to mesolve and sesolve, and faster state number enumeration and Husimi Q functions.; Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits.; The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are includ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:6757,release,release,6757,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['release'],['release']
Deployability,ule qutip.superop_reps). to_choi() (in module qutip.superop_reps). to_kraus() (in module qutip.superop_reps). to_list() (QobjEvo method). to_stinespring() (in module qutip.superop_reps). to_super() (in module qutip.superop_reps). toffoli() (in module qutip.qip.operations.gates). tr() (Qobj method). tracedist() (in module qutip.metrics). trans() (Qobj method). (QobjEvo method). transform() (Qobj method). triplet_states() (in module qutip.states). trunc_neg() (Qobj method). TSlotCompUpdateAll (class in qutip.control.tslotcomp). ttmsolve() (in module qutip.nonmarkov.transfertensor). TTMSolverOptions (class in qutip.nonmarkov.transfertensor). tunneling() (in module qutip.operators). TwoModeQuadratureCorrelation (class in qutip.distributions). types (BathExponent attribute). U. UnderDampedBath (class in qutip.nonmarkov.heom). unflatten() (in module qutip.dimensions). unit() (Qobj method). unitarity() (in module qutip.metrics). unitarity_check() (Dynamics method). update() (HarmonicOscillatorProbabilityFunction method). (HarmonicOscillatorWaveFunction method). (TwoModeQuadratureCorrelation method). update_ctrl_amps() (Dynamics method). update_fid_err_log() (OptimDump method). update_grad_log() (OptimDump method). update_grad_norm_log() (OptimDump method). update_psi() (TwoModeQuadratureCorrelation method). update_rho() (TwoModeQuadratureCorrelation method). V. value() (eseries method). variance() (in module qutip.expect). vector_mutation (Bloch attribute). vector_style (Bloch attribute). vector_to_operator() (in module qutip.superoperator). vector_width (Bloch attribute). version_table() (in module qutip.ipynbtools). visualize() (Distribution method). W. w_state() (in module qutip.states). weighted_bipartite_matching() (in module qutip.graph). wigner() (in module qutip.wigner). wigner_cmap() (in module qutip.matplotlib_utilities). wigner_covariance_matrix() (in module qutip.continuous_variables). WignerDistribution (class in qutip.distributions). winding_number() (Lattice1,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/genindex.html:35824,update,update,35824,docs/4.7/genindex.html,https://qutip.org,https://qutip.org/docs/4.7/genindex.html,1,['update'],['update']
Deployability,"ule qutip.superop_reps). to_super() (in module qutip.superop_reps). toffoli() (in module qutip.qip.gates). tr() (Qobj method). tracedist() (in module qutip.metrics). trans() (Qobj method). transform() (Qobj method). trunc_neg() (Qobj method). TSlotCompUpdateAll (class in qutip.control.tslotcomp). ttmsolve() (in module qutip.nonmarkov.transfertensor). TTMSolverOptions (class in qutip.nonmarkov.transfertensor). tunneling() (in module qutip.operators). TwoModeQuadratureCorrelation (class in qutip.distributions). U. unflatten() (in module qutip.dimensions). unit() (Qobj method). unitarity_check() (Dynamics method). update() (HarmonicOscillatorProbabilityFunction method). (HarmonicOscillatorWaveFunction method). (TwoModeQuadratureCorrelation method). update_ctrl_amps() (Dynamics method). update_fid_err_log() (OptimDump method). update_grad_log() (OptimDump method). update_grad_norm_log() (OptimDump method). update_psi() (TwoModeQuadratureCorrelation method). update_rho() (TwoModeQuadratureCorrelation method). UserNoise (class in qutip.qip.noise). V. value() (eseries method). variance() (in module qutip.expect). vector_mutation (Bloch attribute). vector_style (Bloch attribute). vector_to_operator() (in module qutip.superoperator). vector_width (Bloch attribute). version_table() (in module qutip.ipynbtools). visualize() (Distribution method). W. weighted_bipartite_matching() (in module qutip.graph). wigner() (in module qutip.wigner). wigner_covariance_matrix() (in module qutip.continuous_variables). WignerDistribution (class in qutip.distributions). winding_number() (Lattice1d method). writeout() (DynamicsDump method). (EvoCompDumpItem method). (OptimDump method). X. x() (Lattice1d method). Z. zero_ket() (in module qutip.states). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/genindex.html:29940,update,updated,29940,docs/4.5/genindex.html,https://qutip.org,https://qutip.org/docs/4.5/genindex.html,1,['update'],['updated']
Deployability,ule qutip.three_level_atom). three_level_ops() (in module qutip.three_level_atom). tidyup() (eseries method). (Qobj method). TimeslotComputer (class in qutip.control.tslotcomp). tlist() (Pulse property). to_chi() (in module qutip.superop_reps). to_choi() (in module qutip.superop_reps). to_kraus() (in module qutip.superop_reps). to_stinespring() (in module qutip.superop_reps). to_super() (in module qutip.superop_reps). toffoli() (in module qutip.qip.gates). tr() (Qobj method). tracedist() (in module qutip.metrics). trans() (Qobj method). transform() (Qobj method). trunc_neg() (Qobj method). TSlotCompUpdateAll (class in qutip.control.tslotcomp). ttmsolve() (in module qutip.nonmarkov.transfertensor). TTMSolverOptions (class in qutip.nonmarkov.transfertensor). tunneling() (in module qutip.operators). TwoModeQuadratureCorrelation (class in qutip.distributions). U. unflatten() (in module qutip.dimensions). unit() (Qobj method). unitarity_check() (Dynamics method). update() (HarmonicOscillatorProbabilityFunction method). (HarmonicOscillatorWaveFunction method). (TwoModeQuadratureCorrelation method). update_ctrl_amps() (Dynamics method). update_fid_err_log() (OptimDump method). update_grad_log() (OptimDump method). update_grad_norm_log() (OptimDump method). update_psi() (TwoModeQuadratureCorrelation method). update_rho() (TwoModeQuadratureCorrelation method). UserNoise (class in qutip.qip.noise). V. value() (eseries method). variance() (in module qutip.expect). vector_mutation (Bloch attribute). vector_style (Bloch attribute). vector_to_operator() (in module qutip.superoperator). vector_width (Bloch attribute). version_table() (in module qutip.ipynbtools). visualize() (Distribution method). W. weighted_bipartite_matching() (in module qutip.graph). wigner() (in module qutip.wigner). wigner_covariance_matrix() (in module qutip.continuous_variables). WignerDistribution (class in qutip.distributions). winding_number() (Lattice1d method). writeout() (DynamicsDump method). (EvoCom,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/genindex.html:28648,update,update,28648,docs/4.5/genindex.html,https://qutip.org,https://qutip.org/docs/4.5/genindex.html,1,['update'],['update']
Deployability,"ult, config, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode, dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.settings import debug; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the `H` or `c_ops`; elements. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be callback; functions that takes two arguments, time and `args`, and returns the; Ham",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/mesolve.html:3506,integrat,integrating,3506,docs/4.5/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/mesolve.html,1,['integrat'],['integrating']
Deployability,"ultiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:90816,update,updated,90816,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,5,['update'],['updated']
Deployability,"ults¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {‘adams’,’bdf’}Integration method. orderint {12}Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntrajint {500}Number of trajectories in stochastic solvers. openm",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:78698,Integrat,Integration,78698,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['Integrat'],['Integration']
Deployability,"um Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Control Amplitude Noise. Note; Click here; to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x7f0268569e80>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2[0].step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.081 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html:1964,update,updated,1964,docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html,2,['update'],['updated']
Deployability,"um of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps; ; stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.evo_full_initial = None; self.stats = None; self.optimizer = None. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/optimresult.html:3096,update,updated,3096,docs/4.7/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/optimresult.html,2,['update'],['updated']
Deployability,"um states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . QuTiP: Quantum Toolbox in Python (3.1.0); Indices and tables. Frontmatter ». QuTiP: Quantum Toolbox in Python (3.1.0)¶. Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.8+); Setup Using Homebrew; Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Optional Installation Options; UMFPACK Linear Solver; Optimized BLAS Libraries. Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/index.html:1827,install,installation,1827,docs/3.1.0/index.html,https://qutip.org,https://qutip.org/docs/3.1.0/index.html,2,['install'],['installation']
Deployability,"um_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:22142,update,update,22142,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['update'],['update']
Deployability,"umber basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from qutip.tensor import tensor. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/operators.html:23898,update,updated,23898,docs/4.6/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html,2,['update'],['updated']
Deployability,"umbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP webs",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:5365,release,release,5365,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['release'],['release']
Deployability,"ument to the task function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns:; result : list; The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters:; ops : list/array; list or array of qobjs representing commuting Hermitian; operators. Returns:; eigs : tuple; Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:216953,update,updated,216953,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['update'],['updated']
Deployability,"umentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Lattice; Visualization; Quantum Information Processing; Non-Markovian Solvers; Optimal control; Utility Functions. Change Log; Version 4.5.0 (January 31, 2020); Improvements; Bug Fixes. Version 4.4.1 (August 29, 2019); Improvements; Bug Fixes. Version 4.4.0 (July 03, 2019); Improvements; Bug Fixes. Version 4.3.0 (July 14, 2018); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Indices and tables¶. Index; Module Index; Search Page. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/index.html:4216,release,released,4216,docs/4.5/index.html,https://qutip.org,https://qutip.org/docs/4.5/index.html,1,['release'],['released']
Deployability,"umpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:5424,configurat,configuration,5424,docs/4.5/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html,1,['configurat'],['configuration']
Deployability,"unched photons, more likely to arrive separated in time).; To calculate this type of correlation function with QuTiP, we can use qutip.correlation.correlation_3op_1t, which computes a correlation function on the form \(\left<A(0)B(\tau)C(0)\right>\) (three operators, one delay-time vector).; We first have to combine the central two operators into one single one as they are evaluated at the same time, e.g. here we do \(a^\dagger(\tau)a(\tau) = (a^\dagger a)(\tau)\).; The following code calculates and plots \(g^{(2)}(\tau)\) as a function of \(\tau\) for a coherent, thermal and Fock state.; import numpy as np; import matplotlib.pyplot as plt; import qutip. N = 25; taus = np.linspace(0, 25.0, 200); a = qutip.destroy(N); H = 2 * np.pi * a.dag() * a. kappa = 0.25; n_th = 2.0 # bath temperature in terms of excitation number; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag()]. states = [; {'state': qutip.coherent_dm(N, np.sqrt(2)), 'label': ""coherent state""},; {'state': qutip.thermal_dm(N, 2), 'label': ""thermal state""},; {'state': qutip.fock_dm(N, 2), 'label': ""Fock state""},; ]. fig, ax = plt.subplots(1, 1). for state in states:; rho0 = state['state']. # first calculate the occupation number as a function of time; n = qutip.mesolve(H, rho0, taus, c_ops, [a.dag() * a]).expect[0]. # calculate the correlation function G2 and normalize with n(0)n(t) to; # obtain g2; G2 = qutip.correlation_3op_1t(H, rho0, taus, c_ops, a.dag(), a.dag()*a, a); g2 = G2 / (n[0] * n). ax.plot(taus, np.real(g2), label=state['label'], lw=2). ax.legend(loc=0); ax.set_xlabel(r'$\tau$'); ax.set_ylabel(r'$g^{(2)}(\tau)$'); plt.show(). For convenience, the steps for calculating the second-order coherence function have been collected in the function qutip.correlation.coherence_function_g2. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-correlation.html:12708,update,updated,12708,docs/4.7/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html,2,['update'],['updated']
Deployability,"unitarity_check_level:; dyn.check_unitarity(). if dyn.dump:; self.dump_current(). [docs] def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to be updated; ####; # Note _recalc means the value needs updating at some point; # e.g. here no values have been set, except the initial and final; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/tslotcomp.html:12578,update,updated,12578,docs/4.4/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/tslotcomp.html,1,['update'],['updated']
Deployability,"unning; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:5384,install,install,5384,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,6,['install'],"['install', 'installation']"
Deployability,"upled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import pylab as plt; from qutip import *; # Define paramters; N = 20 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plt.plot(tlist, mcdata.expect[0], tlist, medata.expect[0], lw=2); # plot steady-state expt. value as horizontal line (should be = 2); plt.axhline(y=fexpt, color='r', lw=1.5); plt.ylim([0, 10]); plt.xlabel('Time', fontsize=14); plt.ylabel('Number of excitations', fontsize=14); plt.legend(('Monte-Carlo', 'Master Equation', 'Steady State')); plt.title('Decay of Fock state $\left|10\\rangle\\right.$' +; ' in a thermal environment with $\langle n\\rangle=2$'); plt.show(). (Source code, png, hires.png, pdf). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-steady.html:11714,update,updated,11714,docs/4.3/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-steady.html,1,['update'],['updated']
Deployability,"urce packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-number> is the expected version number of the release. Make a pull request on the main q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:2294,release,releases,2294,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['release'],['releases']
Deployability,"ure instance; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance; The axis context in which the plot will be drawn. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. """"""; if not isket(ket):; raise Exception(""Schmidt plot works only for pure states, i.e. kets.""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). dim_list = ket.dims[0]. if splitting is None:; splitting = (len(dim_list) + 1) // 2. if isinstance(labels_iteration, int):; labels_iteration = labels_iteration, labels_iteration. ketdata = ket.full(). dim_list_y = dim_list[:splitting]; dim_list_x = dim_list[splitting:]. size_x = np.prod(dim_list_x); size_y = np.prod(dim_list_y). ketdata = ketdata.reshape((size_y, size_x)). dim_list_small_x = dim_list_x[:labels_iteration[1]]; dim_list_small_y = dim_list_y[:labels_iteration[0]]. quadrants_x = np.prod(dim_list_small_x); quadrants_y = np.prod(dim_list_small_y). ticks_x = [size_x / quadrants_x * (i + 0.5); for i in range(quadrants_x)]; ticks_y = [size_y / quadrants_y * (quadrants_y - i - 0.5); for i in range(quadrants_y)]. labels_x = [_sequence_to_latex(_index_to_sequence(i*size_x // quadrants_x,; dim_list=dim_list_x)); for i in range(quadrants_x)]; labels_y = [_sequence_to_latex(_index_to_sequence(i*size_y // quadrants_y,; dim_list=dim_list_y)); for i in range(quadrants_y)]. ax.set_xticks(ticks_x); ax.set_xticklabels(labels_x); ax.set_yticks(ticks_y); ax.set_yticklabels(labels_y); ax.set_xlabel(""last particles""); ax.set_ylabel(""first particles""). ax.imshow(complex_array_to_rgb(ketdata, theme=theme),; interpolation=""none"",; extent=(0, size_x, 0, size_y)). return fig, ax. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:40837,update,updated,40837,docs/3.1.0/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html,1,['update'],['updated']
Deployability,"ures; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing.; MAJOR FEATURE: Added a photon scattering module (by Ben Bartlett) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides.; Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed.; Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors.; Computing Q.overlap() [inner product] is now ~30x faster.; Added projector method to Qobj class.; Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/changelog.html:1713,configurat,configuration,1713,docs/4.3/changelog.html,https://qutip.org,https://qutip.org/docs/4.3/changelog.html,1,['configurat'],['configuration']
Deployability,"urier basis functions, i.e. sin and cos. Attributes; ----------; freqs : float array[num_coeffs]; Frequencies for the basis functions; randomize_freqs : bool; If True (default) the some random offset is applied to the frequencies; """""". [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGenCrab.reset(self); self.freqs = None; self.randomize_freqs = True. [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGenCrab.init_pulse(self); ; self.init_freqs(); ; [docs] def init_freqs(self):; """"""; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset; """"""; self.freqs = np.empty(self.num_coeffs); ff = 2*np.pi / self.pulse_time; for i in range(self.num_coeffs):; self.freqs[i] = ff*(i + 1); ; if self.randomize_freqs:; self.freqs += np.random.random(self.num_coeffs) - 0.5; ; [docs] def gen_pulse(self, coeffs=None):; """"""; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes.; ; Parameters; ----------; coeffs : float array[num_coeffs, num_basis_funcs]; The basis coefficient values; If given this overides the default and sets the attribute; of the same name.; """"""; if coeffs:; self.coeffs = coeffs; ; if not self._pulse_initialised:; self.init_pulse(); ; pulse = np.zeros(self.num_tslots). for i in range(self.num_coeffs):; phase = self.freqs[i]*self.time; # basis1comp = self.coeffs[i, 0]*np.sin(phase); # basis2comp = self.coeffs[i, 1]*np.cos(phase); # pulse += basis1comp + basis2comp; pulse += self.coeffs[i, 0]*np.sin(phase) + \; self.coeffs[i, 1]*np.cos(phase) . if self.guess_pulse_func:; pulse = self.guess_pulse_func(pulse); if self.ramping_pulse is not None:; pulse = self._apply_ramping_pulse(pulse); ; return self._apply_bounds(pulse); . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:36483,update,updated,36483,docs/4.3/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html,1,['update'],['updated']
Deployability,"uring the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; Thi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:192636,update,update,192636,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['update'],['update']
Deployability,"urio); Improved mcsolve memory efficiency by not storing final states when they are not needed. (#1669 by Eric Giguère); Improved the default colors and styling of matrix_histogram and provided additional styling options. (#1573 and #1628 by Mahdi Aslani); Sped up state_number_enumerate, state_number_index, state_index_number, and added some error checking. enr_state_dictionaries now returns a list for idx2state. (#1604 by Johannes Feist); Added new Husimi Q algorithms, improving the speed for density matrices, and giving a near order-of-magnitude improvement when calculating the Q function for many different states, using the new qutip.QFunc class, instead of the qutip.qfunc function. (#934 and #1583 by Daniel Weigand and Jake Lishman); Updated licence holders with regards to new governance model, and remove extraneous licensing information from source files. (#1579 by Jake Lishman); Removed the vendored copy of LaTeX’s qcircuit package which is GPL licensed. We now rely on the package being installed by user. It is installed by default with TexLive. (#1580 by Jake Lishman); The signatures of rand_ket and rand_ket_haar were changed to allow N (the size of the random ket) to be determined automatically when dims are specified. (#1509 by Purva Thakre). Bug Fixes¶. Fix circuit index used when plotting circuits with non-reversed states. (#1847 by Christian Staufenbiel); Changed implementation of qutip.orbital to use scipy.special.spy_harm to remove bugs in angle interpretation. (#1844 by Christian Staufenbiel); Fixed QobjEvo.tidyup to use settings.auto_tidyup_atol when removing small elements in sparse matrices. (#1832 by Eric Giguère); Ensured that tidyup’s default tolerance is read from settings at each call. (#1830 by Eric Giguère); Fixed scipy.sparse deprecation warnings raised by qutip.fast_csr_matrix. (#1827 by Simon Cross); Fixed rendering of vectors on the Bloch sphere when using matplotlib 3.5 and above. (#1818 by Simon Cross); Fixed the displaying of Lattice1",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:10898,install,installed,10898,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['install'],['installed']
Deployability,"urn _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/partial_transpose.html:6527,update,updated,6527,docs/3.1.0/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/partial_transpose.html,1,['update'],['updated']
Deployability,"urn y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); #; # Evaluate d E(t)/dt for E a super-operator; #. def _ode_super_func(t, y, data):; ym = vec2mat(y); return (data*ym).ravel('F'). # -----------------------------------------------------------------------------; # Master equation solver for pyth",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:22636,integrat,integrate,22636,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['integrat'],['integrate']
Deployability,"urns; -------. R, kets: :class:`qutip.Qobj`, list of :class:`qutip.Qobj`. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. """""". # Sanity checks for input parameters; if not isinstance(H, Qobj):; raise TypeError(""H must be an instance of Qobj""). for a in a_ops:; if not isinstance(a, Qobj) or not a.isherm:; raise TypeError(""Operators in a_ops must be Hermitian Qobj.""). # default spectrum; if not spectra_cb:; spectra_cb = [lambda w: 1.0 for _ in a_ops]. # use the eigenbasis; evals, ekets = H.eigenstates(). N = len(evals); K = len(a_ops); A = np.zeros((K, N, N), dtype=complex) # TODO: use sparse here; W = np.zeros((N, N)). # pre-calculate matrix elements; for n in range(N):; for m in range(N):; W[m, n] = np.real(evals[m] - evals[n]). for k in range(K):; # A[k,n,m] = a_ops[k].matrix_element(ekets[n], ekets[m]); A[k, :, :] = a_ops[k].transform(ekets).full(). dw_min = abs(W[W.nonzero()]).min(). # unitary part; Heb = H.transform(ekets); if c_ops is not None:; R = liouvillian(Heb, c_ops=[c_op.transform(ekets) for c_op in c_ops]); else:; R = -1.0j * (spre(Heb) - spost(Heb)); R.data = R.data.tolil(); for I in range(N * N):; a, b = vec2mat_index(N, I); for J in range(N * N):; c, d = vec2mat_index(N, J). # unitary part: use spre and spost above, same as this:; # R.data[I,J] = -1j * W[a,b] * (a == c) * (b == d). if use_secular is False or abs(W[a, b] - W[c, d]) < dw_min / 10.0:. # dissipative part:; for k in range(K):; # for each operator coupling the system to the environment. R.data[I, J] += ((A[k, a, c] * A[k, d, b] / 2) *; (spectra_cb[k](W[c, a]) +; spectra_cb[k](W[d, b]))); s1 = s2 = 0; for n in range(N):; s1 += A[k, a, n] * A[k, n, c] * spectra_cb[k](W[c, n]); s2 += A[k, d, n] * A[k, n, b] * spectra_cb[k](W[d, n]). R.data[I, J] += - (b == d) * s1 / 2 - (a == c) * s2 / 2. R.data = R.data.tocsr(); return R, ekets. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/bloch_redfield.html:10927,update,updated,10927,docs/3.1.0/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/bloch_redfield.html,1,['update'],['updated']
Deployability,"us of the args variable:; def H1_coeff(t, args):; return args['A'] * exp(-(t/args['sigma'])**2). or equivalently:; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; >>> output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty:; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals. We remind the reader that the types of functions that can be used with this method is limited to:; ['acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil'; , 'copysign', 'cos', 'cosh', 'degrees', 'erf', 'erfc', 'exp', 'expm1'; , 'fabs', 'factorial', 'floor', 'fmod'",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:11110,install,installed,11110,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['install'],['installed']
Deployability,"use; the master equation instead of the unitary Schrödinger equation.; Using the example with the spin dynamics from the previous section, we can; easily add a relaxation process (describing the dissipation of energy from the; spin to its environment), by adding sqrt(0.05) * sigmax() to; the previously empty list in the fourth parameter to the qutip.mesolve function:; In [14]: times = np.linspace(0.0, 10.0, 100). In [15]: result = mesolve(H, psi0, times, [sqrt(0.05) * sigmax()], [sigmaz(), sigmay()]). In [16]: import matplotlib.pyplot as plt. In [17]: fig, ax = plt.subplots(). In [18]: ax.plot(times, result.expect[0]);. In [19]: ax.plot(times, result.expect[1]);. In [20]: ax.set_xlabel('Time');. In [21]: ax.set_ylabel('Expectation values');. In [22]: ax.legend((""Sigma-Z"", ""Sigma-Y""));. In [23]: plt.show(fig). Here, 0.05 is the rate and the operator \(\sigma_x\) (qutip.operators.sigmax) describes the dissipation; process.; Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in its groundstate and the cavity in a 5-photon Fock state, the dynamics is calculated with the lines following code:; >>> times = linspace(0.0, 10.0, 200); >>> psi0 = tensor(fock(2,0), fock(10, 5)); >>> a = tensor(qeye(2), destroy(10)); >>> sm = tensor(destroy(2), qeye(10)); >>> H = 2 * pi * a.dag() * a + 2 * pi * sm.dag() * sm + \; >>> 2 * pi * 0.25 * (sm * a.dag() + sm.dag() * a); >>> result = mesolve(H, psi0, times, ntraj, [sqrt(0.1)*a], [a.dag()*a, sm.dag()*sm]); >>> from pylab import *; >>> plot(times, result.expect[0]); >>> plot(times, result.expect[1]); >>> xlabel('Time'); >>> ylabel('Expectation values'); >>> legend((""cavity photon number"", ""atom excitation probability"")); >>> show(). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-master.html:16371,update,updated,16371,docs/3.0.1/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-master.html,1,['update'],['updated']
Deployability,"ut. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; r""""""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html:8243,update,updated,8243,docs/4.6/modules/qutip/nonmarkov/transfertensor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/transfertensor.html,2,['update'],['updated']
Deployability,"utable types. (by Jake Lishman); Fixed comsumable iterators being used to parametrise some tests, preventing the testing suite from being re-run within the same session. (by Jake Lishman); Remove unused imports, simplify some floats and remove unnecessary list conversions. (by jakobjakobson13); Improve Travis jobs matrix for specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenB",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:16183,install,installing,16183,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,4,['install'],"['installation', 'installing']"
Deployability,"ute _isherm to True. (#2214 by AGaliciaMartinez); ssesolve average states to density matrices (#2216 reported by BenjaminDAnjou). Miscellaneous¶. Exclude cython 3.0.0 from requirement (#2204); Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28)¶; This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its tra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:4506,release,release,4506,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['release'],['release']
Deployability,"utip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg.; While either choice works on linux, it is best to choose ffmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: bloch_decay.mp4. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-bloch.html:14649,install,install,14649,docs/4.6/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html,2,['install'],['install']
Deployability,"utip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.superoperator import vec2mat; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state,; spmvpy_csr); from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup. from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, psi0, tlist, e_ops=[], args={}, options=None,; progress_bar=None,; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Evolve the state vector (`psi0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. psi0 : :class:`qutip.qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values.; Must be emp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:3402,integrat,integrating,3402,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['integrat'],['integrating']
Deployability,"utput of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Returns instance of OptimResult, which has attributes giving the. reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=-inf, amp_ubound=inf, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=10000000.0, dyn_type='GEN_MAT', prop_type='DEF', fid_type='DEF', phase_option=None, fid_err_scale_factor=None, amp_update_mode='ALL', init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters:drift : Qobj. the underlying dynamics generator of the system. ctrls : List of Qobj. a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj. starting point for the evolution.; Typically the identity matrix. target : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:142591,configurat,configuration,142591,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['configurat'],['configuration']
Deployability,"utput.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:21015,release,release,21015,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,2,"['release', 'update']","['release', 'updated']"
Deployability,"utput.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/changelog.html:23381,release,release,23381,docs/4.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.2/changelog.html,2,"['release', 'update']","['release', 'updated']"
Deployability,"utput.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/changelog.html:21719,release,release,21719,docs/4.1/changelog.html,https://qutip.org,https://qutip.org/docs/4.1/changelog.html,2,"['release', 'update']","['release', 'updated']"
Deployability,"uture.; The rest of this section describes the Qtrl implementation and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses that of pulse generators that generate different types of puls",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:15095,configurat,configuration,15095,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['configurat'],['configuration']
Deployability,"val(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), self.xvecs[0]). for n in range(N):; k_n = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += np.conjugate(k_n) * k_m * rho.data[m, n]. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/distributions.html:11915,update,update,11915,docs/4.0.2/modules/qutip/distributions.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/distributions.html,3,['update'],"['update', 'updated']"
Deployability,"val(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), self.xvecs[0]). for n in range(N):; k_n = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += np.conjugate(k_n) * k_m * rho.data[m, n]. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/distributions.html:11915,update,update,11915,docs/4.2/modules/qutip/distributions.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/distributions.html,3,['update'],"['update', 'updated']"
Deployability,"val(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), self.xvecs[0]). for n in range(N):; k_n = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += np.conjugate(k_n) * k_m * rho.data[m, n]. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/distributions.html:11915,update,update,11915,docs/4.1/modules/qutip/distributions.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/distributions.html,3,['update'],"['update', 'updated']"
Deployability,"valuations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_names = (; ""idx"", ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""fid_err"", ""grad_norm"", ""wall_time""; ). summary_property_fmt_type = (; 'd', 'd', 'd', 'd',; 'g', 'g', 'g'; ). summary_property_fmt_prec = (; 0, 0, 0, 0,; 4, 4, 2; ). def __init__(self):; self.reset(). def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.fid_err = None; self.grad_norm = None; self.wall_time = 0.0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/optimizer.html:41315,update,updated,41315,docs/4.4/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/optimizer.html,1,['update'],['updated']
Deployability,"vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=""avconv"", codec=""libx264""). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = video.encode(""base64""); video_tag = '<video controls src=""data:video/x-m4v;base64,{0}",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html:11931,update,update,11931,docs/3.1.0/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html,1,['update'],['update']
Deployability,"vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<video con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html:11337,update,update,11337,docs/4.2/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html,3,['update'],['update']
Deployability,"vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; return plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=writer, codec=codec). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = b64encode(video).decode(""ascii""); video_tag = '<vi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html:11335,update,update,11335,docs/4.3/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/ipynbtools.html,7,['update'],['update']
Deployability,"velopment; Working with the QuTiP Documentation; Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Changelog; Create a New Minor or Major Release; Create a Bug Fix Release. Build Release Distribution and Deploy; Build and Deploy; Download Built Files; Monitoring Progress (optional). Getting the Built Documentation; Making a Release on GitHub; Website; Copying New Files; HTML File Updates. Conda Forge. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:1275,deploy,deploy,1275,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,4,['deploy'],['deploy']
Deployability,"ven eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; Non-Markovian Solvers; Optimal control; Utility Functions. Change Log; Version 4.4.0 (July 03, 2019); Bug Fixes. Version 4.3.0 (July 14, 2018); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Indices and tables¶. Index; Module Index; Search Page. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/index.html:3879,release,released,3879,docs/4.4/index.html,https://qutip.org,https://qutip.org/docs/4.4/index.html,1,['release'],['released']
Deployability,"ven the Liouvillian; (or Hamiltonian) `L`. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """""". if issuper(L):. # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). # check if state is below error threshold; if abs(rho0.full().sum()) < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full().sum()) < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = rho0.full(); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(np.matrix(vv[:, i]).T, dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, -1.0j * w[i]); else:; out = eseries(qo, -1.0j * w[i]). else:; raise TypeError('First argument must be a Hamiltonian or Liouvillian.'). return estidy(out). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/essolve.html:6371,update,updated,6371,docs/4.0.2/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/essolve.html,1,['update'],['updated']
Deployability,"ven the Liouvillian; (or Hamiltonian) `L`. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """""". if issuper(L):. # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). # check if state is below error threshold; if abs(rho0.full().sum()) < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full().sum()) < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = rho0.full(); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(np.matrix(vv[:, i]).T, dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, -1.0j * w[i]); else:; out = eseries(qo, -1.0j * w[i]). else:; raise TypeError('First argument must be a Hamiltonian or Liouvillian.'). return estidy(out). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/essolve.html:6371,update,updated,6371,docs/4.2/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/essolve.html,1,['update'],['updated']
Deployability,"ven the Liouvillian; (or Hamiltonian) `L`. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """""". if issuper(L):. # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). # check if state is below error threshold; if abs(rho0.full().sum()) < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full().sum()) < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = rho0.full(); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(np.matrix(vv[:, i]).T, dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, -1.0j * w[i]); else:; out = eseries(qo, -1.0j * w[i]). else:; raise TypeError('First argument must be a Hamiltonian or Liouvillian.'). return estidy(out). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/essolve.html:6371,update,updated,6371,docs/4.1/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/essolve.html,1,['update'],['updated']
Deployability,"ver. """"""; def __init__(self):; self.solver = None; self.times = None; self.states = []; self.expect = []; self.num_expect = 0; self.num_collapse = 0; self.ntraj = None; self.seeds = None; self.col_times = None; self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; [docs]class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):; # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/solver.html:12990,update,update,12990,docs/4.5/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/solver.html,5,['update'],['update']
Deployability,"ver. """"""; def __init__(self):; self.solver = None; self.times = None; self.states = []; self.expect = []; self.num_expect = 0; self.num_collapse = 0; self.ntraj = None; self.seeds = None; self.col_times = None; self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:12955,update,update,12955,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,1,['update'],['update']
Deployability,"ver. """"""; def __init__(self):; self.solver = None; self.times = None; self.states = []; self.expect = []; self.num_expect = 0; self.num_collapse = 0; self.ntraj = None; self.seeds = None; self.col_times = None; self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/solver.html:11152,update,update,11152,docs/3.1.0/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/solver.html,3,['update'],['update']
Deployability,"ver. """"""; def __init__(self):; self.solver = None; self.times = None; self.states = []; self.expect = []; self.num_expect = 0; self.num_collapse = 0; self.ntraj = None; self.seeds = None; self.col_times = None; self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem; ; self.soft_reset(). def soft_reset(self):. # Hamiltonian",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:10687,update,update,10687,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,2,['update'],['update']
Deployability,"ver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-floquet.html:1432,integrat,integration,1432,docs/4.5/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-floquet.html,1,['integrat'],['integration']
Deployability,"verted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s wer",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:14248,update,updated,14248,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['update'],['updated']
Deployability,"vironment to install QuTiP in, the conda package manager provides a convenient way to do this.; To create a conda environment for QuTiP called qutip-env:; conda create -n qutip-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:5016,install,install,5016,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['install'],['install']
Deployability,"vis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary fil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:16623,release,release,16623,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['release'],['release']
Deployability,"volution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Bibliography. « Developers. Bibliography¶. [Hav03]Havel, T. Robust procedures for converting among Lindblad, Kraus and matrix representations of quantum dynamical semigroups. Journal of Mathematical Physics 44 2, 534 (2003). doi:10.1063/1.1518555. [Wat13]Watrous, J. Theory of Quantum Information, lecture notes. [Moh08]; Mohseni, A. T. Rezakhani, D. A. Lidar, Quantum-process tomography: Resource analysis of different strategies, Phys. Rev. A 77, 032322 (2008). doi:10.1103/PhysRevA.77.032322. [Gri98]; Grifoni, P. Hänggi, Driven quantum tunneling, Physics Reports 304, 299 (1998). doi:10.1016/S0370-1573(98)00022-2. [Cre03]. Creffield, Location of crossings in the Floquet spectrum of a driven two-level system, Phys. Rev. B 67, 165301 (2003). doi:10.1103/PhysRevB.67.165301. [Gar03]Gardineer and Zoller, Quantum Noise (Springer, 2004). [Bre02]H.-P. Breuer and F. Petruccione, The Theory of Open Quantum Systems (Oxford, 2002). [Coh92]; Cohen-Tannoudji, J. Dupont-Roc, G. Grynberg, Atom-Photon Interactions: Basic Processes and Applications, (Wiley, 1992). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/biblio.html:2551,update,updated,2551,docs/3.0.0/biblio.html,https://qutip.org,https://qutip.org/docs/3.0.0/biblio.html,1,['update'],['updated']
Deployability,"w Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/changelog.html:30445,release,release,30445,docs/4.5/changelog.html,https://qutip.org,https://qutip.org/docs/4.5/changelog.html,2,"['release', 'update']","['release', 'updated']"
Deployability,"w used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control, qutip.mcsolve, qutip.random_objects, and qutip.stochastic. (#1575 by Jake Lishman); Bumped the version of urllib3 used to build documentation from 1.26.4 to 1.26.5. (#1563 by dependabot); Moved tests to GitHub Actions. (#1551 by Jake Lishman); The GitHub contributing guidelines were re-added and updated to point to the more complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:14427,release,release,14427,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['release'],['release']
Deployability,"wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; dyn.get_num_ctrls(). # Create a pulse generator of the type specified; p_gen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn); p_gen.scaling = pulse_scaling; p_gen.offset = pulse_offset; p_gen.lbound = amp_lbound; p_gen.ubound = amp_ubound. # If the pulse is a periodic type, then set the pulse to be one complete; # wave; if isinstance(p_gen, pulsegen.PulseGenPeriodic):; p_gen.num_waves = 1.0; optim.pulse_generator = p_gen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + p_gen.__class__.__name__). return optim. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:31842,update,updated,31842,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['update'],['updated']
Deployability,"ward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_compute¶; float – Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls¶; integer – Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls¶; integer – Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute¶; integer – Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes¶; integer – Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes¶; integer – Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates¶; integer – Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter¶; float – Mean number of control amplitude updates per iteration. num_timeslot_changes¶; integer – Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update¶; float – Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes¶; integer – Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update¶; float – Mean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. parent¶; some control object (Dynamics or Optimizer) – aka the host. Object that generates the data",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:113792,update,updated,113792,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['update'],['updated']
Deployability,"we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Installation on MS Windows¶; We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work.; QuTiP uses dynamic compilation of C for some of its time-dependant dynamics solvers. For MS Windows users the additional challenge is the need for a ANSI C99 compliant C compiler. Unlike other platforms, no C compiler is provided with Windows by default.; It is possible to install a Windows SDK tha",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:6207,install,installed,6207,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,1,['install'],['installed']
Deployability,"which does have to be on the system drive. If this is not feasible, then it is possible to run QuTiP under Python 2.7. Windows and Python 2.7¶. Important; Running QuTiP under Python 2.7 on Windows is not recommended or supported. However, it is currently possible. There are no working conda-forge packages for Python 2.7 on Windows. You will have to install via pip or from source in Python 2.7 on Windows. The ‘MS Visual C for Python 2.7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” funct",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:7876,install,installed,7876,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,4,['install'],['installed']
Deployability,"which does have to be on the system drive. If this is not feasible, then it is possible to run QuTiP under Python 2.7. Windows and Python 2.7¶. Important; Running QuTiP under Python 2.7 on Windows is not recommended or supported. However, it is currently possible. There are no working conda-forge packages for Python 2.7 on Windows. You will have to install via pip or from source in Python 2.7 on Windows. The ‘MS Visual C for Python 2.7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the pytest testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” fun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/installation.html:8011,install,installed,8011,docs/4.5/installation.html,https://qutip.org,https://qutip.org/docs/4.5/installation.html,1,['install'],['installed']
Deployability,"which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:18323,release,release,18323,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,4,"['release', 'update']","['release', 'updated']"
Deployability,"which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:12536,release,release,12536,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,4,"['release', 'update']","['release', 'updated']"
Deployability,"width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. """"""; if not isket(ket):; raise Exception(""Schmidt plot works only for pure states, i.e. kets.""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). dim_list = ket.dims[0]. if splitting is None:; splitting = (len(dim_list) + 1) // 2. if isinstance(labels_iteration, int):; labels_iteration = labels_iteration, labels_iteration. ketdata = ket.full(). dim_list_y = dim_list[:splitting]; dim_list_x = dim_list[splitting:]. size_x = np.prod(dim_list_x); size_y = np.prod(dim_list_y). ketdata = ketdata.reshape((size_y, size_x)). dim_list_small_x = dim_list_x[:labels_iteration[1]]; dim_list_small_y = dim_list_y[:labels_iteration[0]]. quadrants_x = np.prod(dim_list_small_x); quadrants_y = np.prod(dim_list_small_y). ticks_x = [size_x / quadrants_x * (i + 0.5); for i in range(quadrants_x)]; ticks_y = [size_y / quadrants_y * (quadrants_y - i - 0.5); for i in range(quadrants_y)]. labels_x = [_sequence_to_latex(_index_to_sequence(i*size_x // quadrants_x,; dim_list=dim_list_x)); for i in range(quadrants_x)]; labels_y = [_sequence_to_latex(_index_to_sequence(i*size_y // quadrants_y,; dim_list=dim_list_y)); for i in range(quadrants_y)]. ax.set_xticks(ticks_x); ax.set_xticklabels(labels_x); ax.set_yticks(ticks_y); ax.set_yticklabels(labels_y); ax.set_xlabel(""last particles""); ax.set_ylabel(""first particles""). ax.imshow(complex_array_to_rgb(ketdata, theme=theme),; interpolation=""none"",; extent=(0, size_x, 0, size_y)). return fig, ax. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/visualization.html:43005,update,updated,43005,docs/4.6/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html,2,['update'],['updated']
Deployability,"will be drawn. ax : a matplotlib axis instance; The axis context in which the plot will be drawn. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. """"""; if not isket(ket):; raise Exception(""Schmidt plot works only for pure states, i.e. kets.""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). dim_list = ket.dims[0]. if splitting is None:; splitting = (len(dim_list) + 1) // 2. if isinstance(labels_iteration, int):; labels_iteration = labels_iteration, labels_iteration. ketdata = ket.full(). dim_list_y = dim_list[:splitting]; dim_list_x = dim_list[splitting:]. size_x = np.prod(dim_list_x); size_y = np.prod(dim_list_y). ketdata = ketdata.reshape((size_y, size_x)). dim_list_small_x = dim_list_x[:labels_iteration[1]]; dim_list_small_y = dim_list_y[:labels_iteration[0]]. quadrants_x = np.prod(dim_list_small_x); quadrants_y = np.prod(dim_list_small_y). ticks_x = [size_x / quadrants_x * (i + 0.5); for i in range(quadrants_x)]; ticks_y = [size_y / quadrants_y * (quadrants_y - i - 0.5); for i in range(quadrants_y)]. labels_x = [_sequence_to_latex(_index_to_sequence(i*size_x // quadrants_x,; dim_list=dim_list_x)); for i in range(quadrants_x)]; labels_y = [_sequence_to_latex(_index_to_sequence(i*size_y // quadrants_y,; dim_list=dim_list_y)); for i in range(quadrants_y)]. ax.set_xticks(ticks_x); ax.set_xticklabels(labels_x); ax.set_yticks(ticks_y); ax.set_yticklabels(labels_y); ax.set_xlabel(""last particles""); ax.set_ylabel(""first particles""). ax.imshow(complex_array_to_rgb(ketdata, theme=theme),; interpolation=""none"",; extent=(0, size_x, 0, size_y)). return fig, ax. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/visualization.html:48703,update,updated,48703,docs/4.7/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html,2,['update'],['updated']
Deployability,"will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; shp = self.drift_dyn_gen.shape; n_ts = self.num_tslots; self.decomp_curr = [False for x in range(n_ts)]; self.prop_eigen = \; [np.empty(shp[0], dtype=complex) for x in range(n_ts)]; self.dyn_gen_eigenvectors = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]; self.dyn_gen_factormatrix = \; [np.empty(shp, dtype=complex) for x in range(n_ts)]. def _check_test_out_files(self):; cfg = self.config; if cfg.any_test_files():; if not cfg.check_create_test_out_dir():; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; # Note this call is made just to initialise the num_ctrls attrib; self.get_num_ctrls(). if init_tslots:; self.init_time_slots(); self._init_lists(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:14947,configurat,configuration,14947,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['configurat'],['configuration']
Deployability,"will update your conda to the latest version, but this can lead to breaking your default Ananconda enviroment.; Alternatively, this will add conda-forge as the highest priority channel.; conda config --add channels conda-forge. It is almost certainly better to have defaults as the highest priority channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html. and the latest source code is available in our Github repository. http://github.com/qutip. In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Window",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/installation.html:4946,release,release,4946,docs/4.4/installation.html,https://qutip.org,https://qutip.org/docs/4.4/installation.html,2,['release'],['release']
Deployability,"with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-changelog and then jump to release.; For a bug fix to an existing release, do update-changelog and then jump to bugfix.; Changes that are not backwards-compatible may only be made in a major release.; New features that do not affect backwards-compatibility can be made in a minor release.; Bug fix releases should be small, only fix bugs, and not introduce any new features.; There are a few steps that should have been kept up-to-date during day-to-day development, but might not be quite accurate.; For every change that is going to be part of your release, make sure that:. The user guide in the documentation is updated with any new features, or changes to existing features.; Any new API classes or functions have entries in a suitable RST file in doc/apidoc.; Any new or changed docstrings are up-to-date and render correctly in the API documentation. Please make a normal PR to master correcting anything missing from these points and have it merged before you begin the release, if necessary. Updating the Changelog¶; This needs to be done no matter what type of release is being made. Create a new branch to use to make a pull request.; Update the changelog using towncrier:; towncrier build –version=<version-number>. Where <version-number> is the expected version number of the release. Make a pull request on the main qutip/qutip repository with this changelog, and get other members of the admin team to approve it.; Merge this into master. Now jump to release if you are making a major or minor release, or bugfix if you are",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:2547,release,release,2547,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['release'],['release']
Deployability,"without making a pull request.; Create a second new branch, which will be pushed to your fork and used to make a pull request against the qutip-<major>.<minor>.X branch on qutip/qutip you just created.; You can call this branch whatever you like because it is not going to the main repository, for example git checkout -b prepare-qutip-4.7.0. Change the VERSION file to contain the new version number exactly, removing the .dev suffix.; For example, if you are releasing the first release of the minor 4.7 track, set VERSION to contain the string 4.7.0.; (Special circumstances: if you are making an alpha, beta or release candidate release, append a .a<n>, .b<n> or .rc<n> to the version string, where <n> is an integer starting from 0 that counts how many of that pre-release track there have been.); Edit setup.cfg by changing the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes (git add VERSION setup.cfg; git commit -m ""Set release mode for 4.7.0""), and then push them to your fork (git push -u origin prepare-qutip-4.7.0). Using GitHub, make a pull request to the release branch (e.g. qutip-4.7.X) using this branch that you just created.; You will need to change the “base branch” in the pull request, because GitHub will always try to make the PR against master at first.; When the tests have passed, merge this in.; Finally, back on master, make a new pull request that changes the VERSION file to be <next-expected-version>.dev, for example 4.8.0.dev.; The “Development Status” in setup.cfg on master should not have changed, and should be; Development Status :: 2 - Pre-Alpha. because master is never directly released. You should now have a branch that you can see on the GitHub website that is called qutip-4.7.X (or whatever minor version), and the state of the code in it should be exactly what you want to release as the new minor release.; If you notice you have made a mistake, you can make additional pull re",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:5478,release,release,5478,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['release'],['release']
Deployability,"wn-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:11241,install,installed,11241,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,4,['install'],['installed']
Deployability,"ws¶; QuTiP is primarily developed for Unix-based platforms such as Linux an Mac OS X, but it can also be used on Windows. We have limited experience and ability to help troubleshoot problems on Windows, but the following installation steps have been reported to work:. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32. [build_ext]; compiler = mingw32. The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above. Obtain the QuTiP source code and installed it following the instructions given above. Note; In some cases, to get the dynamic compilation of Cython code to work, it; might be necessary to edit the PATH variable and make sure that; C:\MinGW32-xy\bin appears either first in the PATH list, or possibly; right after C:\Python27\Lib\site-packages\PyQt4. This is to make sure; that the right version of the MinGW compiler is used if more than one; is installed (not uncommon under Windows, since many packages are; distributed and installed with their own version of all dependencies). Optional Installation Options¶. UMFPACK Linear Solver¶; As of SciPy 0.14+, the umfpack linear solver routines for solving large-scale sparse linear systems have been replaced due to licensing restrictions. The default method for all sparse linear problems is now the SuperLU library. However, scipy still includes the ability to call the umfpack library via the scikits.umfpack module. In our experience, the umfpack solver is 2-5x faster than the SuperLU routi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:9406,install,installed,9406,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,2,['install'],['installed']
Deployability,"ws¶; QuTiP is primarily developed for Unix-based platforms such as Linux an Mac OS X, but it can also be used on Windows. We have limited experience and ability to help troubleshoot problems on Windows, but the following installation steps have been reported to work:. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32. [build_ext]; compiler = mingw32. The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above. Obtain the QuTiP source code and installed it following the instructions given above. Note; In some cases, to get the dynamic compilation of Cython code to work, it; might be necessary to edit the PATH variable and make sure that; C:\MinGW32-xy\bin appears either first in the PATH list, or possibly; right after C:\Python27\Lib\site-packages\PyQt4. This is to make sure; that the right version of the MinGW compiler is used if more than one; is installed (not uncommon under Windows, since many packages are; distributed and installed with their own version of all dependencies). Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:9314,install,installed,9314,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,1,['install'],['installed']
Deployability,"wyth University) - Code contributor; Amit Jamadagni - Bug fix; Anders Lund (Technical University of Denmark) - Bug hunting for the Monte-Carlo solver; Andre Carvalho - Bug hunter; André Xuereb (University of Hannover) - Bug hunter; Anubhav Vardhan (IIT, Kanpur) - Bug hunter, Code contributor, Documentation; Arne Grimsmo (University of Auckland) - Bug hunter, Code contributor; Ben Criger (Waterloo IQC) - Code contributor; Bredan Abolins (Berkeley) - Bug hunter; Chris Granade - Code contributor; Claudia Degrandi (Yale University) - Documentation; Dawid Crivelli - Bug hunter; Denis Vasilyev (St. Petersburg State University) - Code contributor; Dong Zhou (Yale University) - Bug hunter; Florian Ong (Institute for Quantum Computation) - Bug hunter; Frank Schima - Macports packaging; Henri Nielsen (Technical University of Denmark) - Bug hunter; Hwajung Kang (Systems Biology Institute, Tokyo) - Suggestions for improving Bloch class; James Clemens (Miami University - Ohio) - Bug hunter; Johannes Feist - Code contributor; Jonas Hörsch - Code contributor; Jonas Neergaard-Nielsen (Technical University of Denmark) - Code contributor, Windows support; JP Hadden (University of Bristol) - Code contributor, improved Bloch sphere visualization; Kevin Fischer (Stanford) - Code contributor; Laurence Stant - Documentation; Markus Baden (Centre for Quantum Technologies, Singapore) - Code contributor, Documentation; Myung-Joong Hwang (Pohang University of Science and Technology) - Bug hunter; Neill Lambert (RIKEN) - Code contributor, Windows support; Nikolas Tezak (Stanford) - Code contributor; Per Nielsen (Technical University of Denmark) - Bug hunter, Code contributor; Piotr Migdał (ICFO) - Code contributor; Reinier Heeres (Yale University) - Code contributor; Robert Jördens (NIST) - Linux packaging; Simon Whalen - Code contributor; W.M. Witzel - Bug hunter. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/contributors.html:3811,update,updated,3811,docs/3.1.0/contributors.html,https://qutip.org,https://qutip.org/docs/3.1.0/contributors.html,1,['update'],['updated']
Deployability,"x == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; rates, ampl = [], []; for ur_key in unique_rates.keys():; total_ampl = sum(ampl_dict[ur_key]); if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); self.rates = np.array(rates); self.ampl = np.empty((len(ampl),), dtype=object); self.ampl[:] = ampl; return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/eseries.html:11329,update,updated,11329,docs/4.6/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/eseries.html,2,['update'],['updated']
Deployability,"xecution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact¶; boolean – indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of mess",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:91192,configurat,configuration,91192,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['configurat'],['configuration']
Deployability,"xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Changelog Generation¶; We use towncrier for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named <PR number>.<change type> in the doc/changes directory, where the PR number should be substituted for <PR number>, and <change type> is either feature, bugfix, doc, removal, misc, or deprecation,; depending on the type of change included in the PR.; You can also create this file by installing towncrier and running. towncrier create <PR number>.<change type>. Running this will create a file in the doc/changes directory with a filename corresponding to the argument you passed to towncrier create.; In this file, you should add a short description of the changes that the PR introduces. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/contributing.html:9639,install,installing,9639,docs/4.7/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html,2,['install'],['installing']
Deployability,"xp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters. NintShape of output quantum operator. densityfloatDensity between [0,1] of output Unitary operator. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:43267,configurat,configuration,43267,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['configurat'],['configuration']
Deployability,"xpect[1], '--', lw=2); Out[31]: ; [<matplotlib.lines.Line2D at 0x1096d45d0>,; <matplotlib.lines.Line2D at 0x1096d47d0>]. In [32]: title('Monte Carlo time evolution'); Out[32]: <matplotlib.text.Text at 0x107db4790>. In [33]: xlabel('Time', fontsize=14); Out[33]: <matplotlib.text.Text at 0x1078fcd10>. In [34]: ylabel('Expectation values', fontsize=14); Out[34]: <matplotlib.text.Text at 0x107df7150>. In [35]: legend((""cavity photon number"", ""atom excitation probability"")); Out[35]: <matplotlib.legend.Legend at 0x107a31b90>. In [36]: show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has enhanced performance for systems with small Hilbert space dimensionality. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstration; In [37]: data1 = mcsolve_f90(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a list of trajectories to ntraj. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html:17496,update,updated,17496,docs/3.1.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html,1,['update'],['updated']
Deployability,"xperimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting dynamics.oper_dtype = <type>; Note this can be done by passing dyn_params={'oper_dtype':<type>} in any of the pulseoptim functions.; Some other properties a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:4112,configurat,configuration,4112,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,8,['configurat'],['configuration']
Deployability,"xt = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html:24436,update,updated,24436,docs/4.0.2/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/control/fidcomp.html,1,['update'],['updated']
Deployability,"xt = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html:24436,update,updated,24436,docs/4.2/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/fidcomp.html,1,['update'],['updated']
Deployability,"xt = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:24436,update,updated,24436,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,1,['update'],['updated']
Deployability,"y for simulating quantum dyanmics.; Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure¶; With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:3572,Install,Installation,3572,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,2,['Install'],['Installation']
Deployability,"y list conversions. (by jakobjakobson13); Improve Travis jobs matrix for specifying the testing containers. (by Jake Lishman); Fix coverage reporting on Travis. (by Jake Lishman); Added a pyproject.toml file. (by Simon Humpohl and Eric Giguère); Add doctests to documentation. (by Sidhant Saraogi); Fix all warnings in the documentation build. (by Jake Lishman). Version 4.5.3 (February 19, 2021)¶; This patch release adds support for Numpy 1.20, made necessary by changes to how array-like objects are handled. There are no other changes relative to version 4.5.2.; Users building from source should ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:16440,install,installation,16440,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['install'],['installation']
Deployability,"y merge conflicts.; Once the tests have passed and you have another admin’s approval, merge the PR. You should now see that the qutip-4.6.X (or whatever) branch on GitHub has been updated, and now includes all the changes you have just made.; If you have made a mistake, feel free to make additonal PRs to rectify the situation.; You are now ready to actually perform the release.; Go to deploy. Build Release Distribution and Deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and Deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:11479,release,release,11479,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['release'],['release']
Deployability,"y setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; state_norm_func=None, dims=None):; """"""; Internal function for solving ODEs.; """""". #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y). return output. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:18829,update,update,18829,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,4,"['integrat', 'update']","['integrate', 'integration', 'update', 'updated']"
Deployability,"y using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:4690,release,release,4690,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['release'],['release']
Deployability,"y.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:12205,release,release,12205,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['release'],['release']
Deployability,"y.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:7457,release,release,7457,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['release'],['release']
Deployability,"yCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:41719,integrat,integratorstr,41719,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,"['Integrat', 'integrat']","['Integrator', 'integratorstr']"
Deployability,"yCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem coll",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:34724,integrat,integratorstr,34724,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['integrat'],['integratorstr']
Deployability,"you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:9429,release,release,9429,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,3,"['Release', 'release']","['Releases', 'release']"
Deployability,"ystem Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; needed instead. When we are modeling an open system, or an ensemble; of systems, the use of the density matrix is mandatory.; Collapse operators are used to model the collapse of the state vector; that can occur when a measurement is performed.; The following tables lists some of the solvers QuTiP provides for dynamic quantum systems and indicates the type of object; returned by the solver:. QuTiP Solvers¶. Solver; Returns; Remarks. sesolve(); qutip.solver.Result; Unitary evolution, single system. mesolve(); qutip.solver.Result; Lindblad master eqn. or Von Neuman eqn. Density matrix. mcsolve(); qutip.solver.Result; Monte Carlo with collapse operators. essolve(); Array of expectation values; Exponential series with collapse operators. bloch_redfield_solve(); qutip.solver. floquet_markov_solve(); qutip.solver.Result; Floquet-Markov master equation. fmmesolve(); qutip.solver; Floquet-Markov master equation. smesolve(); qutip.solver.Result; Stochastic master equation. ssesolve(); qutip.solver.Result; Stochastic Schrödinger equation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:3141,update,updated,3141,docs/4.7/guide/dynamics/dynamics-intro.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html,2,['update'],['updated']
Deployability,"ystem Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. On Windows you should create a Python 3.5+ environment. The default Anaconda environment has all the Python packages needed for running QuTiP. You may however wish to install QuTiP in a Conda environment (env) other than the default Anaconda environment. You may wish to install Miniconda instead if you need to be economical with disk space. However, if you are not familiar with conda environments and only plan to use if for QuTiP, then you should probably work with a default Anaconda / Miniconda environment.; To create a Conda env for QuTiP called qutip-env:; conda create -n qutip-env python=3. Note the python=3 can be ommited if you want the default Python version for the Anaconda / Miniconda install.; If you have created a specific conda environment, or you have installed Miniconda, then you will need to install the required packages for QuTiP.; recommended:; conda install numpy scipy cython matplotlib nose jupyter notebook spyder. minimum (recommended):; conda install numpy scipy cython nose matplotlib. absolute mimimum:; conda install numpy scipy cython. The jupyter and notebook packages are for working with Jupyter notebooks (fka IPython notebooks). Spyder is an IDE for scie",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:2576,install,install,2576,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,1,['install'],['install']
Deployability,"ystems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:6150,update,updated,6150,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,4,['update'],['updated']
Deployability,"ystems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:7327,update,updated,7327,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,6,['update'],['updated']
Deployability,"ython 2.7 on Windows. The ‘MS Visual C for Python 2.7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/installation.html:8353,install,installing,8353,docs/4.3/installation.html,https://qutip.org,https://qutip.org/docs/4.3/installation.html,6,"['install', 'update']","['installation', 'installed', 'installing', 'updated']"
Deployability,"ython on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶; The default Anaconda environment has all the Python packages needed for running QuTiP.; You may however wish to install QuTiP in a Conda environment (env) other than the default Anaconda environment.; You may wish to this for many reasons:. It is a good idea generally; You are using MS Windows and want to use Python 3; You are using Miniconda because you do not have the disk space for full Anaconda. To create a Conda env for QuTiP called qutip:-; (note the python=3 can be ommited if you want the default Python version, if you want to use Python 3 with MS Windows, then it must be python=3.4); recommended:; conda create -n qutip python=3 mkl numpy scipy cython matplotlib nose multiprocess jupyter notebook spyder. minimum (recommended):; conda create -n qutip numpy scipy cython nose matplotlib. absolute mimimum:; conda create -n qutip numpy scipy cython. The jupyter and notebook packages are for working with Jupyter notebooks (fka IPython notebooks).; Spyder is an IDE for scientific development with Python. Adding the conda-forge channel¶; If you have conda 4.1.0 or later then, add the conda-forge channel with lowest priority us",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:3006,install,install,3006,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,1,['install'],['install']
Deployability,"ython setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Installation on MS Windows¶; We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work.; QuTiP uses dynamic compilation of C for some of its time-dependant dynamics solvers. For MS Windows users the additional challenge is the need for a ANSI C99 compliant C compiler. Unlike other platforms, no C compiler is provided with Windows by default.; It is possible to install a Windows SDK that includes a C compiler, but ANSI C99 compliance is not 100%.; The mingw-w64 project looks to help overcome this, and to some extent it is successful.; The conda-forge packages for QuTiP will also install the Mingwpy package, which uses mingw-w64.; Currently we are only able get QuTiP working with Python <= 3.4. Python >= 3.5 is compiled with a ne",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:6618,install,installed,6618,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,1,['install'],['installed']
Deployability,"ython; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Functions. Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; API documentation. API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Krylov Subspace Solver; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Next ; Previous. © Copyright 2011 to 2",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/apidoc.html:1130,Continuous,Continuous,1130,docs/4.7/apidoc/apidoc.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/apidoc.html,1,['Continuous'],['Continuous']
Deployability,"yval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), self.xvecs[0]). for n in range(N):; k_n = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += np.conjugate(k_n) * k_m * rho.data[m, n]. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/distributions.html:11915,update,update,11915,docs/4.3/modules/qutip/distributions.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/distributions.html,3,['update'],"['update', 'updated']"
Deployability,"zation of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-basics.html:1857,install,installation,1857,docs/3.1.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html,1,['install'],['installation']
Deployability,"zation of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Performance (QuTiP vs. qotoolbox). « Floquet Formalis... Setting Options ... ». Performance (QuTiP vs. qotoolbox)¶; Here we compare the performance of the master equation and Monte Carlo solvers to their quantum optics toolbox counterparts.; In this example, we calculate the time evolution of the density matrix for a coupled oscillator system using the qutip.mesolve function, and compare it to the quantum optics toolbox (qotoolbox). Here, we see that the QuTiP solver out performs its qotoolbox counterpart by a substantial margin as the system size increases. To test the Monte Carlo solvers, here we simulate a trilinear Hamiltonian over a range of Hilbert space sizes. Since QuTiP uses multiprocessing, we can measure the performance gain when using several CPU’s. In contrast, the qotoolbox is limited to a single processor only. In the legend, we show the speed-up factor in the parenthesis, which should ideally be equal to the number of processors. Finally, we have included the results using hyperthreading, written here as 4+(x) where x is the number of hyperthreads, found in some newer Intel processors. We see however that the performance benefits from hyperthreading are marginal at best. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-performance.html:2780,update,updated,2780,docs/3.0.1/guide/dynamics/dynamics-performance.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-performance.html,1,['update'],['updated']
Deployability,"{0.type} ""; ""and superrep = {0.superrep} to supermatrix not ""; ""supported."".format(q_oper); ). [docs]def to_kraus(q_oper):; """"""; Converts a Qobj representing a quantum map to a list of quantum objects,; each representing an operator in the Kraus decomposition of the given map. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to Kraus representation. If; ``q_oper`` is ``type=""oper""``, then it is taken to act by conjugation,; such that ``to_kraus(A) == to_kraus(sprepost(A, A.dag())) == [A]``. Returns; -------; kraus_ops : list of Qobj; A list of quantum objects, each representing a Kraus operator in the; decomposition of ``q_oper``. Raises; ------; TypeError: if the given quantum object is not a map, or cannot be; decomposed into Kraus operators.; """"""; if q_oper.type == 'super':; if q_oper.superrep in (""super"", ""chi""):; return to_kraus(to_choi(q_oper)); elif q_oper.superrep == 'choi':; return choi_to_kraus(q_oper); elif q_oper.type == 'oper': # Assume unitary; return [q_oper]; else:; raise TypeError(; ""Conversion of Qobj with type = {0.type} ""; ""and superrep = {0.superrep} to Kraus decomposition not ""; ""supported."".format(q_oper); ). def to_stinespring(q_oper):; r""""""; Converts a Qobj representing a quantum map $\Lambda$ to a pair of partial isometries; $A$ and $B$ such that $\Lambda(X) = \Tr_2(A X B^\dagger)$ for all inputs $X$, where; the partial trace is taken over a a new index on the output dimensions of $A$ and $B$. For completely positive inputs, $A$ will always equal $B$ up to precision errors. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to a Stinespring pair. Returns; -------; A, B : Qobj; Quantum objects representing each of the Stinespring matrices for the input Qobj.; """"""; return choi_to_stinespring(to_choi(q_oper)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html:18714,update,updated,18714,docs/4.0.2/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/superop_reps.html,1,['update'],['updated']
Deployability,"{0.type} ""; ""and superrep = {0.superrep} to supermatrix not ""; ""supported."".format(q_oper); ). [docs]def to_kraus(q_oper):; """"""; Converts a Qobj representing a quantum map to a list of quantum objects,; each representing an operator in the Kraus decomposition of the given map. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to Kraus representation. If; ``q_oper`` is ``type=""oper""``, then it is taken to act by conjugation,; such that ``to_kraus(A) == to_kraus(sprepost(A, A.dag())) == [A]``. Returns; -------; kraus_ops : list of Qobj; A list of quantum objects, each representing a Kraus operator in the; decomposition of ``q_oper``. Raises; ------; TypeError: if the given quantum object is not a map, or cannot be; decomposed into Kraus operators.; """"""; if q_oper.type == 'super':; if q_oper.superrep in (""super"", ""chi""):; return to_kraus(to_choi(q_oper)); elif q_oper.superrep == 'choi':; return choi_to_kraus(q_oper); elif q_oper.type == 'oper': # Assume unitary; return [q_oper]; else:; raise TypeError(; ""Conversion of Qobj with type = {0.type} ""; ""and superrep = {0.superrep} to Kraus decomposition not ""; ""supported."".format(q_oper); ). def to_stinespring(q_oper):; r""""""; Converts a Qobj representing a quantum map $\Lambda$ to a pair of partial isometries; $A$ and $B$ such that $\Lambda(X) = \Tr_2(A X B^\dagger)$ for all inputs $X$, where; the partial trace is taken over a a new index on the output dimensions of $A$ and $B$. For completely positive inputs, $A$ will always equal $B$ up to precision errors. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to a Stinespring pair. Returns; -------; A, B : Qobj; Quantum objects representing each of the Stinespring matrices for the input Qobj.; """"""; return choi_to_stinespring(to_choi(q_oper)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/superop_reps.html:18714,update,updated,18714,docs/4.2/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/superop_reps.html,1,['update'],['updated']
Deployability,"{0.type} ""; ""and superrep = {0.superrep} to supermatrix not ""; ""supported."".format(q_oper); ). [docs]def to_kraus(q_oper):; """"""; Converts a Qobj representing a quantum map to a list of quantum objects,; each representing an operator in the Kraus decomposition of the given map. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to Kraus representation. If; ``q_oper`` is ``type=""oper""``, then it is taken to act by conjugation,; such that ``to_kraus(A) == to_kraus(sprepost(A, A.dag())) == [A]``. Returns; -------; kraus_ops : list of Qobj; A list of quantum objects, each representing a Kraus operator in the; decomposition of ``q_oper``. Raises; ------; TypeError: if the given quantum object is not a map, or cannot be; decomposed into Kraus operators.; """"""; if q_oper.type == 'super':; if q_oper.superrep in (""super"", ""chi""):; return to_kraus(to_choi(q_oper)); elif q_oper.superrep == 'choi':; return choi_to_kraus(q_oper); elif q_oper.type == 'oper': # Assume unitary; return [q_oper]; else:; raise TypeError(; ""Conversion of Qobj with type = {0.type} ""; ""and superrep = {0.superrep} to Kraus decomposition not ""; ""supported."".format(q_oper); ). def to_stinespring(q_oper):; r""""""; Converts a Qobj representing a quantum map $\Lambda$ to a pair of partial isometries; $A$ and $B$ such that $\Lambda(X) = \Tr_2(A X B^\dagger)$ for all inputs $X$, where; the partial trace is taken over a a new index on the output dimensions of $A$ and $B$. For completely positive inputs, $A$ will always equal $B$ up to precision errors. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to a Stinespring pair. Returns; -------; A, B : Qobj; Quantum objects representing each of the Stinespring matrices for the input Qobj.; """"""; return choi_to_stinespring(to_choi(q_oper)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html:18714,update,updated,18714,docs/4.1/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html,1,['update'],['updated']
Deployability,"}` are the; coefficients specified by the list of kets. Each ket has 2l+1 components; for some integer l. The first entry of the ket defines the coefficient; c_{l,-l}, while the last entry of the ket defines the; coefficient c_{l, l}. Parameters; ----------; theta : int/float/list/array; Polar angles in [0, pi]. phi : int/float/list/array; Azimuthal angles in [0, 2*pi]. args : list/array; ``list`` of ket vectors. Returns; -------; ``array`` for angular wave function evaluated at all; possible combinations of theta and phi. """"""; if isinstance(args[0], list):; # use the list in args[0]; args = args[0]. # convert to numpy array; theta = np.atleast_1d(theta); phi = np.atleast_1d(phi); # check that arrays are only 1D; if len(theta.shape) != 1:; raise ValueError('Polar angles theta must be 1D list'); if len(phi.shape) != 1:; raise ValueError('Azimuthal angles phi must be 1D list'). # make meshgrid; phi_mesh, theta_mesh = np.meshgrid(phi, theta); # setup empty wavefunction; psi = np.zeros([theta.shape[0], phi.shape[0]], dtype=complex); # iterate through provided kets; for k in range(len(args)):; ket = args[k]; if ket.type == 'bra':; ket = ket.conj(); elif not ket.type == 'ket':; raise TypeError('Invalid type for input ket in orbital'); # Extract l value from the state; l = (ket.shape[0] - 1) / 2.0; if l != np.floor(l):; raise ValueError(; 'Kets must have odd number of components in orbital'); l = int(l); # get factors from ket; factors = ket.full(); # iterate through the possible m. for i in range(len(factors)):; # set correct m; m = i - l; # calculate spherical harmonics; # note that theta and phi are interchanged in scipy implementation; res = sph_harm(m, l, phi_mesh, theta_mesh); psi += factors[i] * res. # flatten output if only one row; if psi.shape[1] == 1:; psi = psi.flatten(). return psi. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/orbital.html:2629,update,updated,2629,docs/4.7/modules/qutip/orbital.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/orbital.html,2,['update'],['updated']
Deployability,"‘iterative-lgmres’, SVD ‘svd’ (dense), or inverse-power method ‘power’. sparse : bool, optional, default=True. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default=True. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default=False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. use_umfpack : bool {False, True}. Use umfpack solver instead of SuperLU. For SciPy 0.14+, this option; requires installing scikits.umfpack. maxiter : int, optional, default=10000. Maximum number of iterations to perform if using an iterative method. tol : float, optional, default=1e-9. Tolerance used for terminating solver solution when using iterative; solvers. permc_spec : str, optional, default=’COLAMD’. Column ordering used internally by superLU for the ‘direct’ LU; decomposition method. Options include ‘COLAMD’ and ‘NATURAL’.; If using RCM then this is set to ‘NATURAL’ automatically unless; explicitly specified. use_precond : bool optional, default = True. ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional. Preconditioner for A. The preconditioner should approximate the inverse; of A. Effective preconditioning dramatically improves the rate of; convergence, for iterative methods only . If no ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:71030,install,installing,71030,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['install'],['installing']
Deployability,"‘iterative-lgmres’, SVD ‘svd’ (dense), or inverse-power method ‘power’. sparse : bool, optional, default=True. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default=True. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default=False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. use_umfpack : bool {False, True}. Use umfpack solver instead of SuperLU. For SciPy 0.14+, this option; requires installing scikits.umfpack. maxiter : int, optional, default=10000. Maximum number of iterations to perform if using an iterative method. tol : float, optional, default=1e-9. Tolerance used for terminating solver solution when using iterative; solvers. permc_spec : str, optional, default=’NATURAL’. Column ordering used internally by superLU for the ‘direct’ LU; decomposition method. Options include ‘NATURAL and ‘COLAMD’.; If not using RCM then this is set to ‘COLAMD’ automatically unless; explicitly specified. use_precond : bool optional, default = True. ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional. Preconditioner for A. The preconditioner should approximate the inverse; of A. Effective preconditioning dramatically improves the rate of; convergence, for iterative methods only . If ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:70967,install,installing,70967,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['install'],['installing']
Deployability,"” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Conf",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:5932,Update,Update,5932,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,1,['Update'],['Update']
Deployability,"﻿. API documentation — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . API documentation. « Modifying Intern... Classes ». API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; eseries; Bloch sphere. Solver Options and Results; Distribution functions. Quantum information processing. Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Lev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/apidoc.html:244,install,installation,244,docs/3.1.0/apidoc/apidoc.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/apidoc.html,1,['install'],['installation']
Deployability,"﻿. An Overview of the Eseries Class — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-eseries.html:259,install,installation,259,docs/3.1.0/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-eseries.html,1,['install'],['installation']
Deployability,"﻿. Basic Operations on Quantum Objects — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-basics.html:262,install,installation,262,docs/3.1.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html,1,['install'],['installation']
Deployability,"﻿. Bibliography — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Bibliography. « Developers. Bibliography¶. [Hav03]Havel, T. Robust procedures for converting among Lindblad, Kraus and matrix representations of quantum dynamical semigroups. Journal of Mathematical Physics 44 2, 534 (2003). doi:10.1063/1.1518555. [Wat13]Watrous, J. Theory of Quantum Information, lecture notes. [Moh08]; Mohseni, A. T. Rezakhani, D. A. Lidar, Quantum-process tomography: Resource analysis of different strategies, Phys. Rev. A 77, 032322 (2008). doi:10.1103/PhysRevA",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/biblio.html:239,install,installation,239,docs/3.1.0/biblio.html,https://qutip.org,https://qutip.org/docs/3.1.0/biblio.html,1,['install'],['installation']
Deployability,"﻿. Bloch-Redfield master equation — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. « Monte Carlo Solv... Solving Problems... ». Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html:257,install,installation,257,docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html,1,['install'],['installation']
Deployability,"﻿. Bloch-Redfield master equation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, an",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:121,Install,Installation,121,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,1,['Install'],['Installation']
Deployability,"﻿. Change Log — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Change Log; Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fix",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:237,install,installation,237,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,1,['install'],['installation']
Deployability,"﻿. Classes — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Classes; Qobj; eseries; Bloch sphere. Solver Options and Results; Distribution functions. Quantum information processing. Optimal control. « API documentatio... Classes¶. Qobj¶. class Qobj(inpt=None, dims=[[], []], shape=[], type=None, isherm=None, fast=False, superrep=None)¶; A class for representing quantum objects, such as quantum operators; and states.; The Qobj class is the QuTiP representation of quantum operators and state; vectors. This class also implements math operations +,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:234,install,installation,234,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['install'],['installation']
Deployability,"﻿. Developers — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Developers; Lead Developers; Contributors. « Change Log. Bibliography ». Developers¶. Lead Developers¶; Robert Johansson (RIKEN); Paul Nation (Korea University). Contributors¶. Note; Anyone is welcome to contribute to QuTiP. If you are interested in helping, please let us know!. alexbrc (github user) - Code contributor; Alexander Pitchford (Aberystwyth University) - Code contributor; Amit Jamadagni - Bug fix; Anders Lund (Technical University of Denmark) - Bug hunting for the Monte",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/contributors.html:237,install,installation,237,docs/3.1.0/contributors.html,https://qutip.org,https://qutip.org/docs/3.1.0/contributors.html,1,['install'],['installation']
Deployability,"﻿. Dynamics Simulation Results — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. « Time Evolution a... Lindblad Master ... ». Dynamics Simulation Results¶. Important; In QuTiP 2, the results from all of the dynamics solvers are returned as Odedata objects. This unified and significantly simplified postprocessing of simulation results from different solvers, compared to QuTiP 1. However, this change also results in the loss of backward",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-data.html:254,install,installation,254,docs/3.1.0/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-data.html,1,['install'],['installation']
Deployability,"﻿. Floquet Formalism — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independen",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:231,install,installation,231,docs/3.0.0/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html,1,['install'],['installation']
Deployability,"﻿. Floquet Formalism — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hami",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-floquet.html:231,install,installation,231,docs/3.0.1/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-floquet.html,1,['install'],['installation']
Deployability,"﻿. Floquet Formalism — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Setting Options ... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-floquet.html:244,install,installation,244,docs/3.1.0/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-floquet.html,1,['install'],['installation']
Deployability,"﻿. Floquet Formalism — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms sho",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:108,Install,Installation,108,docs/4.6/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html,1,['Install'],['Installation']
Deployability,"﻿. Frontmatter — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. « QuTiP: Quantum T... Installation ». Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Address:Department of Physics, Korea University,; Seongbuk-gu Seoul",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/frontmatter.html:238,install,installation,238,docs/3.1.0/frontmatter.html,https://qutip.org,https://qutip.org/docs/3.1.0/frontmatter.html,1,['install'],['installation']
Deployability,"﻿. Frontmatter — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; QuTiP Plugins; Libraries Using QuTiP; Contributing to QuTiP. Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.7.5. copyright; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the Copyright and Licensing page of this documentation. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quan",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/frontmatter.html:955,release,release,955,docs/4.7/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html,1,['release'],['release']
Deployability,"﻿. Functions — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; References; Notes. Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Ser",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:236,install,installation,236,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['install'],['installation']
Deployability,"﻿. GPU implementation of the Hierarchical Equations of Motion — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/heom-gpu.html:149,Install,Installation,149,docs/4.6/development/ideas/heom-gpu.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/heom-gpu.html,2,"['Install', 'Release']","['Installation', 'Release']"
Deployability,"﻿. GPU implementation of the Hierarchical Equations of Motion — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/heom-gpu.html:149,Install,Installation,149,docs/4.7/development/ideas/heom-gpu.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/heom-gpu.html,2,"['Install', 'Release']","['Installation', 'Release']"
Deployability,"﻿. Generating Random Quantum States & Operators — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Generating Random Quantum States & Operators; Composite random objects. « Saving QuTiP Obj... Modifying Intern... ». Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state generators for simulations, theorem evaluation, and code testing:. Function; Description. rand_ket; Random ket-vector. rand_dm; Random density matrix. rand_herm; Random Hermitian matrix. rand_unitary; Random Unitary matrix. See the API document",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-random.html:271,install,installation,271,docs/3.1.0/guide/guide-random.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-random.html,1,['install'],['installation']
Deployability,"﻿. Guide Overview — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-overview.html:228,install,installation,228,docs/3.0.0/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-overview.html,1,['install'],['installation']
Deployability,"﻿. Guide Overview — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-overview.html:228,install,installation,228,docs/3.0.1/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-overview.html,1,['install'],['installation']
Deployability,"﻿. Guide Overview — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API docume",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-overview.html:241,install,installation,241,docs/3.1.0/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-overview.html,1,['install'],['installation']
Deployability,"﻿. Guide Overview — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Sh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-overview.html:105,Install,Installation,105,docs/4.6/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-overview.html,1,['Install'],['Installation']
Deployability,"﻿. Guide Overview — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP devel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-overview.html:105,Install,Installation,105,docs/4.7/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html,1,['Install'],['Installation']
Deployability,"﻿. Index — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Index. A; | B; | C; | D; | E; | F; | G; | H; | I; | J; | K; | L; | M; | N; | O; | P; | Q; | R; | S; | T; | U; | V; | W. A. about() (in module qutip). add_1q_gate() (QubitCircuit method). add_annotation() (Bloch method). add_circuit() (QubitCircuit method). add_gate() (QubitCircuit method). add_points() (Bloch method). (Bloch3d method). add_states() (Bloch method). (Bloch3d method). add_vectors() (Bloch method). (Bloch3d method). adjacent_gates() (CircuitProcessor method). (QubitCircuit ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/genindex.html:232,install,installation,232,docs/3.1.0/genindex.html,https://qutip.org,https://qutip.org/docs/3.1.0/genindex.html,1,['install'],['installation']
Deployability,"﻿. Installation — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.8+); Setup Using Homebrew; Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Optional Installation Options; UMFPACK Linear Solver; Optimized BLAS Libraries. Verifying the Installation; Checking Version I",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:239,install,installation,239,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['install'],['installation']
Deployability,"﻿. Installation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Quick Start; General Requirements; Installing with conda; Adding the conda-forge channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfai",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:688,install,install,688,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['install'],['install']
Deployability,"﻿. Installation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Quick Start; General Requirements; Installing with conda; Adding the conda-forge channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/installation.html:713,install,install,713,docs/4.7/installation.html,https://qutip.org,https://qutip.org/docs/4.7/installation.html,2,['install'],['install']
Deployability,"﻿. Lindblad Master Equation Solver — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. « Dynamics Simulat... Monte Carlo Solv... ». Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-master.html:258,install,installation,258,docs/3.1.0/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-master.html,1,['install'],['installation']
Deployability,"﻿. Lindblad Master Equation Solver — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; wh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:122,Install,Installation,122,docs/4.6/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html,1,['Install'],['Installation']
Deployability,"﻿. Manipulating States and Operators — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-states.html:247,install,installation,247,docs/3.0.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html,1,['install'],['installation']
Deployability,"﻿. Manipulating States and Operators — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-states.html:247,install,installation,247,docs/3.0.1/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-states.html,1,['install'],['installation']
Deployability,"﻿. Manipulating States and Operators — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-states.html:260,install,installation,260,docs/3.1.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html,1,['install'],['installation']
Deployability,"﻿. Manipulating States and Operators — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:124,Install,Installation,124,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,1,['Install'],['Installation']
Deployability,"﻿. Manipulating States and Operators — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-states.html:124,Install,Installation,124,docs/4.7/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html,1,['Install'],['Installation']
Deployability,"﻿. Modifying Internal QuTiP Settings — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. « Generating Rando... API documentatio... ». Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; qu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-settings.html:260,install,installation,260,docs/3.1.0/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-settings.html,1,['install'],['installation']
Deployability,"﻿. Monte Carlo Solver — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Monte Carlo Solver; Introduction; Monte Carlo in QuTiP; Changing the Number of Trajectories; Reusing Hamiltonian Data; Fortran Based Monte Carlo Solver. « Lindblad Master ... Bloch-Redfield m... ». Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realizatio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html:245,install,installation,245,docs/3.1.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html,1,['install'],['installation']
Deployability,"﻿. Monte Carlo Solver — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse ope",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:109,Install,Installation,109,docs/4.6/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html,1,['Install'],['Installation']
Deployability,"﻿. Overview: module code — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . All modules for which code is available; qutip; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dynamics; qutip.control.grape; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.correlation; qutip.distributions; qutip.entropy; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.fortran.mcsolve_f90; qutip.graph; qutip.ipynbtools; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.operators; qutip.parallel; qutip",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/index.html:248,install,installation,248,docs/3.1.0/modules/index.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/index.html,1,['install'],['installation']
Deployability,"﻿. Parallel computation — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. « Visualization of... Saving QuTiP Obj... ». Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-parfor.html:247,install,installation,247,docs/3.1.0/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-parfor.html,1,['install'],['installation']
Deployability,"﻿. Permutational Invariance — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; Consider a system evolving according to the equation. \[ \begin{align}\begin{aligned}\do",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-piqs.html:115,Install,Installation,115,docs/4.6/guide/dynamics/dynamics-piqs.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-piqs.html,1,['Install'],['Installation']
Deployability,"﻿. Permutational Invariance — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:115,Install,Installation,115,docs/4.7/guide/dynamics/dynamics-piqs.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html,1,['Install'],['Installation']
Deployability,"﻿. Plotting on the Bloch Sphere — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay; Generating Images for Animation; Directly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-bloch.html:255,install,installation,255,docs/3.1.0/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-bloch.html,1,['install'],['installation']
Deployability,"﻿. Plotting on the Bloch Sphere — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay. Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-bloch.html:119,Install,Installation,119,docs/4.6/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html,1,['Install'],['Installation']
Deployability,"﻿. Pulse level description of quantum circuits — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html:134,Install,Installation,134,docs/4.6/development/ideas/pulse-level-quantum-circuits.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/pulse-level-quantum-circuits.html,2,"['Install', 'Release']","['Installation', 'Release']"
Deployability,"﻿. Pulse level description of quantum circuits — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; lib",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:134,Install,Installation,134,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html,2,"['Install', 'Release']","['Installation', 'Release']"
Deployability,"﻿. Pulse-level circuit simulation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Pulse-level circuit simulation. Pulse-level circuit simulation¶. Modelling quantum hardware with Processor¶; Based on the open system solver, Processor in the qutip.qip module simulates quantum circuits at the level of time evolution. One can consider the processor as a simulator of a quantum device, on which the quantum circuit is to be implemented.; The procedure is illustrated in the figure below.; It first compiles circuit into a Hamiltonian model, adds noisy dynamics and then uses the QuTiP open time evolution solvers to simulation the evolution. Like a real quantum device, the processor is determined by a list of Hamiltonians, i.e. the control pulses driving the evolution. Given the intensity of the control pulses and the corresponding time slices for each pulse, the evolution is then computed. A control pulse is characterized by Pulse, consisting of the control Hamilt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:121,Install,Installation,121,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,1,['Install'],['Installation']
Deployability,"﻿. Pulse-level circuit simulation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Pulse-level circuit simulation. Pulse-level circuit simulation¶. Modelling quantum hardware with Processor¶; Based on the open system solver, Processor in the qutip.qip module simulates quantum circuits at the level of time evolution. One can consider the processor as a simulator of a quantum device, on which the quantum circuit is to be implemented.; The procedure is illustrated in the figure below.; It first compiles circuit into a Hamiltonian model, adds noisy dynamics and then uses the QuTiP open time evolution solvers to simulation the evolution. Like a real quantum device, the processor is determined by a list of Hamiltonians, i.e. the control pulses driving the evolution. Given the intensity of the control pulses and the corresponding time slices for each pulse, the evolution is then computed. A control pulse ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:121,Install,Installation,121,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,1,['Install'],['Installation']
Deployability,"﻿. Python Module Index — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Python Module Index. q.  . q. qutip.    ; qutip.bloch_redfield.    ; qutip.continuous_variables.    ; qutip.control.grape.    ; qutip.control.pulsegen.    ; qutip.control.pulseoptim.    ; qutip.correlation.    ; qutip.entropy.    ; qutip.essolve.    ; qutip.expect.    ; qutip.fileio.    ; qutip.floquet.    ; qutip.fortran.mcsolve_f90.    ; qutip.graph.    ; qutip.ipynbtools.    ; qutip.mcsolve.    ; qutip.mesolve.    ; qutip.metrics.    ; qutip.operators.    ; qutip.parall",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/py-modindex.html:246,install,installation,246,docs/3.1.0/py-modindex.html,https://qutip.org,https://qutip.org/docs/3.1.0/py-modindex.html,1,['install'],['installation']
Deployability,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Code of conduct; As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities.; We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality.; Examples of unacceptable behavior by participants include:. The use of sexualized language or imagery; Personal attacks; Trolling or insulting/derogatory comments; Public or private harassment; Publishing other’s private information, such as physical or electronic addresses, without explicit permission; Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team.; This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community.; Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/cofc.html:563,patch,patches,563,cofc.html,https://qutip.org,https://qutip.org/cofc.html,1,['patch'],['patches']
Deployability,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP Virtual Lab. Exploring simple quantum systems with QuTiP can help build intuition for them,; but there are many cases where writing code and Jupyter notebooks can get; in the way:. When teaching, coding can be a big distraction. Quantum mechanics is complex ; enough without your students having to struggle with installing software,; messing up their notebooks or learning QuTiP at the same time. When doing research, coding can be a big detour. You just want to do a quick; check to remind yourself how a simple system works, not spend the afternoon; fiddling in a text editor. You have papers to write and grant reports to fill; in. Time is precious. When at a party or while pitching your cool ideas, you don’t want to take out; your laptop to show people how cool your ideas are. It breaks the flow. You; need to be able to show them on your tablet. For all of these use cases, there is QuTiP Virtual Lab – a tablet and web; optimized graphical interface for building and exploring simple quantum systems.; It runs entirely in your browser, so there’s no server and nothing to install.; Click the button below to get started!; Enter QuTiP Virtual Lab.; There’s a handy tutorial with videos included in the virtual lab itself and some pre-built systems; to get you started. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/qutip-virtual-lab.html:599,install,installing,599,qutip-virtual-lab.html,https://qutip.org,https://qutip.org/qutip-virtual-lab.html,2,['install'],"['install', 'installing']"
Deployability,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP has been developed over seven years by volunteers working in their spare time. If you find QuTiP useful, please consider taking a minute of your own time and citing it in your publications. Download; The recommended way to install QuTiP is with conda or pip, see the; documentation for details.; Latest releases; Verion 5.0.4 - 3 September 2024. v5.0.4.tar.gz; v5.0.4.zip. Version 4.7.6 - 5 April 2024. v4.7.6.tar.gz; v4.7.6.zip. Recent minor releases; Verion 5.0.3 - 28 June 2024. v5.0.3.tar.gz; v5.0.3.zip. Verion 5.0.2 - 17 May 2024. v5.0.2.tar.gz; v5.0.2.zip. Verion 5.0.1 - 3 April 2024. v5.0.1.tar.gz; v5.0.1.zip. Verion 5.0.0 - 28 March 2024. v5.0.0.tar.gz; v5.0.0.zip. Version 4.7.5 - 30 January 2024. v4.7.5.tar.gz; v4.7.5.zip. Version 4.7.4 - 18 January 2024. v4.7.4.tar.gz; v4.7.4.zip. Version 4.7.3 - 23 August 2023. v4.7.3.tar.gz; v4.7.3.zip. Version 4.7.2 - 29 June 2023. v4.7.2.tar.gz; v4.7.2.zip. Version 4.7.1 - 12 December 2022. v4.7.1.tar.gz; v4.7.1.zip. Version 4.7.0 - 13 April 2022. v4.7.0.tar.gz; v4.7.0.zip. Legacy releases; If you are interested in legacy releases of QuTiP, you can download all previous; versions from the GitHub by selecting the appropriate tag.; Installation; Instructions for installing QuTiP can be found in the documentation, or; in the INSTALL.txt file included in the QuTiP source folder.; Source Code; If you want to checkout the latest source code and documentation then head on; over to the QuTiP repositories at GitHub. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/download.html:509,install,install,509,download.html,https://qutip.org,https://qutip.org/download.html,6,"['install', 'release']","['install', 'installing', 'releases']"
Deployability,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Users guide; Latest releases; Version 5.0.4. Read the Docs. PDF documentation. Version 4.7.6. Read the Docs. PDF documentation. Previous releases; Version 4.7.5 (archived). Online HTML documentation. PDF documentation. Version 4.6.0. Online HTML documentation. PDF documentation. Version 4.5.0. Online HTML documentation. PDF documentation. Version 4.4.0. Online HTML documentation. PDF documentation. Version 4.3.1. Online HTML documentation. PDF documentation. Version 4.2.0. Online HTML documentation. PDF documentation. Version 4.1.0. Online HTML documentation. PDF documentation. Version 4.0.2. Online HTML documentation. PDF documentation. Version 3.1.0. Online HTML documentation. PDF documentation. Version 3.0.1. Online HTML documentation. PDF documentation. Version 3.0.0. Online HTML documentation. PDF documentation. Version 2.2.0. PDF documentation. Development documentation; The documentation for the development version of QuTiP is available at the qutip-doc github repository. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/documentation.html:300,release,releases,300,documentation.html,https://qutip.org,https://qutip.org/documentation.html,2,['release'],['releases']
Deployability,"﻿. QuTiP Development Roadmap — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuTiP is also an organisation, in the Github sense, and in t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:494,integrat,integration,494,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,6,"['Install', 'Release', 'integrat', 'release']","['Installation', 'Release', 'integration', 'release']"
Deployability,"﻿. QuTiP Development Roadmap — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; Solver data layer integration; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. Completed Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; QIP migration; HEOM revamp. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuT",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:416,integrat,integration,416,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,6,"['Install', 'Release', 'integrat', 'release']","['Installation', 'Release', 'integration', 'release']"
Deployability,"﻿. QuTiP Interactive — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html:108,Install,Installation,108,docs/4.6/development/ideas/qutip-interactive.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/qutip-interactive.html,2,"['Install', 'Release']","['Installation', 'Release']"
Deployability,"﻿. QuTiP Interactive — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Ha",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:108,Install,Installation,108,docs/4.7/development/ideas/qutip-interactive.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html,2,"['Install', 'Release']","['Installation', 'Release']"
Deployability,"﻿. QuTiP: Quantum Toolbox in Python (3.1.0) — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . QuTiP: Quantum Toolbox in Python (3.1.0); Indices and tables. Frontmatter ». QuTiP: Quantum Toolbox in Python (3.1.0)¶. Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/index.html:267,install,installation,267,docs/3.1.0/index.html,https://qutip.org,https://qutip.org/docs/3.1.0/index.html,1,['install'],['installation']
Deployability,"﻿. Quantum Error Mitigation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pul",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:878,release,release,878,docs/4.6/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html,4,"['Install', 'Release', 'release']","['Installation', 'Release', 'release']"
Deployability,"﻿. Quantum Error Mitigation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:921,release,release,921,docs/4.7/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html,4,"['Install', 'Release', 'release']","['Installation', 'Release', 'release']"
Deployability,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:431,release,release,431,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,27,"['Install', 'Release', 'deploy', 'release', 'update']","['Installation', 'Release', 'deploy', 'release', 'releases', 'updates']"
Deployability,"﻿. Release and Distribution — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Changelog; Create a New Minor or Major Release; Create a Bug Fix Release. Build Release Distribution and Deploy; Build and Deploy; Download Built Files; Monitoring Progress (optional). Getting the Built Documentation; Making a Release on GitHub; Website; Copying New Files; HTML File Updates. Conda Forge. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-chang",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:958,update,updates,958,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,19,"['Deploy', 'Install', 'Release', 'Update', 'release', 'update']","['Deploy', 'Installation', 'Release', 'Updates', 'release', 'releases', 'updates']"
Deployability,"﻿. Saving QuTiP Objects and Data Sets — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Parallel computa... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-saving.html:261,install,installation,261,docs/3.1.0/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-saving.html,1,['install'],['installation']
Deployability,"﻿. Saving QuTiP Objects and Data Sets — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename exte",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-saving.html:125,Install,Installation,125,docs/4.6/guide/guide-saving.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-saving.html,1,['Install'],['Installation']
Deployability,"﻿. Search — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Search. Please activate JavaScript to enable the search; functionality.; . From here you can search these documents. Enter your search; words into the box below and click ""search"". Note that the search; function will automatically search for all of the words. Pages; containing fewer words won't appear in the result list.; . Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/search.html:233,install,installation,233,docs/3.1.0/search.html,https://qutip.org,https://qutip.org/docs/3.1.0/search.html,2,"['install', 'update']","['installation', 'updated']"
Deployability,"﻿. Setting Options for the Dynamics Solvers — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Setting Options for the Dynamics Solvers. « Floquet Formalis... Solving for Stea... ». Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; In [1]: options = Options(). the properties and default values of this",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-options.html:267,install,installation,267,docs/3.1.0/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-options.html,1,['install'],['installation']
Deployability,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:263,install,installation,263,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,1,['install'],['installation']
Deployability,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-time.html:263,install,installation,263,docs/3.0.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-time.html,1,['install'],['installation']
Deployability,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:276,install,installation,276,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['install'],['installation']
Deployability,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:140,Install,Installation,140,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,1,['Install'],['Installation']
Deployability,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the en",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:140,Install,Installation,140,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,1,['Install'],['Installation']
Deployability,"﻿. Solving for Steady-State Solutions — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving for Steady-State Solutions; Introduction; Steady State Solutions for Arbitrary Systems; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. « Setting Options ... An Overview of t... ». Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend towar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-steady.html:261,install,installation,261,docs/3.1.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html,1,['install'],['installation']
Deployability,"﻿. Solving for Steady-State Solutions — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Solving for Steady-State Solutions. Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{d\hat{\rho}_{ss}}{dt}=\mathcal{L}\hat{\rho}_{ss}=0.\]; Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP¶; In QuTiP, the steady-state soluti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-steady.html:125,Install,Installation,125,docs/4.6/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html,1,['Install'],['Installation']
Deployability,"﻿. Stochastic Solver — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.genera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:108,Install,Installation,108,docs/4.6/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html,1,['Install'],['Installation']
Deployability,"﻿. Stochastic Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) an",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:108,Install,Installation,108,docs/4.7/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html,1,['Install'],['Installation']
Deployability,"﻿. TensorFlow Data Backend — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; TensorFlow Data Backend. TensorFlow Data Backend¶. Contents. Why a TensorFlow backend?; Challenges. Expected outcomes; Skills; Difficulty; Mentors; References. QuTiP’s data layer provides the mathematical operations needed to work with; quantum states and operators, i.e. Qobj, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to wo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html:114,Install,Installation,114,docs/4.6/development/ideas/tensorflow-data-backend.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html,2,"['Install', 'Release']","['Installation', 'Release']"
Deployability,"﻿. TensorFlow Data Backend — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; TensorFlow Data Backend. TensorFlow Data Backend¶. Contents. Why a TensorFlow backend?; Challenges. Expected outcomes; Skills; Difficulty; Mentors; References. Note; This project was completed as part of GSoC 2021 3. QuTiP’s data layer provides the mathematical operations needed to work with; quantum states and operators, i.e. Qobj, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; de",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:114,Install,Installation,114,docs/4.7/development/ideas/tensorflow-data-backend.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html,2,"['Install', 'Release']","['Installation', 'Release']"
Deployability,"﻿. Time Evolution and Quantum System Dynamics — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Time Evolution and Quantum System Dynamics. « Using Tensor Pro... Dynamics Simulat... ». Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; B",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-dynamics.html:269,install,installation,269,docs/3.1.0/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-dynamics.html,1,['install'],['installation']
Deployability,"﻿. Two-time correlation functions — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. « An Overview of t... Plotting on the ... ». Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-correlation.html:244,install,installation,244,docs/3.0.0/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html,1,['install'],['installation']
Deployability,"﻿. Two-time correlation functions — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. « An Overview of t... Plotting on the ... ». Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-correlation.html:244,install,installation,244,docs/3.0.1/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-correlation.html,1,['install'],['installation']
Deployability,"﻿. Two-time correlation functions — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. « An Overview of t... Plotting on the ... ». Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-correlation.html:257,install,installation,257,docs/3.1.0/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-correlation.html,1,['install'],['installation']
Deployability,"﻿. Two-time correlation functions — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Two-time correlation functions. Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-correlation.html:121,Install,Installation,121,docs/4.6/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-correlation.html,1,['Install'],['Installation']
Deployability,"﻿. Users Guide — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Users Guide. « Installation. Guide Overview ». Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide.html:238,install,installation,238,docs/3.1.0/guide/guide.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide.html,1,['install'],['installation']
Deployability,"﻿. Using Tensor Products and Partial Traces — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Two coupled qubits; Three coupled qubits; A two-level system coupled to a cavity: The Jaynes-Cummings model. Partial trace; Superoperators and Tensor Manipulations. « Manipulating Sta... Time Evolution a... ». Using Tensor Products and Partial Traces¶. Tensor products¶; To describe the states of multipartite quantum systems - such as two coupled qub",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-tensor.html:267,install,installation,267,docs/3.1.0/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-tensor.html,1,['install'],['installation']
Deployability,"﻿. Visualization of quantum states and processes — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Custom Color Maps. Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. « Plotting on the ... Parallel computa... ». Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first meth",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-visualization.html:272,install,installation,272,docs/3.1.0/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-visualization.html,1,['install'],['installation']
Deployability,"﻿. Visualization of quantum states and processes — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Visualization of quantum states and processes. Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-visualization.html:136,Install,Installation,136,docs/4.6/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-visualization.html,1,['Install'],['Installation']
Deployability,"﻿. Working with the QuTiP Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/docs.html:127,Install,Installation,127,docs/4.6/development/docs.html,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html,2,"['Install', 'Release']","['Installation', 'Release']"
Deployability,"﻿. qutip — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistribu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip.html:232,install,installation,232,docs/3.1.0/modules/qutip.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html,1,['install'],['installation']
Deployability,"﻿. qutip.bloch — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.bloch; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/bloch.html:238,install,installation,238,docs/3.1.0/modules/qutip/bloch.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/bloch.html,1,['install'],['installation']
Deployability,"﻿. qutip.bloch3d — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.bloch3d; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/bloch3d.html:240,install,installation,240,docs/3.1.0/modules/qutip/bloch3d.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/bloch3d.html,1,['install'],['installation']
Deployability,"﻿. qutip.bloch_redfield — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.bloch_redfield; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/bloch_redfield.html:247,install,installation,247,docs/3.1.0/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/bloch_redfield.html,1,['install'],['installation']
Deployability,"﻿. qutip.continuous_variables — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.continuous_variables; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/continuous_variables.html:253,install,installation,253,docs/3.1.0/modules/qutip/continuous_variables.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/continuous_variables.html,1,['install'],['installation']
Deployability,"﻿. qutip.control.dynamics — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.control.dynamics; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:249,install,installation,249,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['install'],['installation']
Deployability,"﻿. qutip.control.grape — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.control.grape; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following dis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:246,install,installation,246,docs/3.1.0/modules/qutip/control/grape.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html,1,['install'],['installation']
Deployability,"﻿. qutip.control.pulsegen — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.control.pulsegen; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html:249,install,installation,249,docs/3.1.0/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html,1,['install'],['installation']
Deployability,"﻿. qutip.control.pulseoptim — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.control.pulseoptim; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions an",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:251,install,installation,251,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['install'],['installation']
Deployability,"﻿. qutip.correlation — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.correlation; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclai",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:244,install,installation,244,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['install'],['installation']
Deployability,"﻿. qutip.distributions — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.distributions; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following dis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/distributions.html:246,install,installation,246,docs/3.1.0/modules/qutip/distributions.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/distributions.html,1,['install'],['installation']
Deployability,"﻿. qutip.entropy — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.entropy; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html:240,install,installation,240,docs/3.1.0/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html,1,['install'],['installation']
Deployability,"﻿. qutip.essolve — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.essolve; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/essolve.html:240,install,installation,240,docs/3.1.0/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/essolve.html,1,['install'],['installation']
Deployability,"﻿. qutip.expect — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.expect; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/expect.html:239,install,installation,239,docs/3.1.0/modules/qutip/expect.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/expect.html,1,['install'],['installation']
Deployability,"﻿. qutip.fileio — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.fileio; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fileio.html:239,install,installation,239,docs/3.1.0/modules/qutip/fileio.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fileio.html,1,['install'],['installation']
Deployability,"﻿. qutip.floquet — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.floquet; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/floquet.html:240,install,installation,240,docs/3.1.0/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/floquet.html,1,['install'],['installation']
Deployability,"﻿. qutip.fortran.mcsolve_f90 — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.fortran.mcsolve_f90; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:252,install,installation,252,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['install'],['installation']
Deployability,"﻿. qutip.graph — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.graph; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/graph.html:238,install,installation,238,docs/3.1.0/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/graph.html,1,['install'],['installation']
Deployability,"﻿. qutip.ipynbtools — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.ipynbtools; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaime",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html:243,install,installation,243,docs/3.1.0/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html,1,['install'],['installation']
Deployability,"﻿. qutip.mcsolve — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.mcsolve; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:240,install,installation,240,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['install'],['installation']
Deployability,"﻿. qutip.mesolve — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.mesolve; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:240,install,installation,240,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['install'],['installation']
Deployability,"﻿. qutip.metrics — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.metrics; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/metrics.html:240,install,installation,240,docs/3.1.0/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/metrics.html,1,['install'],['installation']
Deployability,"﻿. qutip.operators — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.operators; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/operators.html:242,install,installation,242,docs/3.1.0/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/operators.html,1,['install'],['installation']
Deployability,"﻿. qutip.parallel — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.parallel; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/parallel.html:241,install,installation,241,docs/3.1.0/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/parallel.html,1,['install'],['installation']
Deployability,"﻿. qutip.partial_transpose — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.partial_transpose; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the follo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/partial_transpose.html:250,install,installation,250,docs/3.1.0/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/partial_transpose.html,1,['install'],['installation']
Deployability,"﻿. qutip.propagator — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.propagator; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaime",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/propagator.html:243,install,installation,243,docs/3.1.0/modules/qutip/propagator.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/propagator.html,1,['install'],['installation']
Deployability,"﻿. qutip.qip.algorithms.qft — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.qip.algorithms.qft; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the fol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/qip/algorithms/qft.html:251,install,installation,251,docs/3.1.0/modules/qutip/qip/algorithms/qft.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/algorithms/qft.html,1,['install'],['installation']
Deployability,"﻿. qutip.qip.circuit — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.qip.circuit; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclai",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/qip/circuit.html:244,install,installation,244,docs/3.1.0/modules/qutip/qip/circuit.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/circuit.html,1,['install'],['installation']
Deployability,"﻿. qutip.qip.gates — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.qip.gates; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/qip/gates.html:242,install,installation,242,docs/3.1.0/modules/qutip/qip/gates.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/gates.html,1,['install'],['installation']
Deployability,"﻿. qutip.qip.models — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.qip.models; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaime",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/qip/models.html:243,install,installation,243,docs/3.1.0/modules/qutip/qip/models.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/models.html,1,['install'],['installation']
Deployability,"﻿. qutip.qip.models.cqed — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.qip.models.cqed; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/qip/models/cqed.html:248,install,installation,248,docs/3.1.0/modules/qutip/qip/models/cqed.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/models/cqed.html,1,['install'],['installation']
Deployability,"﻿. qutip.qip.models.spinchain — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.qip.models.spinchain; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/qip/models/spinchain.html:253,install,installation,253,docs/3.1.0/modules/qutip/qip/models/spinchain.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/models/spinchain.html,1,['install'],['installation']
Deployability,"﻿. qutip.qip.qubits — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.qip.qubits; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaime",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/qip/qubits.html:243,install,installation,243,docs/3.1.0/modules/qutip/qip/qubits.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/qip/qubits.html,1,['install'],['installation']
Deployability,"﻿. qutip.random_objects — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.random_objects; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/random_objects.html:247,install,installation,247,docs/3.1.0/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/random_objects.html,1,['install'],['installation']
Deployability,"﻿. qutip.sesolve — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.sesolve; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:240,install,installation,240,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['install'],['installation']
Deployability,"﻿. qutip.solver — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.solver; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/solver.html:239,install,installation,239,docs/3.1.0/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/solver.html,1,['install'],['installation']
Deployability,"﻿. qutip.states — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.states; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/states.html:239,install,installation,239,docs/3.1.0/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/states.html,1,['install'],['installation']
Deployability,"﻿. qutip.steadystate — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.steadystate; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclai",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:244,install,installation,244,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['install'],['installation']
Deployability,"﻿. qutip.stochastic — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.stochastic; # -*- coding: utf-8 -*-; #; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:243,install,installation,243,docs/3.1.0/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html,1,['install'],['installation']
Deployability,"﻿. qutip.superop_reps — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.superop_reps; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of condition",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html:245,install,installation,245,docs/3.1.0/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/superop_reps.html,1,['install'],['installation']
Deployability,"﻿. qutip.superoperator — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.superoperator; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following dis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/superoperator.html:246,install,installation,246,docs/3.1.0/modules/qutip/superoperator.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/superoperator.html,1,['install'],['installation']
Deployability,"﻿. qutip.tensor — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.tensor; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/tensor.html:239,install,installation,239,docs/3.1.0/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/tensor.html,1,['install'],['installation']
Deployability,"﻿. qutip.three_level_atom — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.three_level_atom; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the followi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/three_level_atom.html:249,install,installation,249,docs/3.1.0/modules/qutip/three_level_atom.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/three_level_atom.html,1,['install'],['installation']
Deployability,"﻿. qutip.tomography — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.tomography; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaime",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/tomography.html:243,install,installation,243,docs/3.1.0/modules/qutip/tomography.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/tomography.html,1,['install'],['installation']
Deployability,"﻿. qutip.utilities — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.utilities; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html:242,install,installation,242,docs/3.1.0/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/utilities.html,1,['install'],['installation']
Deployability,"﻿. qutip.visualization — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.visualization; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following dis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:246,install,installation,246,docs/3.1.0/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html,1,['install'],['installation']
Deployability,"﻿. qutip.wigner — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.wigner; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/wigner.html:239,install,installation,239,docs/3.1.0/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/wigner.html,1,['install'],['installation']
Energy Efficiency," ""("" + self.ops[_set[0]].coeff + "")""; for i in _set[1:]:; new_str += "" + ("" + self.ops[i].coeff + "")""; new_op[1] = _StrWrapper(new_str); new_op[2] = new_str; new_ops.append(EvoElement.make(new_op)). elif self.ops[_set[0]].type == ""array"":; new_op = [self.ops[_set[0]].qobj, None, None, ""array""]; new_array = (self.ops[_set[0]].coeff).copy(); for i in _set[1:]:; new_array += self.ops[i].coeff; new_op[2] = new_array; new_op[1] = _CubicSplineWrapper(; self.tlist, new_array, args=self.args); new_ops.append(EvoElement.make(new_op)). self.ops = new_ops. def _compress_merge_func(self, fsets):; new_ops = []; for _set in fsets:; base = self.ops[_set[0]]; new_op = [None, base.get_coeff, base.coeff, base.type]; if len(_set) == 1:; new_op[0] = base.qobj; else:; new_op[0] = base.qobj.copy(); for i in _set[1:]:; new_op[0] += self.ops[i].qobj; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops. [docs] def compress(self):; """"""; Merge together elements that share the same time-dependence, to reduce; the number of matrix multiplications and additions that need to be done; to evaluate this object. Modifies the object inplace.; """"""; self.tidyup(); sets, fsets = self._compress_make_set(); N_sets = len(sets); N_fsets = len(fsets); num_ops = len(self.ops). if N_sets < num_ops and N_fsets < num_ops:; # Both could be better; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; if N_sets < N_fsets:; self._compress_merge_qobj(sets); else:; self._compress_merge_func(fsets); sets, fsets = self._compress_make_set(); N_sets = len(sets); N_fsets = len(fsets); num_ops = len(self.ops). if N_sets < num_ops:; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self._compress_merge_qobj(sets); elif N_fsets < num_ops:; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self._compress_merge_func(fsets); self._reset_type(). def _reset_type(self):; op_type_count = [0, 0, 0, 0]; for op in self.ops:; if op.type == ""func"":; op_type_count[0] ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:31928,reduce,reduce,31928,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,4,['reduce'],['reduce']
Energy Efficiency," # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; randint(1, 100000000.0 + 1, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = randint(1, 100000000.0 + 1, ; size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:12089,reduce,reduced,12089,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['reduce'],['reduced']
Energy Efficiency," (by Boxi Li).; Generalize expand_oper for arbitrary dimensions, and new method for cyclic permutations of given target cubits (by Boxi Li). Bug Fixes¶. Fixed the pickling but that made solver unable to run in parallel on Windows (Thank lrunze for reporting); Removed warning when mesolve fall back on sesolve (by Michael Goerz).; Fixed dimension check and confusing documentation in random ket (by Yariv Yanay).; Fixed Qobj isherm not working after using Qobj.permute (Thank llorz1207 for reporting).; Correlation functions call now properly handle multiple time dependant functions (Thank taw181 for reporting).; Removed mutable default values in mesolve/sesolve (by Michael Goerz).; Fixed simdiag bug (Thank Croydon-Brixton for reporting).; Better support of constant QobjEvo (by Boxi Li).; Fixed potential cyclic import in the control module (by Alexander Pitchford). Version 4.4.0 (July 03, 2019)¶. Improvements¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients.; The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/changelog.html:5615,efficient,efficiently,5615,docs/4.5/changelog.html,https://qutip.org,https://qutip.org/docs/4.5/changelog.html,3,['efficient'],['efficiently']
Energy Efficiency," (qutip.ui.BaseProgressBar) Optional progress bar class instance. Distribution functions¶. class Distribution(data=None, xvecs=[], xlabels=[])[source]¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:data : array_like. Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list. List of arrays that spans the space for each coordinate. xlabels : list. List of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d : Distributions. A new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d : Distributions. A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualiz",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:45883,reduce,reduced,45883,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,1,['reduce'],['reduced']
Energy Efficiency," (qutip.ui.BaseProgressBar) Optional progress bar class instance. Distribution functions¶. class Distribution(data=None, xvecs=[], xlabels=[])[source]¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:data : array_like. Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list. List of arrays that spans the space for each coordinate. xlabels : list. List of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d : Distributions. A new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d : Distributions. A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig; : matplotlib Figure instanceIf given, use this figure instance for the visualiza",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/classes.html:45727,reduce,reduced,45727,docs/4.1/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/classes.html,1,['reduce'],['reduced']
Energy Efficiency," * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; ----",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:7290,energy,energy,7290,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,11,['energy'],['energy']
Energy Efficiency," * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]); ; # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim); ; # Load the parameters with the Choi matrix passed in.; J_dat = J.data; Jr.value, Ji.value = J_dat.real, J_dat.imag; ; # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/metrics.html:11989,efficient,efficiently,11989,docs/4.0.2/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/metrics.html,1,['efficient'],['efficiently']
Energy Efficiency," * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]); ; # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim); ; # Load the parameters with the Choi matrix passed in.; J_dat = J.data; Jr.value, Ji.value = J_dat.real, J_dat.imag; ; # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/metrics.html:11989,efficient,efficiently,11989,docs/4.2/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html,1,['efficient'],['efficiently']
Energy Efficiency," * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]); ; # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim); ; # Load the parameters with the Choi matrix passed in.; J_dat = J.data; Jr.value, Ji.value = J_dat.real, J_dat.imag; ; # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/metrics.html:11989,efficient,efficiently,11989,docs/4.1/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/metrics.html,1,['efficient'],['efficiently']
Energy Efficiency," + j3)), np.int32); sign = (-1) ** (vmin + j2 + m2); for i,v in enumerate(range(vmin, vmax + 1)):; factor = s_factors[i,:]; _factorial_prod(j2 + j3 + m1 - v, factor); _factorial_prod(j1 - m1 + v, factor); _factorial_div(j3 - j1 + j2 - v, factor); _factorial_div(j3 + m3 - v, factor); _factorial_div(v + j1 - j2 - m3, factor); _factorial_div(v, factor); common_denominator = -np.min(s_factors, axis=0); numerators = s_factors + common_denominator; S = sum([(-1)**i * _to_long(vec) for i,vec in enumerate(numerators)]) * \; sign / _to_long(common_denominator); return C * S. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : flo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/utilities.html:6161,energy,energy,6161,docs/4.5/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/utilities.html,1,['energy'],['energy']
Energy Efficiency," 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destruction (lowering) operator. Parameters. NintDimension of Hilbert space. offsetint (default",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:17908,charge,charge,17908,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['charge'],['charge']
Energy Efficiency," 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: tensor(sigmaz(), identity(2)); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [6]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [7]: H; Out[7]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [8]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [9]: H; Out[9]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-tensor.html:4560,energy,energy,4560,docs/4.3/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-tensor.html,3,['energy'],['energy']
Energy Efficiency," 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:N : int. Hilbert space dimensionality. dims : list. Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:zero_ket : qobj. Zero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:Nmax : int. Maximum charge state to consider. Nmin : int (default = -Nmax). Lowest charge state to consider. frac : float (default = 1). Specify fractional charge if needed. Returns:C : Qobj. Charge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:N : int. Dimension of Hilbert space. Returns:oper : qobj. Qobj for raising operator. offset : int (default 0). The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destruction (lowering) oper",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:18192,charge,charge,18192,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['charge'],['charge']
Energy Efficiency," 1e-4, 'fill_factor': 100,; 'diag_pivot_thresh': None, 'maxiter': 1000, 'tol': 1e-9,; 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', 'restart': 20,; 'return_info': False, 'info': {'perm': []}}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:5839,power,power,5839,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,2,['power'],['power']
Energy Efficiency," 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction. Examples; --------; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; ``[gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]``; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles.; """"""; circuit = deepcopy(circuit); if repeat_num > 0:; random_shuffle = True; result = [0]; max_length = 4294967296; for i in range(repeat_num):; gate_cycle_indices = self.schedule(; circuit, gates_schedule=gates_schedule,; return_cycles_list=return_cycles_list,; random_shuffle=random_shuffle, repeat_num=0); current_length = max(gate_cycle_indices); if current_length < max_length:; result = gate_cycle_indices; max_length = current_length; return result. if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit. # Generate the quantum operations dependency graph.; instructio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:16727,schedul,scheduler,16727,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,10,"['Schedul', 'schedul']","['Scheduler', 'scheduler']"
Energy Efficiency," = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; # FIXME: These atol keyword except checks can be removed once scipy 1.1; # is a minimum requirement; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; try:; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = gmres(L, v, tol=mtol,; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'power-lgmres':; try:; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = lgmres(L, v, tol=mtol,; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'power-bicgstab':; try:; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = bicgstab(L, v, tol=mtol,; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and ss_args['solver'] == 'mkl':; lu.delete(); if ss_args['return_info']:; ss_args",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:29354,power,power-lgmres,29354,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['power'],['power-lgmres']
Energy Efficiency," = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N : int; Hilbert space dimensionality. dims : list; Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:; zero_ket : qobj; Zero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns:; C : Qobj; Charge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:; N : int; Dimension of Hilbert space. Returns:; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.7320508",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:18242,charge,charge,18242,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['charge'],['charge']
Energy Efficiency," = self._isherm. out.superrep = self.superrep. return out. else:; raise TypeError(""Incompatible object for division""). def __neg__(self):; """"""; NEGATION operation.; """"""; out = Qobj(); out.data = -self.data; out.dims = self.dims; out.superrep = self.superrep; if settings.auto_tidyup:; out.tidyup(); out._isherm = self._isherm; out._isunitary = self._isunitary; return out. def __getitem__(self, ind):; """"""; GET qobj elements.; """"""; out = self.data[ind]; if sp.issparse(out):; return out.toarray(); else:; return out. def __eq__(self, other):; """"""; EQUALITY operator.; """"""; if (isinstance(other, Qobj) and; self.dims == other.dims and; not np.any(np.abs((self.data - other.data).data) >; settings.atol)):; return True; else:; return False. def __ne__(self, other):; """"""; INEQUALITY operator.; """"""; return not (self == other). def __pow__(self, n, m=None): # calculates powers of Qobj; """"""; POWER operation.; """"""; if self.shape[0] != self.shape[1]:; raise Exception(""Raising a qobj to some power works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; except (TypeError, ValueError):; raise ValueError('Invalid choice of exponent.'); out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t + ""\n""); s += ""Qobj data =\n"". if shape[0] > 10000 or shape[1] > 10000:; # if the system is huge, don't attempt to ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:20453,power,power,20453,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,4,['power'],['power']
Energy Efficiency," = self.data / other; out.dims = self.dims; if settings.auto_tidyup: out.tidyup(); if isinstance(other, complex):; out._isherm = out.isherm; else:; out._isherm = self._isherm. out.superrep = self.superrep. return out. else:; raise TypeError(""Incompatible object for division""). def __neg__(self):; """"""; NEGATION operation.; """"""; out = Qobj(); out.data = -self.data; out.dims = self.dims; out.superrep = self.superrep; if settings.auto_tidyup: out.tidyup(); out._isherm = self._isherm; return out. def __getitem__(self, ind):; """"""; GET qobj elements.; """"""; out = self.data[ind]; if sp.issparse(out):; return np.asarray(out.todense()); else:; return out. def __eq__(self, other):; """"""; EQUALITY operator.; """"""; if (isinstance(other, Qobj) and; self.dims == other.dims and; not np.any(np.abs((self.data - other.data).data) >; settings.atol)):; return True; else:; return False. def __ne__(self, other):; """"""; INEQUALITY operator.; """"""; return not (self == other). def __pow__(self, n, m=None): # calculates powers of Qobj; """"""; POWER operation.; """"""; if self.type not in ['oper', 'super']:; raise Exception(""Raising a qobj to some power works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. except:; raise ValueError('Invalid choice of exponent.'). def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:18381,power,powers,18381,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,1,['power'],['powers']
Energy Efficiency," A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; stor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:4955,monitor,monitored,4955,docs/4.6/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html,4,['monitor'],['monitored']
Energy Efficiency," A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware cons",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:181122,schedul,scheduler,181122,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,6,"['Schedul', 'schedul']","['Scheduler', 'scheduler']"
Energy Efficiency," CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = conf",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:13088,reduce,reduced,13088,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['reduce'],['reduced']
Energy Efficiency," False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. fill_factor : float, optional, default = 100; ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method; algoithm used in creating the preconditoner. Should only be used by; advanced users. Returns; -------; dm : qobj; Steady state density matrix. info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems). """"""; ss_args = _default_steadystate_args(); for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(; ""Invalid keyword argument '""+key+""' passed to steadystate.""). # Set column perm to NATURAL",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:8492,reduce,reduced,8492,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['reduce'],['reduced']
Energy Efficiency," False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. fill_factor : float, optional, default = 100; ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method; algoithm used in creating the preconditoner. Should only be used by; advanced users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems). """"""; if solver is None:; solver = 'scipy'; if settings.has_mkl:; if method in ['direct', 'power']:; solver = 'mkl'; elif solver == 'mkl' and \; (method not in ['direct', 'power']):; raise Exception('MKL solver only for direct or power metho",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:8857,reduce,reduced,8857,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['reduce'],['reduced']
Energy Efficiency," False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. fill_factor : float, optional, default = 100; ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method; algoithm used in creating the preconditoner. Should only be used by; advanced users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; ; """"""; ss_args = _default_steadystate_args(); for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(; ""Invalid keyword argument '""+key+""' passed to steadystate.""). # Set column perm to NAT",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:7981,reduce,reduced,7981,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['reduce'],['reduced']
Energy Efficiency," Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2), _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (target) + [U] +; [identity(2)] * (N - target - 1)). [docs]def gate_expand_2toN(U, N, control=None, target=None, targets=None):; """"""; Create a Qobj representing a two-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/qip/gates.html:19050,reduce,reduce,19050,docs/4.1/modules/qutip/qip/gates.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/qip/gates.html,6,['reduce'],['reduce']
Energy Efficiency," Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int, default 10; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, default 1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, default 1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional; ITERATIVE 'power' methods ONLY. Tolerance for lu solve method. If None; given then ``max(0.1*tol, 1e-15)`` is used. matol : float, default 1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' (default); and 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool, default False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = Tru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:7920,power,power,7920,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,4,['power'],['power']
Energy Efficiency," S = 0; for v in range(vmin, vmax + 1):; S += (-1.0) ** (v + j2 + m2) / factorial(v) * \; factorial(j2 + j3 + m1 - v) * factorial(j1 - m1 + v) / \; factorial(j3 - j1 + j2 - v) / factorial(j3 + m3 - v) / \; factorial(v + j1 - j2 - m3); C = C * S; return C. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:5747,energy,energy,5747,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,6,['energy'],['energy']
Energy Efficiency," Same parameter for all the gates; qc = QubitCircuit(N=1); qc.add_gate(""SNOT"", 0). num_tslots = 10; evo_time = 10; processor = OptPulseProcessor(N=1, drift=sigmaz()); processor.add_control(sigmax()); # num_tslots and evo_time are two keyword arguments; tlist, coeffs = processor.load_circuit(; qc, num_tslots=num_tslots, evo_time=evo_time). # Different parameters for different gates; qc = QubitCircuit(N=2); qc.add_gate(""SNOT"", 0); qc.add_gate(""SWAP"", targets=[0, 1]); qc.add_gate('CNOT', controls=1, targets=[0]). processor = OptPulseProcessor(N=2, drift=tensor([sigmaz()]*2)); processor.add_control(sigmax(), cyclic_permutation=True); processor.add_control(sigmay(), cyclic_permutation=True); processor.add_control(tensor([sigmay(), sigmay()])). setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}. tlist, coeffs = processor.load_circuit(; qc, setting_args=setting_args, merge_gates=False). Compiler and scheduler¶. Note; New in QuTiP 4.6. In order to simulate quantum circuits at the level of time evolution.; We need to first compile the circuit into the Hamiltonian model, i.e.; the control pulses.; Hence each Processor has a corresponding; GateCompiler class.; The compiler takes a QubitCircuit; and returns the compiled tlist and coeffs.; It is called implicitly when calling the method; run_state.; from qutip.qip.compiler import SpinChainCompiler; qc = QubitCircuit(2); qc.add_gate(""X"", targets=0); qc.add_gate(""X"", targets=1). processor = LinearSpinChain(2); compiler = SpinChainCompiler(; 2, params=processor.params, pulse_dict=processor.pulse_dict); resolved_qc = qc.resolve_gates([""RX"", ""RZ"", ""ISWAP""]); tlists, coeffs = compiler.compile(resolved_qc); print(tlists); print(coeffs). Output; [array([0., 1.]), array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:9849,schedul,scheduler,9849,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,4,['schedul'],['scheduler']
Energy Efficiency," The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(confi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/utilities.html:7748,energy,energy,7748,docs/4.6/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html,4,['energy'],['energy']
Energy Efficiency," The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__cla",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:7796,energy,energy,7796,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,7,['energy'],['energy']
Energy Efficiency," This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_nor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:219317,efficient,efficient,219317,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['efficient'],['efficient']
Energy Efficiency," Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int {10}; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool {True, False}; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool {True, False}; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional, default=None; ITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method.; If None given then max(0.1*tol, 1e-15) is used. matol : float, optional, default=1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional, default=’COLAMD’; ITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precond : bool optional, default = False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:104070,power,power,104070,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['power'],['power']
Energy Efficiency," Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int {10}; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool {True, False}; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool {True, False}; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional, default=None; ITERATIVE 'power' methods ONLY. Tolerance for lu solve method.; If None given then `max(0.1*tol, 1e-15)` is used. matol : float, optional, default=1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional, default='COLAMD'; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool optional, default = False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditione",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:7403,power,power,7403,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['power'],['power']
Energy Efficiency," [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-tensor.html:4659,energy,energy,4659,docs/4.7/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html,2,['energy'],['energy']
Energy Efficiency," [29]: plt.figure(); Out[29]: <Figure size 640x480 with 0 Axes>. In [30]: plt.plot(tlist, out.expect[0]); Out[30]: [<matplotlib.lines.Line2D at 0x1a251955c0>]. In [31]: plt.plot(tlist, actual_answer); Out[31]: [<matplotlib.lines.Line2D at 0x1a254cc860>]. In [32]: plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; In [33]: a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; In [34]: N = 10. In [35]: w0 = 1.0 * 2 * np.pi. In [36]: g = 0.05 * w0. In [37]: kappa = 0.15. In [38]: times = np.linspace(0, 25, 1000). In [39]: a = destroy(N). In [40]: H = w0 * a.dag() * a + g * (a + a.dag()). In [41]: psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). In [42]: a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. In [43]: e_ops = [a.dag() * a, a + a.dag()]. In [44]: res_brme = brmesolve(H, psi0, times, a_ops, e_ops). In [45]: plt.figure(); Out[45]: <Figure size 640x480 with 0 Axes>. In [46]: plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'); Out[46]: [<matplotlib.lines.Line2D at 0x1a24dff668>]. In [47]: plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'); Out[47]: [<matplotlib.lines.Line2D at 0x1a24dffc50>]. In [48]: plt.legend(); Out[48]: <matplotlib.legend.Le",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-bloch-redfield.html:18372,power,power,18372,docs/4.5/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-bloch-redfield.html,1,['power'],['power']
Energy Efficiency," [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destruction (lowering) operator. Par",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:17840,charge,charge,17840,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['charge'],['charge']
Energy Efficiency," \(\tau\). c_ops : list of qutip.qobj.Qobj. list of collapse operators. a_op : qutip.qobj.Qobj. The annihilation operator of the mode. solver : str. choice of solver (currently only ‘me’). Returns:g2, G2: tuble of *array* :. The normalized and unnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=, []**kwargs)¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:A : qobj. A Hamiltonian or Liouvillian operator. c_op_list : list. A list of collapse operators. method : str {‘direct’, ‘eigen’, ‘iterative-bicg’, ‘iterative-gmres’, ‘svd’, ‘power’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, SVD ‘svd’ (dense), or inverse-power method ‘power’. sparse : bool, optional, default=True. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default=True. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default=False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:69762,power,power,69762,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['power'],['power']
Energy Efficiency," \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:28318,power,power,28318,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,4,['power'],['power']
Energy Efficiency," a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [3]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as $f_{PSU}$ this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [4]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [5], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [6,7",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:9903,efficient,efficient,9903,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['efficient'],['efficient']
Energy Efficiency," a in a_ops]. [docs]def enr_identity(dims, excitations):; """"""; Generate the identity operator for the excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dty",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/operators.html:22410,charge,charge,22410,docs/4.6/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html,12,['charge'],['charge']
Energy Efficiency," a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None). Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels; : List of stringA list of labels for each Hamiltonian. show_ylabels; : Bool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. N; : intThe number of energy levels to plot. figsize; : tuple (int,int)The size of the figure (width, height). fig; : a matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. ax; : a matplotlib axes instanceThe axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:rho : qutip.qobj.Qobj. The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance. The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance. The axes context in which the plot will be drawn. title : string. An optional title for the figure. figsize : (width, height). The size of the matplotlib figure (in inches) ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:114593,energy,energy,114593,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency," a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from qutip.tenso",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/operators.html:22708,charge,charge,22708,docs/4.6/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html,4,['charge'],['charge']
Energy Efficiency," among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:data : array_like. Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list. List of arrays that spans the space for each coordinate. xlabels : list. List of labels for each coordinate. Methods. marginal. project. visualize. visualize_1d. visualize_2d_colormap. visualize_2d_surface. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d : Distributions. A new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d : Distributions. A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,; ax : matplotlib Axes instance; If given, render the visualization using this axis instance.; figsize : tuple; Size of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style : string; Type of visualization: ‘colormap’ (defau",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:34120,reduce,reduced-dimensionality,34120,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['reduce'],['reduced-dimensionality']
Energy Efficiency," and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(vec2mat(data), rhoss.shape[0], rhoss.shape[0]); rhoss.data = 0.5 * (data + data.H); rhoss.isherm = True; if ss_args['return_info']:; return rhoss, ss_args['info']; else:; return rhoss. [docs]def build_preconditioner(A, c_op_list=[], **kwargs):; """"""Constructs a iLU preconditioner necessary for solving for; the steady state density matrix using the ite",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:26413,power,power,26413,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['power'],['power']
Energy Efficiency," and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.te",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/operators.html:22635,charge,charge,22635,docs/4.6/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html,4,['charge'],['charge']
Energy Efficiency," and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function :. The function that is to be called for each value in task_vec. task_vec: array / list :. The list or array of values for which the task function is to be; evaluated. args: list / dictionary :. The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client :. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view :. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False :. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False :. Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table()¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string :. Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. parfor(func, *args, **kwargs)¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; argume",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:108833,schedul,scheduled,108833,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['schedul'],['scheduled']
Energy Efficiency," are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). return result_list. # -----------------------------------------------------------------------------; # Functions for calculting the Bloch-Redfield tensor for a time-independent; # system.; #; [docs]def bloch_redfield_tensor(H, a_ops, spectra_cb, c_ops=None, use_secular=True):; """"""; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system's coupling; to its environment. .. note::. This tensor generation requires a time-independent Hamiltonian. Parameters; ----------. H : :class:`qutip.qobj`; System Hamiltonian. a_ops : list of :class:`qutip.qobj`; List of system operators that couple to the environment. spectra_cb : list of callback functions; List of callback functions that evaluate the noise power spectrum; at a given frequency. c_ops : list of :class:`qutip.qobj`; List of system collapse operators. use_secular : bool; Flag (True of False) that indicates if the secular approximation should; be used. Returns; -------. R, kets: :class:`qutip.Qobj`, list of :class:`qutip.Qobj`. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. """""". # Sanity checks for input parameters; if not isinstance(H, Qobj):; raise TypeError(""H must be an instance of Qobj""). for a in a_ops:; if not isinstance(a, Qobj) or not a.isherm:; raise TypeError(""Operators in a_ops must be Hermitian Qobj.""). # default spectrum; if not spectra_cb:; spectra_cb = [lambda w: 1.0 for _ in a_ops]. # use the eigenbasis; evals, ekets = H.eigenstates(). N = len(evals); K = len(a_ops); A = np.zeros((K, N, N), dtype=complex) # TODO: use sparse here; W = np.zeros((N, N)). # pre-calculate matrix elements; for n in range(N):; for m in range(N):; W[m, n] = np.real(evals",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/bloch_redfield.html:8766,power,power,8766,docs/3.1.0/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/bloch_redfield.html,1,['power'],['power']
Energy Efficiency," array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate on Spin Chain model,; the rotation over X-axis.; We pass the hardware parameters of the SpinChain model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorith",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:11659,schedul,schedules,11659,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,2,['schedul'],['schedules']
Energy Efficiency," bath, so we define two different correlation; functions, \(C_{+}(t)\), and \(C_{-}(t)\):. \[C^{\sigma}(t) = \frac{1}{2\pi} \int_{-\infty}^{\infty} d\omega e^{\sigma i \omega t} J(\omega) f_F[\sigma\beta(\omega - \mu)]\]; where \(\sigma\) is either + or - and, \(f_F\) is the Fermi; distribution function, and \(J(\omega)\) is the Lorentzian spectral density; we defined at the start.; The Fermi distribution function is:. \[f_F (x) = (\exp(x) + 1)^{-1}\]; As in the bosonic case we can approximate this integral with a Matsubara or; Padé expansion. For the Lorentzian bath the Padé expansion converges much; more quickly, so we will calculate the Padé expansion coefficients here.; The Padé decomposition approximates the Fermi distribution as:. \[f_F(x) \approx f_F^{\mathrm{approx}}(x) = \frac{1}{2} - \sum_{l=0}^{Nk} \frac{2k_l x}{x^2 + \epsilon_l^2}\]; where \(k_l\) and \(\epsilon_l\) are coefficients defined in; J. Chem Phys 133, “Efficient on the fly calculation of time correlation functions in computer simulations”,; and \(Nk\) specifies the cut-off in the expansion.; Evaluating the integral for the correlation functions gives:. \[C^{\sigma}(t) \approx \sum_{l=0}^{Nk} \eta^{\sigma,l} e^{-\gamma_{\sigma,l}t}\]; where:. \[ \begin{align}\begin{aligned}\begin{split}\eta_{\sigma, l} &= \begin{cases}; \frac{\Gamma W}{2} f_F^{approx}(i\beta W) & l = 0\\; -i\cdot \frac{k_l}{\beta} \cdot \frac{\Gamma W^2}{-\frac{\epsilon^2_l}{\beta^2} + W^2} & l \neq 0\\; \end{cases}\end{split}\\\begin{split}\gamma_{\sigma,l} &= \begin{cases}; W - \sigma i\mu & l = 0\\; \frac{\epsilon_l}{\beta} - \sigma i \mu & l \neq 0\\; \end{cases}\end{split}\end{aligned}\end{align} \]; and \(\beta = \frac{1}{T}\).; And now we calculate the same numbers in Python:; # Imports; from numpy.linalg import eigvalsh. # Convenience functions and parameters:; def deltafun(j, k):; """""" Kronecker delta function. """"""; return 1.0 if j == k else 0. def f_approx(x, Nk):; """""" Padé approxmation to Fermi distribution. """"""; f = 0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/fermionic.html:11666,Efficient,Efficient,11666,docs/4.7/guide/heom/fermionic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html,1,['Efficient'],['Efficient']
Energy Efficiency," block. state_degeneracy(N, j)[source]¶; Calculate the degeneracy of the Dicke state.; Each state \(|j, m\rangle\) includes D(N,j) irreducible; representations \(|j, m, \alpha\rangle\).; Uses Decimals to calculate higher numerator and denominators numbers. Parameters. N: intThe number of two-level systems. j: floatTotal spin eigenvalue (cooperativity). Returns. degeneracy: intThe state degeneracy. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(|j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. energy_degeneracy(N, m)[source]¶; Calculate the number of Dicke states with same energy.; The use of the Decimals class allows to explore N > 1000,; unlike the built-in function scipy.special.binom. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns. degeneracy: intThe energy degeneracy. ap(j, m)[source]¶; Calculate the coefficient ap by applying J_+ |j, m>.; The action of ap is given by:; \(J_{+}|j, m\rangle = A_{+}(j, m)|j, m+1\rangle\). Parameters. j, m: floatThe value for j and m in the dicke basis |j,m>. Returns. a_plus: floatThe value of \(a_{+}\). am(j, m)[source]¶; Calculate the operator am used later.; The action of ap is given by: J_{-}|j, m> = A_{-}(jm)|j, m-1>. Parameters. j: floatThe value for j. m: floatThe value for m. Returns. a_minus: floatThe value of \(a_{-}\). spin_algebra(N, op=None)[source]¶; Create the list [sx, sy, sz] with the spin operators.; The operators are constructed for a collection of N two-level systems; (TLSs). Each element of the list, i.e., sx, is a vector of qutip.Qobj; objects (spin matrices), as it cointains the list of the SU(2) Pauli; matrices for the N TLSs. Each TLS operator sx[i], with i = 0, …, (N-1),; is placed in a \(2^N\)-dimensional Hilbert space. Para",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:137415,energy,energy,137415,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency," bool optional, default = True. ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional. Preconditioner for A. The preconditioner should approximate the inverse; of A. Effective preconditioning dramatically improves the rate of; convergence, for iterative methods only . If no preconditioner is; given and use_precond=True, then one is generated automatically. fill_factor : float, optional, default=10. ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default=1e-3. ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default=None. ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default=’smilu_2’. Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns:dm : qobj. Steady state density matrix. Notes; The SVD method works only for dense operators (i.e. small systems). Propagators¶. propagator(H, t, c_op_list, args=None, options=None, sparse=False)¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters:H : qobj or list. Hamiltonian",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:72437,reduce,reduced,72437,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['reduce'],['reduced']
Energy Efficiency," by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['total_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = prod(rhoss.shape); L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); L.sort_indices(); orig_nnz = L.nnz. # start with all ones as RHS; v = np.ones(n, dtype=complex). if ss_args['use_rcm']:; if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); v = v[np.ix_(perm,)]; if settings.debug:; new_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' %; round(old_band/new_band, 2)). _power_start = time.time(); # Get LU factors; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:22461,power,power,22461,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['power'],['power']
Energy Efficiency," by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flippin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13284,schedul,scheduler,13284,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,5,"['Schedul', 'schedul']","['Scheduler', 'scheduler']"
Energy Efficiency," by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:13250,schedul,scheduler,13250,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,5,"['Schedul', 'schedul']","['Scheduler', 'scheduler']"
Energy Efficiency," cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag(), np.sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = correlation_ss(H, tlist, c_ops, a.dag(), a); wlist1, spec1 = spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default); wlist2 = np.linspace(0.25, 1.75, 200) * 2 * np.pi; spec2 = spectrum(H, wlist2, c_ops, a.dag(), a). # plot the spectra; fig, ax = plt.subplots(1, 1); ax.plot(wlist1 / (2 * np.pi), spec1, 'b', lw=2, label='eseries method'); ax.plot(wlist2 / (2 * np.pi), spec2, 'r--', lw=2, label='me+fft method'); ax.legend(); ax.set_xlabel('Frequency'); ax.set_ylabel('Power spectrum'); ax.set_title('Vacuum Rabi splitting'); ax.set_xlim(wlist2[0]/(2*np.pi), wlist2[-1]/(2*np.pi)); plt.show(). (Source code, png, hires.png, pdf). Non-steadystate correlation function¶; More generally, we can also calculate correlation functions of the kind \(\left<A(t_1+t_2)B(t_1)\right>\), i.e., the correlation function of a system that is not in its steadystate. In QuTiP, we can evoluate such correlation functions using the function qutip.correlation.correlation_2op_2t. The default behavior of this function is to return a matrix with the correlations as a function of the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-correlation.html:7488,power,power,7488,docs/3.1.0/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-correlation.html,1,['power'],['power']
Energy Efficiency," check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and ss_args['solver'] == 'mkl':; lu.delete(); if ss_args['return_info']:; ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v, np.inf); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(vec2mat(data),; rhoss.shape[0],; rhoss.shape[0]); rhoss.data = 0.5 * (data + data.H); rhoss.isherm = True; if ss_args['",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:29280,power,power,29280,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,4,['power'],['power']
Energy Efficiency," class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:data : array_like. Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list. List of arrays that spans the space for each coordinate. xlabels : list. List of labels for each coordinate. Methods. marginal(dim=0)¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d : Distributions. A new instances of Distribution that describes the marginal; distribution. project(dim=0)¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d : Distributions. A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,; ax : matplotlib Axes instance; If given, render the visualization using this axis instance.; figsize : tuple; Size of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style : string; Type of visualization: ‘colormap’ (default) or ‘",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:31825,reduce,reduced-dimensionality,31825,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,2,['reduce'],['reduced-dimensionality']
Energy Efficiency," consisting of an optomechanical device coupled to a two-level system"", ; Phys. Rev. A 92, 033806 (2015). 107. Mattioli et al., ""From classical to quantum non-equilibrium dynamics of Rydberg excitations in optical lattices"", ; New J. Phys. 17, 113039 (2015). 106. Lambert et al., ""Bistable Photon Emission from a Solid-State Single-Atom Laser"", ; Phys. Rev. Lett. 115, 216803 (2015). 105. Keller et al., ""Precise determination of micromotion for trapped-ion optical clocks"", ; J. Appl. Phys. 118, 104501 (2015). 104. Wen et al., ""A scheme for two-photon lasing with two coupled flux qubits in circuit quantum electrodynamics"", ; Chin. Phys. B 24, 064207 (2015). 103. Gessner et al., ""Probing polariton dynamics in trapped ions with phase-coherent two-dimensional spectroscopy"", ; J. Chem. Phys. 142, 212439 (2015). 102. Bretheau et al., ""Quantum dynamics of an electromagnetic mode that cannot contain N photons"", ; Science 348, 776 (2015). 101. Leggio et al., ""Thermally activated nonlocal amplification in quantum energy transport"", ; Euro. Phys. Lett 110, 40002 (2015). 100. Patrzyk et al., ""Towards a novel environment for simulation of quantum computing"", ; Computer Science 16, 103 (2015). 99. Plankensteiner et al., ""Selective protected state preparation of coupled dissipative quantum emitters"", ; Sci Rep. 5, 16231 (2015). 98. Goryachev et al., ""Single-photon level study of microwave properties of lithium niobate at millikelvin temperatures"", ; Phys. Rev. B 92, 060406(R) 2015). 97. Nation, ""Steady-state solution methods for open quantum optical systems"", ; arXiv:1504.06768. 96. Higgins et al., ""Quantum-Enhanced Capture of Photons Using Optical Ratchet States"", ; J. Phys. Chem. C 121, 20714 (2017). 95. Bassereh et al., ""Perfect energy transport via single edge deletion in a complete network"", ; arXiv:1504.04398. 94. Wiśniewska et al., ""High performance computing and quantum trajectory method in CPU and GPU systems"", ; J. Phys.: Conf. Ser. 574, 012127 (2015). 93. Holland et al., ""S",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:35917,energy,energy,35917,users.html,https://qutip.org,https://qutip.org/users.html,1,['energy'],['energy']
Energy Efficiency," fill_value=u[r, j, -1, best_k]); for j in range(J)]. def _H_t(t, args=None):; return H0 + sum([float(ip_funcs[j](t)) * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_t(times[idx]) * dt).expm(); for idx in range(M-1)]. else:; def _H_idx(idx):; return H0 + sum([u[r, j, idx, best_k] * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. logger.debug(""Time 1: %fs"" % (time.time() - _t0)); _t0 = time.time(). U_f_list = []; U_b_list = []. U_f = 1; U_b = 1; for m in range(M - 1):. U_f = U_list[m] * U_f; U_f_list.append(U_f). U_b_list.insert(0, U_b); U_b = U_list[M - 2 - m].dag() * U_b. logger.debug(""Time 2: %fs"" % (time.time() - _t0)); _t0 = time.time(). for j in range(J):; for m in range(M-1):; P = U_b_list[m] * U; Q = 1j * dt * H_ops[j] * U_f_list[m]. if phase_sensitive:; du = - cy_overlap(P.data, Q.data); else:; du = (- 2 * cy_overlap(P.data, Q.data) *; cy_overlap(U_f_list[m].data, P.data)). if alpha:; # penalty term for high power control signals u; du += -2 * alpha * u[r, j, m, best_k] * dt. if beta:; # penalty term for late control signals u; du += -2 * beta * k ** 2 * u[r, j, k] * dt. for k, eps_val in enumerate(eps_vec):; u[r + 1, j, m, k] = u[r, j, m, k] + eps_val * du.real. if u_limits:; if u[r + 1, j, m, k] < u_limits[0]:; u[r + 1, j, m, k] = u_limits[0]; elif u[r + 1, j, m, k] > u_limits[1]:; u[r + 1, j, m, k] = u_limits[1]. u[r + 1, j, -1, :] = u[r + 1, j, -2, :]. logger.debug(""Time 3: %fs"" % (time.time() - _t0)); _t0 = time.time(). for k, eps_val in enumerate(eps_vec):. def _H_idx(idx):; return H0 + sum([u[r + 1, j, idx, k] * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. Uf[k] = gate_sequence_product(U_list); _k_overlap[k] = _fidelity_function(cy_overlap(Uf[k].data,; U.data)).real. best_k = np.argmax(_k_overlap); logger.debug(""k_overlap: "", _k_overlap, best_k). if _prev_overlap > _k_overlap[best_k]:; logger.debug(""Regression, stepping back with smaller eps.""). u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:15516,power,power,15516,docs/3.1.0/modules/qutip/control/grape.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html,1,['power'],['power']
Energy Efficiency," float numbers. The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None). Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels; : List of stringA list of labels for each Hamiltonian. show_ylabels; : Bool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. N; : intThe number of energy levels to plot. figsize; : tuple (int,int)The size of the figure (width, height). fig; : a matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. ax; : a matplotlib axes instanceThe axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:rho : qutip.qobj.Qobj. The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance. The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance. The axes context in which the plot will be drawn. title : string. An optional title for the figu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:114528,energy,energy,114528,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency," float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/floquet.html:4839,energy,energy,4839,docs/4.6/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html,2,['energy'],['energy']
Energy Efficiency," float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.matrix(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:4732,energy,energy,4732,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,7,['energy'],['energy']
Energy Efficiency," for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = 'smilu_2'; Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns; -------; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information.; """"""; ss_args = _default_steadystate_args(); for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(""Invalid keyword argument '"" + key +; ""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:26318,reduce,reduced,26318,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['reduce'],['reduced']
Energy Efficiency," for this excitation mode. vk : complex; The frequency of the exponent of the excitation term. ck : complex; The coefficient of the excitation term. ck2 : optional, complex; For exponents of type ""RI"" this is the coefficient of the term in the; imaginary expansion (and ``ck`` is the coefficient in the real; expansion). sigma_bar_k_offset : optional, int; For exponents of type ""+"" this gives the offset (within the list of; exponents within the bath) of the corresponding ""-"" bath exponent.; For exponents of type ""-"" it gives the offset of the corresponding; ""+"" exponent. tag : optional, str, tuple or any other object; A label for the exponent (often the name of the bath). It; defaults to None. Attributes; ----------. All of the parameters are available as attributes.; """"""; types = enum.Enum(""ExponentType"", [""R"", ""I"", ""RI"", ""+"", ""-""]). def _check_ck2(self, type, ck2):; if type == self.types[""RI""]:; if ck2 is None:; raise ValueError(""RI bath exponents require ck2""); else:; if ck2 is not None:; raise ValueError(; ""Second co-efficient (ck2) should only be specified for RI""; "" bath exponents""; ). def _check_sigma_bar_k_offset(self, type, offset):; if type in (self.types[""+""], self.types[""-""]):; if offset is None:; raise ValueError(; ""+ and - bath exponents require sigma_bar_k_offset""; ); else:; if offset is not None:; raise ValueError(; ""Offset of sigma bar (sigma_bar_k_offset) should only be""; "" specified for + and - bath exponents""; ). def __init__(; self, type, dim, Q, ck, vk, ck2=None, sigma_bar_k_offset=None,; tag=None,; ):; if not isinstance(type, self.types):; type = self.types[type]; self._check_ck2(type, ck2); self._check_sigma_bar_k_offset(type, sigma_bar_k_offset); self.type = type; self.dim = dim; self.Q = Q; self.ck = ck; self.vk = vk; self.ck2 = ck2; self.sigma_bar_k_offset = sigma_bar_k_offset; self.tag = tag. def __repr__(self):; dims = getattr(self.Q, ""dims"", None); return (; f""<{self.__class__.__name__} type={self.type.name}""; f"" dim={self.dim!r}""; f"" Q.di",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:3138,efficient,efficient,3138,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['efficient'],['efficient']
Energy Efficiency," g_{\alpha\beta}(\tau); \left[\delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}e^{i\omega_{cn}\tau}; -; A^\alpha_{ac} A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; +; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\\end{split}\]; where the “sec” above the summation symbol indicate summation of the secular terms which satisfy \(|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}\). This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function \(g(\tau)\) in terms of the noise-power spectrum of the environment \(S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)\):. (4)\[ \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\beta}",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:8722,energy,energy,8722,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,3,['energy'],['energy']
Energy Efficiency," g_{\alpha\beta}(\tau); \left[\delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}e^{i\omega_{cn}\tau}; -; A^\alpha_{ac} A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; +; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\\end{split}\]; where the “sec” above the summation symbol indicate summation of the secular terms which satisfy \(|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}\). This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function \(g(\tau)\) in terms of the noise-power spectrum of the environment \(S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)\):. (4)¶\[ \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)¶\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\bet",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:8340,energy,energy,8340,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,10,['energy'],['energy']
Energy Efficiency," histogram for the amplitudes of matrix M, using the argument; of each element for coloring the bars, with the given x and y labels; and title. Parameters:M : Matrix of Qobj. The matrix to visualize. xlabels : list of strings. list of x labels. ylabels : list of strings. list of y labels. title : string. title of the plot (optional). limits : list/array with two float numbers. The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers. The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None) :. Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. wigner_cmap(W, levels=1024, shift=0, invert=False)¶; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:80060,energy,energy,80060,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency," histogram for the amplitudes of matrix M, using the argument; of each element for coloring the bars, with the given x and y labels; and title. Parameters:M : Matrix of Qobj. The matrix to visualize. xlabels : list of strings. list of x labels. ylabels : list of strings. list of y labels. title : string. title of the plot (optional). limits : list/array with two float numbers. The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers. The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None). Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:116176,energy,energy,116176,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency," histogram for the amplitudes of matrix M, using the argument; of each element for coloring the bars, with the given x and y labels; and title. Parameters:M : Matrix of Qobj. The matrix to visualize. xlabels : list of strings. list of x labels. ylabels : list of strings. list of y labels. title : string. title of the plot (optional). limits : list/array with two float numbers. The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers. The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None). Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels; : List of stringA list of labels for each Hamiltonian. show_ylabels; : Bool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. N; : intThe number of energy levels to plot. figsize; : tuple (int,int)The size of the figure (width, height). fig; : a matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. ax; : a matplotlib axes instanceThe axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:114097,energy,energy,114097,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency," in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:7210,energy,energy,7210,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,11,['energy'],['energy']
Energy Efficiency," interval; with additional elements added.; Returns num spaced array with elements from elems inserted; if not already included in set.; Returned sample array is not evenly spaced if addtional elements; are added. Parameters. startintThe starting value of the sequence. stopintThe stoping values of the sequence. numint, optionalNumber of samples to generate. elemslist/ndarray, optionalRequested elements to include in array. Returns. samplesndadrrayOriginal equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestrName of data file to be stored, including extension. data: array_likeData to be written to file. numtypestr {‘complex, ‘real’}Type of numerical data. numformatstr {‘decimal’,’exp’}Format for written data. sepstrSingle-character field seperato",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:205598,energy,energy,205598,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency," is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; >>> output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)':; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e or pi will mess things up when using the string-based format. Collapse operators are handled in the exact same way. Function Based Hamiltonian¶; In the previous version of QuTiP, the simulation of time-dependent problems required writing the Hamiltonian itself as a Python function. However, this method does not allow for time-dependent collapse operators, and is therefore more restrictive. Furthermore, it is less efficient than the other methods for all but the most basic of Hamiltonians (see the next section for a comparison of times.). In this format, the entire Hamiltonian is written as a Python function:; def Hfunc(t, args):; H0 = args[0]; H1 = args[1]; w = 9 * exp(-(t/5.)**2); return H0 - w * H1. where the args variable must always be given, and is now a list of Hamiltonian terms: args=[H0, H1]. In this format, our call to the master equation is now:; >>> output = mesolve(Hfunc, psi0, times, c_ops, [a.dag() * a], args=[H0, H1]). We cannot evaluate time-dependent collapse operators in this format, so we can not simulate the previous harmonic oscillator decay example. A Quick Comparison of Simulation Times¶; Here we give a table of simulation times for the single-photon example using the different time-dependent formats and both the master equation and Monte Carlo solver. Format; Master Equation; Monte Carlo. Python Function; 2.1 sec; 27 sec. Cython String; 1.4 sec; 9 sec. Hamiltonian Function; 1.0 sec; 238 sec. For the current example, the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:13589,efficient,efficient,13589,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['efficient'],['efficient']
Energy Efficiency," j1 - j2) *; factorial(j3 - j1 + j2) * factorial(j1 + j2 - j3) *; factorial(j3 + m3) * factorial(j3 - m3) /; (factorial(j1 + j2 + j3 + 1) *; factorial(j1 - m1) * factorial(j1 + m1) *; factorial(j2 - m2) * factorial(j2 + m2))); S = 0; for v in range(vmin, vmax + 1):; S += (-1.0) ** (v + j2 + m2) / factorial(v) * \; factorial(j2 + j3 + m1 - v) * factorial(j1 - m1 + v) / \; factorial(j3 - j1 + j2 - v) / factorial(j3 + m3 - v) / \; factorial(v + j1 - j2 - m3); C = C * S; return C. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The en",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:5520,energy,energy,5520,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,6,['energy'],['energy']
Energy Efficiency," known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:9668,efficient,efficient,9668,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,2,['efficient'],['efficient']
Energy Efficiency," linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = 'iterative'; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use 'iterative'.; For power iterative methods use 'power'. permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = 'smilu_2'; Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns; -------; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information.; """"""; ss_args = _default_steadystate_args(); ss_args['method'] = 'iterative'; for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(""Invalid keyword argument '"" + key +; ""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:33428,reduce,reduced,33428,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,5,['reduce'],['reduced']
Energy Efficiency," linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = 'iterative'; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use 'iterative'.; For power iterative methods use 'power'. permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = 'smilu_2'; Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns; -------; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information.; """"""; ss_args = _default_steadystate_args(); ss_args['method'] = 'iterative'; for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise TypeError(""Invalid keyword argument '"" + key +; ""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:33825,reduce,reduced,33825,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,2,['reduce'],['reduced']
Energy Efficiency," linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = ‘iterative’. Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_spec : str, optional, default=’COLAMD’. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factor : float, optional, default = 100. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = ‘smilu_2’. Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns:lu : object. Returns a SuperLU object representing iLU preconditioner. info : dict, optional. Dictionary containing solver-specific information. Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:106487,reduce,reduced,106487,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['reduce'],['reduced']
Energy Efficiency," linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = ‘iterative’; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_spec : str, optional, default=’COLAMD’; Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = ‘smilu_2’; Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns:; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information. Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, _safe_mode=True, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:108225,reduce,reduced,108225,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['reduce'],['reduced']
Energy Efficiency," list of integer for the dimension of each composite system.; E.g ``[2, 2, 2, 2, 2]`` for 5 qubits system. If None, qubits system; will be the default option.; cyclic_permutation : boolean, optional; Expand for all cyclic permutation of the targets.; E.g. if ``N=3`` and `oper` is a 2-qubit operator,; the result will be a list of three operators,; each acting on qubits 0 and 1, 1 and 2, 2 and 0. Returns; -------; expanded_oper : :class:`qutip.Qobj`; The expanded qubits operator acting on a system with N qubits. Notes; -----; This is equivalent to gate_expand_1toN, gate_expand_2toN,; gate_expand_3toN in ``qutip.qip.gate.py``, but works for any dimension.; """"""; if dims is None:; dims = [2] * N; targets = _targets_to_list(targets, oper=oper, N=N); _check_qubits_oper(oper, dims=dims, targets=targets). # Call expand_operator for all cyclic permutation of the targets.; if cyclic_permutation:; oper_list = []; for i in range(N):; new_targets = np.mod(np.array(targets)+i, N); oper_list.append(; expand_operator(oper, N=N, targets=new_targets, dims=dims)); return oper_list. # Generate the correct order for qubits permutation,; # eg. if N = 5, targets = [3,0], the order is [1,2,3,0,4].; # If the operator is cnot,; # this order means that the 3rd qubit controls the 0th qubit.; new_order = [0] * N; for i, t in enumerate(targets):; new_order[t] = i; # allocate the rest qutbits (not targets) to the empty; # position in new_order; rest_pos = [q for q in list(range(N)) if q not in targets]; rest_qubits = list(range(len(targets), N)); for i, ind in enumerate(rest_pos):; new_order[ind] = rest_qubits[i]; id_list = [identity(dims[i]) for i in rest_pos]; return tensor([oper] + id_list).permute(new_order). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:41842,allocate,allocate,41842,docs/4.6/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html,2,['allocate'],['allocate']
Energy Efficiency," match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. N: intThe number of the component systems. params: dictA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dictA map between the pulse label and its index in the pulse list. gate_compiler: dictThe Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. compile(circuit, schedule_mode=None, args=None)¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate; Notes; This version of sqrtiswap_compiler has very low fidelity, please use; iswap. class SpinChainCompiler(N, params, pulse_dict, setup='linear', global_phase=0.0)[source]¶; Compile a QubitCircuit into; the pulse sequence for the processor. Parameters. N: in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:177688,schedul,schedule,177688,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['schedul'],['schedule']
Energy Efficiency," module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.krylovsolve; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.bofin_baths; qutip.nonmarkov.bofin_solvers; qutip.nonmarkov.dlheom_solver; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.topology; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/index.html:1477,schedul,scheduler,1477,docs/4.7/modules/index.html,https://qutip.org,https://qutip.org/docs/4.7/modules/index.html,2,['schedul'],['scheduler']
Energy Efficiency," nanowire quantum dot"", ; arXiv:1409.4728v1. 57. Feist et al., ""Extraordinary Exciton Conductance Induced by Strong Coupling"", ; Phys. Rev. Lett. 114, 196402 (2015). 56. Molony et al., ""Creation of Ultracold 87RbCs Molecules in the Rovibrational Ground State"", ; Phys. Rev. Lett. 113, 255301 (2014). 55. Lecocq et al., ""Resolving the vacuum fluctuations of an optomechanical system using an artificial atom"", ; Nat. Phys. 11, 635 (2015). 54. Bassereh et al., ""Effect of Noise on the Efficiency of Quantum Excitation Energy Transfer in a Toy Model of a Linear Protein Structure"", ; arXiv:1408.6256. 53. Müller et al., ""Coherent Generation of Nonclassical Light on Chip via Detuned Photon Blockade"", ; Phys. Rev. Lett. 114, 233601 (2015). 52. Reimann et al., ""Cavity-Modified Collective Rayleigh Scattering of Two Atoms"", ; Phys. Rev. Lett. 114, 023601 (2015). 51. Ostermann et al., ""Protected subspace Ramsey metrology"", ; Phys. Rev. A 90, 053823 (2014). 50. Mari et al., ""Quantum optomechanical piston engines powered by heat"", ; J. Phys. B 48, 175501 (2015). 49. Lin et al., ""Josephson parametric phase-locked oscillator and its application to dispersive readout of superconducting qubits"", ; Nat. Commun. 5, 4480 (2014). 48. Lagoudakis et al., ""Hole Spin Pumping and Re-pumping in a p-type δ-doped InAs Quantum Dot"", ; Phys. Rev. B 90, 121402(R) (2014). 47. Figueiredo Roque et al., ""Dissipation-driven squeezed and sub-Poissonian mechanical states in quadratic optomechanical systems"", ; arXiv:1406.1987. 46. Hardal, ""Dynamics of mode entanglement in a system of cavities coupled with a chiral mirror"", ; J. Opt. Soc. Am. B 31, 2339 (2014). 45. Craddock et al., ""The Feasibility of Coherent Energy Transfer in Microtubules"", ; J. R. Soc. Interface 11, 1742 (2014). 44. Seilmeier et al., ""Optical Thermometry of an Electron Reservoir Coupled to a Single Quantum Dot in the Millikelvin Range"", ; Phys. Rev. Applied 2, 024002 (2014). 43. Pfaff et al., ""Unconditional quantum teleportation between dist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:42790,power,powered,42790,users.html,https://qutip.org,https://qutip.org/users.html,1,['power'],['powered']
Energy Efficiency," not significantly change as a result of the interaction with the system; (2) The system and the environment remain separable throughout the evolution. These assumptions are justified if the interaction is weak, and if the environment is much larger than the system. In summary, \(\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}\).; Markov approximation The time-scale of decay for the environment \(\tau_{\rm env}\) is much shorter than the smallest time-scale of the system dynamics \(\tau_{\rm sys} \gg \tau_{\rm env}\). This approximation is often deemed a “short-memory environment” as it requires that environmental correlation functions decay on a time-scale fast compared to those of the system.; Secular approximation Stipulates that elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; mast",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html:10548,energy,energy,10548,docs/4.2/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html,12,['energy'],['energy']
Energy Efficiency," not significantly change as a result of the interaction with the system; (2) The system and the environment remain separable throughout the evolution. These assumptions are justified if the interaction is weak, and if the environment is much larger than the system. In summary, \(\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}\).; Markov approximation The time-scale of decay for the environment \(\tau_{\rm env}\) is much shorter than the smallest time-scale of the system dynamics \(\tau_{\rm sys} \gg \tau_{\rm env}\). This approximation is often deemed a “short-memory environment” as it requires that environmental correlation functions decay on a time-scale fast compared to those of the system.; Secular approximation Stipulates that elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (5) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (5) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; mast",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-master.html:10641,energy,energy,10641,docs/4.5/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-master.html,1,['energy'],['energy']
Energy Efficiency," of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:183831,schedul,schedule,183831,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['schedul'],['schedule']
Energy Efficiency," of a slected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html:9111,power,power,9111,docs/3.1.0/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html,2,['power'],['power']
Energy Efficiency," of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. 5; Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. 6; Mitiq. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:3620,schedul,schedule,3620,docs/4.6/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html,2,['schedul'],['schedule']
Energy Efficiency," of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum objects and data arrays.; The steady-state solver has been further optimized for sparse matrices, and can handle much larger system Hamiltonians.; The steady-state solver can use the iterative bi-conjugate gradient method instead of a direct solver.; There are three new entropy functions for concurrence, mutual information, and conditional entropy.; Correlation functions have been combined under a single function.; The operator norm can now be set to trace, Frobius, one, or max norm.; Global QuTiP settings can now be modified.; QuTiP includes a collection of unit tests for verifying ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:9719,efficient,efficient,9719,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,11,['efficient'],['efficient']
Energy Efficiency," or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; However, this method is somewhat less efficient then the previously mentioned methods.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficie",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:5095,efficient,efficient,5095,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,4,['efficient'],['efficient']
Energy Efficiency," passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['info']['weight']; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if ss_args['sparse']:; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:9955,power,power,9955,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,12,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency," phi. [docs]def wigner(psi, xvec, yvec, method='clenshaw', g=sqrt(2),; sparse=False, parfor=False):; """"""Wigner function for a state vector or density matrix at points; `xvec + i * yvec`. Parameters; ----------. state : qobj; A state vector or density matrix. xvec : array_like; x-coordinates at which to calculate the Wigner function. yvec : array_like; y-coordinates at which to calculate the Wigner function. Does not; apply to the 'fft' method. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`. method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}; Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw' ; and 'iterative' use an iterative method to evaluate the Wigner functions for density; matrices :math:`|m><n|`, while 'laguerre' uses the Laguerre polynomials; in scipy for the same task. The 'fft' method evaluates the Fourier; transform of the density matrix. The 'iterative' method is default, and; in general recommended, but the 'laguerre' method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The 'clenshaw' method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). 'clenshaw' is a fast and numerically stable method. sparse : bool {False, True}; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance.; ; parfor : bool {False, True}; Flag for calculating the Laguerre polynomial based Wigner function; method='laguerre' in parallel using the parfor function. Returns; -------. W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; -----; The 'fft' method accepts only an xvec input for the x-coordinate.; The y-c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/wigner.html:7875,efficient,efficient,7875,docs/4.4/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/wigner.html,1,['efficient'],['efficient']
Energy Efficiency," plot_fock_distribution(rho, offset=0, fig=None, ax=None,; figsize=(8, 6), title=None, unit_y_range=True):; """"""; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :class:`qutip.qobj.Qobj`; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. title : string; An optional title for the figure. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure.; """""". if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). if isket(rho):; rho = ket2dm(rho). N = rho.shape[0]. ax.bar(np.arange(offset, offset + N), np.real(rho.diag()),; color=""green"", alpha=0.6, width=0.8); if unit_y_range:; ax.set_ylim(0, 1). ax.set_xlim(-.5 + offset, N + offset); ax.set_xlabel('Fock number', fontsize=12); ax.set_ylabel('Occupation probability', fontsize=12). if title:; ax.set_title(title). return fig, ax. def fock_distribution(rho, offset=0, fig=None, ax=None,; figsize=(8, 6), title=None, unit_y_range=True):; warnings.warn(""Deprecated: Use plot_fock_distribution""); return plot_fock_distribution(rho, offset=offset, fig=fig, ax=ax,; figsize=figsize, title=title,; unit_y_range=unit_y_range). [docs]def plot_wigner(rho, fig=None, ax=None, figsize=(6, 6),; cmap=None, alpha_max=7.5, colorbar=False,; method='clenshaw', projection='2d'):; """"""; Plot the the Wigner function for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :class:`qutip.qobj.Qobj`; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/visualization.html:20041,green,green,20041,docs/4.5/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/visualization.html,3,['green'],['green']
Energy Efficiency," qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/entropy.html:8577,power,power,8577,docs/4.0.2/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/entropy.html,2,['power'],['power']
Energy Efficiency," qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/entropy.html:8577,power,power,8577,docs/4.2/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/entropy.html,2,['power'],['power']
Energy Efficiency," qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/entropy.html:8577,power,power,8577,docs/4.1/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/entropy.html,2,['power'],['power']
Energy Efficiency," quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/frontmatter.html:4209,efficient,efficiently,4209,docs/3.1.0/frontmatter.html,https://qutip.org,https://qutip.org/docs/3.1.0/frontmatter.html,3,['efficient'],['efficiently']
Energy Efficiency," quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a small number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions by providing the following advantages:. QuTiP relies on completely open-source software. You are free to modify and use it as you wish with no licensing fees.; QuTiP is based on the Python scripting language, provid",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/frontmatter.html:4087,efficient,efficiently,4087,docs/3.0.0/frontmatter.html,https://qutip.org,https://qutip.org/docs/3.0.0/frontmatter.html,2,['efficient'],['efficiently']
Energy Efficiency," r""""""Calculate the degeneracy of the Dicke state. Each state :math:`\lvert j, m\rangle` includes D(N,j) irreducible; representations :math:`\lvert j, m, \alpha\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2 * j + 1); denominator_1 = Decimal(factorial(_ensure_int(N / 2 + j + 1))); denominator_2 = Decimal(factorial(_ensure_int(N / 2 - j))); degeneracy = numerator / (denominator_1 * denominator_2); degeneracy = int(np.round(float(degeneracy))); return degeneracy. [docs]def m_degeneracy(N, m):; r""""""Calculate the number of Dicke states :math:`\lvert j, m\rangle` with; same energy. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue (proportional to the total; energy). Returns; -------; degeneracy: int; The m-degeneracy.; """"""; jvals = j_vals(N); maxj = np.max(jvals); if m < -maxj:; e = ""m value is incorrect for this N.""; e += "" Minimum m value can be {}"".format(-maxj); raise ValueError(e); degeneracy = N / 2 + 1 - abs(m); return int(degeneracy). [docs]def ap(j, m):; r""""""; Calculate the coefficient ``ap`` by applying :math:`J_+\lvert j,m\rangle`. The action of ap is given by:; :math:`J_{+}\lvert j, m\rangle = A_{+}(j, m) \lvert j, m+1\rangle`. Parameters; ----------; j, m: float; The value for j and m in the dicke basis :math:`\lvert j, m\rangle`. Returns; -------; a_plus: float; The value of :math:`a_{+}`.; """"""; a_plus = np.sqrt((j - m) * (j + m + 1)); return a_plus. [docs]def am(j, m):; r""""""Calculate the operator ``am`` used later. The action of ``ap`` is given by:; :math:`J_{-}\lvert j,m\rangle = A_{-}(jm)\lvert j,m-1\rangle`. Parameters; ----------; j: float; The value for j. m: float; The value for m. R",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/piqs.html:17806,energy,energy,17806,docs/4.6/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html,4,['energy'],['energy']
Energy Efficiency," reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 3.02s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.02s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.02s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.02s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.02s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.03s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.03s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.03s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.03s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.03s. Est. time left: 00:00:00:00; Total run time: 25.10s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-parfor.html:6506,power,powerful,6506,docs/4.5/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-parfor.html,1,['power'],['powerful']
Energy Efficiency," same thing with mesolve; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t, args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian ; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = qutip.floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = np.zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:12596,efficient,efficiently,12596,docs/4.7/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html,2,['efficient'],['efficiently']
Energy Efficiency," sample array is not evenly spaced if addtional elements; are added. Parameters:; start : int; The starting value of the sequence. stop : int; The stoping values of the sequence. num : int, optional; Number of samples to generate. elems : list/ndarray, optional; Requested elements to include in array. Returns:; samples : ndadrray; Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:; j1 : float; Total angular momentum 1. j2 : float; Total angular momentum 2. j3 : float; Total angular momentum 3. m1 : float; z-component of angular momentum 1. m2 : float; z-component of angular momentum 2. m3 : float; z-component of angular momentum 3. Returns:; cg_coeff : float; Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:; value : float / array; The energy in the old unit. orig : string; The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string; The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:; value_new_unit : float / array; The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename : str; Name of file containing reqested data. sep : str; Seperator used to store data. Returns:; data : array_like; Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:; filename : str; Name of data file to be stored, including extension. data: array_like; Data to be written to file. numtype : str {‘complex, ‘real’}; Type of numerical data. numformat : str {‘decimal’,’exp’}; Format for written data. sep : str; Single-character field seperator. Usually a tab, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:207936,energy,energy,207936,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency," sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). from qutip.qip.operations.gates import swap; a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/entropy.html:10868,power,power,10868,docs/4.6/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html,2,['power'],['power']
Energy Efficiency," systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. H_sys¶; Qobj – System Hamiltonian. coup_op¶; Qobj – Operator describing the coupling between system and bath. coup_strength¶; float – Coupling strength. temperature¶; float – Bath temperature, in units corresponding to planck. N_cut¶; int – Cutoff parameter for the bath. N_exp¶; int – Number of exponential terms used to approximate the bath correlation; functions. planck¶; float – reduced Planck constant. boltzmann¶; float – Boltzmann’s constant. options¶; qutip.solver.Options – Generic solver options.; If set to None the default options will be used. progress_bar¶; BaseProgressBar – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats¶; qutip.solver.Stats – optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff¶; list of complex – Coefficients for the exponential series terms. exp_freq¶; list of complex – Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:27148,reduce,reduced,27148,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['reduce'],['reduced']
Energy Efficiency," that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method; algoithm used in creating the preconditoner. Should only be used by; advanced users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems). """"""; if solver is None:; solver = 'scipy'; if settings.has_mkl:; if method in ['direct', 'power']:; solver = 'mkl'; elif solver == 'mkl' and \; (method not in ['direct', 'power']):; raise Exception('MKL solver only for direct or power methods.'). elif solver not in ['scipy', 'mkl']:; raise Exception('Invalid solver kwarg.'). if solver == 'scipy':; ss_args = _default_steadystate_args(); elif solver == 'mkl':; ss_args = _mkl_steadystate_args(); else:; raise Exception('Invalid solver keyword argument.'); ss_args['method'] = method; ss_args['info']['solver'] = ss_args['solver']; ss_args['info']['method'] = ss_args['method']. for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(; ""Invalid keyword argument '""+key+""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weigh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:9766,power,power,9766,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,6,['power'],['power']
Energy Efficiency," that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method; algoithm used in creating the preconditoner. Should only be used by; advanced users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems). """"""; if solver is None:; solver = 'scipy'; if settings.has_mkl:; if method in ['direct', 'power']:; solver = 'mkl'; elif solver == 'mkl' and \; (method not in ['direct', 'power']):; raise Exception('MKL solver only for direct or power methods.'). elif solver not in ['scipy', 'mkl']:; raise Exception('Invalid solver kwarg.'). ss_args = _default_steadystate_args(); ss_args['method'] = method; if solver is not None:; ss_args['solver'] = solver; ss_args['info']['solver'] = ss_args['solver']; ss_args['info']['method'] = ss_args['method']. for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(; ""Invalid keyword argument '""+key+""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/steadystate.html:9512,power,power,9512,docs/4.5/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/steadystate.html,3,['power'],['power']
Energy Efficiency," the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. values: array / list; The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the task function. task_kwargs: list / dictionary; The optional additional keyword argument to the task function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns:; result : list; The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]¶; Simultaneous diagonalization of commuting",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:215599,schedul,scheduled,215599,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['schedul'],['scheduled']
Energy Efficiency," the degeneracy of the Dicke state.; Each state \(|j, m\rangle\) includes D(N,j) irreducible; representations \(|j, m, \alpha\rangle\).; Uses Decimals to calculate higher numerator and denominators numbers. Parameters. N: intThe number of two-level systems. j: floatTotal spin eigenvalue (cooperativity). Returns. degeneracy: intThe state degeneracy. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(|j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. energy_degeneracy(N, m)[source]¶; Calculate the number of Dicke states with same energy.; The use of the Decimals class allows to explore N > 1000,; unlike the built-in function scipy.special.binom. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns. degeneracy: intThe energy degeneracy. ap(j, m)[source]¶; Calculate the coefficient ap by applying J_+ |j, m>.; The action of ap is given by:; \(J_{+}|j, m\rangle = A_{+}(j, m)|j, m+1\rangle\). Parameters. j, m: floatThe value for j and m in the dicke basis |j,m>. Returns. a_plus: floatThe value of \(a_{+}\). am(j, m)[source]¶; Calculate the operator am used later.; The action of ap is given by: J_{-}|j, m> = A_{-}(jm)|j, m-1>. Parameters. j: floatThe value for j. m: floatThe value for m. Returns. a_minus: floatThe value of \(a_{-}\). spin_algebra(N, op=None)[source]¶; Create the list [sx, sy, sz] with the spin operators.; The operators are constructed for a collection of N two-level systems; (TLSs). Each element of the list, i.e., sx, is a vector of qutip.Qobj; objects (spin matrices), as it cointains the list of the SU(2) Pauli; matrices for the N TLSs. Each TLS operator sx[i], with i = 0, …, (N-1),; is placed in a \(2^N\)-dimensional Hilbert space. Parameters. N: intThe number of two-level systems. Re",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:137451,energy,energy,137451,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency," the excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax.; ; Parameters; ----------; Nmax : int; Maximum charge state to consider.; ; Nmin : int (default = -Nmax); Lowest charge state to consider.; ; frac : float (default = 1); Specify fractional charge if needed.; ; Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax].; ; Notes; -----; .. versionadded:: 3.2; ; """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form ; :math:`\sum |N><N+m| + |N+m><N|`.; ; Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event.; ; Returns; -------; T : Qobj; Tunneling operator.; ; Notes; -----; .. versionadded:: 3.2; ; """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/operators.html:20903,charge,charge,20903,docs/4.2/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/operators.html,3,['charge'],['charge']
Energy Efficiency," the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate obje",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:12570,schedul,schedule,12570,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,2,['schedul'],['schedule']
Energy Efficiency," the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.G",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:12536,schedul,schedule,12536,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,2,['schedul'],['schedule']
Energy Efficiency," the interval.; b : float; Upper bound of the interval.; coeffs : ndarray; Array of coeffcients defining cubic spline.; ; Notes; -----; This object can be called like a normal function with a; single or array of input points at which to evaluate; the interplating function.; ; Habermann & Kindermann, ""Multidimensional Spline Interpolation: ; Theory and Applications"", Comput Econ 30, 153 (2007). ; ; '''; ; def __init__(self, a, b, y, alpha=0, beta=0):; y = np.asarray(y); n = y.shape[0] - 1; h = (b - a)/n. coeff = np.zeros(n + 3, dtype=y.dtype); # Solutions to boundary coeffcients of spline; coeff[1] = 1/6. * (y[0] - (alpha * h**2)/6) #C2 in paper; coeff[n + 1] = 1/6. * (y[n] - (beta * h**2)/6) #cn+2 in paper. # Compressed tridiagonal matrix ; ab = np.ones((3, n - 1), dtype=float); ab[0,0] = 0 # Because top row is upper diag with one less elem; ab[1, :] = 4; ab[-1,-1] = 0 # Because bottom row is lower diag with one less elem; ; B = y[1:-1].copy() #grabs elements y[1] - > y[n-2] for reduced array; B[0] -= coeff[1]; B[-1] -= coeff[n + 1]. coeff[2:-2] = la.solve_banded((1, 1), ab, B, overwrite_ab=True, ; overwrite_b=True, check_finite=False). coeff[0] = alpha * h**2/6. + 2 * coeff[1] - coeff[2]; coeff[-1] = beta * h**2/6. + 2 * coeff[-2] - coeff[-3]. self.a = a # Lower-bound of domain; self.b = b # Uppser-bound of domain; self.coeffs = coeff # Spline coefficients; self.is_complex = (y.dtype == complex) #Tells which dtype solver to use; ; def __call__(self, pnts, *args):; #If requesting a single return value; if isinstance(pnts, (int, float, complex)):; if self.is_complex:; return zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return interp(pnts, self.a, self.b, self.coeffs); #If requesting multiple return values from array_like; elif isinstance(pnts, (np.ndarray,list)):; pnts = np.asarray(pnts); if self.is_complex:; return arr_zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return arr_interp(pnts, self.a, self.b, self.coeffs). © Copyright 2011 to 2021 inclusive",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/interpolate.html:2034,reduce,reduced,2034,docs/4.7/modules/qutip/interpolate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/interpolate.html,2,['reduce'],['reduced']
Energy Efficiency," the interval.; b : float; Upper bound of the interval.; coeffs : ndarray; Array of coeffcients defining cubic spline.; ; Notes; -----; This object can be called like a normal function with a; single or array of input points at which to evaluate; the interplating function.; ; Habermann & Kindermann, ""Multidimensional Spline Interpolation: ; Theory and Applications"", Comput Econ 30, 153 (2007). ; ; '''; ; def __init__(self, a, b, y, alpha=0, beta=0):; y = np.asarray(y); n = y.shape[0] - 1; h = (b - a)/n. coeff = np.zeros(n + 3, dtype=y.dtype); # Solutions to boundary coeffcients of spline; coeff[1] = 1/6. * (y[0] - (alpha * h**2)/6) #C2 in paper; coeff[n + 1] = 1/6. * (y[n] - (beta * h**2)/6) #cn+2 in paper. # Compressed tridiagonal matrix ; ab = np.ones((3, n - 1), dtype=float); ab[0,0] = 0 # Because top row is upper diag with one less elem; ab[1, :] = 4; ab[-1,-1] = 0 # Because bottom row is lower diag with one less elem; ; B = y[1:-1].copy() #grabs elements y[1] - > y[n-2] for reduced array; B[0] -= coeff[1]; B[-1] -= coeff[n + 1]. coeff[2:-2] = la.solve_banded((1, 1), ab, B, overwrite_ab=True, ; overwrite_b=True, check_finite=False). coeff[0] = alpha * h**2/6. + 2 * coeff[1] - coeff[2]; coeff[-1] = beta * h**2/6. + 2 * coeff[-2] - coeff[-3]. self.a = a # Lower-bound of domain; self.b = b # Uppser-bound of domain; self.coeffs = coeff # Spline coefficients; self.is_complex = (y.dtype == complex) #Tells which dtype solver to use; ; def __call__(self, pnts, *args):; #If requesting a single return value; if isinstance(pnts, (int, float, complex)):; if self.is_complex:; return zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return interp(pnts, self.a, self.b, self.coeffs); #If requesting multiple return values from array_like; elif isinstance(pnts, (np.ndarray,list)):; pnts = np.asarray(pnts); if self.is_complex:; return arr_zinterp(pnts, self.a, ; self.b, self.coeffs); else:; return arr_interp(pnts, self.a, self.b, self.coeffs); ; . © Copyright 2011 and later, P.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/interpolate.html:3697,reduce,reduced,3697,docs/4.2/modules/qutip/interpolate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/interpolate.html,6,['reduce'],['reduced']
Energy Efficiency," the position operator. Returns. Qobj(xs)qutip.QobjThe position operator. Distribution functions¶. class Distribution(data=None, xvecs=[], xlabels=[])[source]¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters. dataarray_likeData for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecslistList of arrays that spans the space for each coordinate. xlabelslistList of labels for each coordinate. marginal(self, dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; marginal distribution. Returns. dDistributionsA new instances of Distribution that describes the marginal; distribution. project(self, dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; projected distribution. Returns. dDistributionsA new instances of Distribution that describes the projection. visualize(self, fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:69296,reduce,reduced,69296,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['reduce'],['reduced']
Energy Efficiency," the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:18011,efficient,efficient,18011,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,2,['efficient'],['efficient']
Energy Efficiency," the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:9114,reduce,reduces,9114,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,2,['reduce'],['reduces']
Energy Efficiency," this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm; [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,…) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,….). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:11152,efficient,efficiently,11152,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,2,['efficient'],['efficiently']
Energy Efficiency," time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:3538,reduce,reduces,3538,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['reduce'],['reduces']
Energy Efficiency," time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_g",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:184461,schedul,schedule,184461,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['schedul'],['schedule']
Energy Efficiency," to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [5], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [6,7] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,...) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,....). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [8] that",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:11343,efficient,efficiently,11343,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['efficient'],['efficiently']
Energy Efficiency," to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. k_maxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:76431,power,power,76431,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['power'],['power']
Energy Efficiency," to sparse matrices, but can be faster; in some cases due to not having to deal with repeated structural; mismatches. densebool, default FalseWhether to swap to using dense matrices to back the data. ompint, optionalThe number of OpenMP threads to use when doing matrix; multiplications, if QuTiP was compiled with OpenMP. Returns. compiled_strstr(Only if code was set to True). The code-generated string of; compiled calling code. compress()[source]¶; Merge together elements that share the same time-dependence, to reduce; the number of matrix multiplications and additions that need to be done; to evaluate this object.; Modifies the object inplace. conj()[source]¶; Return the matrix elementwise conjugation. copy()[source]¶; Return a copy of this object. dag()[source]¶; Return the matrix conjugate-transpose (dagger). expect(t, state, herm=False)[source]¶; Calculate the expectation value of this operator on the given; (time-independent) state at a particular time.; This is more efficient than expect(QobjEvo(t), state). Parameters. tfloatThe time to evaluate this operator at. stateQobj or np.ndarrayThe state to take the expectation value around. hermbool, default FalseWhether this operator and the state are both Hermitian. If True,; only the real part of the result will be returned. See also. expectGeneral-purpose expectation values. mul_mat(t, mat)[source]¶; Multiply this object evaluated at time t by a matrix (from the; right). Parameters. tfloatThe time to evaluate this object at. matQobj or np.ndarrayThe matrix that is multiplied by this object. Returns. mat: Qobj or np.ndarrayThe matrix result in the same type as the input. mul_vec(t, vec)[source]¶; Multiply this object evaluated at time t by a vector. Parameters. tfloatThe time to evaluate this object at. vecQobj or np.ndarrayThe state-vector to multiply this object by. Returns. vec: Qobj or np.ndarrayThe vector result in the same type as the input. permute(order)[source]¶; Permute the tensor structure of the underly",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:25725,efficient,efficient,25725,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['efficient'],['efficient']
Energy Efficiency," to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:13234,monitor,monitor,13234,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,3,"['Monitor', 'monitor']","['Monitoring', 'monitor']"
Energy Efficiency," to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” secti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:8486,monitor,monitor,8486,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,3,"['Monitor', 'monitor']","['Monitoring', 'monitor']"
Energy Efficiency," to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13441,schedul,scheduling,13441,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,2,['schedul'],['scheduling']
Energy Efficiency," to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:13407,schedul,scheduling,13407,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,2,['schedul'],['scheduling']
Energy Efficiency," use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint {10}MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsbool {True, False}MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingbool {True, False}MKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, optional, default=1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, optional, default=1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optional, default=NoneITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method.; If None given then max(0.1*tol, 1e-15) is used. matolfloat, optional, default=1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optional, default=’COLAMD’ITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool optional, default = FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precon",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:104524,power,power,104524,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['power'],['power']
Energy Efficiency," using the exponentiation of the the augmented; matrix.; The propagtor is calculated for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k); aug = self._get_aug_mat(k, j). if dyn.oper_dtype == Qobj:; aug_exp = aug.expm(); prop_grad = Qobj(aug_exp.data[:dg.shape[0], dg.shape[1]:],; dims=dyn.dyn_dims); if compute_prop:; prop = Qobj(aug_exp.data[:dg.shape[0], :dg.shape[1]],; dims=dyn.dyn_dims); else:; aug_exp = la.expm(aug); prop_grad = aug_exp[:dg.shape[0], dg.shape[1]:]; if compute_prop:; prop = aug_exp[:dg.shape[0], :dg.shape[1]]. if compute_prop:; return prop, prop_grad; else:; return prop_grad. [docs]class PropCompFrechet(PropagatorComputer):; """"""; Frechet method for calculating the propagator:; exponentiating the combined dynamics generator; and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient; """"""; [docs] def reset(self):; PropagatorComputer.reset(self); self.id_text = 'FRECHET'; self.grad_exact = True; self.apply_params(). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot using the expm_frechet method; The propagtor is calculated (almost) for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent. if dyn.oper_dtype == Qobj:; A = dyn._get_phased_dyn_gen(k).full()*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).full()*dyn.tau[k]; if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = Qobj(prop_dense, dims=dyn.dyn_dims); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); elif dyn.oper_dtype == np.ndarray:; A = dyn._get_phased_dyn_gen(k)*dyn.tau[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:12373,efficient,efficient,12373,docs/4.3/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html,3,['efficient'],['efficient']
Energy Efficiency," using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation are; processes that describe dissipation in the quantum system due to its interaction; with an environment. These environmental interactions are defined by the; operators through which the system couples to the environment, and rates that; describe the strength of the processes.; In QuTiP, the product of the square root of the rate and the operator that; describe the dissipation process is called a collapse operator. A list of; collapse operators (c_ops) is passed as the fourth argument to the; qutip.mesolve function in order to define the dissipation processes in the master; equation. When the c_ops isn’t empty, the qutip.mesolve function will use; the master equation instead of the unitary Schrödinger equation.; Using the example with the spin dynamics from the previous section, we can; easily add a relaxation process (describing the dissipation of energy from the; spin to its environment), by adding sqrt(0.05) * sigmax() to; the previously empty list in the fourth parameter to the qutip.mesolve function:; >>> times = linspace(0.0, 10.0, 100); >>> result = mesolve(H, psi0, times, [sqrt(0.05) * sigmax()], [sigmaz(), sigmay()]); >>> from pylab import *; >>> plot(times, result.expect[0]); >>> plot(times, result.expect[1]); >>> xlabel('Time'); >>> ylabel('Expectation values'); >>> legend((""Sigma-Z"", ""Sigma-Y"")); >>> show(). Here, 0.05 is the rate and the operator \(\sigma_x\) (qutip.operators.sigmax) describes the dissipation; process. Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in its groundstate and the cavity in a 5-photon Fock state, the dynamics is calculated with the lines following code:; >>> times = lin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:14392,energy,energy,14392,docs/3.0.0/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html,1,['energy'],['energy']
Energy Efficiency," using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation are; processes that describe dissipation in the quantum system due to its interaction; with an environment. These environmental interactions are defined by the; operators through which the system couples to the environment, and rates that; describe the strength of the processes.; In QuTiP, the product of the square root of the rate and the operator that; describe the dissipation process is called a collapse operator. A list of; collapse operators (c_ops) is passed as the fourth argument to the; qutip.mesolve function in order to define the dissipation processes in the master; equation. When the c_ops isn’t empty, the qutip.mesolve function will use; the master equation instead of the unitary Schrödinger equation.; Using the example with the spin dynamics from the previous section, we can; easily add a relaxation process (describing the dissipation of energy from the; spin to its environment), by adding sqrt(0.05) * sigmax() to; the previously empty list in the fourth parameter to the qutip.mesolve function:; In [14]: times = np.linspace(0.0, 10.0, 100). In [15]: result = mesolve(H, psi0, times, [sqrt(0.05) * sigmax()], [sigmaz(), sigmay()]). In [16]: import matplotlib.pyplot as plt. In [17]: fig, ax = plt.subplots(). In [18]: ax.plot(times, result.expect[0]);. In [19]: ax.plot(times, result.expect[1]);. In [20]: ax.set_xlabel('Time');. In [21]: ax.set_ylabel('Expectation values');. In [22]: ax.legend((""Sigma-Z"", ""Sigma-Y""));. In [23]: plt.show(fig). Here, 0.05 is the rate and the operator \(\sigma_x\) (qutip.operators.sigmax) describes the dissipation; process.; Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-master.html:14635,energy,energy,14635,docs/3.0.1/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-master.html,1,['energy'],['energy']
Energy Efficiency," valued matrix element. Note; ----; It is slightly more computationally efficient to use a ket; vector for the 'bra' input. """"""; if not self.isoper:; raise TypeError(""Can only get matrix elements for an operator.""). else:; if bra.isbra and ket.isket:; return zcsr_mat_elem(self.data,bra.data,ket.data,1). elif bra.isket and ket.isket:; return zcsr_mat_elem(self.data,bra.data,ket.data,0); else:; raise TypeError(""Can only calculate matrix elements for bra and ket vectors.""). [docs] def overlap(self, other):; """"""Overlap between two state vectors. Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. Parameters; -----------; other : qobj; Quantum object for a state vector of type 'ket' or 'bra'. Returns; -------; overlap : complex; Complex valued overlap. Raises; ------; TypeError; Can only calculate overlap between a bra and ket quantum objects. Notes; -----; Since QuTiP mainly deals with ket vectors, the most efficient inner product; call is the ket-ket version that computes the product <self|other> with; both vectors expressed as kets. """""". if isinstance(other, Qobj):. if self.isbra:; if other.isket:; return zcsr_inner(self.data, other.data, 1); elif other.isbra:; #Since we deal mainly with ket vectors, the bra-bra combo; #is not common, and not optimized.; return zcsr_inner(self.data, other.dag().data, 1); else:; raise TypeError(""Can only calculate overlap for state vector Qobjs""). elif self.isket:; if other.isbra:; return zcsr_inner(other.data, self.data, 1); elif other.isket:; return zcsr_inner(self.data, other.data, 0); else:; raise TypeError(""Can only calculate overlap for state vector Qobjs""). raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use spars",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:38517,efficient,efficient,38517,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,1,['efficient'],['efficient']
Energy Efficiency," w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/utilities.html:7828,energy,energy,7828,docs/4.6/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html,4,['energy'],['energy']
Energy Efficiency," w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:7876,energy,energy,7876,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,7,['energy'],['energy']
Energy Efficiency," with the given x and y labels; and title. Parameters:M : Matrix of Qobj. The matrix to visualize. xlabels : list of strings. list of x labels. ylabels : list of strings. list of y labels. title : string. title of the plot (optional). limits : list/array with two float numbers. The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers. The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None). Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a densi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:116243,energy,energy,116243,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency," with the given x and y labels; and title. Parameters:M : Matrix of Qobj. The matrix to visualize. xlabels : list of strings. list of x labels. ylabels : list of strings. list of y labels. title : string. title of the plot (optional). limits : list/array with two float numbers. The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers. The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None). Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels; : List of stringA list of labels for each Hamiltonian. show_ylabels; : Bool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. N; : intThe number of energy levels to plot. figsize; : tuple (int,int)The size of the figure (width, height). fig; : a matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. ax; : a matplotlib axes instanceThe axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density mat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:114164,energy,energy,114164,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency," wlist : list / array. list of frequencies for \(\omega\). c_ops : list of qutip.qobj. list of collapse operators. a_op : qutip.qobj. operator A. b_op : qutip.qobj. operator B. Returns:spectrum: *array* :. An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)¶; Calculate the spectrum corresponding to a correlation function; \(\left<A(\tau)B(0)\right>\), i.e., the Fourier transform of the; correlation function:. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right>; e^{-i\omega\tau} d\tau.\end{split}\]. Parameters:H : qutip.qobj. system Hamiltonian. wlist : list / array. list of frequencies for \(\omega\). c_ops : list of qutip.qobj. list of collapse operators. a_op : qutip.qobj. operator A. b_op : qutip.qobj. operator B. Returns:s_vec: *array* :. An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y)¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:tlist : list / array. list/array of times \(t\) which the correlation function is given. y : list / array. list/array of correlations corresponding to time delays \(t\). Returns:w, S : tuple. Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. coherence_function_g1(H, rho0, taulist, c_ops, a_op, solver='me', args=None, options=<qutip.solver.Options instance at 0x2ac686929cf8>)¶; Calculate the first-order quantum coherence function:. \[g^{(1)}(\tau) = \frac{\langle a^\dagger(\tau)a(0)\rangle}; {\sqrt{\langle a^\dagger(\tau)a(\tau)\rangle; \langle a^\dagger(0)a(0)\rangle}}\]. Parameters:H : qutip.qobj.Qobj. system Hamiltonian. rho0 : qutip.qobj.Qobj. Initial state density matrix (or state vector). If ‘rho0’ is; ‘None’, then the steady state will be used as initial state. taulist : list / array. list of times for \(\tau\). c_ops : list of qutip.qobj.Qobj. list of coll",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:66893,power,power,66893,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['power'],['power']
Energy Efficiency," wlist : list / array. list of frequencies for \(\omega\). c_ops : list of qutip.qobj. list of collapse operators. a_op : qutip.qobj. operator A. b_op : qutip.qobj. operator B. Returns:spectrum: *array* :. An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)¶; Calculate the spectrum corresponding to a correlation function; \(\left<A(\tau)B(0)\right>\), i.e., the Fourier transform of the; correlation function:. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right>; e^{-i\omega\tau} d\tau.\end{split}\]. Parameters:H : qutip.qobj. system Hamiltonian. wlist : list / array. list of frequencies for \(\omega\). c_ops : list of qutip.qobj. list of collapse operators. a_op : qutip.qobj. operator A. b_op : qutip.qobj. operator B. Returns:s_vec: *array* :. An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y)¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:tlist : list / array. list/array of times \(t\) which the correlation function is given. y : list / array. list/array of correlations corresponding to time delays \(t\). Returns:w, S : tuple. Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. coherence_function_g1(H, rho0, taulist, c_ops, a_op, solver='me', args=None, options=<qutip.solver.Options instance at 0x2b11f682fcb0>)¶; Calculate the first-order quantum coherence function:. \[g^{(1)}(\tau) = \frac{\langle a^\dagger(\tau)a(0)\rangle}; {\sqrt{\langle a^\dagger(\tau)a(\tau)\rangle; \langle a^\dagger(0)a(0)\rangle}}\]. Parameters:H : qutip.qobj.Qobj. system Hamiltonian. rho0 : qutip.qobj.Qobj. Initial state density matrix (or state vector). If ‘rho0’ is; ‘None’, then the steady state will be used as initial state. taulist : list / array. list of times for \(\tau\). c_ops : list of qutip.qobj.Qobj. list of coll",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:66955,power,power,66955,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"!= len(xtics):; raise ValueError(f""got {nxlabels} xlabels but needed {len(xtics)}""); ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ytics = -0.5 + np.arange(M.shape[1]); ax.axes.w_yaxis.set_major_locator(plt.FixedLocator(ytics)); if ylabels:; nylabels = len(ylabels); if nylabels != len(ytics):; raise ValueError(f""got {nylabels} ylabels but needed {len(ytics)}""); ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/visualization.html:18188,energy,energy,18188,docs/4.6/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html,2,['energy'],['energy']
Energy Efficiency,"""""""; Calculate the overall unitary matrix for a given list of unitary operations; that are still of original dimension. Parameters; ----------; U_list : list of Qobj; List of gates(unitaries) implementing the quantum circuit. ind_list : list of list of int; List of qubit indices corresponding to each gate in tensor_list. Returns; -------; U_overall : qobj; Unitary matrix corresponding to U_list. overall_inds : list of int; List of qubit indices on which U_overall applies. Examples; --------. First, we get some imports out of the way,. >>> from qutip.qip.operations.gates import _gate_sequence_product; >>> from qutip.qip.operations.gates import x_gate, y_gate, toffoli, z_gate. Suppose we have a circuit with gates X, Y, Z, TOFFOLI; applied on qubit indices 0, 1, 2 and [0, 1, 3] respectively. >>> tensor_lst = [x_gate(), y_gate(), z_gate(), toffoli()]; >>> overall_inds = [[0], [1], [2], [0, 1, 3]]. Then, we can use _gate_sequence_product to produce a single unitary; obtained by multiplying unitaries in the list using heuristic methods; to reduce the size of matrices being multiplied. >>> U_list, overall_inds = _gate_sequence_product(tensor_lst, overall_inds); """""". num_qubits = len(set(chain(*ind_list))); sorted_inds = sorted(set(_flatten(ind_list))); ind_list = [[sorted_inds.index(ind) for ind in inds] for inds in ind_list]. U_overall = 1; overall_inds = []. for i, (U, inds) in enumerate(zip(U_list, ind_list)):. # when the tensor_list covers the full dimension of the circuit, we; # expand the tensor_list to a unitary and call _gate_sequence_product; # recursively on the rest of the U_list.; if len(overall_inds) == 1 and len(overall_inds[0]) == num_qubits:; U_overall, overall_inds = _expand_overall(tensor_list, overall_inds); U_left, rem_inds = _gate_sequence_product(U_list[i:],; ind_list[i:]); U_left = expand_operator(U_left, num_qubits, rem_inds); return U_left * U_overall, [sorted_inds[ind] for ind in overall_inds]. # special case for first unitary in the list; if U_ove",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:26926,reduce,reduce,26926,docs/4.6/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html,4,['reduce'],['reduce']
Energy Efficiency,"""""""; numerator = Decimal(factorial(N)); d1 = Decimal(factorial(N / 2 + m)); d2 = Decimal(factorial(N / 2 - m)); degeneracy = numerator / (d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; """"""Calculate the degeneracy of the Dicke state. Each state :math:`|j, m\\rangle` includes D(N,j) irreducible; representations :math:`|j, m, \\alpha\\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2 * j + 1); denominator_1 = Decimal(factorial(N / 2 + j + 1)); denominator_2 = Decimal(factorial(N / 2 - j)); degeneracy = numerator / (denominator_1 * denominator_2); degeneracy = int(np.round(float(degeneracy))); return degeneracy. [docs]def m_degeneracy(N, m):; """"""Calculate the number of Dicke states :math:`|j, m\\rangle` with; same energy. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue (proportional to the total; energy). Returns; -------; degeneracy: int; The m-degeneracy.; """"""; jvals = j_vals(N); maxj = np.max(jvals); if m < -maxj:; e = ""m value is incorrect for this N.""; e += "" Minimum m value can be {}"".format(-maxj); raise ValueError(e); degeneracy = N / 2 + 1 - abs(m); return int(degeneracy). [docs]def ap(j, m):; """"""Calculate the coefficient `ap` by applying J_+ |j, m>. The action of ap is given by:; :math:`J_{+}|j, m\\rangle = A_{+}(j, m)|j, m+1\\rangle`. Parameters; ----------; j, m: float; The value for j and m in the dicke basis |j,m>. Returns; -------; a_plus: float; The value of :math:`a_{+}`.; """"""; a_plus = np.sqrt((j - m) * (j + m + 1)); return a_plus. [docs]def am(j, m):; """"""Calculate the operator `am` used later. The action of ap is given by: J_{-}|j, m> = A_{-}(jm)|j, m-1>. Paramet",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/piqs.html:17465,energy,energy,17465,docs/4.5/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/piqs.html,1,['energy'],['energy']
Energy Efficiency,"""""; ce = self.collective_emission; cd = self.collective_dephasing; cp = self.collective_pumping; c_ops_list = collapse_uncoupled(; N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=ce,; collective_dephasing=cd,; collective_pumping=cp,; ); return c_ops_list. [docs] def coefficient_matrix(self):; """"""Build coefficient matrix for ODE for a diagonal problem. Returns; -------; M: ndarray; The matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis.; """"""; diagonal_system = Pim(; N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=self.collective_emission,; collective_dephasing=self.collective_dephasing,; collective_pumping=self.collective_pumping,; ); coef_matrix = diagonal_system.coefficient_matrix(); return coef_matrix. # Utility functions for properties of the Dicke space; [docs]def energy_degeneracy(N, m):; """"""Calculate the number of Dicke states with same energy. The use of the `Decimals` class allows to explore N > 1000,; unlike the built-in function `scipy.special.binom`. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""; numerator = Decimal(factorial(N)); d1 = Decimal(factorial(N / 2 + m)); d2 = Decimal(factorial(N / 2 - m)); degeneracy = numerator / (d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; """"""Calculate the degeneracy of the Dicke state. Each state :math:`|j, m\\rangle` includes D(N,j) irreducible; representations :math:`|j, m, \\alpha\\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/piqs.html:16078,energy,energy,16078,docs/4.5/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/piqs.html,1,['energy'],['energy']
Energy Efficiency,"""""; ce = self.collective_emission; cd = self.collective_dephasing; cp = self.collective_pumping; c_ops_list = collapse_uncoupled(; N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=ce,; collective_dephasing=cd,; collective_pumping=cp,; ); return c_ops_list. [docs] def coefficient_matrix(self):; """"""Build coefficient matrix for ODE for a diagonal problem. Returns; -------; M: ndarray; The matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis.; """"""; diagonal_system = Pim(; N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=self.collective_emission,; collective_dephasing=self.collective_dephasing,; collective_pumping=self.collective_pumping,; ); coef_matrix = diagonal_system.coefficient_matrix(); return coef_matrix. # Utility functions for properties of the Dicke space; [docs]def energy_degeneracy(N, m):; """"""Calculate the number of Dicke states with same energy. The use of the `Decimals` class allows to explore N > 1000,; unlike the built-in function `scipy.special.binom`. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""; numerator = Decimal(factorial(N)); d1 = Decimal(factorial(_ensure_int(N / 2 + m))); d2 = Decimal(factorial(_ensure_int(N / 2 - m))); degeneracy = numerator / (d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; r""""""Calculate the degeneracy of the Dicke state. Each state :math:`\lvert j, m\rangle` includes D(N,j) irreducible; representations :math:`\lvert j, m, \alpha\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/piqs.html:16200,energy,energy,16200,docs/4.6/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html,4,['energy'],['energy']
Energy Efficiency,"""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:6305,power,power,6305,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,4,['power'],['power']
Energy Efficiency,"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 me",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:6430,energy,energy,6430,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,11,['energy'],['energy']
Energy Efficiency,"# Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; # FIXME: These atol keyword except checks can be removed once scipy 1.1; # is a minimum requirement; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; try:; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = gmres(L, v, tol=mtol,; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:28116,power,power,28116,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['power'],['power']
Energy Efficiency,"# Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:27698,power,power,27698,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,4,['power'],['power']
Energy Efficiency,"# For reference: calculate the same thing with mesolve; p_ex_ref = mesolve(H, psi0, tlist, [], [num(2)], args).expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'ro', tlist, 1-real(p_ex), 'bo'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 10 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); psi_t = floquet_wavefunction(f_modes_t, f_energies, f_coeff, t); p_ex[n] = expect(num(2",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-floquet.html:13503,efficient,efficiently,13503,docs/4.4/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-floquet.html,1,['efficient'],['efficiently']
Energy Efficiency,"%i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:24804,power,power-gmres,24804,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,9,['power'],"['power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"',; 'tan', 'tanh'. If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the numpy math library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. The available functions can be found using; In [1]: import numpy as np. In [2]: np.array(dir(np.math)[6:]); Out[2]: ; array(['acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp',; 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum',; 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf',; 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf',; 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh',; 'tau', 'trunc'], ; dtype='<U9'). Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:4764,efficient,efficient,4764,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['efficient'],['efficient']
Energy Efficiency,"'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'weight': None, 'use_precond': False, ; 'all_states': False, 'M': None, 'x0': None, 'drop_tol': 1e-4, ; 'fill_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000, ; 'tol': 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info': False, 'info': _empty_info_dict(), ; 'verbose': False}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvilli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/steadystate.html:4988,power,power,4988,docs/4.2/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html,12,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"(July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Monte Carlo Solver; Introduction; Monte Carlo in QuTiP; Changing the Number of Trajectories; Reusing Hamiltonian Data; Fortran Based Monte Carlo Solver. « Lindblad Master ... Bloch-Redfield m... ». Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)\[\begin{split}\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\end{split}\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2).",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:1963,monitor,monitored,1963,docs/3.0.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html,1,['monitor'],['monitored']
Energy Efficiency,(TimeslotComputer method). average_gate_fidelity() (in module qutip.metrics). B. basis() (in module qutip.states). (Lattice1d method). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.gates). berry_curvature() (in module qutip.topology). Bloch (class in qutip.bloch). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bloch_wave_functions() (Lattice1d method). block_matrix() (in module qutip.piqs). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bulk_Hamiltonians() (Lattice1d method). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). cell_periodic_parts() (Lattice1d method). cell_structures() (in module qutip.lattice). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). chi_to_choi() (in module qutip.superop_reps). choi_to_chi() (in module qutip.superop_reps). choi_to_kraus() (in module qutip.superop_reps). choi_to_super() (in module qutip.superop_reps). CircularSpinChain (class in qutip.qip.device). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module quti,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/genindex.html:2780,charge,charge,2780,docs/4.5/genindex.html,https://qutip.org,https://qutip.org/docs/4.5/genindex.html,1,['charge'],['charge']
Energy Efficiency,"(by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X, Y and Z gates in circuits. (by Boxi Li); Refactor QubitCircuit.resolve_gate() (by Martín Sande Costa). Bug Fixes¶. F",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:12138,schedul,scheduler,12138,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['schedul'],['scheduler']
Energy Efficiency,"(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [9]: H; Out[9]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; In [10]: N = 10. In [11]: omega_a = 1.0. In [12]: omega_c = 1.25. In [13]: g = 0.05. In [14]: a = tensor(identity(2), destroy(N)). In [15]: sm = tensor(destroy(2), identity(N)). In [16]: sz = tensor(sigmaz(), identity(N)). In [17]: H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In QuTiP the class method qutip.Qobj.ptrace is used to take partial traces. qutip.Qobj.ptrace acts on the qutip.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-tensor.html:6202,energy,energy,6202,docs/4.2/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-tensor.html,6,['energy'],['energy']
Energy Efficiency,"(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [9]: H; Out[9]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; In [10]: N = 10. In [11]: omega_a = 1.0. In [12]: omega_c = 1.25. In [13]: g = 0.05. In [14]: a = tensor(identity(2), destroy(N)). In [15]: sm = tensor(destroy(2), identity(N)). In [16]: sz = tensor(sigmaz(), identity(N)). In [17]: H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In QuTiP the class method qutip.Qobj.ptrace is used to take partial traces. qutip.Qobj.ptrace acts on the qutip.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-tensor.html:7002,energy,energy,7002,docs/3.1.0/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-tensor.html,1,['energy'],['energy']
Energy Efficiency,"(if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(other)[source]¶; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ‘ket’, ‘bra’ or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets. permute(order)[source]¶; Permutes a composite quantum object. Parameters. orderlist/arrayList specifying new tensor order. Returns. Pqutip.QobjPermuted quantum object. proj()[source]¶; Form the projector from a given ket or bra vector. Parameters. Qqutip.QobjInput bra or ket vector. Returns. Pqutip.QobjProjection operator. ptrace(sel, sparse=None)[source]¶; Partial trace of the quantum object. Parameters. selint/listAn int or list of components to keep after partial trace.; The order is unimportant; no transposition will be done and the; spaces will remain in the same order in the output. Returns. operqutip.QobjQuantum object representing partial trace with selected components; remaining. Notes; This function is identical to the qutip.qobj.ptrace function; that has been deprecated. purity()[source]¶; Calculate purity of a quantum object. Returns. state_purityfloatReturns the purity of a quant",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:13142,efficient,efficient,13142,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['efficient'],['efficient']
Energy Efficiency,"(q_oper.dims[0][i]) for i in range(2)][::-1]; return [Qobj(inpt=sqrt(val)*vec2mat(vec, shape=shape),; dims=q_oper.dims[0][::-1]); for val, vec in zip(vals, vecs) if abs(val) >= tol]. [docs]def kraus_to_choi(kraus_list):; """"""; Takes a list of Kraus operators and returns the Choi matrix for the channel; represented by the Kraus operators in `kraus_list`; """"""; kraus_mat_list = list(map(lambda x: matrix(x.data.todense()), kraus_list)); op_rng = range(kraus_mat_list[0].shape[1]); choi_blocks = array([[sum([op[:, c_ix] * array([op.H[r_ix, :]]); for op in kraus_mat_list]); for r_ix in op_rng]; for c_ix in op_rng]); return Qobj(inpt=hstack(hstack(choi_blocks)),; dims=[kraus_list[0].dims[::-1], kraus_list[0].dims[::-1]],; type='super', superrep='choi'). [docs]def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.product(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. [docs]def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). [docs]def chi_to_choi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # convertin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html:9258,power,power,9258,docs/4.5/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html,1,['power'],['power']
Energy Efficiency,")), np.ones((levels, 1)))); zero_pos = int(np.round(levels * np.abs(shift - bounds[0]); / (bounds[1] - bounds[0]))); num_pos = levels - zero_pos; num_neg = zero_pos - 1; # set zero values to mid_color; adjust_RGBA[zero_pos] = mid_color; # interpolate colors; for k in range(0, levels):; if k < zero_pos:; interp = k / (num_neg + 1.0); adjust_RGBA[k][0:3] = (1.0 - interp) * \; min_color[0:3] + interp * neg_color[0:3]; elif k > zero_pos:; interp = (k - zero_pos) / (num_pos + 1.0); adjust_RGBA[k][0:3] = (1.0 - interp) * \; mid_color[0:3] + interp * max_color[0:3]; # create colormap; wig_cmap = mpl.colors.LinearSegmentedColormap.from_list('wigner_cmap',; adjust_RGBA,; N=levels); return wig_cmap. [docs]def complex_phase_cmap():; """"""; Create a cyclic colormap for representing the phase of complex variables. Returns; -------; cmap :; A matplotlib linear segmented colormap.; """"""; cdict = {'blue': ((0.00, 0.0, 0.0),; (0.25, 0.0, 0.0),; (0.50, 1.0, 1.0),; (0.75, 1.0, 1.0),; (1.00, 0.0, 0.0)),; 'green': ((0.00, 0.0, 0.0),; (0.25, 1.0, 1.0),; (0.50, 0.0, 0.0),; (0.75, 1.0, 1.0),; (1.00, 0.0, 0.0)),; 'red': ((0.00, 1.0, 1.0),; (0.25, 0.5, 0.5),; (0.50, 0.0, 0.0),; (0.75, 0.0, 0.0),; (1.00, 1.0, 1.0))}. cmap = mpl.colors.LinearSegmentedColormap('phase_colormap', cdict, 256). return cmap. class MidpointNorm(Normalize):; """"""Normalization for a colormap centered about a given midpoint. Parameters; ----------; midpoint : float (optional, default=0); Midpoint about which colormap is centered.; vmin: float (optional); Minimal value for colormap. Calculated from data by default.; vmax: float (optional); Maximal value for colormap. Calculated from data by default. Returns; -------; Returns a Matplotlib colormap normalization that can be used; with any colormap. """""". def __init__(self, midpoint=0, vmin=None, vmax=None, clip=False):; self.midpoint = midpoint; Normalize.__init__(self, vmin, vmax, clip). def __call__(self, value, clip=None):; x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/matplotlib_utilities.html:5574,green,green,5574,docs/4.6/modules/qutip/matplotlib_utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/matplotlib_utilities.html,4,['green'],['green']
Energy Efficiency,")); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False ; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)); ; def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = self.drift_dyn_gen[0]; else:; dg = self.drift_dyn_gen; for c in self.ctrl_dyn_gen:; dg = dg + c. N = dg.data.shape[0]; n = dg.data.nnz. if N ** 2 < 100 * n:; # large number of nonzero elements, revert to dense solver; self.oper_dtype = np.ndarray; elif N > 400:; # large system, and quite sparse -> qutips sparse method; self.oper_dtype = Qobj; else:; # small system, but quite sparse -> qutips sparse/dense method; self.oper_dtype = np.ndarray. return self.oper_dtype. def _init_evo(self):; """"""; Create the container lists / arrays for the:; dynamics generations, propagators, and evolutions etc; Set the time slices and cumula",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:20922,efficient,efficient,20922,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,2,['efficient'],['efficient']
Energy Efficiency,")); ; if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)); ; if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True ; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)); ; if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True ; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)); ; if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False ; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)); ; def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = self.drift_dyn_gen[0]; else:; dg = self.drift_dyn_gen; if self.time_depend_ctrl_dyn_gen:; ctrls = self.ctrl_dyn_gen[0, :]; else:; ctrls = self.ctrl_dyn_gen; for c in ctrls:; dg = dg + c. N = dg.data.shape[0]; n = dg.data.nnz. if N ** 2 < 100 * n:; # large number of nonzero elements, revert to dense solver; self.oper_dtype = np.ndarray; elif N > 400:; # large system, and quite sparse -> qutips sparse method; self.oper_dtype = Qobj; else:; # small system, but quite sparse -> qutips sparse/dense method; self.oper_dtype = np.ndarray. return self.oper_dtype. def _init_evo(self):; """"""; Create the container lists / arrays for t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:22210,efficient,efficient,22210,docs/4.2/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html,2,['efficient'],['efficient']
Energy Efficiency,). (QubitCircuit method). (SpinChain method). am() (in module qutip.piqs). ap() (in module qutip.piqs). apply_method_params() (Optimizer method). apply_params() (Dynamics method). (FidelityComputer method). (Optimizer method). (PropagatorComputer method). (PulseGen method). (TimeslotComputer method). average_gate_fidelity() (in module qutip.metrics). B. basis() (in module qutip.states). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coefficient_matrix() (Dicke method). (Pim method). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/genindex.html:1918,charge,charge,1918,docs/4.3/genindex.html,https://qutip.org,https://qutip.org/docs/4.3/genindex.html,2,['charge'],['charge']
Energy Efficiency,"); # set options; qtf90.qutraj_run.n_c_ops = config.c_num; qtf90.qutraj_run.n_e_ops = config.e_num; qtf90.qutraj_run.ntraj = ntraj; qtf90.qutraj_run.unravel_type = self.unravel_type; qtf90.qutraj_run.average_states = config.options.average_states; qtf90.qutraj_run.average_expect = config.options.average_expect; qtf90.qutraj_run.init_result(config.psi0_shape[0],; config.options.atol,; config.options.rtol, mf=self.mf,; norm_steps=config.norm_steps,; norm_tol=config.norm_tol); # set optional arguments; qtf90.qutraj_run.order = config.options.order; qtf90.qutraj_run.nsteps = config.options.nsteps; qtf90.qutraj_run.first_step = config.options.first_step; qtf90.qutraj_run.min_step = config.options.min_step; qtf90.qutraj_run.max_step = config.options.max_step; qtf90.qutraj_run.norm_steps = config.options.norm_steps; qtf90.qutraj_run.norm_tol = config.options.norm_tol; # use sparse density matrices during computation?; qtf90.qutraj_run.rho_return_sparse = self.sparse_dms; # calculate entropy of reduced density matrice?; qtf90.qutraj_run.calc_entropy = self.calc_entropy; # run; show_progress = 1 if debug else 0; qtf90.qutraj_run.evolve(instanceno, rngseed, show_progress). # construct Result instance; sol = Result(); sol.ntraj = ntraj; # sol.col_times = qtf90.qutraj_run.col_times; # sol.col_which = qtf90.qutraj_run.col_which-1; sol.col_times, sol.col_which = self.get_collapses(ntraj); if (config.e_num == 0):; sol.states = self.get_states(len(config.tlist), ntraj); else:; sol.expect = self.get_expect(len(config.tlist), ntraj); if (self.calc_entropy):; sol.entropy = self.get_entropy(len(config.tlist)). if (not self.serial_run):; # put to queue; queue.put(sol); queue.join(). # deallocate stuff; # finalize(); return sol. # Routines for retrieving data data from fortran; def get_collapses(self, ntraj):. if debug:; print(inspect.stack()[0][3]). col_times = np.zeros((ntraj), dtype=np.ndarray); col_which = np.zeros((ntraj), dtype=np.ndarray); if (config.c_num == 0):; # no collapses; r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:12699,reduce,reduced,12699,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['reduce'],['reduced']
Energy Efficiency,")]); >>> fig, ax = plt.subplots(); >>> ax.plot(result.times, result.expect[0]) ; >>> ax.plot(result.times, result.expect[1]) ; >>> ax.set_xlabel('Time') ; >>> ax.set_ylabel('Expectation values') ; >>> ax.legend((""Sigma-Z"", ""Sigma-Y"")) ; >>> plt.show() . If an empty list of operators is passed as fourth parameter, the qutip.sesolve function returns a qutip.solver.Result instance that contains a list of state vectors for the times specified in times; >>> times = [0.0, 1.0]; >>> result = sesolve(H, psi0, times, []); >>> result.states ; [Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]], Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.80901699+0.j ]; [0. -0.58778526j]]]. Non-unitary evolution¶; While the evolution of the state vector in a closed quantum system is deterministic, open quantum systems are stochastic in nature. The effect of an environment on the system of interest is to induce stochastic transitions between energy levels, and to introduce uncertainty in the phase difference between states of the system. The state of an open quantum system is therefore described in terms of ensemble averaged states using the density matrix formalism. A density matrix \(\rho\) describes a probability distribution of quantum states \(\left|\psi_n\right>\), in a matrix representation \(\rho = \sum_n p_n \left|\psi_n\right>\left<\psi_n\right|\), where \(p_n\) is the classical probability that the system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:6481,energy,energy,6481,docs/4.7/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html,2,['energy'],['energy']
Energy Efficiency,"+ 1)):; factor = s_factors[i,:]; _factorial_prod(j2 + j3 + m1 - v, factor); _factorial_prod(j1 - m1 + v, factor); _factorial_div(j3 - j1 + j2 - v, factor); _factorial_div(j3 + m3 - v, factor); _factorial_div(v + j1 - j2 - m3, factor); _factorial_div(v, factor); common_denominator = -np.min(s_factors, axis=0); numerators = s_factors + common_denominator; S = sum([(-1)**i * _to_long(vec) for i,vec in enumerate(numerators)]) * \; sign / _to_long(common_denominator); return C * S. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The en",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/utilities.html:6250,energy,energy,6250,docs/4.5/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/utilities.html,5,['energy'],['energy']
Energy Efficiency,"+ j3))), np.int32); sign = (-1) ** (vmin + j2 + m2); for i,v in enumerate(range(vmin, vmax + 1)):; factor = s_factors[i,:]; _factorial_prod(j2 + j3 + m1 - v, factor); _factorial_prod(j1 - m1 + v, factor); _factorial_div(j3 - j1 + j2 - v, factor); _factorial_div(j3 + m3 - v, factor); _factorial_div(v + j1 - j2 - m3, factor); _factorial_div(v, factor); common_denominator = -np.min(s_factors, axis=0); numerators = s_factors + common_denominator; S = sum([(-1)**i * _to_long(vec) for i,vec in enumerate(numerators)]) * \; sign / _to_long(common_denominator); return C * S. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : flo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/utilities.html:5383,energy,energy,5383,docs/4.6/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html,4,['energy'],['energy']
Energy Efficiency,", 'sqrt',; 'tan', 'tanh'. If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the numpy math library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. The available functions can be found using; In [1]: import numpy as np. In [2]: np.array(dir(np.math)[6:]); Out[2]: ; array(['acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp',; 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum',; 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf',; 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf',; 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh',; 'trunc'], ; dtype='<U9'). Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:4658,efficient,efficient,4658,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['efficient'],['efficient']
Energy Efficiency,", 40004 (2015). 132. Iles-Smith et al., ""Energy transfer in structured and unstructured environments: Master equations beyond the Born-Markov approximations"", ; J. Chem. Phys. 144, 044110 (2016). 131. Korkmaz et al., ""Nuclear spin squeezing via electric quadrupole interaction"", ; Phys. Rev. A 93, 013812 (2016). 130. del Pino et al., ""Signatures of Vibrational Strong Coupling in Raman Scattering"", ; J. Phys. Chem. C 119, 29132 (2015). 129. Ardelt et al., ""Optical control of nonlinearly dressed states in an individual quantum dot"", ; Phys. Rev. B 93, 165305 (2016). 128. Deng et al., ""Coupling two distant double quantum dots to a microwave resonator"", ; Nano Letters 15, 6620 (2015). 127. Straubel et al., ""Plasmonic nanoantenna based triggered single-photon source"", ; Phys. Rev. B 93, 195412 (2016). 126. Levi et al., ""Robustness of Many-Body Localization in the Presence of Dissipation"", ; Phys. Rev. Lett. 116, 237203 (2016). 125. Verdon-Akzam et al., ""Asymptotically limitless quantum energy teleportation via qudit probes"", ; Phys. Rev. A 93, 022308 (2016). 124. Overbeck et al., ""Time evolution of open quantum many-body systems"", ; Phys. Rev. A 93, 012106 (2016). 123. Dast et al., ""Purity oscillations in Bose-Einstein condensates with balanced gain and loss"", ; Phys. Rev. A 93, 033617 (2016). 122. Zhao et al., ""Quantum statistics control with a plasmonic nanocavity: Multimode-enhanced interferences"", ; Phys. Rev. A 92, 033836 (2015). 121. Granade et al., ""Practical Bayesian tomography"", ; New J. Phys. 18, 033024 (2016). 120. Wan et al., ""Tolerance in the Ramsey interference of a trapped nanodiamond"", ; Phys. Rev. A 93, 043852 (2016). 119. Cirio et al., ""Ground State Electroluminescence"", ; Phys. Rev. Lett. 116, 113601 (2016). 118. Lee et al., ""Ramsey interference in a multilevel quantum system"", ; Phys. Rev. B 93, 085407 (2016). 117. Huang et al., ""Dark state in a nonlinear optomechanical system with quadratic coupling"", ; Phys. Rev. A 92, 013829 (2015). 116. Friis et al.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:32839,energy,energy,32839,users.html,https://qutip.org,https://qutip.org/users.html,1,['energy'],['energy']
Energy Efficiency,", args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe lis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:211417,schedul,scheduled,211417,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['schedul'],['scheduled']
Energy Efficiency,", args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:255041,schedul,scheduled,255041,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['schedul'],['scheduled']
Energy Efficiency,", b_op, use_pinv=False)¶; Calculate the spectrum corresponding to a correlation function; \(\left<A(\tau)B(0)\right>\), i.e., the Fourier transform of the; correlation function:. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right>; e^{-i\omega\tau} d\tau.\end{split}\]. Parameters:H : qutip.qobj. system Hamiltonian. wlist : list / array. list of frequencies for \(\omega\). c_ops : list of qutip.qobj. list of collapse operators. a_op : qutip.qobj. operator A. b_op : qutip.qobj. operator B. Returns:s_vec: *array* :. An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y)¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:tlist : list / array. list/array of times \(t\) which the correlation function is given. y : list / array. list/array of correlations corresponding to time delays \(t\). Returns:w, S : tuple. Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. coherence_function_g1(H, rho0, taulist, c_ops, a_op, solver='me', args=None, options=<qutip.solver.Options instance at 0x2ac686929cf8>)¶; Calculate the first-order quantum coherence function:. \[g^{(1)}(\tau) = \frac{\langle a^\dagger(\tau)a(0)\rangle}; {\sqrt{\langle a^\dagger(\tau)a(\tau)\rangle; \langle a^\dagger(0)a(0)\rangle}}\]. Parameters:H : qutip.qobj.Qobj. system Hamiltonian. rho0 : qutip.qobj.Qobj. Initial state density matrix (or state vector). If ‘rho0’ is; ‘None’, then the steady state will be used as initial state. taulist : list / array. list of times for \(\tau\). c_ops : list of qutip.qobj.Qobj. list of collapse operators. a_op : qutip.qobj.Qobj. The annihilation operator of the mode. solver : str. choice of solver (‘me’, ‘mc’, ‘es’). Returns:g1, G2: tuble of *array* :. The normalized and unnormalized first-order coherence function. coherence_function_g2(H, rho0, taulist, c_ops, a_op, solver='me', args=None, options=<",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:67249,power,power,67249,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,", b_op, use_pinv=False)¶; Calculate the spectrum corresponding to a correlation function; \(\left<A(\tau)B(0)\right>\), i.e., the Fourier transform of the; correlation function:. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right>; e^{-i\omega\tau} d\tau.\end{split}\]. Parameters:H : qutip.qobj. system Hamiltonian. wlist : list / array. list of frequencies for \(\omega\). c_ops : list of qutip.qobj. list of collapse operators. a_op : qutip.qobj. operator A. b_op : qutip.qobj. operator B. Returns:s_vec: *array* :. An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y)¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:tlist : list / array. list/array of times \(t\) which the correlation function is given. y : list / array. list/array of correlations corresponding to time delays \(t\). Returns:w, S : tuple. Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. coherence_function_g1(H, rho0, taulist, c_ops, a_op, solver='me', args=None, options=<qutip.solver.Options instance at 0x2b11f682fcb0>)¶; Calculate the first-order quantum coherence function:. \[g^{(1)}(\tau) = \frac{\langle a^\dagger(\tau)a(0)\rangle}; {\sqrt{\langle a^\dagger(\tau)a(\tau)\rangle; \langle a^\dagger(0)a(0)\rangle}}\]. Parameters:H : qutip.qobj.Qobj. system Hamiltonian. rho0 : qutip.qobj.Qobj. Initial state density matrix (or state vector). If ‘rho0’ is; ‘None’, then the steady state will be used as initial state. taulist : list / array. list of times for \(\tau\). c_ops : list of qutip.qobj.Qobj. list of collapse operators. a_op : qutip.qobj.Qobj. The annihilation operator of the mode. solver : str. choice of solver (‘me’, ‘mc’, ‘es’). Returns:g1, G2: tuble of *array* :. The normalized and unnormalized first-order coherence function. coherence_function_g2(H, rho0, taulist, c_ops, a_op, solver='me', args=None, options=<",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:67311,power,power,67311,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,", f_coeff, t, H, T, args); p_ex[n] = qutip.expect(qutip.num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). (png, hires.png, pdf). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t, args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian ; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = qutip.floquet_modes_table(f_modes_0, f_energies, tlist, H, T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:12476,efficient,efficiently,12476,docs/4.6/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html,2,['efficient'],['efficiently']
Energy Efficiency,", isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:N : int. Hilbert space dimensionality. dims : list. Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:zero_ket : qobj. Zero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:Nmax : int. Maximum charge state to consider. Nmin : int (default = -Nmax). Lowest charge state to consider. frac : float (default = 1). Specify fractional charge if needed. Returns:C : Qobj. Charge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:N : int. Dimension of Hilbert space. Returns:oper : qobj. Qobj for raising operator. offset : int (default 0). The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:18129,charge,charge,18129,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['charge'],['charge']
Energy Efficiency,", result.expect[0]);. In [13]: ax.plot(result.times, result.expect[1]);. In [14]: ax.set_xlabel('Time');. In [15]: ax.set_ylabel('Expectation values');. In [16]: ax.legend((""Sigma-Z"", ""Sigma-Y""));. In [17]: show(). If an empty list of operators is passed as fifth parameter, the qutip.mesolve function returns a qutip.solver.Result instance that contains a list of state vectors for the times specified in times; In [18]: times = [0.0, 1.0]. In [19]: result = mesolve(H, psi0, times, [], []). In [20]: result.states; Out[20]: ; [Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 1.]; [ 0.]], Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.80901699+0.j ]; [ 0.00000000-0.58778526j]]]. Non-unitary evolution¶; While the evolution of the state vector in a closed quantum system is deterministic, open quantum systems are stochastic in nature. The effect of an environment on the system of interest is to induce stochastic transitions between energy levels, and to introduce uncertainty in the phase difference between states of the system. The state of an open quantum system is therefore described in terms of ensemble averaged states using the density matrix formalism. A density matrix \(\rho\) describes a probability distribution of quantum states \(\left|\psi_n\right>\), in a matrix representation \(\rho = \sum_n p_n \left|\psi_n\right>\left<\psi_n\right|\), where \(p_n\) is the classical probability that the system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html:6741,energy,energy,6741,docs/4.2/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html,3,['energy'],['energy']
Energy Efficiency,", result.expect[0]);. In [13]: ax.plot(result.times, result.expect[1]);. In [14]: ax.set_xlabel('Time');. In [15]: ax.set_ylabel('Expectation values');. In [16]: ax.legend((""Sigma-Z"", ""Sigma-Y""));. In [17]: show(). If an empty list of operators is passed as fifth parameter, the qutip.mesolve function returns a qutip.solver.Result instance that contains a list of state vectors for the times specified in times; In [18]: times = [0.0, 1.0]. In [19]: result = mesolve(H, psi0, times, [], []). In [20]: result.states; Out[20]: ; [Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]], Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.80901699+0.j ]; [ 0.00000000-0.58778526j]]]. Non-unitary evolution¶; While the evolution of the state vector in a closed quantum system is deterministic, open quantum systems are stochastic in nature. The effect of an environment on the system of interest is to induce stochastic transitions between energy levels, and to introduce uncertainty in the phase difference between states of the system. The state of an open quantum system is therefore described in terms of ensemble averaged states using the density matrix formalism. A density matrix \(\rho\) describes a probability distribution of quantum states \(\left|\psi_n\right>\), in a matrix representation \(\rho = \sum_n p_n \left|\psi_n\right>\left<\psi_n\right|\), where \(p_n\) is the classical probability that the system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-master.html:7292,energy,energy,7292,docs/3.1.0/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-master.html,1,['energy'],['energy']
Energy Efficiency,", to_choi, _super_to_superpauli, to_super; from qutip.superoperator import operator_to_vector, vector_to_operator; from qutip.operators import qeye; from qutip.semidefinite import dnorm_problem, dnorm_sparse_problem; import qutip.settings as settings. import qutip.logging_utils as logging; logger = logging.get_logger('qutip.metrics'). try:; import cvxpy; except ImportError:; cvxpy = None. [docs]def fidelity(A, B):; """"""; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""; if A.isket or A.isbra:; if B.isket or B.isbra:; # The fidelity for pure states reduces to the modulus of their; # inner product.; return np.abs(A.overlap(B)); # Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.; sqrtmA = ket2dm(A); else:; if B.isket or B.isbra:; # Swap the order so that we can take a more numerically; # stable square root of B.; return fidelity(B, A); # If we made it here, both A and B are operators, so; # we have to take the sqrtm of one of them.; sqrtmA = A.sqrtm(). if sqrtmA.dims != B.dims:; raise TypeError('Density matrices do not have same dimensions.'). # We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.; eig_vals = (sqrtmA * B * sqrtmA).eigenenergies(); return float(np.real(np.sqrt(eig_vals[eig_vals > 0]).sum())). [docs]def process_fidelity(U1, U2, normalize=True",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/metrics.html:1869,reduce,reduces,1869,docs/4.7/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html,2,['reduce'],['reduces']
Energy Efficiency,", x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so ; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-correlation.html:5152,power,power,5152,docs/4.6/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-correlation.html,2,['power'],['power']
Energy Efficiency,",0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remaining_est(p)); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, p) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)); # display(Javascript(""$('div#%s').width('%i%%')"" % (self.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_done = time.time(); lbl = ""Elapsed time: %s"" % self.time_elapsed(); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, 100.0) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)). def _visualize_parfor_data(metadata):; """"""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""; res = numpy.array(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``cl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html:6239,schedul,scheduling,6239,docs/4.2/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html,11,['schedul'],['scheduling']
Energy Efficiency,"-----------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Return",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:6043,energy,energy,6043,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,11,['energy'],['energy']
Energy Efficiency,"----------; xvec, yvec : array_like; x- and y-coordinates at which to calculate the Husimi-Q function. g : float, default sqrt(2); Scaling factor for ``a = 0.5 * g * (x + iy)``. The value of `g` is; related to the value of `hbar` in the commutation relation; :math:`[x,\,y] = i\hbar` via :math:`\hbar=2/g^2`, so the default; corresponds to :math:`\hbar=1`. memory : real, default 1024; Size in MB that may be used internally as workspace. This class will; raise ``MemoryError`` if subsequently passed a state of sufficiently; large dimension that this bound would be exceeded. In those cases, use; :obj:`.qfunc` with ``precompute_memory=None`` instead to force using; the slower, more memory-efficient algorithm. Examples; --------; Initialise the class for a square set of coordinates, with some states we; want to investigate. >>> xvec = np.linspace(-2, 2, 101); >>> states = [qutip.rand_dm(10) for _ in [None]*10]; >>> qfunc = qutip.QFunc(xvec, xvec). Now we can calculate the Husimi-Q function over each of the states more; efficiently with:. >>> husimiq = np.array([qfunc(state) for state in states]). See Also; --------; :obj:`.qfunc` :; a single function version, which will involve computing several; quantities multiple times in order to use less memory.; """""". def __init__(; self, xvec, yvec, g: float = np.sqrt(2), memory: float = 1024; ):; self._g = g; self._coherent_grid = _QFuncCoherentGrid(xvec, yvec, g); # 16 bytes per complex, 1024**2 bytes per MB.; self._size_mb = self._coherent_grid.grid.size * 16 / (1024 ** 2); self._memory_mb = memory; self._max_size = int(self._memory_mb // self._size_mb); self._current_size = 0; self._cache = None. def _alphas(self, size: int):; r""""""; Retrive the full tensor of (the conjugate of) coherent states over all; values of :math:`\alpha`, for states of dimension ``size``.; """"""; if self._current_size >= size:; return self._cache[:, :, :size]; if size > self._max_size:; requirement = self._size_mb * size; raise MemoryError(; f""Refusing to pr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:22264,efficient,efficiently,22264,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,4,['efficient'],['efficiently']
Energy Efficiency,"-------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from qutip.tensor import tensor. © Copyright 2011 and later, P.D. Nation, J.R. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/operators.html:22754,Charge,Charge,22754,docs/4.6/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html,1,['Charge'],['Charge']
Energy Efficiency,"-------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from qutip.tensor import tensor. © Copyright 2011 to 2021 inclusive, QuTiP deve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/operators.html:21002,Charge,Charge,21002,docs/4.7/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html,1,['Charge'],['Charge']
Energy Efficiency,"-------; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information.; """"""; ss_args = _default_steadystate_args(); ss_args['method'] = 'iterative'; for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(""Invalid keyword argument '"" + key +; ""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. L = _steadystate_setup(A, c_op_list); # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(L.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. n = int(np.sqrt(L.shape[0])); if ss_args['method'] == 'iterative':; ss_list = _steadystate_LU_liouvillian(L, ss_args); L, perm, perm2, rev_perm, ss_args = ss_list; elif ss_args['method'] == 'power':; ss_list = _steadystate_power_liouvillian(L, ss_args); L, perm, perm2, rev_perm, ss_args = ss_list; else:; raise Exception(""Invalid preconditioning method.""). M, ss_args = _iterative_precondition(L, n, ss_args). if ss_args['return_info']:; return M, ss_args['info']; else:; return M. def _pseudo_inverse_dense(L, rhoss, w=None, **pseudo_args):; """"""; Internal function for computing the pseudo inverse of an Liouvillian using; dense matrix methods. See pseudo_inverse for details.; """"""; rho_vec = np.transpose(mat2vec(rhoss.full())). tr_mat = tensor([identity(n) for n in L.dims[0][0]]); tr_vec = np.transpose(mat2vec(tr_mat.full())); N = np.prod(L.dims[0][0]); I = np.identity(N * N); P = np.kron(np.transpose(rho_vec), tr_vec); Q = I - P. if w is None:; L = L; else:; L = 1.0j*w*spre(tr_mat)+L. if pseudo_args['method'] == 'direct':; try:; LIQ = np.linalg.solve(L.full(), Q); except:; LIQ = np.linalg.lstsq(L.full(), Q)[0]. R = np.dot(Q, LIQ). return Qobj(R, dims=L.dims). elif pseudo_a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:34994,power,power,34994,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,5,['power'],['power']
Energy Efficiency,"-------; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information.; """"""; ss_args = _default_steadystate_args(); ss_args['method'] = 'iterative'; for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise TypeError(""Invalid keyword argument '"" + key +; ""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. L = _steadystate_setup(A, c_op_list); # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(L.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. n = int(np.sqrt(L.shape[0])); if ss_args['method'] == 'iterative':; ss_list = _steadystate_LU_liouvillian(L, ss_args); L, perm, perm2, rev_perm, ss_args = ss_list; elif ss_args['method'] == 'power':; ss_list = _steadystate_power_liouvillian(L, ss_args); L, perm, perm2, rev_perm, ss_args = ss_list; else:; raise ValueError(""Invalid preconditioning method.""). M, ss_args = _iterative_precondition(L, n, ss_args). if ss_args['return_info']:; return M, ss_args['info']; else:; return M. def _pseudo_inverse_dense(L, rhoss, w=None, **pseudo_args):; """"""; Internal function for computing the pseudo inverse of an Liouvillian using; dense matrix methods. See pseudo_inverse for details.; """"""; rho_vec = np.transpose(mat2vec(rhoss.full())). tr_mat = tensor([identity(n) for n in L.dims[0][0]]); tr_vec = np.transpose(mat2vec(tr_mat.full())); N = np.prod(L.dims[0][0]); I = np.identity(N * N); P = np.kron(np.transpose(rho_vec), tr_vec); Q = I - P. if w is None:; L = L; else:; L = 1.0j*w*spre(tr_mat)+L. if pseudo_args['method'] == 'direct':; try:; LIQ = np.linalg.solve(L.full(), Q); except Exception:; LIQ = np.linalg.lstsq(L.full(), Q, rcond=None)[0]. R = np.dot(Q, LIQ). return Qobj(R, dims=",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:35391,power,power,35391,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,2,['power'],['power']
Energy Efficiency,"-; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """""";",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:6504,energy,energy,6504,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,11,['energy'],['energy']
Energy Efficiency,"-; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:6721,energy,energy,6721,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,11,['energy'],['energy']
Energy Efficiency,"-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations preven",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:14613,efficient,efficient,14613,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,4,['efficient'],['efficient']
Energy Efficiency,"-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-steady.html:2466,power,power,2466,docs/4.2/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-steady.html,22,"['Power', 'power']","['Power', 'power']"
Energy Efficiency,". 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N : int; Hilbert space dimensionality. dims : list; Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:; zero_ket : qobj; Zero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns:; C : Qobj; Charge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:; N : int; Dimension of Hilbert space. Returns:; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destruction (lowering) operator. Parameters:; N : int; Dimension of Hi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:18378,charge,charge,18378,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['charge'],['charge']
Energy Efficiency,". 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: tensor(sigmaz(), identity(2)); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [6]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [7]: H; Out[7]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [8]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [9]: H; Out[9]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-tensor.html:4580,energy,energy,4580,docs/4.2/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-tensor.html,3,['energy'],['energy']
Energy Efficiency,". 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: tensor(sigmaz(), identity(2)); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [6]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [7]: H; Out[7]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [8]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [9]: H; Out[9]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isherm = True; Qobj data =; [[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-tensor.html:5380,energy,energy,5380,docs/3.1.0/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-tensor.html,1,['energy'],['energy']
Energy Efficiency,". 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [6]: tensor(sigmaz(), identity(2)); Out[6]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [7]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [8]: H; Out[8]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [9]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [10]: H; Out[10]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isherm = True; Qobj data =; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-tensor.html:5237,energy,energy,5237,docs/3.0.0/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html,2,['energy'],['energy']
Energy Efficiency,". 79. Dalmonte et al., ""Cluster Luttinger liquids and emergent supersymmetric conformal critical points in the one-dimensional soft-shoulder Hubbard model"", ; Phys. Rev. B 92, 045106 (2015). 78. Weimer, ""Variational analysis of driven-dissipative Rydberg gases"", ; Phys. Rev. A 91, 063401 (2015). 77. Schulte et al., ""Quantum Algorithmic Readout in Multi-Ion Clocks"", ; Phys. Rev. Lett. 116, 013002 (2016). 76. Dalmonte et al., ""Realizing dipolar spin models with arrays of superconducting qubits"", ; Phys. Rev. B 92, 174507 (2015). 75. Neilinger et al., ""Two-photon lasing by a superconducting qubit"", ; Phys. Rev. B 91, 104516 (2015). 74. Elliott et al., ""Enhancement and state tomography of a squeezed vacuum with circuit quantum electrodynamics"", ; Phys. Rev. A 92, 013826 (2015). 73. Borregaard et al., ""Heralded Quantum Gates with Integrated Error Detection in Optical Cavities"", ; Phys. Rev. Lett. 114, 110502 (2015). 72. Killoran et al., ""Enhancing light-harvesting power with coherent vibrational interactions: a quantum heat engine picture"", ; J. Chem. Phys. 143, 155102 (2015). 71. Lu et al., ""Squeezed Optomechanics with Phase-Matched Amplification and Dissipation"", ; Phys. Rev. Lett. 114, 093602 (2015). 70. Hush et al., ""Spin correlations as a probe of quantum synchronization in trapped-ion phonon lasers"", ; Phys. Rev. A 91, 061401(R) (2015). 69. Hauke et al., ""Probing entanglement in adiabatic quantum optimization with trapped ions"", ; Front. Phys. 3, 21 (2015). 68. Nation et al., ""Iterative solutions to the steady-state density matrix for optomechanical systems"", ; Phys. Rev. E 91, 013307 (2015). 67. Schlawin et al., ""Nonlinear spectroscopy of trapped ions"", ; Phys. Rev. A 90, 023603 (2014). 66. Dunning et al., ""Composite pulses for interferometry in a thermal cold atom cloud"", ; Phys. Rev. A 90, 033608 (2014). 65. Rosado et al., ""Upper-bounded and sliced Jaynes- and anti-Jaynes-Cummings Hamiltonians and Liouvillians in cavity quantum electrodynamics"", ; J. Modern Opti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:39858,power,power,39858,users.html,https://qutip.org,https://qutip.org/users.html,1,['power'],['power']
Energy Efficiency,". AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. methodstr, default = ‘iterative’Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_specstr, optional, default=’COLAMD’Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factorfloat, optional, default = 100Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, optional, default = 1e-4Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optional, default = NoneSets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_M",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:107935,power,power,107935,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,12,['power'],['power']
Energy Efficiency,". List of system operators that couple to bath degrees of freedom. e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. args : dictionary. Dictionary of parameters for time-dependent Hamiltonians and collapse; operators. options : qutip.Qdeoptions. Options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; a list of expectation values, for operators given in e_ops, or a list; of states for the times specified by tlist. bloch_redfield_tensor(H, a_ops, spectra_cb, use_secular=True)¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system’s coupling; to its environment. Parameters:H : qutip.qobj. System Hamiltonian. a_ops : list of qutip.qobj. List of system operators that couple to the environment. spectra_cb : list of callback functions. List of callback functions that evaluate the noise power spectrum; at a given frequency. use_secular : bool. Flag (True of False) that indicates if the secular approximation should; be used. Returns:R, kets: :class:`qutip.qobj`, list of :class:`qutip.qobj` :. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=, []options=None)¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters:R : qutip.qobj. Bloch-Redfield tensor. ekets : array of qutip.qobj. Array of kets that make up a basis tranformation for the eigenbasis. rho0 : qutip.qobj. Initial density matrix. tlist : list / array. List of times for \(t\). e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. options : qutip.Qdeoptions. Options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:45728,power,power,45728,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['power'],['power']
Energy Efficiency,". Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; linspace(0, T, 500 + 1), H, T, args). # solve the floquet-markov master equation; output = fmmesolve(H, psi0, tlist, [sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = zeros(shape(tlist), dtype=complex); for idx, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); p_ex[idx] = expect(num(2), output.states[idx].transform(f_modes_t, True)). # For reference: calculate the same thing with mesolve; output = mesolve(H, psi0, tlist, [sqrt(gamma1) * sigmax()], [num(2)], args); p_ex_ref = output.expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'r--', tlist, 1-real(p_ex), 'b--'); plot(tlist, real(p_ex",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html:17932,power,power,17932,docs/4.2/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html,9,['power'],['power']
Energy Efficiency,". Notes; Experimental. wigner(psi, xvec, yvec, method='clenshaw', g=1.4142135623730951, sparse=False, parfor=False)[source]¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:; state : qobj; A state vector or density matrix. xvec : array_like; x-coordinates at which to calculate the Wigner function. yvec : array_like; y-coordinates at which to calculate the Wigner function. Does not; apply to the ‘fft’ method. g : float; Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). method : string {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}; Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method. sparse : bool {False, True}; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parfor : bool {False, True}; Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns:; W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are cal",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:126813,efficient,efficient,126813,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['efficient'],['efficient']
Energy Efficiency,". Notes; The ‘operator’ method (default) generates; the thermal state using the truncated number operator num(N). This; is the method that should be used in computations. The; ‘analytic’ method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N (int) – Hilbert space dimensionality; dims (list) – Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:zero_ket – Zero ket on given Hilbert space. Return type:qobj. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax (int) – Maximum charge state to consider.; Nmin (int (default = -Nmax)) – Lowest charge state to consider.; frac (float (default = 1)) – Specify fractional charge if needed. Returns:C – Charge operator over [Nmin,Nmax]. Return type:Qobj. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:N (int) – Dimension of Hilbert space. Returns:; oper (qobj) – Qobj for raising operator.; offset (int (default 0)) – The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:18623,charge,charge,18623,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['charge'],['charge']
Energy Efficiency,". Quantum Information Processing — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing. Quantum Information Processing¶. Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-qip.html:1386,schedul,scheduler,1386,docs/4.6/guide/guide-qip.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-qip.html,2,['schedul'],['scheduler']
Energy Efficiency,". Quantum Information Processing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing. Quantum Information Processing¶. Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-qip.html:1445,schedul,scheduler,1445,docs/4.7/guide/guide-qip.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-qip.html,2,['schedul'],['scheduler']
Energy Efficiency,". This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [3]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as $f_{PSU}$ this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [4]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [5], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial re",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:9555,efficient,efficient,9555,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['efficient'],['efficient']
Energy Efficiency,". ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N : int; Hilbert space dimensionality. dims : list; Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:; zero_ket : qobj; Zero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns:; C : Qobj; Charge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:; N : int; Dimension of Hilbert space. Returns:; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:18305,charge,charge,18305,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['charge'],['charge']
Energy Efficiency,". def qubit_clifford_group(N=None, target=0):; """"""; Generates the Clifford group on a single qubit,; using the presentation of the group given by Ross and Selinger; (https://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2),; _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if targ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/operations/gates.html:29382,reduce,reduce,29382,docs/4.7/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/operations/gates.html,2,['reduce'],['reduce']
Energy Efficiency,". out.superrep = self.superrep. return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible object for division""). def __neg__(self):; """"""; NEGATION operation.; """"""; out = Qobj(); out.data = -self.data; out.dims = self.dims; out.superrep = self.superrep; out._isherm = self._isherm; return out.tidyup() if settings.auto_tidyup else out. def __getitem__(self, ind):; """"""; GET qobj elements.; """"""; out = self.data[ind]; if sp.issparse(out):; return np.asarray(out.todense()); else:; return out. def __eq__(self, other):; """"""; EQUALITY operator.; """"""; if (isinstance(other, Qobj) and; self.dims == other.dims and; not np.any(np.abs((self.data - other.data).data) >; settings.atol)):; return True; else:; return False. def __ne__(self, other):; """"""; INEQUALITY operator.; """"""; return not (self == other). def __pow__(self, n, m=None): # calculates powers of Qobj; """"""; POWER operation.; """"""; if self.type not in ['oper', 'super']:; raise Exception(""Raising a qobj to some power works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. except:; raise ValueError('Invalid choice of exponent.'). def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t + ""\n""); s += ""Qobj data =\n"". if shape[0] > 10000 or shape[1] > 10000:; # if the system is huge, don't attempt to convert to a; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:18310,power,power,18310,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,2,['power'],['power']
Energy Efficiency,". purityfloatThe purity of the quantum state.; It’s 1 for pure states, 0<=purity<1 for mixed states. entropy_vn_dicke(rho)[source]¶; Von Neumann Entropy of a Dicke-basis density matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. entropy_dm: floatEntropy. Use degeneracy to multiply each block. state_degeneracy(N, j)[source]¶; Calculate the degeneracy of the Dicke state.; Each state \(|j, m\rangle\) includes D(N,j) irreducible; representations \(|j, m, \alpha\rangle\).; Uses Decimals to calculate higher numerator and denominators numbers. Parameters. N: intThe number of two-level systems. j: floatTotal spin eigenvalue (cooperativity). Returns. degeneracy: intThe state degeneracy. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(|j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. energy_degeneracy(N, m)[source]¶; Calculate the number of Dicke states with same energy.; The use of the Decimals class allows to explore N > 1000,; unlike the built-in function scipy.special.binom. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns. degeneracy: intThe energy degeneracy. ap(j, m)[source]¶; Calculate the coefficient ap by applying J_+ |j, m>.; The action of ap is given by:; \(J_{+}|j, m\rangle = A_{+}(j, m)|j, m+1\rangle\). Parameters. j, m: floatThe value for j and m in the dicke basis |j,m>. Returns. a_plus: floatThe value of \(a_{+}\). am(j, m)[source]¶; Calculate the operator am used later.; The action of ap is given by: J_{-}|j, m> = A_{-}(jm)|j, m-1>. Parameters. j: floatThe value for j. m: floatThe value for m. Returns. a_minus: floatThe value of \(a_{-}\). spin_algebra(N, op=None)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:137030,energy,energy,137030,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,". qutip.control.fidcomp — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.fidcomp. Source code for qutip.control.fidcomp; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling wi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/fidcomp.html:841,efficient,efficient,841,docs/4.7/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/fidcomp.html,2,['efficient'],['efficient']
Energy Efficiency,". qutip.operators — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.operators. Source code for qutip.operators; """"""; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators.; """""". __all__ = ['jmat', 'spin_Jx', 'spin_Jy', 'spin_Jz', 'spin_Jm', 'spin_Jp',; 'spin_J_set', 'sigmap', 'sigmam', 'sigmax', 'sigmay', 'sigmaz',; 'destroy', 'create', 'qeye', 'identity', 'position', 'momentum',; 'num', 'squeeze', 'squeezing', 'displace', 'commutator',; 'qutrit_ops', 'qdiags', 'phase', 'qzero', 'enr_destroy',; 'enr_identity', 'charge', 'tunneling']. import numbers; import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.dimensions import flatten. #; # Spin operators; #; [docs]def jmat(j, *args):; """"""Higher-order spin operators:. Parameters; ----------; j : float; Spin of operator. args : str; Which operator to return 'x','y','z','+','-'.; If no args given, then output is ['x','y','z']. Returns; -------; jmat : qobj / ndarray; ``qobj`` for requested spin operator(s). Examples; --------; >>> jmat(1) # doctest: +SKIP; [ Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0. 0.70710678 0. ]; [ 0.70710678 0. 0.70710678]; [ 0. 0.70710678 0. ]]; Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.-0.70710678j 0.+0.j ]; [ 0.+0.70710678j 0.+0.j 0.-0.70710678j]; [ 0.+0.j 0.+0.70710678j 0.+0.j ]]; Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. -1.]]]. Notes; -----; If no 'args' input, then returns array of ['x','y','z'] ope",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/operators.html:822,charge,charge,822,docs/4.7/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/operators.html,2,['charge'],['charge']
Energy Efficiency,". qutip.qip.compiler.gatecompiler — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.gatecompiler. Source code for qutip.qip.compiler.gatecompiler; import numpy as np; from .instruction import Instruction; from .scheduler import Scheduler; from ..circuit import QubitCircuit, Gate. __all__ = ['GateCompiler']. [docs]class GateCompiler(object):; """"""; Base class. It compiles a :class:`.QubitCircuit` into; the pulse sequence for the processor. The core member function; `compile` calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters; ----------; N: int; The number of the component systems. params: dict, optional; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optional; A map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; ``(pulse_label, coeff)``, instead of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling routine saved under the attributes ``gate_compiler``. Attributes; ----------; gate_compiler: dict; The Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dict; Arguments for individual compiling routines.; It adds more flexibility in customizing compiler.; """"""; def __init__(self, N, params=None, pulse_dict=None):; self.gate_compiler = {}; self.N = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/gatecompiler.html:464,schedul,scheduler,464,docs/4.7/modules/qutip/qip/compiler/gatecompiler.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/gatecompiler.html,3,"['Schedul', 'schedul']","['Scheduler', 'scheduler']"
Energy Efficiency,". qutip.qip.compiler.scheduler — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.scheduler. Source code for qutip.qip.compiler.scheduler; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:21,schedul,scheduler,21,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,6,['schedul'],['scheduler']
Energy Efficiency,". qutip.qip.compiler.scheduler — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.scheduler. Source code for qutip.qip.compiler.scheduler; from collections import deque; from copy import deepcopy; from functools import cmp_to_key; from random import shuffle. from ..circuit import QubitCircuit, Gate; from .instruction import Instruction. class InstructionsGraph():; """"""; A directed acyclic graph (DAG) representation; of the quantum instruction dependency.; An example is Fig3(b) in https://doi.org/10.1117/12.666419.; It contains methods of generating the instruction dependency graph,; a list-schedule algorithm to find the topological order; and the computation of the distance in the weighted graph; (circuit latency). It uses the `Instruction` object as a representation of node; and adds the following attributes to it:. predecessors, successors: dependency arrow of the DAG; distance_to_start, distance_to_end: longest distance to the start and end. Parameters; ----------; instructions: list; A list of instructions. Attributes; ----------; nodes: list; The input list of instruction with additional graph information.; start, end: list; List of indices of nodes connected to the start or end nodes.; """"""; def __init__(self, instructions):; instructions = deepcopy(instructions); self.nodes = []; for instruction in instructions:; if isinstance(instruction, Gate):; self.nodes.append(Instruction(instruction)); else:; self.nodes.append(instruction); for node in self.nodes:; if node.duration is None:; node.duration = 1; self.start = None; self.end = None. def generate_dependency_graph(self, commuting):; """"""; Generate the instruction dependency graph.; It modifies the class attribute `nodes`, where each element (node); is an `Instructio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/scheduler.html:21,schedul,scheduler,21,docs/4.7/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/scheduler.html,8,['schedul'],"['schedule', 'scheduler']"
Energy Efficiency,". qutip.qip.operations.gates — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.operations.gates. Source code for qutip.qip.operations.gates; import numbers; from collections.abc import Iterable; from itertools import product, chain; from functools import partial, reduce; from operator import mul. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.operators import identity, qeye, sigmax, sigmay, sigmaz; from qutip.tensor import tensor; from qutip.states import fock_dm. __all__ = ['rx', 'ry', 'rz', 'sqrtnot', 'snot', 'phasegate', 'qrot',; 'x_gate', 'y_gate', 'z_gate', 'cy_gate', 'cz_gate', 's_gate',; 't_gate', 'qasmu_gate', 'cs_gate', 'ct_gate', 'cphase', 'cnot',; 'csign', 'berkeley', 'swapalpha', 'swap', 'iswap', 'sqrtswap',; 'sqrtiswap', 'fredkin', 'molmer_sorensen',; 'toffoli', 'rotation', 'controlled_gate',; 'globalphase', 'hadamard_transform', 'gate_sequence_product',; 'gate_expand_1toN', 'gate_expand_2toN', 'gate_expand_3toN',; 'qubit_clifford_group', 'expand_operator']. #; # Single Qubit Gates; #. def x_gate(N=None, target=0):; """"""Pauli-X gate or sigmax operator. Returns; -------; result : :class:`qutip.Qobj`; Quantum object for operator describing; a single-qubit rotation through pi radians around the x-axis. """"""; if N is not None:; return gate_expand_1toN(x_gate(), N, target); return sigmax(). def y_gate(N=None, target=0):; """"""Pauli-Y gate or sigmay operator. Returns; -------; result : :class:`qutip.Qobj`; Quantum object for operator describing; a single-qubit rotation through pi radians around the y-axis. """"""; if N is not None:; return gate_expand_1toN(y_gate(), N, target); return sigmay(). def cy_gate(N=None, control=0, target=1):; """"""Controlled Y gate. Returns; -------; result : :cl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/operations/gates.html:508,reduce,reduce,508,docs/4.7/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/operations/gates.html,2,['reduce'],['reduce']
Energy Efficiency,". xlabels : list of strings. list of x labels. ylabels : list of strings. list of y labels. title : string. title of the plot (optional). limits : list/array with two float numbers. The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers. The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None). Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:rho : qutip.qobj.Qobj. The densi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:116290,energy,energy,116290,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,". xlabels : list of strings. list of x labels. ylabels : list of strings. list of y labels. title : string. title of the plot (optional). limits : list/array with two float numbers. The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers. The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None). Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels; : List of stringA list of labels for each Hamiltonian. show_ylabels; : Bool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. N; : intThe number of energy levels to plot. figsize; : tuple (int,int)The size of the figure (width, height). fig; : a matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. ax; : a matplotlib axes instanceThe axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:rho : qutip.qobj.Qobj. The density mat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:114211,energy,energy,114211,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,".2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.4.0 (July 03, 2019)¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3.; quite.cite() is improved.; Added matplotlib as optional depend",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/changelog.html:1780,efficient,efficient,1780,docs/4.4/changelog.html,https://qutip.org,https://qutip.org/docs/4.4/changelog.html,1,['efficient'],['efficient']
Energy Efficiency,".602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; #",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:6124,energy,energy,6124,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,11,['energy'],['energy']
Energy Efficiency,".Line2D at 0x10b4fddd0>]. In [10]: legend(['0.5','1.0','2.0']); Out[10]: <matplotlib.legend.Legend at 0x10df0d310>. In [11]: xlabel(r'Time $t$'); Out[11]: <matplotlib.text.Text at 0x10d29b1d0>. In [12]: ylabel(r'Correlation $\left<x(t)x(0)\right>$'); Out[12]: <matplotlib.text.Text at 0x10d263f90>. In [13]: show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from qutip import *; import pylab as plt. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag(), np.sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-correlation.html:6393,power,power,6393,docs/3.1.0/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-correlation.html,1,['power'],['power']
Energy Efficiency,".X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:4795,adapt,adaptive,4795,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['adapt'],['adaptive']
Energy Efficiency,".dag().data.todense(). return Qobj(B, dims=dims). # PRIVATE CONVERSION FUNCTIONS ------------------------------------------------; # These functions handle the main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); sqrt_shape = int(sqrt(data.shape[0])); return Qobj(dims=q_oper.dims,; inpt=data.reshape([sqrt_shape] * 4).; transpose(3, 1, 2, 0).reshape(q_oper.data.shape)). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**floor(log2(dim)) == dim; for dim in flatten(dims); ]). def _super_to_superpauli(q_oper):; """"""; Converts a superoperator in the column-stacking basis to; the Pauli basis (assuming qubit dimensions). This is an internal function, as QuTiP does not currently have; a way to mark that superoperators are represented in the Pauli; basis as opposed to the column-stacking basis; a Pauli-basis; ``type='super'`` would thus break other conversion functions.; """"""; # Ensure we start with a column-stacking-basis superoperator.; sqobj = to_super(q_oper); if not _isqubitdims(sqobj.dims):; raise ValueError(""Pauli basis is only defined for qubits.""); nq = int(log2(sqobj.shape[0]) / 2); B = _pauli_basis(nq) / sqrt(2**nq); # To do this, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html:5853,power,powers,5853,docs/4.1/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html,5,['power'],['powers']
Energy Efficiency,".g., the qutip.correlation.correlation_2op_1t function. These correlation function solvers return a vector or matrix (in general complex) with the correlations as a function of the delays times. Steadystate correlation function¶; The following code demonstrates how to calculate the \(\left<x(t)x(0)\right>\) correlation for a leaky cavity with three different relaxation rates.; times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-correlation.html:4560,power,power,4560,docs/4.6/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-correlation.html,2,['power'],['power']
Energy Efficiency,".min([j2 + j3 + m1, j3 - j1 + j2, j3 + m3])). C = np.sqrt((2.0 * j3 + 1.0) * factorial(j3 + j1 - j2) *; factorial(j3 - j1 + j2) * factorial(j1 + j2 - j3) *; factorial(j3 + m3) * factorial(j3 - m3) /; (factorial(j1 + j2 + j3 + 1) *; factorial(j1 - m1) * factorial(j1 + m1) *; factorial(j2 - m2) * factorial(j2 + m2))); S = 0; for v in range(vmin, vmax + 1):; S += (-1.0) ** (v + j2 + m2) / factorial(v) * \; factorial(j2 + j3 + m1 - v) * factorial(j1 - m1 + v) / \; factorial(j3 - j1 + j2 - v) / factorial(j3 + m3 - v) / \; factorial(v + j1 - j2 - m3); C = C * S; return C. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : flo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:5431,energy,energy,5431,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,6,['energy'],['energy']
Energy Efficiency,".pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at https://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:20403,schedul,schedule,20403,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,2,['schedul'],['schedule']
Energy Efficiency,".qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (eta",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:1885,schedul,schedule,1885,docs/4.6/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html,2,['schedul'],['schedule']
Energy Efficiency,"0, gate1, (gate3, gate4), (gate2, gate5), gate6]``; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles.; """"""; circuit = deepcopy(circuit); if repeat_num > 0:; random_shuffle = True; result = [0]; max_length = 4294967296; for i in range(repeat_num):; gate_cycle_indices = self.schedule(; circuit, gates_schedule=gates_schedule,; return_cycles_list=return_cycles_list,; random_shuffle=random_shuffle, repeat_num=0); current_length = max(gate_cycle_indices); if current_length < max_length:; result = gate_cycle_indices; max_length = current_length; return result. if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit. # Generate the quantum operations dependency graph.; instructions_graph = InstructionsGraph(gates); instructions_graph.generate_dependency_graph(; commuting=self.commutation_rules); if self.method == ""ALAP"":; instructions_graph.reverse_graph(). # Schedule without hardware constraints, then; # use this cycles_list to compute the distance.; cycles_list, _ = instructions_graph.find_topological_order(; priority=False, apply_constraint=None, random=random_shuffle); instructions_graph.compute_distance(cycles_list=cycles_list). # Schedule again with priority and hardware constraint.; cycles_list, constraint_dependency = \; instructions_graph.find_topological_order(; priority=True, apply_constraint=self.apply_constraint,; random=random_shuffle). # If we only need gates schedule, we can output the result here.; if gates_schedule or return_cycles_list:; if self.method == ""ALAP"":; cycles_list.reverse(); if return_cycles_list:; return cycles_list; gate_cycles_indices = [0] * len(gates); for cycle_ind, cycle in enumerate(cycles_list):; for instruction_ind in cycle:; gate_cycles_indices[instruction_ind] = cycle_ind; return gate_cycles_indices. # For pulse schedule,; # we add the hardware dependency to the graph; # and compute the longest distance to the start node again.; # The longest",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:17912,Schedul,Schedule,17912,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,2,['Schedul'],['Schedule']
Energy Efficiency,"0. 0. 0. 0. 0. 0.14142136; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0. 0. 11.75 0. 0.; 0. 0. 0. 0. 0. 0.; 0.15 0. ]; [ 0. 0.05 0. 0. 0. 0.; 0. 0. 0. 0. -0.5 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0.07071068 0. 0. 0.; 0. 0. 0. 0. 0. 0.75; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0.08660254 0. 0.; 0. 0. 0. 0. 0. 0.; 2. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0.1 0.; 0. 0. 0. 0. 0. 0.; 0. 3.25 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.1118034; 0. 0. 0. 0. 0. 0.; 0. 0. 4.5 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0.12247449 0. 0. 0. 0. 0.; 0. 0. 0. 5.75 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0.13228757 0. 0. 0. 0.; 0. 0. 0. 0. 7. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0. 0.14142136 0. 0. 0.; 0. 0. 0. 0. 0. 8.25; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0.15 0. 0.; 0. 0. 0. 0. 0. 0.; 9.5 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 10.75 ]]. Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In QuTiP the class method qutip.Qobj.ptrace is used to take partial traces. qutip.Qobj.ptrace acts on the qutip.Qobj instance for which it is called, and it takes one argument sel, which is a list of integers that mark the component systems that should be kept. All other components are traced out.; For example, the density matrix describing a single qubit obtained from a coupled two-qubit system is obtained via:; >>> psi = tensor(basis(2, 0), basis(2, 1)). >>> psi.ptrace(0); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. >>> psi.ptrace(1); Quantum object: dims = [[2], [2]], shape = (2, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-tensor.html:8311,reduce,reduces,8311,docs/4.6/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html,4,['reduce'],['reduces']
Energy Efficiency,"0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. triplet_states()[source]¶; Returns a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:20363,charge,charge,20363,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,12,['charge'],['charge']
Energy Efficiency,"0. 0. 0.03125]]. triplet_states()[source]¶; Returns a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:20509,charge,charge,20509,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['charge'],['charge']
Energy Efficiency,"0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-tensor.html:4598,energy,energy,4598,docs/4.6/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html,2,['energy'],['energy']
Energy Efficiency,"0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:N : int. Hilbert space dimensionality. dims : list. Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:zero_ket : qobj. Zero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:Nmax : int. Maximum charge state to consider. Nmin : int (default = -Nmax). Lowest charge state to consider. frac : float (default = 1). Specify fractional charge if needed. Returns:C : Qobj. Charge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:N : int. Dimension of Hilbert space. Returns:oper : qobj. Qobj for raising operator. offset : int (default 0). The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destruction (lowering) operator. Parameters:N : int. Dimension of Hilbert space. offset : ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:18265,charge,charge,18265,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['charge'],['charge']
Energy Efficiency,"0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. Notes; The ‘operator’ method (default) generates; the thermal state using the truncated number operator num(N). This; is the method that should be used in computations. The; ‘analytic’ method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N (int) – Hilbert space dimensionality; dims (list) – Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:zero_ket – Zero ket on given Hilbert space. Return type:qobj. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax (int) – Maximum charge state to consider.; Nmin (int (default = -Nmax)) – Lowest charge state to consider.; frac (float (default = 1)) – Specify fractional charge if needed. Returns:C – Charge operator over [Nmin,Nmax]. Return type:Qobj. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:N (int) – Dimension of Hilbert space. Returns:; oper (qobj) – Qobj for raising operator.; offset (int (default 0)) – The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:18558,charge,charge,18558,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['charge'],['charge']
Energy Efficiency,"0000053282376. In [39]: tracedist(y, y); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-states.html:11451,energy,energy,11451,docs/4.3/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html,1,['energy'],['energy']
Energy Efficiency,"00102501865. In [39]: tracedist(y, y); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-states.html:11577,energy,energy,11577,docs/4.2/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-states.html,2,['energy'],['energy']
Energy Efficiency,"0; eigvals = eigvals[idx_nonzero]; eigstates = eigstates[idx_nonzero]. if method == 'clip':; eigvals[eigvals < 0] = 0; elif method == 'sgs':; eigvals = eigvals[::-1]; eigstates = eigstates[::-1]. acc = 0.0; dim = self.shape[0]; n_eigs = len(eigvals). for idx in reversed(range(n_eigs)):; if eigvals[idx] + acc / (idx + 1) >= 0:; break; else:; acc += eigvals[idx]; eigvals[idx] = 0.0. eigvals[:idx+1] += acc / (idx + 1). return sum([; val * qutip.states.ket2dm(state); for val, state in zip(eigvals, eigstates); ], Qobj(np.zeros(self.shape), dims=self.dims); ).unit(). [docs] def matrix_element(self, bra, ket):; """"""Calculates a matrix element. Gives the matrix element for the quantum object sandwiched between a; `bra` and `ket` vector. Parameters; -----------; bra : :class:`qutip.Qobj`; Quantum object of type 'bra' or 'ket'. ket : :class:`qutip.Qobj`; Quantum object of type 'ket'. Returns; -------; elem : complex; Complex valued matrix element. Note; ----; It is slightly more computationally efficient to use a ket; vector for the 'bra' input. """"""; if not self.isoper:; raise TypeError(""Can only get matrix elements for an operator.""). else:; if bra.isbra and ket.isket:; return zcsr_mat_elem(self.data, bra.data, ket.data, 1). elif bra.isket and ket.isket:; return zcsr_mat_elem(self.data, bra.data, ket.data, 0); else:; err = ""Can only calculate matrix elements for bra""; err += "" and ket vectors.""; raise TypeError(err). [docs] def overlap(self, other):; """"""Overlap between two state vectors or two operators. Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters; -----------; other : :class:`qutip.Qobj`; Quantum object for a state vector of type 'ket', 'bra' or density; matrix. Returns; -------; overlap : complex; Complex valued overlap. Raises; ------; TypeError; Can only calculate overlap between a bra, ket and density matrix; qua",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobj.html:39516,efficient,efficient,39516,docs/4.5/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobj.html,1,['efficient'],['efficient']
Energy Efficiency,"0; eigvals = eigvals[idx_nonzero]; eigstates = eigstates[idx_nonzero]. if method == 'clip':; eigvals[eigvals < 0] = 0; elif method == 'sgs':; eigvals = eigvals[::-1]; eigstates = eigstates[::-1]. acc = 0.0; dim = self.shape[0]; n_eigs = len(eigvals). for idx in reversed(range(n_eigs)):; if eigvals[idx] + acc / (idx + 1) >= 0:; break; else:; acc += eigvals[idx]; eigvals[idx] = 0.0. eigvals[:idx+1] += acc / (idx + 1). return sum([; val * qutip.states.ket2dm(state); for val, state in zip(eigvals, eigstates); ], Qobj(np.zeros(self.shape), dims=self.dims); ).unit(). [docs] def matrix_element(self, bra, ket):; """"""Calculates a matrix element. Gives the matrix element for the quantum object sandwiched between a; `bra` and `ket` vector. Parameters; -----------; bra : :class:`qutip.Qobj`; Quantum object of type 'bra' or 'ket'. ket : :class:`qutip.Qobj`; Quantum object of type 'ket'. Returns; -------; elem : complex; Complex valued matrix element. Note; ----; It is slightly more computationally efficient to use a ket; vector for the 'bra' input. """"""; if not self.isoper:; raise TypeError(""Can only get matrix elements for an operator.""). else:; if bra.isbra and ket.isket:; return zcsr_mat_elem(self.data,bra.data,ket.data,1). elif bra.isket and ket.isket:; return zcsr_mat_elem(self.data,bra.data,ket.data,0); else:; raise TypeError(""Can only calculate matrix elements for bra and ket vectors.""). [docs] def overlap(self, other):; """"""Overlap between two state vectors or two operators. Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters; -----------; other : :class:`qutip.Qobj`; Quantum object for a state vector of type 'ket', 'bra' or density; matrix. Returns; -------; overlap : complex; Complex valued overlap. Raises; ------; TypeError; Can only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; -----; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:38082,efficient,efficient,38082,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,1,['efficient'],['efficient']
Energy Efficiency,"0]]),; np.fliplr(psi.conj()),; np.zeros((1, n//2 - 1))), axis=1); r2 = np.concatenate((np.array([[0]]), psi,; np.zeros((1, n//2 - 1))), axis=1); w = la.toeplitz(np.zeros((n//2, 1)), r1) * \; np.flipud(la.toeplitz(np.zeros((n//2, 1)), r2)); w = np.concatenate((w[:, n//2:n], w[:, 0:n//2]), axis=1); w = ft.fft(w); w = np.real(np.concatenate((w[:, 3*n//4:n+1], w[:, 0:n//4]), axis=1)); p = np.arange(-n/4, n/4)*np.pi / (n*(xvec[1] - xvec[0])); w = w / (p[1] - p[0]) / n; return w, p. def _osc_eigen(N, pnts):; """"""; Vector of and N-dim oscillator eigenfunctions evaluated; at the points in pnts.; """"""; pnts = np.asarray(pnts); lpnts = len(pnts); A = np.zeros((N, lpnts)); A[0, :] = np.exp(-pnts ** 2 / 2.0) / pi ** 0.25; if N == 1:; return A; else:; A[1, :] = np.sqrt(2) * pnts * A[0, :]; for k in range(2, N):; A[k, :] = np.sqrt(2.0 / k) * pnts * A[k - 1, :] - \; np.sqrt((k - 1.0) / k) * A[k - 2, :]; return A. def _wigner_clenshaw(rho, xvec, yvec, g=sqrt(2), sparse=False):; """"""; Using Clenshaw summation - numerically stable and efficient; iterative algorithm to evaluate polynomial series. The Wigner function is calculated as; :math:`W = e^(-0.5*x^2)/pi * \sum_{L} c_L (2x)^L / sqrt(L!)` where; :math:`c_L = \sum_n \\rho_{n,L+n} LL_n^L` where; :math:`LL_n^L = (-1)^n sqrt(L!n!/(L+n)!) LaguerreL[n,L,x]`. """""". M = np.prod(rho.shape[0]); X,Y = np.meshgrid(xvec, yvec); #A = 0.5 * g * (X + 1.0j * Y); A2 = g * (X + 1.0j * Y) #this is A2 = 2*A. B = np.abs(A2); B *= B; w0 = (2*rho.data[0,-1])*np.ones_like(A2); L = M-1; #calculation of \sum_{L} c_L (2x)^L / sqrt(L!); #using Horner's method; if not sparse:; rho = rho.full() * (2*np.ones((M,M)) - np.diag(np.ones(M))); while L > 0:; L -= 1; #here c_L = _wig_laguerre_val(L, B, np.diag(rho, L)); w0 = _wig_laguerre_val(L, B, np.diag(rho, L)) + w0 * A2 * (L+1)**-0.5; else:; while L > 0:; L -= 1; diag = _csr_get_diag(rho.data.data,rho.data.indices,; rho.data.indptr,L); if L != 0:; diag *= 2; #here c_L = _wig_laguerre_val(L, B, np.diag(rho, L)); w0 = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/wigner.html:15160,efficient,efficient,15160,docs/4.5/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/wigner.html,1,['efficient'],['efficient']
Energy Efficiency,"0]]),; np.fliplr(psi.conj()),; np.zeros((1, n//2 - 1))), axis=1); r2 = np.concatenate((np.array([[0]]), psi,; np.zeros((1, n//2 - 1))), axis=1); w = la.toeplitz(np.zeros((n//2, 1)), r1) * \; np.flipud(la.toeplitz(np.zeros((n//2, 1)), r2)); w = np.concatenate((w[:, n//2:n], w[:, 0:n//2]), axis=1); w = ft.fft(w); w = np.real(np.concatenate((w[:, 3*n//4:n+1], w[:, 0:n//4]), axis=1)); p = np.arange(-n/4, n/4)*np.pi / (n*(xvec[1] - xvec[0])); w = w / (p[1] - p[0]) / n; return w, p. def _osc_eigen(N, pnts):; """"""; Vector of and N-dim oscillator eigenfunctions evaluated; at the points in pnts.; """"""; pnts = np.asarray(pnts); lpnts = len(pnts); A = np.zeros((N, lpnts)); A[0, :] = np.exp(-pnts ** 2 / 2.0) / pi ** 0.25; if N == 1:; return A; else:; A[1, :] = np.sqrt(2) * pnts * A[0, :]; for k in range(2, N):; A[k, :] = np.sqrt(2.0 / k) * pnts * A[k - 1, :] - \; np.sqrt((k - 1.0) / k) * A[k - 2, :]; return A. def _wigner_clenshaw(rho, xvec, yvec, g=sqrt(2), sparse=False):; """"""; Using Clenshaw summation - numerically stable and efficient; iterative algorithm to evaluate polynomial series.; ; The Wigner function is calculated as; :math:`W = e^(-0.5*x^2)/pi * \sum_{L} c_L (2x)^L / sqrt(L!)` where ; :math:`c_L = \sum_n \\rho_{n,L+n} LL_n^L` where; :math:`LL_n^L = (-1)^n sqrt(L!n!/(L+n)!) LaguerreL[n,L,x]`; ; """""". M = np.prod(rho.shape[0]); X,Y = np.meshgrid(xvec, yvec); #A = 0.5 * g * (X + 1.0j * Y); A2 = g * (X + 1.0j * Y) #this is A2 = 2*A. B = np.abs(A2); B *= B; w0 = (2*rho.data[0,-1])*np.ones_like(A2); L = M-1; #calculation of \sum_{L} c_L (2x)^L / sqrt(L!); #using Horner's method; if not sparse:; rho = rho.full() * (2*np.ones((M,M)) - np.diag(np.ones(M))); while L > 0:; L -= 1; #here c_L = _wig_laguerre_val(L, B, np.diag(rho, L)); w0 = _wig_laguerre_val(L, B, np.diag(rho, L)) + w0 * A2 * (L+1)**-0.5; else:; while L > 0:; L -= 1; diag = _csr_get_diag(rho.data.data,rho.data.indices,; rho.data.indptr,L); if L != 0:; diag *= 2; #here c_L = _wig_laguerre_val(L, B, np.diag(rho, L));",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/wigner.html:14978,efficient,efficient,14978,docs/4.4/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/wigner.html,1,['efficient'],['efficient']
Energy Efficiency,"0]]),; np.fliplr(psi.conj()),; np.zeros((1, n//2 - 1))), axis=1); r2 = np.concatenate((np.array([[0]]), psi,; np.zeros((1, n//2 - 1))), axis=1); w = la.toeplitz(np.zeros((n//2, 1)), r1) * \; np.flipud(la.toeplitz(np.zeros((n//2, 1)), r2)); w = np.concatenate((w[:, n//2:n], w[:, 0:n//2]), axis=1); w = ft.fft(w); w = np.real(np.concatenate((w[:, 3*n//4:n+1], w[:, 0:n//4]), axis=1)); p = np.arange(-n/4, n/4)*np.pi / (n*(xvec[1] - xvec[0])); w = w / (p[1] - p[0]) / n; return w, p. def _osc_eigen(N, pnts):; """"""; Vector of and N-dim oscillator eigenfunctions evaluated; at the points in pnts.; """"""; pnts = np.asarray(pnts); lpnts = len(pnts); A = np.zeros((N, lpnts)); A[0, :] = np.exp(-pnts ** 2 / 2.0) / pi ** 0.25; if N == 1:; return A; else:; A[1, :] = np.sqrt(2) * pnts * A[0, :]; for k in range(2, N):; A[k, :] = np.sqrt(2.0 / k) * pnts * A[k - 1, :] - \; np.sqrt((k - 1.0) / k) * A[k - 2, :]; return A. def _wigner_clenshaw(rho, xvec, yvec, g=sqrt(2), sparse=False):; """"""; Using Clenshaw summation - numerically stable and efficient; iterative algorithm to evaluate polynomial series.; ; The Wigner function is calculated as; :math:`W = e^(-0.5*x^2)/pi * \sum_{L} c_L (2x)^L / sqrt(L!)` where ; :math:`c_L = \sum_n \\rho_{n,L+n} LL_n^L` where; :math:`LL_n^L = (-1)^n sqrt(L!n!/(L+n)!) LaguerreL[n,L,x]`; ; """""". M = np.prod(rho.shape[0]); X,Y = np.meshgrid(xvec, yvec); #A = 0.5 * g * (X + 1.0j * Y); A2 = g * (X + 1.0j * Y) #this is A2 = 2*A; ; B = np.abs(A2); B *= B; w0 = (2*rho.data[0,-1])*np.ones_like(A2); L = M-1; #calculation of \sum_{L} c_L (2x)^L / sqrt(L!); #using Horner's method; if not sparse:; rho = rho.full() * (2*np.ones((M,M)) - np.diag(np.ones(M))); while L > 0:; L -= 1; #here c_L = _wig_laguerre_val(L, B, np.diag(rho, L)); w0 = _wig_laguerre_val(L, B, np.diag(rho, L)) + w0 * A2 * (L+1)**-0.5; else:; while L > 0:; L -= 1; diag = _csr_get_diag(rho.data.data,rho.data.indices,; rho.data.indptr,L); if L != 0:; diag *= 2; #here c_L = _wig_laguerre_val(L, B, np.diag(rho, L)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/wigner.html:10813,efficient,efficient,10813,docs/4.1/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/wigner.html,4,['efficient'],['efficient']
Energy Efficiency,"0]]),; np.fliplr(psi.conj()),; np.zeros((1, n//2 - 1))), axis=1); r2 = np.concatenate((np.array([[0]]), psi,; np.zeros((1, n//2 - 1))), axis=1); w = la.toeplitz(np.zeros((n//2, 1)), r1) * \; np.flipud(la.toeplitz(np.zeros((n//2, 1)), r2)); w = np.concatenate((w[:, n//2:n], w[:, 0:n//2]), axis=1); w = ft.fft(w); w = np.real(np.concatenate((w[:, 3*n//4:n+1], w[:, 0:n//4]), axis=1)); p = np.arange(-n/4, n/4)*np.pi / (n*(xvec[1] - xvec[0])); w = w / (p[1] - p[0]) / n; return w, p. def _osc_eigen(N, pnts):; """"""; Vector of and N-dim oscillator eigenfunctions evaluated; at the points in pnts.; """"""; pnts = np.asarray(pnts); lpnts = len(pnts); A = np.zeros((N, lpnts)); A[0, :] = np.exp(-pnts ** 2 / 2.0) / pi ** 0.25; if N == 1:; return A; else:; A[1, :] = np.sqrt(2) * pnts * A[0, :]; for k in range(2, N):; A[k, :] = np.sqrt(2.0 / k) * pnts * A[k - 1, :] - \; np.sqrt((k - 1.0) / k) * A[k - 2, :]; return A. def _wigner_clenshaw(rho, xvec, yvec, g=sqrt(2), sparse=False):; r""""""; Using Clenshaw summation - numerically stable and efficient; iterative algorithm to evaluate polynomial series. The Wigner function is calculated as; :math:`W = e^(-0.5*x^2)/pi * \sum_{L} c_L (2x)^L / \sqrt(L!)` where; :math:`c_L = \sum_n \rho_{n,L+n} LL_n^L` where; :math:`LL_n^L = (-1)^n \sqrt(L!n!/(L+n)!) LaguerreL[n,L,x]`; """""". M = np.prod(rho.shape[0]); X,Y = np.meshgrid(xvec, yvec); #A = 0.5 * g * (X + 1.0j * Y); A2 = g * (X + 1.0j * Y) #this is A2 = 2*A. B = np.abs(A2); B *= B; w0 = (2*rho.data[0,-1])*np.ones_like(A2); L = M-1; #calculation of \sum_{L} c_L (2x)^L / \sqrt(L!); #using Horner's method; if not sparse:; rho = rho.full() * (2*np.ones((M,M)) - np.diag(np.ones(M))); while L > 0:; L -= 1; #here c_L = _wig_laguerre_val(L, B, np.diag(rho, L)); w0 = _wig_laguerre_val(L, B, np.diag(rho, L)) + w0 * A2 * (L+1)**-0.5; else:; while L > 0:; L -= 1; diag = _csr_get_diag(rho.data.data,rho.data.indices,; rho.data.indptr,L); if L != 0:; diag *= 2; #here c_L = _wig_laguerre_val(L, B, np.diag(rho, L)); w0 ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:15017,efficient,efficient,15017,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,4,['efficient'],['efficient']
Energy Efficiency,"1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:6349,energy,energy,6349,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,11,['energy'],['energy']
Energy Efficiency,"10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solverstr {None, ‘scipy’, ‘mkl’}Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. methodstr {‘direct’, ‘eigen’, ‘iterative-gmres’,; ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. sparsebool, optional, default = TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:102520,power,power,102520,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,8,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"153373552. In [39]: tracedist(y, y); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-states.html:11579,energy,energy,11579,docs/4.0.2/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-states.html,1,['energy'],['energy']
Energy Efficiency,"1d: Spin-Bath model, fitting of spectrum and correlation functions; HEOM 1e: Spin-Bath model (pure dephasing); HEOM 2: Dynamics in Fenna-Mathews-Olsen complex (FMO); HEOM 3: Quantum Heat Transport; HEOM 4: Dynamical decoupling of a non-Markovian environment; HEOM 5a: Fermionic single impurity model; HEOM 5b: Discrete boson coupled to an impurity and fermionic leads; Hierarchical Equation of Motion Examples. Miscellaneous tutorials. Lecture: Single-photon Interference. Quantum mechanics lectures with QuTiP; These lecture-style notebooks focus on particular quantum mechanics; topics and analyze them numerically using QuTiP (some more detailed than others). Lecture 0 - Introduction to QuTiP; Lecture 1 - Vacuum Rabi oscillations in the Jaynes-Cummings model; Lecture 2A - Simulation of a two-qubit gate using a resonator as coupler; Lecture 2B - Single-Atom-Lasing; Lecture 3A - The Dicke model; Lecture 3B - Jaynes-Cummings-like model in the ultrastrong coupling regime; Lecture 4 - Correlation functions; Lecture 5 - Evolution and quantum statistics of a quantum parameter amplifier; Lecture 6 - Quantum Monte-Carlo Trajectories; Lecture 7 - Two-qubit iSWAP gate and process tomography; Lecture 8 - Adiabatic sweep; Lecture 9 - Squeezed states of a quantum harmonic oscillator; Lecture 10 - Cavity-QED in the dispersive regime; Lecture 11 - Superconducting Josephson charge qubits; Lecture 12 - Decay into a squeezed vacuum field; Lecture 13 - Resonance flourescence; Lecture 14 - Kerr nonlinearities; Lecture 15 - Nonclassically driven atoms (cascaded quantum systems); Lecture 16 - Gallery of Wigner functions. Contributing; If you would like to contribute a notebook or report a bug, you may open; an issue or pull request in the; qutip-tutorials; GitHub repository. A few of the notebooks are still maintained in the repository; qutip-notebooks and; a complete archive of older versions of the tutorials is maintained there. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/qutip-tutorials/index-v4.html:5626,charge,charge,5626,qutip-tutorials/index-v4.html,https://qutip.org,https://qutip.org/qutip-tutorials/index-v4.html,1,['charge'],['charge']
Energy Efficiency,"2) Pauli matrices. Notes; -----; The collapse operator list can be given to `qutip.mesolve`.; Notice that the operators are placed in a Hilbert space of; dimension :math:`2^N`. Thus the method is suitable only for; small N (of the order of 10). Parameters; ----------; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: float; Collective pumping coefficient.; default: 0.0. collective_dephasing: float; Collective dephasing coefficient.; default: 0.0. Returns; -------; c_ops: list; The list of collapse operators as `qutip.Qobj` for the system.; """"""; N = int(N). if N > 10:; msg = ""N > 10. dim(H) = 2^N. ""; msg += ""Better use `piqs.lindbladian` to reduce Hilbert space ""; msg += ""dimension and exploit permutational symmetry.""; raise Warning(msg). [sx, sy, sz] = spin_algebra(N); sp, sm = spin_algebra(N, ""+""), spin_algebra(N, ""-""); [jx, jy, jz] = jspin(N, basis=""uncoupled""); jp, jm = (; jspin(N, ""+"", basis=""uncoupled""),; jspin(N, ""-"", basis=""uncoupled""),; ). c_ops = []. if emission != 0:; for i in range(0, N):; c_ops.append(np.sqrt(emission) * sm[i]). if dephasing != 0:; for i in range(0, N):; c_ops.append(np.sqrt(dephasing) * sz[i]). if pumping != 0:; for i in range(0, N):; c_ops.append(np.sqrt(pumping) * sp[i]). if collective_emission != 0:; c_ops.append(np.sqrt(collective_emission) * jm). if collective_dephasing != 0:; c_ops.append(np.sqrt(collective_dephasing) * jz). if collective_pumping != 0:; c_ops.append(np.sqrt(collective_pumping) * jp). return c_ops. # State definitions in the Dicke basis with an option for basis transformation; [docs]def dicke_basis(N, jmm1=None):; """"""; Initialize the density matrix of a Dicke state for several (j, m, m1). This functi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/piqs.html:24634,reduce,reduce,24634,docs/4.5/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/piqs.html,1,['reduce'],['reduce']
Energy Efficiency,"2) Pauli matrices. Notes; -----; The collapse operator list can be given to `qutip.mesolve`.; Notice that the operators are placed in a Hilbert space of; dimension :math:`2^N`. Thus the method is suitable only for; small N (of the order of 10). Parameters; ----------; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: float; Collective pumping coefficient.; default: 0.0. collective_dephasing: float; Collective dephasing coefficient.; default: 0.0. Returns; -------; c_ops: list; The list of collapse operators as `qutip.Qobj` for the system.; """"""; N = int(N). if N > 10:; msg = ""N > 10. dim(H) = 2^N. ""; msg += ""Better use `piqs.lindbladian` to reduce Hilbert space ""; msg += ""dimension and exploit permutational symmetry.""; raise Warning(msg). [sx, sy, sz] = spin_algebra(N); sp, sm = spin_algebra(N, ""+""), spin_algebra(N, ""-""); [jx, jy, jz] = jspin(N, basis=""uncoupled""); jp, jm = (; jspin(N, ""+"", basis=""uncoupled""),; jspin(N, ""-"", basis=""uncoupled""),; ). c_ops = []. if emission != 0:; for i in range(0, N):; c_ops.append(np.sqrt(emission) * sm[i]). if dephasing != 0:; for i in range(0, N):; c_ops.append(np.sqrt(dephasing) * sz[i]). if pumping != 0:; for i in range(0, N):; c_ops.append(np.sqrt(pumping) * sp[i]). if collective_emission != 0:; c_ops.append(np.sqrt(collective_emission) * jm). if collective_dephasing != 0:; c_ops.append(np.sqrt(collective_dephasing) * jz). if collective_pumping != 0:; c_ops.append(np.sqrt(collective_pumping) * jp). return c_ops. # State definitions in the Dicke basis with an option for basis transformation; [docs]def dicke_basis(N, jmm1=None):; r""""""; Initialize the density matrix of a Dicke state for several (j, m, m1). This funct",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/piqs.html:24936,reduce,reduce,24936,docs/4.6/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html,4,['reduce'],['reduce']
Energy Efficiency,"2) Pauli matrices. Notes; -----; The collapse operator list can be given to `qutip.mesolve`.; Notice that the operators are placed in a Hilbert space of; dimension :math:`2^N`. Thus the method is suitable only for; small N (of the order of 10). Parameters; ----------; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: float; Collective pumping coefficient.; default: 0.0. collective_dephasing: float; Collective dephasing coefficient.; default: 0.0. Returns; -------; c_ops: list; The list of collapse operators as `qutip.Qobj` for the system.; """"""; N = int(N). if N > 10:; msg = ""N > 10. dim(H) = 2^N. ""; msg += ""Better use `piqs.lindbladian` to reduce Hilbert space ""; msg += ""dimension and exploit permutational symmetry.""; raise Warning(msg). [sx, sy, sz] = spin_algebra(N); sp, sm = spin_algebra(N, ""+""), spin_algebra(N, ""-""); [jx, jy, jz] = jspin(N, basis=""uncoupled""); jp, jm = (jspin(N, ""+"", basis = ""uncoupled""),; jspin(N, ""-"", basis=""uncoupled"")). c_ops = []. if emission != 0:; for i in range(0, N):; c_ops.append(np.sqrt(emission) * sm[i]). if dephasing != 0:; for i in range(0, N):; c_ops.append(np.sqrt(dephasing) * sz[i]). if pumping != 0:; for i in range(0, N):; c_ops.append(np.sqrt(pumping) * sp[i]). if collective_emission != 0:; c_ops.append(np.sqrt(collective_emission) * jm). if collective_dephasing != 0:; c_ops.append(np.sqrt(collective_dephasing) * jz). if collective_pumping != 0:; c_ops.append(np.sqrt(collective_pumping) * jp). return c_ops. # State definitions in the Dicke basis with an option for basis transformation; [docs]def dicke_basis(N, jmm1=None):; """"""; Initialize the density matrix of a Dicke state for several (j, m, m1). This function ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/piqs.html:21148,reduce,reduce,21148,docs/4.3/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/piqs.html,2,['reduce'],['reduce']
Energy Efficiency,"25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; In [10]: N = 10. In [11]: omega_a = 1.0. In [12]: omega_c = 1.25. In [13]: g = 0.05. In [14]: a = tensor(identity(2), destroy(N)). In [15]: sm = tensor(destroy(2), identity(N)). In [16]: sz = tensor(sigmaz(), identity(N)). In [17]: H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In QuTiP the class method qutip.Qobj.ptrace is used to take partial traces. qutip.Qobj.ptrace acts on the qutip.Qobj instance for which it is called, and it takes one argument sel, which is a list of integers that mark the component systems that should be kept. All other components are traced out.; For example, the density matrix describing a single qubit obtained from a coupled two-qubit system is obtained via:; In [18]: psi = tensor(basis(2, 0), basis(2, 1)). In [19]: psi.ptrace(0); Out[19]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 0.]]. In [20]: psi.ptrace(1); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-tensor.html:6812,reduce,reduces,6812,docs/4.2/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-tensor.html,3,['reduce'],['reduces']
Energy Efficiency,"25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; In [10]: N = 10. In [11]: omega_a = 1.0. In [12]: omega_c = 1.25. In [13]: g = 0.05. In [14]: a = tensor(identity(2), destroy(N)). In [15]: sm = tensor(destroy(2), identity(N)). In [16]: sz = tensor(sigmaz(), identity(N)). In [17]: H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In QuTiP the class method qutip.Qobj.ptrace is used to take partial traces. qutip.Qobj.ptrace acts on the qutip.Qobj instance for which it is called, and it takes one argument sel, which is a list of integers that mark the component systems that should be kept. All other components are traced out.; For example, the density matrix describing a single qubit obtained from a coupled two-qubit system is obtained via:; In [18]: psi = tensor(basis(2, 0), basis(2, 1)). In [19]: psi.ptrace(0); Out[19]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. In [20]: psi.ptrace(1); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-tensor.html:6792,reduce,reduces,6792,docs/4.3/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-tensor.html,2,['reduce'],['reduces']
Energy Efficiency,"25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; In [10]: N = 10. In [11]: omega_a = 1.0. In [12]: omega_c = 1.25. In [13]: g = 0.05. In [14]: a = tensor(identity(2), destroy(N)). In [15]: sm = tensor(destroy(2), identity(N)). In [16]: sz = tensor(sigmaz(), identity(N)). In [17]: H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In QuTiP the class method qutip.Qobj.ptrace is used to take partial traces. qutip.Qobj.ptrace acts on the qutip.Qobj instance for which it is called, and it takes one argument sel, which is a list of integers that mark the component systems that should be kept. All other components are traced out.; For example, the density matrix describing a single qubit obtained from a coupled two-qubit system is obtained via:; In [18]: psi = tensor(basis(2, 0), basis(2, 1)). In [19]: psi.ptrace(0); Out[19]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. In [20]: psi.ptrace(1); Out[20]: ; Quantum ob",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-tensor.html:6833,reduce,reduces,6833,docs/4.5/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-tensor.html,1,['reduce'],['reduces']
Energy Efficiency,"25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; In [10]: N = 10. In [11]: omega_a = 1.0. In [12]: omega_c = 1.25. In [13]: g = 0.05. In [14]: a = tensor(identity(2), destroy(N)). In [15]: sm = tensor(destroy(2), identity(N)). In [16]: sz = tensor(sigmaz(), identity(N)). In [17]: H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In QuTiP the class method qutip.Qobj.ptrace is used to take partial traces. qutip.Qobj.ptrace acts on the qutip.Qobj instance for which it is called, and it takes one argument sel, which is a list of integers that mark the component systems that should be kept. All other components are traced out.; For example, the density matrix describing a single qubit obtained from a coupled two-qubit system is obtained via:; In [18]: psi = tensor(basis(2, 0), basis(2, 1)). In [19]: psi.ptrace(0); Out[19]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 0.]]. In [20]: psi.ptrace(1); Out[20]: ; Quantum ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-tensor.html:7612,reduce,reduces,7612,docs/3.1.0/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-tensor.html,1,['reduce'],['reduces']
Energy Efficiency,"2: tuble of *array* :. The normalized and unnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=, []**kwargs)¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:A : qobj. A Hamiltonian or Liouvillian operator. c_op_list : list. A list of collapse operators. method : str {‘direct’, ‘eigen’, ‘iterative-bicg’,. ‘iterative-gmres’, ‘svd’, ‘power’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, SVD ‘svd’ (dense), or inverse-power method ‘power’. sparse : bool, optional, default=True. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default=True. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default=False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. use_umfpack : bool {False, True}. Use umfpack solver instead of SuperLU. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:70076,power,power,70076,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,2,['power'],['power']
Energy Efficiency,"5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; >>> N = 10; >>> omega_a = 1.0; >>> omega_c = 1.25; >>> g = 0.05; >>> a = tensor(identity(2), destroy(N)); >>> sm = tensor(destroy(2), identity(N)); >>> sz = tensor(sigmaz(), identity(N)); >>> H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In QuTiP the class method qutip.Qobj.ptrace is used to take partial traces. qutip.Qobj.ptrace acts on the qutip.Qobj instance for which it is called, and it takes one argument sel, which is a list of integers that mark the component systems that should be kept. All other components are traced out.; For example, the density matrix describing a single qubit obtained from a coupled two-qubit system is obtained via:; In [11]: psi = tensor(basis(2, 0), basis(2, 1)). In [12]: psi.ptrace(0); Out[12]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 0.]]. In [13]: psi.ptrace(1); Out[13]: ; Quantum ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-tensor.html:7431,reduce,reduces,7431,docs/3.0.0/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html,2,['reduce'],['reduces']
Energy Efficiency,"6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X, Y and Z gates in circuits. (by Boxi Li); Refactor QubitCircuit.resolve_gate() (by Martín Sande Costa). Bug Fixes¶. Fix dims in the returns from Qobj.eigenstates on superoperators. (by Jake",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:12220,schedul,scheduling,12220,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['schedul'],['scheduling']
Energy Efficiency,"68>,; <matplotlib.lines.Line2D at 0x1a250d2c18>]. In [10]: legend(['0.5','1.0','2.0']); Out[10]: <matplotlib.legend.Legend at 0x1a2551cef0>. In [11]: xlabel(r'Time $t$'); Out[11]: Text(0.5,0,'Time $t$'). In [12]: ylabel(r'Correlation $\left<x(t)x(0)\right>$'); Out[12]: Text(0,0.5,'Correlation $\\left<x(t)x(0)\\right>$'). In [13]: show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; import pylab as plt; from qutip import *. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag(), np.sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-correlation.html:5590,power,power,5590,docs/4.5/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-correlation.html,1,['power'],['power']
Energy Efficiency,"9080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.sigmaz, qutip.operators.sigmap, and qutip.operators.sigmam on these two-level states. For example, if vac corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the \(\left|1\right>\) state:; print(vac). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. c = create(2). print(c * vac). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator qutip.operators.sigmap. Operating on the spin state gives:; print(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:11480,energy,energy,11480,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,4,['energy'],['energy']
Energy Efficiency,": 10,; 'scaling_vectors': True,; 'weighted_matching': True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None}; return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, 'scipy', 'mkl'}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvilli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/steadystate.html:5081,power,power,5081,docs/4.5/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/steadystate.html,4,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,": 1e-12, 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', ; 'restart': 20, 'return_info': False, 'info': _empty_info_dict(), ; 'verbose': False}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/steadystate.html:5338,power,power,5338,docs/4.2/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html,6,['power'],['power']
Energy Efficiency,": True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None}; return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~qutip.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:4940,power,power,4940,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,8,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,": [<matplotlib.lines.Line2D at 0x2b4e7eb36ac8>]. In [31]: plt.plot(tlist, actual_answer); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:18514,power,power,18514,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,1,['power'],['power']
Energy Efficiency,": a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None) :. Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. wigner_cmap(W, levels=1024, shift=0, invert=False)¶; A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters:W : array. Wigner function array, or any array. levels : int. Number of color levels to create. shift : float. Shifts the value at which Wigner elements are emphasized.; This parameter should typically be negative and small (i.e -5e-3). invert : bool. Invert the color scheme for negative values so that smaller negative; values have darker color. Returns:Returns a Matplotlib colormap instance for use in plotting. :. Notes; The ‘shi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:80559,energy,energy,80559,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,": qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/entropy.html:8577,power,power,8577,docs/4.3/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/entropy.html,2,['power'],['power']
Energy Efficiency,"; # calculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. k_max : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). nT = 100; dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, nT + 1), H, T,; args). for t in tlist:; # TODO: repeated invocations of floquet_modes_t is; # ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:15539,power,power,15539,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,5,['power'],['power']
Energy Efficiency,"; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. 5; Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. 6; Mitiq. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:3664,schedul,schedule,3664,docs/4.7/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html,2,['schedul'],['schedule']
Energy Efficiency,"; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'GMRES' and 'LGMRES' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make thee iterative methods faster than the other solution methods. The problem with precon",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-steady.html:5146,power,power,5146,docs/3.0.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html,4,['power'],['power']
Energy Efficiency,"; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the oth",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-steady.html:5541,power,power,5541,docs/3.1.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html,2,['power'],['power']
Energy Efficiency,"; Examples; >>> thermal_dm(5, 1); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N : int; Hilbert space dimensionality. dims : list; Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:; zero_ket : qobj; Zero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns:; C : Qobj; Charge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:; N : int; Dimension of Hilbert space. Returns:; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:18090,charge,charge,18090,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,3,['charge'],['charge']
Energy Efficiency,"; First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, DrudeLorentzBath and; DrudeLorentzPadeBath. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths.; Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; example notebook 1a. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where \(\gamma\) (gamma), \(\lambda\) (lam) and \(T\) are; the parameters of a Drude-Lorentz bath, and Q is the coupling operator; between the system and the bath.; We may the pass these parameters to either; DrudeLorentzBath or; DrudeLorentzPadeBath to construct an expansion of; the bath correlations:; from qutip.nonmarkov.heom import DrudeLorentzBath; from qutip.nonmarkov.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). Where Nk is the number of terms to ret",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/bosonic.html:2803,energy,energy,2803,docs/4.7/guide/heom/bosonic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html,2,['energy'],['energy']
Energy Efficiency,"; J. Chem. Phys. 142, 212439 (2015). 102. Bretheau et al., ""Quantum dynamics of an electromagnetic mode that cannot contain N photons"", ; Science 348, 776 (2015). 101. Leggio et al., ""Thermally activated nonlocal amplification in quantum energy transport"", ; Euro. Phys. Lett 110, 40002 (2015). 100. Patrzyk et al., ""Towards a novel environment for simulation of quantum computing"", ; Computer Science 16, 103 (2015). 99. Plankensteiner et al., ""Selective protected state preparation of coupled dissipative quantum emitters"", ; Sci Rep. 5, 16231 (2015). 98. Goryachev et al., ""Single-photon level study of microwave properties of lithium niobate at millikelvin temperatures"", ; Phys. Rev. B 92, 060406(R) 2015). 97. Nation, ""Steady-state solution methods for open quantum optical systems"", ; arXiv:1504.06768. 96. Higgins et al., ""Quantum-Enhanced Capture of Photons Using Optical Ratchet States"", ; J. Phys. Chem. C 121, 20714 (2017). 95. Bassereh et al., ""Perfect energy transport via single edge deletion in a complete network"", ; arXiv:1504.04398. 94. Wiśniewska et al., ""High performance computing and quantum trajectory method in CPU and GPU systems"", ; J. Phys.: Conf. Ser. 574, 012127 (2015). 93. Holland et al., ""Single-Photon-Resolved Cross-Kerr Interaction for Autonomous Stabilization of Photon-Number States"", ; Phys. Rev. Lett. 115, 180501 (2015). 92. Ardelt et al., ""Controlled tunneling-induced dephasing of Rabi rotations for high-fidelity hole spin initialization"", ; Phys. Rev. B 92, 115306 (2015). 91. Wallman et al., ""Estimating the coherence of noise"", ; New J. Phys. 17, 113020 (2015). 90. Černotík et al., ""Adiabatic elimination of Gaussian subsystems from quantum dynamics under continuous measurement"", ; Phys. Rev. A 92, 012124 (2015). 89. Müller et al., ""Ultrafast Polariton-Phonon Dynamics of Strongly Coupled Quantum Dot-Nanocavity Systems"", ; Phys. Rev. X 5, 031006 (2015). 88. Osipovs et al., ""Markov Chains in the Task of Author's Writing Style Profile Construction"",",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:36645,energy,energy,36645,users.html,https://qutip.org,https://qutip.org/users.html,1,['energy'],['energy']
Energy Efficiency,"; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function. The function that is to be called for each value in task_vec. task_vec: array / list. The list or array of values for which the task function is to be; evaluated. args: list / dictionary. The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False. Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function. The function that is to be called for each value in task_vec. values: array / list. The list or array of va",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:198992,schedul,scheduled,198992,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['schedul'],['scheduled']
Energy Efficiency,"; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:12698,monitor,monitor,12698,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['monitor'],['monitor']
Energy Efficiency,"; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:7950,monitor,monitor,7950,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['monitor'],['monitor']
Energy Efficiency,"; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; """"""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html:8796,reduce,reduced,8796,docs/4.1/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html,6,['reduce'],['reduced']
Energy Efficiency,"; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; r""""""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:8826,reduce,reduced,8826,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html,4,['reduce'],['reduced']
Energy Efficiency,"; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g2, G2 : tuple. The normalized and unnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:A : qobj. A Hamiltonian or Liouvillian operator. c_op_list : list. A list of collapse operators. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False. Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillia",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:100799,power,power,100799,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,8,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"; corr2 = correlation_ss(H, times, [sqrt(1.0) * a], x, x); corr3 = correlation_ss(H, times, [sqrt(2.0) * a], x, x). from pylab import *; plot(times, real(corr1), times, real(corr2), times, real(corr3)); xlabel(r'Time $t$'); ylabel(r'Correlation $\left<x(t)x(0)\right>$'); show(). (Source code, png, hires.png, pdf). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; from qutip import *; import pylab as plt; from scipy import *; from scipy import *; N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * pi # cavity and atom frequency; g = 0.1 * 2 * pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [sqrt(kappa * (1 + n_th)) * a, sqrt(kappa * n_th) * a.dag(), sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = linspace",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-correlation.html:5884,power,power,5884,docs/3.0.0/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html,2,['power'],['power']
Energy Efficiency,"; eigvals = eigvals[idx_nonzero]; eigstates = eigstates[idx_nonzero]. if method == 'clip':; eigvals[eigvals < 0] = 0; elif method == 'sgs':; eigvals = eigvals[::-1]; eigstates = eigstates[::-1]. acc = 0.0; dim = self.shape[0]; n_eigs = len(eigvals). for idx in reversed(range(n_eigs)):; if eigvals[idx] + acc / (idx + 1) >= 0:; break; else:; acc += eigvals[idx]; eigvals[idx] = 0.0. eigvals[:idx+1] += acc / (idx + 1). return sum([; val * qutip.states.ket2dm(state); for val, state in zip(eigvals, eigstates); ], Qobj(np.zeros(self.shape), dims=self.dims); ).unit(). [docs] def matrix_element(self, bra, ket):; """"""Calculates a matrix element. Gives the matrix element for the quantum object sandwiched between a; `bra` and `ket` vector. Parameters; -----------; bra : :class:`qutip.Qobj`; Quantum object of type 'bra' or 'ket'. ket : :class:`qutip.Qobj`; Quantum object of type 'ket'. Returns; -------; elem : complex; Complex valued matrix element. Notes; -----; It is slightly more computationally efficient to use a ket; vector for the 'bra' input.; """"""; if not self.isoper:; raise TypeError(""Can only get matrix elements for an operator.""). else:; if bra.isbra and ket.isket:; return zcsr_mat_elem(self.data, bra.data, ket.data, 1). elif bra.isket and ket.isket:; return zcsr_mat_elem(self.data, bra.data, ket.data, 0); else:; err = ""Can only calculate matrix elements for bra""; err += "" and ket vectors.""; raise TypeError(err). [docs] def overlap(self, other):; """"""Overlap between two state vectors or two operators. Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters; -----------; other : :class:`qutip.Qobj`; Quantum object for a state vector of type 'ket', 'bra' or density; matrix. Returns; -------; overlap : complex; Complex valued overlap. Raises; ------; TypeError; Can only calculate overlap between a bra, ket and density matrix; q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:40391,efficient,efficient,40391,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,4,['efficient'],['efficient']
Energy Efficiency,"; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. def reverse_graph(self):; """"""; Reverse the graph.; The start node becomes the end node; Predecessors and successors of each node are exchanged.; """"""; for node in self.nodes:; node.predecessors, node.successors \; = node.successors, node.predecessors; try:; self.distance_to_start, self.distance_to_end = \; self.distance_to_end, self.distance_to_start; except AttributeError:; pass; self.start, self.end = self.end, self.start. def find_topological_order(; self, priority=True, apply_constraint=None, random=False):; """"""; A list-schedule algorithm, it; finds the topological order of the directed graph; under certain constraint and priority indicator.; The function returns a list of cycles,; where each cycle is a list of instructions; that can be executed in parallel.; In the case of gates schedule,; the result will be the gates cycle list. Parameters; ----------; priority: bool; If use distance to the start and end nodes; as a priority measure for the schedule problem.; apply_constraint: function; A Python function that determines; if to instruction can be executed in parallel.; E.g. if two gates apply to the same qubit, the function; returns False. Returns; -------; cycles_list: list; A list of cycles, where each cycle is a list of instructions; that can be executed in parallel.; constraint_dependency: set; A set of instruction pairs that are found conflicted; due to the hardware constraints.; Because of this, they are executed in different cycles.; This set is used to add this dependency to the graph; in another method.; """"""; # The method will destruct the graph, therefore we make a copy.; graph = deepcopy(self.nodes); cycles_list = []; available_nodes = list(self.start) # a list of available instructions; # pairs of instructions that are limited by hardware constraint; constraint_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:7435,schedul,schedule,7435,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['schedule']
Energy Efficiency,"; expect(e_ops[m], rho.transform(f_modes_t, False)). r.integrate(r.t + dt); t_idx += 1. return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #; [docs]def fmmesolve(H, rho0, tlist, c_ops, e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/floquet.html:24778,power,power,24778,docs/3.1.0/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/floquet.html,1,['power'],['power']
Energy Efficiency,"; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:15131,schedul,schedule,15131,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['schedule']
Energy Efficiency,"; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:184191,schedul,schedule,184191,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['schedul'],['schedule']
Energy Efficiency,"; if not already included in set.; Returned sample array is not evenly spaced if addtional elements; are added. Parameters:; start (int) – The starting value of the sequence.; stop (int) – The stoping values of the sequence.; num (int, optional) – Number of samples to generate.; elems (list/ndarray, optional) – Requested elements to include in array. Returns:samples – Original equally spaced sample array with additional; elements added. Return type:ndadrray. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:; j1 (float) – Total angular momentum 1.; j2 (float) – Total angular momentum 2.; j3 (float) – Total angular momentum 3.; m1 (float) – z-component of angular momentum 1.; m2 (float) – z-component of angular momentum 2.; m3 (float) – z-component of angular momentum 3. Returns:cg_coeff – Requested Clebsch-Gordan coefficient. Return type:float. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:; value (float / array) – The energy in the old unit.; orig (string) – The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”); to (string) – The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit – The energy in the new unit. Return type:float / array. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename (str) – Name of file containing reqested data.; sep (str) – Seperator used to store data. Returns:data – Data from selected file. Return type:array_like. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:; filename (str) – Name of data file to be stored, including extension.; data (array_like) – Data to be written to file.; numtype (str {'complex, 'real'}) – Type of numerical data.; numfor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:194737,energy,energy,194737,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"; if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. def reverse_graph(self):; """"""; Reverse the graph.; The start node becomes the end node; Predecessors and successors of each node are exchanged.; """"""; for node in self.nodes:; node.predecessors, node.successors \; = node.successors, node.predecessors; try:; self.distance_to_start, self.distance_to_end = \; self.distance_to_end, self.distance_to_start; except AttributeError:; pass; self.start, self.end = self.end, self.start. def find_topological_order(; self, priority=True, apply_constraint=None, random=False):; """"""; A list-schedule algorithm, it; finds the topological order of the directed graph; under certain constraint and priority indicator.; The function returns a list of cycles,; where each cycle is a list of instructions; that can be executed in parallel.; In the case of gates schedule,; the result will be the gates cycle list. Parameters; ----------; priority: bool; If use distance to the start and end nodes; as a priority measure for the schedule problem.; apply_constraint: function; A Python function that determines; if to instruction can be executed in parallel.; E.g. if two gates apply to the same qubit, the function; returns False. Returns; -------; cycles_list: list; A list of cycles, where each cycle is a list of instructions; that can be executed in parallel.; constraint_dependency: set; A set of instruction pairs that are found conflicted; due to the hardware constraints.; Because of this, they are executed in different cycles.; This set is used to add this dependency to the graph; in another method.; """"""; # The method will destruct the graph, therefore we make a copy.; graph = deepcopy(self.nodes); cycles_list = []; available_nodes = list(self.start) # a list of available instructions; # pairs of instructions that are limited by hardware constraint; constraint_dependency = set(). while available_nodes:; if random:; shuffle(available_nodes); if priority:; availab",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:7601,schedul,schedule,7601,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['schedule']
Energy Efficiency,"; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g2: array. The normalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:A : qobj. A Hamiltonian or Liouvillian operator. c_op_list : list. A list of collapse operators. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,. SVD ‘svd’ (dense), or inverse-power method ‘power’. return_info : bool, optional, default = False. Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:89280,power,power,89280,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:15208,schedul,schedule,15208,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['schedule']
Energy Efficiency,"= 1.0 * 2 * pi # cavity and atom frequency; g = 0.1 * 2 * pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [sqrt(kappa * (1 + n_th)) * a, sqrt(kappa * n_th) * a.dag(), sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = linspace(0, 100, 5000); corr = correlation_ss(H, tlist, c_ops, a.dag(), a); wlist1, spec1 = spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum_ss, which internally uses essolve; # to solve for the dynamics; wlist2 = linspace(0.25, 1.75, 200) * 2 * pi; spec2 = spectrum_ss(H, wlist2, c_ops, a.dag(), a). # plot the spectra; fig, ax = plt.subplots(1, 1); ax.plot(wlist1 / (2 * pi), spec1, 'b', lw=2, label='eseries method'); ax.plot(wlist2 / (2 * pi), spec2, 'r--', lw=2, label='me+fft method'); ax.legend(); ax.set_xlabel('Frequency'); ax.set_ylabel('Power spectrum'); ax.set_title('Vacuum Rabi splitting'); ax.set_xlim(wlist2[0]/(2*pi), wlist2[-1]/(2*pi)); plt.show(). (Source code, png, hires.png, pdf). Non-steadystate correlation function¶; More generally, we can also calculate correlation functions of the kind \(\left<A(t_1+t_2)B(t_1)\right>\), i.e., the correlation function of a system that is not in its steadystate. In QuTiP, we can evoluate such correlation functions using the function qutip.correlation.correlation. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (\(t_1\) ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-correlation.html:6983,power,power,6983,docs/3.0.0/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html,2,['power'],['power']
Energy Efficiency,"= 1024)[source]¶; Class-based method of calculating the Husimi-Q function of many different; quantum states at fixed phase-space points 0.5*g* (xvec + i*yvec).; This class has slightly higher first-usage costs than qfunc, but; subsequent operations will be several times faster. However, it can require; quite a lot of memory. Call the created object as a function to retrieve; the Husimi-Q function. Parameters. xvec, yvecarray_likex- and y-coordinates at which to calculate the Husimi-Q function. gfloat, default sqrt(2)Scaling factor for a = 0.5 * g * (x + iy). The value of g is; related to the value of hbar in the commutation relation; \([x,\,y] = i\hbar\) via \(\hbar=2/g^2\), so the default; corresponds to \(\hbar=1\). memoryreal, default 1024Size in MB that may be used internally as workspace. This class will; raise MemoryError if subsequently passed a state of sufficiently; large dimension that this bound would be exceeded. In those cases, use; qfunc with precompute_memory=None instead to force using; the slower, more memory-efficient algorithm. See also. qfunca single function version, which will involve computing several quantities multiple times in order to use less memory. Examples; Initialise the class for a square set of coordinates, with some states we; want to investigate.; >>> xvec = np.linspace(-2, 2, 101); >>> states = [qutip.rand_dm(10) for _ in [None]*10]; >>> qfunc = qutip.QFunc(xvec, xvec). Now we can calculate the Husimi-Q function over each of the states more; efficiently with:; >>> husimiq = np.array([qfunc(state) for state in states]). Cubic Spline¶. class Cubic_Spline(a, b, y, alpha=0, beta=0)[source]¶; Calculates coefficients for a cubic spline; interpolation of a given data set.; This function assumes that the data is sampled; uniformly over a given interval. Parameters. afloatLower bound of the interval. bfloatUpper bound of the interval. yndarrayFunction values at interval points. alphafloatSecond-order derivative at a. Default is 0. betaflo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:34632,efficient,efficient,34632,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['efficient'],['efficient']
Energy Efficiency,"= [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:17782,charge,charge,17782,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['charge'],['charge']
Energy Efficiency,"= w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/utilities.html:7534,energy,energy,7534,docs/4.6/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html,4,['energy'],['energy']
Energy Efficiency,"= w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_prop",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:7582,energy,energy,7582,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,7,['energy'],['energy']
Energy Efficiency,"=True, show_ylabel=True):. if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). p = ax.plot(self.xvecs[0], self.data). if show_xlabel:; ax.set_xlabel(self.xlabels[0], fontsize=12); if show_ylabel:; ax.set_ylabel(""Marginal distribution"", fontsize=12). return fig, ax. [docs] def marginal(self, dim=0):; """"""; Calculate the marginal distribution function along the dimension; `dim`. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns; -------. d : Distributions; A new instances of Distribution that describes the marginal; distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.x",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/distributions.html:7450,reduce,reduced-dimensionality,7450,docs/4.2/modules/qutip/distributions.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/distributions.html,11,['reduce'],['reduced-dimensionality']
Energy Efficiency,"=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:5405,power,power-lgmres,5405,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,12,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = lgmres(L, v, tol=mtol,; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'power-bicgstab':; try:; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = bicgstab(L, v, tol=mtol,; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and ss_args['solver'] == 'mkl':; lu.delete(); if ss_args['return_info']:; ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v, np.inf); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(vec2mat(data),; rhoss.shape[0],; rhoss.shape[0]); rhoss.data = 0.5 * (data + data.H); rhoss.isherm = True; if ss_args['",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:30434,power,power,30434,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['power'],['power']
Energy Efficiency,"B : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/entropy.html:8813,power,power,8813,docs/4.4/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/entropy.html,1,['power'],['power']
Energy Efficiency,"ENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections import deque; from copy import deepcopy; from functools import cmp_to_key; from random import shuffle. from ..circuit import QubitCircuit, Gate; from .instruction import Instruction. class InstructionsGraph():; """"""; A directed acyclic graph (DAG) representation; of the quantum instruction dependency.; An example is Fig3(b) in https://doi.org/10.1117/12.666419.; It contains methods of generating the instruction dependency graph,; a list-schedule algorithm to find the topological order; and the computation of the distance in the weighted graph; (circuit latency). It uses the `Instruction` object as a representation of node; and adds the following attributes to it:. predecessors, successors: dependency arrow of the DAG; distance_to_start, distance_to_end: longest distance to the start and end. Parameters; ----------; instructions: list; A list of instructions. Attributes; ----------; nodes: list; The input list of instruction with additional graph information.; start, end: list; List of indices of nodes connected to the start or end nodes.; """"""; def __init__(self, instructions):; instructions = deepcopy(instructions); self.nodes = []; for instruction in instructions:; if isinstance(instruction, Gate):; self.nodes.append(Instruction(instruction)); else:; self.nodes.append(instruction); for node in self.nodes:; if node.duration is None:; node.duration = 1; self.start = None; self.end = None. def generate_dependency_graph(self, commuting):; """"""; G",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:2583,schedul,schedule,2583,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,2,['schedul'],['schedule']
Energy Efficiency,"EPRECIATED. Do not use. options : qutip.solver.Options. Options for the solver. progress_bar : BaseProgressBar. Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:result: qutip.solver.Result. An instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=[], use_secular=True, sec_cutoff=0.1)[source]¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system’s coupling; to its environment. Note; This tensor generation requires a time-independent Hamiltonian. Parameters:H : qutip.qobj. System Hamiltonian. a_ops : list of qutip.qobj. List of system operators that couple to the environment. spectra_cb : list of callback functions. List of callback functions that evaluate the noise power spectrum; at a given frequency. c_ops : list of qutip.qobj. List of system collapse operators. use_secular : bool. Flag (True of False) that indicates if the secular approximation should; be used. sec_cutoff : float {0.1}. Threshold for secular approximation. Returns:R, kets: qutip.Qobj, list of qutip.Qobj. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters:R : qutip.qobj. Bloch-Redfield tensor. ekets : array of qutip.qobj. Array of kets that make up a basis tranformation for the eigenbasis. rho0 : qutip.qobj. Initial density matrix. tlist : list / array. List of times for \(t\). e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. options ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:66789,power,power,66789,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"ERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators.; """""". __all__ = ['jmat', 'spin_Jx', 'spin_Jy', 'spin_Jz', 'spin_Jm', 'spin_Jp',; 'spin_J_set', 'sigmap', 'sigmam', 'sigmax', 'sigmay', 'sigmaz',; 'destroy', 'create', 'qeye', 'identity', 'position', 'momentum',; 'num', 'squeeze', 'squeezing', 'displace', 'commutator',; 'qutrit_ops', 'qdiags', 'phase', 'qzero', 'enr_destroy',; 'enr_identity', 'charge', 'tunneling']. import numbers; import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.dimensions import flatten. #; # Spin operators; #; [docs]def jmat(j, *args):; """"""Higher-order spin operators:. Parameters; ----------; j : float; Spin of operator. args : str; Which operator to return 'x','y','z','+','-'.; If no args given, then output is ['x','y','z']. Returns; -------; jmat : qobj / ndarray; ``qobj`` for requested spin operator(s). Examples; --------; >>> jmat(1) # doctest: +SKIP; [ Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0. 0.70710678 0. ]; [ 0.70710678 0. 0.70710678]; [ 0. 0.70710678 0. ]]; Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = Tru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/operators.html:2557,charge,charge,2557,docs/4.6/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html,2,['charge'],['charge']
Energy Efficiency,"ERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators.; """""". __all__ = ['jmat', 'spin_Jx', 'spin_Jy', 'spin_Jz', 'spin_Jm', 'spin_Jp',; 'spin_J_set', 'sigmap', 'sigmam', 'sigmax', 'sigmay', 'sigmaz',; 'destroy', 'create', 'qeye', 'identity', 'position', 'momentum',; 'num', 'squeeze', 'squeezing', 'displace', 'commutator',; 'qutrit_ops', 'qdiags', 'phase', 'qzero', 'enr_destroy',; 'enr_identity', 'charge', 'tunneling']. import numbers; import numpy as np; import scipy; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity; from qutip.dimensions import flatten. #; # Spin operators; #; [docs]def jmat(j, *args):; """"""Higher-order spin operators:. Parameters; ----------; j : float; Spin of operator. args : str; Which operator to return 'x','y','z','+','-'.; If no args given, then output is ['x','y','z']. Returns; -------; jmat : qobj / ndarray; ``qobj`` for requested spin operator(s). Examples; --------; >>> jmat(1); [ Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0. 0.70710678 0. ]; [ 0.70710678 0. 0.70710678]; [ 0. 0.70710678 0. ]]; Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/operators.html:2537,charge,charge,2537,docs/4.5/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/operators.html,1,['charge'],['charge']
Energy Efficiency,"ERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators.; """""". __all__ = ['jmat', 'spin_Jx', 'spin_Jy', 'spin_Jz', 'spin_Jm', 'spin_Jp',; 'spin_J_set', 'sigmap', 'sigmam', 'sigmax', 'sigmay', 'sigmaz',; 'destroy', 'create', 'qeye', 'identity', 'position', 'momentum',; 'num', 'squeeze', 'squeezing', 'displace', 'commutator',; 'qutrit_ops', 'qdiags', 'phase', 'qzero', 'enr_destroy',; 'enr_identity', 'charge', 'tunneling']. import numpy as np; import scipy; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.fastsparse import fast_csr_matrix, fast_identity. #; # Spin operators; #; [docs]def jmat(j, *args):; """"""Higher-order spin operators:. Parameters; ----------; j : float; Spin of operator. args : str; Which operator to return 'x','y','z','+','-'.; If no args given, then output is ['x','y','z']. Returns; -------; jmat : qobj / ndarray; ``qobj`` for requested spin operator(s). Examples; --------; >>> jmat(1); [ Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0. 0.70710678 0. ]; [ 0.70710678 0. 0.70710678]; [ 0. 0.70710678 0. ]]; Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.-0.70710678j 0.+0.j ]; [ 0.+0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/operators.html:2528,charge,charge,2528,docs/4.2/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/operators.html,5,['charge'],['charge']
Energy Efficiency,"Experimental. wigner(psi, xvec, yvec, method='clenshaw', g=1.4142135623730951, sparse=False, parfor=False)[source]¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:; state (qobj) – A state vector or density matrix.; xvec (array_like) – x-coordinates at which to calculate the Wigner function.; yvec (array_like) – y-coordinates at which to calculate the Wigner function. Does not; apply to the ‘fft’ method.; g (float) – Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; method (string {'clenshaw', 'iterative', 'laguerre', 'fft'}) – Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method.; sparse (bool {False, True}) – Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance.; parfor (bool {False, True}) – Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns:; W (array) – Values representing the Wigner function calculated over the specified; range [xvec,yvec].; yvex (array) – FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:113183,efficient,efficient,113183,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['efficient'],['efficient']
Energy Efficiency,"G2: tuble of *array* :. The normalized and unnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=, []**kwargs)¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:A : qobj. A Hamiltonian or Liouvillian operator. c_op_list : list. A list of collapse operators. method : str {‘direct’, ‘eigen’, ‘iterative-bicg’, ‘iterative-gmres’, ‘svd’, ‘power’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, SVD ‘svd’ (dense), or inverse-power method ‘power’. sparse : bool, optional, default=True. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default=True. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default=False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. use_umfpack : bool {False, True}. Use umfpack solver instead of SuperLU. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:70013,power,power,70013,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['power'],['power']
Energy Efficiency,"HI. Notes; Experimental. wigner(psi, xvec, yvec, method='clenshaw', g=1.4142135623730951, sparse=False, parfor=False)[source]¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. Does not; apply to the ‘fft’ method. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). method : string {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}. Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method. sparse : bool {False, True}. Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parfor : bool {False, True}. Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns:W : array. Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array. FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calcu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:112214,efficient,efficient,112214,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['efficient'],['efficient']
Energy Efficiency,"Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:6341,power,power,6341,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,8,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"Hamiltonian.; """"""; if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit; if args is not None:; self.args.update(args); instruction_list = []. # compile gates; for gate in gates:; if gate.name not in self.gate_compiler:; raise ValueError(""Unsupported gate %s"" % gate.name); instruction = self.gate_compiler[gate.name](gate, self.args); if instruction is None:; continue # neglecting global phase gate; instruction_list += instruction; if not instruction_list:; return None, None; if self.pulse_dict:; num_controls = len(self.pulse_dict); else: # if pulse_dict is not given, compute the number of pulses; num_controls = 0; for instruction in instruction_list:; for pulse_index, _ in instruction.pulse_info:; num_controls = max(num_controls, pulse_index); num_controls += 1. # schedule; # scheduled_start_time:; # An ordered list of the start_time for each pulse,; # corresponding to gates in the instruction_list.; # instruction_list reordered according to the scheduled result; instruction_list, scheduled_start_time = \; self._schedule(instruction_list, schedule_mode). # An instruction can be composed from several different pulse elements.; # We separate them an assign them to each pulse index.; pulse_instructions = [[] for tmp in range(num_controls)]; for instruction, start_time in \; zip(instruction_list, scheduled_start_time):; for pulse_name, coeff in instruction.pulse_info:; if self.pulse_dict:; try:; pulse_ind = self.pulse_dict[pulse_name]; except KeyError:; raise ValueError(; f""Pulse name {pulse_name} not found""; "" in pulse_dict.""); else:; pulse_ind = pulse_name; pulse_instructions[pulse_ind].append(; (start_time, instruction.tlist, coeff)). # concatenate pulses; compiled_tlist, compiled_coeffs = \; self._concatenate_pulses(; pulse_instructions, scheduled_start_time, num_controls); return compiled_tlist, compiled_coeffs. def _schedule(self, instruction_list, schedule_mode):; """"""; Schedule the instructions if required and ; reorder instruction_l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:5982,schedul,scheduled,5982,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,4,['schedul'],['scheduled']
Energy Efficiency,"ISWAP""]); tlists, coeffs = compiler.compile(resolved_qc); print(tlists); print(coeffs). Output; [array([0., 1.]), array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate on Spin Chain model,; the rotation over X-axis.; We pass the hardware parameters of the SpinChain model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:11549,schedul,scheduler,11549,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,3,"['Schedul', 'schedul']","['Scheduler', 'scheduler']"
Energy Efficiency,"ITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import division. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.operators import identity, qeye, sigmax; from qutip.tensor import tensor; from qutip.states import fock_dm. from itertools import product; from functools import partial, reduce; from operator import mul. __all__ = ['rx', 'ry', 'rz', 'sqrtnot', 'snot', 'phasegate', 'cphase', 'cnot',; 'csign', 'berkeley', 'swapalpha', 'swap', 'iswap', 'sqrtswap',; 'sqrtiswap', 'fredkin', 'toffoli', 'rotation', 'controlled_gate',; 'globalphase', 'hadamard_transform', 'gate_sequence_product',; 'gate_expand_1toN', 'gate_expand_2toN', 'gate_expand_3toN',; 'qubit_clifford_group']. #; # Single Qubit Gates; #. [docs]def rx(phi, N=None, target=0):; """"""Single-qubit rotation for operator sigmax with angle phi. Returns; -------; result : qobj; Quantum object for operator describing the rotation. """"""; if N is not None:; return gate_expand_1toN(rx(phi), N, target); else:; return Qobj([[np.cos(phi / 2), -1j * np.sin(phi / 2)],; [-1j * np.sin(phi / 2), np.cos(phi / 2)]]). [docs]def ry(phi, N=None, target=0):; """"""Single-qubit rotation for operator sigmay with angle phi. Returns; -------; result : qobj; Quantum object for operator describing the rotation. """"""; if N is not ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/qip/gates.html:2348,reduce,reduce,2348,docs/4.1/modules/qutip/qip/gates.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/qip/gates.html,4,['reduce'],['reduce']
Energy Efficiency,"If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html:30731,efficient,efficient,30731,docs/4.1/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html,5,['efficient'],['efficient']
Energy Efficiency,"Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2),; _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (target) + [U] +; [identity(2)] * (N - target - 1)). [docs]def gate_expand_2toN(U, N, control=None, target=None, targets=None):; """"""; Create a Qobj representing a two-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:31493,reduce,reduce,31493,docs/4.6/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html,4,['reduce'],['reduce']
Energy Efficiency,"July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Monte Carlo Solver; Introduction; Monte Carlo in QuTiP; Changing the Number of Trajectories; Reusing Hamiltonian Data; Fortran Based Monte Carlo Solver. « Lindblad Master ... Bloch-Redfield m... ». Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)\[\begin{split}\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\end{split}\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2).",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-monte.html:2025,monitor,monitored,2025,docs/3.0.1/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-monte.html,2,['monitor'],['monitored']
Energy Efficiency,"L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:24136,power,power,24136,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['power'],['power']
Energy Efficiency,"L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = gmres(L, v, tol=mtol,; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'power-lgmres':; try:; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = lgmres(L, v, tol=mtol,; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'power-bicgstab':; try:; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = bicgstab(L, v, tol=mtol,; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and ss_args['solver'] == 'mkl':; lu.delete(); if ss_args['return_info']:; ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:29746,power,power-bicgstab,29746,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['power'],['power-bicgstab']
Energy Efficiency,"MPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; import numpy as np; import warnings; from qutip import tensor, identity, destroy, sigmax, sigmaz, basis; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.models.circuitprocessor import CircuitProcessor. [docs]class DispersivecQED(CircuitProcessor):; """"""; Representation of the physical implementation of a quantum; program/algorithm on a dispersive cavity-QED system.; """""". def __init__(self, N, correct_global_phase=True, Nres=None, deltamax=None,; epsmax=None, w0=None, wq=None, eps=None, delta=None, g=None):; """"""; Parameters; ----------; Nres: Integer; The number of energy levels in the resonator. deltamax: Integer/List; The sigma-x coefficient for each of the qubits in the system. epsmax: Integer/List; The sigma-z coefficient for each of the qubits in the system. wo: Integer; The base frequency of the resonator. wq: Integer/List; The frequency of the qubits. eps: Integer/List; The epsilon for each of the qubits in the system. delta: Integer/List; The epsilon for each of the qubits in the system. g: Integer/List; The interaction strength for each of the qubit with the resonator.; """""". super(DispersivecQED, self).__init__(N, correct_global_phase). # user definable; if Nres is None:; self.Nres = 10; else:; self.Nres = Nres. if deltamax is None:; self.sx_coeff = np.array([1.0 * 2 * np.pi] * N); elif not isinstance(deltamax, list):; self.sx_coeff = np.array([deltamax * 2 * np.pi] * N); else:; self.sx_coeff = np.array(deltamax). if epsmax is None:; self.sz_coeff = np.arr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/qip/models/cqed.html:2663,energy,energy,2663,docs/4.1/modules/qutip/qip/models/cqed.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/qip/models/cqed.html,6,['energy'],['energy']
Energy Efficiency,"Matrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, axes=None, figsize=(8, 4))[source]¶; Visualize the results (expectation values) for an evolution solver.; results is assumed to be an instance of Result, or a list of Result; instances. Parameters. res",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:168270,energy,energy,168270,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['energy'],['energy']
Energy Efficiency,"Matrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters. rhoqutip.qobj.QobjThe density matrix (or ket) of the state to visual",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:130678,energy,energy,130678,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"None:; fig = plt.figure(); ax = Axes3D(fig, azim=-35, elev=35). ax.bar3d(xpos, ypos, zpos, dx, dy, dz, color=colors). if title and fig:; ax.set_title(title). # x axis; ax.axes.w_xaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if xlabels:; ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if ylabels:; ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/visualization.html:14341,energy,energy,14341,docs/4.1/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/visualization.html,7,['energy'],['energy']
Energy Efficiency,"Python notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function. The function that is to be called for each value in task_vec. task_vec: array / list. The list or array of values for which the task function is to be; evaluated. args: list / dictionary. The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False. Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; Th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:198645,schedul,scheduling,198645,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['schedul'],['scheduling']
Energy Efficiency,"Qdeoptions) – Options for the ODE solver. Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Return type:qutip.solver. Floquet States and Floquet-Markov Master Equation¶. fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:; H (qutip.qobj) – system Hamiltonian.; / psi0 (rho0) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; c_ops (list of qutip.qobj) – list of collapse operators.; e_ops (list of qutip.qobj / callback function) – list of operators for which to evaluate expectation values.; spectra_cb (list callback functions) – List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops.; T (float) – The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving.; args (dictionary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options (qutip.solver) – options for the ODE solver.; k_max (int) – The truncation of the number of sidebands (default 5). Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:68750,power,power,68750,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"Qdeoptions. Options for the ODE solver. Returns:output: qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. fmmesolve(H, rho0, tlist, c_ops, e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options instance at 0x105963290>, floquet_basis=True, kmax=5)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:H : qutip.qobj. system Hamiltonian. rho0 / psi0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.qobj. list of collapse operators. e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. spectra_cb : list callback functions. List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:57719,power,power,57719,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Features. QuTiP is the original quantum framework written in Python; the most widely ; used programming language in the quantum sciences. Python's straightforward syntax allows for constructing, manipulating, and evolving quantum objects using QuTiP with just a few lines of code. Easy to learn, and 100% open-source, QuTiP is the ideal toolbox for research or the classroom. Did you know that you can determine if an operator is Hermitian without performing the conjugate transpose? QuTiP does. In fact, it is just one of many custom algorithms that QuTiP uses to maximize performance. Focusing on sparse matrices, and the means by which to efficiently manipulate these data structures, allows QuTiP to tackle even the largest quantum mechanical calculations. ; . In addition to custom algorithms, QuTiP is capable of leveraging the multiprocessing power inside every modern computer. Taking advantage of the Python multiprocessing library, OPENMP, SSE3 processor extensions, and the Intel MKL, if available, allows for faster manipulation of quantum objects, and increased performance of evolution equations, without any work at all.; . QuTiP includes a variety of builtin solvers for dynamical simulations. In addition to the standard Lindblad and Monte Carlo Solvers, QuTiP includes routines for Bloch-Redfield evolution, periodic systems using the Floquet formalism, and stochastic solvers. Add to this, steady state analysis and non-Markovian techniques, and you have a wide variety of tools from which to explore your systems behavior. A wide range of time-dependent evolution simulations can be runtime compiled into C++ behind the scenes using Cython. Thus, you get the ease of use of the Python programming language, and the performance of compiled code, all for free. What can be better than that?; . Can't express",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/features.html:1130,power,power,1130,features.html,https://qutip.org,https://qutip.org/features.html,1,['power'],['power']
Energy Efficiency,"Returned sample array is not evenly spaced if addtional elements; are added. Parameters:start : int. The starting value of the sequence. stop : int. The stoping values of the sequence. num : int, optional. Number of samples to generate. elems : list/ndarray, optional. Requested elements to include in array. Returns:samples : ndadrray. Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:j1 : float. Total angular momentum 1. j2 : float. Total angular momentum 2. j3 : float. Total angular momentum 3. m1 : float. z-component of angular momentum 1. m2 : float. z-component of angular momentum 2. m3 : float. z-component of angular momentum 3. Returns:cg_coeff : float. Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')¶; Convert an energy from unit orig to unit to. Parameters:value : float / array. The energy in the old unit. orig : string. The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string. The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit : float / array. The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)¶; Retrieves an array of data from the requested file. Parameters:filename : str. Name of file containing reqested data. sep : str. Seperator used to store data. Returns:data : array_like. Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')¶; Stores a matrix of data to a file to be read by an external program. Parameters:filename : str. Name of data file to be stored, including extension. data: array_like :. Data to be written to file. numtype : str {‘complex, ‘real’}. Type of numerical data. numformat : str {‘decimal’,’exp’}. Format for written data. sep : str. Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:105973,energy,energy,105973,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"Returns num spaced array with elements from elems inserted; if not already included in set.; Returned sample array is not evenly spaced if addtional elements; are added. Parameters:start : int. The starting value of the sequence. stop : int. The stoping values of the sequence. num : int, optional. Number of samples to generate. elems : list/ndarray, optional. Requested elements to include in array. Returns:samples : ndadrray. Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:j1 : float. Total angular momentum 1. j2 : float. Total angular momentum 2. j3 : float. Total angular momentum 3. m1 : float. z-component of angular momentum 1. m2 : float. z-component of angular momentum 2. m3 : float. z-component of angular momentum 3. Returns:cg_coeff : float. Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')¶; Convert an energy from unit orig to unit to. Parameters:value : float / array. The energy in the old unit. orig : string. The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string. The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit : float / array. The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)¶; Retrieves an array of data from the requested file. Parameters:filename : str. Name of file containing reqested data. sep : str. Seperator used to store data. Returns:data : array_like. Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')¶; Stores a matrix of data to a file to be read by an external program. Parameters:filename : str. Name of data file to be stored, including extension. data: array_like :. Data to be written to file. numtype : str {‘complex, ‘real’}. Type of numerical data. numformat : str {‘decimal’,’exp’}. Format for written data. sep : st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:105901,energy,energy,105901,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"Rotation around y axis. “RZ”; Rotation around z axis. “SQRTNOT”; Square root of NOT gate. “SNOT”; Hardmard gate. “PHASEGATE”; Add a phase one the state 1. “CRX”; Controlled rotation around x axis. “CRY”; Controlled rotation around y axis. “CRZ”; Controlled rotation around z axis. “CPHASE”; Controlled phase gate. “CNOT”; Controlled NOT gate. “CSIGN”; Same as CPHASE. “BERKELEY”; Berkeley gate. “SWAPalpha”; SWAPalpha gate. “SWAP”; Swap the states of two qubits. “ISWAP”; Swap gate with additional phase for 01 and 10 states. “SQRTSWAP”; Square root of the SWAP gate. “SQRTISWAP”; Square root of the ISWAP gate. “FREDKIN”; Fredkin gate. “TOFFOLI”; Toffoli gate. “GLOBALPHASE”; Global phase. For some of the gates listed above, qutip.qip.QubitCircuit also has a primitive qutip.qip.QubitCircuit.resolve_gates method that decomposes them into elementary gate sets such as CNOT or SWAP with single-qubit gates. However, this method is not fully optimized. It is very likely that the depth of the circuit can be further reduced by merging quantum gates. Apart from it, there is also a function drawing the circuit with LaTeX code using the Q-qircuit package from http://physics.unm.edu/CQuIC/Qcircuit.; In addition to these pre-defined gates, QuTiP also allows the user to define their own gate. The following example shows how to define a customized gate. Note; Available from QuTiP 4.4. >>> from qutip.qip.circuit import Gate; >>> from qutip.qip.operations import rx; >>> from qutip import Qobj; >>> import numpy as np; >>> def user_gate1(arg_value):; ... # controlled rotation X; ... mat = np.zeros((4, 4), dtype=np.complex); ... mat[0, 0] = mat[1, 1] = 1.; ... mat[2:4, 2:4] = rx(arg_value); ... return Qobj(mat, dims=[[2, 2], [2, 2]]); ...; >>> def user_gate2():; ... # S gate; ... mat = np.array([[1., 0],; ... [0., 1.j]]); ... return Qobj(mat, dims=[[2], [2]]); ...; >>>; >>> qc = QubitCircuit(2); >>> qc.user_gates = {""CTRLRX"": user_gate1,; ... ""S"" : user_gate2}; >>>; >>> # qubit 0 controlls qubi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-qip.html:3885,reduce,reduced,3885,docs/4.5/guide/guide-qip.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-qip.html,1,['reduce'],['reduced']
Energy Efficiency,"TORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:2531,efficient,efficient,2531,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,5,['efficient'],['efficient']
Energy Efficiency,"TORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/fidcomp.html:2540,efficient,efficient,2540,docs/4.5/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/fidcomp.html,1,['efficient'],['efficient']
Energy Efficiency,"TORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:2560,efficient,efficient,2560,docs/4.6/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html,2,['efficient'],['efficient']
Energy Efficiency,"True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'mkl',; 'use_rcm': False,; 'use_wbm': False, 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None,; 'maxiter': 1000}. return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, 'scipy', 'mkl'}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvilli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:5335,power,power,5335,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,8,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"TypeError(""Can only get matrix elements for an operator.""). else:; if bra.isbra and ket.isket:; return zcsr_mat_elem(self.data,bra.data,ket.data,1). elif bra.isket and ket.isket:; return zcsr_mat_elem(self.data,bra.data,ket.data,0); else:; raise TypeError(""Can only calculate matrix elements for bra and ket vectors.""). [docs] def overlap(self, other):; """"""Overlap between two state vectors or two operators. Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters; -----------; other : :class:`qutip.Qobj`; Quantum object for a state vector of type 'ket', 'bra' or density; matrix. Returns; -------; overlap : complex; Complex valued overlap. Raises; ------; TypeError; Can only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; -----; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets.; """""". if isinstance(other, Qobj):. if self.isbra:; if other.isket:; return zcsr_inner(self.data, other.data, 1); elif other.isbra:; #Since we deal mainly with ket vectors, the bra-bra combo; #is not common, and not optimized.; return zcsr_inner(self.data, other.dag().data, 1); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; raise TypeError(""Can only calculate overlap for state vector Qobjs""). elif self.isket:; if other.isbra:; return zcsr_inner(other.data, self.data, 1); elif other.isket:; return zcsr_inner(self.data, other.data, 0); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; raise TypeError(""Can only calculate overlap for state vector Qobjs""). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * other).tr(); else:; raise Ty",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:39135,efficient,efficient,39135,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,1,['efficient'],['efficient']
Energy Efficiency,"WAP""]); tlists, coeffs = compiler.compile(resolved_qc); print(tlists); print(coeffs). Output; [array([0., 1.]), array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate on Spin Chain model,; the rotation over X-axis.; We pass the hardware parameters of the SpinChain ` model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:11515,schedul,scheduler,11515,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,3,"['Schedul', 'schedul']","['Scheduler', 'scheduler']"
Energy Efficiency,"[docs] def coefficient_matrix(self):; """"""Build coefficient matrix for ODE for a diagonal problem. Returns; -------; M: ndarray; The matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis.; """"""; diagonal_system = Pim(N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=self.collective_emission,; collective_dephasing=self.collective_dephasing,; collective_pumping=self.collective_pumping); coef_matrix = diagonal_system.coefficient_matrix(); return coef_matrix. # Utility functions for properties of the Dicke space; def energy_degeneracy(N, m):; """"""Calculate the number of Dicke states with same energy. The use of the `Decimals` class allows to explore N > 1000,; unlike the built-in function `scipy.special.binom`. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""; numerator = Decimal(factorial(N)); d1 = Decimal(factorial(N/2 + m)); d2 = Decimal(factorial(N/2 - m)); degeneracy = numerator/(d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; """"""Calculate the degeneracy of the Dicke state. Each state :math:`|j, m\\rangle` includes D(N,j) irreducible; representations :math:`|j, m, \\alpha\\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2*j + 1); denominator_1 = Decimal(factorial(N/2 + j + 1)); denominator_2 = Decimal(factorial(N/2 - j)); degeneracy = numerator/(denominator_1 * denominator_2); degeneracy = int(np.round(float(degeneracy))); return d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/piqs.html:12987,energy,energy,12987,docs/4.3/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/piqs.html,2,['energy'],['energy']
Energy Efficiency,"\omega)\) for the frequencies; specified in wlist. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters:; H : qutip.qobj; system Hamiltonian. wlist : array_like; list of frequencies for \(\omega\). c_ops : list of qutip.qobj; list of collapse operators. a_op : qutip.qobj; operator A. b_op : qutip.qobj; operator B. use_pinv : bool; If True use numpy’s pinv method, otherwise use a generic solver. Returns:; spectrum : array; An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:; tlist : array_like; list/array of times \(t\) which the correlation function is given. y : array_like; list/array of correlations corresponding to time delays \(t\). inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns:; w, S : tuple; Returns an array of angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:97614,power,power,97614,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A (qobj) – A Hamiltonian or Liouvillian operator.; c_op_list (list) – A list of collapse operators.; method (str {'direct', 'eigen', 'iterative-gmres',) – ; ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info (bool, optional, default = False) – Return a dictionary of solver-specific infomation about the; solution and how it was obtained.; sparse (bool, optional, default = True) – Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian.; use_wbm (bool, optional, default = False) – Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner.; weight (float, optional) – Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvill",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:101948,power,power,101948,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,4,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"]¶; Von Neumann Entropy of a Dicke-basis density matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. entropy_dm: floatEntropy. Use degeneracy to multiply each block. state_degeneracy(N, j)[source]¶; Calculate the degeneracy of the Dicke state.; Each state \(|j, m\rangle\) includes D(N,j) irreducible; representations \(|j, m, \alpha\rangle\).; Uses Decimals to calculate higher numerator and denominators numbers. Parameters. N: intThe number of two-level systems. j: floatTotal spin eigenvalue (cooperativity). Returns. degeneracy: intThe state degeneracy. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(|j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. energy_degeneracy(N, m)[source]¶; Calculate the number of Dicke states with same energy.; The use of the Decimals class allows to explore N > 1000,; unlike the built-in function scipy.special.binom. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns. degeneracy: intThe energy degeneracy. ap(j, m)[source]¶; Calculate the coefficient ap by applying J_+ |j, m>.; The action of ap is given by:; \(J_{+}|j, m\rangle = A_{+}(j, m)|j, m+1\rangle\). Parameters. j, m: floatThe value for j and m in the dicke basis |j,m>. Returns. a_plus: floatThe value of \(a_{+}\). am(j, m)[source]¶; Calculate the operator am used later.; The action of ap is given by: J_{-}|j, m> = A_{-}(jm)|j, m-1>. Parameters. j: floatThe value for j. m: floatThe value for m. Returns. a_minus: floatThe value of \(a_{-}\). spin_algebra(N, op=None)[source]¶; Create the list [sx, sy, sz] with the spin operators.; The operators are constructed for a collection of N two-level s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:137162,energy,energy,137162,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"_eigenvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = Qobj(np.multiply(cdg.full()*dyn.tau[k],; dyn._dyn_gen_factormatrix[k]), dims=dyn.dyn_dims); # Return to canonical basis; prop_grad = (dyn._dyn_gen_eigenvectors[k]*cdg*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; # put control dyn_gen in combined dg diagonal basis; cdg = dyn._get_dyn_gen_eigenvectors_adj(k).dot(; dyn._get_phased_ctrl_dyn_gen(j)).dot(; dyn._dyn_gen_eigenvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = np.multiply(cdg*dyn.tau[k], dyn._dyn_gen_factormatrix[k]); # Return to canonical basis; prop_grad = dyn._dyn_gen_eigenvectors[k].dot(cdg).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). if compute_prop:; return prop, prop_grad; else:; return prop_grad. class PropCompAugMat(PropagatorComputer):; """"""; Augmented Matrix (deprecated - see _Frechet). It should work for all systems, e.g. open, symplectic; There will be other PropagatorComputer subclasses that are more efficient; The _Frechet class should provide exactly the same functionality; more efficiently. Note the propagator gradient calculation using the augmented matrix; is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'AUG_MAT'; self.grad_exact = True; self.apply_params(). def _get_aug_mat(self, k, j):; """"""; Generate the matrix [[A, E], [0, A]] where; A is the overall dynamics generator; E is the control dynamics generator; for a given timeslot and control; returns this augmented matrix; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k). if dyn.oper_dtype == Qobj:; A = dg.data*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(j).data*dyn.tau[k]; Z = sp.csr_matrix(dg.data.shape); aug = Qobj(sp.vstack([sp.hstack([A, E]), sp.hstack([Z, A])])); elif dyn.oper_dtype == np.ndarray:; A = dg*dyn.tau[k]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html:9907,efficient,efficient,9907,docs/4.1/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html,4,['efficient'],"['efficient', 'efficiently']"
Energy Efficiency,"_fock_distribution(rho, offset=0, fig=None, ax=None,; figsize=(8, 6), title=None, unit_y_range=True):; """"""; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :class:`qutip.qobj.Qobj`; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. title : string; An optional title for the figure. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure.; """""". if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). if isket(rho):; rho = ket2dm(rho). N = rho.shape[0]. ax.bar(np.arange(offset, offset + N) - .4, np.real(rho.diag()),; color=""green"", alpha=0.6, width=0.8); if unit_y_range:; ax.set_ylim(0, 1). ax.set_xlim(-.5 + offset, N + offset); ax.set_xlabel('Fock number', fontsize=12); ax.set_ylabel('Occupation probability', fontsize=12). if title:; ax.set_title(title). return fig, ax. def fock_distribution(rho, offset=0, fig=None, ax=None,; figsize=(8, 6), title=None, unit_y_range=True):; warnings.warn(""Deprecated: Use plot_fock_distribution""); return plot_fock_distribution(rho, offset=offset, fig=fig, ax=ax,; figsize=figsize, title=title,; unit_y_range=unit_y_range). [docs]def plot_wigner(rho, fig=None, ax=None, figsize=(6, 6),; cmap=None, alpha_max=7.5, colorbar=False,; method='clenshaw', projection='2d'):; """"""; Plot the the Wigner function for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :class:`qutip.qobj.Qobj`; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/visualization.html:17755,green,green,17755,docs/4.3/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/visualization.html,2,['green'],['green']
Energy Efficiency,"_fock_distribution(rho, offset=0, fig=None, ax=None,; figsize=(8, 6), title=None, unit_y_range=True):; """"""; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :class:`qutip.qobj.Qobj`; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. title : string; An optional title for the figure. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure.; """""". if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). if isket(rho):; rho = ket2dm(rho). N = rho.shape[0]. ax.bar(np.arange(offset, offset + N) - .4, np.real(rho.diag()),; color=""green"", alpha=0.6, width=0.8); if unit_y_range:; ax.set_ylim(0, 1). ax.set_xlim(-.5 + offset, N + offset); ax.set_xlabel('Fock number', fontsize=12); ax.set_ylabel('Occupation probability', fontsize=12). if title:; ax.set_title(title). return fig, ax. def fock_distribution(rho, offset=0, fig=None, ax=None,; figsize=(8, 6), title=None, unit_y_range=True):; warnings.warn(""Deprecated: Use plot_fock_distribution""); return plot_fock_distribution(rho, offset=offset, fig=fig, ax=ax,; figsize=figsize, title=title,; unit_y_range=unit_y_range). [docs]def plot_wigner(rho, fig=None, ax=None, figsize=(8, 4),; cmap=None, alpha_max=7.5, colorbar=False,; method='iterative', projection='2d'):; """"""; Plot the the Wigner function for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :class:`qutip.qobj.Qobj`; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/visualization.html:17703,green,green,17703,docs/4.1/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/visualization.html,4,['green'],['green']
Energy Efficiency,"_precond : bool, default False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. fill_factor : float, default 100; ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, default 1e-4; ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, default 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; """"""; if solver is None:; solver = 'scipy'; if settings.has_mkl:; if method in ['direct', 'power']:; solver = 'mkl'; elif solver == 'mkl' and \; (method not in ['direct', 'power']):; raise Exception('MKL solver only for direct or power methods.'). elif solver not in [",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:9323,reduce,reduced,9323,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,2,['reduce'],['reduced']
Energy Efficiency,"_precond : bool, default False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. fill_factor : float, default 100; ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, default 1e-4; ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, default 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; """"""; if solver is None:; solver = 'scipy'; if settings.has_mkl:; if method in ['direct', 'power']:; solver = 'mkl'; elif solver == 'mkl' and \; (method not in ['direct', 'power']):; raise ValueError('MKL solver only for direct or power methods.'). elif solver not in ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:8312,reduce,reduced,8312,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,2,['reduce'],['reduced']
Energy Efficiency,"_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:24440,power,power,24440,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['power'],['power']
Energy Efficiency,_state() (in module qutip.states). berkeley() (in module qutip.qip.operations.gates). berry_curvature() (in module qutip.topology). Bloch (class in qutip.bloch). Bloch3d (class in qutip.bloch3d). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bloch_wave_functions() (Lattice1d method). block_matrix() (in module qutip.piqs). BosonicBath (class in qutip.nonmarkov.heom). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bulk_Hamiltonians() (Lattice1d method). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). CavityQEDCompiler (class in qutip.qip.compiler). cell_periodic_parts() (Lattice1d method). cell_structures() (in module qutip.lattice). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). chi_to_choi() (in module qutip.superop_reps). choi_to_chi() (in module qutip.superop_reps). choi_to_kraus() (in module qutip.superop_reps). choi_to_super() (in module qutip.superop_reps). circuit_to_qasm_str() (in module qutip.qip.qasm). CircuitResult (class in qutip.qip.circuit). CircuitSimulator (class in qutip.qip.circuit). CircularSpinChain (class in qutip.qip.device). clear() (Bloch method). (Bloch3d method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.operations.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (DispersiveCavityQED property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/genindex.html:3613,charge,charge,3613,docs/4.7/genindex.html,https://qutip.org,https://qutip.org/docs/4.7/genindex.html,1,['charge'],['charge']
Energy Efficiency,"_time in \; zip(instruction_list, scheduled_start_time):; for pulse_name, coeff in instruction.pulse_info:; if self.pulse_dict:; try:; pulse_ind = self.pulse_dict[pulse_name]; except KeyError:; raise ValueError(; f""Pulse name {pulse_name} not found""; "" in pulse_dict.""); else:; pulse_ind = pulse_name; pulse_instructions[pulse_ind].append(; (start_time, instruction.tlist, coeff)). # concatenate pulses; compiled_tlist, compiled_coeffs = \; self._concatenate_pulses(; pulse_instructions, scheduled_start_time, num_controls); return compiled_tlist, compiled_coeffs. def _schedule(self, instruction_list, schedule_mode):; """"""; Schedule the instructions if required and ; reorder instruction_list accordingly; """"""; if schedule_mode:; scheduler = Scheduler(schedule_mode); scheduled_start_time = scheduler.schedule(instruction_list); time_ordered_pos = np.argsort(scheduled_start_time); instruction_list = [instruction_list[i] for i in time_ordered_pos]; scheduled_start_time.sort(); else: # no scheduling; scheduled_start_time = [0.]; for instruction in instruction_list[:-1]:; scheduled_start_time.append(; instruction.duration + scheduled_start_time[-1]); return instruction_list, scheduled_start_time. def _concatenate_pulses(; self, pulse_instructions, scheduled_start_time, num_controls):; """"""; Concatenate compiled pulses coefficients and tlist for each pulse.; If there is idling time, add zeros properly to prevent wrong spline.; """"""; # Concatenate tlist and coeffs for each control pulses; compiled_tlist = [[] for tmp in range(num_controls)]; compiled_coeffs = [[] for tmp in range(num_controls)]; for pulse_ind in range(num_controls):; last_pulse_time = 0.; for start_time, tlist, coeff in pulse_instructions[pulse_ind]:; # compute the gate time, step size and coeffs; # according to different pulse mode; gate_tlist, coeffs, step_size, pulse_mode = \; self._process_gate_pulse(start_time, tlist, coeff). if abs(last_pulse_time) < step_size * 1.0e-6: # if first pulse; compiled_tlist[pulse_ind",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:7293,schedul,scheduling,7293,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,4,['schedul'],['scheduling']
Energy Efficiency,"_unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:6198,energy,energy,6198,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,11,['energy'],['energy']
Energy Efficiency,"` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_args=None, task_kwargs=None,; client=None, view=None, progress_bar=None,; show_scheduling=False, **kwargs):; """"""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The `",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html:8296,schedul,scheduled,8296,docs/4.2/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html,11,['schedul'],['scheduled']
Energy Efficiency,"``, such that; ``choi.superrep == ""choi""``.; """"""; len_op = np.prod(kraus_ops[0].shape); # If Kraus ops have dims [M, N] in qutip notation (act on [N, N] density matrix and produce [M, M] d.m.),; # Choi matrix Hilbert space will be [[M, N], [M, N]] because Choi Hilbert space is (output space) x (input space).; choi_dims = [kraus_ops[0].dims] * 2; # transform a list of Qobj matrices list[sum_ij k_ij |i><j|]; # into an array of array vectors sum_ij k_ij |i, j>> = sum_I k_I |I>>; kraus_vectors = np.asarray(; [np.reshape(kraus_op.full(), len_op, ""F"") for kraus_op in kraus_ops]; ); # sum_{I} |k_I|^2 |I>><<I|; choi_array = np.tensordot(kraus_vectors, kraus_vectors.conj(), axes=([0], [0])); return Qobj(choi_array, choi_dims, superrep=""choi"", copy=False). [docs]def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.prod(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. [docs]def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). [docs]def chi_to_choi(q_oper):; """"""; Converts a Chi matrix to a Choi matrix. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the sup",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html:8294,power,power,8294,docs/4.7/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/superop_reps.html,2,['power'],['power']
Energy Efficiency,"a) * sm,; ]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so ; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = qutip.correlation_2op_1t(H, None, tlist, c_ops, a.dag(), a); wlist1, spec1 = qutip.spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default); wlist2 = np.linspace(0.25, 1.75, 200) * 2 * np.pi; spec2 = qutip.spectrum(H, wlist2, c_ops, a.dag(), a). # plot the spectra; fig, ax = pyplot.subplots(1, 1); ax.plot(wlist1 / (2 * np.pi), spec1, 'b', lw=2, label='eseries method'); ax.plot(wlist2 / (2 * np.pi), spec2, 'r--', lw=2, label='me+fft method'); ax.legend(); ax.set_xlabel('Frequency'); ax.set_ylabel('Power spectrum'); ax.set_title('Vacuum Rabi splitting'); ax.set_xlim(wlist2[0]/(2*np.pi), wlist2[-1]/(2*np.pi)); plt.show(). (png, hires.png, pdf). Non-steadystate correlation function¶; More generally, we can also calculate correlation functions of the kind \(\left<A(t_1+t_2)B(t_1)\right>\), i.e., the correlation function of a system that is not in its steadystate. In QuTiP, we can evoluate such correlation functions using the function qutip.correlation.correlation_2op_2t. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (\(t_1\) and \(t_2\)).; import numpy as np; import matplotlib.pyplot as plt; import qutip. times = np.linspace(0, 10.0, 200); a = qutip.destroy(10); x = a.dag() + a; H = a.dag() * a; alpha = 2.5; rho0 = qutip.coherent_dm(10, alpha); corr = qutip.correlation_2op_2t(H, rho0, times, times, [np.sqrt(0.25) * a], x, x). plt.pcolor(np.real(corr)); plt.xlabel(r'Time $t_2$'); plt.ylabel(r'Time $t_1$'); plt.t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-correlation.html:6767,Power,Power,6767,docs/4.6/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-correlation.html,1,['Power'],['Power']
Energy Efficiency,"a) * sm,; ]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so ; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = qutip.correlation_2op_1t(H, None, tlist, c_ops, a.dag(), a); wlist1, spec1 = qutip.spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default); wlist2 = np.linspace(0.25, 1.75, 200) * 2 * np.pi; spec2 = qutip.spectrum(H, wlist2, c_ops, a.dag(), a). # plot the spectra; fig, ax = pyplot.subplots(1, 1); ax.plot(wlist1 / (2 * np.pi), spec1, 'b', lw=2, label='eseries method'); ax.plot(wlist2 / (2 * np.pi), spec2, 'r--', lw=2, label='me+fft method'); ax.legend(); ax.set_xlabel('Frequency'); ax.set_ylabel('Power spectrum'); ax.set_title('Vacuum Rabi splitting'); ax.set_xlim(wlist2[0]/(2*np.pi), wlist2[-1]/(2*np.pi)); plt.show(). Non-steadystate correlation function¶; More generally, we can also calculate correlation functions of the kind \(\left<A(t_1+t_2)B(t_1)\right>\), i.e., the correlation function of a system that is not in its steady state. In QuTiP, we can evaluate such correlation functions using the function qutip.correlation.correlation_2op_2t. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (\(t_1\) and \(t_2\)).; import numpy as np; import matplotlib.pyplot as plt; import qutip. times = np.linspace(0, 10.0, 200); a = qutip.destroy(10); x = a.dag() + a; H = a.dag() * a; alpha = 2.5; rho0 = qutip.coherent_dm(10, alpha); corr = qutip.correlation_2op_2t(H, rho0, times, times, [np.sqrt(0.25) * a], x, x). plt.pcolor(np.real(corr)); plt.xlabel(r'Time $t_2$'); plt.ylabel(r'Time $t_1$'); plt.title(r'Correlation $\l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-correlation.html:6777,Power,Power,6777,docs/4.7/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html,1,['Power'],['Power']
Energy Efficiency,"a, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if has_mkl:; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro); ; if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm'",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:22284,power,power,22284,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['power'],['power']
Energy Efficiency,"a, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); with warnings.catch_warnings():; warnings.filterwarnings(; ""ignore"", ""qutip graph functions are deprecated"",; DeprecationWarning,; ); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:23830,power,power,23830,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,2,['power'],['power']
Energy Efficiency,"a, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for power based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = L.shape[0]; if ss_args['solver'] == 'mkl':; L = L.data - (1e-15) * sp.eye(n, n, format='csr'); kind = 'csr'; else:; L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); kind = 'csc'; orig_nnz = L.nnz; if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Original bandwidth: %i' % old_band); logger.debug('Original profile: %i' % old_pro). if ss_args['use_wbm']:; if settings.debug:; logger.debug('Calculating Weighted Bipartite Matching ordering...'); _wbm_start = time.time(); perm = weighted_bipartite_matching(L); _wbm_end = time.time(); L = sp_permute(L, perm, [], kind); ss_args['info']['perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:25089,power,power,25089,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,5,['power'],['power']
Energy Efficiency,"abels : list of strings; list of x labels. ylabels : list of strings; list of y labels. title : string; title of the plot (optional). limits : list/array with two float numbers; The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:; rho : qutip.qobj.Qobj; T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:130909,energy,energy,130909,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"abels; and title. Parameters:; M (Matrix of Qobj) – The matrix to visualize; xlabels (list of strings) – list of x labels; ylabels (list of strings) – list of y labels; title (string) – title of the plot (optional); limits (list/array with two float numbers) – The z-axis limits [min, max] (optional); phase_limits (list/array with two float numbers) – The phase-axis (colorbar) limits [min, max] (optional); ax (a matplotlib axes instance) – The axes context in which the plot will be drawn.; threshold (float (None)) – Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list (List of Qobj) – A list of Hamiltonians.; labels (List of string) – A list of labels for each Hamiltonian; show_ylabels (Bool (default False)) – Show y labels to the left of energy levels of the initial; Hamiltonian.; N (int) – The number of energy levels to plot; figsize (tuple (int,int)) – The size of the figure (width, height).; fig (a matplotlib Figure instance) – The Figure canvas in which the plot will be drawn.; ax (a matplotlib axes instance) – The axes context in which the plot will be drawn. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Foc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:117291,energy,energy,117291,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"ability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with a modified; liouvillian. (5)¶\[L_{\rm eff}(\rho(t)) = L_{\rm sys}(\rho(t)) +; \sum_{n}\left(; \rm{tr} \left(C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right); - C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right),\]; with the probability of jumps in a time step \(\delta t\) given by. (6)¶\[\delta p = \rm{tr} \left( C \rho C^{+} \right) \delta t.\]; After a jump, the density matrix become. \[\rho' = \frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)}.\]; The evolution of the system at each time step if thus given by. (7)¶\[\rho(t + \delta t) = \rho(t) + L_{\rm eff}(\rho) \delta t + \delta N; \left(\frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)} - \rho \right).\]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-photocurrent.html:3170,efficient,efficient,3170,docs/4.5/guide/dynamics/dynamics-photocurrent.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-photocurrent.html,3,['efficient'],['efficient']
Energy Efficiency,"ability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with a modified; liouvillian. \[L_{\rm eff}(\rho(t)) = L_{\rm sys}(\rho(t)) +; \sum_{n}\left(; \rm{tr} \left(C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right); - C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right),\]; with the probability of jumps in a time step \(\delta t\) given by. (5)¶\[\delta p = \rm{tr} \left( C \rho C^{+} \right) \delta t.\]; After a jump, the density matrix become. \[\rho' = \frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)}.\]; The evolution of the system at each time step if thus given by. (6)¶\[\rho(t + \delta t) = \rho(t) + L_{\rm eff}(\rho) \delta t + \delta N; \left(\frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)} - \rho \right).\]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-photocurrent.html:3145,efficient,efficient,3145,docs/4.4/guide/dynamics/dynamics-photocurrent.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-photocurrent.html,1,['efficient'],['efficient']
Energy Efficiency,"ability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.stochastic.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with a modified; liouvillian. (5)¶\[L_{\rm eff}(\rho(t)) = L_{\rm sys}(\rho(t)) +; \sum_{n}\left(; \rm{tr} \left(C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right); - C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right),\]; with the probability of jumps in a time step \(\delta t\) given by. (6)¶\[\delta p = \rm{tr} \left( C \rho C^{+} \right) \delta t.\]; After a jump, the density matrix become. \[\rho' = \frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)}.\]; The evolution of the system at each time step if thus given by. (7)¶\[\rho(t + \delta t) = \rho(t) + L_{\rm eff}(\rho) \delta t + \delta N; \left(\frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)} - \rho \right).\]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP develo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:3276,efficient,efficient,3276,docs/4.7/guide/dynamics/dynamics-photocurrent.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html,2,['efficient'],['efficient']
Energy Efficiency,"acting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:8273,reduce,reduced,8273,docs/4.6/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html,4,['reduce'],['reduced']
Energy Efficiency,"acting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^{+} - \rho(t) C_n^{+} C_n - C_n^{+} C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires: (1) that th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html:8513,reduce,reduced,8513,docs/4.2/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html,5,['reduce'],['reduced']
Energy Efficiency,"acting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^{+} - \rho(t) C_n^{+} C_n - C_n^{+} C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (5) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (5) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires: (1) that th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-master.html:8606,reduce,reduced,8606,docs/4.5/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-master.html,1,['reduce'],['reduced']
Energy Efficiency,"actor); _factorial_div(j2 - m2, c_factor); _factorial_div(j2 + m2, c_factor); C = np.sqrt((2.0 * j3 + 1.0)*_to_long(c_factor)). s_factors = np.zeros(((vmax + 1 - vmin), (int(j1 + j2 + j3))), np.int32); sign = (-1) ** (vmin + j2 + m2); for i,v in enumerate(range(vmin, vmax + 1)):; factor = s_factors[i,:]; _factorial_prod(j2 + j3 + m1 - v, factor); _factorial_prod(j1 - m1 + v, factor); _factorial_div(j3 - j1 + j2 - v, factor); _factorial_div(j3 + m3 - v, factor); _factorial_div(v + j1 - j2 - m3, factor); _factorial_div(v, factor); common_denominator = -np.min(s_factors, axis=0); numerators = s_factors + common_denominator; S = sum([(-1)**i * _to_long(vec) for i,vec in enumerate(numerators)]) * \; sign / _to_long(common_denominator); return C * S. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/utilities.html:5218,Joule,Joule,5218,docs/4.6/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html,2,['Joule'],['Joule']
Energy Efficiency,"addtional elements; are added. Parameters:; start (int) – The starting value of the sequence.; stop (int) – The stoping values of the sequence.; num (int, optional) – Number of samples to generate.; elems (list/ndarray, optional) – Requested elements to include in array. Returns:samples – Original equally spaced sample array with additional; elements added. Return type:ndadrray. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:; j1 (float) – Total angular momentum 1.; j2 (float) – Total angular momentum 2.; j3 (float) – Total angular momentum 3.; m1 (float) – z-component of angular momentum 1.; m2 (float) – z-component of angular momentum 2.; m3 (float) – z-component of angular momentum 3. Returns:cg_coeff – Requested Clebsch-Gordan coefficient. Return type:float. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:; value (float / array) – The energy in the old unit.; orig (string) – The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”); to (string) – The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit – The energy in the new unit. Return type:float / array. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename (str) – Name of file containing reqested data.; sep (str) – Seperator used to store data. Returns:data – Data from selected file. Return type:array_like. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:; filename (str) – Name of data file to be stored, including extension.; data (array_like) – Data to be written to file.; numtype (str {'complex, 'real'}) – Type of numerical data.; numformat (str {'decimal','exp'}) – Format for written data.; sep (str) – Single-charac",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:194812,energy,energy,194812,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"adients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,...) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,....). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:11325,efficient,efficiently,11325,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,1,['efficient'],['efficiently']
Energy Efficiency,"adients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] tha",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-control.html:11325,efficient,efficiently,11325,docs/4.3/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html,5,['efficient'],['efficiently']
Energy Efficiency,"ains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. target",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:185779,schedul,schedule,185779,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['schedul'],['schedule']
Energy Efficiency,"al, vk_real); ); exponents.extend(; BathExponent(""I"", None, Q, ck, vk, tag=tag); for ck, vk in zip(ck_imag, vk_imag); ). if combine:; exponents = self.combine(exponents). super().__init__(exponents). [docs] @classmethod; def combine(cls, exponents, rtol=1e-5, atol=1e-7):; """"""; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present. Exponents with the same frequency are only combined if they share the; same coupling operator ``.Q``. Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters; ----------; exponents : list of BathExponent; The list of exponents to combine. rtol : float, default 1e-5; The relative tolerance to use to when comparing frequencies and; coupling operators. atol : float, default 1e-7; The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns; -------; list of BathExponent; The new reduced list of exponents.; """"""; groups = []; remaining = exponents[:]. while remaining:; e1 = remaining.pop(0); group = [e1]; for e2 in remaining[:]:; if (; np.isclose(e1.vk, e2.vk, rtol=rtol, atol=atol) and; np.allclose(e1.Q, e2.Q, rtol=rtol, atol=atol); ):; group.append(e2); remaining.remove(e2); groups.append(group). new_exponents = []; for combine in groups:; exp1 = combine[0]; if (exp1.type != exp1.types.RI) and all(; exp2.type == exp1.type for exp2 in combine; ):; # the group is either type I or R; ck = sum(exp.ck for exp in combine); new_exponents.append(BathExponent(; exp1.type, None, exp1.Q, ck, exp1.vk, tag=exp1.tag,; )); else:; # the group includes both type I and R exponents; ck_R = (; sum(exp.ck for exp in combine if exp.type == exp.types.R) +; sum(exp.ck for exp in combine if exp.type == exp.types.RI); ); ck_I = (; sum(exp.ck for exp in combine if exp.type == exp.types.I) +; sum(exp.ck2 for exp in combine if exp.type == exp.types.RI); ); new_exponents.append(B",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:7972,reduce,reduced,7972,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['reduce'],['reduced']
Energy Efficiency,"amics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)¶\[\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2). If the environmental ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-monte.html:1560,monitor,monitored,1560,docs/4.5/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-monte.html,1,['monitor'],['monitored']
Energy Efficiency,"amples to generate. elems : list/ndarray, optional. Requested elements to include in array. Returns:samples : ndadrray. Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:j1 : float. Total angular momentum 1. j2 : float. Total angular momentum 2. j3 : float. Total angular momentum 3. m1 : float. z-component of angular momentum 1. m2 : float. z-component of angular momentum 2. m3 : float. z-component of angular momentum 3. Returns:cg_coeff : float. Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')¶; Convert an energy from unit orig to unit to. Parameters:value : float / array. The energy in the old unit. orig : string. The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string. The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit : float / array. The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)¶; Retrieves an array of data from the requested file. Parameters:filename : str. Name of file containing reqested data. sep : str. Seperator used to store data. Returns:data : array_like. Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')¶; Stores a matrix of data to a file to be read by an external program. Parameters:filename : str. Name of data file to be stored, including extension. data: array_like :. Data to be written to file. numtype : str {‘complex, ‘real’}. Type of numerical data. numformat : str {‘decimal’,’exp’}. Format for written data. sep : str. Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:name : str. Name of data file to be loaded. Returns:qobject : instance / array_like. Object retrieved from requested file. qsave(data, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:106190,energy,energy,106190,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"ams(axis='x', labelsize=12). # y axis; ytics = -0.5 + np.arange(M.shape[1]); if parse_version(mpl.__version__) >= parse_version(""3.8""):; ax.axes.yaxis.set_major_locator(plt.FixedLocator(ytics)); else:; ax.axes.w_yaxis.set_major_locator(plt.FixedLocator(ytics)); if ylabels:; nylabels = len(ylabels); if nylabels != len(ytics):; raise ValueError(f""got {nylabels} ylabels but needed {len(ytics)}""); ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/visualization.html:24016,energy,energy,24016,docs/4.7/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html,2,['energy'],['energy']
Energy Efficiency,"an of the lattice. display_lattice()[source]¶; Produces a graphic portraying the lattice symbolically with a unit cell; marked in it. Returns. inter_TQobjThe coefficient of $psi_{i,N}^{dagger}psi_{0,i+1}$, i.e. the; coupling between the two boundary sites of the two unit cells i and; i+1. display_unit_cell(label_on=False)[source]¶; Produces a graphic displaying the unit cell features with labels on if; defined by user. Also returns a dict of Qobj’s corresponding to the; labeled elements on the display. Returns. HcelldictHcell[i][j] is the Hamiltonian segment for $H_{i,j}$ labeled on the; graphic. distribute_operator(op)[source]¶; A function that returns an operator matrix that applies op to all the; cells in the 1d lattice. Parameters; op (qutip.Qobj) – Qobj representing the operator to be applied at all cells. Returns. op_Hqutip.QobjQuantum object representing the operator with op applied at all; cells. get_dispersion(knpoints=0)[source]¶; Returns dispersion relationship for the lattice with the specified; number of unit cells with a k array and a band energy array. Returns. knxanp.arrayknxA[j][0] is the jth good Quantum number k. val_knsnp.arrayval_kns[j][:] is the array of band energies of the jth band good at; all the good Quantum numbers of k. k()[source]¶; Returns the crystal momentum operator. All degrees of freedom has the; cell number at their correspondig entry in the position operator. Returns. Qobj(ks)qutip.QobjThe crystal momentum operator in units of 1/a. L is the number; of unit cells, a is the length of a unit cell which is always taken; to be 1. operator_at_cells(op, cells)[source]¶; A function that returns an operator matrix that applies op to specific; cells specified in the cells list. Parameters. opqutip.QobjQobj representing the operator to be applied at certain cells. cells: list of intThe cells at which the operator op is to be applied. Returns. Qobj(op_H)QobjQuantum object representing the operator with op applied at; the specified cells. op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:70561,energy,energy,70561,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['energy'],['energy']
Energy Efficiency,"an using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation are; processes that describe dissipation in the quantum system due to its interaction; with an environment. These environmental interactions are defined by the; operators through which the system couples to the environment, and rates that; describe the strength of the processes.; In QuTiP, the product of the square root of the rate and the operator that; describe the dissipation process is called a collapse operator. A list of; collapse operators (c_ops) is passed as the fourth argument to the; qutip.mesolve function in order to define the dissipation processes in the master; equation. When the c_ops isn’t empty, the qutip.mesolve function will use; the master equation instead of the unitary Schrödinger equation.; Using the example with the spin dynamics from the previous section, we can; easily add a relaxation process (describing the dissipation of energy from the; spin to its environment), by adding np.sqrt(0.05) * sigmax() in the fourth; parameter to the qutip.mesolve function and moving the expectation; operators [sigmaz(), sigmay()] to the fifth argument.; >>> times = np.linspace(0.0, 10.0, 100); >>> result = mesolve(H, psi0, times, [np.sqrt(0.05) * sigmax()], [sigmaz(), sigmay()]); >>> fig, ax = plt.subplots(); >>> ax.plot(times, result.expect[0]) ; >>> ax.plot(times, result.expect[1]) ; >>> ax.set_xlabel('Time') ; >>> ax.set_ylabel('Expectation values') ; >>> ax.legend((""Sigma-Z"", ""Sigma-Y"")) ; >>> plt.show() . Here, 0.05 is the rate and the operator \(\sigma_x\) (qutip.operators.sigmax) describes the dissipation; process.; Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in its groundstate and the cavit",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:12877,energy,energy,12877,docs/4.7/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html,2,['energy'],['energy']
Energy Efficiency,"an using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation are; processes that describe dissipation in the quantum system due to its interaction; with an environment. These environmental interactions are defined by the; operators through which the system couples to the environment, and rates that; describe the strength of the processes.; In QuTiP, the product of the square root of the rate and the operator that; describe the dissipation process is called a collapse operator. A list of; collapse operators (c_ops) is passed as the fourth argument to the; qutip.mesolve function in order to define the dissipation processes in the master; equation. When the c_ops isn’t empty, the qutip.mesolve function will use; the master equation instead of the unitary Schrödinger equation.; Using the example with the spin dynamics from the previous section, we can; easily add a relaxation process (describing the dissipation of energy from the; spin to its environment), by adding np.sqrt(0.05) * sigmax() to; the previously empty list in the fourth parameter to the qutip.mesolve function:; >>> times = np.linspace(0.0, 10.0, 100); >>> result = mesolve(H, psi0, times, [np.sqrt(0.05) * sigmax()], [sigmaz(), sigmay()]); >>> fig, ax = plt.subplots(); >>> ax.plot(times, result.expect[0]) ; >>> ax.plot(times, result.expect[1]) ; >>> ax.set_xlabel('Time') ; >>> ax.set_ylabel('Expectation values') ; >>> ax.legend((""Sigma-Z"", ""Sigma-Y"")) ; >>> plt.show() . (png, hires.png, pdf). Here, 0.05 is the rate and the operator \(\sigma_x\) (qutip.operators.sigmax) describes the dissipation; process.; Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in its groundstate and the cavity in a 5-photon Fock state, t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:12899,energy,energy,12899,docs/4.6/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html,2,['energy'],['energy']
Energy Efficiency,"an using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation are; processes that describe dissipation in the quantum system due to its interaction; with an environment. These environmental interactions are defined by the; operators through which the system couples to the environment, and rates that; describe the strength of the processes.; In QuTiP, the product of the square root of the rate and the operator that; describe the dissipation process is called a collapse operator. A list of; collapse operators (c_ops) is passed as the fourth argument to the; qutip.mesolve function in order to define the dissipation processes in the master; equation. When the c_ops isn’t empty, the qutip.mesolve function will use; the master equation instead of the unitary Schrödinger equation.; Using the example with the spin dynamics from the previous section, we can; easily add a relaxation process (describing the dissipation of energy from the; spin to its environment), by adding np.sqrt(0.05) * sigmax() to; the previously empty list in the fourth parameter to the qutip.mesolve function:; In [21]: times = np.linspace(0.0, 10.0, 100). In [22]: result = mesolve(H, psi0, times, [np.sqrt(0.05) * sigmax()], [sigmaz(), sigmay()]). In [23]: fig, ax = subplots(). In [24]: ax.plot(times, result.expect[0]);. In [25]: ax.plot(times, result.expect[1]);. In [26]: ax.set_xlabel('Time');. In [27]: ax.set_ylabel('Expectation values');. In [28]: ax.legend((""Sigma-Z"", ""Sigma-Y""));. In [29]: show(). Here, 0.05 is the rate and the operator \(\sigma_x\) (qutip.operators.sigmax) describes the dissipation; process.; Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in its groundstate and the cavity in a 5-photon ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-master.html:13268,energy,energy,13268,docs/4.4/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-master.html,2,['energy'],['energy']
Energy Efficiency,"an using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation are; processes that describe dissipation in the quantum system due to its interaction; with an environment. These environmental interactions are defined by the; operators through which the system couples to the environment, and rates that; describe the strength of the processes.; In QuTiP, the product of the square root of the rate and the operator that; describe the dissipation process is called a collapse operator. A list of; collapse operators (c_ops) is passed as the fourth argument to the; qutip.mesolve function in order to define the dissipation processes in the master; equation. When the c_ops isn’t empty, the qutip.mesolve function will use; the master equation instead of the unitary Schrödinger equation.; Using the example with the spin dynamics from the previous section, we can; easily add a relaxation process (describing the dissipation of energy from the; spin to its environment), by adding np.sqrt(0.05) * sigmax() to; the previously empty list in the fourth parameter to the qutip.mesolve function:; In [21]: times = np.linspace(0.0, 10.0, 100). In [22]: result = mesolve(H, psi0, times, [np.sqrt(0.05) * sigmax()], [sigmaz(), sigmay()]). In [23]: fig, ax = subplots(). In [24]: ax.plot(times, result.expect[0]);. In [25]: ax.plot(times, result.expect[1]);. In [26]: ax.set_xlabel('Time');. In [27]: ax.set_ylabel('Expectation values');. In [28]: ax.legend((""Sigma-Z"", ""Sigma-Y""));. In [29]: show(fig). Here, 0.05 is the rate and the operator \(\sigma_x\) (qutip.operators.sigmax) describes the dissipation; process.; Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in its groundstate and the cavity in a 5-phot",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html:13127,energy,energy,13127,docs/4.2/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html,5,['energy'],['energy']
Energy Efficiency,"and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, ‘scipy’, ‘mkl’}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian eleme",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:102393,power,power,102393,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,4,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"andom.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at http://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:20447,schedul,schedule,20447,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,2,['schedul'],['schedule']
Energy Efficiency,"appa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). (png, hires.png, pdf). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). (png, hires.png, pdf). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:17749,power,power,17749,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,2,['power'],['power']
Energy Efficiency,"append(r"" \targ ""); elif gate.name == ""CT"":; col.append(r"" \targ ""); elif gate.name == ""TOFFOLI"":; col.append(r"" \targ ""); else:; col.append(r"" \gate{%s} "" %; _gate_label(gate.name, gate.arg_label)). elif gate.controls and n in gate.controls:; control_tag = (-1 if; self.reverse_states; else 1) * (gate.targets[0] - n); col.append(r"" \ctrl{%d} "" % control_tag). elif (gate.classical_controls and; (n - self.N) in gate.classical_controls):; control_tag = n - gate.targets[0]; col.append(r"" \ctrl{%d} "" % control_tag). elif (not gate.controls and not gate.targets):; # global gate; if ((self.reverse_states and n == self.N - 1) or; (not self.reverse_states and n == 0)):; col.append(r"" \multigate{%d}{%s} "" %; (self.N - 1,; _gate_label(gate.name,; gate.arg_label))); else:; col.append(r"" \ghost{%s} "" %; (_gate_label(gate.name,; gate.arg_label))); else:; col.append(r"" \qw ""). else:; measurement = op; col = []; for n in range(self.N+self.num_cbits):. if n in measurement.targets:; col.append(r"" \meter""); elif (n-self.N) == measurement.classical_store:; store_tag = n - measurement.targets[0]; col.append(r"" \qw \cwx[%d] "" % store_tag); else:; col.append(r"" \qw ""). col.append(r"" \qw ""); rows.append(col). input_states_quantum = [r""\lstick{\ket{"" + x + ""}}"" if x is not None; else """" for x in self.input_states[:self.N]]; input_states_classical = [r""\lstick{"" + x + ""}"" if x is not None; else """" for x in self.input_states[self.N:]]; input_states = input_states_quantum + input_states_classical. code = """"; n_iter = (reversed(range(self.N+self.num_cbits)) if self.reverse_states; else range(self.N+self.num_cbits)); for n in n_iter:; code += r"" & %s"" % input_states[n]; for m in range(len(ops)):; code += r"" & %s"" % rows[m][n]; code += r"" & \qw \\ "" + ""\n"". return code. # This slightly convoluted dance with the conversion formats is because; # image conversion has optional dependencies. We always want the `png` and; # `svg` methods to be available so that they are discoverable by the user,; # howe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:51565,meter,meter,51565,docs/4.6/modules/qutip/qip/circuit.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html,2,['meter'],['meter']
Energy Efficiency,"append(r"" \targ ""); elif gate.name == ""CT"":; col.append(r"" \targ ""); elif gate.name == ""TOFFOLI"":; col.append(r"" \targ ""); else:; col.append(r"" \gate{%s} "" %; _gate_label(gate.name, gate.arg_label)). elif gate.controls and n in gate.controls:; control_tag = (-1 if; self.reverse_states; else 1) * (gate.targets[0] - n); col.append(r"" \ctrl{%d} "" % control_tag). elif (gate.classical_controls and; (n - self.N) in gate.classical_controls):; control_tag = n - gate.targets[0]; col.append(r"" \ctrl{%d} "" % control_tag). elif (not gate.controls and not gate.targets):; # global gate; if ((self.reverse_states and n == self.N - 1) or; (not self.reverse_states and n == 0)):; col.append(r"" \multigate{%d}{%s} "" %; (self.N - 1,; _gate_label(gate.name,; gate.arg_label))); else:; col.append(r"" \ghost{%s} "" %; (_gate_label(gate.name,; gate.arg_label))); else:; col.append(r"" \qw ""). else:; measurement = op; col = []; for n in range(self.N+self.num_cbits):; if n in measurement.targets:; col.append(r"" \meter""); elif (n-self.N) == measurement.classical_store:; sgn = 1 if self.reverse_states else -1; store_tag = sgn * (n - measurement.targets[0]); col.append(r"" \qw \cwx[%d] "" % store_tag); else:; col.append(r"" \qw ""). col.append(r"" \qw ""); rows.append(col). input_states_quantum = [r""\lstick{\ket{"" + x + ""}}"" if x is not None; else """" for x in self.input_states[:self.N]]; input_states_classical = [r""\lstick{"" + x + ""}"" if x is not None; else """" for x in self.input_states[self.N:]]; input_states = input_states_quantum + input_states_classical. code = """"; n_iter = (reversed(range(self.N+self.num_cbits)) if self.reverse_states; else range(self.N+self.num_cbits)); for n in n_iter:; code += r"" & %s"" % input_states[n]; for m in range(len(ops)):; code += r"" & %s"" % rows[m][n]; code += r"" & \qw \\ "" + ""\n"". return code. # This slightly convoluted dance with the conversion formats is because; # image conversion has optional dependencies. We always want the `png` and; # `svg` methods to be available so",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/circuit.html:49520,meter,meter,49520,docs/4.7/modules/qutip/qip/circuit.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/circuit.html,2,['meter'],['meter']
Energy Efficiency,"array is not evenly spaced if addtional elements; are added. Parameters:start : int. The starting value of the sequence. stop : int. The stoping values of the sequence. num : int, optional. Number of samples to generate. elems : list/ndarray, optional. Requested elements to include in array. Returns:samples : ndadrray. Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:j1 : float. Total angular momentum 1. j2 : float. Total angular momentum 2. j3 : float. Total angular momentum 3. m1 : float. z-component of angular momentum 1. m2 : float. z-component of angular momentum 2. m3 : float. z-component of angular momentum 3. Returns:cg_coeff : float. Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:value : float / array. The energy in the old unit. orig : string. The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string. The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit : float / array. The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:filename : str. Name of file containing reqested data. sep : str. Seperator used to store data. Returns:data : array_like. Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:filename : str. Name of data file to be stored, including extension. data: array_like. Data to be written to file. numtype : str {‘complex, ‘real’}. Type of numerical data. numformat : str {‘decimal’,’exp’}. Format for written data. sep : str. Single-character field seperator. Usually a tab, space, comma,; or semicolo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:193096,energy,energy,193096,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['energy'],['energy']
Energy Efficiency,"ars, with the given x and y labels; and title. Parameters:M : Matrix of Qobj. The matrix to visualize. xlabels : list of strings. list of x labels. ylabels : list of strings. list of y labels. title : string. title of the plot (optional). limits : list/array with two float numbers. The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers. The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None) :. Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. wigner_cmap(W, levels=1024, shift=0, invert=False)¶; A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters:W",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:80127,energy,energy,80127,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"as a; strict sub-class of Qobj.; """"""; vals, vecs = eig(q_oper.data.todense()); vecs = [array(_) for _ in zip(*vecs)]; return [Qobj(inpt=sqrt(val)*vec2mat(vec)) for val, vec in zip(vals, vecs)]. def kraus_to_choi(kraus_list):; """"""; Takes a list of Kraus operators and returns the Choi matrix for the channel; represented by the Kraus operators in `kraus_list`; """"""; kraus_mat_list = list(map(lambda x: matrix(x.data.todense()), kraus_list)); op_len = len(kraus_mat_list[0]); op_rng = range(op_len); choi_blocks = array([[sum([op[:, c_ix] * array([op.H[r_ix, :]]); for op in kraus_mat_list]); for r_ix in op_rng]; for c_ix in op_rng]); return Qobj(inpt=hstack(hstack(choi_blocks)),; dims=[kraus_list[0].dims, kraus_list[0].dims], type='super',; superrep='choi'). def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.product(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). def chi_to_choi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html:8930,power,power,8930,docs/4.1/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html,5,['power'],['power']
Energy Efficiency,"ase class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters. dataarray_likeData for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecslistList of arrays that spans the space for each coordinate. xlabelslistList of labels for each coordinate. marginal(self, dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; marginal distribution. Returns. dDistributionsA new instances of Distribution that describes the marginal; distribution. project(self, dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; projected distribution. Returns. dDistributionsA new instances of Distribution that describes the projection. visualize(self, fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. axmatplotlib Axes instanceIf given, render the visualization using this axis instance. figsizetupleSize of the new Figure instance, if one needs to be created. colorbar: BoolWhether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instanceIf given, use this colormap for 2D visualizations. stylestringType of visualization: ‘colormap’ (default) or ‘surface’. Returns. fig",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:59693,reduce,reduced-dimensionality,59693,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['reduce'],['reduced-dimensionality']
Energy Efficiency,"ask(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. task_vec: array / list; The list or array of values for which the task function is to be; evaluated. args: list / dictionary; The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:; result : list; The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. values: array /",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:213860,schedul,scheduled,213860,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['schedul'],['scheduled']
Energy Efficiency,"ask_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:253094,schedul,scheduling,253094,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['schedul'],['scheduling']
Energy Efficiency,"ask_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:212788,schedul,scheduling,212788,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['schedul'],['scheduling']
Energy Efficiency,"ask_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function. The function that is to be called for each value in task_vec. values: array / list. The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary. The optional additional argument to the task function. task_kwargs: list / dictionary. The optional additional keyword argument to the task function. client: IPython.parallel.Client. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False. Display a HTML-based progress bar during the execution of the parfor; loop. Returns:result : list. The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string. Return an ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:200380,schedul,scheduling,200380,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['schedul'],['scheduling']
Energy Efficiency,"ast step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13507,schedul,schedule,13507,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,4,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"ast step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:13473,schedul,schedule,13473,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,4,['schedul'],"['schedule', 'scheduling']"
Energy Efficiency,"at are acted on.; dims : list, optional; A list of integer for the dimension of each composite system.; E.g ``[2, 2, 2, 2, 2]`` for 5 qubits system. If None, qubits system; will be the default option.; cyclic_permutation : boolean, optional; Expand for all cyclic permutation of the targets.; E.g. if ``N=3`` and `oper` is a 2-qubit operator,; the result will be a list of three operators,; each acting on qubits 0 and 1, 1 and 2, 2 and 0. Returns; -------; expanded_oper : :class:`qutip.Qobj`; The expanded qubits operator acting on a system with N qubits. Notes; -----; This is equivalent to gate_expand_1toN, gate_expand_2toN,; gate_expand_3toN in ``qutip.qip.gate.py``, but works for any dimension.; """"""; if dims is None:; dims = [2] * N; targets = _targets_to_list(targets, oper=oper, N=N); _check_qubits_oper(oper, dims=dims, targets=targets). # Call expand_operator for all cyclic permutation of the targets.; if cyclic_permutation:; oper_list = []; for i in range(N):; new_targets = np.mod(np.array(targets)+i, N); oper_list.append(; expand_operator(oper, N=N, targets=new_targets, dims=dims)); return oper_list. # Generate the correct order for qubits permutation,; # eg. if N = 5, targets = [3,0], the order is [1,2,3,0,4].; # If the operator is cnot,; # this order means that the 3rd qubit controls the 0th qubit.; new_order = [0] * N; for i, t in enumerate(targets):; new_order[t] = i; # allocate the rest qutbits (not targets) to the empty; # position in new_order; rest_pos = [q for q in list(range(N)) if q not in targets]; rest_qubits = list(range(len(targets), N)); for i, ind in enumerate(rest_pos):; new_order[ind] = rest_qubits[i]; id_list = [identity(dims[i]) for i in rest_pos]; return tensor([oper] + id_list).permute(new_order). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html:30969,allocate,allocate,30969,docs/4.5/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html,1,['allocate'],['allocate']
Energy Efficiency,"at elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the function qutip.mesolve is used for both:; the evolution according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The qutip.mesolve; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large systems) than using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation are",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:11095,energy,energy,11095,docs/4.7/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html,2,['energy'],['energy']
Energy Efficiency,"at elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the same function (qutip.mesolve) is used for; evolution both according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The qutip.mesolve; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large systems) than using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html:11343,energy,energy,11343,docs/4.2/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html,10,['energy'],['energy']
Energy Efficiency,"at elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (5) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (5) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the same function (qutip.mesolve) is used for; evolution both according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The qutip.mesolve; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large systems) than using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-master.html:11436,energy,energy,11436,docs/4.5/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-master.html,1,['energy'],['energy']
Energy Efficiency,"at is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:90586,reduce,reduce,90586,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,6,['reduce'],['reduce']
Energy Efficiency,"at_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction. Examples; --------; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; ``[gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]``; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles.; """"""; circuit = deepcopy(circuit); if repeat_num > 0:; random_shuffle = True; result = [0]; max_length = 4294967296; for i in range(repeat_num):; gate_cycle_indices = self.schedule(; circuit, gates_schedule=gates_schedule,; return_cycles_list=return_cycles_list,; random_shuffle=random_shuffle, repeat_num=0); current_length = max(gate_cycle_indices); if current_length < max_length:; result = gate_cycle_indices; max_length = current_length; return result. if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit. # Generate the quantum operations dependency graph.; instructions_graph = InstructionsGraph(gates); instructions_graph.generate_dependency_graph(; commuting=self.commutation_rules); if self.method == ""ALAP"":; instructions_graph.reverse_graph(). # Schedule without hardware constraints, then; # use this cycles_list to compute the distance",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:17092,reduce,reduce,17092,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['reduce'],['reduce']
Energy Efficiency,"ate using the truncated number operator num(N). This; is the method that should be used in computations. The; ‘analytic’ method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N (int) – Hilbert space dimensionality; dims (list) – Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:zero_ket – Zero ket on given Hilbert space. Return type:qobj. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax (int) – Maximum charge state to consider.; Nmin (int (default = -Nmax)) – Lowest charge state to consider.; frac (float (default = 1)) – Specify fractional charge if needed. Returns:C – Charge operator over [Nmin,Nmax]. Return type:Qobj. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:N (int) – Dimension of Hilbert space. Returns:; oper (qobj) – Qobj for raising operator.; offset (int (default 0)) – The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destruction (lowering) operator. Parameters:; N (int) – D",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:18698,charge,charge,18698,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['charge'],['charge']
Energy Efficiency,"ate(tlist):; psi_t = floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args); p_ex[n] = expect(num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = mesolve(H, psi0, tlist, [], [num(2)], args).expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'ro', tlist, 1-real(p_ex), 'bo'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 10 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = floquet_mo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-floquet.html:13350,efficient,efficiently,13350,docs/4.4/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-floquet.html,1,['efficient'],['efficiently']
Energy Efficiency,"ate.steadystate, and letting the function automatically build the Liouvillian for the system. Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'GMRES' and 'LGMRES' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-steady.html:4885,reduce,reduced,4885,docs/3.0.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html,2,['reduce'],['reduced']
Energy Efficiency,"ate.steadystate, and letting the function automatically build the Liouvillian for the system. Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To ove",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-steady.html:5280,reduce,reduced,5280,docs/3.1.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html,1,['reduce'],['reduced']
Energy Efficiency,"ates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:14757,schedul,schedule,14757,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['schedule']
Energy Efficiency,"ators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However; Attributes. num_ctrls. dyn_gen. prop. prop_grad. fwd_evo. onwd_evo. onto_evo. dumping. log_level; (integer) level of messaging output from the logger. Options are attributes of qutip.logging_utils, in decreasing levels of messaging, are: DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL Anything WARN or above is effectively ‘quiet’ execution, assuming everything runs as expected. The default NOTSET implies that the level will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value Note: attributes are created if they do not exist already, and are overwritten if they do. stats; (Stats) Attributes of which give performance stats for the optimisation set to None to reduce overhead of calculating stats. Note it is (usually) shared with the Optimizer object. tslot_computer; (TimeslotComputer (subclass instance)) Used to manage when the timeslot dynamics generators, propagators, gradients etc are updated. prop_computer; (PropagatorComputer (subclass instance)) Used to compute the propagators and their gradients. fid_computer; (FidelityComputer (subclass instance)) Used to computer the fidelity error and the fidelity error gradient. memory_optimization; (int) Level of memory optimisation. Setting to 0 (default) means that execution speed is prioritized over memory. Setting to 1 means that some memory prioritisation steps will be taken, for instance using Qobj (and hence sparse arrays) as the the internal operator data type, and not caching some operators Potentially further memory saving maybe made with memory_optimization > 1. The options are processed in _set_memory_optimizations, see this for more information. Individu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:73905,reduce,reduce,73905,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['reduce'],['reduce']
Energy Efficiency,"atrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). from qutip.qip.operations.gates import swap; a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/entropy.html:8804,power,power,8804,docs/4.5/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/entropy.html,1,['power'],['power']
Energy Efficiency,"aved under the attributes gate_compiler. Attributes. N: intThe number of the component systems. params: dictA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dictA map between the pulse label and its index in the pulse list. gate_compiler: dictThe Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. setup: string“linear” or “circular” for two sub-classes. global_phase: boolRecord of the global phase change and will be returned. compile(circuit, schedule_mode=None, args=None)¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:180355,schedul,schedule,180355,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['schedul'],['schedule']
Energy Efficiency,"ax.axes.w_yaxis.set_major_locator(plt.FixedLocator(ytics)); if ylabels:; nylabels = len(ylabels); if nylabels != len(ytics):; raise ValueError(f""got {nylabels} ylabels but needed {len(ytics)}""); ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else mi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/visualization.html:18302,energy,energy,18302,docs/4.6/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html,4,['energy'],['energy']
Energy Efficiency,"ax=None, threshold=None)[source]¶; Draw a histogram for the amplitudes of matrix M, using the argument; of each element for coloring the bars, with the given x and y labels; and title. Parameters. MMatrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, ax",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:168156,energy,energy,168156,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['energy'],['energy']
Energy Efficiency,"ax=None, threshold=None)[source]¶; Draw a histogram for the amplitudes of matrix M, using the argument; of each element for coloring the bars, with the given x and y labels; and title. Parameters. MMatrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, uni",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:130564,energy,energy,130564,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"ay; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a""",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/utilities.html:7454,energy,energy,7454,docs/4.6/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html,4,['energy'],['energy']
Energy Efficiency,"ay; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:7502,energy,energy,7502,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,7,['energy'],['energy']
Energy Efficiency,"ber of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. gate_compiler: dictThe Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dictArguments for individual compiling routines.; It adds more flexibility in customizing compiler. compile(circuit, schedule_mode=None, args=None)[source]¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. class CavityQEDCompiler(N, params, pulse_dict, global_phase=0.0)[source]¶; Decompose a QubitCircuit into; the pulse sequence for the processor. Parameters. N: intThe number of qubits in the system. params: dictA Python dictionary contains the name and the value of the parameters.; See DispersiveCavityQED.set_up_params for the definition. global_phase: float, optionalRecord of the global phase change and will be returned. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If g",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:175546,schedul,schedule,175546,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['schedul'],['schedule']
Energy Efficiency,"bit,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2), _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/qip/gates.html:18755,reduce,reduce,18755,docs/4.1/modules/qutip/qip/gates.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/qip/gates.html,6,['reduce'],['reduce']
Energy Efficiency,"c. def qubit_clifford_group(N=None, target=0):; """"""; Generates the Clifford group on a single qubit,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2),; _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if targ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:31116,reduce,reduce,31116,docs/4.6/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html,2,['reduce'],['reduce']
Energy Efficiency,"cc. def qubit_clifford_group(N=None, target=0):; """"""; Generates the Clifford group on a single qubit,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2), _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if targe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/qip/gates.html:18674,reduce,reduce,18674,docs/4.1/modules/qutip/qip/gates.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/qip/gates.html,6,['reduce'],['reduce']
Energy Efficiency,"ccept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*np.pi). # find the floquet modes for the time-dependent hamiltonian ; f_modes_0, f_energies = qutip.floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = qutip.floquet_modes_table(; f_modes_0, f_energies, np.linspace(0, T, 500 + 1), H, T, args,; ). # solve the floquet-markov master equation; output = qutip.fmmesolve(H, psi0, tlist, [qutip.sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = np.zeros(tlist.shape, dtype=np.complex128); for idx, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = qutip.floquet_states(f_modes_t, f_energies, t); p_ex[idx] = qutip.expect(qutip.num(2), output.states[idx].transform(f_states_t, True)). # For reference: calculate the same thing with mesolve; output = qutip.mesolve(H, psi0, tlist,; [np.sqrt(gamma1) * qutip.sigmax()], [qutip.num(2)],; args); p_ex_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:18674,power,power,18674,docs/4.7/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html,2,['power'],['power']
Energy Efficiency,"ccept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*np.pi). # find the floquet modes for the time-dependent hamiltonian ; f_modes_0, f_energies = qutip.floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = qutip.floquet_modes_table(; f_modes_0, f_energies, np.linspace(0, T, 500 + 1), H, T, args,; ). # solve the floquet-markov master equation; output = qutip.fmmesolve(H, psi0, tlist, [qutip.sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = np.zeros(tlist.shape, dtype=np.complex128); for idx, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_t, t, T); p_ex[idx] = qutip.expect(qutip.num(2), output.states[idx].transform(f_modes_t, True)). # For reference: calculate the same thing with mesolve; output = qutip.mesolve(H, psi0, tlist,; [np.sqrt(gamma1) * qutip.sigmax()], [qutip.num(2)],; args); p_ex_ref = output.expect[0]. # plot the results; pyplot.plot(tlist,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:17216,power,power,17216,docs/4.6/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html,2,['power'],['power']
Energy Efficiency,"ce condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. methodstr, default = ‘iterative’Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_specstr, optional, default=’COLAMD’Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factorfloat, optional, default = 100Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, optional, default = 1e-4Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optional, default = NoneSets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, optional, default = ‘smilu_2’Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, _safe_mode=True, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:108577,reduce,reduced,108577,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['reduce'],['reduced']
Energy Efficiency,"ce condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. methodstr, default = ‘iterative’Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_specstr, optional, default=’COLAMD’Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factorfloat, optional, default = 100Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, optional, default = 1e-4Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optional, default = NoneSets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, optional, default = ‘smilu_2’Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:134113,reduce,reduced,134113,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['reduce'],['reduced']
Energy Efficiency,"ce(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of correspond",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html:5346,reduce,reduced,5346,docs/4.1/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html,5,['reduce'],['reduced']
Energy Efficiency,"ce(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; r""""""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of correspon",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:5375,reduce,reduced,5375,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html,4,['reduce'],['reduced']
Energy Efficiency,"ce(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of correspondi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/nonmarkov/memorycascade.html:5342,reduce,reduced,5342,docs/4.4/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/nonmarkov/memorycascade.html,1,['reduce'],['reduced']
Energy Efficiency,"cense), and this License will continue; in full force and effect unless terminated as stated above. Miscellaneous. Each time You Distribute or Publicly Perform the Work or a Collection,; the Licensor offers to the recipient a license to the Work on the same; terms and conditions as the license granted to You under this License.; Each time You Distribute or Publicly Perform an Adaptation, Licensor; offers to the recipient a license to the original Work on the same terms; and conditions as the license granted to You under this License.; If any provision of this License is invalid or unenforceable under; applicable law, it shall not affect the validity or enforceability of the; remainder of the terms of this License, and without further action by the; parties to this agreement, such provision shall be reformed to the; minimum extent necessary to make such provision valid and enforceable.; No term or provision of this License shall be deemed waived and no breach; consented to unless such waiver or consent shall be in writing and signed; by the party to be charged with such waiver or consent.; This License constitutes the entire agreement between the parties with; respect to the Work licensed here. There are no understandings,; agreements or representations with respect to the Work not specified; here. Licensor shall not be bound by any additional provisions that may; appear in any communication from You. This License may not be modified; without the mutual written agreement of the Licensor and You.; The rights granted under, and the subject matter referenced, in this; License were drafted utilizing the terminology of the Berne Convention; for the Protection of Literary and Artistic Works (as amended on; September 28, 1979), the Rome Convention of 1961, the WIPO Copyright; Treaty of 1996, the WIPO Performances and Phonograms Treaty of 1996 and; the Universal Copyright Convention (as revised on July 24, 1971). These; rights and subject matter take effect in the relevant ju",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:16561,charge,charged,16561,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,2,['charge'],['charged']
Energy Efficiency,"ch bath will have a different chemical; potential \(\mu\) which we will label \(\mu_L\) and \(\mu_R\).; First we will do this using the built-in implementations of the bath expansions,; LorentzianBath and; LorentzianPadeBath.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own fermionic baths.; Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in example notebook 4b. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where \(\Gamma\) (gamma), \(W\) and \(T\) are the parameters of; an Lorentzian bath, \(\mu_L\) (mu_L) and \(\mu_R\) (mu_R) are; the chemical potentials of the left and right baths, and Q is the coupling; operator between the system and the baths.; We may the pass these parameters to either LorentzianBath or; LorentzianPadeBath to construct an expansion of the bath correlations:; from qutip.nonmarkov.heom import LorentzianBath; from qutip.nonmarkov.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, ta",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/fermionic.html:2989,energy,energy,2989,docs/4.7/guide/heom/fermionic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html,2,['energy'],['energy']
Energy Efficiency,"ch instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:184915,schedul,schedule,184915,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['schedul'],['schedule']
Energy Efficiency,"charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting dynamics.oper_dtype = <type>; Note this can be done by passing dyn_params={'oper_dtype':<type>} in any of the pulseoptim functions.; Some other properties and methods were renamed at the same time. A full list is given here. All modules; - function: set_log_level -> property: log_level; dynamics functions. _init_lists now _init_evo; get_num_ctrls now property: num_ctrls; get_owd_evo_target now property: onto_evo_target; combine_dyn_gen now _combine_dyn_gen (no longer returns a value); get_dyn_gen now _get_phased_dyn_gen; get_ctrl_den_gen now _get_phased_ctrl_dyn_gen; ensure_decomp_curr now _ensure_decomp_curr; spectral_decomp now _spectral_decomp. dynamics properties. evo_init2t now _fwd_evo (fwd_evo as Qobj); evo_t2end now _onwd_evo (onwd_evo as Qobj); evo_t2targ now _onto_evo (onto_evo as ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/changelog.html:10135,efficient,efficient,10135,docs/4.4/changelog.html,https://qutip.org,https://qutip.org/docs/4.4/changelog.html,4,['efficient'],['efficient']
Energy Efficiency,"charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more efficient to set the internal data type to Qobj.; The internal operator data will be chosen automatically based on the size and sparsity of the dynamics generator. It can be forced by setting dynamics.oper_dtype = <type>; Note this can be done by passing dyn_params={'oper_dtype':<type>} in any of the pulseoptim functions.; Some other properties and methods were renamed at the same time. A full list is given here. All modules; - function: set_log_level -> property: log_level; dynamics functions; _init_lists now _init_evo; get_num_ctrls now property: num_ctrls; get_owd_evo_target now property: onto_evo_target; combine_dyn_gen now _combine_dyn_gen (no longer returns a value); get_dyn_gen now _get_phased_dyn_gen; get_ctrl_den_gen now _get_phased_ctrl_dyn_gen; ensure_decomp_curr now _ensure_decomp_curr; spectral_decomp now _spectral_decomp. dynamics properties; evo_init2t now _fwd_evo (fwd_evo as Qobj); evo_t2end now _onwd_evo (onwd_evo as Qobj); evo_t2targ now _onto_evo (onto_evo as ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:4659,efficient,efficient,4659,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,4,['efficient'],['efficient']
Energy Efficiency,"ching': True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None}; return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:5951,power,power,5951,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,8,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"cific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; import numbers; from collections.abc import Iterable; from itertools import product, chain; from functools import partial, reduce; from operator import mul. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.operators import identity, qeye, sigmax, sigmay, sigmaz; from qutip.tensor import tensor; from qutip.states import fock_dm. __all__ = ['rx', 'ry', 'rz', 'sqrtnot', 'snot', 'phasegate', 'qrot',; 'x_gate', 'y_gate', 'z_gate', 'cy_gate', 'cz_gate', 's_gate',; 't_gate', 'qasmu_gate', 'cs_gate', 'ct_gate', 'cphase', 'cnot',; 'csign', 'berkeley', 'swapalpha', 'swap', 'iswap', 'sqrtswap',; 'sqrtiswap', 'fredkin', 'molmer_sorensen',; 'toffoli', 'rotation', 'controlled_gate',; 'globalphase', 'hadamard_transform', 'gate_sequence_product',; 'gate_expand_1toN', 'gate_expand_2toN', 'gate_expand_3toN',; 'qubit_clifford_group', 'expand_operator']. #; # Single Qubit Gates; #. def x_gate(N=None, target=0):; """"""Pauli-X gate or sigmax operator. Returns; -------; result : :class:`qutip.Qobj`; Quantum object for operator describing; a single-qubit rotation thr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:2243,reduce,reduce,2243,docs/4.6/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html,2,['reduce'],['reduce']
Energy Efficiency,"ckend. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; TensorFlow Data Backend. TensorFlow Data Backend¶. Contents. Why a TensorFlow backend?; Challenges. Expected outcomes; Skills; Difficulty; Mentors; References. Note; This project was completed as part of GSoC 2021 3. QuTiP’s data layer provides the mathematical operations needed to work with; quantum states and operators, i.e. Qobj, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:1614,efficient,efficiently,1614,docs/4.7/development/ideas/tensorflow-data-backend.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html,2,['efficient'],['efficiently']
Energy Efficiency,"cks(rho)[source]¶; Create the list of blocks for block-diagonal density matrix in the Dicke basis. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. square_blocks: list of np.arrayGive back the blocks list. dicke_blocks_full(rho)[source]¶; Give the full (2^N-dimensional) list of blocks for a Dicke-basis matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. full_blockslistThe list of blocks expanded in the 2^N space for N qubits. dicke_function_trace(f, rho)[source]¶; Calculate the trace of a function on a Dicke density matrix.; :param f: A Taylor-expandable function of rho.; :type f: function; :param rho: A density matrix in the Dicke basis.; :type rho: qutip.Qobj. Returns. resfloatTrace of a nonlinear function on rho. energy_degeneracy(N, m)[source]¶; Calculate the number of Dicke states with same energy.; The use of the Decimals class allows to explore N > 1000,; unlike the built-in function scipy.special.binom. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns. degeneracy: intThe energy degeneracy. entropy_vn_dicke(rho)[source]¶; Von Neumann Entropy of a Dicke-basis density matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. entropy_dm: floatEntropy. Use degeneracy to multiply each block. excited(N, basis='dicke')[source]¶; Generate the density matrix for the excited state.; This state is given by (N/2, N/2) in the default Dicke basis. If the; argument basis is “uncoupled” then it generates the state in a; 2**N dim Hilbert space. Parameters. N: intThe number of two-level systems. basis: strThe basis to use. Either “dicke” or ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:151745,energy,energy,151745,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['energy'],['energy']
Energy Efficiency,"client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """""". if show_progressbar:; progress_bar = HTMLProgressBar(); else:; progress_bar = None. return parallel_map(task, task_vec, task_args=args,; client=client, view=view, progress_bar=progress_bar,; show_scheduling=show_scheduling). [docs]def parallel_map(task, values, task_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html:7941,schedul,scheduling,7941,docs/4.2/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html,11,['schedul'],['scheduling']
Energy Efficiency,"coefficient_matrix(self):; """"""Build coefficient matrix for ODE for a diagonal problem. Returns; -------; M: ndarray; The matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis.; """"""; diagonal_system = Pim(; N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=self.collective_emission,; collective_dephasing=self.collective_dephasing,; collective_pumping=self.collective_pumping,; ); coef_matrix = diagonal_system.coefficient_matrix(); return coef_matrix. # Utility functions for properties of the Dicke space; [docs]def energy_degeneracy(N, m):; """"""Calculate the number of Dicke states with same energy. The use of the `Decimals` class allows to explore N > 1000,; unlike the built-in function `scipy.special.binom`. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""; numerator = Decimal(factorial(N)); d1 = Decimal(factorial(N / 2 + m)); d2 = Decimal(factorial(N / 2 - m)); degeneracy = numerator / (d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; """"""Calculate the degeneracy of the Dicke state. Each state :math:`|j, m\\rangle` includes D(N,j) irreducible; representations :math:`|j, m, \\alpha\\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2 * j + 1); denominator_1 = Decimal(factorial(N / 2 + j + 1)); denominator_2 = Decimal(factorial(N / 2 - j)); degeneracy = numerator / (denominator_1 * denominator_2); degeneracy = int(np.round(float(degenerac",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/piqs.html:16350,energy,energy,16350,docs/4.5/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/piqs.html,1,['energy'],['energy']
Energy Efficiency,"coefficient_matrix(self):; """"""Build coefficient matrix for ODE for a diagonal problem. Returns; -------; M: ndarray; The matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis.; """"""; diagonal_system = Pim(; N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=self.collective_emission,; collective_dephasing=self.collective_dephasing,; collective_pumping=self.collective_pumping,; ); coef_matrix = diagonal_system.coefficient_matrix(); return coef_matrix. # Utility functions for properties of the Dicke space; [docs]def energy_degeneracy(N, m):; """"""Calculate the number of Dicke states with same energy. The use of the `Decimals` class allows to explore N > 1000,; unlike the built-in function `scipy.special.binom`. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""; numerator = Decimal(factorial(N)); d1 = Decimal(factorial(_ensure_int(N / 2 + m))); d2 = Decimal(factorial(_ensure_int(N / 2 - m))); degeneracy = numerator / (d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; r""""""Calculate the degeneracy of the Dicke state. Each state :math:`\lvert j, m\rangle` includes D(N,j) irreducible; representations :math:`\lvert j, m, \alpha\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2 * j + 1); denominator_1 = Decimal(factorial(_ensure_int(N / 2 + j + 1))); denominator_2 = Decimal(factorial(_ensure_int(N / 2 - j))); degeneracy = numerator / (denominator",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/piqs.html:16472,energy,energy,16472,docs/4.6/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html,4,['energy'],['energy']
Energy Efficiency,"coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis.; """"""; diagonal_system = Pim(; N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=self.collective_emission,; collective_dephasing=self.collective_dephasing,; collective_pumping=self.collective_pumping,; ); coef_matrix = diagonal_system.coefficient_matrix(); return coef_matrix. # Utility functions for properties of the Dicke space; [docs]def energy_degeneracy(N, m):; """"""Calculate the number of Dicke states with same energy. The use of the `Decimals` class allows to explore N > 1000,; unlike the built-in function `scipy.special.binom`. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""; numerator = Decimal(factorial(N)); d1 = Decimal(factorial(N / 2 + m)); d2 = Decimal(factorial(N / 2 - m)); degeneracy = numerator / (d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; """"""Calculate the degeneracy of the Dicke state. Each state :math:`|j, m\\rangle` includes D(N,j) irreducible; representations :math:`|j, m, \\alpha\\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2 * j + 1); denominator_1 = Decimal(factorial(N / 2 + j + 1)); denominator_2 = Decimal(factorial(N / 2 - j)); degeneracy = numerator / (denominator_1 * denominator_2); degeneracy = int(np.round(float(degeneracy))); return degeneracy. [docs]def m_degeneracy(N, m):; """"""Calculate the number of Dicke states :math:`|j, m\\rangle` with; same energy.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/piqs.html:16397,energy,energy,16397,docs/4.5/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/piqs.html,1,['energy'],['energy']
Energy Efficiency,"col_cell] = 1; op_H = np.kron(T, op); dim_op = [self.lattice_tensor_config, self.lattice_tensor_config]; return Qobj(op_H, dims=dim_op). [docs] def plot_dispersion(self):; """"""; Plots the dispersion relationship for the lattice with the specified; number of unit cells. The dispersion of the infinte crystal is also; plotted if num_cell is smaller than MAXc.; """"""; MAXc = 20 # Cell numbers above which we do not plot the infinite; # crystal dispersion; if self.period_bnd_cond_x == 0:; raise Exception(""The lattice is not periodic.""). if self.num_cell <= MAXc:; (kxA, val_ks) = self.get_dispersion(101); (knxA, val_kns) = self.get_dispersion(); fig, ax = plt.subplots(); if self.num_cell <= MAXc:; for g in range(self._length_of_unit_cell):; ax.plot(kxA/np.pi, val_ks[g, :]). for g in range(self._length_of_unit_cell):; if self.num_cell % 2 == 0:; ax.plot(np.append(knxA, [np.pi])/np.pi,; np.append(val_kns[g, :], val_kns[g, 0]), 'ro'); else:; ax.plot(knxA/np.pi, val_kns[g, :], 'ro'); ax.set_ylabel('Energy'); ax.set_xlabel(r'$k_x(\pi/a)$'); plt.show(fig); fig.savefig('./Dispersion.pdf'). [docs] def get_dispersion(self, knpoints=0):; """"""; Returns dispersion relationship for the lattice with the specified; number of unit cells with a k array and a band energy array. Returns; -------; knxa : np.array; knxA[j][0] is the jth good Quantum number k. val_kns : np.array; val_kns[j][:] is the array of band energies of the jth band good at; all the good Quantum numbers of k.; """"""; # The _k_space_calculations() function is not used for get_dispersion; # because we calculate the infinite crystal dispersion in; # plot_dispersion using this coode and we do not want to calculate; # all the eigen-values, eigenvectors of the bulk Hamiltonian for too; # many points, as is done in the _k_space_calculations() function.; if self.period_bnd_cond_x == 0:; raise Exception(""The lattice is not periodic.""); if knpoints == 0:; knpoints = self.num_cell. a = 1 # The unit cell length is always considered 1; kn_st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/lattice.html:24455,Energy,Energy,24455,docs/4.6/modules/qutip/lattice.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/lattice.html,2,['Energy'],['Energy']
Energy Efficiency,"complete characterisation of the STIRAP transfer"", ; ChemPhysChem (2016). 190. Moran, ""Quintuple: a Python 5-qubit quantum computer simulator to facilitate cloud quantum computing"", ; arXiv:1606.09225. 189. Falloon et al., ""QSWalk: A Mathematica package for quantum stochastic walks on arbitrary graphs"", ; Comp. Phys. Commun. 217, 162 (2017). 188. Lammers et al., ""Open-system many-body dynamics through interferometric measurements and feedback"", ; Phys. Rev. A 94, 052120 (2016). 187. Li et al., ""Hybrid Quantum Device with Nitrogen-Vacancy Centers in Diamond Coupled to Carbon Nanotubes"", ; Phys. Rev. Lett. 117, 015502 (2016). 186. Grimm et al., ""Optomechanical self-oscillations in an anharmonic potential: engineering a nonclassical steady state"", ; J. Opt. 18, 094004 (2016). 185. Puri et al., ""Engineering the quantum states of light in a Kerr-nonlinear resonator by two-photon driving"", ; npj Quantum Information 3, 18 (2017). 184. Rossatto et al., ""Relaxation time for monitoring the quantumness of an intense cavity field"", ; Phys. Rev. A 94, 033819 (2016). 183. Shackerley-Bennett et al., ""The reachable set of single-mode quadratic Hamiltonians"", ; J. Phys. A: Math. Theor. 50, 155203 (2017). 182. Blumoff et al., ""Implementing and Characterizing Precise Multiqubit Measurements"", ; Phys. Rev. X 6, 031041 (2016). 181. Li et al., ""Entangling a single NV centre with a superconducting qubit via parametric couplings between photons and phonons in a hybrid system"", ; Journal of Modern Optics (2016). 180. Straubel et al., ""Entangled light from bimodal optical nanoantennas"", ; Phys. Rev. B 95, 085421 (2017). 179. Vool et al., ""Continuous Quantum Nondemolition Measurement of the Transverse Component of a Qubit"", ; Phys. Rev. Lett. 117, 133601 (2016). 178. Granade et al., ""Practical adaptive quantum tomography"", ; New J. Phys. 19, 113017 (2017). 177. Plankensteiner et al., ""Laser noise imposed limitations of ensemble quantum metrology"", ; J. Phys. B: At. Mol. Opt. Phys. 49, 245501 ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:24968,monitor,monitoring,24968,users.html,https://qutip.org,https://qutip.org/users.html,1,['monitor'],['monitoring']
Energy Efficiency,"cos', 'cosh','exp', 'imag', 'log', 'pow', 'proj, 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the numpy math library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. The available functions can be found using; In [1]: import numpy as np. In [2]: np.array(dir(np.math)[6:]); Out[2]: ; array(['asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign',; 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1',; 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma',; 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10',; 'log1p', 'modf', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh', 'trunc'], ; dtype='|S9'). Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:5127,efficient,efficient,5127,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['efficient'],['efficient']
Energy Efficiency,"coupling; operator). See combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. classmethod combine(exponents, rtol=1e-05, atol=1e-07)[source]¶; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present.; Exponents with the same frequency are only combined if they share the; same coupling operator .Q.; Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns. list of BathExponentThe new reduced list of exponents. class DrudeLorentzBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. terminator()[source]¶; Return the Matsubara terminator for the bath and the calculated; approximation discrepancy. Returns. delta: floatThe approximation discrepancy. That is, the di",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:54125,reduce,reduced,54125,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['reduce'],['reduced']
Energy Efficiency,"ction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:185369,schedul,scheduler,185369,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,6,"['Schedul', 'schedul']","['Scheduler', 'scheduler']"
Energy Efficiency,"ctrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslist of qutip.qobjlist of collapse operators. a_opqutip.qobjoperator A. b_opqutip.qobjoperator B. use_pinvboolIf True use numpy’s pinv method, otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters. tlistarray_likelist/array of times \(t\) which the correlation function is given. yarray_likelist/array of correlations corresponding to time delays \(t\). inverse: booleanboolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns. w, StupleReturns an array of angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object at 0x1a2041a358>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:116174,power,power,116174,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"ctrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslist of qutip.qobjlist of collapse operators. a_opqutip.qobjoperator A. b_opqutip.qobjoperator B. use_pinvboolIf True use numpy’s pinv method, otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters. tlistarray_likelist/array of times \(t\) which the correlation function is given. yarray_likelist/array of correlations corresponding to time delays \(t\). inverse: booleanboolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns. w, StupleReturns an array of angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624eaa58>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:98219,power,power,98219,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"culates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~qutip.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:5294,power,power,5294,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,4,['power'],['power']
Energy Efficiency,"cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:185734,schedul,scheduler,185734,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,10,"['Schedul', 'schedul']","['Scheduler', 'scheduler']"
Energy Efficiency,"d atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag(), np.sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = correlation_2op_1t(H, None, tlist, c_ops, a.dag(), a); wlist1, spec1 = spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default); wlist2 = np.linspace(0.25, 1.75, 200) * 2 * np.pi; spec2 = spectrum(H, wlist2, c_ops, a.dag(), a). # plot the spectra; fig, ax = plt.subplots(1, 1); ax.plot(wlist1 / (2 * np.pi), spec1, 'b', lw=2, label='eseries method'); ax.plot(wlist2 / (2 * np.pi), spec2, 'r--', lw=2, label='me+fft method'); ax.legend(); ax.set_xlabel('Frequency'); ax.set_ylabel('Power spectrum'); ax.set_title('Vacuum Rabi splitting'); ax.set_xlim(wlist2[0]/(2*np.pi), wlist2[-1]/(2*np.pi)); plt.show(). (Source code, png, hires.png, pdf). Non-steadystate correlation function¶; More generally, we can also calculate correlation functions of the kind \(\left<A(t_1+t_2)B(t_1)\right>\), i.e., the correlation function of a system that is not in its steadystate. In QuTiP, we can evoluate such correlation functions using the function qutip.correlation.correlation_2op_2t. The default behavior of this function is to return a matrix with the correlations as a function of the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-correlation.html:10596,power,power,10596,docs/4.2/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-correlation.html,6,['power'],['power']
Energy Efficiency,"d of the interval.; b : float; Upper bound of the interval.; coeffs : ndarray; Array of coeffcients defining cubic spline.; ; Notes; -----; This object can be called like a normal function with a; single or array of input points at which to evaluate; the interplating function.; ; Habermann & Kindermann, ""Multidimensional Spline Interpolation: ; Theory and Applications"", Comput Econ 30, 153 (2007). ; ; '''. def __init__(self, a, b, y, alpha=0, beta=0):; y = np.asarray(y); n = y.shape[0] - 1; h = (b - a)/n. coeff = np.zeros(n + 3, dtype=y.dtype); # Solutions to boundary coeffcients of spline; coeff[1] = 1/6. * (y[0] - (alpha * h**2)/6) #C2 in paper; coeff[n + 1] = 1/6. * (y[n] - (beta * h**2)/6) #cn+2 in paper. # Compressed tridiagonal matrix ; ab = np.ones((3, n - 1), dtype=float); ab[0,0] = 0 # Because top row is upper diag with one less elem; ab[1, :] = 4; ab[-1,-1] = 0 # Because bottom row is lower diag with one less elem. B = y[1:-1].copy() #grabs elements y[1] - > y[n-2] for reduced array; B[0] -= coeff[1]; B[-1] -= coeff[n + 1]. coeff[2:-2] = la.solve_banded((1, 1), ab, B, overwrite_ab=True,; overwrite_b=True, check_finite=False). coeff[0] = alpha * h**2/6. + 2 * coeff[1] - coeff[2]; coeff[-1] = beta * h**2/6. + 2 * coeff[-2] - coeff[-3]. self.a = a # Lower-bound of domain; self.b = b # Uppser-bound of domain; self.coeffs = coeff # Spline coefficients; self.is_complex = (y.dtype == complex) #Tells which dtype solver to use. def __call__(self, pnts, *args):; #If requesting a single return value; if isinstance(pnts, (int, float, complex)):; if self.is_complex:; return zinterp(pnts, self.a,; self.b, self.coeffs); else:; return interp(pnts, self.a, self.b, self.coeffs); #If requesting multiple return values from array_like; elif isinstance(pnts, (np.ndarray,list)):; pnts = np.asarray(pnts); if self.is_complex:; return arr_zinterp(pnts, self.a,; self.b, self.coeffs); else:; return arr_interp(pnts, self.a, self.b, self.coeffs). © Copyright 2011 and later, P.D. Nation",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/interpolate.html:3689,reduce,reduced,3689,docs/4.4/modules/qutip/interpolate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/interpolate.html,1,['reduce'],['reduced']
Energy Efficiency,"d using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 2.02s. Est. time left: 00:00:00:18; 20.0%. Run time: 3.02s. Est. time left: 00:00:00:12; 30.0%. Run time: 4.02s. Est. time left: 00:00:00:09; 40.0%. Run time: 5.03s. Est. time left: 00:00:00:07; 50.0%. Run time: 7.03s. Est. time left: 00:00:00:07; 60.0%. Run time: 8.03s. Est. time left: 00:00:00:05; 70.0%. Run time: 9.03s. Est. time left: 00:00:00:03; 80.0%. Run time: 10.03s. Est. time left: 00:00:00:02; 90.0%. Run time: 12.03s. Est. time left: 00:00:00:01; 100.0%. Run time: 13.04s. Est. time left: 00:00:00:00; Total run time: 13.07s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-parfor.html:7134,power,powerful,7134,docs/4.1/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-parfor.html,1,['power'],['powerful']
Energy Efficiency,"d using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 2.02s. Est. time left: 00:00:00:18; 20.0%. Run time: 3.03s. Est. time left: 00:00:00:12; 30.0%. Run time: 4.03s. Est. time left: 00:00:00:09; 40.0%. Run time: 5.03s. Est. time left: 00:00:00:07; 50.0%. Run time: 7.03s. Est. time left: 00:00:00:07; 60.0%. Run time: 8.03s. Est. time left: 00:00:00:05; 70.0%. Run time: 9.03s. Est. time left: 00:00:00:03; 80.0%. Run time: 10.04s. Est. time left: 00:00:00:02; 90.0%. Run time: 12.04s. Est. time left: 00:00:00:01; 100.0%. Run time: 13.04s. Est. time left: 00:00:00:00; Total run time: 13.06s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-parfor.html:7134,power,powerful,7134,docs/4.2/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-parfor.html,1,['power'],['powerful']
Energy Efficiency,"d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslist of qutip.qobjlist of collapse operators. a_opqutip.qobjoperator A. b_opqutip.qobjoperator B. use_pinvboolIf True use numpy’s pinv method, otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters. tlistarray_likelist/array of times \(t\) which the correlation function is given. yarray_likelist/array of correlations corresponding to time delays \(t\). inverse: booleanboolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns. w, StupleReturns an array of angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object at 0x1a2041a358>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver ch",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:116629,power,power,116629,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslist of qutip.qobjlist of collapse operators. a_opqutip.qobjoperator A. b_opqutip.qobjoperator B. use_pinvboolIf True use numpy’s pinv method, otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters. tlistarray_likelist/array of times \(t\) which the correlation function is given. yarray_likelist/array of correlations corresponding to time delays \(t\). inverse: booleanboolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns. w, StupleReturns an array of angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624eaa58>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:98674,power,power,98674,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"d_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; ``[gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]``; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles.; """"""; circuit = deepcopy(circuit); if repeat_num > 0:; random_shuffle = True; result = [0]; max_length = 4294967296; for i in range(repeat_num):; gate_cycle_indices = self.schedule(; circuit, gates_schedule=gates_schedule,; return_cycles_list=return_cycles_list,; random_shuffle=random_shuffle, repeat_num=0); current_length = max(gate_cycle_indices); if current_length < max_length:; result = gate_cycle_indices; max_length = current_length; return result. if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit. # Generate the quantum operations dependency graph.; instructions_graph = InstructionsGraph(gates); instructions_graph.generate_dependency_graph(; commuting=self.commutation_rules); if self.method == ""ALAP"":; instructions_graph.reverse_graph(). # Schedule without hardware constraints, then; # use this cycles_list to compute the distance.; cycles_list, _ = instructions_graph.find_topological_order(; priority=False, apply_constraint=None, random=random_shuffle); instructions_graph.compute_distance(cycles_list=cycles_list). # Schedule again with priority and hardware constraint.; cycles_list, constraint_dependency = \; instructions_graph.find_topological_order(; priority=True, apply_constraint=self.apply_constraint,; random=random_shuffle). # If we only need gates",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:17293,schedul,schedule,17293,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['schedule']
Energy Efficiency,"daries for the control amplitudes Can be a scalar value applied to all controls or a list of bounds for each control. bounds; (List of floats) Bounds for the parameters. If not set before the run_optimization call then the list is built automatically based on the amp_lbound and amp_ubound attributes. Setting this attribute directly allows specific bounds to be set for individual parameters. Note: Only some methods use bounds. dynamics; (Dynamics (subclass instance)) describes the dynamics of the (quantum) system to be control optimised (see Dynamics classes for details). config; (OptimConfig instance) various configuration options (see OptimConfig for details). termination_conditions; (TerminationCondition instance) attributes determine when the optimisation will end. pulse_generator; (PulseGen (subclass instance)) (can be) used to create initial pulses not used by the class, but set by pulseoptim.create_pulse_optimizer. stats; (Stats) attributes of which give performance stats for the optimisation set to None to reduce overhead of calculating stats. Note it is (usually) shared with the Dynamics instance. dump; (dump.OptimDump) Container for data dumped during the optimisation. Can be set by specifying the dumping level or set directly. Note this is mainly intended for user and a development debugging but could be used for status information during a long optimisation. dump_to_file; (bool) If set True then data will be dumped to file during the optimisation dumping will be set to SUMMARY during init_optim if dump_to_file is True and dumping not set. Default is False. dump_dir; (string) Basically a link to dump.dump_dir. Exists so that it can be set through optim_params. If dump is None then will return None or will set dumping to SUMMARY when setting a path. iter_summary; (OptimIterSummary) Summary of the most recent iteration. Note this is only set if dummping is on. apply_method_params(params=None)[source]¶; Loops through all the method_params; (either passed here",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:59662,reduce,reduce,59662,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['reduce'],['reduce']
Energy Efficiency,"degenerate blocks in the density matrix. Parameters. rhoqutip.QobjDensity matrix in the Dicke basis of qutip.piqs.jspin(N), for N spins. Returns. purityfloatThe purity of the quantum state.; It’s 1 for pure states, 0<=purity<1 for mixed states. entropy_vn_dicke(rho)[source]¶; Von Neumann Entropy of a Dicke-basis density matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. entropy_dm: floatEntropy. Use degeneracy to multiply each block. state_degeneracy(N, j)[source]¶; Calculate the degeneracy of the Dicke state.; Each state \(|j, m\rangle\) includes D(N,j) irreducible; representations \(|j, m, \alpha\rangle\).; Uses Decimals to calculate higher numerator and denominators numbers. Parameters. N: intThe number of two-level systems. j: floatTotal spin eigenvalue (cooperativity). Returns. degeneracy: intThe state degeneracy. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(|j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. energy_degeneracy(N, m)[source]¶; Calculate the number of Dicke states with same energy.; The use of the Decimals class allows to explore N > 1000,; unlike the built-in function scipy.special.binom. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns. degeneracy: intThe energy degeneracy. ap(j, m)[source]¶; Calculate the coefficient ap by applying J_+ |j, m>.; The action of ap is given by:; \(J_{+}|j, m\rangle = A_{+}(j, m)|j, m+1\rangle\). Parameters. j, m: floatThe value for j and m in the dicke basis |j,m>. Returns. a_plus: floatThe value of \(a_{+}\). am(j, m)[source]¶; Calculate the operator am used later.; The action of ap is given by: J_{-}|j, m> = A_{-}(j",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:136895,energy,energy,136895,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"delity(x, x); Out[39]: 1.000000024796918. In [40]: tracedist(y, y); Out[40]: 0.0. We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\).; In [41]: tracedist(y, x); Out[41]: 0.9771565834831235. In [42]: sqrt(1 - fidelity(y, x) ** 2); Out[42]: 0.97715657031452496. For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; In [43]: 1 - fidelity(x, z) ** 2; Out[43]: 0.7782890495537043. In [44]: tracedist(x, z); Out[44]: 0.8559028328862588. Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; In [45]: spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; In [46]: vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.sigmaz, qutip.operators.sigmap, and qutip.operators.sigmam on these two-level states. For example, if vac corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the \(\left|1\right>\) state:; In [47]: vac; Out[47]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. In [48]: c = create(2). In [49]: c * vac; Out[49]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator qutip.operators.sigmap. Operating on the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-states.html:12028,energy,energy,12028,docs/3.0.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html,2,['energy'],['energy']
Energy Efficiency,"dency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over a minima. In practice it is difficult to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [3]. This limited memory and bounded ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:8307,efficient,efficient,8307,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['efficient'],['efficient']
Energy Efficiency,"dency to get stuck in local maxima. It is hard to determine whether one has found a global maximum or not - a local peak is likely not to be the highest mountain in the region. In quantum optimal control we can typically define an infidelity that has a lower bound of zero. We can then look to minimise the infidelity (from here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over a minima. In practice it is difficult to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:8256,efficient,efficient,8256,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,6,['efficient'],['efficient']
Energy Efficiency,"display_lattice(self)[source]¶; Produces a graphic portraying the lattice symbolically with a unit cell; marked in it. Returns. inter_TQobjThe coefficient of $psi_{i,N}^{dagger}psi_{0,i+1}$, i.e. the; coupling between the two boundary sites of the two unit cells i and; i+1. display_unit_cell(self, label_on=False)[source]¶; Produces a graphic displaying the unit cell features with labels on if; defined by user. Also returns a dict of Qobj’s corresponding to the; labeled elements on the display. Returns. HcelldictHcell[i][j] is the Hamiltonian segment for $H_{i,j}$ labeled on the; graphic. distribute_operator(self, op)[source]¶; A function that returns an operator matrix that applies op to all the; cells in the 1d lattice. Parameters; op (qutip.Qobj) – Qobj representing the operator to be applied at all cells. Returns. op_Hqutip.QobjQuantum object representing the operator with op applied at all; cells. get_dispersion(self, knpoints=0)[source]¶; Returns dispersion relationship for the lattice with the specified; number of unit cells with a k array and a band energy array. Returns. knxanp.arrayknxA[j][0] is the jth good Quantum number k. val_knsnp.arrayval_kns[j][:] is the array of band energies of the jth band good at; all the good Quantum numbers of k. k(self)[source]¶; Returns the crystal momentum operator. All degrees of freedom has the; cell number at their correspondig entry in the position operator. Returns. Qobj(ks)qutip.QobjThe crystal momentum operator in units of 1/a. L is the number; of unit cells, a is the length of a unit cell which is always taken; to be 1. operator_at_cells(self, op, cells)[source]¶; A function that returns an operator matrix that applies op to specific; cells specified in the cells list. Parameters. opqutip.QobjQobj representing the operator to be applied at certain cells. cells: list of intThe cells at which the operator op is to be applied. Returns. Qobj(op_H)QobjQuantum object representing the operator with op applied at; the specif",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:66173,energy,energy,66173,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['energy'],['energy']
Energy Efficiency,"duler includes two methods,; ""ASAP"", as soon as possible, and ""ALAP"", as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits. The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]; else:; return constraint_functions. [docs] def schedule(self, circuit, gates_schedule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `QubitCircuit`,; a list of `Gates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:13638,schedul,schedule,13638,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,6,"['Schedul', 'schedul']","['Schedule', 'schedule']"
Energy Efficiency,"dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more informatio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:84839,reduce,reduce,84839,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['reduce'],['reduce']
Energy Efficiency,"e = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. Notes; The ‘operator’ method (default) generates; the thermal state using the truncated number operator num(N). This; is the method that should be used in computations. The; ‘analytic’ method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:; N (int) – Hilbert space dimensionality; dims (list) – Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:zero_ket – Zero ket on given Hilbert space. Return type:qobj. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:; Nmax (int) – Maximum charge state to consider.; Nmin (int (default = -Nmax)) – Lowest charge state to consider.; frac (float (default = 1)) – Specify fractional charge if needed. Returns:C – Charge operator over [Nmin,Nmax]. Return type:Qobj. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:N (int) – Dimension of Hilbert space. Returns:; oper (qobj) – Qobj for raising operator.; offset (int (default 0)) – The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j];",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:18405,charge,charge,18405,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,3,['charge'],['charge']
Energy Efficiency,"e code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.topology; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/index.html:1349,schedul,scheduler,1349,docs/4.6/modules/index.html,https://qutip.org,https://qutip.org/docs/4.6/modules/index.html,2,['schedul'],['scheduler']
Energy Efficiency,"e contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A (qobj) – A Hamiltonian or Liouvillian operator.; c_op_list (list) – A list of collapse operators.; method (str {'direct', 'eigen', 'iterative-gmres',) – ; ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info (bool, optional, default = False) – Return a dictionary of solver-specific infomation about the; solution and how it was obtained.; sparse (bool, optional, default = True) – Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian.; use_wbm (bool, optional, default = False) – Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:101911,power,power,101911,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,2,['power'],['power']
Energy Efficiency,"e dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/metrics.html:14263,efficient,efficiently,14263,docs/4.6/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html,2,['efficient'],['efficiently']
Energy Efficiency,"e lab frame. Tfloat, optionalThe time period of driving. Necessary if floquet_basis is; False and the transformation should be made back to the lab frame. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. kmaxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). optionsqutip.solver.Optionsoptions for the ODE solver. Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None, options=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:100642,power,power,100642,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['power'],['power']
Energy Efficiency,"e of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit impo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:184268,schedul,schedule,184268,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['schedul'],['schedule']
Energy Efficiency,e qutip.metrics). B. basis() (in module qutip.states). (Lattice1d method). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.operations.gates). berry_curvature() (in module qutip.topology). Bloch (class in qutip.bloch). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bloch_wave_functions() (Lattice1d method). block_matrix() (in module qutip.piqs). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bulk_Hamiltonians() (Lattice1d method). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). CavityQEDCompiler (class in qutip.qip.compiler). cell_periodic_parts() (Lattice1d method). cell_structures() (in module qutip.lattice). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). chi_to_choi() (in module qutip.superop_reps). choi_to_chi() (in module qutip.superop_reps). choi_to_kraus() (in module qutip.superop_reps). choi_to_super() (in module qutip.superop_reps). circuit_to_qasm_str() (in module qutip.qip.qasm). CircuitResult (class in qutip.qip.circuit). CircuitSimulator (class in qutip.qip.circuit). CircularSpinChain (class in qutip.qip.device). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.operations.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (DispersiveCavityQED property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module quti,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/genindex.html:3318,charge,charge,3318,docs/4.6/genindex.html,https://qutip.org,https://qutip.org/docs/4.6/genindex.html,1,['charge'],['charge']
Energy Efficiency,"e solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-steady.html:5128,power,power,5128,docs/4.2/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-steady.html,10,['power'],['power']
Energy Efficiency,"e specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contai",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:44553,reduce,reduced,44553,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['reduce'],['reduced']
Energy Efficiency,"e without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; import numpy as np; from .instruction import Instruction; from .scheduler import Scheduler; from ..circuit import QubitCircuit, Gate. __all__ = ['GateCompiler']. [docs]class GateCompiler(object):; """"""; Base class. It compiles a :class:`.QubitCircuit` into; the pulse sequence for the processor. The core member function; `compile` calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters; ----------; N: int; The number of the component systems. params: dict, optional; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optional; A map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; ``(pulse_label, coeff)``, instead of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling rou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:2199,schedul,scheduler,2199,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,3,"['Schedul', 'schedul']","['Scheduler', 'scheduler']"
Energy Efficiency,"e(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing withou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:26956,power,power,26956,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['power'],['power']
Energy Efficiency,"e)). if self.cache_phased_dyn_gen is None:; if self.memory_optimization > 0:; self.cache_phased_dyn_gen = False; else:; self.cache_phased_dyn_gen = True; logger.info(""phased dynamics generator caching {}"".format(; self.cache_phased_dyn_gen)). if self.cache_prop_grad is None:; if self.memory_optimization > 0:; self.cache_prop_grad = False; else:; self.cache_prop_grad = True; logger.info(""propagator gradient caching {}"".format(; self.cache_prop_grad)). if self.cache_dyn_gen_eigenvectors_adj is None:; if self.memory_optimization > 0:; self.cache_dyn_gen_eigenvectors_adj = False; else:; self.cache_dyn_gen_eigenvectors_adj = True; logger.info(""eigenvector adjoint caching {}"".format(; self.cache_dyn_gen_eigenvectors_adj)). if self.sparse_eigen_decomp is None:; if self.memory_optimization > 1:; self.sparse_eigen_decomp = True; else:; self.sparse_eigen_decomp = False; logger.info(""use sparse eigen decomp {}"".format(; self.sparse_eigen_decomp)). def _choose_oper_dtype(self):; """"""; Attempt select most efficient internal operator data type; """""". if self.memory_optimization > 0:; self.oper_dtype = Qobj; else:; # Method taken from Qobj.expm(); # if method is not explicitly given, try to make a good choice; # between sparse and dense solvers by considering the size of the; # system and the number of non-zero elements.; if self.time_depend_drift:; dg = self.drift_dyn_gen[0]; else:; dg = self.drift_dyn_gen; if self.time_depend_ctrl_dyn_gen:; ctrls = self.ctrl_dyn_gen[0, :]; else:; ctrls = self.ctrl_dyn_gen; for c in ctrls:; dg = dg + c. N = dg.data.shape[0]; n = dg.data.nnz. if N ** 2 < 100 * n:; # large number of nonzero elements, revert to dense solver; self.oper_dtype = np.ndarray; elif N > 400:; # large system, and quite sparse -> qutips sparse method; self.oper_dtype = Qobj; else:; # small system, but quite sparse -> qutips sparse/dense method; self.oper_dtype = np.ndarray. return self.oper_dtype. def _init_evo(self):; """"""; Create the container lists / arrays for the:; dynamic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:22242,efficient,efficient,22242,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,6,['efficient'],['efficient']
Energy Efficiency,"e)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:; H : qutip.qobj; system Hamiltonian. rho0 / psi0 : qutip.qobj; initial density matrix or state vector (ket). tlist : list / array; list of times for \(t\). c_ops : list of qutip.qobj; list of collapse operators. e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float; The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary; dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns:; output : qutip.solver; An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:69933,energy,energy,69933,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"e, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. values: array / list; The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the task function. task_kwargs: list / dictionary; The optional additional keyword argument to the task function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns:; result : list; The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:; version_table: string; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:215252,schedul,scheduling,215252,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['schedul'],['scheduling']
Energy Efficiency,"e. In qutip.parallel.parallel_map, keyword arguments to the task function are specified using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 2.01s. Est. time left: 00:00:00:18; 20.0%. Run time: 3.01s. Est. time left: 00:00:00:12; 30.0%. Run time: 4.02s. Est. time left: 00:00:00:09; 40.0%. Run time: 5.02s. Est. time left: 00:00:00:07; 50.0%. Run time: 7.02s. Est. time left: 00:00:00:07; 60.0%. Run time: 8.02s. Est. time left: 00:00:00:05; 70.0%. Run time: 9.02s. Est. time left: 00:00:00:03; 80.0%. Run time: 10.02s. Est. time left: 00:00:00:02; 90.0%. Run time: 12.02s. Est. time left: 00:00:00:01; 100.0%. Run time: 13.02s. Est. time left: 00:00:00:00; Total run time: 13.07s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-parfor.html:7348,power,powerful,7348,docs/3.1.0/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-parfor.html,1,['power'],['powerful']
Energy Efficiency,"e: this spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters; ----------; H : :class:`qutip.qobj`; system Hamiltonian.; wlist : array_like; list of frequencies for :math:`\\omega`.; c_ops : list; list of collapse operators.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; solver : str; choice of solver (`es` for exponential series and; `pi` for psuedo-inverse).; use_pinv : bool; For use with the `pi` solver: if `True` use numpy's pinv method,; otherwise use a generic solver. Returns; -------; spectrum : array; An array with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(taulist, y):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; one-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]). N = len(taulist); dt = taulist[1] - taulist[0]. F = scipy.fftpack.fft(y). # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # select only indices for elements that corresponds; # to positive frequencies; indices = np.where(f > 0.0). return 2 * np.pi * f[indices], 2 * dt * np.real(F[indices]). # -----------------------------------------------------------------------------; # LEGACY API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/correlation.html:17621,power,power,17621,docs/4.0.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/correlation.html,2,['power'],['power']
Energy Efficiency,"e:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['total_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; if ss_args['return_info']:; return rhoss_list, ss_args['info']; else:; return rhoss_list; else:; rhoss = Qobj(vec2mat(ns[:, 0]), dims=L.dims[0]); return rhoss / rhoss.tr(). def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = prod(rhoss.shape); L = L.data.tocsc() - (1e-15) * sp.eye(n, n, format='csc'); L.sort_indices(); orig_nnz = L.nnz. # start with all ones as RHS; v = np.ones(n, dtype=complex). if ss_args['use_rcm']:; if settings.debug:; old_band = sp_bandwidth(L)[0]; logger.debug('Original bandwidth: %i' % old_band); perm = reverse_cuthill_mckee(L); rev_perm = np.argsort(perm); L = sp_permute(L, perm, perm, 'csc'); v = v[np.ix_(perm,)]; if settings.debug:; new_band = sp_bandwidth(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' %; round(old_band/new_band, 2)). _power_start = time.time();",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:22318,power,power,22318,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['power'],['power']
Energy Efficiency,"e; New in QuTiP 4.2. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:14927,efficient,efficient,14927,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,4,['efficient'],['efficient']
Energy Efficiency,"e; element). c2 : qutip.Qobj; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:; : :class:`qutip.Qobj`; time-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters:; t : float; current time. tau : float; time-delay. notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. ——-. : :class:`qutip.Qobj`; time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns:; : :class:`qutip.Qobj`; density matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes:; dynmaps : list of qutip.Qobj; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes : array_like; List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres : float; Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options : qutip.solver.Options; Generic solver options. Solver Options and Results¶. c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:31987,reduce,reduced,31987,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['reduce'],['reduced']
Energy Efficiency,"e; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). (png, hires.png, pdf). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t, args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian ; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = qutip.floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = np.zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:12629,efficient,efficiently,12629,docs/4.6/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html,2,['efficient'],['efficiently']
Energy Efficiency,"eV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/utilities.html:8193,energy,energy,8193,docs/4.6/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html,4,['energy'],['energy']
Energy Efficiency,"eV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:8241,energy,energy,8241,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,7,['energy'],['energy']
Energy Efficiency,"e]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distan",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:183009,schedul,scheduler,183009,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['schedul'],['scheduler']
Energy Efficiency,"e_args():; def_args = {'method': 'direct', 'sparse': True, 'use_rcm': False,; 'use_wbm': False, 'use_umfpack': False, 'weight': None,; 'use_precond': False, 'all_states': False,; 'M': None, 'x0': None, 'drop_tol': 1e-4, 'fill_factor': 100,; 'diag_pivot_thresh': None, 'maxiter': 1000, 'tol': 1e-9,; 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2', 'restart': 20,; 'return_info': False, 'info': {'perm': []}}. return def_args. [docs]def steadystate(A, c_op_list=[], **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:5539,power,power,5539,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['power'],['power']
Energy Efficiency,"eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. # -----------------------------------------------------------------------------; # Functions for calculating the Bloch-Redfield tensor for a time-independent; # system.; #; [docs]def bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=[], use_secular=True, sec_cutoff=0.1):; """"""; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system's coupling; to its environment. .. note::. This tensor generation requires a time-independent Hamiltonian. Parameters; ----------. H : :class:`qutip.qobj`; System Hamiltonian. a_ops : list of :class:`qutip.qobj`; List of system operators that couple to the environment. spectra_cb : list of callback functions; List of callback functions that evaluate the noise power spectrum; at a given frequency. c_ops : list of :class:`qutip.qobj`; List of system collapse operators. use_secular : bool; Flag (True of False) that indicates if the secular approximation should; be used.; ; sec_cutoff : float {0.1}; Threshold for secular approximation. Returns; -------. R, kets: :class:`qutip.Qobj`, list of :class:`qutip.Qobj`. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. """"""; ; if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops; ; # Sanity checks for input parameters; if not isinstance(H, Qobj):; raise TypeError(""H must be an instance of Qobj""). for a in a_ops:; if not isinstance(a[0], Qobj) or not a[0].isherm:; raise TypeError(""Operators in a_ops must be Hermitian Qobj.""). if c_ops is None:; c_ops = []. # use the eigenbasis; evals, ekets = H.eigen",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:11794,power,power,11794,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['power'],['power']
Energy Efficiency,"ecific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:; data : array_like; Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list; List of arrays that spans the space for each coordinate. xlabels : list; List of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:; d : Distributions; A new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns:; d : Distributions; A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,; ax : matplotlib Axes instance; If given, render the visualization using this axis instance.; figsize : tuple; Size of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style : string; Type of visualization: ‘colormap’ (d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:54903,reduce,reduced-dimensionality,54903,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['reduce'],['reduced-dimensionality']
Energy Efficiency,"ecified in wlist. Return type:array. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters:; H (qutip.qobj) – system Hamiltonian.; wlist (array_like) – list of frequencies for \(\omega\).; c_ops (list of qutip.qobj) – list of collapse operators.; a_op (qutip.qobj) – operator A.; b_op (qutip.qobj) – operator B.; use_pinv (bool) – If True use numpy’s pinv method, otherwise use a generic solver. Returns:spectrum – An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. Return type:array. spectrum_correlation_fft(taulist, y)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:; tlist (array_like) – list/array of times \(t\) which the correlation function is given.; y (array_like) – list/array of correlations corresponding to time delays \(t\). Returns:w, S – Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. Return type:tuple. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\ps",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:97453,power,power,97453,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"econditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-steady.html:7553,power,power,7553,docs/4.2/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-steady.html,10,['power'],['power']
Energy Efficiency,"econditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_umfpack; False, True; Use the umfpack solver rather than the default superLU. on SciPy 0.14+, this option requires installing the scikits.umfpack extension. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching alg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-steady.html:8153,power,power,8153,docs/3.1.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html,1,['power'],['power']
Energy Efficiency,"econditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_umfpack; False, True; Use the umfpack solver rather than the default superLU. on SciPy 0.14+, this option requires installing the scikits.umfpack extension. use_precond; True, False; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching alg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-steady.html:7686,power,power,7686,docs/3.0.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html,2,['power'],['power']
Energy Efficiency,"ectation values. optionsqutip.QdeoptionsOptions for the ODE solver. Returns. output: qutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object at 0x1a2035b7b8>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specif",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:78366,power,power,78366,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"ected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-control.html:18151,efficient,efficient,18151,docs/4.4/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-control.html,1,['efficient'],['efficient']
Energy Efficiency,"ectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters:H : qutip.qobj. system Hamiltonian. wlist : array_like. list of frequencies for \(\omega\). c_ops : list of qutip.qobj. list of collapse operators. a_op : qutip.qobj. operator A. b_op : qutip.qobj. operator B. use_pinv : bool. If True use numpy’s pinv method, otherwise use a generic solver. Returns:spectrum : array. An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(taulist, y)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:tlist : array_like. list/array of times \(t\) which the correlation function is given. y : array_like. list/array of correlations corresponding to time delays \(t\). Returns:w, S : tuple. Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj. Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:94692,power,power,94692,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"ecuted before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:12976,Schedul,Scheduler,12976,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,1,['Schedul'],['Scheduler']
Energy Efficiency,"ecuted before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:12942,Schedul,Scheduler,12942,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,1,['Schedul'],['Scheduler']
Energy Efficiency,"ed dimension check and confusing documentation in random ket (by Yariv Yanay).; Fixed Qobj isherm not working after using Qobj.permute (Thank llorz1207 for reporting).; Correlation functions call now properly handle multiple time dependant functions (Thank taw181 for reporting).; Removed mutable default values in mesolve/sesolve (by Michael Goerz).; Fixed simdiag bug (Thank Croydon-Brixton for reporting).; Better support of constant QobjEvo (by Boxi Li).; Fixed potential cyclic import in the control module (by Alexander Pitchford). Version 4.4.0 (July 03, 2019)¶. Improvements¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients.; The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/changelog.html:5936,efficient,efficient,5936,docs/4.5/changelog.html,https://qutip.org,https://qutip.org/docs/4.5/changelog.html,3,['efficient'],['efficient']
Energy Efficiency,"ed users. Returns; -------; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information.; """"""; ss_args = _default_steadystate_args(); ss_args['method'] = 'iterative'; for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(""Invalid keyword argument '"" + key +; ""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. L = _steadystate_setup(A, c_op_list); # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(L.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. n = int(np.sqrt(L.shape[0])); if ss_args['method'] == 'iterative':; L, perm, perm2, rev_perm, ss_args = _steadystate_LU_liouvillian(L, ss_args); elif ss_args['method'] == 'power':; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ss_args); else:; raise Exception(""Invalid preconditioning method.""); ; M, ss_args = _iterative_precondition(L, n, ss_args). if ss_args['return_info']:; return M, ss_args['info']; else:; return M. def _pseudo_inverse_dense(L, rhoss, w=None, **pseudo_args):; """"""; Internal function for computing the pseudo inverse of an Liouvillian using; dense matrix methods. See pseudo_inverse for details.; """"""; rho_vec = np.transpose(mat2vec(rhoss.full())). tr_mat = tensor([identity(n) for n in L.dims[0][0]]); tr_vec = np.transpose(mat2vec(tr_mat.full())); N = np.prod(L.dims[0][0]); I = np.identity(N * N); P = np.kron(np.transpose(rho_vec), tr_vec); Q = I - P; ; if w is None:; L = L; else:; L = 1.0j*w*spre(tr_mat)+L; ; if pseudo_args['method'] == 'direct':; try:; LIQ = np.linalg.solve(L.full(), Q); except:; LIQ = np.linalg.lstsq(L.full(), Q)[0]; ; R = np.dot(Q, LIQ); ; return Qobj(R, dims=L.dims). elif pseudo_args['meth",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:30710,power,power,30710,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['power'],['power']
Energy Efficiency,"ed) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(self, other)[source]¶; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ‘ket’, ‘bra’ or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets. permute(self, order)[source]¶; Permutes a composite quantum object. Parameters. orderlist/arrayList specifying new tensor order. Returns. Pqutip.QobjPermuted quantum object. proj(self)[source]¶; Form the projector from a given ket or bra vector. Parameters. Qqutip.QobjInput bra or ket vector. Returns. Pqutip.QobjProjection operator. ptrace(self, sel)[source]¶; Partial trace of the quantum object. Parameters. selint/listAn int or list of components to keep after partial trace. Returns. operqutip.QobjQuantum object representing partial trace with selected components; remaining. Notes; This function is identical to the qutip.qobj.ptrace function; that has been deprecated. sinm(self)[source]¶; Sine of a quantum operator.; Operator must be square. Returns. operqutip.QobjMatrix sine of operator. Raises. TypeErrorQuantum object is not square. Notes; Uses the Q.expm() method. sqrtm(self, sparse=False",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:12692,efficient,efficient,12692,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['efficient'],['efficient']
Energy Efficiency,"ed) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(self, other)[source]¶; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ‘ket’, ‘bra’ or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets. permute(self, order)[source]¶; Permutes a composite quantum object. Parameters. orderlist/arrayList specifying new tensor order. Returns. Pqutip.QobjPermuted quantum object. proj(self)[source]¶; Form the projector from a given ket or bra vector. Parameters. Qqutip.QobjInput bra or ket vector. Returns. Pqutip.QobjProjection operator. ptrace(self, sel, sparse=None)[source]¶; Partial trace of the quantum object. Parameters. selint/listAn int or list of components to keep after partial trace. Returns. operqutip.QobjQuantum object representing partial trace with selected components; remaining. Notes; This function is identical to the qutip.qobj.ptrace function; that has been deprecated. purity(self)[source]¶; Calculate purity of a quantum object. Returns. state_purityfloatReturns the purity of a quantum object.; For a pure state, the purity is 1.; For a mixed state of dimension d, 1/d<=purity<1. s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:12999,efficient,efficient,12999,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['efficient'],['efficient']
Energy Efficiency,"eduled result; instruction_list, scheduled_start_time = \; self._schedule(instruction_list, schedule_mode). # An instruction can be composed from several different pulse elements.; # We separate them an assign them to each pulse index.; pulse_instructions = [[] for tmp in range(num_controls)]; for instruction, start_time in \; zip(instruction_list, scheduled_start_time):; for pulse_name, coeff in instruction.pulse_info:; if self.pulse_dict:; try:; pulse_ind = self.pulse_dict[pulse_name]; except KeyError:; raise ValueError(; f""Pulse name {pulse_name} not found""; "" in pulse_dict.""); else:; pulse_ind = pulse_name; pulse_instructions[pulse_ind].append(; (start_time, instruction.tlist, coeff)). # concatenate pulses; compiled_tlist, compiled_coeffs = \; self._concatenate_pulses(; pulse_instructions, scheduled_start_time, num_controls); return compiled_tlist, compiled_coeffs. def _schedule(self, instruction_list, schedule_mode):; """"""; Schedule the instructions if required and ; reorder instruction_list accordingly; """"""; if schedule_mode:; scheduler = Scheduler(schedule_mode); scheduled_start_time = scheduler.schedule(instruction_list); time_ordered_pos = np.argsort(scheduled_start_time); instruction_list = [instruction_list[i] for i in time_ordered_pos]; scheduled_start_time.sort(); else: # no scheduling; scheduled_start_time = [0.]; for instruction in instruction_list[:-1]:; scheduled_start_time.append(; instruction.duration + scheduled_start_time[-1]); return instruction_list, scheduled_start_time. def _concatenate_pulses(; self, pulse_instructions, scheduled_start_time, num_controls):; """"""; Concatenate compiled pulses coefficients and tlist for each pulse.; If there is idling time, add zeros properly to prevent wrong spline.; """"""; # Concatenate tlist and coeffs for each control pulses; compiled_tlist = [[] for tmp in range(num_controls)]; compiled_coeffs = [[] for tmp in range(num_controls)]; for pulse_ind in range(num_controls):; last_pulse_time = 0.; for start_time, t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:7033,schedul,scheduler,7033,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,12,"['Schedul', 'schedul']","['Schedule', 'Scheduler', 'scheduler']"
Energy Efficiency,"een representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); sqrt_shape = int(sqrt(data.shape[0])); return Qobj(dims=q_oper.dims,; inpt=data.reshape([sqrt_shape] * 4).; transpose(3, 1, 2, 0).reshape(q_oper.data.shape)). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**floor(log2(dim)) == dim; for dim in flatten(dims); ]). def _super_to_superpauli(q_oper):; """"""; Converts a superoperator in the column-stacking basis to; the Pauli basis (assuming qubit dimensions). This is an internal function, as QuTiP does not currently have; a way to mark that superoperators are represented in the Pauli; basis as opposed to the column-stacking basis; a Pauli-basis; ``type='super'`` would thus break other conversion functions.; """"""; # Ensure we start with a column-stacking-basis superoperator.; sqobj = to_super(q_oper); if not _isqubitdims(sqobj.dims):; raise ValueError(""Pauli basis is only defined for qubits.""); nq = int(log2(sqobj.shape[0]) / 2); B = _pauli_basis(nq) / sqrt(2**nq); # To do this, we have to hack a bit and force the dims to match,; # since the _pauli_basis function makes different assumptions; # about indices than we need here.; B.dims = sqobj.dims; return (B.dag() ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html:6057,power,power,6057,docs/4.1/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/superop_reps.html,5,['power'],['power']
Energy Efficiency,"eful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. permc_spec : str, optional, default=’COLAMD’. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factor : float, optional, default = 100. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = ‘smilu_2’. Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns:lu : object. Returns a SuperLU object representing iLU preconditioner. info : dict, optional. Dictionary containing solver-specific information. Propagators¶. propagator(H, t, c_op_list, args=None, options=None, sparse=False, progress_bar=None)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density mat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:94720,reduce,reduced,94720,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['reduce'],['reduced']
Energy Efficiency,"el client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; values (array / list) – The list or array of values for which the task function is to be; evaluated.; task_args (list / dictionary) – The optional additional argument to the task function.; task_kwargs (list / dictionary) – The optional additional keyword argument to the task function.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar during the execution of the parfor; loop. Returns:result – The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. Return type:list. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table – Return an HTML-formatted string containing version information for; QuTiP dependencies. Return type:string. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]¶; Simulateous dia",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:202628,schedul,scheduled,202628,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['schedul'],['scheduled']
Energy Efficiency,"elf._isherm. out.superrep = self.superrep. return out. else:; raise TypeError(""Incompatible object for division""). def __neg__(self):; """"""; NEGATION operation.; """"""; out = Qobj(); out.data = -self.data; out.dims = self.dims; out.superrep = self.superrep; if settings.auto_tidyup: out.tidyup(); out._isherm = self._isherm; out._isunitary = self._isunitary; return out. def __getitem__(self, ind):; """"""; GET qobj elements.; """"""; out = self.data[ind]; if sp.issparse(out):; return np.asarray(out.todense()); else:; return out. def __eq__(self, other):; """"""; EQUALITY operator.; """"""; if (isinstance(other, Qobj) and; self.dims == other.dims and; not np.any(np.abs((self.data - other.data).data) >; settings.atol)):; return True; else:; return False. def __ne__(self, other):; """"""; INEQUALITY operator.; """"""; return not (self == other). def __pow__(self, n, m=None): # calculates powers of Qobj; """"""; POWER operation.; """"""; if self.type not in ['oper', 'super']:; raise Exception(""Raising a qobj to some power works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. except:; raise ValueError('Invalid choice of exponent.'). def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t + ""\n""); s += ""Qobj data =\n"". if shape[0] > 10000 or shape[1] > 10000:; # if the system is huge, don't attempt to convert to a; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:19310,power,power,19310,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,3,['power'],['power']
Energy Efficiency,"elf.dims; if settings.auto_tidyup: out.tidyup(); if isinstance(other, complex):; out._isherm = out.isherm; else:; out._isherm = self._isherm. out.superrep = self.superrep. return out. else:; raise TypeError(""Incompatible object for division""). def __neg__(self):; """"""; NEGATION operation.; """"""; out = Qobj(); out.data = -self.data; out.dims = self.dims; out.superrep = self.superrep; if settings.auto_tidyup: out.tidyup(); out._isherm = self._isherm; out._isunitary = self._isunitary; return out. def __getitem__(self, ind):; """"""; GET qobj elements.; """"""; out = self.data[ind]; if sp.issparse(out):; return np.asarray(out.todense()); else:; return out. def __eq__(self, other):; """"""; EQUALITY operator.; """"""; if (isinstance(other, Qobj) and; self.dims == other.dims and; not np.any(np.abs((self.data - other.data).data) >; settings.atol)):; return True; else:; return False. def __ne__(self, other):; """"""; INEQUALITY operator.; """"""; return not (self == other). def __pow__(self, n, m=None): # calculates powers of Qobj; """"""; POWER operation.; """"""; if self.type not in ['oper', 'super']:; raise Exception(""Raising a qobj to some power works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. except:; raise ValueError('Invalid choice of exponent.'). def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:19186,power,powers,19186,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,3,['power'],['powers']
Energy Efficiency,"ely.; Examples; >>> thermal_dm(5, 1); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters:N : int. Hilbert space dimensionality. dims : list. Optional dimensions if ket corresponds to; a composite Hilbert space. Returns:zero_ket : qobj. Zero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters:Nmax : int. Maximum charge state to consider. Nmin : int (default = -Nmax). Lowest charge state to consider. frac : float (default = 1). Specify fractional charge if needed. Returns:C : Qobj. Charge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters:N : int. Dimension of Hilbert space. Returns:oper : qobj. Qobj for raising operator. offset : int (default 0). The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:17979,charge,charge,17979,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,6,['charge'],['charge']
Energy Efficiency,"ems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code.; Attributes. H_sys; (Qobj) System Hamiltonian. coup_op; (Qobj) Operator describing the coupling between system and bath. coup_strength; (float) Coupling strength. temperature; (float) Bath temperature, in units corresponding to planck. N_cut; (int) Cutoff parameter for the bath. N_exp; (int) Number of exponential terms used to approximate the bath correlation functions. planck; (float) reduced Planck constant. boltzmann; (float) Boltzmann’s constant. options; (qutip.solver.Options) Generic solver options. If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for showing the progress of the simulation. stats; (qutip.solver.Stats) optional container for holding performance statitics If None is set, then statistics are not collected There may be an overhead in collecting statistics. exp_coeff; (list of complex) Coefficients for the exponential series terms. exp_freq; (list of complex) Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:options : qutip.solver",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:23976,reduce,reduced,23976,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['reduce'],['reduced']
Energy Efficiency,"energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/utilities.html:7608,energy,energy,7608,docs/4.6/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html,4,['energy'],['energy']
Energy Efficiency,"energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:7656,energy,energy,7656,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,7,['energy'],['energy']
Energy Efficiency,"ented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters. dataarray_likeData for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecslistList of arrays that spans the space for each coordinate. xlabelslistList of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; marginal distribution. Returns. dDistributionsA new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; projected distribution. Returns. dDistributionsA new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. axmatplotlib Axes instanceIf given, render the visualization using this axis instance. figsizetupleSize of the new Figure instance, if one needs to be created. colorbar: BoolWhether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instanceIf given, use this colormap for 2D visualizations. stylestringType of visualization: ‘colormap’ (default) or ‘surface’. Returns. fig, axtu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:74050,reduce,reduced-dimensionality,74050,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['reduce'],['reduced-dimensionality']
Energy Efficiency,"entity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; N = 10. omega_a = 1.0. omega_c = 1.25. g = 0.05. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). print(H). Output:; Quantum object: dims = [[2, 10], [2, 10]], shape = (20, 20), type = oper, isherm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 1.75 0. 0. 0. 0.; 0. 0. 0. 0. 0.05 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 3. 0. 0. 0.; 0. 0. 0. 0. 0. 0.07071068; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 4.25 0. 0.; 0. 0. 0. 0. 0. 0.; 0.08660254 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 5.5 0.; 0. 0. 0. 0. 0. 0.; 0. 0.1 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 6.75; 0. 0. 0. 0. 0. 0.; 0. 0. 0.1118034 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 8. 0. 0. 0. 0. 0.; 0. 0. 0. 0.12247449 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 9.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-tensor.html:6156,energy,energy,6156,docs/4.6/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html,2,['energy'],['energy']
Energy Efficiency,"envalue solver for trace norm. Other norms are not; affected by this parameter. tol : float; Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns:; norm : float; The requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(other)[source]¶; Overlap between two state vectors.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. Parameters:; other : qobj; Quantum object for a state vector of type ‘ket’ or ‘bra’. Returns:; overlap : complex; Complex valued overlap. Raises:; TypeError; Can only calculate overlap between a bra and ket quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner product; call is the ket-ket version that computes the product <self|other> with; both vectors expressed as kets. permute(order)[source]¶; Permutes a composite quantum object. Parameters:; order : list/array; List specifying new tensor order. Returns:; P : qobj; Permuted quantum object. proj()[source]¶; Form the projector from a given ket or bra vector. Parameters:; Q : Qobj; Input bra or ket vector. Returns:; P : Qobj; Projection operator. ptrace(sel)[source]¶; Partial trace of the quantum object. Parameters:; sel : int/list; An int or list of components to keep after partial trace. Returns:; oper : qobj; Quantum object representing partial trace with selected components; remaining. Notes; This function is identical to the qutip.qobj.ptrace function; that has been deprecated. sinm()[source]¶; Sine of a quantum operator.; Operator must be square. Returns:; oper : qobj; Matrix sine of operator. Raises:; TypeError; Quantum object is not square. Notes; Uses the Q.expm() method. sqrtm(sparse=False, tol=0, ma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:12781,efficient,efficient,12781,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['efficient'],['efficient']
Energy Efficiency,"eracy). [docs]def state_degeneracy(N, j):; """"""Calculate the degeneracy of the Dicke state. Each state :math:`|j, m\\rangle` includes D(N,j) irreducible; representations :math:`|j, m, \\alpha\\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2 * j + 1); denominator_1 = Decimal(factorial(N / 2 + j + 1)); denominator_2 = Decimal(factorial(N / 2 - j)); degeneracy = numerator / (denominator_1 * denominator_2); degeneracy = int(np.round(float(degeneracy))); return degeneracy. [docs]def m_degeneracy(N, m):; """"""Calculate the number of Dicke states :math:`|j, m\\rangle` with; same energy. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue (proportional to the total; energy). Returns; -------; degeneracy: int; The m-degeneracy.; """"""; jvals = j_vals(N); maxj = np.max(jvals); if m < -maxj:; e = ""m value is incorrect for this N.""; e += "" Minimum m value can be {}"".format(-maxj); raise ValueError(e); degeneracy = N / 2 + 1 - abs(m); return int(degeneracy). [docs]def ap(j, m):; """"""Calculate the coefficient `ap` by applying J_+ |j, m>. The action of ap is given by:; :math:`J_{+}|j, m\\rangle = A_{+}(j, m)|j, m+1\\rangle`. Parameters; ----------; j, m: float; The value for j and m in the dicke basis |j,m>. Returns; -------; a_plus: float; The value of :math:`a_{+}`.; """"""; a_plus = np.sqrt((j - m) * (j + m + 1)); return a_plus. [docs]def am(j, m):; """"""Calculate the operator `am` used later. The action of ap is given by: J_{-}|j, m> = A_{-}(jm)|j, m-1>. Parameters; ----------; j: float; The value for j. m: float; The value for m. Returns; -------; a_minus: float; The value of :math:`a_{-}`.; """"""; a_minus = np.sqrt((j + m) ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/piqs.html:17616,energy,energy,17616,docs/4.5/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/piqs.html,1,['energy'],['energy']
Energy Efficiency,"erformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-control.html:18182,efficient,efficient,18182,docs/4.3/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html,1,['efficient'],['efficient']
Energy Efficiency,"erm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if (ss_args['solver'] == 'scipy' and ss_args['sparse']) \; or ss_args['solver'] == 'mkl':; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:11454,power,power,11454,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,20,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"ert space.; """"""; ce = self.collective_emission; cd = self.collective_dephasing; cp = self.collective_pumping; c_ops_list = collapse_uncoupled(N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=ce,; collective_dephasing=cd,; collective_pumping=cp); return c_ops_list. [docs] def coefficient_matrix(self):; """"""Build coefficient matrix for ODE for a diagonal problem. Returns; -------; M: ndarray; The matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis.; """"""; diagonal_system = Pim(N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=self.collective_emission,; collective_dephasing=self.collective_dephasing,; collective_pumping=self.collective_pumping); coef_matrix = diagonal_system.coefficient_matrix(); return coef_matrix. # Utility functions for properties of the Dicke space; def energy_degeneracy(N, m):; """"""Calculate the number of Dicke states with same energy. The use of the `Decimals` class allows to explore N > 1000,; unlike the built-in function `scipy.special.binom`. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""; numerator = Decimal(factorial(N)); d1 = Decimal(factorial(N/2 + m)); d2 = Decimal(factorial(N/2 - m)); degeneracy = numerator/(d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; """"""Calculate the degeneracy of the Dicke state. Each state :math:`|j, m\\rangle` includes D(N,j) irreducible; representations :math:`|j, m, \\alpha\\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/piqs.html:12715,energy,energy,12715,docs/4.3/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/piqs.html,2,['energy'],['energy']
Energy Efficiency,"es; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, delta=0.0, g=0.01, t1=None, t2=None)[source]¶; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_phase: float, optionalSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. num_levels: int, optionalThe number of energy levels in the resonator. deltamax: int or list, optionalThe coefficients of sigma-x for each of the qubits in the system. epsmax: int or list, optionalThe coefficients of sigma-z for each of the qubits in the system. w0: int, optionalThe base frequency of the resonator. eps: int or list, optionalThe epsilon for each of the qubits in the system. delta: int or list, optionalThe epsilon for each of the qubits in the system. g: int or list, optionalThe interaction strength for each of the qubit with the resonator. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. Attributes. sx_ops: listA list of sigmax Hamiltonians for each qubit. sz_ops: listA list of sigmaz Hamiltonians for each qubit. cavityqubit_ops: listA list of interacting Hamiltonians between cavity and each qubit. sx_u: arra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:150116,energy,energy,150116,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['energy'],['energy']
Energy Efficiency,"es[ind1].distance_to_end == \; self.nodes[ind2].distance_to_end:; # lower distance_to_start, higher priority; return self.nodes[ind1].distance_to_start - \; self.nodes[ind2].distance_to_start; else:; # higher distance_to_end, higher priority; return self.nodes[ind2].distance_to_end - \; self.nodes[ind1].distance_to_end. def add_constraint_dependency(self, constraint_dependency):; """"""; Add the dependency caused by hardware constraint to the graph. Parameters; ----------; constraint_dependency: list; `constraint_dependency` obtained by the method; `find_topological_order`.; """"""; for ind1, ind2 in constraint_dependency:; self.nodes[ind1].successors.add(ind2); self.nodes[ind2].predecessors.add(ind1). # Update the start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. [docs]class Scheduler():; """"""; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419. The scheduler includes two methods,; ""ASAP"", as soon as possible, and ""ALAP"", as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits. The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:12492,schedul,scheduler,12492,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,6,"['Schedul', 'schedul']","['Scheduler', 'scheduler']"
Energy Efficiency,"es_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:183708,schedul,schedule,183708,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['schedul'],['schedule']
Energy Efficiency,"esponding the eigenstate \(\left|m\right>\), we obtain in matrix form in the Schrödinger picture. \[\begin{split}\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); -\hbar^{-2}; \sum_{\alpha,\beta}; \sum_{c,d}^{\rm sec}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\tau); \left[\delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}e^{i\omega_{cn}\tau}; -; A^\alpha_{ac} A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; +; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\\end{split}\]; where the “sec” above the summation symbol indicate summation of the secular terms which satisfy \(|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}\). This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function \(g(\tau)\) in terms of the noise-power spectrum of the environment \(S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)\):. (4)\[ \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:8441,power,power,8441,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,3,['power'],['power']
Energy Efficiency,"esponding the eigenstate \(\left|m\right>\), we obtain in matrix form in the Schrödinger picture. \[\begin{split}\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); -\hbar^{-2}; \sum_{\alpha,\beta}; \sum_{c,d}^{\rm sec}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\tau); \left[\delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}e^{i\omega_{cn}\tau}; -; A^\alpha_{ac} A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; +; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\\end{split}\]; where the “sec” above the summation symbol indicate summation of the secular terms which satisfy \(|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}\). This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function \(g(\tau)\) in terms of the noise-power spectrum of the environment \(S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)\):. (4)¶\[ \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)¶\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:8058,power,power,8058,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,10,['power'],['power']
Energy Efficiency,"ess_bar; qutip.ui.BaseProgressBar; Optional progress bar class instance. Distribution functions¶. class Distribution(data=None, xvecs=, []xlabels=[])¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:data : array_like. Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list. List of arrays that spans the space for each coordinate. xlabels : list. List of labels for each coordinate. Methods. marginal(dim=0)¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d : Distributions. A new instances of Distribution that describes the marginal; distribution. project(dim=0)¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d : Distributions. A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,; ax : mat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:31425,reduce,reduced,31425,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,2,['reduce'],['reduced']
Energy Efficiency,"essary libraries, one can check for INTEL MKL Ext: True in the QuTiP about box (qutip.about). Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these it",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-steady.html:4604,reduce,reduced,4604,docs/4.2/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-steady.html,10,['reduce'],['reduced']
Energy Efficiency,"esult.times, result.expect[0]);. In [13]: ax.plot(result.times, result.expect[1]);. In [14]: ax.set_xlabel('Time');. In [15]: ax.set_ylabel('Expectation values');. In [16]: ax.legend((""Sigma-Z"", ""Sigma-Y""));. In [17]: show(). If an empty list of operators is passed as fifth parameter, the qutip.mesolve function returns a qutip.solver.Result instance that contains a list of state vectors for the times specified in times; In [18]: times = [0.0, 1.0]. In [19]: result = mesolve(H, psi0, times, [], []). In [20]: result.states; Out[20]: ; [Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]], Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.80901699+0.j ]; [0. -0.58778526j]]]. Non-unitary evolution¶; While the evolution of the state vector in a closed quantum system is deterministic, open quantum systems are stochastic in nature. The effect of an environment on the system of interest is to induce stochastic transitions between energy levels, and to introduce uncertainty in the phase difference between states of the system. The state of an open quantum system is therefore described in terms of ensemble averaged states using the density matrix formalism. A density matrix \(\rho\) describes a probability distribution of quantum states \(\left|\psi_n\right>\), in a matrix representation \(\rho = \sum_n p_n \left|\psi_n\right>\left<\psi_n\right|\), where \(p_n\) is the classical probability that the system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html:6754,energy,energy,6754,docs/4.3/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html,2,['energy'],['energy']
Energy Efficiency,"et Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)¶\[\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2). If the environmental ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html:1440,monitor,monitored,1440,docs/4.2/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html,3,['monitor'],['monitored']
Energy Efficiency,"et_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else min(H.shape[0], N). xticks = []; yticks = []. x = 0; evals0 = H.eigenenergies(eigvals=N) / (2 * np.pi); for e_idx, e in enumerate(evals0[:N]):; ax.plot([x, x + 2], np.array([1, 1]) * e, 'b', linewidth=2); yticks.append(e); xticks.append(x + 1); x += 2. for H1 in H_list[1:]:. H = H + H1; evals1 = H.eigenenergies() / (2 * np.pi). for e_idx, e in enum",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/visualization.html:14853,energy,energy,14853,docs/4.1/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/visualization.html,4,['energy'],['energy']
Energy Efficiency,"et_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else min(H.shape[0], N). xticks = []; yticks = []. x = 0; evals0 = H.eigenenergies(eigvals=N); for e_idx, e in enumerate(evals0[:N]):; ax.plot([x, x + 2], np.array([1, 1]) * e, 'b', linewidth=2); yticks.append(e); xticks.append(x + 1); x += 2. for H1 in H_list[1:]:. H = H + H1; evals1 = H.eigenenergies(). for e_idx, e in enumerate(evals1[:N]):; ax.plot(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/visualization.html:14933,energy,energy,14933,docs/4.3/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/visualization.html,7,['energy'],['energy']
Energy Efficiency,"ethod.; :func:`~general_stochastic` only accepts the derivative-free; solvers: ``'euler'``, ``'platen'`` and ``'explicit1.5'``. Available solvers for :obj:`~photocurrent_sesolve` and \; :obj:`~photocurrent_mesolve`; Photocurrent use ordinary differential equations between; stochastic ""jump/collapse"". euler; Euler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]_. - Order 1.0; - Code: ``'euler'``. predictor–corrector; predictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. - Order 2.0; - Code: ``'pred-corr'``. References; ----------; .. [1] Peter E. Kloeden and Exkhard Platen, *Numerical Solution of; Stochastic Differential Equations*.; .. [2] H.-P. Breuer and F. Petruccione, *The Theory of Open Quantum; Systems*.; .. [3] Pierre Rouchon and Jason F. Ralpha, *Efficient Quantum Filtering for; Quantum Feedback Control*, `arXiv:1410.5345 [quant-ph]; <https://arxiv.org/abs/1410.5345>`_, Phys. Rev. A 91, 012118,; (2015).; .. [4] Howard M. Wiseman, Gerard J. Milburn, *Quantum measurement and; control*.; """""". [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photocurrent_sesolve` and; :func:`qutip.stochastic.photocurrent_mesolve`; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Within the attribute list, a ``time_dependent_object`` is either. - :class:`~Qobj`: a constant term; - 2-element list of ``[Qobj, time_dependence]``: a tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:7474,Efficient,Efficient,7474,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,1,['Efficient'],['Efficient']
Energy Efficiency,"ethod.; :func:`~general_stochastic` only accepts the derivative-free; solvers: ``'euler'``, ``'platen'`` and ``'explicit1.5'``. Available solvers for :obj:`~photocurrent_sesolve` and \; :obj:`~photocurrent_mesolve`; Photocurrent use ordinary differential equations between; stochastic ""jump/collapse"". euler; Euler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]_. - Order 1.0; - Code: ``'euler'``. predictor–corrector; predictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. - Order 2.0; - Code: ``'pred-corr'``. References; ----------; .. [1] Peter E. Kloeden and Exkhard Platen, *Numerical Solution of; Stochastic Differential Equations*.; .. [2] H.-P. Breuer and F. Petruccione, *The Theory of Open Quantum; Systems*.; .. [3] Pierre Rouchon and Jason F. Ralpha, *Efficient Quantum Filtering for; Quantum Feedback Control*, `arXiv:1410.5345 [quant-ph]; <https://arxiv.org/abs/1410.5345>`_, Phys. Rev. A 91, 012118,; (2015).; .. [4] Howard M. Wiseman, Gerard J. Milburn, *Quantum measurement and; control*.; """""". [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photocurrent_sesolve` and; :func:`qutip.stochastic.photocurrent_mesolve`; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Within the attribute list, a ``time_dependent_object`` is either. - :class:`~qutip.Qobj`: a constant term; - 2-element list of ``[Qobj, time_dependence]``:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/stochastic.html:5736,Efficient,Efficient,5736,docs/4.7/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html,1,['Efficient'],['Efficient']
Energy Efficiency,"etting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and nam",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-floquet.html:1663,efficient,efficiently,1663,docs/4.5/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-floquet.html,1,['efficient'],['efficiently']
Energy Efficiency,"eturn L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; # FIXME: These atol keyword except checks can be removed once s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:27736,power,power-gmres,27736,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,9,['power'],"['power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"eturn L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:27318,power,power-gmres,27318,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,12,['power'],"['power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"f output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. [docs]def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. .. note :; The number of integration steps (for calculating X) within one period; is set to 20 * kmax. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. kmax : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). options : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). # time steps for integration of coupling operator; nT = int(np.max([20 * kmax, 100])); dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_mod",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:14895,power,power,14895,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['power'],['power']
Energy Efficiency,"f self.L1 has more than one; element); c2 (qutip.Qobj) – system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element); notrace (bool {False}) – If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for computing field correlation function. Return type:qutip.Qobj. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters:; t (float) – current time; tau (float) – time-delay; notrace (bool {False}) – If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for reduced system dynamics. Return type:qutip.Qobj. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket); t (float) – current time; tau (float) – time-delay. Returns:density matrix at time \(t\). Return type:qutip.Qobj. class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. dynmaps¶; list of qutip.Qobj – List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times¶; array_like – List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes¶; array_like – List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres¶; float – Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options¶; qutip.solver.Options – Generic solver options. Solver Opti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:34404,reduce,reduced,34404,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['reduce'],['reduced']
Energy Efficiency,"f solver (`es` for exponential series and; `pi` for psuedo-inverse).; use_pinv : bool; For use with the `pi` solver: if `True` use numpy's pinv method,; otherwise use a generic solver. Returns; -------; spectrum : array; An array with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(tlist, y):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; one-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]); tlist = np.asarray(tlist); N = tlist.shape[0]; dt = tlist[1] - tlist[0]; if not np.allclose(np.diff(tlist), dt*np.ones(N-1,dtype=float)):; raise Exception('tlist must be equally spaced for FFT.'); ; F = scipy.fftpack.fft(y); # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # select only indices for elements that corresponds; # to positive frequencies; indices = np.where(f > 0.0). return 2 * np.pi * f[indices], 2 * dt * np.real(F[indices]). # -----------------------------------------------------------------------------; # LEGACY API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_ss(H, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the two-operator two-time correlation function:. .. math::",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:18003,power,power,18003,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,1,['power'],['power']
Energy Efficiency,"f the finite lifetime of qubits. The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]; else:; return constraint_functions. [docs] def schedule(self, circuit, gates_schedule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `QubitCircuit`,; a list of `Gates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:13840,schedul,schedule,13840,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['schedule']
Energy Efficiency,"f.data / other; out.dims = self.dims; if isinstance(other, complex):; out._isherm = out.isherm; else:; out._isherm = self._isherm. out.superrep = self.superrep. return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible object for division""). def __neg__(self):; """"""; NEGATION operation.; """"""; out = Qobj(); out.data = -self.data; out.dims = self.dims; out.superrep = self.superrep; out._isherm = self._isherm; return out.tidyup() if settings.auto_tidyup else out. def __getitem__(self, ind):; """"""; GET qobj elements.; """"""; out = self.data[ind]; if sp.issparse(out):; return np.asarray(out.todense()); else:; return out. def __eq__(self, other):; """"""; EQUALITY operator.; """"""; if (isinstance(other, Qobj) and; self.dims == other.dims and; not np.any(np.abs((self.data - other.data).data) >; settings.atol)):; return True; else:; return False. def __ne__(self, other):; """"""; INEQUALITY operator.; """"""; return not (self == other). def __pow__(self, n, m=None): # calculates powers of Qobj; """"""; POWER operation.; """"""; if self.type not in ['oper', 'super']:; raise Exception(""Raising a qobj to some power works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. except:; raise ValueError('Invalid choice of exponent.'). def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:18186,power,powers,18186,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,2,['power'],['powers']
Energy Efficiency,"factor); _factorial_div(v, factor); common_denominator = -np.min(s_factors, axis=0); numerators = s_factors + common_denominator; S = sum([(-1)**i * _to_long(vec) for i,vec in enumerate(numerators)]) * \; sign / _to_long(common_denominator); return C * S. # -----------------------------------------------------------------------------; # Functions for unit conversions; #; _e = 1.602176565e-19 # C; _kB = 1.3806488e-23 # J/K; _h = 6.62606957e-34 # Js. _unit_factor_tbl = {; # ""unit"": ""factor that convert argument from unit 'unit' to Joule""; ""J"": 1.0,; ""eV"": _e,; ""meV"": 1.0e-3 * _e,; ""GHz"": 1.0e9 * _h,; ""mK"": 1.0e-3 * _kB,; }. [docs]def convert_unit(value, orig=""meV"", to=""GHz""):; """"""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : string; The name of the original unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). to : string; The name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/utilities.html:6477,energy,energy,6477,docs/4.5/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/utilities.html,5,['energy'],['energy']
Energy Efficiency,"field master equation in QuTiP. « Monte Carlo Solv... Solving Problems... ». Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more ro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:2385,energy,energy,2385,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,6,"['energy', 'power']","['energy', 'power']"
Energy Efficiency,"float numbers. The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None). Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:rho : qutip.qobj.Qobj. The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance. The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance. The axes context in which the plot will be drawn. title : string. An optional title for the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:116609,energy,energy,116609,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set throu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:76078,reduce,reduce,76078,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['reduce'],['reduce']
Energy Efficiency,"floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=Non",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:190229,reduce,reduce,190229,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['reduce'],['reduce']
Energy Efficiency,"floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpqutip.control.dump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_par",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:222652,reduce,reduce,222652,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['reduce'],['reduce']
Energy Efficiency,"floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args); p_ex[n] = expect(num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = mesolve(H, psi0, tlist, [], [num(2)], args).expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'ro', tlist, 1-real(p_ex), 'bo'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code, png, hires.png, pdf). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 10 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = floquet_mo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html:13422,efficient,efficiently,13422,docs/4.2/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html,8,['efficient'],['efficiently']
Energy Efficiency,"for a in a_ops]. [docs]def enr_identity(dims, excitations):; """"""; Generate the identity operator for the excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtyp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/operators.html:20671,charge,charge,20671,docs/4.3/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/operators.html,9,['charge'],['charge']
Energy Efficiency,"for a in a_ops]. [docs]def enr_identity(dims, excitations):; """"""; Generate the identity operator for the excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax.; ; Parameters; ----------; Nmax : int; Maximum charge state to consider.; ; Nmin : int (default = -Nmax); Lowest charge state to consider.; ; frac : float (default = 1); Specify fractional charge if needed.; ; Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax].; ; Notes; -----; .. versionadded:: 3.2; ; """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form ; :math:`\sum |N><N+m| + |N+m><N|`.; ; Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event.; ; Returns; -------; T : Qobj; Tunneling operator.; ; Notes; -----; .. versionadded:: 3.2; ; """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(di",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/operators.html:20738,charge,charge,20738,docs/4.2/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/operators.html,9,['charge'],['charge']
Energy Efficiency,"for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from qutip.tensor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/operators.html:20969,charge,charge,20969,docs/4.3/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/operators.html,3,['charge'],['charge']
Energy Efficiency,"for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:data : array_like. Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list. List of arrays that spans the space for each coordinate. xlabels : list. List of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d : Distributions. A new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d : Distributions. A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,; ax : matplotlib Axes instance; If given, render the visualization using this axis instance.; figsize : tuple; Size of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style : string; Type of visualization: ‘colormap’ (defau",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:46291,reduce,reduced-dimensionality,46291,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,1,['reduce'],['reduced-dimensionality']
Energy Efficiency,"for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:data : array_like. Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list. List of arrays that spans the space for each coordinate. xlabels : list. List of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d : Distributions. A new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d : Distributions. A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig; : matplotlib Figure instanceIf given, use this figure instance for the visualization,; ax; : matplotlib Axes instanceIf given, render the visualization using this axis instance.; figsize; : tupleSize of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style; : stringType of visualization: ‘colormap’ (default) ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/classes.html:46135,reduce,reduced-dimensionality,46135,docs/4.1/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/classes.html,1,['reduce'],['reduced-dimensionality']
Energy Efficiency,"for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis.; """"""; diagonal_system = Pim(; N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=self.collective_emission,; collective_dephasing=self.collective_dephasing,; collective_pumping=self.collective_pumping,; ); coef_matrix = diagonal_system.coefficient_matrix(); return coef_matrix. # Utility functions for properties of the Dicke space; [docs]def energy_degeneracy(N, m):; """"""Calculate the number of Dicke states with same energy. The use of the `Decimals` class allows to explore N > 1000,; unlike the built-in function `scipy.special.binom`. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""; numerator = Decimal(factorial(N)); d1 = Decimal(factorial(_ensure_int(N / 2 + m))); d2 = Decimal(factorial(_ensure_int(N / 2 - m))); degeneracy = numerator / (d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; r""""""Calculate the degeneracy of the Dicke state. Each state :math:`\lvert j, m\rangle` includes D(N,j) irreducible; representations :math:`\lvert j, m, \alpha\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2 * j + 1); denominator_1 = Decimal(factorial(_ensure_int(N / 2 + j + 1))); denominator_2 = Decimal(factorial(_ensure_int(N / 2 - j))); degeneracy = numerator / (denominator_1 * denominator_2); degeneracy = int(np.round(float(degeneracy))); return degeneracy. [docs]def m_degeneracy(N, m):; r""""""Calculate the number of Dic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/piqs.html:16519,energy,energy,16519,docs/4.6/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html,4,['energy'],['energy']
Energy Efficiency,"for the frequencies; specified in wlist. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t o \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty}; \lim_{t o \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\end{split}\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters:H : qutip.qobj. system Hamiltonian. wlist : list / array. list of frequencies for \(\omega\). c_ops : list of qutip.qobj. list of collapse operators. a_op : qutip.qobj. operator A. b_op : qutip.qobj. operator B. use_pinv : bool. If True use numpy’s pinv method, otherwise use a generic solver. Returns:spectrum: array. An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(taulist, y)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:tlist : list / array. list/array of times \(t\) which the correlation function is given. y : list / array. list/array of correlations corresponding to time delays \(t\). Returns:w, S : tuple. Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. coherence_function_g1(H, taulist, c_ops, a_op, solver='me', args=None, options=<qutip.solver.Options instance at 0x105963998>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) = \lim_{t o \infty}; \frac{\langle a^\dagger(t+\tau)a(t)\rangle}; {\langle a^\dagger(t)a(t)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Note: g1 is only defined for stationary; statistics (uses steady state). Parameters:H : qutip.qobj.Qobj. system Hamiltonian. taulist : list / array. list of times for \(\tau\). taulist must be positive and co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:85686,power,power,85686,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"fty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters:H : qutip.qobj. system Hamiltonian. wlist : array_like. list of frequencies for \(\omega\). c_ops : list of qutip.qobj. list of collapse operators. a_op : qutip.qobj. operator A. b_op : qutip.qobj. operator B. use_pinv : bool. If True use numpy’s pinv method, otherwise use a generic solver. Returns:spectrum : array. An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:tlist : array_like. list/array of times \(t\) which the correlation function is given. y : array_like. list/array of correlations corresponding to time delays \(t\). Returns:w, S : tuple. Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj. Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list. list of collapse operators, may be time-dependent for solver cho",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:97123,power,power,97123,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"fying the data for each quantum object is inefficient. Even more so when most objects correspond to commonly used types such as the ladder operators of a harmonic oscillator, the Pauli spin operators for a two-level system, or state vectors such as Fock states. Therefore, QuTiP includes predefined objects for a variety of states:. States; Command (# means optional); Inputs. Fock state ket vector; basis(N,#m)/fock(N,#m); N = number of levels in Hilbert space,; m = level containing excitation; (0 if no m given). Fock density matrix; (outer product of basis); fock_dm(N,#p); same as basis(N,m) / fock(N,m). Coherent state; coherent(N,alpha); alpha = complex number (eigenvalue); for requested coherent state. Coherent density matrix; (outer product); coherent_dm(N,alpha); same as coherent(N,alpha). Thermal density matrix; (for n particles); thermal_dm(N,n); n = particle number expectation value. and operators:. Operators; Command (# means optional); Inputs. Charge operator; charge(N,M=-N); Diagonal operator with entries; from M..0..N. Commutator; commutator(A, B, kind); Kind = ‘normal’ or ‘anti’. Diagonals operator; qdiags(N); Quantum object created from arrays of; diagonals at given offsets. Displacement operator; (Single-mode); displace(N,alpha); N=number of levels in Hilbert space,; alpha = complex displacement amplitude. Higher spin operators; jmat(j,#s); j = integer or half-integer; representing spin, s = ‘x’, ‘y’, ‘z’,; ‘+’, or ‘-‘. Identity; qeye(N); N = number of levels in Hilbert space. Lowering (destruction); operator; destroy(N); same as above. Momentum operator; momentum(N); same as above. Number operator; num(N); same as above. Phase operator; (Single-mode); phase(N, phi0); Single-mode Pegg-Barnett phase; operator with ref phase phi0. Position operator; position(N); same as above. Raising (creation); operator; create(N); same as above. Squeezing operator; (Single-mode); squeeze(N, sp); N=number of levels in Hilbert space,; sp = squeezing parameter. Squeezing op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-basics.html:4329,charge,charge,4329,docs/4.2/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-basics.html,6,['charge'],['charge']
Energy Efficiency,"g QuTiP with IPython notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:211072,schedul,scheduling,211072,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['schedul'],['scheduling']
Energy Efficiency,"g the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the othe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-steady.html:4943,power,power,4943,docs/4.2/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-steady.html,20,['power'],['power']
Energy Efficiency,"genenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; J_dat = J.data. Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices, J_dat.indptr),; shape=J_dat.shape). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices, J_dat.indptr),; shape=J_dat.shape); # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/metrics.html:13525,efficient,efficiently,13525,docs/4.4/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/metrics.html,1,['efficient'],['efficiently']
Energy Efficiency,"genvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = Qobj(np.multiply(cdg.full()*dyn.tau[k],; dyn._dyn_gen_factormatrix[k]), dims=dyn.dyn_dims); # Return to canonical basis; prop_grad = (dyn._dyn_gen_eigenvectors[k]*cdg*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; # put control dyn_gen in combined dg diagonal basis; cdg = dyn._get_dyn_gen_eigenvectors_adj(k).dot(; dyn._get_phased_ctrl_dyn_gen(k, j)).dot(; dyn._dyn_gen_eigenvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = np.multiply(cdg*dyn.tau[k], dyn._dyn_gen_factormatrix[k]); # Return to canonical basis; prop_grad = dyn._dyn_gen_eigenvectors[k].dot(cdg).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). if compute_prop:; return prop, prop_grad; else:; return prop_grad. class PropCompAugMat(PropagatorComputer):; """"""; Augmented Matrix (deprecated - see _Frechet). It should work for all systems, e.g. open, symplectic; There will be other PropagatorComputer subclasses that are more efficient; The _Frechet class should provide exactly the same functionality; more efficiently. Note the propagator gradient calculation using the augmented matrix; is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'AUG_MAT'; self.grad_exact = True; self.apply_params(). def _get_aug_mat(self, k, j):; """"""; Generate the matrix [[A, E], [0, A]] where; A is the overall dynamics generator; E is the control dynamics generator; for a given timeslot and control; returns this augmented matrix; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k). if dyn.oper_dtype == Qobj:; A = dg.data*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).data*dyn.tau[k]; Z = sp.csr_matrix(dg.data.shape); aug = Qobj(sp.vstack([sp.hstack([A, E]), sp.hstack([Z, A])])); elif dyn.oper_dtype == np.ndarray:; A = dg*dyn.tau",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:9916,efficient,efficient,9916,docs/4.2/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html,8,['efficient'],"['efficient', 'efficiently']"
Energy Efficiency,"genvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = Qobj(np.multiply(cdg.full()*dyn.tau[k],; dyn._dyn_gen_factormatrix[k]), dims=dyn.dyn_dims); # Return to canonical basis; prop_grad = (dyn._dyn_gen_eigenvectors[k]*cdg*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; # put control dyn_gen in combined dg diagonal basis; cdg = dyn._get_dyn_gen_eigenvectors_adj(k).dot(; dyn._get_phased_ctrl_dyn_gen(k, j)).dot(; dyn._dyn_gen_eigenvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = np.multiply(cdg*dyn.tau[k], dyn._dyn_gen_factormatrix[k]); # Return to canonical basis; prop_grad = dyn._dyn_gen_eigenvectors[k].dot(cdg).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). if compute_prop:; return prop, prop_grad; else:; return prop_grad. class PropCompAugMat(PropagatorComputer):; """"""; Augmented Matrix (deprecated - see _Frechet). It should work for all systems, e.g. open, symplectic; There will be other PropagatorComputer subclasses that are more efficient; The _Frechet class should provide exactly the same functionality; more efficiently. Note the propagator gradient calculation using the augmented matrix; is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'AUG_MAT'; self.grad_exact = True; self.apply_params(). def _get_aug_mat(self, k, j):; """"""; Generate the matrix [[A, E], [0, A]] where; A is the overall dynamics generator; E is the control dynamics generator; for a given timeslot and control; returns this augmented matrix; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k). if dyn.oper_dtype == Qobj:; A = dg.data*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).data*dyn.tau[k]; Z = sp.csr_matrix(dg.data.shape); aug = Qobj(sp.vstack([sp.hstack([A, E]), sp.hstack([Z, A])])); else:; A = dg*dyn.tau[k]; E = dyn._get_phased_ctrl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:9950,efficient,efficient,9950,docs/4.6/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html,8,['efficient'],"['efficient', 'efficiently']"
Energy Efficiency,"gger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing withou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:26538,power,power,26538,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,4,['power'],['power']
Energy Efficiency,"gram for the amplitudes of matrix M, using the argument; of each element for coloring the bars, with the given x and y labels; and title. Parameters:; M : Matrix of Qobj; The matrix to visualize. xlabels : list of strings; list of x labels. ylabels : list of strings; list of y labels. title : string; title of the plot (optional). limits : list/array with two float numbers; The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=Non",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:130795,energy,energy,130795,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"gs=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; task_vec (array / list) – The list or array of values for which the task function is to be; evaluated.; args (list / dictionary) – The optional additional argument to the task function. For example; a dictionary with parameter values.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result – The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. Return type:list. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:200856,schedul,scheduled,200856,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['schedul'],['scheduled']
Energy Efficiency,"gs['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; # set the weight to the mean of the non-zero absoluate values in A:; ss_args['weight'] = np.mean(np.abs(A.data.data)); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if (ss_args['solver'] == 'scipy' and ss_args['sparse']) \; or ss_args['solver'] == 'mkl':; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] in ['power', 'power-gmres',; 'power-lgmres', 'power-bicgstab']:; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args, has_mkl=0):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = int(np.sqrt(L.shape[0])); form = 'csr'; if has_mkl:; L = L.data + sp.csr_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])), shape=(n ** 2, n ** 2)); else:; form = 'csc'; L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:10858,power,power,10858,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,8,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"h = max(gate_cycle_indices); if current_length < max_length:; result = gate_cycle_indices; max_length = current_length; return result. if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit. # Generate the quantum operations dependency graph.; instructions_graph = InstructionsGraph(gates); instructions_graph.generate_dependency_graph(; commuting=self.commutation_rules); if self.method == ""ALAP"":; instructions_graph.reverse_graph(). # Schedule without hardware constraints, then; # use this cycles_list to compute the distance.; cycles_list, _ = instructions_graph.find_topological_order(; priority=False, apply_constraint=None, random=random_shuffle); instructions_graph.compute_distance(cycles_list=cycles_list). # Schedule again with priority and hardware constraint.; cycles_list, constraint_dependency = \; instructions_graph.find_topological_order(; priority=True, apply_constraint=self.apply_constraint,; random=random_shuffle). # If we only need gates schedule, we can output the result here.; if gates_schedule or return_cycles_list:; if self.method == ""ALAP"":; cycles_list.reverse(); if return_cycles_list:; return cycles_list; gate_cycles_indices = [0] * len(gates); for cycle_ind, cycle in enumerate(cycles_list):; for instruction_ind in cycle:; gate_cycles_indices[instruction_ind] = cycle_ind; return gate_cycles_indices. # For pulse schedule,; # we add the hardware dependency to the graph; # and compute the longest distance to the start node again.; # The longest distance to the start node determines; # the start time of each pulse.; instructions_graph.add_constraint_dependency(constraint_dependency); instructions_graph.compute_distance(cycles_list=cycles_list). # Output pulse schedule result.; instruction_start_time = []; if self.method == ""ASAP"":; for instruction in instructions_graph.nodes:; instruction_start_time.append(; instruction.distance_to_start - instruction.duration); elif self.method == ""ALAP"":; for instruction in instructions_g",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:18437,schedul,schedule,18437,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['schedule']
Energy Efficiency,"h to evaluate expectation values. c_ops : list of qutip.qobj. List of system collapse operators. args : dictionary. Placeholder for future implementation, kept for API consistency. options : qutip.solver.Options. Options for the solver. Returns:result: qutip.solver.Result. An instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. bloch_redfield_tensor(H, a_ops, spectra_cb, c_ops=None, use_secular=True)[source]¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system’s coupling; to its environment. Note; This tensor generation requires a time-independent Hamiltonian. Parameters:H : qutip.qobj. System Hamiltonian. a_ops : list of qutip.qobj. List of system operators that couple to the environment. spectra_cb : list of callback functions. List of callback functions that evaluate the noise power spectrum; at a given frequency. c_ops : list of qutip.qobj. List of system collapse operators. use_secular : bool. Flag (True of False) that indicates if the secular approximation should; be used. Returns:R, kets: qutip.Qobj, list of qutip.Qobj. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters:R : qutip.qobj. Bloch-Redfield tensor. ekets : array of qutip.qobj. Array of kets that make up a basis tranformation for the eigenbasis. rho0 : qutip.qobj. Initial density matrix. tlist : list / array. List of times for \(t\). e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. options : qutip.Qdeoptions. Options for the ODE solver. Returns:output: qutip.solver. An i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:55814,power,power,55814,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"hardware parameters of the SpinChain model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:11876,schedul,scheduler,11876,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,2,['schedul'],['scheduler']
Energy Efficiency,"hat the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. [docs]def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/metrics.html:12587,efficient,efficiently,12587,docs/4.7/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html,2,['efficient'],['efficiently']
Energy Efficiency,"he Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and nam",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:1681,efficient,efficiently,1681,docs/4.6/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html,2,['efficient'],['efficiently']
Energy Efficiency,"he bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve). This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html:4418,reduce,reduced,4418,docs/4.1/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html,10,['reduce'],['reduced']
Energy Efficiency,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/development.html:2084,Monitor,Monitoring,2084,docs/4.6/development/development.html,https://qutip.org,https://qutip.org/docs/4.6/development/development.html,1,['Monitor'],['Monitoring']
Energy Efficiency,"he excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex128); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # No",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/operators.html:22572,charge,charge,22572,docs/4.6/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html,4,['charge'],['charge']
Energy Efficiency,"he gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]; else:; return constraint_functions. [docs] def schedule(self, circuit, gates_schedule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `QubitCircuit`,; a list of `Gates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distanc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:13936,schedul,scheduler,13936,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['scheduler']
Energy Efficiency,"he name of the new unit (""J"", ""eV"", ""meV"", ""GHz"", ""mK""). Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""; if orig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit :",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:6642,energy,energy,6642,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,11,['energy'],['energy']
Energy Efficiency,"he old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; bl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/utilities.html:8267,energy,energy,8267,docs/4.6/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html,4,['energy'],['energy']
Energy Efficiency,"he old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_lis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:8315,energy,energy,8315,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,7,['energy'],['energy']
Energy Efficiency,"he second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction. Examples; --------; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; ``[gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]``; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles.; """"""; circuit = deepcopy(circuit); if repeat_num > 0:; random_shuffle = True; result = [0]; max_length = 4294967296; for i in range(repeat_num):; gate_cycle_indices = self.schedule(; circuit, gates_schedule=gates_schedule,; return_cycles_list=return_cycles_list,; random_shuffle=random_shuffle, repeat_num=0); current_length = max(gate_cycle_indices); if current_length < max_length:; result = gate_cycle_indices; max_length = current_length; return result. if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit. # Generate the quantum operations dependency graph.; instructions_graph = InstructionsGraph(gates); instructions_graph.generate_dependency",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:16772,schedul,schedule,16772,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['schedule']
Energy Efficiency,"her than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); dims = q_oper.dims; new_dims = [[dims[1][1], dims[0][1]], [dims[1][0], dims[0][0]]]; d0 = np.prod(np.ravel(new_dims[0])); d1 = np.prod(np.ravel(new_dims[1])); s0 = np.prod(dims[0][0]); s1 = np.prod(dims[1][1]); return Qobj(dims=new_dims,; inpt=data.reshape([s0, s1, s0, s1]).; transpose(3, 1, 2, 0).reshape((d0, d1))). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**floor(log2(dim)) == dim; for dim in flatten(dims); ]). def _super_to_superpauli(q_oper):; """"""; Converts a superoperator in the column-stacking basis to; the Pauli basis (assuming qubit dimensions). This is an internal function, as QuTiP does not currently have; a way to mark that superoperators are represented in the Pauli; basis as opposed to the column-stacking basis; a Pauli-basis; ``type='super'`` would thus break other conversion functions.; """"""; # Ensure we start with a column-stacking-basis superoperator.; sqobj = to_super(q_oper); if not _isqubitdims(sqobj.dims):; raise ValueError(""Pauli basis is only defined for qubits.""); nq = int(log2(sqobj.shape[0]) / 2); B = _pauli_basis(nq) / sqrt(2**nq); # To do this, we have to hack a bit and force the dims to match,; # since the _pauli_basis function makes different assumptions; # about indices than we need here.; B.dims = sqobj.dims; return (B.dag() ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html:6223,power,power,6223,docs/4.5/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html,5,['power'],['power']
Energy Efficiency,"how(). The advantage of the Monte Carlo method over the master equation approach is that only the state vector is required to be kept in the computers memory, as opposed to the entire density matrix. For large quantum system this becomes a significant advantage, and the Monte Carlo solver is therefore generally recommended for such systems. For example, simulating a Heisenberg spin-chain consisting of 10 spins with random parameters and initial states takes almost 7 times longer using the master equation rather than Monte Carlo approach with the default number of trajectories running on a quad-CPU machine. Furthermore, it takes about 7 times the memory as well. However, for small systems, the added overhead of averaging a large number of stochastic trajectories to obtain the open system dynamics, as well as starting the multiprocessing functionality, outweighs the benefit of the minor (in this case) memory saving. Master equation methods are therefore generally more efficient when Hilbert space sizes are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html:12011,efficient,efficient,12011,docs/4.2/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html,11,['efficient'],['efficient']
Energy Efficiency,"hstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2), _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (target) + [U] +; [identity(2)] * (N - target - 1)). [docs]def gate_expand_2toN(U, N, c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/qip/gates.html:18901,reduce,reduce,18901,docs/4.1/modules/qutip/qip/gates.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/qip/gates.html,6,['reduce'],['reduce']
Energy Efficiency,"i.e. Qobj, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not requi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html:2004,efficient,efficiently,2004,docs/4.6/development/ideas/tensorflow-data-backend.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html,4,['efficient'],['efficiently']
Energy Efficiency,iP 4.6 Documentation; qutip.control.dynamics — QuTiP 4.6 Documentation; qutip.control.fidcomp — QuTiP 4.6 Documentation; qutip.control.optimizer — QuTiP 4.6 Documentation; qutip.control.optimresult — QuTiP 4.6 Documentation; qutip.control.propcomp — QuTiP 4.6 Documentation; qutip.control.pulsegen — QuTiP 4.6 Documentation; qutip.control.pulseoptim — QuTiP 4.6 Documentation; qutip.control.stats — QuTiP 4.6 Documentation; qutip.control.termcond — QuTiP 4.6 Documentation; qutip.control.tslotcomp — QuTiP 4.6 Documentation. /nonmarkov; ; qutip.nonmarkov.heom — QuTiP 4.6 Documentation; qutip.nonmarkov.memorycascade — QuTiP 4.6 Documentation; qutip.nonmarkov.transfertensor — QuTiP 4.6 Documentation. /qip; . /algorithms; ; qutip.qip.algorithms.qft — QuTiP 4.6 Documentation. /compiler; ; qutip.qip.compiler.cavityqedcompiler — QuTiP 4.6 Documentation; qutip.qip.compiler.gatecompiler — QuTiP 4.6 Documentation; qutip.qip.compiler.instruction — QuTiP 4.6 Documentation; qutip.qip.compiler.scheduler — QuTiP 4.6 Documentation; qutip.qip.compiler.spinchaincompiler — QuTiP 4.6 Documentation. /device; ; qutip.qip.device.cavityqed — QuTiP 4.6 Documentation; qutip.qip.device.modelprocessor — QuTiP 4.6 Documentation; qutip.qip.device.optpulseprocessor — QuTiP 4.6 Documentation; qutip.qip.device.processor — QuTiP 4.6 Documentation; qutip.qip.device.spinchain — QuTiP 4.6 Documentation. /operations; ; qutip.qip.operations.gates — QuTiP 4.6 Documentation. qutip.qip.circuit — QuTiP 4.6 Documentation; qutip.qip.noise — QuTiP 4.6 Documentation; qutip.qip.pulse — QuTiP 4.6 Documentation; qutip.qip.qasm — QuTiP 4.6 Documentation; qutip.qip.qubits — QuTiP 4.6 Documentation. qutip.about — QuTiP 4.6 Documentation; qutip.bloch — QuTiP 4.6 Documentation; qutip.bloch_redfield — QuTiP 4.6 Documentation; qutip.continuous_variables — QuTiP 4.6 Documentation; qutip.correlation — QuTiP 4.6 Documentation; qutip.dimensions — QuTiP 4.6 Documentation; qutip.distributions — QuTiP 4.6 Documentation; qutip.entropy,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:54043,schedul,scheduler,54043,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['schedul'],['scheduler']
Energy Efficiency,"iag. [docs]def wigner(psi, xvec, yvec, method='clenshaw', g=sqrt(2), ; sparse=False, parfor=False):; """"""Wigner function for a state vector or density matrix at points; `xvec + i * yvec`. Parameters; ----------. state : qobj; A state vector or density matrix. xvec : array_like; x-coordinates at which to calculate the Wigner function. yvec : array_like; y-coordinates at which to calculate the Wigner function. Does not; apply to the 'fft' method. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`. method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}; Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw' ; and 'iterative' use an iterative method to evaluate the Wigner functions for density; matrices :math:`|m><n|`, while 'laguerre' uses the Laguerre polynomials; in scipy for the same task. The 'fft' method evaluates the Fourier; transform of the density matrix. The 'iterative' method is default, and; in general recommended, but the 'laguerre' method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The 'clenshaw' method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). 'clenshaw' is a fast and numerically stable method. sparse : bool {False, True}; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance.; ; parfor : bool {False, True}; Flag for calculating the Laguerre polynomial based Wigner function; method='laguerre' in parallel using the parfor function. Returns; -------. W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; -----; The 'fft' method accepts only an xvec input for the x-coordinate.; The y-c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/wigner.html:3708,efficient,efficient,3708,docs/4.1/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/wigner.html,4,['efficient'],['efficient']
Energy Efficiency,"ich to evaluate expectation values. c_ops : list of qutip.qobj. List of system collapse operators. args : dictionary. Placeholder for future implementation, kept for API consistency. options : qutip.solver.Options. Options for the solver. Returns:result: qutip.solver.Result. An instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. bloch_redfield_tensor(H, a_ops, spectra_cb, c_ops=[], use_secular=True)[source]¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system’s coupling; to its environment. Note; This tensor generation requires a time-independent Hamiltonian. Parameters:H : qutip.qobj. System Hamiltonian. a_ops : list of qutip.qobj. List of system operators that couple to the environment. spectra_cb : list of callback functions. List of callback functions that evaluate the noise power spectrum; at a given frequency. c_ops : list of qutip.qobj. List of system collapse operators. use_secular : bool. Flag (True of False) that indicates if the secular approximation should; be used. Returns:R, kets: qutip.Qobj, list of qutip.Qobj. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters:R : qutip.qobj. Bloch-Redfield tensor. ekets : array of qutip.qobj. Array of kets that make up a basis tranformation for the eigenbasis. rho0 : qutip.qobj. Initial density matrix. tlist : list / array. List of times for \(t\). e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. options : qutip.Qdeoptions. Options for the ODE solver. Returns:output: qutip.solver. An i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:64790,power,power,64790,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"ics (uses steady state rho0). Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. wlist : *list* / *array*; list of frequencies for :math:`\\omega`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. a_op : :class:`qutip.qobj`; operator A. b_op : :class:`qutip.qobj`; operator B. solver : str; choice of solver (`es` for exponential series and; `pi` for psuedo-inverse). use_pinv : bool; For use with the `pi` solver: if `True` use numpy's pinv method,; otherwise use a generic solver. Returns; -------. spectrum: *array*; An *array* with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(taulist, y):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------. tlist : *list* / *array*; list/array of times :math:`t` which the correlation function is given. y : *list* / *array*; list/array of correlations corresponding to time delays :math:`t`. Returns; -------. w, S : *tuple*; Returns an array of angular frequencies 'w' and the corresponding; one-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]). N = len(taulist); dt = taulist[1] - taulist[0]. F = scipy.fftpack.fft(y). # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # select only indices for elements that corresponds; # to positive frequencies; indices = np.where(f > 0.0). return 2 * np.pi * f[indices], 2 * dt * np.real(F[indices]). # -----------------------------------------------------------------------------; # LEGACY API; # -----------------------------------------------------------------------------. # low level correlation. [docs",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:18322,power,power,18322,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['power'],['power']
Energy Efficiency,"ient and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function. The function that is to be called for each value in task_vec. values: array / list. The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary. The optional additional argument to the task function. task_kwargs: list / dictionary. The optional additional keyword argument to the task function. client: IPython.parallel.Client. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False. Display a HTML-based progress bar during the execution of the parfor; loop. Returns:result : list. The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string. Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]¶; Simulateous diagonalization of communting Hermitian matrices.. Paramete",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:200727,schedul,scheduled,200727,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['schedul'],['scheduled']
Energy Efficiency,"ient and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function. The function that is to be called for each value in task_vec. values: array / list. The list or array of values for which the task function is to be; evaluated. task_args: list / dictionary. The optional additional argument to the task function. task_kwargs: list / dictionary. The optional additional keyword argument to the task function. client: IPython.parallel.Client. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False. Display a HTML-based progress bar during the execution of the parfor; loop. Returns:result : list. The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_table: string. Return an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()¶; About box for qutip. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)¶; Simulateous diagonalization of communting Hermitian matrices.. Parameters:ops : list/ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:163325,schedul,scheduled,163325,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['schedul'],['scheduled']
Energy Efficiency,"ifferent; quantum states at fixed phase-space points ``0.5*g* (xvec + i*yvec)``.; This class has slightly higher first-usage costs than :obj:`.qfunc`, but; subsequent operations will be several times faster. However, it can require; quite a lot of memory. Call the created object as a function to retrieve; the Husimi-Q function. Parameters; ----------; xvec, yvec : array_like; x- and y-coordinates at which to calculate the Husimi-Q function. g : float, default sqrt(2); Scaling factor for ``a = 0.5 * g * (x + iy)``. The value of `g` is; related to the value of `hbar` in the commutation relation; :math:`[x,\,y] = i\hbar` via :math:`\hbar=2/g^2`, so the default; corresponds to :math:`\hbar=1`. memory : real, default 1024; Size in MB that may be used internally as workspace. This class will; raise ``MemoryError`` if subsequently passed a state of sufficiently; large dimension that this bound would be exceeded. In those cases, use; :obj:`.qfunc` with ``precompute_memory=None`` instead to force using; the slower, more memory-efficient algorithm. Examples; --------; Initialise the class for a square set of coordinates, with some states we; want to investigate. >>> xvec = np.linspace(-2, 2, 101); >>> states = [qutip.rand_dm(10) for _ in [None]*10]; >>> qfunc = qutip.QFunc(xvec, xvec). Now we can calculate the Husimi-Q function over each of the states more; efficiently with:. >>> husimiq = np.array([qfunc(state) for state in states]). See Also; --------; :obj:`.qfunc` :; a single function version, which will involve computing several; quantities multiple times in order to use less memory.; """""". def __init__(; self, xvec, yvec, g: float = np.sqrt(2), memory: float = 1024; ):; self._g = g; self._coherent_grid = _QFuncCoherentGrid(xvec, yvec, g); # 16 bytes per complex, 1024**2 bytes per MB.; self._size_mb = self._coherent_grid.grid.size * 16 / (1024 ** 2); self._memory_mb = memory; self._max_size = int(self._memory_mb // self._size_mb); self._current_size = 0; self._cache = None",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:21928,efficient,efficient,21928,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,4,['efficient'],['efficient']
Energy Efficiency,"ified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(self, t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(self, rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:38556,reduce,reduced,38556,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['reduce'],['reduced']
Energy Efficiency,"ified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(self, t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(self, rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adam",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:37576,reduce,reduced,37576,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['reduce'],['reduced']
Energy Efficiency,"igsize); ax = Axes3D(fig, azim=-62, elev=25). if cmap is None:; cmap = mpl.cm.get_cmap('RdBu'). lim = abs(self.data).max(). X, Y = np.meshgrid(self.xvecs[0], self.xvecs[1]); s = ax.plot_surface(X, Y, self.data,; norm=mpl.colors.Normalize(-lim, lim),; rstride=5, cstride=5, cmap=cmap, lw=0.1). if show_xlabel:; ax.set_xlabel(self.xlabels[0], fontsize=12); if show_ylabel:; ax.set_ylabel(self.xlabels[1], fontsize=12). if colorbar:; cb = fig.colorbar(s, ax=ax, shrink=0.5). return fig, ax. def visualize_1d(self, fig=None, ax=None, figsize=(8, 6),; show_xlabel=True, show_ylabel=True):. if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). p = ax.plot(self.xvecs[0], self.data). if show_xlabel:; ax.set_xlabel(self.xlabels[0], fontsize=12); if show_ylabel:; ax.set_ylabel(""Marginal distribution"", fontsize=12). return fig, ax. [docs] def marginal(self, dim=0):; """"""; Calculate the marginal distribution function along the dimension; `dim`. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns; -------. d : Distributions; A new instances of Distribution that describes the marginal; distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/distributions.html:6890,reduce,reduced,6890,docs/4.2/modules/qutip/distributions.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/distributions.html,11,['reduce'],['reduced']
Energy Efficiency,"ilities import clebsch; from scipy.misc import factorial. [docs]def wigner(psi, xvec, yvec, method='iterative', g=sqrt(2), parfor=False):; """"""Wigner function for a state vector or density matrix at points; `xvec + i * yvec`. Parameters; ----------. state : qobj; A state vector or density matrix. xvec : array_like; x-coordinates at which to calculate the Wigner function. yvec : array_like; y-coordinates at which to calculate the Wigner function. Does not; apply to the 'fft' method. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`. method : string {'iterative', 'laguerre', 'fft'}; Select method 'iterative', 'laguerre', or 'fft', where 'iterative' uses; an iterative method to evaluate the Wigner functions for density; matrices :math:`|m><n|`, while 'laguerre' uses the Laguerre polynomials; in scipy for the same task. The 'fft' method evaluates the Fourier; transform of the density matrix. The 'iterative' method is default, and; in general recommended, but the 'laguerre' method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The 'fft' method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). parfor : bool {False, True}; Flag for calculating the Laguerre polynomial based Wigner function; method='laguerre' in parallel using the parfor function. Returns; -------. W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; -----; The 'fft' method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally. References; ----------. Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). """""". if not (psi.type == 'ket' or psi.type == 'oper' or psi.type == 'bra'):; raise TypeError('Input state is not a valid operator.')",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/wigner.html:4864,efficient,efficient,4864,docs/3.1.0/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/wigner.html,1,['efficient'],['efficient']
Energy Efficiency,"im_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters:; H (qutip.qobj) – system Hamiltonian.; wlist (array_like) – list of frequencies for \(\omega\).; c_ops (list of qutip.qobj) – list of collapse operators.; a_op (qutip.qobj) – operator A.; b_op (qutip.qobj) – operator B.; use_pinv (bool) – If True use numpy’s pinv method, otherwise use a generic solver. Returns:spectrum – An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. Return type:array. spectrum_correlation_fft(taulist, y)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:; tlist (array_like) – list/array of times \(t\) which the correlation function is given.; y (array_like) – list/array of correlations corresponding to time delays \(t\). Returns:w, S – Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. Return type:tuple. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:97803,power,power,97803,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"ime Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more ro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:1999,energy,energy,1999,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,20,"['energy', 'power']","['energy', 'power']"
Energy Efficiency,"imeslot using the exponentiation of the the augmented; matrix.; The propagtor is calculated for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k); aug = self._get_aug_mat(k, j). if dyn.oper_dtype == Qobj:; aug_exp = aug.expm(); prop_grad = Qobj(aug_exp.data[:dg.shape[0], dg.shape[1]:],; dims=dyn.dyn_dims); if compute_prop:; prop = Qobj(aug_exp.data[:dg.shape[0], :dg.shape[1]],; dims=dyn.dyn_dims); else:; aug_exp = la.expm(aug); prop_grad = aug_exp[:dg.shape[0], dg.shape[1]:]; if compute_prop:; prop = aug_exp[:dg.shape[0], :dg.shape[1]]. if compute_prop:; return prop, prop_grad; else:; return prop_grad. [docs]class PropCompFrechet(PropagatorComputer):; """"""; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; :obj:`PropagatorComputer` subclasses that may be more efficient.; """"""; [docs] def reset(self):; PropagatorComputer.reset(self); self.id_text = 'FRECHET'; self.grad_exact = True; self.apply_params(). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot using the expm_frechet method; The propagtor is calculated (almost) for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent. if dyn.oper_dtype == Qobj:; A = dyn._get_phased_dyn_gen(k).full()*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).full()*dyn.tau[k]; if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = Qobj(prop_dense, dims=dyn.dyn_dims); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); else:; A = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; E = dyn.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html:12240,efficient,efficient,12240,docs/4.6/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/propcomp.html,4,['efficient'],['efficient']
Energy Efficiency,"in x_alphas; ... ]; ... for y_alphas in all_alphas; ... ]). The naive approach is typically several of orders of magnitude slower than; this class, which uses much simpler vectorised operations. The outputs are; within close tolerance, however:. >>> np.allclose(naive, grid(max_ns)); True; >>> np.allclose(naive[:, :, 4:7], grid(4, 7)); True; """"""; def __init__(self, xvec, yvec, g: float):; self.xvec, self.yvec = _qfunc_check_coordinates(xvec, yvec); x, y = np.meshgrid(0.5 * g * self.xvec, 0.5 * g * self.yvec); self.grid = np.empty(x.shape, dtype=np.complex128); self.grid.real = x; # We produce the adjoint of the coherent states to save an operation; # later when computing dot products, hence the negative imaginary part.; self.grid.imag = -y; self.prefactor = np.exp(-0.5 * (x * x + y * y)).astype(np.complex128). def _start(self, first: int):; """"""; Get the coherent state matrix corresponding to the first needed Fock; state.; """"""; if first == 0:; return self.prefactor.copy(); out = np.power(self.grid, first); out *= self.prefactor; return out. def __call__(self, first: int, last: int = None):; """"""; Get a 3D array of shape ``(yvec.size, xvec.size, last - first)`` of the; coherent-state vectors for all the Fock states in the range ``first``; to ``last``, excluding the end point. The first two axes are the y-; and x-coordinates of phase space (i.e. Cartesian indexing, like; ``numpy.meshgrid``), and the last runs over the selected range of; Fock-space dimensions.; """"""; ns = np.arange(first, last).reshape(1, 1, -1); # Technically we could avoid hitting the limits of floating-point; # exponents for longer by doing all this in logarithmic space (using; # scipy.special.gammaln), but that ends up involving more; # floating-point operations overall, and needs special care around the; # point alpha = 0 to avoid nan appearing, due to how Python handles; # mixed-width arithmetic operations.; out = np.empty(self.grid.shape + (ns.size,), dtype=np.complex128); out[:, :, 0] = self._start(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:19654,power,power,19654,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,4,['power'],['power']
Energy Efficiency,"ing for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and nam",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:1768,efficient,efficiently,1768,docs/4.7/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html,2,['efficient'],['efficiently']
Energy Efficiency,"ing task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 3.03s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.03s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.04s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.04s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.05s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.05s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.06s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.06s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.07s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.07s. Est. time left: 00:00:00:00; Total run time: 25.12s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-parfor.html:7138,power,powerful,7138,docs/4.0.2/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-parfor.html,1,['power'],['powerful']
Energy Efficiency,"ing] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Given the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user-defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.bloch_redfield.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:3795,efficient,efficient,3795,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['efficient'],['efficient']
Energy Efficiency,"ings) – list of x labels; ylabels (list of strings) – list of y labels; title (string) – title of the plot (optional); limits (list/array with two float numbers) – The z-axis limits [min, max] (optional); phase_limits (list/array with two float numbers) – The phase-axis (colorbar) limits [min, max] (optional); ax (a matplotlib axes instance) – The axes context in which the plot will be drawn.; threshold (float (None)) – Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list (List of Qobj) – A list of Hamiltonians.; labels (List of string) – A list of labels for each Hamiltonian; show_ylabels (Bool (default False)) – Show y labels to the left of energy levels of the initial; Hamiltonian.; N (int) – The number of energy levels to plot; figsize (tuple (int,int)) – The size of the figure (width, height).; fig (a matplotlib Figure instance) – The Figure canvas in which the plot will be drawn.; ax (a matplotlib axes instance) – The axes context in which the plot will be drawn. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:; rho ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:117338,energy,energy,117338,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"inimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated aut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:137477,power,power,137477,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['power'],['power']
Energy Efficiency,"int; The number of Dicke ladders. num_tls(nds)[source]¶; Calculate the number of two-level systems. Parameters:; nds: int; The number of Dicke states. Returns:; N: int; The number of two-level systems. isdiagonal(mat)[source]¶; Check if the input matrix is diagonal. Parameters:; mat: ndarray/Qobj; A 2D numpy array. Returns:; diag: bool; True/False depending on whether the input matrix is diagonal. state_degeneracy(N, j)[source]¶; Calculate the degeneracy of the Dicke state.; Each state \(|j, m\rangle\) includes D(N,j) irreducible; representations \(|j, m, \alpha\rangle\).; Uses Decimals to calculate higher numerator and denominators numbers. Parameters:; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns:; degeneracy: int; The state degeneracy. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(|j, m\rangle\) with; same energy. Parameters:; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue (proportional to the total; energy). Returns:; degeneracy: int; The m-degeneracy. ap(j, m)[source]¶; Calculate the coefficient ap by applying J_+ |j, m>.; The action of ap is given by:; \(J_{+}|j, m\rangle = A_{+}(j, m)|j, m+1\rangle\). Parameters:; j, m: float; The value for j and m in the dicke basis |j,m>. Returns:; a_plus: float; The value of \(a_{+}\). am(j, m)[source]¶; Calculate the operator am used later.; The action of ap is given by: J_{-}|j, m> = A_{-}(jm)|j, m-1>. Parameters:; j: float; The value for j. m: float; The value for m. Returns:; a_minus: float; The value of \(a_{-}\). spin_algebra(N, op=None)[source]¶; Create the list [sx, sy, sz] with the spin operators.; The operators are constructed for a collection of N two-level systems; (TLSs). Each element of the list, i.e., sx, is a vector of qutip.Qobj; objects (spin matrices), as it cointains the list of the SU(2) Pauli; matrices for the N TLSs. Each TLS operator sx[i], with i = 0, …, (N-1),; is placed in a \(2^N",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:121198,energy,energy,121198,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"ion_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so ; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-correlation.html:5162,power,power,5162,docs/4.7/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html,2,['power'],['power']
Energy Efficiency,"ionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Sinc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:181354,schedul,scheduler,181354,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['schedul'],['scheduler']
Energy Efficiency,"ions. Options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. fmmesolve(H, rho0, tlist, c_ops, e_ops=, []spectra_cb=, []T=None, args={}, options=<qutip.solver.Options instance at 0x2ac686946518>, floquet_basis=True, kmax=5)¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:H : qutip.qobj. system Hamiltonian. rho0 / psi0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.qobj. list of collapse operators. e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. spectra_cb : list callback functions. List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:47588,power,power,47588,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"ions. Options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. fmmesolve(H, rho0, tlist, c_ops, e_ops=, []spectra_cb=, []T=None, args={}, options=<qutip.solver.Options instance at 0x2b11f68454d0>, floquet_basis=True, kmax=5)¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:H : qutip.qobj. system Hamiltonian. rho0 / psi0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.qobj. list of collapse operators. e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. spectra_cb : list callback functions. List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:47650,power,power,47650,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"ions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)¶\[\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2). If the environmental ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:1666,monitor,monitored,1666,docs/4.7/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html,2,['monitor'],['monitored']
Energy Efficiency,"ions_cycles[cycle_ind1]:; for instruction_ind2 in instructions_cycles[cycle_ind1+1]:; self.nodes[instruction_ind1].successors.add(; instruction_ind2); self.nodes[instruction_ind2].predecessors.add(; instruction_ind1). # Find start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. def reverse_graph(self):; """"""; Reverse the graph.; The start node becomes the end node; Predecessors and successors of each node are exchanged.; """"""; for node in self.nodes:; node.predecessors, node.successors \; = node.successors, node.predecessors; try:; self.distance_to_start, self.distance_to_end = \; self.distance_to_end, self.distance_to_start; except AttributeError:; pass; self.start, self.end = self.end, self.start. def find_topological_order(; self, priority=True, apply_constraint=None, random=False):; """"""; A list-schedule algorithm, it; finds the topological order of the directed graph; under certain constraint and priority indicator.; The function returns a list of cycles,; where each cycle is a list of instructions; that can be executed in parallel.; In the case of gates schedule,; the result will be the gates cycle list. Parameters; ----------; priority: bool; If use distance to the start and end nodes; as a priority measure for the schedule problem.; apply_constraint: function; A Python function that determines; if to instruction can be executed in parallel.; E.g. if two gates apply to the same qubit, the function; returns False. Returns; -------; cycles_list: list; A list of cycles, where each cycle is a list of instructions; that can be executed in parallel.; constraint_dependency: set; A set of instruction pairs that are found conflicted; due to the hardware constraints.; Because of this, they are executed in different cycles.; This set is used to add this dependency to the graph; in another method",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:7170,schedul,schedule,7170,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['schedule']
Energy Efficiency,"ip.Qdeoptions; Options for the ODE solver. Returns:; output: :class:`qutip.solver`; An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:; H : qutip.qobj; system Hamiltonian. rho0 / psi0 : qutip.qobj; initial density matrix or state vector (ket). tlist : list / array; list of times for \(t\). c_ops : list of qutip.qobj; list of collapse operators. e_ops : list of qutip.qobj / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float; The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary; dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns:; output : qutip.solver; An instance of the class qutip.solver, which contains either; an array of expectatio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:69477,power,power,69477,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"ip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. options : :class:`qutip.solver.Options`; options for the ODE solver. For the propagator U. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args=args, options=copy(options)). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None,; options=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:3028,energy,energy,3028,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['energy'],['energy']
Energy Efficiency,"irect or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State Solutions for Arbitrary Systems¶. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument.; Available Steady-State Methods:. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the eigenvector corresponding to the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Iteratively solve for the steady-state solution using the inverse-power method. GMRES; ‘iterative-gmres’; Iteratively solve for the steady-state solution using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Iteratively solve for the steady-state solution using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Iteratively solve for the steady-state solution using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the SVD of the Liouvillian represented by a dense matrix. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, an arbitrary Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian for the system. Using the S",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-steady.html:3392,power,power,3392,docs/3.1.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html,2,['power'],['power']
Energy Efficiency,"ires.png, pdf). Husimi Q-function¶; The Husimi Q function is, like the Wigner function, a quasiprobability; distribution for harmonic modes. It is defined as. \[Q(\alpha) = \frac{1}{\pi}\left<\alpha|\rho|\alpha\right>\]; where \(\left|\alpha\right>\) is a coherent state and; \(\alpha = x + iy\). In QuTiP, the Husimi Q function can be computed given; a state ket or density matrix using the function qfunc, as; demonstrated below.; Q_coherent = qfunc(rho_coherent, xvec, xvec); Q_thermal = qfunc(rho_thermal, xvec, xvec); Q_fock = qfunc(rho_fock, xvec, xvec); fig, axes = plt.subplots(1, 3, figsize=(12,3)); cont0 = axes[0].contourf(xvec, xvec, Q_coherent, 100); lbl0 = axes[0].set_title(""Coherent state""); cont1 = axes[1].contourf(xvec, xvec, Q_thermal, 100); lbl1 = axes[1].set_title(""Thermal state""); cont0 = axes[2].contourf(xvec, xvec, Q_fock, 100); lbl2 = axes[2].set_title(""Fock state""); plt.show(). (png, hires.png, pdf). If you need to calculate the Q function for many states with the same; phase-space coordinates, it is more efficient to use the QFunc class.; This stores various intermediary results to achieve an order-of-magnitude; improvement compared to calling qfunc in a loop.; xs = np.linspace(-1, 1, 101); qfunc_calculator = qutip.QFunc(xs, xs); q_state1 = qfunc_calculator(qutip.rand_dm(5)); q_state2 = qfunc_calculator(qutip.rand_ket(100)). Visualizing operators¶; Sometimes, it may also be useful to directly visualizing the underlying matrix; representation of an operator. The density matrix, for example, is an operator; whose elements can give insights about the state it represents, but one might; also be interesting in plotting the matrix of an Hamiltonian to inspect the; structure and relative importance of various elements.; QuTiP offers a few functions for quickly visualizing matrix data in the; form of histograms, qutip.visualization.matrix_histogram and; qutip.visualization.matrix_histogram_complex, and as Hinton diagram of weighted; squares, qutip.visualiza",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-visualization.html:8599,efficient,efficient,8599,docs/4.6/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-visualization.html,2,['efficient'],['efficient']
Energy Efficiency,"is spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters:; H : qutip.qobj; system Hamiltonian. wlist : array_like; list of frequencies for \(\omega\). c_ops : list of qutip.qobj; list of collapse operators. a_op : qutip.qobj; operator A. b_op : qutip.qobj; operator B. use_pinv : bool; If True use numpy’s pinv method, otherwise use a generic solver. Returns:; spectrum : array; An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:; tlist : array_like; list/array of times \(t\) which the correlation function is given. y : array_like; list/array of correlations corresponding to time delays \(t\). inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns:; w, S : tuple; Returns an array of angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:98088,power,power,98088,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"is spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters; ----------; H : :class:`qutip.qobj`; system Hamiltonian.; wlist : array_like; list of frequencies for :math:`\omega`.; c_ops : list; list of collapse operators.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; solver : str; choice of solver (`es` for exponential series and; `pi` for psuedo-inverse).; use_pinv : bool; For use with the `pi` solver: if `True` use numpy's pinv method,; otherwise use a generic solver. Returns; -------; spectrum : array; An array with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(tlist, y, inverse=False):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`.; inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; two-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]); tlist = np.asarray(tlist); N = tlist.shape[0]; dt = tlist[1] - tlist[0]; if not np.allclose(np.diff(tlist), dt*np.ones(N-1,dtype=float)):; raise Exception('tlist must be equally spaced for FFT.'). if inverse:; F = N * scipy.fftpack.ifft(y); else:; F = scipy.fftpack.fft(y). # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # re-order frequencies from most negative to most positive (cent",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:17715,power,power,17715,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,4,['power'],['power']
Energy Efficiency,"is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:184540,schedul,schedule,184540,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['schedul'],['schedule']
Energy Efficiency,"istance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:185069,schedul,scheduling,185069,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['schedul'],['scheduling']
Energy Efficiency,"istribution(data=None, xvecs=[], xlabels=[])[source]¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:data : array_like. Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list. List of arrays that spans the space for each coordinate. xlabels : list. List of labels for each coordinate. Methods. marginal. project. visualize. visualize_1d. visualize_2d_colormap. visualize_2d_surface. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d : Distributions. A new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d : Distributions. A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualiz",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:33712,reduce,reduced,33712,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['reduce'],['reduced']
Energy Efficiency,"it, or set to `None` to suppress warning.""; ); alpha_grid = _QFuncCoherentGrid(xvec, yvec, g); if state.isket:; out = _qfunc_iterative_single(state.full().ravel(), alpha_grid, g); out /= np.pi; return out; # We don't use Qobj.eigenstates() to avoid building many unnecessary CSR; # versions of dense matrices.; values, vectors = eigh(state.full()); vectors = vectors.T; out = values[0] * _qfunc_iterative_single(vectors[0], alpha_grid, g); for value, vector in zip(values[1:], vectors[1:]):; out += value * _qfunc_iterative_single(vector, alpha_grid, g); out /= np.pi; return out. # -----------------------------------------------------------------------------; # PSEUDO DISTRIBUTION FUNCTIONS FOR SPINS; #; [docs]def spin_q_function(rho, theta, phi):; r""""""The Husimi Q function for spins is defined as ``Q(theta, phi) =; SCS.dag() * rho * SCS`` for the spin coherent state ``SCS = spin_coherent(; j, theta, phi)`` where j is the spin length.; The implementation here is more efficient as it doesn't; generate all of the SCS at theta and phi (see references). The spin Q function is normal when integrated over the surface of the; sphere. .. math:: \frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1. Parameters; ----------; state : qobj; A state vector or density matrix for a spin-j quantum system.; theta : array_like; Polar (colatitude) angle at which to calculate the Husimi-Q function.; phi : array_like; Azimuthal angle at which to calculate the Husimi-Q function. Returns; -------; Q, THETA, PHI : 2d-array; Values representing the spin Husimi Q function at the values specified; by THETA and PHI. References; ----------; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. """""". if rho.type == 'bra':; rho = rho.dag(). if rho.type == 'ket':; rho = ket2dm(rho). J = rho.shape[0]; j = (J - 1) / 2. THETA, PHI = meshgrid(theta, phi). Q = np.zeros_like(THETA, dtype=complex). for m1 in arange(-j, j + 1)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:28109,efficient,efficient,28109,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,4,['efficient'],['efficient']
Energy Efficiency,"it,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2),; _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:31198,reduce,reduce,31198,docs/4.6/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html,2,['reduce'],['reduce']
Energy Efficiency,"iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(L*v); if settings.debug:; logger.debug('Number of iterations: %i' % it). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. # normalise according to type of problem; if sflag:; trow = v[::rhoss.shape[0]+1]; data = v / np.sum(trow); else:; data = data / la.norm(v). data = dense2D_to_fastcsr_fmode(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:25794,power,power-gmres,25794,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,9,['power'],"['power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"ith maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thfloatThe temperature in units of frequency (or the same units as w). Returns. n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestr or pathlib.PathName of file containing reqested data. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:259082,energy,energy,259082,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"ith maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thfloatThe temperature in units of frequency (or the same units as w). Returns. n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:246964,energy,energy,246964,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"ith respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:9312,reduce,reduces,9312,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,6,['reduce'],['reduces']
Energy Efficiency,"ith two float numbers) – The phase-axis (colorbar) limits [min, max] (optional); ax (a matplotlib axes instance) – The axes context in which the plot will be drawn.; threshold (float (None)) – Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list (List of Qobj) – A list of Hamiltonians.; labels (List of string) – A list of labels for each Hamiltonian; show_ylabels (Bool (default False)) – Show y labels to the left of energy levels of the initial; Hamiltonian.; N (int) – The number of energy levels to plot; figsize (tuple (int,int)) – The size of the figure (width, height).; fig (a matplotlib Figure instance) – The Figure canvas in which the plot will be drawn.; ax (a matplotlib axes instance) – The axes context in which the plot will be drawn. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:; rho (qutip.qobj.Qobj) – The density matrix (or ket) of the state to visualize.; fig (a matplotlib Figure instance) – The Figure canvas in which the plot will be drawn.; ax (a matplotlib axes instance) – The axes context in which the p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:117663,energy,energy,117663,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"ithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thfloatThe temperature in units of frequency (or the same units as w). Returns. n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestr or pathlib.PathName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=',')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestr or pathlib.Pat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:259353,energy,energy,259353,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"ithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thfloatThe temperature in units of frequency (or the same units as w). Returns. n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=',')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestrName of data file to be stored,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:247235,energy,energy,247235,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"itslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, axes=None, figsize=(8, 4))[source]¶; Visualize the results (expectation values) for an evolution solver.; results is assumed to be an instance of Result, or a list of Result; instances. Parameters. results(list of) qutip.solver.ResultList of results objects returned by any of the QuTiP evolution solvers. ylabelslist of stringsThe y-axis labels. List should be of the same length as results. titlestringThe title of the figure. show_legendboolWheth",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:168577,energy,energy,168577,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['energy'],['energy']
Energy Efficiency,"itslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters. rhoqutip.qobj.QobjThe density matrix (or ket) of the state to visualize. figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. titlestringAn optional title for the figure. figsize(width, height)The size of the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:130985,energy,energy,130985,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"itten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (ja",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html:2094,efficient,efficiently,2094,docs/4.6/development/ideas/tensorflow-data-backend.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html,4,['efficient'],['efficiently']
Energy Efficiency,"ity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [3]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as $f_{PSU}$ this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [4]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRA",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:9358,reduce,reduces,9358,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['reduce'],['reduces']
Energy Efficiency,"ix elements for an operator.""). else:; if bra.isbra and ket.isket:; return zcsr_mat_elem(self.data, bra.data, ket.data, 1). elif bra.isket and ket.isket:; return zcsr_mat_elem(self.data, bra.data, ket.data, 0); else:; err = ""Can only calculate matrix elements for bra""; err += "" and ket vectors.""; raise TypeError(err). [docs] def overlap(self, other):; """"""Overlap between two state vectors or two operators. Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters; -----------; other : :class:`qutip.Qobj`; Quantum object for a state vector of type 'ket', 'bra' or density; matrix. Returns; -------; overlap : complex; Complex valued overlap. Raises; ------; TypeError; Can only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; -----; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets.; """""". if isinstance(other, Qobj):. if self.isbra:; if other.isket:; return zcsr_inner(self.data, other.data, 1); elif other.isbra:; # Since we deal mainly with ket vectors, the bra-bra combo; # is not common, and not optimized.; return zcsr_inner(self.data, other.dag().data, 1); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isket:; if other.isbra:; return zcsr_inner(other.data, self.data, 1); elif other.isket:; return zcsr_inner(self.data, other.data, 0); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * othe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobj.html:40597,efficient,efficient,40597,docs/4.5/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobj.html,5,['efficient'],['efficient']
Energy Efficiency,"ix. This cannot have tensor-product; structure. xvec, yvecarray_likex- and y-coordinates at which to calculate the Husimi-Q function. gfloat, default sqrt(2)Scaling factor for a = 0.5 * g * (x + iy). The value of g is; related to the value of \(\hbar\) in the commutation relation; \([x,\,y] = i\hbar\) via \(\hbar=2/g^2\), so the default; corresponds to \(\hbar=1\). precompute_memoryreal, default 1024Size in MB that may be used during calculations as working space when; dealing with density-matrix inputs. This is ignored for state-vector; inputs. The bound is not quite exact due to other, order-of-magnitude; smaller, intermediaries being necessary, but is a good approximation.; If you want to use the same iterative algorithm for density matrices; that is used for single kets, set precompute_memory=None. Returns. ndarrayValues representing the Husimi-Q function calculated over the specified; range [xvec, yvec]. See also. QFunca class-based version, more efficient if you want to calculate the Husimi-Q function for several states over the same coordinates. spin_q_function(rho, theta, phi)[source]¶; The Husimi Q function for spins is defined as Q(theta, phi) =; SCS.dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:161116,efficient,efficient,161116,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['efficient'],['efficient']
Energy Efficiency,"ject; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/entropy.html:8573,power,power,8573,docs/4.4/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/entropy.html,1,['power'],['power']
