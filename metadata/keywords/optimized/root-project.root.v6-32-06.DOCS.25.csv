quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Security,"rl>"", ""masteronly""); Add full support for placeholders; <uid>,; <gid>, <group> and <homedir>; for the directives specified via 'xpd.putenv'; Add the configuration directive 'proofservparents' to; allow specifying a different list of parent names for the 'proofserv'; tasks. This is needed to avoid untimely killing of 'proofserv'; instances in test setups when multiple instances of the daemons are; running on the same machines under different names.; Add the possibility to switch to asynchronous mode while; running synchronously. A new button ""Run; in background"" has been added; to the dialog box. The behaviour of Ctrl-C has also been modified: the; user is prompted for a choice among continuing asynchronously, stopping; (terminating) or aborting the query.; Add the possibility to define the dataset information; sources via the directive 'xpd.datasetsrc'.; In this way the permissions; should be set correctly and the related problems disappear.; Record the logs from the ROOT version validation tests; (proofserv forked in test mode). In case of failure - or if the debug; flag is on - the log files are kept under; <xproof_adminpath>/rootsysvalidation/root.<tag>.log; (the <tag> has all the '/' replaced by '-'). This should; facilitate understanding the problems when in case of validation; failures.; Add support for automatic; running of PROOF sessions in valgrind. The second; argument of TProof::Open is used to trigger the relevant; settings. To valgrind the master session start PROOF; with TProof::Open(""<master>"",""valgrind=master"");; to valgrind two workers sessions use; TProof::Open(""<master>"",""valgrind=workers""); to valgrind; master and 2 workers, use; TProof::Open(""<master>"",""valgrind=master+workers""). Other; combinations are available. ; The valgrind logs are available with the tag; '<ordinal>-valgrind' in the log dialog or form; TProofMgr::GetSessionLogs() .; To add options to valgrind execute; TProof::AddEnvVar(""PROOF_WRAPPERCMD"",; ""valgrind_opts:<options>"") before",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:3334,validat,validation,3334,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['validat'],['validation']
Security,"rmatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a format style complying with Webkit's style guide:; /// https://webkit.org/code-style-guidelines/; FormatStyle getWebkitStyle();. /// Returns a format style complying with Microsoft's style guide:; /// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference; FormatStyle getMicrosoftStyle();. These options are also exposed in the :doc:`standalone tools <ClangFormat>`; through the `-style` option. In the future, we plan on making this configurable.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:2369,expose,exposed,2369,interpreter/llvm-project/clang/docs/LibFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst,1,['expose'],['exposed']
Security,"rmission, you risk loosing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is may also be corrupted. In addition, adding a branch to; a tree enlarges the tree and increases the amount of memory needed to; read an entry, and therefore decreases the performance. For these; reasons, ROOT offers the concept of friends for trees (and chains). We; encourage you to use `TTree::AddFriend` rather than adding a branch; manually. ### TTree::AddFriend. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way it; is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the; `TTree::AddFriend` method. The **`TTree`** (`tree`) below has two; friends (`ft1` and `ft2`) and now has access to the variables; `a,b,c,i,j,k,l` and `m`. ![](pictures/02000101.jpg). The `AddFriend` method has two parameters, the first is the tree name; and the second is the name of the ROOT file where the friend tree is; saved. `AddFriend` automatically opens the friend file. If no file name; is given, the tree called `ft1` is assumed to be in the same file as the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the friend's; variables were in the original tree. To specify which tree to use in the; `Draw` method, use the syntax:. ``` {.cpp}; <treeName>.<branchname>.<varname>; ```. If the `variablename` is enough to identify uniquely the variable, you; can leave out the tree and/or branch name. For exampl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:53140,access,access,53140,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['access'],['access']
Security,"rn CPUs. These; exploits are currently broken down into three variants:; * GPZ Variant #1 (a.k.a. Spectre Variant #1): Bounds check (or predicate) bypass; * GPZ Variant #2 (a.k.a. Spectre Variant #2): Branch target injection; * GPZ Variant #3 (a.k.a. Meltdown): Rogue data cache load. For more details, see the Google Project Zero blog post and the Spectre research; paper:; * https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html; * https://spectreattack.com/spectre.pdf. The core problem of GPZ Variant #1 is that speculative execution uses branch; prediction to select the path of instructions speculatively executed. This path; is speculatively executed with the available data, and may load from memory and; leak the loaded values through various side channels that survive even when the; speculative execution is unwound due to being incorrect. Mispredicted paths can; cause code to be executed with data inputs that never occur in correct; executions, making checks against malicious inputs ineffective and allowing; attackers to use malicious data inputs to leak secret data. Here is an example,; extracted and simplified from the Project Zero paper:; ```; struct array {; unsigned long length;; unsigned char data[];; };; struct array *arr1 = ...; // small array; struct array *arr2 = ...; // array of size 0x400; unsigned long untrusted_offset_from_caller = ...;; if (untrusted_offset_from_caller < arr1->length) {; unsigned char value = arr1->data[untrusted_offset_from_caller];; unsigned long index2 = ((value&1)*0x100)+0x200;; unsigned char value2 = arr2->data[index2];; }; ```. The key of the attack is to call this with `untrusted_offset_from_caller` that; is far outside of the bounds when the branch predictor will predict that it; will be in-bounds. In that case, the body of the `if` will be executed; speculatively, and may read secret data into `value` and leak it via a; cache-timing side channel when a dependent access is made to populate `val",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:1376,attack,attackers,1376,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attackers']
Security,"rnal information could be needed. Such data would help to identify; debug information processed or incorrect logical element management.; Typically these kind of options are available only in *debug* builds. :program:`llvm-debuginfo-analyzer` supports these advanced options in; both *release* and *debug* builds, with the exception of the unique ID; that is generated only in *debug* builds. .. option:: --internal=<value[,value,...]>. With **value** being one of the options in the following list. .. code-block:: text. =all: Include all the below options. The following options allow to check the integrity of the logical view;; collect the debug tags that are processed or not implemented; ignore the; logical element line number, to facilitate the logical view comparison; when using external comparison tools; print the command line options; used to invoke :program:`llvm-debuginfo-analyzer`. .. code-block:: text. =id: Print unique element ID.; =cmdline: Print command line.; =integrity: Check elements integrity.; =none: Ignore element line number.; =tag: Debug information tags. **Note:** For ELF format, the collected tags represent the debug tags; that are not processed. For PE/COFF format, they represent the tags; that are processed. EXAMPLES; --------; This section includes some real binary files to show how to use; :program:`llvm-debuginfo-analyzer` to print a logical view and to; diagnose possible debug information issues. TEST CASE 1 - GENERAL OPTIONS; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The below example is used to show different output generated by; :program:`llvm-debuginfo-analyzer`. We compiled the example for an X86; ELF target with Clang (-O0 -g):. .. code-block:: c++. 1 using INTPTR = const int *;; 2 int foo(INTPTR ParamPtr, unsigned ParamUnsigned, bool ParamBool) {; 3 if (ParamBool) {; 4 typedef int INTEGER;; 5 const INTEGER CONSTANT = 7;; 6 return CONSTANT;; 7 }; 8 return ParamUnsigned;; 9 }. PRINTING MODE; ^^^^^^^^^^^^^; In this mode :program:`llvm-debuginfo-analy",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:23367,integrity,integrity,23367,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,2,['integrity'],['integrity']
Security,"rns which happen to resemble very closely the initial; proofs of concept. As such, while its performance is acceptable, it does not; appear to be an adequate systematic mitigation. ## Performance Overhead. The performance overhead of this style of comprehensive mitigation is very; high. However, it compares very favorably with previously recommended; approaches such as the `lfence` instruction. Just as users can restrict the; scope of `lfence` to control its performance impact, this mitigation technique; could be restricted in scope as well. However, it is important to understand what it would cost to get a fully; mitigated baseline. Here we assume targeting a Haswell (or newer) processor and; using all of the tricks to improve performance (so leaves the low 2gb; unprotected and +/- 2gb surrounding any PC in the program). We ran both; Google's microbenchmark suite and a large highly-tuned server built using; ThinLTO and PGO. All were built with `-march=haswell` to give access to BMI2; instructions, and benchmarks were run on large Haswell servers. We collected; data both with an `lfence`-based mitigation and load hardening as presented; here. The summary is that mitigating with load hardening is 1.77x faster than; mitigating with `lfence`, and the overhead of load hardening compared to a; normal program is likely between a 10% overhead and a 50% overhead with most; large applications seeing a 30% overhead or less. | Benchmark | `lfence` | Load Hardening | Mitigated Speedup |; | -------------------------------------- | -------: | -------------: | ----------------: |; | Google microbenchmark suite | -74.8% | -36.4% | **2.5x** |; | Large server QPS (using ThinLTO & PGO) | -62% | -29% | **1.8x** |. Below is a visualization of the microbenchmark suite results which helps show; the distribution of results that is somewhat lost in the summary. The y-axis is; a log-scale speedup ratio of load hardening relative to `lfence` (up -> faster; -> better). Each box-and-whiskers rep",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:47255,access,access,47255,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['access'],['access']
Security,"root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the section; [Configure ROOT at start-up](#configure-root-at-start-up)).; The most important among them are presented in the following:. - **[gROOT](https://root.cern.ch/doc/master/classTROOT.html)**: the `gROOT`; variable is the entry point to the ROOT system. Technically it is an; instance of the `TROOT` class. Using the `gROOT` pointer one has; access to basically every object created in a ROOT based program.; The `TROOT` object is essentially a container of several lists; pointing to the main `ROOT` objects. - **[gStyle](https://root.cern.ch/doc/master/classTStyle.html)**: By default; ROOT creates a default style that can be accessed via the `gStyle`; pointer. This class includes functions to set some of the following; object attributes. - Canvas; - Pad; - Histogram axis; - Lines; - Fill areas; - Text; - Markers; - Functions; - Histogram Statistics and Titles; - etc ... - **[gSystem](https://root.cern.ch/doc/master/classTSystem.html)**: An; instance of a base class defining a generic interface to the; underlying Operating System, in our case `TUnixSystem`. - **[gInterpreter](http://root.cern.ch/htmldoc/html/TInterpreter.html)**: The; entry point for the ROOT interpreter. Technically an abstraction level; over a singleton instance of `TCling`. At this point you have already learnt quite a bit about some basic; features of ROOT. ***Please move on to become an expert!***. [^2]: All ROOT classes' names start with the letter T. A notable exception is; RooFit. In this context all classes' names are of the form Roo*. Starting with; ROOT7, all names start with and R.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:20643,access,accessed,20643,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['access'],['accessed']
Security,"ros_mask = 0;; void leak(int data);; void example(int* pointer1, int* pointer2) {; uintptr_t predicate_state = all_ones_mask;; switch (condition) {; case 0:; // Assuming ?: is implemented using branchless logic...; predicate_state = (condition != 0) ? all_zeros_mask : predicate_state;; // ... lots of code ...; //; // Harden the pointer so it can't be loaded; pointer1 &= predicate_state;; leak(*pointer1);; break;. case 1:; predicate_state = (condition != 1) ? all_zeros_mask : predicate_state;; // ... more code ...; //; // Alternative: Harden the loaded value; int value2 = *pointer2 & predicate_state;; leak(value2);; break;. // ...; }; }; ```. The core idea remains the same: validate the control flow using data-flow and; use that validation to check that loads cannot leak information along; misspeculated paths. Typically this involves passing the desired target of such; control flow across the edge and checking that it is correct afterwards. Note; that while it is tempting to think that this mitigates variant #2 attacks, it; does not. Those attacks go to arbitrary gadgets that don't include the checks. ### Variant #1.1 and #1.2 attacks: ""Bounds Check Bypass Store"". Beyond the core variant #1 attack, there are techniques to extend this attack.; The primary technique is known as ""Bounds Check Bypass Store"" and is discussed; in this research paper: https://people.csail.mit.edu/vlk/spectre11.pdf. We will analyze these two variants independently. First, variant #1.1 works by; speculatively storing over the return address after a bounds check bypass. This; speculative store then ends up being used by the CPU during speculative; execution of the return, potentially directing speculative execution to; arbitrary gadgets in the binary. Let's look at an example.; ```; unsigned char local_buffer[4];; unsigned char *untrusted_data_from_caller = ...;; unsigned long untrusted_size_from_caller = ...;; if (untrusted_size_from_caller < sizeof(local_buffer)) {; // Speculative execution e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:10854,attack,attacks,10854,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attacks']
Security,"rotocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap())`. - Access to meta information (`IsA()`, `InheritsFrom())`. - Object browsing (`Browse()`, `IsFolder())`. ## Global Variables. ROOT has a set of global variables that apply to the session. For; example,; ***`gDirectory`*** always holds the current directory, and; ***`gStyle`*** holds the current style. All global variables begin with ""*g*"" followed by a capital letter. ### gROOT. The single instance of **`TROOT`** is accessible via the global; ***`gROOT`*** and holds information relative to the current session.; By using the ***`gROOT`*** pointer, you get the access to every object; created in a ROOT program. The **`TROOT`** object has several lists; pointing to the main ROOT objects. During a ROOT session, the; ***`gROOT`*** keeps a series of collections to manage objects. They; can be accessed via ***`gROOT`***`::GetListOf...` methods. ``` {.cpp}; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->GetListOfGlobalFunctions(); gROOT->GetListOfFiles(); gROOT->GetListOfMappedFiles(); gROOT->GetListOfSockets(); gROOT->GetListOfCanvases(); gROOT->GetListOfStyles(); gROOT->GetListOfFunctions(); gROOT->GetListOfSpecials(); gROOT->GetListOfGeometries(); gROOT->GetListOfBrowsers(); gROOT->GetListOfMessageHandlers(); ```. These methods return a **`TSeqCollection`**, meaning a collection of; objects, and they can be used to do list operations such as finding an; object, or traversing the list and calling a method for each of the; members. See the **`TCollection`** class description for the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:32605,access,access,32605,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['access'],['access']
Security,"roup figures out how the LLVM project’s own releases, as well as individual vendors’ releases, can be timed to patch the issue simultaneously.; * Embargo date can be delayed or pulled forward at the Security Group’s discretion.; * The issue champion obtains a CVE entry from MITRE_.; * Once the embargo expires, the patch is posted publicly according to LLVM’s usual code review process.; * All security issues (as well as nomination / removal discussions) become public within approximately fourteen weeks of the fix landing in the LLVM repository. Precautions should be taken to avoid disclosing particularly sensitive data included in the report (e.g. username and password pairs). Changes to the Policy; =====================. The LLVM Security Policy may be changed by majority vote of the LLVM Security Group. Such changes also need to be approved by the LLVM Board. What is considered a security issue?; ====================================. The LLVM Project has a significant amount of code, and not all of it is; considered security-sensitive. This is particularly true because LLVM is used in; a wide variety of circumstances: there are different threat models, untrusted; inputs differ, and the environment LLVM runs in is varied. Therefore, what the; LLVM Project considers a security issue is what its members have signed up to; maintain securely. As this security process matures, members of the LLVM community can propose that; a part of the codebase be designated as security-sensitive (or no longer; security-sensitive). This requires a rationale, and buy-in from the LLVM; community as for any RFC. In some cases, parts of the codebase could be handled; as security-sensitive but need significant work to get to the stage where that's; manageable. The LLVM community will need to decide whether it wants to invest in; making these parts of the code securable, and maintain these security; properties over time. In all cases the LLVM Security Group should be consulted,; since they'l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:14150,secur,security-sensitive,14150,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security-sensitive']
Security,"roup judged 2 of these; reports to be security issues:. * https://bugs.chromium.org/p/llvm/issues/detail?id=5; * https://bugs.chromium.org/p/llvm/issues/detail?id=11. Both issues were addressed with source changes: #5 in clangd/vscode-clangd, and; #11 in llvm-project. No dedicated LLVM release was made for either. We believe that with the publishing of this first annual transparency report,; the security group now has implemented all necessary processes for the group to; operate as promised. The group's processes can be improved further, and we do; expect further improvements to get implemented in 2022. Many of the potential; improvements end up being discussed on the `monthly public call on LLVM's; security group <https://llvm.org/docs/GettingInvolved.html#online-sync-ups>`_. 2022; ----. In this section we report on the issues the group received in 2022, or on issues; that were received earlier, but were disclosed in 2022. In 2022, the llvm security group received 15 issues that have been disclosed at; the time of writing this transparency report. 5 of these were judged to be security issues:. * https://bugs.chromium.org/p/llvm/issues/detail?id=17 reports a miscompile in; LLVM that can result in the frame pointer and return address being; overwritten. This was fixed. * https://bugs.chromium.org/p/llvm/issues/detail?id=19 reports a vulnerability; in `std::filesystem::remove_all` in libc++. This was fixed. * https://bugs.chromium.org/p/llvm/issues/detail?id=23 reports a new Spectre; gadget variant that Speculative Load Hardening (SLH) does not mitigate. No; extension to SLH was implemented to also mitigate against this variant. * https://bugs.chromium.org/p/llvm/issues/detail?id=30 reports missing memory; safety protection on the (C++) exception handling path. A number of fixes; were implemented. * https://bugs.chromium.org/p/llvm/issues/detail?id=33 reports the RETBLEED; vulnerability. The outcome was clang growing a new security hardening feature; `-mfunction-return",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst:2254,secur,security,2254,interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst,1,['secur'],['security']
Security,"roxy for CVMFS; : An URL specifying the proxy server for CernVM-FS, such as; `http://ca-proxy.cern.ch:3128/`. If you leave it empty, proxy will; be automatically discovered. HTCondor shared secret; : VMs part of the same cluster should have the same value of this; field. It is used to mutually authenticate VMs and it is used like a; password. Context password; : Current profile will be saved on the [CernVM Online; repository](http://cernvm-online.cern.ch/). If you don't want the; information there to be publicly available to other users, type in; a value for protecting the context with an encryption password. You will have to create a profile for the **master** and the **slave**. Since; most of the configuration variables are the same (like the *HTCondor; shared secret*) you can create one, clone it and change only what's; needed to change. Deploy it on the cloud; ----------------------. Provided you have access to a certain cloud API, you'll need to; instantiate a certain number of CernVM batch images with proper; contextualization: one for the master, as many as you want as slaves. CernVM supports contextualization through the ""user data"" field; supported by all cloud infrastructures. Each cloud infrastructure has a different method of setting the ""user; data"". The following description will focus on:. - [OpenNebula](http://opennebula.org/). - OpenStack (such as the [CERN Agile; infrastructure](https://openstack.cern.ch/)). - [Amazon EC2](http://aws.amazon.com/ec2/)-compatible interfaces via; the open [Eucalyptus](http://www.eucalyptus.com/); [Euca2ools](http://www.eucalyptus.com/eucalyptus-cloud/tools): many popular; clouds support such interface and tools. ### Download the CernVM Online contextualizations. Go to the CernVM Online Dashboard page where you have previously; customized the contexts for your master and your slaves. Click on the rightmost button on the line of the desired context and; select **Get rendered context** from the dropdown: save the output ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:3598,access,access,3598,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,1,['access'],['access']
Security,"rprising is that logarithmical search was faster; sometimes by up to 15%. The; hashing method needs some extra CPU time, which is the main reason why it works; slower; in most cases, total ""hashing"" time is greater than total; ""logarithmical-search"" time. So, preference has been granted to the ""logarithmical search"". Though in the case of need, *logarithmical-search* (read ""total-ordering"") could; be used as a milestone on our way to the *random-access* implementation. Every comparison is based either on the numbers or on the flags comparison. In; the *random-access* approach, we could use the same comparison algorithm.; During comparison, we exit once we find the difference, but here we might have; to scan the whole function body every time (note, it could be slower). Like in; ""total-ordering"", we will track every number and flag, but instead of; comparison, we should get the numbers sequence and then create the hash number.; So, once again, *total-ordering* could be considered as a milestone for even; faster (in theory) random-access approach. MergeFunctions, main fields and runOnModule; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; There are two main important fields in the class:. ``FnTree`` – the set of all unique functions. It keeps items that couldn't be; merged with each other. It is defined as:. ``std::set<FunctionNode> FnTree;``. Here ``FunctionNode`` is a wrapper for ``llvm::Function`` class, with; implemented “<” operator among the functions set (below we explain how it works; exactly; this is a key point in fast functions comparison). ``Deferred`` – merging process can affect bodies of functions that are in; ``FnTree`` already. Obviously, such functions should be rechecked again. In this; case, we remove them from ``FnTree``, and mark them to be rescanned, namely; put them into ``Deferred`` list. runOnModule; """"""""""""""""""""""; The algorithm is pretty simple:. 1. Put all module's functions into the *worklist*. 2. Scan *worklist*'s functions twice: first enumer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:7555,access,access,7555,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['access'],['access']
Security,"rrently using a very simple approach where the light; source is matching the eye position (no shadows or back-tracing of the; reflected ray). In future we are considering providing a base class in; order to be able to derive more complex models. Due to the fact that the number of rays that have to be tracked matches; the size in pixels of the pad, the time required by this algorithm is; proportional to the pad size. On the other hand, the speed is quite; acceptable for the default ROOT pad size and the images produced by; using this technique have high quality. Since the algorithm is; practically using all navigation features, producing ray-traced pictures; is also a geometry validation check. Ray tracing can be activated at; volume level as the normal `Draw()`. \image html geometry013.jpg ""Ray-traced view in a pad"". ~~~{.cpp}; myVolume->Raytrace(); ~~~. Once ray-tracing a view, this can be zoomed or rotated as a usual one.; Objects on the screen are no longer highlighted when picking the; vertices but the corresponding volumes is still accessible. \anchor GP04ca; #### Clipping Ray-traced Images. A ray-traced view can be `clipped` with any shape known by the modeller.; This means that the region inside the clipping shape is subtracted from; the current drawn geometry (become invisible). In order to activate; clipping, one has to first define the clipping shape(s):. 1. `TGeoShape *clip1, *clip2, ...`; One might switch between several clipping shapes. Note that these; shapes are considered defined in the current `MARS`. Composite shapes; may be used.; 2. `gGeoManager->SetClippingShape(clip1);`; One can activate or deactivate clipping at any time:; `gGeoManager->SetClipping(flag);`; 3. Perform ray-tracing:` gGeoManager->GetTopVolume()->Raytrace();`. One can redo the steps 2-3 as many times as needed. Let us look how the; rootgeom.C example looks clipped with a tube. \image html geometry014.png ""Ray-tracing example with box-clipping"". \anchor GP05; ## Representing Misali",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:105046,access,accessible,105046,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['access'],['accessible']
Security,"rs are not required - specified item will be displayed automatically when web page is opened.; One also can configure to display several items at once. For that one also can configure layout of the drawing area:. ```cpp; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; ```. One also can change appearance of hierarchy browser on the left side of the web page:. ```cpp; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; ```. If necessary, one also can automatically open ROOT file when web page is opened:. ```cpp; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; ```. ## Configuring user access. By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the **htdigest** utility. ```bash; [shell] htdigest -c .htdigest domain_name user_name; ```. It is recommended not to use special symbols in domain or user names. Several users can be add to the "".htdigest"" file. When starting the server, the following arguments should be specified:. ```cpp; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; ```. After that, the web browser will automatically request to input a name/password for the domain ""domain_name"". Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using `THttpServer::Restrict()` method. For instance, one could hide complete folder from 'guest' account:. ```cpp; serv->Restrict(""/Folder"", ""hidden=guest"");; ```. Or one could hide from all but 'admin' account:. ```cpp; serv->Re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:8175,access,access,8175,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['access'],['access']
Security,"rs can query constraint bounds to improve diagnostic messages.; (`#74141 <https://github.com/llvm/llvm-project/pull/74141>`_). - Improved the generated initializers for modules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`_). Moved checkers; ^^^^^^^^^^^^^^. - Move checker ``alpha.unix.Errno`` out of the ``alpha`` package; to ``unix.Errno``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-errno-c>`__. - Move checker ``alpha.unix.StdCLibraryFunctions`` out of the ``alpha`` package; to ``unix.StdCLibraryFunctions``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-stdclibraryfunctions-c>`__. - Move checker ``alpha.security.cert.env.InvalidPtr`` out of the ``alpha``; package to ``security.cert.env.InvalidPtr``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__. - Move checker ``alpha.cplusplus.EnumCastOutOfRange`` out of the ``alpha``; package to ``optin.core.EnumCastOutOfRange``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#optin-core-enumcastoutofrange-c-c>`__. .. _release-notes-sanitizers:. Sanitizers; ----------. - ``-fsanitize=signed-integer-overflow`` now instruments ``__builtin_abs`` and; ``abs`` builtins. Python Binding Changes; ----------------------. Additional Information; ======================. A wide variety of additional information is available on the `Clang web; page <https://clang.llvm.org/>`_. The web page contains versions of the; API documentation which are up-to-date with the Git version of; the source code. You can access versions of these documents specific to; this release by going into the ""``clang/docs/``"" directory in the Clang; tree. If you ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:77040,secur,security,77040,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['secur'],['security']
Security,"rs compilation of the symbol(s) searched for; (if they have not been compiled already), and (2) it provides the; synchronization mechanism for concurrent compilation. The pseudo-code for the; lookup process is:. .. code-block:: none. construct a query object from a query set and query handler; lock the session; lodge query against requested symbols, collect required materializers (if any); unlock the session; dispatch materializers (if any). In this context a materializer is something that provides a working definition; of a symbol upon request. Usually materializers are just wrappers for compilers,; but they may also wrap a jit-linker directly (if the program representation; backing the definitions is an object file), or may even be a class that writes; bits directly into memory (for example, if the definitions are; stubs). Materialization is the blanket term for any actions (compiling, linking,; splatting bits, registering with runtimes, etc.) that are required to generate a; symbol definition that is safe to call or access. As each materializer completes its work it notifies the JITDylib, which in turn; notifies any query objects that are waiting on the newly materialized; definitions. Each query object maintains a count of the number of symbols that; it is still waiting on, and once this count reaches zero the query object calls; the query handler with a *SymbolMap* (a map of symbol names to addresses); describing the result. If any symbol fails to materialize the query immediately; calls the query handler with an error. The collected materialization units are sent to the ExecutionSession to be; dispatched, and the dispatch behavior can be set by the client. By default each; materializer is run on the calling thread. Clients are free to create new; threads to run materializers, or to send the work to a work queue for a thread; pool (this is what LLJIT/LLLazyJIT do). Top Level APIs; ==============. Many of ORC's top-level APIs are visible in the example above:. -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:10375,access,access,10375,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['access'],['access']
Security,"rs must not change the number of; volatile operations or change their order of execution relative to other; volatile operations. The optimizers *may* change the order of volatile; operations relative to non-volatile operations. This is not Java's; ""volatile"" and has no cross-thread synchronization behavior. A volatile load or store may have additional target-specific semantics.; Any volatile operation can have side effects, and any volatile operation; can read and/or modify state which is not accessible via a regular load; or store in this module. Volatile operations may use addresses which do; not point to memory (like MMIO registers). This means the compiler may; not use a volatile operation to prove a non-volatile access to that; address has defined behavior. The allowed side-effects for volatile accesses are limited. If a; non-volatile store to a given address would be legal, a volatile; operation may modify the memory at that address. A volatile operation; may not modify any other memory accessible by the module being compiled.; A volatile operation may not call any code in the current module. In general (without target specific context), the address space of a; volatile operation may not be changed. Different address spaces may; have different trapping behavior when dereferencing an invalid; pointer. The compiler may assume execution will continue after a volatile operation,; so operations which modify memory or may have undefined behavior can be; hoisted past a volatile operation. As an exception to the preceding rule, the compiler may not assume execution; will continue after a volatile store operation. This restriction is necessary; to support the somewhat common pattern in C of intentionally storing to an; invalid pointer to crash the program. In the future, it might make sense to; allow frontends to control this behavior. IR-level volatile loads and stores cannot safely be optimized into llvm.memcpy; or llvm.memmove intrinsics even when those intrinsics ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:147001,access,accessible,147001,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessible']
Security,"rt of the `ROOTNTupleUtil` library. ### RNTupleInspector; The RNTupleInspector provides insights of an RNTuple, e.g. the distribution of data volume wrt. column types.; It is part of the `ROOTNTupleUtil` library. Ownership Model; ---------------. By default, objects involved in RNTuple I/O (objects read from disk or written to disk) are passed to RNTuple as shared pointers.; Both RNTuple or the application may create the object.; Raw pointers to objects can be passed to RNTuple -- such objects are considered as owned by the application.; The caller has to ensure that the lifetime of the object lasts during the I/O operations. An RNTuple writer that is constructed without a `TFile` object (`RNTupleWriter::Recreate()`) assumes exclusive access to the underlying file.; An RNTuple writer that uses a `TFile` for writing (`RNTupleWriter::Append()`) assumes that the `TFile` object outlives the writer's lifetime.; The serial writer assumes exclusive access to the underlying file during construction, destruction and `Fill()` as well as `CommitCluster()` and `FlushCluster()`.; For `FlushColumns()` and `FillNoFlush()`, the sequential writer assumes exclusive access only if buffered writing is turned off.; The parallel writer assumes exclusive access to the underlying file during all operations on the writer (e.g. construction and destruction) and all operations on any created fill context (e.g. `Fill()` and `FlushCluster()`).; Notable exceptions are `FlushColumns()` and `FillNoFlush()` which are guaranteed to never access the underlying `TFile` during parallel writing (which is always buffered). A `TFile` does not take ownership of any `RNTuple` objects. When reading data, RNTuple uses the `RMiniFile` and `RRawFile` classes to open a given storage path and find the `RNTuple` anchor.; When creating a `RNTupleReader` from an existing anchor object, RNTuple uses `RRawFile` only for files of dynamic type `TFile`, `TDavixFile`, and `TNetXNGFile`.; In either case, the `RRawFile` own",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:17821,access,access,17821,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['access'],['access']
Security,"rted.; - *RISCV64* only supports up to 11 bit type parameters, 4; 32-bit floating-point parameters, and 4 64-bit floating-point; parameters. This calling convention supports `tail call; optimization <CodeGenerator.html#tail-call-optimization>`_ but requires; both the caller and callee are using it.; ""``cc 11``"" - The HiPE calling convention; This calling convention has been implemented specifically for use by; the `High-Performance Erlang; (HiPE) <http://www.it.uu.se/research/group/hipe/>`_ compiler, *the*; native code compiler of the `Ericsson's Open Source Erlang/OTP; system <http://www.erlang.org/download.shtml>`_. It uses more; registers for argument passing than the ordinary C calling; convention and defines no callee-saved registers. The calling; convention properly supports `tail call; optimization <CodeGenerator.html#tail-call-optimization>`_ but requires; that both the caller and the callee use it. It uses a *register pinning*; mechanism, similar to GHC's convention, for keeping frequently; accessed runtime components pinned to specific hardware registers.; At the moment only X86 supports this convention (both 32 and 64; bit).; ""``anyregcc``"" - Dynamic calling convention for code patching; This is a special convention that supports patching an arbitrary code; sequence in place of a call site. This convention forces the call; arguments into registers but allows them to be dynamically; allocated. This can currently only be used with calls to; llvm.experimental.patchpoint because only this intrinsic records; the location of its arguments in a side table. See :doc:`StackMaps`.; ""``preserve_mostcc``"" - The `PreserveMost` calling convention; This calling convention attempts to make the code in the caller as; unintrusive as possible. This convention behaves identically to the `C`; calling convention on how arguments and return values are passed, but it; uses a different set of caller/callee-saved registers. This alleviates the; burden of saving and recovering a lar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:15569,access,accessed,15569,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessed']
Security,"rts 16 bytes at; ``%ymm0``, then the runtime can safely optimize by saving only; ``%xmm0``. The stack map format is a contract between an LLVM SVN revision and; the runtime. It is currently experimental and may change in the short; term, but minimizing the need to update the runtime is; important. Consequently, the stack map design is motivated by; simplicity and extensibility. Compactness of the representation is; secondary because the runtime is expected to parse the data; immediately after compiling a module and encode the information in its; own format. Since the runtime controls the allocation of sections, it; can reuse the same stack map space for multiple modules. Stackmap support is currently only implemented for 64-bit; platforms. However, a 32-bit implementation should be able to use the; same format with an insignificant amount of wasted space. .. _stackmap-section:. Stack Map Section; ^^^^^^^^^^^^^^^^^. A JIT compiler can easily access this section by providing its own; memory manager via the LLVM C API; ``LLVMCreateSimpleMCJITMemoryManager()``. When creating the memory; manager, the JIT provides a callback:; ``LLVMMemoryManagerAllocateDataSectionCallback()``. When LLVM creates; this section, it invokes the callback and passes the section name. The; JIT can record the in-memory address of the section at this time and; later parse it to recover the stack map data. For MachO (e.g. on Darwin), the stack map section name is; ""__llvm_stackmaps"". The segment name is ""__LLVM_STACKMAPS"". For ELF (e.g. on Linux), the stack map section name is; "".llvm_stackmaps"". The segment name is ""__LLVM_STACKMAPS"". Stack Map Usage; ===============. The stack map support described in this document can be used to; precisely determine the location of values at a specific position in; the code. LLVM does not maintain any mapping between those values and; any higher-level entity. The runtime must be able to interpret the; stack map record given only the ID, offset, and the order of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:16197,access,access,16197,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['access'],['access']
Security,"ructions, or by flat instructions. Multi-dword; access is not supported except by flat and scratch instructions in; GFX9-GFX11. Code that manipulates the stack values in other lanes of a wavefront,; such as by ``addrspacecast``-ing stack pointers to generic ones and taking offsets; that reach other lanes or by explicitly constructing the scratch buffer descriptor,; triggers undefined behavior when it modifies the scratch values of other lanes.; The compiler may assume that such modifications do not occur.; When using code object V5 ``LIBOMPTARGET_STACK_SIZE`` may be used to provide the; private segment size in bytes, for cases where a dynamic stack is used. **Constant 32-bit**; *TODO*. **Buffer Fat Pointer**; The buffer fat pointer is an experimental address space that is currently; unsupported in the backend. It exposes a non-integral pointer that is in; the future intended to support the modelling of 128-bit buffer descriptors; plus a 32-bit offset into the buffer (in total encapsulating a 160-bit; *pointer*), allowing normal LLVM load/store/atomic operations to be used to; model the buffer descriptors used heavily in graphics workloads targeting; the backend. The buffer descriptor used to construct a buffer fat pointer must be *raw*:; the stride must be 0, the ""add tid"" flag must be 0, the swizzle enable bits; must be off, and the extent must be measured in bytes. (On subtargets where; bounds checking may be disabled, buffer fat pointers may choose to enable; it or not). **Buffer Resource**; The buffer resource pointer, in address space 8, is the newer form; for representing buffer descriptors in AMDGPU IR, replacing their; previous representation as `<4 x i32>`. It is a non-integral pointer; that represents a 128-bit buffer descriptor resource (`V#`). Since, in general, a buffer resource supports complex addressing modes that cannot; be easily represented in LLVM (such as implicit swizzled access to structured; buffers), it is **illegal** to perform non-trivial a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:28633,expose,exposes,28633,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['expose'],['exposes']
Security,"ructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:70820,access,access,70820,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['access']
Security,"rupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:3871,checksum,checksum,3871,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,2,['checksum'],['checksum']
Security,"ry cache. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_SIZE_MAX | Sets the maximum size of entries that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TSDs that can be used |; | | up to the limit specified at compile time. |; +---------------------------+-------------------------------------------------------+. Error Types; ===========. The allocator will output an error message, and potentially terminate the; process, when an unexpected behavior is detected. The output usually starts with; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root-cause the issue,; please consider `ASan <https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; for this purpose. Here is a list of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""invalid chunk state""``: the chunk is not in the expected state for a given; operation, eg: it is not allocated when trying to free it, or it's not; quarantined when trying to recycle it, etc. A double-free is the typical; reason this error would occur;. - ``""misaligned pointer""``: we strongly enforce basic alignment requirements, 8; bytes on 32-bit platforms, 16 bytes on 64-bit platforms. If a pointer p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:14995,sanitiz,sanitizers,14995,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['sanitiz'],['sanitizers']
Security,"ry subregions in a; memcpy are padding and what the TBAA tags of the struct are. The current metadata format is very simple. ``!tbaa.struct`` metadata; nodes are a list of operands which are in conceptual groups of three.; For each group of three, the first operand gives the byte offset of a; field in bytes, the second gives its size in bytes, and the third gives; its tbaa tag. e.g.:. .. code-block:: llvm. !4 = !{ i64 0, i64 4, !1, i64 8, i64 4, !2 }. This describes a struct with two fields. The first is at offset 0 bytes; with size 4 bytes, and has tbaa tag !1. The second is at offset 8 bytes; and has size 4 bytes and has tbaa tag !2. Note that the fields need not be contiguous. In this example, there is a; 4 byte gap between the two fields. This gap represents padding which; does not carry useful data and need not be preserved. '``noalias``' and '``alias.scope``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``noalias`` and ``alias.scope`` metadata provide the ability to specify generic; noalias memory-access sets. This means that some collection of memory access; instructions (loads, stores, memory-accessing calls, etc.) that carry; ``noalias`` metadata can specifically be specified not to alias with some other; collection of memory access instructions that carry ``alias.scope`` metadata.; Each type of metadata specifies a list of scopes where each scope has an id and; a domain. When evaluating an aliasing query, if for some domain, the set; of scopes with that domain in one instruction's ``alias.scope`` list is a; subset of (or equal to) the set of scopes for that domain in another; instruction's ``noalias`` list, then the two memory accesses are assumed not to; alias. Because scopes in one domain don't affect scopes in other domains, separate; domains can be used to compose multiple independent noalias sets. This is; used for example during inlining. As the noalias function parameters are; turned into noalias scope metadata, a new domain is used every",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:281084,access,access,281084,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"ry. It is higher; performance than global memory. It is allocated by the runtime. The data; store (DS) instructions can be used to access it. **Local**; The local address space uses the hardware Local Data Store (LDS) which is; automatically allocated when the hardware creates the wavefronts of a; work-group, and freed when all the wavefronts of a work-group have; terminated. All wavefronts belonging to the same work-group will access the; same memory for any given local address. However, the same local address; accessed by wavefronts belonging to different work-groups will access; different memory. It is higher performance than global memory. The data store; (DS) instructions can be used to access it. **Private**; The private address space uses the hardware scratch memory support which; automatically allocates memory when it creates a wavefront and frees it when; a wavefronts terminates. The memory accessed by a lane of a wavefront for any; given private address will be different to the memory accessed by another lane; of the same or different wavefront for the same private address. If a kernel dispatch uses scratch, then the hardware allocates memory from a; pool of backing memory allocated by the runtime for each wavefront. The lanes; of the wavefront access this using dword (4 byte) interleaving. The mapping; used from private address to backing memory address is:. ``wavefront-scratch-base +; ((private-address / 4) * wavefront-size * 4) +; (wavefront-lane-id * 4) + (private-address % 4)``. If each lane of a wavefront accesses the same private address, the; interleaving results in adjacent dwords being accessed and hence requires; fewer cache lines to be fetched. There are different ways that the wavefront scratch base address is; determined by a wavefront (see; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). Scratch memory can be accessed in an interleaved manner using buffer; instructions with the scratch buffer descriptor and per wavefront scratch; offset",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:26699,access,accessed,26699,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,2,['access'],['accessed']
Security,"ry:; %promise = alloca i32; %id = call token @llvm.coro.id(i32 0, ptr %promise, ptr null, ptr null); %need.dyn.alloc = call i1 @llvm.coro.alloc(token %id); br i1 %need.dyn.alloc, label %dyn.alloc, label %coro.begin; dyn.alloc:; %size = call i32 @llvm.coro.size.i32(); %alloc = call ptr @malloc(i32 %size); br label %coro.begin; coro.begin:; %phi = phi ptr [ null, %entry ], [ %alloc, %dyn.alloc ]; %hdl = call noalias ptr @llvm.coro.begin(token %id, ptr %phi); br label %loop; loop:; %n.val = phi i32 [ %n, %coro.begin ], [ %inc, %loop ]; %inc = add nsw i32 %n.val, 1; store i32 %n.val, ptr %promise; %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %loop; i8 1, label %cleanup]; cleanup:; %mem = call ptr @llvm.coro.free(token %id, ptr %hdl); call void @free(ptr %mem); br label %suspend; suspend:; %unused = call i1 @llvm.coro.end(ptr %hdl, i1 false, token none); ret ptr %hdl; }. A coroutine consumer can rely on the `coro.promise`_ intrinsic to access the; coroutine promise. .. code-block:: llvm. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4); %promise.addr = call ptr @llvm.coro.promise(ptr %hdl, i32 4, i1 false); %val0 = load i32, ptr %promise.addr; call void @print(i32 %val0); call void @llvm.coro.resume(ptr %hdl); %val1 = load i32, ptr %promise.addr; call void @print(i32 %val1); call void @llvm.coro.resume(ptr %hdl); %val2 = load i32, ptr %promise.addr; call void @print(i32 %val2); call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. After example in this section is compiled, result of the compilation will be:. .. code-block:: llvm. define i32 @main() {; entry:; tail call void @print(i32 4); tail call void @print(i32 5); tail call void @print(i32 6); ret i32 0; }. .. _final:; .. _final suspend:. Final Suspend; -------------. A coroutine author or a frontend may designate a particular suspend to be final,; by setting the second argument of the `coro.suspend`_ intrinsic to `true`.; Such a suspend point has two properti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:23700,access,access,23700,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['access'],['access']
Security,"s ... / (4; workers still sending). This asserts socket activity and fixes the timeout; problems during long merging phases reported in a few cases.; In TFileMerger, create directly the output file at the; final destination do not make a local copy in the temp directory first; (if needed, one can always set the temporary destination to temp; followed by a TFile::Cp to the final destination); this allows to avoid; reported problems with small temp partitions (see Forum).; In XrdProofConn, enable cycling through the; authentication protocol presented by the server. This only holds for; the choice of the protocol, because the server currently supports only; one full handshake.; In test/stressProof.cxx, avoid interferences between the; settings used for the PROOF tutorial and possible local settings; (daemon, dataset manager).; Add possibility to control the automatic re-loading of; the <proof.conf> file via the keyword; 'reload:1'/'reload:0'; in the xpd.resource directive.; Move the validation of <proof.conf> at the; moment of use; this allows to specify a file path and to dynamically; create/modify/destroy the file; used by PoD.; Improve displaying speed of large log files. Fixes. Fix two severe; bugs in the way TTreeCache; was used in PROOF: one bug was de facto disactivating the cache; the; other was causing a std::bad_alloc exception to be thrown on workers; when opening a remote file after a local one.    ; Fix several problems in TChain::Draw including. drawing into an existing histogram, i.e.; chain->Draw(""var>>myhist"");. treatment of histogram merging in case of small; statistics, i.e. when; the autobinning is not or only partially active;. usage of existing canvases when different histogram; names are specified;. Fix a problem causing a duplication of the final feedback; object. Fix problem with determining the subdir name in; TFileMerger::MergeRecursive on Windows; Make sure that the default sandbox is under $HOME/.proof; Fix a problem with dataset validation",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:8444,validat,validation,8444,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['validat'],['validation']
Security,"s a global pointer since only the device global memory is visible; and managed on the host side. The vector and scalar L1 caches are invalidated; of volatile data before each kernel dispatch execution to allow constant; memory to change values between kernel dispatches. **Region**; The region address space uses the hardware Global Data Store (GDS). All; wavefronts executing on the same device will access the same memory for any; given region address. However, the same region address accessed by wavefronts; executing on different devices will access different memory. It is higher; performance than global memory. It is allocated by the runtime. The data; store (DS) instructions can be used to access it. **Local**; The local address space uses the hardware Local Data Store (LDS) which is; automatically allocated when the hardware creates the wavefronts of a; work-group, and freed when all the wavefronts of a work-group have; terminated. All wavefronts belonging to the same work-group will access the; same memory for any given local address. However, the same local address; accessed by wavefronts belonging to different work-groups will access; different memory. It is higher performance than global memory. The data store; (DS) instructions can be used to access it. **Private**; The private address space uses the hardware scratch memory support which; automatically allocates memory when it creates a wavefront and frees it when; a wavefronts terminates. The memory accessed by a lane of a wavefront for any; given private address will be different to the memory accessed by another lane; of the same or different wavefront for the same private address. If a kernel dispatch uses scratch, then the hardware allocates memory from a; pool of backing memory allocated by the runtime for each wavefront. The lanes; of the wavefront access this using dword (4 byte) interleaving. The mapping; used from private address to backing memory address is:. ``wavefront-scratch-base +; ((private-a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:26218,access,access,26218,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"s active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""*Undo*"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""*Position*"" allows editing the; positioning matrix of a given node. ![Setting volume properties and modifying volume hierarchy](pictures/020001F5.jpg); ![Setting volume properties and modifying volume hierarchy](pictures/020001F6.jpg). - *Visua",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:171843,access,accessible,171843,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['access'],['accessible']
Security,"s data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"")",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:66744,attack,attacker,66744,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,2,"['attack', 'inject']","['attacker', 'inject']"
Security,"s declared ""`private`"" instead of ""`public`"" ?; Well, it will behave as any other name declared private in; **`TArrow`**: only the data members and methods of **`TArrow`** will; be able to access **`TLine`**, its methods and data members, nobody; else. This may seem a little bit confusing and readers should read a; good C++ book if they want more details. Especially since, besides; public and private, a member can be protected. Usually, one puts; private the methods that the class uses internally, like some; utilities classes, and that the programmer does not want to be seen; in the outside world. With ""good"" C++ practice (which we have tried to use in ROOT), all; data members of a class are private. This is called data encapsulation; and is one of the strongest advantages of Object Oriented Programming; (OOP). Private data members of a class are not visible, except to the; class itself. So, from the outside world, if one wants to access those; data members, one should use so called ""getters"" and ""setters""; methods, which are special methods used only to get or set the data; members. The advantage is that if the programmers want to modify the; inner workings of their classes, they can do so without changing what; the user sees. The user does not even have to know that something has; changed (for the better, hopefully). For example, in our **`TArrow`**; class, we would have set the data member `ArrowHeadSize` private. The; setter method is `SetArrowSize()`, we do not need a getter method:. ``` {.cpp}; class TArrow : public TLine {; private:; int ArrowHeadSize;; public:; void Draw();; void SetArrowSize(int arrowsize);; }; ```. To define an arrow object you call the constructor. This will also; call the constructor of **`TLine`**, which is the parent class of; **`TArrow`**, automatically. Then we can call any of the line or arrow; public methods:. ``` {.cpp}; root[] TArrow *myarrow = new TArrow(1,5,89,124);; root[] myarrow->SetArrowSize(10);; root[] myarrow->Draw();; `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:6253,access,access,6253,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['access'],['access']
Security,"s for debug-info"" OFF). set(LLVM_CODESIGNING_IDENTITY """" CACHE STRING; ""Sign executables and dylibs with the given identity or skip if empty (Darwin Only)""). # If enabled, verify we are on a platform that supports oprofile.; if( LLVM_USE_OPROFILE ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""OProfile support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_OPROFILE ). option(LLVM_USE_PERF; ""Use perf JIT interface to inform perf about JIT code"" OFF). # If enabled, verify we are on a platform that supports perf.; if( LLVM_USE_PERF ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""perf support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_PERF ). set(LLVM_USE_SANITIZER """" CACHE STRING; ""Define the sanitizer used to build binaries and tests.""); option(LLVM_OPTIMIZE_SANITIZED_BUILDS ""Pass -O1 on debug sanitizer builds"" ON); set(LLVM_UBSAN_FLAGS; ""-fsanitize=undefined -fno-sanitize=vptr,function -fno-sanitize-recover=all""; CACHE STRING; ""Compile flags set to enable UBSan. Only used if LLVM_USE_SANITIZER contains 'Undefined'.""); set(LLVM_LIB_FUZZING_ENGINE """" CACHE PATH; ""Path to fuzzing library for linking with fuzz targets""). option(LLVM_USE_SPLIT_DWARF; ""Use -gsplit-dwarf when compiling llvm and --gdb-index when linking."" OFF). # Define an option controlling whether we should build for 32-bit on 64-bit; # platforms, where supported.; if( CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT (WIN32 OR ${CMAKE_SYSTEM_NAME} MATCHES ""AIX"")); # TODO: support other platforms and toolchains.; option(LLVM_BUILD_32_BITS ""Build 32 bits executables and libraries."" OFF); endif(). # Define the default arguments to use with 'lit', and an option for the user to; # override.; set(LIT_ARGS_DEFAULT ""-sv""); if (MSVC_IDE OR XCODE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFAULT} --no-progress-bar""); endif(); if(LLVM_INDIVIDUAL_TEST_COVERAGE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:28411,sanitiz,sanitizer,28411,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,3,['sanitiz'],"['sanitize', 'sanitize-recover', 'sanitizer']"
Security,"s groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructions that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:311760,access,access,311760,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"s initializing a parameter include?; Unknown. 2600; DR; Type dependency of placeholder types; Unknown. 2601; C++23; Tracking of created and destroyed subobjects; Unknown. 2602; C++23; consteval defaulted functions; Unknown. 2603; C++23; Holistic functional equivalence for function templates; Unknown. 2604; C++23; Attributes for an explicit specialization; Unknown. 2605; C++23; Implicit-lifetime aggregates; Unknown. 2606; CD6; static_cast from ""pointer to void"" does not handle similar types; Unknown. 2607; drafting; Visibility of enumerator names; Not resolved. 2608; CD6; Omitting an empty template argument list; Unknown. 2609; open; Padding in class types; Not resolved. 2610; C++23; Indirect private base classes in aggregates; Unknown. 2611; C++23; Missing parentheses in expansion of fold-expression could cause syntactic reinterpretation; Unknown. 2612; C++23; Incorrect comment in example; Unknown. 2613; C++23; Incomplete definition of resumer; Unknown. 2614; C++23; Unspecified results for class member access; Unknown. 2615; C++23; Missing __has_cpp_attribute(assume); Unknown. 2616; C++23; Imprecise restrictions on break and continue; Unknown. 2617; review; Default template arguments for template members of non-template classes; Not resolved. 2618; C++23; Substitution during deduction should exclude exception specifications; Unknown. 2619; C++23; Kind of initialization for a designated-initializer-list; Unknown. 2620; C++23; Nonsensical disambiguation rule; Unknown. 2621; C++23; Kind of lookup for using enum declarations; Clang 16. 2622; C++23; Compounding types from function and pointer-to-member types; Unknown. 2623; drafting; Invoking destroying operator delete for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Unknown. 2627; C++23; Bit-fields and narrowing conversions; Unkn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:180110,access,access,180110,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['access'],['access']
Security,"s is a violation or which action; will be taken. Specific guidance is in the checklist below. For in-person events that have a violation reported, the report should be sent; to the Code of Conduct committee within 24 hours by the on-site CoC response; team. . .. _Immediate Response Checklist:. Immediate Response Checklist; ============================. The CoC committee generally works, decides, and communicates together. If the; report indicates that an immediate response is required and other committee; members are not available, any committee member may take the immediate action; they think is necessary. In-person Code of Conduct response teams should use; this checklist to determine if an immediate response is needed. * If the incident involves physical danger, contact the appropriate law; enforcement or event security immediately. Ensure the reporter feels safe and; stay with them if possible until help arrives.; * If the act is ongoing and involves harassment or threats against someone in; any space (online or physical), any appropriate response (e.g., ban, physical; removal, or moderation) may be used to immediately stop it.; * For events that include talks, organizers should end talks early if the; violations include harassment or violent threats. There may be talks where; other types of code of conduct violations occur and organizers should do ; their best to determine if a talk should be ended early or not. . When undertaking an immediate response, document the action and notify the; committee within 24 hours. . Response Procedure; ==================. The following is a summary of the steps the committee takes when responding to; a reported incident. . 1. Determine if there is a need for an :ref:`immediate response<Immediate; Response Checklist>`. 2. :ref:`Acknowledge the report<Receiving a report>` within 24 hours. 3. :ref:`Discuss the incident report<Incident Response Assessment>`, gather; more information, and determine a :ref:`resolution<Resolutions>`. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:2503,threat,threats,2503,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['threat'],['threats']
Security,"s is not recommended. If it's; absolutely necessary to use this attribute, be very explicit about using the; typedef, and do not assume that it will be preserved by language features like; ``__typeof`` and C++ template argument substitution. .. admonition:: Rationale. Any compiler operation which incidentally strips type ""sugar"" from a type; will yield a type without the attribute, which may result in unexpected; behavior. .. _arc.objects.retains:. Retain count semantics; ----------------------. A retainable object pointer is either a :arc-term:`null pointer` or a pointer; to a valid object. Furthermore, if it has block pointer type and is not; ``null`` then it must actually be a pointer to a block object, and if it has; ``Class`` type (possibly protocol-qualified) then it must actually be a pointer; to a class object. Otherwise ARC does not enforce the Objective-C type system; as long as the implementing methods follow the signature of the static type.; It is undefined behavior if ARC is exposed to an invalid pointer. For ARC's purposes, a valid object is one with ""well-behaved"" retaining; operations. Specifically, the object must be laid out such that the; Objective-C message send machinery can successfully send it the following; messages:. * ``retain``, taking no arguments and returning a pointer to the object.; * ``release``, taking no arguments and returning ``void``.; * ``autorelease``, taking no arguments and returning a pointer to the object. The behavior of these methods is constrained in the following ways. The term; :arc-term:`high-level semantics` is an intentionally vague term; the intent is; that programmers must implement these methods in a way such that the compiler,; modifying code in ways it deems safe according to these constraints, will not; violate their requirements. For example, if the user puts logging statements; in ``retain``, they should not be surprised if those statements are executed; more or less often depending on optimization settings",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:12912,expose,exposed,12912,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['expose'],['exposed']
Security,"s it. Because of this, any reference to; the value produced by an instruction (or the value available as an incoming; argument, for example) is represented as a direct pointer to the instance of the; class that represents this value. Although this may take some getting used to,; it simplifies the representation and makes it easier to manipulate. .. _m_Value:. Important Public Members of the ``Value`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * | ``Value::use_iterator`` - Typedef for iterator over the use-list; | ``Value::const_use_iterator`` - Typedef for const_iterator over the; use-list; | ``unsigned use_size()`` - Returns the number of users of the value.; | ``bool use_empty()`` - Returns true if there are no users.; | ``use_iterator use_begin()`` - Get an iterator to the start of the; use-list.; | ``use_iterator use_end()`` - Get an iterator to the end of the use-list.; | ``User *use_back()`` - Returns the last element in the list. These methods are the interface to access the def-use information in LLVM.; As with all other iterators in LLVM, the naming conventions follow the; conventions defined by the STL_. * ``Type *getType() const``; This method returns the Type of the Value. * | ``bool hasName() const``; | ``std::string getName() const``; | ``void setName(const std::string &Name)``. This family of methods is used to access and assign a name to a ``Value``, be; aware of the :ref:`precaution above <nameWarning>`. * ``void replaceAllUsesWith(Value *V)``. This method traverses the use list of a ``Value`` changing all User_\ s of the; current value to refer to ""``V``"" instead. For example, if you detect that an; instruction always produces a constant value (for example through constant; folding), you can replace all uses of the instruction with the constant like; this:. .. code-block:: c++. Inst->replaceAllUsesWith(ConstVal);. .. _User:. The ``User`` class; ------------------. ``#include ""llvm/IR/User.h""``. header source: `User.h <https://llvm.org/d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:143780,access,access,143780,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['access']
Security,"s linked with %ROOT graphical libraries loaded on demand in order to; control visualization actions. \anchor GP02; ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position \f$\vec{r}\f$ and direction \f$\vec{n}\f$ with respect to the world; reference frame. The direction \f$\vec{n}\f$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of `TGeo` to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with %ROOT. The interface methods related to tracking are incorporated into; TGeoManager class and implemented in the navigator class; TGeoNavigator. In order to be able to start tracking, one has to; define the initial state providing the starting point \f$\vec{r_0}\f$; and direction \f$\vec{n_0}\f$ .; There are several ways of doing that. \anchor GP02a; ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ~~~{.cpp}; TObjArray *navigators",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:62129,access,access,62129,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['access'],['access']
Security,"s makes up the *guarded; allocation pool*. Buffer Underflow/Overflow Detection; -----------------------------------. We gain buffer-overflow and buffer-underflow detection through these guard; pages. When a memory access overruns the allocated buffer, it will touch the; inaccessible guard page, causing memory exception. This exception is caught and; handled by the internal crash handler. Because each allocation is recorded with; metadata about where (and by what thread) it was allocated and deallocated, we; can provide information that will help identify the root cause of the bug. Allocations are randomly selected to be either left- or right-aligned to provide; equal detection of both underflows and overflows. Use after Free Detection; ------------------------. The guarded allocation pool also provides use-after-free detection. Whenever a; sampled allocation is deallocated, we map its guarded slot as inaccessible. Any; memory accesses after deallocation will thus trigger the crash handler, and we; can provide useful information about the source of the error. Please note that the use-after-free detection for a sampled allocation is; transient. To keep memory overhead fixed while still detecting bugs, deallocated; slots are randomly reused to guard future allocations. Usage; =====. GWP-ASan already ships by default in the; `Scudo Hardened Allocator <https://llvm.org/docs/ScudoHardenedAllocator.html>`_,; so building with ``-fsanitize=scudo`` is the quickest and easiest way to try out; GWP-ASan. Options; -------. GWP-ASan's configuration is managed by the supporting allocator. We provide a; generic configuration management library that is used by Scudo. It allows; several aspects of GWP-ASan to be configured through the following methods:. - When the GWP-ASan library is compiled, by setting; ``-DGWP_ASAN_DEFAULT_OPTIONS`` to the options string you want set by default.; If you're building GWP-ASan as part of a compiler-rt/LLVM build, add it during; cmake configure time (e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:4420,access,accesses,4420,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['access'],['accesses']
Security,"s may grow very large, even for small functions. Path Tracking; =============. These checkers print information about the path taken by the analyzer engine. - debug.DumpCalls: Prints out every function or method call encountered during a; path traversal. This is indented to show the call stack, but does NOT do any; special handling of branches, meaning different paths could end up; interleaved. - debug.DumpTraversal: Prints the name of each branch statement encountered; during a path traversal (""IfStmt"", ""WhileStmt"", etc). Currently used to check; whether the analysis engine is doing BFS or DFS. State Checking; ==============. These checkers will print out information about the analyzer state in the form; of analysis warnings. They are intended for use with the -verify functionality; in regression tests. - debug.TaintTest: Prints out the word ""tainted"" for every expression that; carries taint. At the time of this writing, taint was only introduced by the; checks under experimental.security.taint.TaintPropagation; this checker may; eventually move to the security.taint package. - debug.ExprInspection: Responds to certain function calls, which are modeled; after builtins. These function calls should affect the program state other; than the evaluation of their arguments; to use them, you will need to declare; them within your test file. The available functions are described below. (FIXME: debug.ExprInspection should probably be renamed, since it no longer only; inspects expressions.). ExprInspection checks; ---------------------. - ``void clang_analyzer_eval(bool);``. Prints TRUE if the argument is known to have a non-zero value, FALSE if the; argument is known to have a zero or null value, and UNKNOWN if the argument; isn't sufficiently constrained on this path. You can use this to test other; values by using expressions like ""x == 5"". Note that this functionality is; currently DISABLED in inlined functions, since different calls to the same; inlined function could pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:2351,secur,security,2351,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,1,['secur'],['security']
Security,"s non-checked code to be the first; code executed. However, this requires a load from TLS in the entry block, a store to TLS; before every call and every ret, and a load from TLS after every call. As a; consequence it is expected to be substantially more expensive even than using; `%rsp` and potentially `lfence` within the function entry block. ##### Define a new ABI and/or calling convention. We could define a new ABI and/or calling convention to explicitly pass the; predicate state in and out of functions. This may be interesting if none of the; alternatives have adequate performance, but it makes deployment and adoption; dramatically more complex, and potentially infeasible. ## High-Level Alternative Mitigation Strategies. There are completely different alternative approaches to mitigating variant 1; attacks. [Most](https://lwn.net/Articles/743265/); [discussion](https://lwn.net/Articles/744287/) so far focuses on mitigating; specific known attackable components in the Linux kernel (or other kernels) by; manually rewriting the code to contain an instruction sequence that is not; vulnerable. For x86 systems this is done by either injecting an `lfence`; instruction along the code path which would leak data if executed speculatively; or by rewriting memory accesses to have branch-less masking to a known safe; region. On Intel systems, `lfence` [will prevent the speculative load of secret; data](https://newsroom.intel.com/wp-content/uploads/sites/11/2018/01/Intel-Analysis-of-Speculative-Execution-Side-Channels.pdf).; On AMD systems `lfence` is currently a no-op, but can be made; dispatch-serializing by setting an MSR, and thus preclude misspeculation of the; code path ([mitigation G-2 +; V1-1](https://developer.amd.com/wp-content/resources/Managing-Speculation-on-AMD-Processors.pdf)). However, this relies on finding and enumerating all possible points in code; which could be attacked to leak information. While in some cases static; analysis is effective at doing this ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:43696,attack,attackable,43696,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attackable']
Security,"s not lock ``b.mu``. The analysis understands; that these are two separate mutexes, in two different objects. Finally, there is a warning in the ``withdraw()`` method, because it fails to; unlock ``mu``. Every lock must have a corresponding unlock, and the analysis; will detect both double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ============================. Thread safety analysis provides a way of protecting *resources* with; *capabilities*. A resource is either a data member, or a function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared*. An exclusive; capability can be held by only one thread at a time, while a shared capability; can be held by many threads at the same time. This mechanism enforces a; multiple-reader, single-writer pattern. Write operations to protected data; require exclusive access, while ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:3669,access,access,3669,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['access'],['access']
Security,"s of scratch memory used by the shader.; "".lds_size"" integer Size in bytes of LDS memory.; "".vgpr_count"" integer Number of VGPRs used by the shader.; "".sgpr_count"" integer Number of SGPRs used by the shader.; "".stack_frame_size_in_bytes"" integer Amount of stack size used by the shader.; "".shader_subtype"" string Shader subtype/kind. Values include:. - ""Unknown"". ============================= ============== =================================================================. .. .. table:: AMDPAL Code Object Register Map; :name: amdgpu-amdpal-code-object-register-map-table. ========================== ============== ====================================================================; 32-bit Integer Key Value Type Description; ========================== ============== ====================================================================; ``reg offset`` 32-bit integer ``reg offset`` is the dword offset into the GFXIP register space of; a GRBM register (i.e., driver accessible GPU register number, not; shader GPR register number). The driver is required to program each; specified register to the corresponding specified value when; executing this pipeline. Typically, the ``reg offsets`` are the; ``uint16_t`` offsets to each register as defined by the hardware; chip headers. The register is set to the provided value. However, a; ``reg offset`` that specifies a user data register (e.g.,; COMPUTE_USER_DATA_0) needs special treatment. See; :ref:`amdgpu-amdpal-code-object-user-data-section` section for more; information.; ========================== ============== ====================================================================. .. _amdgpu-amdpal-code-object-user-data-section:. User Data; +++++++++. Each hardware stage has a set of 32-bit physical SPI *user data registers*; (either 16 or 32 based on graphics IP and the stage) which can be; written from a command buffer and then loaded into SGPRs when waves are; launched via a subsequent dispatch or draw operation. This is the w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:412621,access,accessible,412621,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessible']
Security,"s r2, ha16(.CPI_X_2); lfd f1, lo16(.CPI_X_2)(r2); lis r2, ha16(.CPI_X_3); lfd f2, lo16(.CPI_X_3)(r2); fmadd f1, f0, f1, f2; blr. It would be better to materialize .CPI_X into a register, then use immediates; off of the register to avoid the lis's. This is even more important in PIC ; mode. Note that this (and the static variable version) is discussed here for GCC:; http://gcc.gnu.org/ml/gcc-patches/2006-02/msg00133.html. Here's another example (the sgn function):; double testf(double a) {; return a == 0.0 ? 0.0 : (a > 0.0 ? 1.0 : -1.0);; }. it produces a BB like this:; LBB1_1: ; cond_true; lis r2, ha16(LCPI1_0); lfs f0, lo16(LCPI1_0)(r2); lis r2, ha16(LCPI1_1); lis r3, ha16(LCPI1_2); lfs f2, lo16(LCPI1_2)(r3); lfs f3, lo16(LCPI1_1)(r2); fsub f0, f0, f1; fsel f1, f0, f2, f3; blr . ===-------------------------------------------------------------------------===. PIC Code Gen IPO optimization:. Squish small scalar globals together into a single global struct, allowing the ; address of the struct to be CSE'd, avoiding PIC accesses (also reduces the size; of the GOT on targets with one). Note that this is discussed here for GCC:; http://gcc.gnu.org/ml/gcc-patches/2006-02/msg00133.html. ===-------------------------------------------------------------------------===. Fold add and sub with constant into non-extern, non-weak addresses so this:. static int a;; void bar(int b) { a = b; }; void foo(unsigned char *c) {; *c = a;; }. So that . _foo:; lis r2, ha16(_a); la r2, lo16(_a)(r2); lbz r2, 3(r2); stb r2, 0(r3); blr. Becomes. _foo:; lis r2, ha16(_a+3); lbz r2, lo16(_a+3)(r2); stb r2, 0(r3); blr. ===-------------------------------------------------------------------------===. We should compile these two functions to the same thing:. #include <stdlib.h>; void f(int a, int b, int *P) {; *P = (a-b)>=0?(a-b):(b-a);; }; void g(int a, int b, int *P) {; *P = abs(a-b);; }. Further, they should compile to something better than:. _g:; subf r2, r4, r3; subfic r3, r2, 0; cmpwi cr0, r2, -1;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt:2644,access,accesses,2644,interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,1,['access'],['accesses']
Security,"s section we only mention loads. Stores have exactly the same problems as their associated loads, so have been skipped for brevity. Considerations; ==============. LLVM IR Lane ordering; ---------------------. LLVM IR has first class vector types. In LLVM IR, the zero'th element of a vector resides at the lowest memory address. The optimizer relies on this property in certain areas, for example when concatenating vectors together. The intention is for arrays and vectors to have identical memory layouts - ``[4 x i8]`` and ``<4 x i8>`` should be represented the same in memory. Without this property there would be many special cases that the optimizer would have to cleverly handle. Use of ``LDR`` would break this lane ordering property. This doesn't preclude the use of ``LDR``, but we would have to do one of two things:. 1. Insert a ``REV`` instruction to reverse the lane order after every ``LDR``.; 2. Disable all optimizations that rely on lane layout, and for every access to an individual lane (``insertelement``/``extractelement``/``shufflevector``) reverse the lane index. AAPCS; -----. The ARM procedure call standard (AAPCS) defines the ABI for passing vectors between functions in registers. It states:. When a short vector is transferred between registers and memory it is treated as an opaque object. That is a short vector is stored in memory as if it were stored with a single ``STR`` of the entire register; a short vector is loaded from memory using the corresponding ``LDR`` instruction. On a little-endian system this means that element 0 will always contain the lowest addressed element of a short vector; on a big-endian system element 0 will contain the highest-addressed element of a short vector. -- Procedure Call Standard for the ARM 64-bit Architecture (AArch64), 4.1.2 Short Vectors. The use of ``LDR`` and ``STR`` as the ABI defines has at least one advantage over ``LD1`` and ``ST1``. ``LDR`` and ``STR`` are oblivious to the size of the individual lanes of a ve",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst:5414,access,access,5414,interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,1,['access'],['access']
Security,"s system, in particular; if you have already drawn for example a histogram in the mother pad. The; only thing left is to draw the pad:. ``` {.cpp}; root[] spad1->Draw(); ```. If you want more sub-pads, you have to repeat this procedure as many; times as necessary. #### Dividing a Canvas into Sub-Pads. The manual way of dividing a pad into sub-pads is sometimes very; tedious. There is a way to automatically generate horizontal and; vertical sub-pads inside a given pad. ``` {.cpp}; root[] pad1->Divide(3,2); ```. ![Dividing a pad into 6 sub-pads](pictures/030000A5.png). ![Dividing a pad into 6 sub-pads](pictures/020000A6.jpg). If `pad1` is a pad then, it will divide the pad into 3 columns of 2; sub-pads. The generated sub-pads get names `pad1_i` where the index; `i=1` to `nxm` (in our case `pad1_1`, `pad1_2`...`pad1_6)`. The names; `pad1_1 `etc... correspond to new variables in Cling, so you may use them; as soon as the executed method was `pad->Divide()`. However, in a; compiled program, one has to access these objects. Remember that a pad; contains other objects and that these objects may themselves be pads. So; we can use the `GetPrimitive()` method:. ``` {.cpp}; TPad* pad1_1 = (TPad*)(pad1->GetPrimitive(""pad1_1"")); ```. One question remains. In case one does an automatic divide, how one can; set the default margins between pads? This is done by adding two; parameters to `Divide()`, which are the margins in `x` and `y`:. ``` {.cpp}; root[] pad1->Divide(3,2,0.1,0.1); ```. The margins are here set to 10% of the parent pad width. ### Updating the Pad. For performance reasons, a pad is not updated with every change. For; example, changing the coordinates of the pad does not automatically; redraw it. Instead, the pad has a ""bit-modified"" that triggers a redraw.; This bit is automatically set by:. - Touching the pad with the mouse - for example resizing it with the; mouse. - Finishing the execution of a script. - Adding a new primitive or modifying some primitives for exa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:25621,access,access,25621,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['access'],['access']
Security,"s the JIT know about sin and cos? The answer is surprisingly; simple: The KaleidoscopeJIT has a straightforward symbol resolution rule that; it uses to find symbols that aren't available in any given module: First; it searches all the modules that have already been added to the JIT, from the; most recent to the oldest, to find the newest definition. If no definition is; found inside the JIT, it falls back to calling ""``dlsym(""sin"")``"" on the; Kaleidoscope process itself. Since ""``sin``"" is defined within the JIT's; address space, it simply patches up calls in the module to call the libm; version of ``sin`` directly. But in some cases this even goes further:; as sin and cos are names of standard math functions, the constant folder; will directly evaluate the function calls to the correct result when called; with constants like in the ""``sin(1.0)``"" above. In the future we'll see how tweaking this symbol resolution rule can be used to; enable all sorts of useful features, from security (restricting the set of; symbols available to JIT'd code), to dynamic code generation based on symbol; names, and even lazy compilation. One immediate benefit of the symbol resolution rule is that we can now extend; the language by writing arbitrary C++ code to implement operations. For example,; if we add:. .. code-block:: c++. #ifdef _WIN32; #define DLLEXPORT __declspec(dllexport); #else; #define DLLEXPORT; #endif. /// putchard - putchar that takes a double and returns 0.; extern ""C"" DLLEXPORT double putchard(double X) {; fputc((char)X, stderr);; return 0;; }. Note, that for Windows we need to actually export the functions because; the dynamic symbol loader will use ``GetProcAddress`` to find the symbols. Now we can produce simple output to the console by using things like:; ""``extern putchard(x); putchard(120);``"", which prints a lowercase 'x'; on the console (120 is the ASCII code for 'x'). Similar code could be; used to implement file I/O, console input, and many other capabilities;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:23570,secur,security,23570,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['secur'],['security']
Security,"s this metadata to efficiently; check (at each call site) that a given address corresponds to either a; valid vtable or function pointer for a given class or function type, and its; whole-program devirtualization pass uses the metadata to identify potential; callees for a given virtual call. To use the mechanism, a client creates metadata nodes with two elements:. 1. a byte offset into the global (generally zero for functions); 2. a metadata object representing an identifier for the type. These metadata nodes are associated with globals by using global object; metadata attachments with the ``!type`` metadata kind. Each type identifier must exclusively identify either global variables; or functions. .. admonition:: Limitation. The current implementation only supports attaching metadata to functions on; the x86-32 and x86-64 architectures. An intrinsic, :ref:`llvm.type.test <type.test>`, is used to test whether a; given pointer is associated with a type identifier. .. _control flow integrity: https://clang.llvm.org/docs/ControlFlowIntegrity.html. Representing Type Information using Type Metadata; =================================================. This section describes how Clang represents C++ type information associated with; virtual tables using type metadata. Consider the following inheritance hierarchy:. .. code-block:: c++. struct A {; virtual void f();; };. struct B : A {; virtual void f();; virtual void g();; };. struct C {; virtual void h();; };. struct D : A, C {; virtual void f();; virtual void h();; };. The virtual table objects for A, B, C and D look like this (under the Itanium ABI):. .. csv-table:: Virtual Table Layout for A, B, C, D; :header: Class, 0, 1, 2, 3, 4, 5, 6. A, A::offset-to-top, &A::rtti, &A::f; B, B::offset-to-top, &B::rtti, &B::f, &B::g; C, C::offset-to-top, &C::rtti, &C::h; D, D::offset-to-top, &D::rtti, &D::f, &D::h, D::offset-to-top, &D::rtti, thunk for &D::h. When an object of type A is constructed, the address of ``&A::f`` in A's; vir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TypeMetadata.rst:1240,integrity,integrity,1240,interpreter/llvm-project/llvm/docs/TypeMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TypeMetadata.rst,1,['integrity'],['integrity']
Security,"s to require the user to specify types for every variable; definition, and record the type of the variable in the symbol table; along with its Value\*.; - **arrays, structs, vectors, etc** - Once you add types, you can start; extending the type system in all sorts of interesting ways. Simple; arrays are very easy and are quite useful for many different; applications. Adding them is mostly an exercise in learning how the; LLVM `getelementptr <../../LangRef.html#getelementptr-instruction>`_ instruction; works: it is so nifty/unconventional, it `has its own; FAQ <../../GetElementPtr.html>`_!; - **standard runtime** - Our current language allows the user to access; arbitrary external functions, and we use it for things like ""printd""; and ""putchard"". As you extend the language to add higher-level; constructs, often these constructs make the most sense if they are; lowered to calls into a language-supplied runtime. For example, if; you add hash tables to the language, it would probably make sense to; add the routines to a runtime, instead of inlining them all the way.; - **memory management** - Currently we can only access the stack in; Kaleidoscope. It would also be useful to be able to allocate heap; memory, either with calls to the standard libc malloc/free interface; or with a garbage collector. If you would like to use garbage; collection, note that LLVM fully supports `Accurate Garbage; Collection <../../GarbageCollection.html>`_ including algorithms that; move objects and need to scan/update the stack.; - **exception handling support** - LLVM supports generation of `zero; cost exceptions <../../ExceptionHandling.html>`_ which interoperate with; code compiled in other languages. You could also generate code by; implicitly making every function return an error value and checking; it. You could also make explicit use of setjmp/longjmp. There are; many different ways to go here.; - **object orientation, generics, database access, complex numbers,; geometric programming",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:3083,hash,hash,3083,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['hash'],['hash']
Security,"s value encodes lambda functions based on a; stable numbering order in which they appear in their local declaration contexts.; Once this builtin is evaluated in a constexpr context, it is erroneous to use; it in an instantiation which changes its value. In order to produce the unique name, the current implementation of the builtin; uses Itanium mangling even if the host compilation uses a different name; mangling scheme at runtime. The mangler marks all the lambdas required to name; the SYCL kernel and emits a stable local ordering of the respective lambdas.; The resulting pattern is demanglable. When non-lambda types are passed to the; builtin, the mangler emits their usual pattern without any special treatment. **Syntax**:. .. code-block:: c. // Computes a unique stable name for the given type.; constexpr const char * __builtin_sycl_unique_stable_name( type-id );. Multiprecision Arithmetic Builtins; ----------------------------------. Clang provides a set of builtins which expose multiprecision arithmetic in a; manner amenable to C. They all have the following form:. .. code-block:: c. unsigned x = ..., y = ..., carryin = ..., carryout;; unsigned sum = __builtin_addc(x, y, carryin, &carryout);. Thus one can form a multiprecision addition chain in the following manner:. .. code-block:: c. unsigned *x, *y, *z, carryin=0, carryout;; z[0] = __builtin_addc(x[0], y[0], carryin, &carryout);; carryin = carryout;; z[1] = __builtin_addc(x[1], y[1], carryin, &carryout);; carryin = carryout;; z[2] = __builtin_addc(x[2], y[2], carryin, &carryout);; carryin = carryout;; z[3] = __builtin_addc(x[3], y[3], carryin, &carryout);. The complete list of builtins are:. .. code-block:: c. unsigned char __builtin_addcb (unsigned char x, unsigned char y, unsigned char carryin, unsigned char *carryout);; unsigned short __builtin_addcs (unsigned short x, unsigned short y, unsigned short carryin, unsigned short *carryout);; unsigned __builtin_addc (unsigned x, unsigned y, unsigned carryin, un",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:124415,expose,expose,124415,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['expose'],['expose']
Security,"s within the same address space. ``singlethread-one-as`` Same as ``singlethread`` but only synchronizes with; other operations within the same address space.; ======================= ===================================================. LLVM IR Intrinsics; ------------------. The AMDGPU backend implements the following LLVM IR intrinsics. *This section is WIP.*. .. table:: AMDGPU LLVM IR Intrinsics; :name: amdgpu-llvm-ir-intrinsics-table. ============================================== ==========================================================; LLVM Intrinsic Description; ============================================== ==========================================================; llvm.amdgcn.sqrt Provides direct access to v_sqrt_f64, v_sqrt_f32 and v_sqrt_f16; (on targets with half support). Performs sqrt function. llvm.amdgcn.log Provides direct access to v_log_f32 and v_log_f16; (on targets with half support). Performs log2 function. llvm.amdgcn.exp2 Provides direct access to v_exp_f32 and v_exp_f16; (on targets with half support). Performs exp2 function. :ref:`llvm.frexp <int_frexp>` Implemented for half, float and double. :ref:`llvm.log2 <int_log2>` Implemented for float and half (and vectors of float or; half). Not implemented for double. Hardware provides; 1ULP accuracy for float, and 0.51ULP for half. Float; instruction does not natively support denormal; inputs. :ref:`llvm.sqrt <int_sqrt>` Implemented for double, float and half (and vectors). :ref:`llvm.log <int_log>` Implemented for float and half (and vectors). :ref:`llvm.exp <int_exp>` Implemented for float and half (and vectors). :ref:`llvm.log10 <int_log10>` Implemented for float and half (and vectors). :ref:`llvm.exp2 <int_exp2>` Implemented for float and half (and vectors of float or; half). Not implemented for double. Hardware provides; 1ULP accuracy for float, and 0.51ULP for half. Float; instruction does not natively support denormal; inputs. :ref:`llvm.stacksave.p5 <int_stacksave>` Implemented, must use",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:36098,access,access,36098,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"s"" \; source=""fXbins"" \; targetClass=""TAxis"" \; target=""fXbins"" \; version=""[-5]"" \; include=""TAxis.h"" \; code=""\; {\; Float_t * xbins=0; \; Int_t n = buffer.ReadArray( xbins ); \; fXbins.Set( xbins ); \; }""; ```. - For REFLEX dictionaries:. ``` {.cpp}; <ioread sourceClass=""ClassA""; source=""double m_a; double m_b; double m_c""; version=""[4-5,7,9,12-]""; checksum=""[12345,123456]""; targetClass=""ClassB""; target=""m_x""; embed=""true""; include=""iostream,cstdlib"">; <![CDATA[; m_x = onfile.m_a * onfile.m_b * onfile.m_c;; ]] >; </ioread>. <ioreadraw sourceClass=""TAxis""; source=""fXbins""; targetClass=""TAxis""; target=""fXbins""; version=""[-5]""; include=""TAxis.h"">; <![CDATA[; Float_t *xbins = 0;; Int_t n = buffer.ReadArray( xbins ) ;; fXbins.Set( xbins );; ]] >; </ioreadraw>; ```. The variables in the rules have the following meaning:. * sourceClass; - The field defines the on-disk class that is the input for the rule.; * source; - A semicolon-separated list of values defining the source class data members; that need to be cached and accessible via object proxy when the rule is; executed. The values are either the names of the data members or the type-name; pairs (separated by a space). If types are specified then the ondisk structure; can be generated and used in the code snippet defined by the user.; * version; - A list of versions of the source class that can be an input for this rule.; The list has to be enclosed in a square bracket and be a comma-separated; list of versions or version ranges. The version is an integer number, whereas; the version range is one of the following:; - ""a-b"": a and b are integers and the expression means all the numbers between; and including a and b; - ""-a"": a is an integer and the expression means all the version numbers smaller; than or equal to a; - ""a-"": a is an integer and the expression means all the version numbers greater; than or equal to a; * checksum; - A list of checksums of the source class that can be an input for this; rule. The list ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:79660,access,accessible,79660,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['access'],['accessible']
Security,"s"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:10730,secur,security,10730,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['secur'],['security']
Security,"s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, i.e. if you need to pass a string as a; parameter, the syntax is:. ```; root -b -q 'myMacro.C(""text"")' > myMacro.log; ```. You can build a shared library with ACLiC and then use this shared; library on the command line for a quicker execution (i.e. the compiled; speed rather than the interpreted speed). See also ""Cling the C++; Interpreter"". ```; root -b -q myMacro.so > myMacro.log; ```. ROOT has a powerful C/C++ interpreter giving you access to all available; ROOT classes, global variables, and functions via the command line. By; typing C++ statements at the prompt, you can create objects, call; functions, execute scripts, etc. For example:. ``` {.cpp}; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; ```. To exit the ROOT session, type `.q`. ``` {.cpp}; root[] .q; ```. ## Using the GUI. The basic whiteboard on which an object is drawn in ROOT is called a; canvas (defined by the class **`TCanvas`**). Every object in the; canvas is a graphical object in the sense that you can grab it, resize; it, and change some characteristics using the mouse. The canvas area; can be divided in several sub areas, so-called pads; (the class **`TPad`**). A pad is a canvas sub area that can contain; other pads or graphical objects. At any one time, just one pad is the; so-called active pad. Any object at the moment of drawing will be; drawn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:4794,access,access,4794,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['access'],['access']
Security,"s, buffers, and; leafs, are explained a little later in this chapter, but for now, it is; important to realize that each object is not written individually, but; rather collected and written a bunch at a time. This is where the **`TTree`** takes advantage of compression and will; produce a much smaller file than if the objects were written; individually. Since the unit to be compressed is a buffer, and the; **`TTree`** contains many same-class objects, the header of the objects; can be compressed. The **`TTree`** reduces the header of each object, but it still contains; the class name. Using compression, the class name of each same-class; object has a good chance of being compressed, since the compression; algorithm recognizes the bit pattern representing the class name. Using; a **`TTree`** and compression the header is reduced to about 4 bytes; compared to the original 60 bytes. However, if compression is turned; off, you will not see these large savings. The **`TTree`** is also used to optimize the data access. A tree uses a; hierarchy of branches, and each branch can be read independently from; any other branch. Now, assume that `Px` and `Py` are data members of the; event, and we would like to compute `Px2 + Py2` for every event; and histogram the result. If we had saved the million events without a **`TTree`** we would have; to:. - read each event in its entirety into memory; - extract the `Px` and `Py` from the event; - compute the sum of the squares; - fill a histogram. We would have to do that a million times! This is very time consuming,; and we really do not need to read the entire event, every time. All we; need are two little data members (`Px` and `Py`). On the other hand, if; we use a tree with one branch containing `Px` and another branch; containing `Py`, we can read all values of `Px` and `Py` by only reading; the `Px` and `Py` branches. This makes the use of the **`TTree`** very; attractive. ## A Simple TTree. This script builds a **`TTree`** from",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:1723,access,access,1723,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['access'],['access']
Security,s-extra/unittests/clang-doc/GeneratorTest.cpp; clang-tools-extra/unittests/clang-doc/HTMLGeneratorTest.cpp; clang-tools-extra/unittests/clang-doc/MDGeneratorTest.cpp; clang-tools-extra/unittests/clang-doc/MergeTest.cpp; clang-tools-extra/unittests/clang-doc/SerializeTest.cpp; clang-tools-extra/unittests/clang-doc/YAMLGeneratorTest.cpp; clang-tools-extra/unittests/clang-tidy/AddConstTest.cpp; clang-tools-extra/unittests/clang-tidy/ClangTidyDiagnosticConsumerTest.cpp; clang-tools-extra/unittests/clang-tidy/ClangTidyTest.h; clang-tools-extra/unittests/clang-tidy/DeclRefExprUtilsTest.cpp; clang-tools-extra/unittests/clang-tidy/GlobListTest.cpp; clang-tools-extra/unittests/clang-tidy/OptionsProviderTest.cpp; clang-tools-extra/unittests/clang-tidy/OverlappingReplacementsTest.cpp; clang-tools-extra/unittests/clang-tidy/ReadabilityModuleTest.cpp; clang-tools-extra/unittests/clang-tidy/TransformerClangTidyCheckTest.cpp; compiler-rt/include/sanitizer/linux_syscall_hooks.h; compiler-rt/include/sanitizer/memprof_interface.h; compiler-rt/include/sanitizer/netbsd_syscall_hooks.h; compiler-rt/include/xray/xray_interface.h; compiler-rt/include/xray/xray_log_interface.h; compiler-rt/lib/asan/asan_activation.h; compiler-rt/lib/asan/asan_lock.h; compiler-rt/lib/asan/asan_mapping.h; compiler-rt/lib/asan/asan_mapping_sparc64.h; compiler-rt/lib/asan/asan_rtl_static.cpp; compiler-rt/lib/asan/tests/asan_globals_test.cpp; compiler-rt/lib/builtins/fp_extend.h; compiler-rt/lib/builtins/fp_lib.h; compiler-rt/lib/builtins/fp_mode.h; compiler-rt/lib/builtins/fp_trunc.h; compiler-rt/lib/builtins/int_endianness.h; compiler-rt/lib/builtins/int_math.h; compiler-rt/lib/builtins/int_types.h; compiler-rt/lib/builtins/int_util.h; compiler-rt/lib/builtins/unwind-ehabi-helpers.h; compiler-rt/lib/builtins/ppc/DD.h; compiler-rt/lib/dfsan/dfsan_allocator.cpp; compiler-rt/lib/dfsan/dfsan_allocator.h; compiler-rt/lib/dfsan/dfsan_chained_origin_depot.cpp; compiler-rt/lib/dfsan/dfsan_chained_origin_depot.h; compi,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:89486,sanitiz,sanitizer,89486,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['sanitiz'],['sanitizer']
Security,"s. Dump compiland information. .. option:: -xme. Dump cross module exports (DEBUG_S_CROSSSCOPEEXPORTS CodeView subsection). .. option:: -xmi. Dump cross module imports (DEBUG_S_CROSSSCOPEIMPORTS CodeView subsection). Symbol Options; ++++++++++++++. .. option:: -globals. dump global symbol records. .. option:: -global-extras. dump additional information about the globals, such as hash buckets and hash; values. .. option:: -publics. dump public symbol records. .. option:: -public-extras. dump additional information about the publics, such as hash buckets and hash; values. .. option:: -symbols. dump symbols (functions, variables, etc) for each module dumped. .. option:: -sym-data. For each symbol record dumped as a result of the :option:`-symbols` option,; display the full bytes of the record in binary as well. Type Record Options; +++++++++++++++++++. .. option:: -types. Dump CodeView type records from TPI stream. .. option:: -type-extras. Dump additional information from the TPI stream, such as hashes and the type; index offsets array. .. option:: -type-data. For each type record dumped, display the full bytes of the record in binary as; well. .. option:: -type-index=<uint>. Only dump types with the specified type index. .. option:: -ids. Dump CodeView type records from IPI stream. .. option:: -id-extras. Dump additional information from the IPI stream, such as hashes and the type; index offsets array. .. option:: -id-data. For each ID record dumped, display the full bytes of the record in binary as; well. .. option:: -id-index=<uint>. only dump ID records with the specified hexadecimal type index. .. option:: -dependents. When used in conjunction with :option:`-type-index` or :option:`-id-index`,; dumps the entire dependency graph for the specified index instead of just the; single record with the specified index. For example, if type index 0x4000 is; a function whose return type has index 0x3000, and you specify; `-dependents=0x4000`, then this would dump both recor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst:9343,hash,hashes,9343,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,1,['hash'],['hashes']
Security,"s. The value is an empty null-terminated string if no source is available. If; the source is available but is an empty file then the value is a; null-terminated single ""\ ``\n``\ "". *When the source field is present, consumers can use the embedded source; instead of attempting to discover the source on disk using the file path; provided by the* ``DW_LNCT_path`` *field. When the source field is absent,; consumers can access the file to get the source text.*. *This is particularly useful for programming languages that support runtime; compilation and runtime generation of source text. In these cases, the; source text does not reside in any permanent file. For example, the OpenCL; language [:ref:`OpenCL <amdgpu-dwarf-OpenCL>`] supports online compilation.*. 2. ``DW_LNCT_LLVM_is_MD5``. ``DW_LNCT_LLVM_is_MD5`` indicates if the ``DW_LNCT_MD5`` content kind, if; present, is valid: when 0 it is not valid and when 1 it is valid. If; ``DW_LNCT_LLVM_is_MD5`` content kind is not present, and ``DW_LNCT_MD5``; content kind is present, then the MD5 checksum is valid. ``DW_LNCT_LLVM_is_MD5`` is always paired with the ``DW_FORM_udata`` form. *This allows a compilation unit to have a mixture of files with and without; MD5 checksums. This can happen when multiple relocatable files are linked; together.*. .. _amdgpu-dwarf-call-frame-information:. A.6.4 Call Frame Information; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. note::. This section provides changes to existing call frame information and defines; instructions added by these extensions. Additional support is added for; address spaces. Register unwind DWARF expressions are generalized to allow any; location description, including those with composite and implicit location; descriptions. These changes would be incorporated into the DWARF Version 5 section 6.4. .. _amdgpu-dwarf-structure_of-call-frame-information:. A.6.4.1 Structure of Call Frame Information; +++++++++++++++++++++++++++++++++++++++++++. The register rules are:. *undefined*; A r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:189625,checksum,checksum,189625,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['checksum'],['checksum']
Security,"s.com/mybucket/path/to/my/file"") // Uses environmental variables for retrieving credentials; ```. Limitations:. - we cannot efficiently detect that a S3 server is able to respond to; multi-range HTTP GET requests. Some servers, such as Amazon's,; respond to such kind of requests with the whole file contents. Other; servers, such as Huawei's, respond with the exact partial content; requested. Therefore, I added the possibility of configuring the; behavior via the ROOT configuration file: the identity of the; servers known to correctly support multi-range requests is; configurable. If the server is known to support this feature, ROOT; will send multi-range requests, otherwise it will issue multiple; single-range GET requests, which is also the default behavior.; - currently the virtual host syntax:; ""s3://mybucket.s3.amazonaws.com/path/to/my/file"" is not supported; but can be added if this is considered useful. The TAS3File class will be removed and should not have been used; directly by users anyway as it was only accessed via the plugin manager; in TFile::Open(). ### New HTTP Server package. A new HTTP Server package has been introduced. The idea behind such server is to provide direct access to the data from a running ROOT application. Any object can be streamed when requested and delivered to the browser. ##### Starting HTTP server. To start http server, at any time create instance; of the **`THttpServer`** class like:. ``` {.cpp}; serv = new THttpServer(""http:8080"");; ```. This will start civetweb-based http server on port 8080.; Then, one should be able to open address ""http://localhost:8080""; in any modern browser and browse objects created in application. By default, the server can access files, canvases and histograms via gROOT. All such objects can be displayed with JSRootIO graphics. At any time one could register other objects with the command:. ``` {.cpp}; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; ```. If t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md:2459,access,accessed,2459,net/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md,1,['access'],['accessed']
Security,"s.html#ts>`_ for; information on the version of SD-6 supported by each Clang release, and the; macros provided by that revision of the recommendations. C++98; -----. The features listed below are part of the C++98 standard. These features are; enabled by default when compiling C++ code. C++ exceptions; ^^^^^^^^^^^^^^. Use ``__has_feature(cxx_exceptions)`` to determine if C++ exceptions have been; enabled. For example, compiling code with ``-fno-exceptions`` disables C++; exceptions. C++ RTTI; ^^^^^^^^. Use ``__has_feature(cxx_rtti)`` to determine if C++ RTTI has been enabled. For; example, compiling code with ``-fno-rtti`` disables the use of RTTI. C++11; -----. The features listed below are part of the C++11 standard. As a result, all; these features are enabled with the ``-std=c++11`` or ``-std=gnu++11`` option; when compiling C++ code. C++11 SFINAE includes access control; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_access_control_sfinae)`` or; ``__has_extension(cxx_access_control_sfinae)`` to determine whether; access-control errors (e.g., calling a private constructor) are considered to; be template argument deduction errors (aka SFINAE errors), per `C++ DR1170; <http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1170>`_. C++11 alias templates; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_alias_templates)`` or; ``__has_extension(cxx_alias_templates)`` to determine if support for C++11's; alias declarations and alias templates is enabled. C++11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_alignas)`` or ``__has_extension(cxx_alignas)`` to; determine if support for alignment specifiers using ``alignas`` is enabled. Use ``__has_feature(cxx_alignof)`` or ``__has_extension(cxx_alignof)`` to; determine if support for the ``alignof`` keyword is enabled. C++11 attributes; ^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_attributes)`` or ``__has_extension(cxx_attributes)`` to; determine if support for attribute parsing ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:40315,access,access-control,40315,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['access'],['access-control']
Security,"s:; """""""""""""""""""". The first argument is a pointer to be tested. The second argument is a; metadata object representing a :doc:`type identifier <TypeMetadata>`. Overview:; """""""""""""""""". The ``llvm.type.test`` intrinsic tests whether the given pointer is associated; with the given type identifier. .. _type.checked.load:. '``llvm.type.checked.load``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare {ptr, i1} @llvm.type.checked.load(ptr %ptr, i32 %offset, metadata %type) nounwind memory(argmem: read). Arguments:; """""""""""""""""""". The first argument is a pointer from which to load a function pointer. The; second argument is the byte offset from which to load the function pointer. The; third argument is a metadata object representing a :doc:`type identifier; <TypeMetadata>`. Overview:; """""""""""""""""". The ``llvm.type.checked.load`` intrinsic safely loads a function pointer from a; virtual table pointer using type metadata. This intrinsic is used to implement; control flow integrity in conjunction with virtual call optimization. The; virtual call optimization pass will optimize away ``llvm.type.checked.load``; intrinsics associated with devirtualized calls, thereby removing the type; check in cases where it is not needed to enforce the control flow integrity; constraint. If the given pointer is associated with a type metadata identifier, this; function returns true as the second element of its return value. (Note that; the function may also return true if the given pointer is not associated; with a type metadata identifier.) If the function's return value's second; element is true, the following rules apply to the first element:. - If the given pointer is associated with the given type metadata identifier,; it is the function pointer loaded from the given byte offset from the given; pointer. - If the given pointer is not associated with the given type metadata; identifier, it is one of the following (the choice of which is unspecified):. 1. The function poi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:938368,integrity,integrity,938368,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['integrity'],['integrity']
Security,"s; ====================. If none of the built in GC strategy descriptions met your needs above, you will; need to define a custom GCStrategy and possibly, a custom LLVM pass to perform; lowering. Your best example of where to start defining a custom GCStrategy; would be to look at one of the built in strategies. You may be able to structure this additional code as a loadable plugin library.; Loadable plugins are sufficient if all you need is to enable a different; combination of built in functionality, but if you need to provide a custom; lowering pass, you will need to build a patched version of LLVM. If you think; you need a patched build, please ask for advice on llvm-dev. There may be an; easy way we can extend the support to make it work for your use case without; requiring a custom build. Collector Requirements; ----------------------. You should be able to leverage any existing collector library that includes the following elements:. #. A memory allocator which exposes an allocation function your compiled; code can call. #. A binary format for the stack map. A stack map describes the location; of references at a safepoint and is used by precise collectors to identify; references within a stack frame on the machine stack. Note that collectors; which conservatively scan the stack don't require such a structure. #. A stack crawler to discover functions on the call stack, and enumerate the; references listed in the stack map for each call site. #. A mechanism for identifying references in global locations (e.g. global; variables). #. If you collector requires them, an LLVM IR implementation of your collectors; load and store barriers. Note that since many collectors don't require; barriers at all, LLVM defaults to lowering such barriers to normal loads; and stores unless you arrange otherwise. Implementing a collector plugin; -------------------------------. User code specifies which GC code generation to use with the ``gc`` function; attribute or, equivalently, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:22513,expose,exposes,22513,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['expose'],['exposes']
Security,"s; Clang 17. 2522; open; Removing placemarker tokens and retention of whitespace; Not resolved. 2523; C++23; Undefined behavior via omitted destructor call in constant expressions; Unknown. 2524; NAD; Distinguishing user-defined conversion sequences by ref-qualifier; Unknown. 2525; drafting; Incorrect definition of implicit conversion sequence; Not resolved. 2526; C++23; Relational comparison of void* pointers; Unknown. 2527; NAD; Non-class potentially-overlapping objects; Unknown. 2528; C++23; Three-way comparison and the usual arithmetic conversions; Unknown. 2529; C++23; Constant destruction of constexpr references; Unknown. 2530; C++23; Multiple definitions of enumerators; Unknown. 2531; DR; Static data members redeclared as constexpr; Unknown. 2532; open; Kind of pointer value returned by new T[0]; Not resolved. 2533; review; Storage duration of implicitly created objects; Not resolved. 2534; CD6; Value category of pseudo-destructor expression; Unknown. 2535; CD6; Type punning in class member access; Unknown. 2536; open; Partially initialized variables during constant initialization; Not resolved. 2537; drafting; Overbroad grammar for parameter-declaration; Not resolved. 2538; C++23; Can standard attributes be syntactically ignored?; Unknown. 2539; C++23; Three-way comparison requiring strong ordering for floating-point types; Unknown. 2540; CD6; Unspecified interpretation of numeric-escape-sequence; Unknown. 2541; open; Linkage specifications, module purview, and module attachment; Not resolved. 2542; DRWP; Is a closure type a structural type?; Unknown. 2543; C++23; constinit and optimized dynamic initialization; Unknown. 2544; open; Address of past-the-end of a potentially-overlapping subobject; Not resolved. 2545; open; Transparently replacing objects in constant expressions; Not resolved. 2546; tentatively ready; Defaulted secondary comparison operators defined as deleted; Unknown. 2547; tentatively ready; Defaulted comparison operator function for non-class",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:173967,access,access,173967,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['access'],['access']
Security,"s; Using ccache materially improves average build times. Incremental builds; can be slightly faster, but introduce the risk of build corruption due to; e.g. state changes, etc... At this point, the recommendation is not to; use incremental builds and instead use ccache as the latter captures the; majority of the benefit with less risk of false positives. One of the non-obvious benefits of using ccache is that it makes the; builder less sensitive to which projects are being monitored vs built.; If a change triggers a build request, but doesn't change the build output; (e.g. doc changes, python utility changes, etc..), the build will entirely; hit in cache and the build request will complete in just the testing time. With multiple workers, it is tempting to try to configure a shared cache; between the workers. Experience to date indicates this is difficult to; well, and that having local per-worker caches gets most of the benefit; anyways. We don't currently recommend shared caches. CCache does depend on the builder hardware having sufficient IO to access; the cache with reasonable access times - i.e. a fast disk, or enough memory; for a RAM cache, etc.. For builders without, incremental may be your best; option, but is likely to require higher ongoing involvement from the; sponsor. Enable batch builds; As a last resort, you can configure your builder to batch build requests.; This makes the build failure notifications markedly less actionable, and; should only be done once all other reasonable measures have been taken. Leave it on the staging buildmaster; While most of this section has been biased towards builders intended for; the main buildmaster, it is worth highlighting that builders can run; indefinitely on the staging buildmaster. Such a builder may still be; useful for the sponsoring organization, without concern of negatively; impacting the broader community. The sponsoring organization simply; has to take on the responsibility of all bisection and triage. ; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:12145,access,access,12145,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,2,['access'],['access']
Security,"s; ^^^^^. The optional ``Calls`` field looks like:. .. code-block:: text. calls: ((Callee)[, (Callee)]*). where each ``Callee`` looks like:. .. code-block:: text. callee: ^1[, hotness: None]?[, relbf: 0]?. The ``callee`` refers to the summary entry id of the callee. At most one; of ``hotness`` (which can take the values ``Unknown``, ``Cold``, ``None``,; ``Hot``, and ``Critical``), and ``relbf`` (which holds the integer; branch frequency relative to the entry frequency, scaled down by 2^8); may be specified. The defaults are ``Unknown`` and ``0``, respectively. .. _params_summary:. Params; ^^^^^^. The optional ``Params`` is used by ``StackSafety`` and looks like:. .. code-block:: text. Params: ((Param)[, (Param)]*). where each ``Param`` describes pointer parameter access inside of the; function and looks like:. .. code-block:: text. param: 4, offset: [0, 5][, calls: ((Callee)[, (Callee)]*)]?. where the first ``param`` is the number of the parameter it describes,; ``offset`` is the inclusive range of offsets from the pointer parameter to bytes; which can be accessed by the function. This range does not include accesses by; function calls from ``calls`` list. where each ``Callee`` describes how parameter is forwarded into other; functions and looks like:. .. code-block:: text. callee: ^3, param: 5, offset: [-3, 3]. The ``callee`` refers to the summary entry id of the callee, ``param`` is; the number of the callee parameter which points into the callers parameter; with offset known to be inside of the ``offset`` range. ``calls`` will be; consumed and removed by thin link stage to update ``Param::offset`` so it; covers all accesses possible by ``calls``. Pointer parameter without corresponding ``Param`` is considered unsafe and we; assume that access with any offset is possible. Example:. If we have the following function:. .. code-block:: text. define i64 @foo(ptr %0, ptr %1, ptr %2, i8 %3) {; store ptr %1, ptr @x; %5 = getelementptr inbounds i8, ptr %2, i64 5; %6 = load",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:344606,access,accessed,344606,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessed']
Security,"s; passed in the kernarg. "".value_type"" string Unused and deprecated. This should no longer; be emitted, but is accepted for compatibility. "".pointee_align"" integer Alignment in bytes of pointee; type for pointer type kernel; argument. Must be a power; of 2. Only present if; "".value_kind"" is; ""dynamic_shared_pointer"".; "".address_space"" string Kernel argument address space; qualifier. Only present if; "".value_kind"" is ""global_buffer"" or; ""dynamic_shared_pointer"". Values; are:. - ""private""; - ""global""; - ""constant""; - ""local""; - ""generic""; - ""region"". .. TODO::. Is ""global_buffer"" only ""global""; or ""constant""? Is; ""dynamic_shared_pointer"" always; ""local""? Can HCC allow ""generic""?; How can ""private"" or ""region""; ever happen?. "".access"" string Kernel argument access; qualifier. Only present if; "".value_kind"" is ""image"" or; ""pipe"". Values; are:. - ""read_only""; - ""write_only""; - ""read_write"". .. TODO::. Does this apply to; ""global_buffer""?. "".actual_access"" string The actual memory accesses; performed by the kernel on the; kernel argument. Only present if; "".value_kind"" is ""global_buffer"",; ""image"", or ""pipe"". This may be; more restrictive than indicated; by "".access"" to reflect what the; kernel actual does. If not; present then the runtime must; assume what is implied by; "".access"" and "".is_const"" . Values; are:. - ""read_only""; - ""write_only""; - ""read_write"". "".is_const"" boolean Indicates if the kernel argument; is const qualified. Only present; if "".value_kind"" is; ""global_buffer"". "".is_restrict"" boolean Indicates if the kernel argument; is restrict qualified. Only; present if "".value_kind"" is; ""global_buffer"". "".is_volatile"" boolean Indicates if the kernel argument; is volatile qualified. Only; present if "".value_kind"" is; ""global_buffer"". "".is_pipe"" boolean Indicates if the kernel argument; is pipe qualified. Only present; if "".value_kind"" is ""pipe"". .. TODO::. Can ""global_buffer"" be pipe; qualified?. ====================== ============== ========= ===================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:139779,access,accesses,139779,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accesses']
Security,"s; that every name declared public is seen by the outside world. This is; opposed to ""`private`"" that means only the class where the name was; declared private could see this name. For example, suppose we declare; in **`TArrow`** the variable `ArrowHeadSize` private. ``` {.cpp}; private:; int ArrowHeadSize;; ```. Then, only the methods (i.e. member functions) of **`TArrow`** will be; able to access this variable. Nobody else will see it. Even the; classes that we could derive from **`TArrow`** will not see it. On the; other hand, if we declare the method `Draw()` as public, everybody will; be able to see it and use it. You see that the character public or; private does not depend of the type of argument. It can be a data; member, a member function, or even a class. For example, in the case; of **`TArrow`**, the base class **`TLine`** is declared as public:. ``` {.cpp}; class TArrow : public TLine { ...; ```. This means that all methods of **`TArrow`** will be able to access all; methods of **`TLine`**, but this will be also true for anybody in the; outside world. Of course, this is true if **`TLine`** accepts the; outside world to see its methods/data members. If something is; declared private in **`TLine`**, nobody will see it, not even; **`TArrow`** members, even if **`TLine`** is declared as a public; base class. What if **`TLine`** is declared ""`private`"" instead of ""`public`"" ?; Well, it will behave as any other name declared private in; **`TArrow`**: only the data members and methods of **`TArrow`** will; be able to access **`TLine`**, its methods and data members, nobody; else. This may seem a little bit confusing and readers should read a; good C++ book if they want more details. Especially since, besides; public and private, a member can be protected. Usually, one puts; private the methods that the class uses internally, like some; utilities classes, and that the programmer does not want to be seen; in the outside world. With ""good"" C++ practice (which we h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:4931,access,access,4931,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['access'],['access']
Security,"s;; ~~~. Example to create a symmetric matrix from a ROOT::Math::SVector containing the lower/upper data block:. ~~~ {.cpp}; ROOT::Math::SVector<double, 6> v(1,2,3,4,5,6);; SMatrixSym3 s1(v); // lower block (default); // this will produce the symmetric matrix; // ( 1 2 4; // 2 3 5; // 4 5 6 ). SMatrixSym3 s2(v,false); // upper block; // this will produce the symmetric matrix; // ( 1 2 3; // 2 4 5; // 3 5 6 ); ~~~. ### Accessing and Setting Methods. The matrix elements can be set using the _operator()(irow,icol)_, where irow and icol are; the row and column indexes or by using the iterator interface. Notice that the indexes start; from zero and not from one as in FORTRAN. All the matrix elements can be set also by using; the ROOT::Math::SetElements function passing a generic iterator.; The elements can be accessed by these same methods and also by using the; ROOT::Math::SMatrix::apply function. The _apply(i)_ function has exactly the same behavior; for general and symmetric matrices, in contrast to the iterator access methods which behave; differently (it follows the data order). ~~~ {.cpp}; SMatrix33 m;; m(0,0) = 1; // set the element in first row and first column; *(m.begin()+1) = 2; // set the second element (0,1); double d[9]={1,2,3,4,5,6,7,8,9};; m.SetElements(d,d+9); // set the d[] values in m. double x = m(2,1); // return the element in third row and first column; x = m.apply(7); // return the 8-th element (row=2,col=1); x = *(m.begin()+7); // return the 8-th element (row=2,col=1); // symmetric matrices (note the difference in behavior between apply and the iterators); x = *(m.begin()+4) // return the element (row=2,col=1).; x = m.apply(7); // returns again the (row=2,col=1) element; ~~~. There are methods to place and/or retrieve ROOT::Math::SVector objects as rows or columns; in (from) a matrix. In addition one can put (get) a sub-matrix as another; ROOT::Math::SMatrix object in a matrix. If the size of the sub-vector or sub-matrix are; larger than the matrix",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/doc/SMatrixClass.md:5292,access,access,5292,math/smatrix/doc/SMatrixClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/doc/SMatrixClass.md,1,['access'],['access']
Security,"s`` interfaces require that in queries involving multiple; values, values which are not :ref:`constants <constants>` are all; defined within the same function. Representation of Pointers; --------------------------. Most importantly, the ``AliasAnalysis`` class provides several methods which are; used to query whether or not two memory objects alias, whether function calls; can modify or read a memory object, etc. For all of these queries, memory; objects are represented as a pair of their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a starting address and a size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this case, the ``basic-aa`` pass will disambiguate the stores to ``C[0]`` and; ``C[1]`` because they are accesses to two distinct locations one byte apart, and; the accesses are each one byte. In this case, the Loop Invariant Code Motion; (LICM) pass can use store motion to remove the stores from the loop. In; contrast, the following code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; ((short*)C)[0] = A[i]; /* Two byte store! */; C[1] = A[9-i]; /* One byte store */; }. In this case, the two stores to C do alias each other, because the access to the; ``&C[0]`` element is a two byte access. If size information wasn't available in; the query, even the first case would have to conservatively assume that the; accesses alias. .. _alias:. The ``alias`` method; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:3550,access,accesses,3550,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,2,['access'],['accesses']
Security,"sanitiser config into any non-sanitised executable, e.g. python.; 2. ROOT executables will get the config automatically, using a static version of the config library, `libROOTStaticSanitizerConfig.a`.; All ROOT executables statically link against it, so they start up without reporting lots of unfixable memory leaks (e.g. llvm). #### Small linker magic to get the config symbols into ROOT's executables; When linking a ROOT executable, the setup functions from the sanitiser config library might get ignored, because they are not used in any of our executables.; In `cmake/modules/SetUp{Linux|MacOS}.cmake`, the functions are therefore marked as ""undefined"" for the linker, so it starts copying; them into all ROOT executables.; This way, root.exe, cling, ... can start up with a sane default config. ### Use your own address/leak sanitizer configuration; The default configurations can be overridden using the environment variables `ASAN_OPTIONS` and `LSAN_OPTIONS`. Refer to the; [address sanitizer documentation](https://github.com/google/sanitizers/wiki/AddressSanitizer) or use `ASAN_OPTIONS=help=1` when starting; up a sanitised executable (e.g. `root.exe`). A template for a leak suppression file can be found in `$ROOTSYS/etc/lsan-root.supp`. ## Create your own sanitised executable; ROOT exports a library target called `ROOT::ROOTStaticSanitizerConfig` that can be used to create sanitised executables with ROOT's default; address sanitizer config. Linking against this target will add the above setup functions and also add the address sanitizer flags that; ROOT was built with. It should be sufficient to; - Link all executables against this target; - And have `-fsanitize=address` in the `CXXFLAGS`. ## Use sanitised ROOT libraries from a non-sanitised executable (e.g. `python`); When ROOT libraries are built with sanitizers, the address sanitizer runtime needs to be loaded at startup. However, when calling into ROOT; functions from python, that won't happen, since python is not sa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md:1834,sanitiz,sanitizer,1834,core/sanitizer/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md,1,['sanitiz'],['sanitizer']
Security,"schema evolution from:; TParameter<Int_t>* MyInt; //-> version 1to; TParameter<Int_t> MyInt; // version 2. The TZIPFile compressed archive reader now supports the Zip64 format for; archives and file members greater than 2 and 4 GB, respectively. MakeProject. Add support for the case when the requested project/files in path that in not under the current directory; Generate the code/dictonary only for pair type that do not already have a dictionary. Object Merging; We introduced a new explicit interface for providing merging; capability. If a class has a method with the name and; signature:. Long64_t Merge(TCollection *input, TFileMergeInfo*);. it will be used by a TFileMerger (and thus by PROOF) to merge one or more; other objects into the current object. Merge should; return a negative value if the merging failed. If this method does not exist, the TFileMerger will use; a method with the name and signature:. Long64_t Merge(TCollection *input);. TClass now provides a quick access to these merging; function via TClass::GetMerge. The wrapper function; is automatically created by rootcint and can be installed; via TClass::SetMerge. The wrapper function should have; the signature/type ROOT::MergeFunc_t:. Long64_t (*)(void *thisobj, TCollection *input, TFileMergeInfo*);. We added the new Merge function to TTree and THStack.; We also added the new Merge function to TQCommand as the; existing TQCommand::Merge does not have the right; semantic (in part because TQCommand is a collection). In TFileMerger, we added a PrintLevel to allow hadd to request; more output than regular TFileMerger. We removed all hard dependencies of TFileMerger on TH1 and TTree.; (Soft dependencies still exist to be able to disable the; merging of TTrees and to be able to disable the AutoAdd; behavior of TH1). The object TFileMergeInfo can be used inside the Merge; function to pass information between runs of the Merge; (see below). In particular it contains:. TDirectory *fOutputDirectory; // Target d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html:3095,access,access,3095,io/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html,1,['access'],['access']
Security,"scope. However, some passes want to peek up or; down the IR hierarchy. For example, an SCC pass may want to look at function; analyses for the functions inside the SCC. Or it may want to look at some; immutable global analysis. In these cases, the analysis manager can provide a; proxy to an outer or inner level analysis manager. For example, to get a; ``FunctionAnalysisManager`` from a ``CGSCCAnalysisManager``, you can call. .. code-block:: c++. FunctionAnalysisManager &FAM =; AM.getResult<FunctionAnalysisManagerCGSCCProxy>(InitialC, CG); .getManager();. and use ``FAM`` as a typical ``FunctionAnalysisManager`` that a function pass; would have access to. To get access to an outer level IR analysis, you can; call. .. code-block:: c++. const auto &MAMProxy =; AM.getResult<ModuleAnalysisManagerCGSCCProxy>(InitialC, CG);; FooAnalysisResult *AR = MAMProxy.getCachedResult<FooAnalysis>(M);. Asking for a cached and immutable outer level IR analysis works via; ``getCachedResult()``, but getting direct access to an outer level IR analysis; manager to compute an outer level IR analysis is not allowed. This is for a; couple reasons. The first reason is that running analyses across outer level IR in inner level; IR passes can result in quadratic compile time behavior. For example, a module; analysis often scans every function and allowing function passes to run a module; analysis may cause us to scan functions a quadratic number of times. If passes; could keep outer level analyses up to date rather than computing them on demand; this wouldn't be an issue, but that would be a lot of work to ensure every pass; updates all outer level analyses, and so far this hasn't been necessary and; there isn't infrastructure for this (aside from function analyses in loop passes; as described below). Self-updating analyses that gracefully degrade also handle; this problem (e.g. GlobalsAA), but they run into the issue of having to be; manually recomputed somewhere in the optimization pipeline if w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:8754,access,access,8754,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['access'],['access']
Security,"scover the stream's MSF stream index. Several important streams (such as the; global string table, which is called ``/names``) can only be located this way, and; so it is important to both produce and consume this correctly as tools will not; function correctly without it. .. important::; Some streams are located by fixed indices (e.g TPI Stream has index 2), but; other streams are located by fixed names (e.g. the string table is called; ``/names``) and can only be located by consulting the Named Stream Map. The on-disk layout of the Named Stream Map consists of 2 components. The first is; a buffer of string data prefixed by a 32-bit length. The second is a serialized; hash table whose key and value types are both ``uint32_t``. The key is the offset; of a null-terminated string in the string data buffer specifying the name of the; stream, and the value is the MSF stream index of the stream with said name.; Note that although the key is an integer, the hash function used to find the right; bucket hashes the string at the corresponding offset in the string data buffer. The on-disk layout of the serialized hash table is described at :doc:`HashTable`. Note that the entire Named Stream Map is not length-prefixed, so the only way to; get to the data following it is to de-serialize it in its entirety. .. _pdb_stream_features:. PDB Feature Codes; =================; Following the Named Stream Map, and consuming all remaining bytes of the PDB; Stream is a list of values from the following enumeration:. .. code-block:: c++. enum class PdbRaw_FeatureSig : uint32_t {; VC110 = 20091201,; VC140 = 20140508,; NoTypeMerge = 0x4D544F4E,; MinimalDebugInfo = 0x494E494D,; };. The meaning of these values is summarized by the following table:. +------------------+-------------------------------------------------+; | Flag | Meaning |; +==================+=================================================+; | VC110 | - No other features flags are present |; | | - PDB contains an :doc:`IPI Stre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst:3659,hash,hash,3659,interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst,2,['hash'],"['hash', 'hashes']"
Security,"scriminator>, i64 <integer discriminator>); ```. ##### Overview:. The '`llvm.ptrauth.blend`' intrinsic blends a pointer address discriminator; with a small integer discriminator to produce a new ""blended"" discriminator. ##### Arguments:. The `address discriminator` argument is a pointer value.; The `integer discriminator` argument is a small integer, as specified by the; target. ##### Semantics:. The '`llvm.ptrauth.blend`' intrinsic combines a small integer discriminator; with a pointer address discriminator, in a way that is specified by the target; implementation. ### Operand Bundle. Function pointers used as indirect call targets can be signed when materialized,; and authenticated before calls. This can be accomplished with the; [`llvm.ptrauth.auth`](#llvm-ptrauth-auth) intrinsic, feeding its result to; an indirect call. However, that exposes the intermediate, unauthenticated pointer, e.g., if it; gets spilled to the stack. An attacker can then overwrite the pointer in; memory, negating the security benefit provided by pointer authentication.; To prevent that, the `ptrauth` operand bundle may be used: it guarantees that; the intermediate call target is kept in a register and never stored to memory.; This hardening benefit is similar to that provided by; [`llvm.ptrauth.resign`](#llvm-ptrauth-resign)). Concretely:. ```llvm; define void @f(void ()* %fp) {; call void %fp() [ ""ptrauth""(i32 <key>, i64 <data>) ]; ret void; }; ```. is functionally equivalent to:. ```llvm; define void @f(void ()* %fp) {; %fp_i = ptrtoint void ()* %fp to i64; %fp_auth = call i64 @llvm.ptrauth.auth(i64 %fp_i, i32 <key>, i64 <data>); %fp_auth_p = inttoptr i64 %fp_auth to void ()*; call void %fp_auth_p(); ret void; }; ```. but with the added guarantee that `%fp_i`, `%fp_auth`, and `%fp_auth_p`; are not stored to (and reloaded from) memory. ## AArch64 Support. AArch64 is currently the only architecture with full support of the pointer; authentication primitives, based on Armv8.3-A instructions.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md:6776,attack,attacker,6776,interpreter/llvm-project/llvm/docs/PointerAuth.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md,3,"['attack', 'authenticat', 'secur']","['attacker', 'authentication', 'security']"
Security,"scriptors; plus a 32-bit offset into the buffer (in total encapsulating a 160-bit; *pointer*), allowing normal LLVM load/store/atomic operations to be used to; model the buffer descriptors used heavily in graphics workloads targeting; the backend. The buffer descriptor used to construct a buffer fat pointer must be *raw*:; the stride must be 0, the ""add tid"" flag must be 0, the swizzle enable bits; must be off, and the extent must be measured in bytes. (On subtargets where; bounds checking may be disabled, buffer fat pointers may choose to enable; it or not). **Buffer Resource**; The buffer resource pointer, in address space 8, is the newer form; for representing buffer descriptors in AMDGPU IR, replacing their; previous representation as `<4 x i32>`. It is a non-integral pointer; that represents a 128-bit buffer descriptor resource (`V#`). Since, in general, a buffer resource supports complex addressing modes that cannot; be easily represented in LLVM (such as implicit swizzled access to structured; buffers), it is **illegal** to perform non-trivial address computations, such as; ``getelementptr`` operations, on buffer resources. They may be passed to; AMDGPU buffer intrinsics, and they may be converted to and from ``i128``. Casting a buffer resource to a buffer fat pointer is permitted and adds an offset; of 0. Buffer resources can be created from 64-bit pointers (which should be either; generic or global) using the `llvm.amdgcn.make.buffer.rsrc` intrinsic, which; takes the pointer, which becomes the base of the resource,; the 16-bit stride (and swzizzle control) field stored in bits `63:48` of a `V#`,; the 32-bit NumRecords/extent field (bits `95:64`), and the 32-bit flags field; (bits `127:96`). The specific interpretation of these fields varies by the; target architecture and is detailed in the ISA descriptions. **Buffer Strided Pointer**; The buffer index pointer is an experimental address space. It represents; a 128-bit buffer descriptor and a 32-bit offset, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:29735,access,access,29735,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"se issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and ``extreme``.; - The ``model`` attribute was now supported for overriding the default code; model used to access global variables. The following values were supported:; ``normal``, ``medium`` and ``extreme``. *Example Code*:. .. code-block:: c. int var __attribute((model(""extreme"")));. - Default to ``-fno-direct-access-external-data`` for non-PIC.; - An ABI mismatch with gcc/g++ about empty structs/unions passing was fixed.; - ``_mcount`` was generated instead of ``mcount``. RISC-V Support; ^^^^^^^^^^^^^^; - Unaligned memory accesses can be toggled by ``-m[no-]unaligned-access`` or the; aliases ``-m[no-]strict-align``.; - CodeGen of RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introdu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:64222,access,accesses,64222,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,2,['access'],"['access', 'accesses']"
Security,"se such class to; create JSON files for selected objects and write such files in a directory,; which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser. There is a demonstration page showing such functionality: <https://root.cern/js/latest/demo/update_draw.htm>.; This demo page reads in cycle 20 json files and displays them. If one has a web server which already provides such JSON file, one could specify the URL to this file like:. <https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz>. Here the same problem with [Cross-Origin Request](https://developer.mozilla.org/en/http_access_control) can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself. ### Binary file-based monitoring (not recommended). Theoretically, one could use binary ROOT files to implement monitoring.; With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats. First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate. The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol.; There is no http file locking mechanism (at least not for standard web servers),; therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:32382,access,accessed,32382,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['access'],['accessed']
Security,"se tags with the YAML I/O; model. Recently, we added support to YAML I/O for checking/setting the optional; tag on a map. Using this functionality it is even possible to support different; mappings, as long as they are convertible. To check a tag, inside your mapping() method you can use io.mapTag() to specify; what the tag should be. This will also add that tag when writing yaml. Validation; ----------. Sometimes in a YAML map, each key/value pair is valid, but the combination is; not. This is similar to something having no syntax errors, but still having; semantic errors. To support semantic level checking, YAML I/O allows; an optional ``validate()`` method in a MappingTraits template specialization. When parsing YAML, the ``validate()`` method is call *after* all key/values in; the map have been processed. Any error message returned by the ``validate()``; method during input will be printed just a like a syntax error would be printed.; When writing YAML, the ``validate()`` method is called *before* the YAML; key/values are written. Any error during output will trigger an ``assert()``; because it is a programming error to have invalid struct values. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. struct Stuff {; ...; };. template <>; struct MappingTraits<Stuff> {; static void mapping(IO &io, Stuff &stuff) {; ...; }; static std::string validate(IO &io, Stuff &stuff) {; // Look at all fields in 'stuff' and if there; // are any bad values return a string describing; // the error. Otherwise return an empty string.; return std::string{};; }; };. Flow Mapping; ------------; A YAML ""flow mapping"" is a mapping that uses the inline notation; (e.g { x: 1, y: 0 } ) when written to YAML. To specify that a type should be; written in YAML using flow mapping, your MappingTraits specialization should; add ""static const bool flow = true;"". For instance:. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. struct Stuff {; ...; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:23610,validat,validate,23610,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['validat'],['validate']
Security,"sed as; the address space identifier. The DWARF expression is ill-formed if AS is not one of the values defined by; the target architecture specific ``DW_ASPACE_LLVM_*`` values. .. note::. Could also consider adding ``DW_OP_LLVM_aspace_breg0,; DW_OP_LLVM_aspace_breg1, ..., DW_OP_LLVM_aspace_bref31`` which would save; encoding size. .. _amdgpu-dwarf-register-location-description-operations:. A.2.5.4.4.4 Register Location Description Operations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. note::. This section replaces DWARF Version 5 section 2.6.1.1.3. There is a register location storage that corresponds to each of the target; architecture registers. The size of each register location storage corresponds; to the size of the corresponding target architecture register. A register location description specifies a register location storage. The bit; offset corresponds to a bit position within the register. Bits accessed using a; register location description access the corresponding target architecture; register starting at the specified bit offset. 1. ``DW_OP_reg0``, ``DW_OP_reg1``, ..., ``DW_OP_reg31``. ``DW_OP_reg<N>`` operations encode the numbers of up to 32 registers,; numbered from 0 through 31, inclusive. The target architecture register; number R corresponds to the N in the operation name. The operation is equivalent to performing ``DW_OP_regx R``. 2. ``DW_OP_regx``. ``DW_OP_regx`` has a single unsigned LEB128 integer operand that represents; a target architecture register number R. If the current call frame is the top call frame, it pushes a location; description L that specifies one register location description SL on the; stack. SL specifies the register location storage that corresponds to R with; a bit offset of 0 for the current thread. If the current call frame is not the top call frame, call frame information; (see :ref:`amdgpu-dwarf-call-frame-information`) is used to determine the; location description that holds the register for the curre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:118222,access,accessed,118222,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,2,['access'],"['access', 'accessed']"
Security,"sed to identify the entries created from this model.; Unless a model is created as ""bare model"", it owns a default entry that is used by default by the `RNTupleReader` and the `RNTupleWriter`. A model can add _projected fields_.; Projected fields map existing physical fields to a different type.; For instance, a `std::vector<Event>` can be projected onto a `std::vector<float>` for a float member of `Event`.; Projected fields are stored as header meta-data. Fields can be added to a model after the writing process has started (cf. `RNTupleWriter::CreateModelUpdater()`).; This is called _late model extension_.; Addition of fields invalidates previously created entries.; The values of deferred fields for the already written entries is set to the default constructed type of the field. ### REntry; The REntry represents a row/entry in an RNTuple.; It contains a list of `RValue` objects that correspond to the top-level fields of the originating model.; The entry gives access to the shared pointers corresponding to the top-level fields.; It also provides functionality to bind application-provided pointers. An REntry can be passed to `RNTupleWriter::Fill()` and `RNTupleReader::LoadEntry()`.; Otherwise, the reader/writer uses the default entry of its model. An entry can safely outlive its originating model.; New objects cannot anymore be created (`EmplaceNewValue` will throw an exception), but the entry is still properly destructed. ### RNTupleWriter, RNTupleParallelWriter; The RNTupleWriter is the primary interface to create an RNTuple.; The writer takes ownership of a given model.; The writer can either add an RNTuple to an existing ROOT file (`RNTupleWriter::Append()`) or create a new ROOT file with an RNTuple (`RNTupleWriter::Recreate()`).; Once created, entries are added to an RNTuple either serially (`RNTupleWriter::Fill()`) or in concurrently in multiple threads with the `RNTupleParallelWriter`.; Once committed (e.g. by releasing the RNTupleWriter), the RNTuple is immut",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:11605,access,access,11605,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['access'],['access']
Security,"seful methods. All of them can be considered as building blocks; for an application, and most of them can be found in dialogs. Provided; snippets of the code will give you practical guidelines where and how to; use certain widgets. The macro `$ROOTSYS/tutorials/gui/guitest.C`; contains the complete source code. ![Widgets created by ROOT GUI classes](pictures/02000204.jpg). Any custom widget can be created by sub classing existing widgets. To; achieve a better understanding of the widgets' properties they are; separated by their type and their inheritance. As all of them inherit; from **`TGObject`** and most from **`TGWidget`**, these base classes are; described first. ### TGObject. **`TGObject`** is the base class for all ROOT GUI classes. It inherits; from **`TObject`**. The two data members of this class contain important; information about X11/Win32 window identifier and the connection to the; host's graphics system. Every GUI element, which derives from; **`TGObject`** has access to the **`TGClient`** via the data member; `fClient` of **`TGObject. TGClient`** creates the connection with the; host's graphics system and sets up the complete graphics system for all; widgets. ### TGWidget. The widgets base class **`TGWidget`** is typically used as a mix-in; class via multiple inheritances. Its properties are available for all; deriving widgets: **`TGButton`**, **`TGComboBox`**, **`TGTab`**,; **`TGColorPalette`**, **`TGColorPick`**, **`TGDoubleSlider`**,; **`TGListTree`**, **`TGNumberEntry`**, **`TGScrollBar`**,; **`TGShutterItem`**, **`TGTextEntry`**, **`TGSlider`**, **`TGListBox`**,; **`TGView.`**. This class has four data members keeping information about the widget id; - important for event processing, the window which handles the widget's; events, the widget status flags and the assigned command (if there is; any). The general properties of **`TGWidget`** are specified by; `SetFlags(Int_t flags)` and `ClearFlags(Int_t flags)` methods. The; status flags are: `kWi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:21259,access,access,21259,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['access'],['access']
Security,"sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:66958,attack,attacker,66958,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['attack'],['attacker']
Security,"servables and their values; // are taken from the dataset:; model.fitTo(*data);. // You can still define the set of global observables yourself, but the values; // will be takes from the dataset if available:; model.fitTo(*data, GlobalObservables(g1, g2));. // To force `fitTo` to take the global observable values from the model even; // though they are in the dataset, you can use the new `GlobalObservablesSource`; // command argument:; model.fitTo(*data, GlobalObservables(g1, g2), GlobalObservablesSource(""model""));; // The only other allowed value for `GlobalObservablesSource` is ""data"", which; // corresponds to the new default behavior explained above.; ```. In case you create a RooFit dataset directly by calling its constructor, you can also pass the global observables in a command argument instead of calling `setGlobalObservables()` later:; ```C++; RooDataSet data{""dataset"", ""dataset"", x, RooFit::GlobalObservables(g1, g2)};; ```. To access the set of global observables stored in a `RooAbsData`, call `RooAbsData::getGlobalObservables()`.; It returns a `nullptr` if no global observable snapshots are stored in the dataset. For more information of global observables and how to attach them to the toy datasets, please take a look at the new; [rf613_global_observables.C](https://root.cern/doc/v626/rf613__global_observables_8C.html) / [.py](https://root.cern/doc/v626/rf613__global_observables_8py.html) tutorial. ### Changes in `RooAbsPdf::fitTo` behaviour for multi-range fits. The `RooAbsPdf::fitTo` and `RooAbsPdf::createNLL` functions accept a command argument to specify the fit range.; One can also fit in multiple ranges simultaneously.; The definition of such multi-range likelihoods for non-extended fits changes in this release.; Previously, the individual likelihoods were normalized separately in each range, which meant that the relative number of events in each sub-range was not used to estimate the PDF parameters.; From now on, the likelihoods are normalized by the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:29106,access,access,29106,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['access'],['access']
Security,"server.C macro on Apache webserver; 3. Evaluate 'monitoring' parameter for online server like:; <http://localhost:8080/?monitoring=1000>; Parameter defines how often displayed objects should be updated.; 4. Implement 'opt' and 'opts' URL parameters for main page.; 5. Show progress with scripts loading in the browser window; 6. When one appends ""+"" to the filename, its content read completely with first I/O operation.; 7. Implement JS custom streamer for TCanvas, restore aspect ratio when drawing; 8. Major redesign of drawing classes. Resize and update of TCanvas are implemented.; All major draw functions working with HTML element id as first argument.; 9. Extract 3D drawings into separate JSRoot3DPainter.js script; 10. Use newest three.min.js (r68) for 3D drawings, solves problem with Firefox.; 11. Introduce generic list of draw functions for all supported classes.; 12. Add possibility to 'expand' normal objects in the hierarchy browser.; For instance, this gives access to single elements of canvas,; when whole canvas cannot be drawn.; 13. Correct usage of colors map, provided with TCanvas.; 14. Introduce JSROOT.redraw() function which is capable to create or update object drawing.; 15. In main index.htm page browser can be disabled (nobrowser parameter) and; page can be used to display only specified items from the file; 16. Add support of TPolyMarker3D in binary I/O. ### September 2014; 1. First try to handle resize of the browser,; for the moment works only with collapsible layout; 2. Also first try to interactively move separation line between; browser and drawing field.; 3. Small fix of minor ticks drawing on the axis; 4. Introduce display class for MDI drawing. Provide two implementations -; 'collapsible' for old kind and 'tabs' for new kinds.; 5. Adjust size of color palette drawing when labels would take more place as provided.; 6. Add correct filling of statistic for TProfile,; fix small problem with underflow/overflow bins.; 7. Provide way to select display",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:71519,access,access,71519,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['access'],['access']
Security,"set and compression settings.; The order of the outer items must match the order of columns in the header and the extension header (small to large). The order of the inner items must match the order of pages or elements, resp.; Every inner item (that describes a page) has the following structure followed by a locator for the page. ```; 0 1 2 3; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | Number of Elements |C|; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; ```. Note that locators for byte ranges in a file may reference identical byte ranges,; but they must not reference arbitrarily overlapping byte ranges. _C(hecksum)_: If set, an XxHash-3 64bit checksum of the compressed page data is stored just after the page.; This bit should be interpreted as the sign bit of the number of elements,; i.e. negative values indicate pages with checksums.; Note that the page size stored in the locator does _not_ include the checksum. Note that we do not need to store the uncompressed size of the page; because the uncompressed size is given by the number of elements in the page and the element size.; We do need, however, the per-column and per-cluster element offset in order to read a certain entry range; without inspecting the meta-data of all the previous clusters. The hierarchical structure of the frames in the page list envelope is as follows:. # this is `List frame of cluster group record frames` mentioned above; - Top-most cluster list frame (one item for each cluster in this RNTuple); |; |---- Cluster 1 column list frame (outer list frame, one item for each column in this RNTuple); | |---- Column 1 page list frame (inner list frame, one item for each page in this column); | | |---- Page 1 description (inner item); | | |---- Page 2 description (inner item); | | | ...; | |---- Column 1 element offset (Int64), negative if the column is suppressed; | |---- Column 1 compres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:34902,checksum,checksum,34902,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['checksum'],['checksum']
Security,"set, by the scratch; instructions, or by flat instructions. If each lane of a wavefront accesses the; same private address, the interleaving results in adjacent dwords being accessed; and hence requires fewer cache lines to be fetched. Multi-dword access is not; supported except by flat and scratch instructions in GFX9-GFX11. The generic address space uses the hardware flat address support available in; GFX7-GFX11. This uses two fixed ranges of virtual addresses (the private and; local apertures), that are outside the range of addressible global memory, to; map from a flat address to a private or local address. FLAT instructions can take a flat address and access global, private (scratch); and group (LDS) memory depending on if the address is within one of the; aperture ranges. Flat access to scratch requires hardware aperture setup and; setup in the kernel prologue (see; :ref:`amdgpu-amdhsa-kernel-prolog-flat-scratch`). Flat access to LDS requires; hardware aperture setup and M0 (GFX7-GFX8) register setup (see; :ref:`amdgpu-amdhsa-kernel-prolog-m0`). To convert between a segment address and a flat address the base address of the; apertures address can be used. For GFX7-GFX8 these are available in the; :ref:`amdgpu-amdhsa-hsa-aql-queue` the address of which can be obtained with; Queue Ptr SGPR (see :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). For; GFX9-GFX11 the aperture base addresses are directly available as inline constant; registers ``SRC_SHARED_BASE/LIMIT`` and ``SRC_PRIVATE_BASE/LIMIT``. In 64 bit; address mode the aperture sizes are 2^32 bytes and the base is aligned to 2^32; which makes it easier to convert from flat to segment or segment to flat. Image and Samplers; ~~~~~~~~~~~~~~~~~~. Image and sample handles created by an HSA compatible runtime (see; :ref:`amdgpu-os`) are 64-bit addresses of a hardware 32-byte V# and 48 byte S#; object respectively. In order to support the HSA ``query_sampler`` operations; two extra dwords are used to store the H",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:155967,access,access,155967,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"setPreservesCFG`` method can be used by transformations that change; instructions in the program but do not modify the CFG or terminator; instructions. ``addPreserved`` is particularly useful for transformations like; ``BreakCriticalEdges``. This pass knows how to update a small set of loop and; dominator related analyses if they exist, so it can preserve them, despite the; fact that it hacks on the CFG. Example implementations of ``getAnalysisUsage``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. // This example modifies the program, but does not modify the CFG; void LICM::getAnalysisUsage(AnalysisUsage &AU) const {; AU.setPreservesCFG();; AU.addRequired<LoopInfoWrapperPass>();; }. .. _writing-an-llvm-pass-getAnalysis:. The ``getAnalysis<>`` and ``getAnalysisIfAvailable<>`` methods; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``Pass::getAnalysis<>`` method is automatically inherited by your class,; providing you with access to the passes that you declared that you required; with the :ref:`getAnalysisUsage <writing-an-llvm-pass-getAnalysisUsage>`; method. It takes a single template argument that specifies which pass class; you want, and returns a reference to that pass. For example:. .. code-block:: c++. bool LICM::runOnFunction(Function &F) {; LoopInfo &LI = getAnalysis<LoopInfoWrapperPass>().getLoopInfo();; //...; }. This method call returns a reference to the pass desired. You may get a; runtime assertion failure if you attempt to get an analysis that you did not; declare as required in your :ref:`getAnalysisUsage; <writing-an-llvm-pass-getAnalysisUsage>` implementation. This method can be; called by your ``run*`` method implementation, or by any other local method; invoked by your ``run*`` method. A module level pass can use function level analysis info using this interface.; For example:. .. code-block:: c++. bool ModuleLevelPass::runOnModule(Module &M) {; //...; DominatorTree &DT = getAnalysis<DominatorTree>(Func)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:32997,access,access,32997,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['access'],['access']
Security,"should be >= 0. Semantics:; """""""""""""""""""". This intrinsic represents the point where a call to a runtime routine; should be inserted for value profiling of target expressions. ``-instrprof``; pass will generate the appropriate data structures and replace the; ``llvm.instrprof.value.profile`` intrinsic with the call to the profile; runtime library with proper arguments. '``llvm.instrprof.mcdc.parameters``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.parameters(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.parameters``' intrinsic is used to initiate MC/DC; code coverage instrumentation for a function. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vectors executed for each boolean expression. Semantics:; """""""""""""""""""". This intrinsic represents basic MC/DC parameters initiating one or more MC/DC; instrumentation sequences in a function. It will cause the ``-instrprof`` pass; to generate the appropriate data structures and the code to instrument MC/DC; test vectors in a format that can be written out by a compiler runtime and; consumed via the ``llvm-profdata`` tool. '``llvm.instrprof.mcdc.condbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.condbitmap.update(ptr <name>, i64 <hash>,; i32 <condition-id>,; ptr <mcdc-temp-addr>,; i1 <bool-value>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic is used to track; MC/DC condition evaluation for eac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:532666,hash,hash,532666,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['hash'],['hash']
Security,"sible by an optimizer with only incomplete information about a; program. Essentially, dependence is carried to ""obvious"" uses of a; pointer. Merely passing a pointer argument to a function does not; itself cause dependence, but since generally the optimizer will not; be able to prove that the function doesn't depend on that parameter,; it will be forced to conservatively assume it does. Dependency propagates to values loaded from a pointer because those; values might be invalidated by deallocating the object. For; example, given the code ``__strong id x = p->ivar;``, ARC must not; move the release of ``p`` to between the load of ``p->ivar`` and the; retain of that value for storing into ``x``. Dependency does not propagate through stores of dependent pointer; values because doing so would allow dependency to outlive the; full-expression which produced the original value. For example, the; address of an instance variable could be written to some global; location and then freely accessed during the lifetime of the local,; or a function could return an inner pointer of an object and store; it to a local. These cases would be potentially impossible to; reason about and so would basically prevent any optimizations based; on imprecise lifetime. There are also uncommon enough to make it; reasonable to require the precise-lifetime annotation if someone; really wants to rely on them. Dependency does propagate through return values of pointer type.; The compelling source of need for this rule is a property accessor; which returns an un-autoreleased result; the calling function must; have the chance to operate on the value, e.g. to retain it, before; ARC releases the original pointer. Note again, however, that; dependence does not survive a store, so ARC does not guarantee the; continued validity of the return value past the end of the; full-expression. .. _arc.optimization.object_lifetime:. No object lifetime extension; ----------------------------. If, in the formal computati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:81506,access,accessed,81506,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['access'],['accessed']
Security,"simply a; string:. .. code-block:: llvm. define void @f() gc ""name"" { ... }. The supported values of *name* includes those :ref:`built in to LLVM; <builtin-gc-strategies>` and any provided by loaded plugins. Specifying a GC; strategy will cause the compiler to alter its output in order to support the; named garbage collection algorithm. Note that LLVM itself does not contain a; garbage collector, this functionality is restricted to generating machine code; which can interoperate with a collector provided externally. .. _prefixdata:. Prefix Data; -----------. Prefix data is data associated with a function which the code; generator will emit immediately before the function's entrypoint.; The purpose of this feature is to allow frontends to associate; language-specific runtime metadata with specific functions and make it; available through the function pointer while still allowing the; function pointer to be called. To access the data for a given function, a program may bitcast the; function pointer to a pointer to the constant's type and dereference; index -1. This implies that the IR symbol points just past the end of; the prefix data. For instance, take the example of a function annotated; with a single ``i32``,. .. code-block:: llvm. define void @f() prefix i32 123 { ... }. The prefix data can be referenced as,. .. code-block:: llvm. %a = getelementptr inbounds i32, ptr @f, i32 -1; %b = load i32, ptr %a. Prefix data is laid out as if it were an initializer for a global variable; of the prefix data's type. The function will be placed such that the; beginning of the prefix data is aligned. This means that if the size; of the prefix data is not a multiple of the alignment size, the; function's entrypoint will not be aligned. If alignment of the; function's entrypoint is desired, padding must be added to the prefix; data. A function may have prefix data but no body. This has similar semantics; to the ``available_externally`` linkage in that the data may be used by the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:72809,access,access,72809,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"sing fill area colors. - `""CONT4"":`Draw a contour plot using surface colors (SURF2 option; at theta = 0); see also options ""`AITOFF`"", ""`MERCATOR`"", etc.; below. - `""CONT5"":` Use Delaunay triangles to compute the contours. ![Different contour options](pictures/02000032.png). The default number of contour levels is 20 equidistant levels. It can; be changed with **`TH1`**`::SetContour`. When option ""`LIST`"" is; specified together with option ""`CONT`"", all points used for contour; drawing, are saved in the **`TGraph`** object and are accessible in; the following way:. ``` {.cpp}; TObjArray *contours =; gROOT->GetListOfSpecials()->FindObject(""contours"");; Int_t ncontours = contours->GetSize(); TList *list =; (TList*)contours->At(i);; ```. Where ""`i`"" is a contour number and list contains a list of; **`TGraph`** objects. For one given contour, more than one disjoint; poly-line may be generated. The **`TGraph`** numbers per contour are; given by `list->GetSize()`. Here we show how to access the first graph; in the list. ``` {.cpp}; TGraph *gr1 = (TGraph*)list->First();; ```. - ""`AITOFF`"": Draw a contour via an AITOFF projection. - ""`MERCATOR`"": Draw a contour via a Mercator projection. - ""`SINUSOIDAL`"": Draw a contour via a Sinusoidal projection. - ""`PARABOLIC`"": Draw a contour via a Parabolic projection. The tutorial macro `earth.C` uses these four options and produces the; following picture:. ![The `earth.C` macro output](pictures/03000033.png). #### The LEGO Options. In a lego plot, the cell contents are drawn as 3D boxes, with the; height of the box proportional to the cell content. ![""LEGO"" and ""SURF"" options](pictures/02000034.png). - ""`LEGO`"": Draw a lego plot with hidden line removal. - ""`LEGO1`"": Draw a lego plot with hidden surface removal. - ""`LEGO2`"": Draw a lego plot using colors to show the cell contents. A lego plot can be represented in several coordinate systems; the; default system is Cartesian coordinates. Other possible coordinate; systems are `CYL` , `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:26067,access,access,26067,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['access'],['access']
Security,"sion of PoD on CernVM-FS you can use; that one. Experiment-independent versions are available from the PH-SFT; cvmfs repository. Only if you have specific reasons while you want to use a customly built; PoD version, download the source code and compile it using the; installation instructions. Please note that [CMake](http://www.cmake.org/) and; [Boost](http://www.boost.org/) are required to build PoD. - After you have built PoD, install it with:. make install. - After installing PoD, run:. pod-server getbins. This has to be done only once and downloads the binary packages that; will be dynamically transferred to the worker nodes as binary; payload, and prevents us from installing PoD on each cluster node. It is important to do this step now, because in case PoD has been; installed in a directory where the user has no write privileges, as; in the case of system-wide installations, the user won't be able to; download those required packages in the PoD binary directory. > There is no need to ""configure"" PoD for your specific cluster: it is; > just enough to install it on your head node.; >; > PoD does not have any system-wide persistent daemon running or any; > system-wide configuration to be performed. Also, no part of PoD will; > be ever run as root.; >; > Do not worry about environment or software configuration at this time:; > there is no system configuration for that. All the environment for; > your software dependencies will be set via proper scripts from the PoD; > client.; >; > PoD client configuration and running is properly covered in the; > appropriate manual page. ### Firewall configuration. The head node only requires **TCP ports 22 (SSH) and 443 (HTTPS)** to accept; connections from the outside. Users will get an authentication ""token""; from port 443 and all PROOF traffic will be automatically tunneled in a; SSH connection on port 22 by PoD. In case you are not using the HTTPS+SSH token+authentication method, access to; the sole port 22 is all you need.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:6806,authenticat,authentication,6806,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,3,"['access', 'authenticat']","['access', 'authentication']"
Security,"sitive in mutation check when using pointer to member function.; (`#66204 <https://github.com/llvm/llvm-project/issues/66204>`_). - Fixed a crash in ``security.cert.env.InvalidPtr`` checker when accidentally; matched user-defined ``strerror`` and similar library functions.; (`#88181 <https://github.com/llvm/llvm-project/issues/88181>`_). Improvements; ^^^^^^^^^^^^. - Improved the ``unix.StdCLibraryFunctions`` checker by modeling more; functions like ``send``, ``recv``, ``readlink``, ``fflush``, ``mkdtemp``,; ``getcwd`` and ``errno`` behavior.; (`52ac71f92d38 <https://github.com/llvm/llvm-project/commit/52ac71f92d38f75df5cb88e9c090ac5fd5a71548>`_,; `#77040 <https://github.com/llvm/llvm-project/pull/77040>`_,; `#76671 <https://github.com/llvm/llvm-project/pull/76671>`_,; `#71373 <https://github.com/llvm/llvm-project/pull/71373>`_,; `#76557 <https://github.com/llvm/llvm-project/pull/76557>`_,; `#71392 <https://github.com/llvm/llvm-project/pull/71392>`_). - Fixed a false negative for when accessing a nonnull property (ObjC).; (`1dceba3a3684 <https://github.com/llvm/llvm-project/commit/1dceba3a3684d12394731e09a6cf3efcebf07a3a>`_). - ``security.insecureAPI.DeprecatedOrUnsafeBufferHandling`` now considers; ``fprintf`` calls unsafe.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-insecureapi-deprecatedorunsafebufferhandling-c>`__. - Improved the diagnostics of the ``optin.core.EnumCastOutOfRange`` checker.; It will display the name and the declaration of the enumeration along with; the concrete value being cast to the enum.; (`#74503 <https://github.com/llvm/llvm-project/pull/74503>`_). - Improved the ``alpha.security.ArrayBoundV2`` checker for detecting buffer; accesses prior the buffer; and also reworked the diagnostic messages.; (`3e014038b373 <https://github.com/llvm/llvm-project/commit/3e014038b373e5a4a96d89d46cea17e4d2456a04>`_,; `#70056 <https://github.com/llvm/llvm-project/pull/70056>`_,; `#72107 <https://github.com/llvm/llvm-project/pull",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:73202,access,accessing,73202,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['access'],['accessing']
Security,"sitory:. git clone https://github.com/llvm/llvm-project.git. At this point you have every sub-project (llvm, clang, lld, lldb, ...), which; :ref:`doesn't imply you have to build all of them <build_single_project>`. You; can still build only compiler-rt for instance. In this way it's not different; from someone who would check out all the projects with SVN today. If you want to avoid checking out all the sources, you can hide the other; directories using a Git sparse checkout::. git config core.sparseCheckout true; echo /compiler-rt > .git/info/sparse-checkout; git read-tree -mu HEAD. The data for all sub-projects is still in your `.git` directory, but in your; checkout, you only see `compiler-rt`.; Before you push, you'll need to fetch and rebase (`git pull --rebase`) as; usual. Note that when you fetch you'll likely pull in changes to sub-projects you don't; care about. If you are using sparse checkout, the files from other projects; won't appear on your disk. The only effect is that your commit hash changes. You can check whether the changes in the last fetch are relevant to your commit; by running::. git log origin/main@{1}..origin/main -- libcxx. This command can be hidden in a script so that `git llvmpush` would perform all; these steps, fail only if such a dependent change exists, and show immediately; the change that prevented the push. An immediate repeat of the command would; (almost) certainly result in a successful push.; Note that today with SVN or git-svn, this step is not possible since the; ""rebase"" implicitly happens while committing (unless a conflict occurs). Checkout/Clone Multiple Projects, with Commit Access; ----------------------------------------------------. Let's look how to assemble llvm+clang+libcxx at a given revision. Currently; ^^^^^^^^^. ::. svn co https://llvm.org/svn/llvm-project/llvm/trunk llvm -r $REVISION; cd llvm/tools; svn co https://llvm.org/svn/llvm-project/clang/trunk clang -r $REVISION; cd ../projects; svn co https://llvm.o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:14602,hash,hash,14602,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['hash'],['hash']
Security,"size S is defined as the address bit size of the target; architecture specific address space that corresponds to AS. A is adjusted to S bits by zero extending if necessary, and then treating; the least significant S bits as an unsigned value A'. It pushes a location description L with one memory location description SL; on the stack. SL specifies the memory location storage LS that corresponds; to AS with a bit offset equal to A' scaled by 8 (the byte size). If AS is an address space that is specific to context elements, then LS; corresponds to the location storage associated with the current context. *For example, if AS is for per thread storage then LS is the location; storage for the current thread. For languages that are implemented using a; SIMT execution model, then if AS is for per lane storage then LS is the; location storage for the current lane of the current thread. Therefore, if L; is accessed by an operation, the location storage selected when the location; description was created is accessed, and not the location storage associated; with the current context of the access operation.*. The DWARF expression is ill-formed if AS is not one of the values defined by; the target architecture specific ``DW_ASPACE_LLVM_*`` values. See :ref:`amdgpu-dwarf-implicit-location-description-operations` for special; rules concerning implicit pointer values produced by dereferencing implicit; location descriptions created by the ``DW_OP_implicit_pointer`` and; ``DW_OP_LLVM_aspace_implicit_pointer`` operations. 4. ``DW_OP_form_tls_address``. ``DW_OP_form_tls_address`` pops one stack entry that must be an integral; type value and treats it as a thread-local storage address TA. It pushes a location description L with one memory location description SL; on the stack. SL is the target architecture specific memory location; description that corresponds to the thread-local storage address TA. The meaning of the thread-local storage address TA is defined by the; run-time environme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:111442,access,accessed,111442,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,3,['access'],"['access', 'accessed']"
Security,"size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this case, the ``basic-aa`` pass will disambiguate the stores to ``C[0]`` and; ``C[1]`` because they are accesses to two distinct locations one byte apart, and; the accesses are each one byte. In this case, the Loop Invariant Code Motion; (LICM) pass can use store motion to remove the stores from the loop. In; contrast, the following code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; ((short*)C)[0] = A[i]; /* Two byte store! */; C[1] = A[9-i]; /* One byte store */; }. In this case, the two stores to C do alias each other, because the access to the; ``&C[0]`` element is a two byte access. If size information wasn't available in; the query, even the first case would have to conservatively assume that the; accesses alias. .. _alias:. The ``alias`` method; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two pointers point to; non-overlapping memory ranges. Another is when the two pointers are only ever; used for reading memory. Anot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:4208,access,accesses,4208,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['access'],['accesses']
Security,"size limit. ``align`` must be; explicitly specified on atomic stores. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic stores. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single metadata; name ``<nontemp_node>`` corresponding to a metadata node with one ``i32`` entry; of value 1. The existence of the ``!nontemporal`` metadata on the instruction; tells the optimizer and code generator that this load is not expected to; be reused in the cache. The code generator may select special; instructions to save cache bandwidth, such as the ``MOVNT`` instruction on; x86. The optional ``!invariant.group`` metadata must reference a; single metadata name ``<empty_node>``. See ``invariant.group`` metadata. Semantics:; """""""""""""""""""". The contents of memory are updated to contain ``<value>`` at the; location specified by the ``<pointer>`` operand. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:421650,access,accessed,421650,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessed']
Security,"sly they were treated as chars, which meant they could; alias with all other types.; - Clang now supports the C-only attribute ``counted_by``. When applied to a; struct's flexible array member, it points to the struct field that holds the; number of elements in the flexible array member. This information can improve; the results of the array bound sanitizer and the; ``__builtin_dynamic_object_size`` builtin. C23 Feature Support; ^^^^^^^^^^^^^^^^^^^; - Clang now accepts ``-std=c23`` and ``-std=gnu23`` as language standard modes,; and the ``__STDC_VERSION__`` macro now expands to ``202311L`` instead of its; previous placeholder value. Clang continues to accept ``-std=c2x`` and; ``-std=gnu2x`` as aliases for C23 and GNU C23, respectively.; - Clang now supports `requires c23` for module maps.; - Clang now supports ``N3007 Type inference for object definitions``. - Clang now supports ``<stdckdint.h>`` which defines several macros for performing; checked integer arithmetic. It is also exposed in pre-C23 modes. - Completed the implementation of; `N2508 <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2508.pdf>`_. We; previously implemented allowing a label at the end of a compound statement,; and now we've implemented allowing a label to be followed by a declaration; instead of a statement.; - Implemented; `N2940 <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2940.pdf>`_ which; removes support for trigraphs in C23 and later. In earlier language modes,; trigraphs remain enabled by default in conforming modes (e.g. ``-std=c17``); and disabled by default in GNU and Microsoft modes (e.g., ``-std=gnu17`` or; ``-fms-compatibility``). If needed, you can enable trigraphs by passing; ``-ftrigraphs``. Non-comprehensive list of changes in this release; -------------------------------------------------. * Clang now has a ``__builtin_vectorelements()`` function that determines the number of elements in a vector.; For fixed-sized vectors, e.g., defined via ``__attribute__((vector_s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:13181,expose,exposed,13181,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['expose'],['exposed']
Security,"software systems which receive less detailed scrutiny but remain sensitive to; these attacks, this seems like an impractical security model. We need an; automatic and systematic mitigation strategy. ### Automatic `lfence` on Conditional Edges. A natural way to scale up the existing hand-coded mitigations is simply to; inject an `lfence` instruction into both the target and fallthrough; destinations of every conditional branch. This ensures that no predicate or; bounds check can be bypassed speculatively. However, the performance overhead; of this approach is, simply put, catastrophic. Yet it remains the only truly; ""secure by default"" approach known prior to this effort and serves as the; baseline for performance. One attempt to address the performance overhead of this and make it more; realistic to deploy is [MSVC's /Qspectre; switch](https://blogs.msdn.microsoft.com/vcblog/2018/01/15/spectre-mitigations-in-msvc/).; Their technique is to use static analysis within the compiler to only insert; `lfence` instructions into conditional edges at risk of attack. However,; [initial](https://arstechnica.com/gadgets/2018/02/microsofts-compiler-level-spectre-fix-shows-how-hard-this-problem-will-be-to-solve/); [analysis](https://www.paulkocher.com/doc/MicrosoftCompilerSpectreMitigation.html); has shown that this approach is incomplete and only catches a small and limited; subset of attackable patterns which happen to resemble very closely the initial; proofs of concept. As such, while its performance is acceptable, it does not; appear to be an adequate systematic mitigation. ## Performance Overhead. The performance overhead of this style of comprehensive mitigation is very; high. However, it compares very favorably with previously recommended; approaches such as the `lfence` instruction. Just as users can restrict the; scope of `lfence` to control its performance impact, this mitigation technique; could be restricted in scope as well. However, it is important to understand what",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:45926,attack,attack,45926,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attack']
Security,"source.html>`_. doxygen info: `User Class <https://llvm.org/doxygen/classllvm_1_1User.html>`_. Superclass: Value_. The ``User`` class is the common base class of all LLVM nodes that may refer to; ``Value``\ s. It exposes a list of ""Operands"" that are all of the ``Value``\ s; that the User is referring to. The ``User`` class itself is a subclass of; ``Value``. The operands of a ``User`` point directly to the LLVM ``Value`` that it refers; to. Because LLVM uses Static Single Assignment (SSA) form, there can only be; one definition referred to, allowing this direct connection. This connection; provides the use-def information in LLVM. .. _m_User:. Important Public Members of the ``User`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``User`` class exposes the operand list in two ways: through an index access; interface and through an iterator based interface. * | ``Value *getOperand(unsigned i)``; | ``unsigned getNumOperands()``. These two methods expose the operands of the ``User`` in a convenient form for; direct access. * | ``User::op_iterator`` - Typedef for iterator over the operand list; | ``op_iterator op_begin()`` - Get an iterator to the start of the operand; list.; | ``op_iterator op_end()`` - Get an iterator to the end of the operand list. Together, these methods make up the iterator based interface to the operands; of a ``User``. .. _Instruction:. The ``Instruction`` class; -------------------------. ``#include ""llvm/IR/Instruction.h""``. header source: `Instruction.h; <https://llvm.org/doxygen/Instruction_8h_source.html>`_. doxygen info: `Instruction Class; <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_. Superclasses: User_, Value_. The ``Instruction`` class is the common base class for all LLVM instructions.; It provides only a few methods, but is a very commonly used class. The primary; data tracked by the ``Instruction`` class itself is the opcode (instruction; type) and the parent BasicBlock_ the ``Instruction`` is embedded into.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:145769,expose,expose,145769,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,2,"['access', 'expose']","['access', 'expose']"
Security,"space (a *layout unit*). Many interesting low level; operations on ``LinkGraph`` instances involve inspecting or mutating block; content or edges. * ``Content`` is represented as an ``llvm::StringRef``, and accessible via; the ``getContent`` method. Content is only available for content blocks,; and not for zero-fill blocks (use ``isZeroFill`` to check, and prefer; ``getSize`` when only the block size is needed as it works for both; zero-fill and content blocks). * ``Section`` is represented as a ``Section&`` reference, and accessible via; the ``getSection`` method. The ``Section`` class is described in more detail; below. * ``Size`` is represented as a ``size_t``, and is accessible via the; ``getSize`` method for both content and zero-filled blocks. * ``Alignment`` is represented as a ``uint64_t``, and available via the; ``getAlignment`` method. It represents the minimum alignment requirement (in; bytes) of the start of the block. * ``AlignmentOffset`` is represented as a ``uint64_t``, and accessible via the; ``getAlignmentOffset`` method. It represents the offset from the alignment; required for the start of the block. This is required to support blocks; whose minimum alignment requirement comes from data at some non-zero offset; inside the block. E.g. if a block consists of a single byte (with byte; alignment) followed by a uint64_t (with 8-byte alignment), then the block; will have 8-byte alignment with an alignment offset of 7. * list of ``Edge`` instances. An iterator range for this list is returned by; the ``edges`` method. The ``Edge`` class is described in more detail below. * ``Symbol`` -- An offset from an ``Addressable`` (often a ``Block``), with an; optional ``Name``, a ``Linkage``, a ``Scope``, a ``Callable`` flag, and a; ``Live`` flag. Symbols make it possible to name content (blocks and addressables are; anonymous), or target content with an ``Edge``. * ``Name`` is represented as an ``llvm::StringRef`` (equal to; ``llvm::StringRef()`` if the symbol ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:9197,access,accessible,9197,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['access'],['accessible']
Security,"specialization whose declaration is; instantiated in one module and whose definition is instantiated in another; module may end up with members associated with the wrong declaration of the; class, which can result in miscompiles in some cases.; - Fix crash on use of a variadic overloaded operator.; (`#42535 <https://github.com/llvm/llvm-project/issues/42535>`_); - Fix a hang on valid C code passing a function type as an argument to; ``typeof`` to form a function declaration.; (`#64713 <https://github.com/llvm/llvm-project/issues/64713>`_); - Clang now reports missing-field-initializers warning for missing designated; initializers in C++.; (`#56628 <https://github.com/llvm/llvm-project/issues/56628>`_); - Clang now respects ``-fwrapv`` and ``-ftrapv`` for ``__builtin_abs`` and; ``abs`` builtins.; (`#45129 <https://github.com/llvm/llvm-project/issues/45129>`_,; `#45794 <https://github.com/llvm/llvm-project/issues/45794>`_); - Fixed an issue where accesses to the local variables of a coroutine during; ``await_suspend`` could be misoptimized, including accesses to the awaiter; object itself.; (`#56301 <https://github.com/llvm/llvm-project/issues/56301>`_); The current solution may bring performance regressions if the awaiters have; non-static data members. See; `#64945 <https://github.com/llvm/llvm-project/issues/64945>`_ for details.; - Clang now prints unnamed members in diagnostic messages instead of giving an; empty ''. Fixes; (`#63759 <https://github.com/llvm/llvm-project/issues/63759>`_); - Fix crash in __builtin_strncmp and related builtins when the size value; exceeded the maximum value representable by int64_t. Fixes; (`#64876 <https://github.com/llvm/llvm-project/issues/64876>`_); - Fixed an assertion if a function has cleanups and fatal erors.; (`#48974 <https://github.com/llvm/llvm-project/issues/48974>`_); - Clang now emits an error if it is not possible to deduce array size for a; variable with incomplete array type.; (`#37257 <https://github.com/llvm/llvm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:33996,access,accesses,33996,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,2,['access'],['accesses']
Security,"spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU over XGMI or PCIe the kernarg backing memory is allocated in host; memory accessed as MTYPE UC (uncached) to avoid needing to invalidate the L2; cache. This also causes it to be treated as non-volatile and so is not; invalidated by ``*_vol``.; * On APU the kernarg backing memory is accessed as MTYPE CC (cache coherent) and; so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX90A are defined; in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx90a-table`. .. table:: AMDHSA Memory Model Code Sequences GFX90A; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx90a-table. ============ ============ ============== ========== ================================; LLVM Instr LLVM Memory LLVM Memory AMDGPU AMDGPU Machine Code; Ordering Sync Scope Address GFX90A; Space; ============ ============ ============== ========== ==================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:241355,access,accessed,241355,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU over XGMI or PCIe the kernarg backing memory is allocated in host; memory accessed as MTYPE UC (uncached) to avoid needing to invalidate the L2; cache. This also causes it to be treated as non-volatile and so is not; invalidated by ``*_vol``.; * On APU the kernarg backing memory is accessed as MTYPE CC (cache coherent) and; so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX940, GFX941, GFX942; are defined in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx940-gfx941-gfx942-table`. .. table:: AMDHSA Memory Model Code Sequences GFX940, GFX941, GFX942; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx940-gfx941-gfx942-table. ============ ============ ============== ========== ================================; LLVM Instr LLVM Memory LLVM Memory AMDGPU AMDGPU Machine Code; Ordering Sync Scope Address GFX940, GFX941, GFX942; S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:291373,access,accessed,291373,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"ss manager is to use a ``PassBuilder`` and call something like; ``PassBuilder::buildPerModuleDefaultPipeline()`` which creates a typical; pipeline for a given optimization level. Sometimes either frontends or backends will want to inject passes into the; pipeline. For example, frontends may want to add instrumentation, and target; backends may want to add passes that lower custom intrinsics. For these; cases, ``PassBuilder`` exposes callbacks that allow injecting passes into; certain parts of the pipeline. For example,. .. code-block:: c++. PassBuilder PB;; PB.registerPipelineStartEPCallback([&](ModulePassManager &MPM,; PassBuilder::OptimizationLevel Level) {; MPM.addPass(FooPass());; };. will add ``FooPass`` near the very beginning of the pipeline for pass; managers created by that ``PassBuilder``. See the documentation for; ``PassBuilder`` for the various places that passes can be added. If a ``PassBuilder`` has a corresponding ``TargetMachine`` for a backend, it; will call ``TargetMachine::registerPassBuilderCallbacks()`` to allow the; backend to inject passes into the pipeline. Clang's ``BackendUtil.cpp`` shows examples of a frontend adding (mostly; sanitizer) passes to various parts of the pipeline.; ``AMDGPUTargetMachine::registerPassBuilderCallbacks()`` is an example of a; backend adding passes to various parts of the pipeline. Pass plugins can also add passes into default pipelines. Different tools have; different ways of loading dynamic pass plugins. For example, ``opt; -load-pass-plugin=path/to/plugin.so`` loads a pass plugin into ``opt``. For; information on writing a pass plugin, see :doc:`WritingAnLLVMNewPMPass`. Using Analyses; ==============. LLVM provides many analyses that passes can use, such as a dominator tree.; Calculating these can be expensive, so the new pass manager has; infrastructure to cache analyses and reuse them when possible. When a pass runs on some IR, it also receives an analysis manager which it can; query for analyses. Querying f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:6179,inject,inject,6179,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['inject'],['inject']
Security,"ss matures, members of the LLVM community can propose that; a part of the codebase be designated as security-sensitive (or no longer; security-sensitive). This requires a rationale, and buy-in from the LLVM; community as for any RFC. In some cases, parts of the codebase could be handled; as security-sensitive but need significant work to get to the stage where that's; manageable. The LLVM community will need to decide whether it wants to invest in; making these parts of the code securable, and maintain these security; properties over time. In all cases the LLVM Security Group should be consulted,; since they'll be responding to security issues filed against these parts of the; codebase. If you're not sure whether an issue is in-scope for this security process or; not, err towards assuming that it is. The Security Group might agree or disagree; and will explain its rationale in the report, as well as update this document; through the above process. The security-sensitive parts of the LLVM Project currently are the following.; Note that this list can change over time. * None are currently defined. Please don't let this stop you from reporting; issues to the security group that you believe are security-sensitive. The parts of the LLVM Project which are currently treated as non-security; sensitive are the following. Note that this list can change over time. * Language front-ends, such as clang, for which a malicious input file can cause; undesirable behavior. For example, a maliciously crafted C or Rust source file; can cause arbitrary code to execute in LLVM. These parts of LLVM haven't been; hardened, and compiling untrusted code usually also includes running utilities; such as `make` which can more readily perform malicious things. .. _CVE process: https://cve.mitre.org; .. _open a new issue: https://bugs.chromium.org/p/llvm/issues/entry; .. _chromium issue tracker: https://crbug.com; .. _GitHub security: https://help.github.com/en/articles/about-maintainer-security-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:15466,secur,security-sensitive,15466,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security-sensitive']
Security,"ssLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify arbitrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). #### Matrix properties. A matrix has five properties, which are all set in the constructor:. - `precision` <br>; If the `precision` is float (i.e. single precision), use the `TMatrixF` class family. If the precision is double, use the `TMatrixD` class family. - `type`<br>; Possible values are: `general` (`TMatrixD`), `symmetric` (`TMatrixDSym`) or `sparse` (`TMatrixDSparse`). - `size`<br>; Number of rows and columns. - `index`<br>; Range start of row and column index. By default these start at 0. - `sparse map`<br>; Only relevant for a sparse matrix. It indicates where elements are unequal 0. #### Accessing matrix properties. Use one of the following methods to access the information about the relevant matrix property:. - `Int_t GetRowLwb()`: Row lower-bound index. - `Int_t GetRowUpb()`: Row upper-bound index. - `Int_t GetNrows()`: Number of rows. - `Int_t GetColLwb()`: Column lower-bound index. - `Int_t GetColUpb()`: Column upper-bound index. - `Int_t GetNcols()`: Number of columns. - `Int_t GetNoElements()`: Number of elements, for a dense matrix this equals: `fNrows x fNcols`. - `Double_t GetTol()`: Tolerance number that is used in decomposition operations. - `Int_t *GetRowIndexArray()`: For sparse matrices, access to the row index of `fNrows+1` entries. - `Int_t *GetColIndexArray()`: For sparse matrices, access to the column index of `fNelems` entries. #### Setting matrix properties. Use one of the following methods to set a matrix property:. - `SetTol (Double_t tol)`<br>; Sets the tolerance number. - `ResizeTo (Int_t nrows,Int_t ncols, Int_t nr_nonzeros=-1)`<br>; Changes the matrix shape to `nrows x ncols`. Index will start at 0. - `ResizeTo(Int_t ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md:2532,access,access,2532,math/matrix/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md,1,['access'],['access']
Security,"sses; ===============. This section describes the LLVM Analysis Passes. ``aa-eval``: Exhaustive Alias Analysis Precision Evaluator; ----------------------------------------------------------. This is a simple N^2 alias analysis accuracy evaluator. Basically, for each; function in the program, it simply queries to see how the alias analysis; implementation answers alias queries between each pair of pointers in the; function. This is inspired and adapted from code by: Naveen Neelakantam, Francesco; Spadini, and Wojciech Stryjewski. ``basic-aa``: Basic Alias Analysis (stateless AA impl); ------------------------------------------------------. A basic alias analysis pass that implements identities (two different globals; cannot alias, etc), but does no stateful analysis. ``basiccg``: Basic CallGraph Construction; -----------------------------------------. Yet to be written. .. _passes-da:. ``da``: Dependence Analysis; ---------------------------. Dependence analysis framework, which is used to detect dependences in memory; accesses. ``domfrontier``: Dominance Frontier Construction; ------------------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominator frontiers. ``domtree``: Dominator Tree Construction; ----------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominators. ``dot-callgraph``: Print Call Graph to ""dot"" file; -------------------------------------------------. This pass, only available in ``opt``, prints the call graph into a ``.dot``; graph. This graph can then be processed with the ""dot"" tool to convert it to; postscript or some other suitable format. ``dot-cfg``: Print CFG of function to ""dot"" file; ------------------------------------------------. This pass, only available in ``opt``, prints the control flow graph into a; ``.dot`` graph. This graph can then be processed with the :program:`dot` tool; to convert it to postscript or s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:2096,access,accesses,2096,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['access'],['accesses']
Security,"ssible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within the library. The preferred way of; providing this protection is to use mutex locks. The library also; locks an object before writing to it. The developer is not required; to explicitly lock or unlock a class object (static, global or; local) to perform a single operation on the object. Note that even; multithread safe level II hardly relieves the user of the library; from the burden of locking. A thread suffers from **`deadlock`** if it is blocked waiting for a; condition that will never occur. Typically, this occurs when one thread; needs to access a resource that is already locked by another thread, and; that other thread is trying to access a resource that has already been; locked by the first thread. In this situation, neither thread is able to; progress; they are deadlocked. A **`multiprocessor`** is a hardware system with multiple processors or; multiple, simultaneous execution units. - Examples can be found at; <http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html>; (the thread authors' web site - Jörn Adamczewski and Marc; Hemberger). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:24860,access,access,24860,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,2,['access'],['access']
Security,"ssing the data interval and the number of bins, you have to pass an; array (single or double precision) of bin edges. When the histogram; has `n` bins, then there are `n+1` distinct edges, so the array you; pass must be of size `n+1`. ``` {.cpp}; const Int_t NBINS = 5;; Double_t edges[NBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; // Bin 1 corresponds to range [0.0, 0.2]; // Bin 2 corresponds to range [0.2, 0.3] etc... TH1* h = new TH1D(; /* name */ ""h1"",; /* title */ ""Hist with variable bin width"",; /* number of bins */ NBINS,; /* edge array */ edges; );; ```. Each histogram object contains three **`TAxis`** objects: `fXaxis` ,; `fYaxis,` and `fZaxis`, but for one-dimensional histograms only the; X-axis is relevant, while for two-dimensional histograms the X-axis; and Y-axis are relevant. See the class **` TAxis`** for a description; of all the access methods. The bin edges are always stored internally; in double precision. You can examine the actual edges / limits of the histogram bins by; accessing the axis parameters, like in the example below:. ``` {.cpp}; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; ```. ## Bin Numbering. All histogram types support fixed or variable bin sizes. 2-D; histograms may have fixed size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw, or; access histograms are identical in both cases. ### Convention. For all histogram types: `nbins` , `xlow` , `xup`. Bin\# 0 contains the underflow.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:5458,access,accessing,5458,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['access'],['accessing']
Security,st common; alignment of ``&`` and ``*``.; Pointer and reference alignment styles are going to be updated according; to the preferences found in the file.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **DisableFormat** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DisableFormat>`; Disables formatting completely. .. _EmptyLineAfterAccessModifier:. **EmptyLineAfterAccessModifier** (``EmptyLineAfterAccessModifierStyle``) :versionbadge:`clang-format 13` :ref:`¶ <EmptyLineAfterAccessModifier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBl,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:61237,access,access,61237,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['access'],['access']
Security,"st. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0, ptr %arrayidx1, !llvm.access.group !1; ...; br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; !1 = distinct !{}. It is also possible to have nested parallel loops:. .. code-block:: llvm. outer.for.body:; ...; %val1 = load i32, ptr %arrayidx3, !llvm.access.group !4; ...; br label %inner.for.body. inner.for.body:; ...; %val0 = load i32, ptr %arrayidx1, !llvm.access.group !3; ...; store i32 %val0, ptr %arrayidx2, !llvm.access.group !3; ...; br i1 %exitcond, label %inner.for.end, label %inner.for.body, !llvm.loop !1. inner.for.end:; ...; store i32 %val1, ptr %arrayidx4, !llvm.access.group !4; ...; br i1 %exitcond, label %outer.for.end, label %outer.for.body, !llvm.loop !2. outer.for.end: ; preds = %for.body; ...; !1 = distinct !{!1, !{!""llvm.loop.parallel_accesses"", !3}} ; metadata for the inner loop; !2 = distinct !{!2, !{!""llvm.loop.parallel_accesses"", !3, !4}} ; m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:313225,access,access,313225,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,stant expressions; Unknown. 1827; drafting; Reference binding with ambiguous conversions; Not resolved. 1828; CD6; nested-name-specifier ambiguity; Unknown. 1829; CD6; Dependent unnamed types; Unknown. 1830; CD4; Repeated specifiers; Unknown. 1831; NAD; Explicitly vs implicitly deleted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declared member functions; Unknown. 1834; CD4; Constant initialization binding a reference to an xvalue; Unknown. 1835; CD6; Dependent member lookup before <; Unknown. 1836; CD5; Use of class type being defined in trailing-return-type; Unknown. 1837; CD6; Use of this in friend and local class declarations; Clang 3.3. 1838; CD4; Definition via unqualified-id and using-declaration; Unknown. 1839; CD6; Lookup of block-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849; CD6; Variable templates and the ODR; Unknown. 1850; CD4; Differences between definition context and point of instantiation; Unknown. 1851; CD4; decltype(auto) in new-expressions; Unknown. 1852; CD4; Wording issues regarding decltype(auto); Unknown. 1853; dup; Defining “allocated storage”; Unknown. 1854; drafting; Disallowing use of implicitly-deleted functions; Not resolved. 1855; dup; Out-of-lifetime access to nonstatic data members; U,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:125034,inject,injected-class-name,125034,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['inject'],['injected-class-name']
Security,"state and one can have multiple instances of MnMigrad objects. ### M fails to find a minimum ###. If M fails to find a minimum, the user is notified by a warning message; issued by M when running into troubles. Problems can be:. - a bug in M. - an error in the $\mbox{FCN}$. - a highly difficult problem (usually strong correlations among; parameters). - floating–point precision. ## The output from minimization ##. ### The FunctionMinimum ###. The output of the minimizers is the FunctionMinimum. The FunctionMinimum; contains the result of the minimization in both internal parameter; representation and external parameter representation. ### User representable format: MnUserParameterState ###. On request, the result of the minimization is transformed into a user; representable format for parameters and errors, the; MnUserParameterState. ### Access values, errors, covariance ###. The result can be accessed via methods like; MnUserParameterState::value(unsigned int n) and; MnUserParameterState::error(unsigned int n), where $n$ is the index of; the parameter in the list of parameters defined by the user. ### Printout of the result ###. The FunctionMinimum can be printed on the output simply via std::cout.; It will print both the internal and external state, that is parameters,; errors and the covariance matrix (if available). It also tells the user; if M did converge or not by issuing an appropriate message. If a; covariance matrix is available, the global correlation coefficients are; printed as well. ### Global correlation coefficients ###. The global correlation coefficient for parameter $n$ is a number between; zero and one which gives the correlation between parameter $n$ and that; linear combination of all other parameters which is most strongly; correlated with $n$. # M application programming interface (API) #. [api:api]. ## FunctionMinimum ##. [api:fm] The FunctionMinimum is the output of the minimizers and; contains the minimization result. The state at the minimu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:36116,access,accessed,36116,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['access'],['accessed']
Security,"state between; functions. This avoids direct ABI implications by using a side channel between; callers and callees to communicate the predicate state. It also allows implicit; zero-initialization of the state, which allows non-checked code to be the first; code executed. However, this requires a load from TLS in the entry block, a store to TLS; before every call and every ret, and a load from TLS after every call. As a; consequence it is expected to be substantially more expensive even than using; `%rsp` and potentially `lfence` within the function entry block. ##### Define a new ABI and/or calling convention. We could define a new ABI and/or calling convention to explicitly pass the; predicate state in and out of functions. This may be interesting if none of the; alternatives have adequate performance, but it makes deployment and adoption; dramatically more complex, and potentially infeasible. ## High-Level Alternative Mitigation Strategies. There are completely different alternative approaches to mitigating variant 1; attacks. [Most](https://lwn.net/Articles/743265/); [discussion](https://lwn.net/Articles/744287/) so far focuses on mitigating; specific known attackable components in the Linux kernel (or other kernels) by; manually rewriting the code to contain an instruction sequence that is not; vulnerable. For x86 systems this is done by either injecting an `lfence`; instruction along the code path which would leak data if executed speculatively; or by rewriting memory accesses to have branch-less masking to a known safe; region. On Intel systems, `lfence` [will prevent the speculative load of secret; data](https://newsroom.intel.com/wp-content/uploads/sites/11/2018/01/Intel-Analysis-of-Speculative-Execution-Side-Channels.pdf).; On AMD systems `lfence` is currently a no-op, but can be made; dispatch-serializing by setting an MSR, and thus preclude misspeculation of the; code path ([mitigation G-2 +; V1-1](https://developer.amd.com/wp-content/resources/Managing-S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:43553,attack,attacks,43553,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attacks']
Security,"std::set <dss_set>`. A sorted vector; (where you don't delete duplicate entries) or some other approach is almost; always better. .. _ds_map:. Map-Like Containers (std::map, DenseMap, etc); ---------------------------------------------. Map-like containers are useful when you want to associate data to a key. As; usual, there are a lot of different ways to do this. :). .. _dss_sortedvectormap:. A sorted 'vector'; ^^^^^^^^^^^^^^^^^. If your usage pattern follows a strict insert-then-query approach, you can; trivially use the same approach as :ref:`sorted vectors for set-like containers; <dss_sortedvectorset>`. The only difference is that your query function (which; uses std::lower_bound to get efficient log(n) lookup) should only compare the; key, not both the key and value. This yields the same advantages as sorted; vectors for sets. .. _dss_stringmap:. llvm/ADT/StringMap.h; ^^^^^^^^^^^^^^^^^^^^. Strings are commonly used as keys in maps, and they are difficult to support; efficiently: they are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" points to the key string; for a value. The StringMap is very fast for several reasons: quadratic probing is very cache; efficient for lookups, the hash value of strings in buckets is not recomputed; when looking up an element, StringMap rarely has to touch the memory for; unrelated objects when looking u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:88602,hash,hash,88602,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['hash'],['hash']
Security,"stems Inc) []; * Boovaragavan Dasarathan (Nvidia) [@mrragava]; * Dimitry Andric (individual; FreeBSD) [@DimitryAndric]; * Ed Maste (individual; FreeBSD) [@emaste]; * George Burgess IV (Google) [@gburgessiv]; * Josh Stone (Red Hat; Rust) [@cuviper]; * Kate McInnes (Apple) []; * Kristof Beyls (ARM) [@kbeyls]; * Matthew Riley (Google) [@mmdriley]; * Nikhil Gupta (Nvidia) []; * Oliver Hunt (Apple) [@ojhunt]; * Paul Robinson (Sony) [@pogo59]; * Peter Smith (ARM) [@smithp35]; * Pietro Albini (Ferrous Systems; Rust) [@pietroalbini]; * Serge Guelton (Mozilla) [@serge-sans-paille]; * Sergey Maslov (Intel) [@smaslov-intel]; * Shayne Hiet-Block (Microsoft) [@GreatKeeper]; * Tim Penge (Sony) []. Criteria; --------. * Nominees for LLVM Security Group membership should fall in one of these groups:. - Individual contributors:. + Specializes in fixing compiler-based security related issues or often participates in their exploration and resolution.; + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities.; + Has actively contributed non-trivial code to the LLVM project in the last year. - Researchers:. + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities. - Vendor contacts:. + Represents an organization or company which ships products that include their own copy of LLVM. Due to their position in the organization, the nominee has a reasonable need to know about security issues and disclosure embargoes. * Additionally, the following are necessary but not sufficient criteria for membership in the LLVM Security Group:. - If already in the LLVM Security Group, has actively participated in one (if any) security issue in the last ye",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:3420,secur,security,3420,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security']
Security,"ster overlaps with another). In addition to the per-register description, the ``TargetRegisterInfo`` class; exposes a set of processor specific register classes (instances of the; ``TargetRegisterClass`` class). Each register class contains sets of registers; that have the same properties (for example, they are all 32-bit integer; registers). Each SSA virtual register created by the instruction selector has; an associated register class. When the register allocator runs, it replaces; virtual registers with a physical register in the set. The target-specific implementations of these classes is auto-generated from a; :doc:`TableGen/index` description of the register file. .. _TargetInstrInfo:. The ``TargetInstrInfo`` class; -----------------------------. The ``TargetInstrInfo`` class is used to describe the machine instructions; supported by the target. Descriptions define things like the mnemonic for; the opcode, the number of operands, the list of implicit register uses and defs,; whether the instruction has certain target-independent properties (accesses; memory, is commutable, etc), and holds any target-specific flags. The ``TargetFrameLowering`` class; ---------------------------------. The ``TargetFrameLowering`` class is used to provide information about the stack; frame layout of the target. It holds the direction of stack growth, the known; stack alignment on entry to each function, and the offset to the local area.; The offset to the local area is the offset from the stack pointer on function; entry to the first location where function data (local variables, spill; locations) can be stored. The ``TargetSubtarget`` class; -----------------------------. The ``TargetSubtarget`` class is used to provide information about the specific; chip set being targeted. A sub-target informs code generation of which; instructions are supported, instruction latencies and instruction execution; itinerary; i.e., which processing units are used, in what order, and for how; long.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:13847,access,accesses,13847,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['access'],['accesses']
Security,"still; used as local cache of the experiment information or to store the work-in-progress status of the dataset manager daemon. This model addresses the scalability issues observed at ALICE AFs.; - Improvements in [TProofBench](https://root.cern.ch/doc/master/classTProofBench.html):; - Recording and display of the maximum rate during query, CPU efficiency calculation for PROOF-Lite runs, better measurement of wall time.; - Support for dynamic startup mode. - Test program xpdtest to test the status of xproofd (see also man page under $ROOTSYS/man/man1):. ``` {.sh}; $ xpdtest [options]; --help, -h; Gives a short list of options avaliable, and exit; -t <test>; type of test to be run:; 0 ping the daemon (includes process existence check if pid specified; see below); 1 ping the daemon and check connection for default user; 2 ping the daemon and check connection for the default user and all recent users; ...; ```; - Interface with **igprof** for fast statistic profiling. Like valgrind, it can be specified as option to TProof::Open and the output is available via the log viewer technology:. ``` {.cpp}; root[] p = TProof::Open(""master"", ""igprof-pp""); ```; - Miscellanea:; - Added functions [Getenv](http://root.cern.ch/root/htmldoc/TProof.html#TProof:Getenv) and [GetRC](http://root.cern.ch/root/htmldoc/TProof.html#TProof:GetRC); in TProof to retrieve environment information from the nodes, typically from the master.; - Add support unix secondary groups in group access control. This allows more flexibility in, for example, assigning group-shared credential files to the daemon.; - Several new tests and options in the test program _stressProof_. ### Bug fixes. Several consolidation fixes in several parts of the system (see the [5.34 patch release notes for details](https://root.cern/install/all_releases/root-version-v5-34-00-patch-release-notes/)). In particular, those for 'xproofd' were provided by B. Butler and M. Swiatlowski and greatly contributed to consolidate the daemon. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v600/index.md:2498,access,access,2498,proof/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v600/index.md,1,['access'],['access']
Security,"stinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructions that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instruct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:311550,access,access,311550,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"stop, then stop. Persisting in such; behavior after being asked to stop is considered harassment. .. _when we disagree, try to understand why:. * **When we disagree, try to understand why.** Disagreements, both social and; technical, happen all the time and LLVM is no exception. It is important that; we resolve disagreements and differing views constructively. Remember that; we're different. The strength of LLVM comes from its varied community, people; from a wide range of backgrounds. Different people have different; perspectives on issues. Being unable to understand why someone holds; a viewpoint doesn't mean that they're wrong. Don't forget that it is human to; err and blaming each other doesn't get us anywhere. Instead, focus on helping; to resolve issues and learning from mistakes. Reporting; =========. If you believe someone is violating the code of conduct you can always report; it to the LLVM Foundation Code of Conduct Committee by emailing; conduct@llvm.org. All reports will be kept confidential. This isn't a public; list and only members of the advisory committee will receive the report. For; details on what to include in the report, please see the :doc:`Reporting Guide; <ReportingGuide>`. If you believe anyone is in physical danger, please notify appropriate law; enforcement first. If you are unsure what law enforcement agency is; appropriate, please include this in your report and we will attempt to notify; them. If the violation occurs at an event such as a Developer Meeting and requires; immediate attention, you can also reach out to any of the event organizers or; staff. Event organizers and staff will be prepared to handle the incident and; able to help. If you cannot find one of the organizers, the venue staff can; locate one for you. We will also post detailed contact information for specific; events as part of each events' information. In person reports will still be; kept confidential exactly as above, but also feel free to (anonymously if; needed",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst:5635,confidential,confidential,5635,interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,1,['confidential'],['confidential']
Security,"sts whether the given pointer is associated; with the given type identifier. .. _type.checked.load:. '``llvm.type.checked.load``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare {ptr, i1} @llvm.type.checked.load(ptr %ptr, i32 %offset, metadata %type) nounwind memory(argmem: read). Arguments:; """""""""""""""""""". The first argument is a pointer from which to load a function pointer. The; second argument is the byte offset from which to load the function pointer. The; third argument is a metadata object representing a :doc:`type identifier; <TypeMetadata>`. Overview:; """""""""""""""""". The ``llvm.type.checked.load`` intrinsic safely loads a function pointer from a; virtual table pointer using type metadata. This intrinsic is used to implement; control flow integrity in conjunction with virtual call optimization. The; virtual call optimization pass will optimize away ``llvm.type.checked.load``; intrinsics associated with devirtualized calls, thereby removing the type; check in cases where it is not needed to enforce the control flow integrity; constraint. If the given pointer is associated with a type metadata identifier, this; function returns true as the second element of its return value. (Note that; the function may also return true if the given pointer is not associated; with a type metadata identifier.) If the function's return value's second; element is true, the following rules apply to the first element:. - If the given pointer is associated with the given type metadata identifier,; it is the function pointer loaded from the given byte offset from the given; pointer. - If the given pointer is not associated with the given type metadata; identifier, it is one of the following (the choice of which is unspecified):. 1. The function pointer that would have been loaded from an arbitrarily chosen; (through an unspecified mechanism) pointer associated with the type; metadata. 2. If the function has a non-void return type, a pointer to a function that",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:938649,integrity,integrity,938649,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['integrity'],['integrity']
Security,"sts.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might be able to improve in the future. Operational Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repository <https://github.com/google/llvm-premerge-checks>`_. For enhancement; ideas and most bugs, please file an issue on said repository. For immediate; operational problems, the point of contact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge_checks.pdf>`_. Committing a change; -------------------. Once a patch has been reviewed and approved on Phabricator it can then be; committed to trunk. If you do not have commit access, someone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:13322,access,access,13322,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['access'],['access']
Security,"style>. .. contents::; :local:. .. warning::; This is a work in progress. Introduction; ============. The LLVM target-independent code generator is a framework that provides a suite; of reusable components for translating the LLVM internal representation to the; machine code for a specified target---either in assembly form (suitable for a; static compiler) or in binary machine code format (usable for a JIT; compiler). The LLVM target-independent code generator consists of six main; components:. 1. `Abstract target description`_ interfaces which capture important properties; about various aspects of the machine, independently of how they will be used.; These interfaces are defined in ``include/llvm/Target/``. 2. Classes used to represent the `code being generated`_ for a target. These; classes are intended to be abstract enough to represent the machine code for; *any* target machine. These classes are defined in; ``include/llvm/CodeGen/``. At this level, concepts like ""constant pool; entries"" and ""jump tables"" are explicitly exposed. 3. Classes and algorithms used to represent code at the object file level, the; `MC Layer`_. These classes represent assembly level constructs like labels,; sections, and instructions. At this level, concepts like ""constant pool; entries"" and ""jump tables"" don't exist. 4. `Target-independent algorithms`_ used to implement various phases of native; code generation (register allocation, scheduling, stack frame representation,; etc). This code lives in ``lib/CodeGen/``. 5. `Implementations of the abstract target description interfaces`_ for; particular targets. These machine descriptions make use of the components; provided by LLVM, and can optionally provide custom target-specific passes,; to build complete code generators for a specific target. Target descriptions; live in ``lib/Target/``. 6. The target-independent JIT components. The LLVM JIT is completely target; independent (it uses the ``TargetJITInfo`` structure to interface for; tar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:1568,expose,exposed,1568,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['expose'],['exposed']
Security,"such as hash buckets and hash; values. .. option:: -publics. dump public symbol records. .. option:: -public-extras. dump additional information about the publics, such as hash buckets and hash; values. .. option:: -symbols. dump symbols (functions, variables, etc) for each module dumped. .. option:: -sym-data. For each symbol record dumped as a result of the :option:`-symbols` option,; display the full bytes of the record in binary as well. Type Record Options; +++++++++++++++++++. .. option:: -types. Dump CodeView type records from TPI stream. .. option:: -type-extras. Dump additional information from the TPI stream, such as hashes and the type; index offsets array. .. option:: -type-data. For each type record dumped, display the full bytes of the record in binary as; well. .. option:: -type-index=<uint>. Only dump types with the specified type index. .. option:: -ids. Dump CodeView type records from IPI stream. .. option:: -id-extras. Dump additional information from the IPI stream, such as hashes and the type; index offsets array. .. option:: -id-data. For each ID record dumped, display the full bytes of the record in binary as; well. .. option:: -id-index=<uint>. only dump ID records with the specified hexadecimal type index. .. option:: -dependents. When used in conjunction with :option:`-type-index` or :option:`-id-index`,; dumps the entire dependency graph for the specified index instead of just the; single record with the specified index. For example, if type index 0x4000 is; a function whose return type has index 0x3000, and you specify; `-dependents=0x4000`, then this would dump both records (as well as any other; dependents in the tree). Miscellaneous Options; +++++++++++++++++++++. .. option:: -all. Implies most other options. .. option:: -section-contribs. Dump section contributions. .. option:: -section-headers. Dump image section headers. .. option:: -section-map. Dump section map. .. option:: -string-table. Dump PDB string table. .. _bytes_subcommand",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst:9717,hash,hashes,9717,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,1,['hash'],['hashes']
Security,"suosl/master/config/workers.py``; * builders are added to ``buildbot/osuosl/master/config/builders.py``. Please make sure your builder name and its builddir are unique through the; file. All new builders should default to using the ""'collapseRequests': False""; configuration. This causes the builder to build each commit individually; and not merge build requests. To maximize quality of feedback to developers,; we *strongly prefer* builders to be configured not to collapse requests.; This flag should be removed only after all reasonable efforts have been; exhausted to improve build times such that the builder can keep up with; commit flow. It is possible to allow email addresses to unconditionally receive; notifications on build failure; for this you'll need to add an; ``InformativeMailNotifier`` to ``buildbot/osuosl/master/config/status.py``.; This is particularly useful for the staging buildmaster which is silent; otherwise. #. Send the buildbot-worker access name and the access password directly to; `Galina Kistanova <mailto:gkistanova@gmail.com>`_, and wait until she; lets you know that your changes are applied and buildmaster is; reconfigured. #. Make sure you can start the buildbot-worker and successfully connect; to the silent buildmaster. Then set up your buildbot-worker to start; automatically at the start up time. See the buildbot documentation; for help. You may want to restart your computer to see if it works. #. Check the status of your buildbot-worker on the `Waterfall Display (Staging); <http://lab.llvm.org/staging/#/waterfall>`_ to make sure it is; connected, and the `Workers Display (Staging); <http://lab.llvm.org/staging/#/workers>`_ to see if administrator; contact and worker information are correct. #. At this point, you have a working builder connected to the staging; buildmaster. You can now make sure it is reliably green and keeps; up with the build queue. No notifications will be sent, so you can; keep an unstable builder connected to staging i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:6288,access,access,6288,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,3,"['access', 'password']","['access', 'password']"
Security,"support for linker relaxation.; * Assorted codegen improvements. Changes to the MIPS Backend; ---------------------------. Changes to the PowerPC Backend; ------------------------------. * LLJIT's JIT linker now defaults to JITLink on 64-bit ELFv2 targets.; * Initial-exec TLS model is supported on AIX.; * Implemented new resource based scheduling model of POWER7 and POWER8.; * ``frexp`` libcall now references correct symbol name for ``fp128``.; * Optimized materialization of 64-bit immediates, code generation of; ``vec_promote`` and atomics.; * Global constant strings are pooled in the TOC under one entry to reduce the; number of entries in the TOC.; * Added a number of missing Power10 extended mnemonics.; * Added the SCV instruction.; * Fixed register class for the paddi instruction.; * Optimize VPERM and fix code order for swapping vector operands on LE.; * Added various bug fixes and code gen improvements. AIX Support/improvements:. * Support for a non-TOC-based access sequence for the local-exec TLS model (called small local-exec).; * XCOFF toc-data peephole optimization and bug fixes.; * Move less often used __ehinfo TOC entries to the end of the TOC section.; * Fixed problems when the AIX libunwind unwinds starting from a signal handler; and the function that raised the signal happens to be a leaf function that; shares the stack frame with its caller or a leaf function that does not store; the stack frame backchain. Changes to the RISC-V Backend; -----------------------------. * The Zfa extension version was upgraded to 1.0 and is no longer experimental.; * Zihintntl extension version was upgraded to 1.0 and is no longer experimental.; * Intrinsics were added for Zk*, Zbb, and Zbc. See https://github.com/riscv-non-isa/riscv-c-api-doc/blob/master/riscv-c-api.md#scalar-bit-manipulation-extension-intrinsics; * Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f for RV64.; * The Zvbb, Zvbc, Zvkb, Zvkg, Zvkn, Zvknc, Zvkned, Zvkng, Zvknha, Z",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:6290,access,access,6290,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['access'],['access']
Security,"sure that e.g. `clang -v` reports a; user-friendly revision number (e.g. `main-12345` or `4.0-5321`), addressing; the objections raised above with respect to this aspect of Git. What About Branches and Merges?; -------------------------------. In contrast to SVN, Git makes branching easy. Git's commit history is; represented as a DAG, a departure from SVN's linear history. However, we propose; to mandate making merge commits illegal in our canonical Git repository. Unfortunately, GitHub does not support server side hooks to enforce such a; policy. We must rely on the community to avoid pushing merge commits. GitHub offers a feature called `Status Checks`: a branch protected by; `status checks` requires commits to be explicitly allowed before the push can happen.; We could supply a pre-push hook on the client side that would run and check the; history, before allowing the commit being pushed [statuschecks]_.; However this solution would be somewhat fragile (how do you update a script; installed on every developer machine?) and prevents SVN access to the; repository. What About Commit Emails?; -------------------------. We will need a new bot to send emails for each commit. This proposal leaves the; email format unchanged besides the commit URL. Straw Man Migration Plan; ========================. Step #1 : Before The Move; -------------------------. 1. Update docs to mention the move, so people are aware of what is going on.; 2. Set up a read-only version of the GitHub project, mirroring our current SVN; repository.; 3. Add the required bots to implement the commit emails, as well as the; umbrella repository update (if the multirepo is selected) or the read-only; Git views for the sub-projects (if the monorepo is selected). Step #2 : Git Move; ------------------. 4. Update the buildbots to pick up updates and commits from the GitHub; repository. Not all bots have to migrate at this point, but it'll help; provide infrastructure testing.; 5. Update Phabricator to pick up",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:6385,access,access,6385,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['access'],['access']
Security,"system of the higher level language; being compiled. **Scalar type descriptors** describe types that do not; contain other types. Each scalar type has a parent type, which must also; be a scalar type or the TBAA root. Via this parent relation, scalar types; within a TBAA root form a tree. **Struct type descriptors** denote types; that contain a sequence of other type descriptors, at known offsets. These; contained type descriptors can either be struct type descriptors themselves; or scalar type descriptors. **Access tags** are metadata nodes attached to load and store instructions.; Access tags use type descriptors to describe the *location* being accessed; in terms of the type system of the higher level language. Access tags are; tuples consisting of a base type, an access type and an offset. The base; type is a scalar type descriptor or a struct type descriptor, the access; type is a scalar type descriptor, and the offset is a constant integer. The access tag ``(BaseTy, AccessTy, Offset)`` can describe one of two; things:. * If ``BaseTy`` is a struct type, the tag describes a memory access (load; or store) of a value of type ``AccessTy`` contained in the struct type; ``BaseTy`` at offset ``Offset``. * If ``BaseTy`` is a scalar type, ``Offset`` must be 0 and ``BaseTy`` and; ``AccessTy`` must be the same; and the access tag describes a scalar; access with scalar type ``AccessTy``. We first define an ``ImmediateParent`` relation on ``(BaseTy, Offset)``; tuples this way:. * If ``BaseTy`` is a scalar type then ``ImmediateParent(BaseTy, 0)`` is; ``(ParentTy, 0)`` where ``ParentTy`` is the parent of the scalar type as; described in the TBAA metadata. ``ImmediateParent(BaseTy, Offset)`` is; undefined if ``Offset`` is non-zero. * If ``BaseTy`` is a struct type then ``ImmediateParent(BaseTy, Offset)``; is ``(NewTy, NewOffset)`` where ``NewTy`` is the type contained in; ``BaseTy`` at offset ``Offset`` and ``NewOffset`` is ``Offset`` adjusted; to be relative within that inner",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:274959,access,access,274959,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"t --trees Events --all-branches --threads 8; ```. ## Core Libraries. ### Interpreter. #### Support for profiling/debugging interpreted/JITted code. This version of ROOT adds an LLVM JIT event listener to create perf map files; during runtime. This allows profiling of interpreted/JITted code generated by; cling. Instead of function addresses, the perf data will contain full function; names. In addition, stack frame pointers are enabled in JITted code, so full; stack traces can be generated. Debugging is aided by switching off optimisations; and adding frame pointers for better stack traces. However, since both have a; runtime cost, they are disabled by default. Similar to `LD_DEBUG` and `LD_PROFILE`; for `ld.so`, the environment variables `CLING_DEBUG=1` and/or `CLING_PROFILE=1`; can be set to enable debugging and/or profiling. ### Other changes. - Shadowing of declarations in the `std` namespace is now diagnosed. Specifically, given that ROOT injects `using namespace std` directive, _all_ the names in the `std` namespace become available in the global scope. However, in some circumstances users inadvertently introduce a declaration that conflicts with a name in `std` making references to the former declaration result in ambiguous lookup.; A fairly common case is trying to declare a global variable named `data` which conflict with [`std::data`](https://en.cppreference.com/w/cpp/iterator/data) [C++17]. See [ROOT-5971](https://sft.its.cern.ch/jira/browse/ROOT-5971) for a discussion.; As of v6.28, such declarations result in; ```; root [] int data;; ROOT_prompt_0:1:1: warning: 'data' shadows a declaration with the same name in the 'std' namespace; use '::data' to reference this declaration; int data;; ^; ```. - Line editing at the ROOT interactive prompt has been improved. This version introduces useful shortcuts for common actions, e.g. Xterm-like fast movement between words using Ctrl+Left and Ctrl+Right, Ctrl+Del to delete the word under the cursor, or clearing the s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:6414,inject,injects,6414,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['inject'],['injects']
Security,"t a given port of a given host.; Improvements. In PROOF-Bench, file generation, add the possibility to change; only the generating function, passed as TMacro. Add also check on the; free space on the device and skip file generation if less than 10% or; less than 1 GB.; Record in TStatus also the max memory usage on the master and printed; via TStatus::Print; this allow a quick visualisation of the overall; memory usage at the end of the query.; Import version 0.9.6 of afdsmgrd; Make sure that the name(s) of the processed dataset(s) are registered; in the TFileInfo objects being processed, so that it can be used for; monitoring.; In XrdProofd, add possibility to skip the checks for the data; directories during session startup, as they may significantly slowdown; the startup process is the medium is busy. In such a case, admins; are responsible to create the directories in advance; the session; releated part fo the path is created by the session once up.; In XrdProofd, move the check for the username after authentication.; This is because authentication may run some credentials-to-user mapping; which can modify the requested username. This way we really check the; final username and not the one requested by the client, which may even; not exist on the machines. Side modification: when the mapping function; returns more usernames, the username specified by the client is used to; help choosing the effective username among the available choices; if not; match is found the handshake does any longer fail, the first mapped; username is chosen instead.; In XrdProofd, allow 'xpd.allowedgroups' to control also PROOF; groups, not only UNIX ones.In XrdProofd, simplify error; messages in case of login failure because of non-authorization.; Remove hardcoded additions of dirname(COMPILER) and of; '/bin:/usr/bin:/usr/local/bin' in front of PATH. These uncontrolled; additions could hide specific settings in PATH and be the source of; weird problems appearing in PROOF only.; Add more f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html:2268,authenticat,authentication,2268,proof/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html,1,['authenticat'],['authentication']
Security,"t a; specific AMDGPU processor as a single architecture regardless of how it is; configured at run time. The compiler explicitly specifies the DWARF registers; that match the mode in which the code it is generating will be executed. DWARF registers are encoded as numbers, which are mapped to architecture; registers. The mapping for AMDGPU is defined in; :ref:`amdgpu-dwarf-register-mapping-table`. All AMDGPU targets use the same; mapping. .. table:: AMDGPU DWARF Register Mapping; :name: amdgpu-dwarf-register-mapping-table. ============== ================= ======== ==================================; DWARF Register AMDGPU Register Bit Size Description; ============== ================= ======== ==================================; 0 PC_32 32 Program Counter (PC) when; executing in a 32-bit process; address space. Used in the CFI to; describe the PC of the calling; frame.; 1 EXEC_MASK_32 32 Execution Mask Register when; executing in wavefront 32 mode.; 2-15 *Reserved* *Reserved for highly accessed; registers using DWARF shortcut.*; 16 PC_64 64 Program Counter (PC) when; executing in a 64-bit process; address space. Used in the CFI to; describe the PC of the calling; frame.; 17 EXEC_MASK_64 64 Execution Mask Register when; executing in wavefront 64 mode.; 18-31 *Reserved* *Reserved for highly accessed; registers using DWARF shortcut.*; 32-95 SGPR0-SGPR63 32 Scalar General Purpose; Registers.; 96-127 *Reserved* *Reserved for frequently accessed; registers using DWARF 1-byte ULEB.*; 128 STATUS 32 Status Register.; 129-511 *Reserved* *Reserved for future Scalar; Architectural Registers.*; 512 VCC_32 32 Vector Condition Code Register; when executing in wavefront 32; mode.; 513-767 *Reserved* *Reserved for future Vector; Architectural Registers when; executing in wavefront 32 mode.*; 768 VCC_64 64 Vector Condition Code Register; when executing in wavefront 64; mode.; 769-1023 *Reserved* *Reserved for future Vector; Architectural Registers when; executing in wavefront 64 mode.*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:87434,access,accessed,87434,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"t and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76663,sanitiz,sanitize-recover,76663,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['sanitiz'],['sanitize-recover']
Security,"t and usage are defined by the shader compiler. Each shader's table in the ``.data`` section is referenced by the symbol; ``_amdgpu_``\ *xs*\ ``_shdr_intrl_data`` where *xs* corresponds with the; hardware shader stage the data is for. E.g.,; ``_amdgpu_cs_shdr_intrl_data`` for the compute shader hardware stage. .. _amdgpu-amdpal-code-object-metadata-user-data-spill-table-section:. Spill Table; ###########. It is possible for a hardware shader to need access to more *user data; entries* than there are slots available in user data registers for one; or more hardware shader stages. In that case, the PAL runtime expects; the necessary *user data entries* to be spilled to GPU memory and use; one user data register to point to the spilled user data memory. The; value of the *user data entry* must then represent the location where; a shader expects to read the low 32-bits of the table's GPU virtual; address. The *spill table* itself represents a set of 32-bit values; managed by the PAL runtime in GPU-accessible memory that can be made; indirectly accessible to a hardware shader. Unspecified OS; --------------. This section provides code conventions used when the target triple OS is; empty (see :ref:`amdgpu-target-triples`). Trap Handler ABI; ~~~~~~~~~~~~~~~~. For code objects generated by AMDGPU backend for non-amdhsa OS, the runtime does; not install a trap handler. The ``llvm.trap`` and ``llvm.debugtrap``; instructions are handled as follows:. .. table:: AMDGPU Trap Handler for Non-AMDHSA OS; :name: amdgpu-trap-handler-for-non-amdhsa-os-table. =============== =============== ===========================================; Usage Code Sequence Description; =============== =============== ===========================================; llvm.trap s_endpgm Causes wavefront to be terminated.; llvm.debugtrap *none* Compiler warning given that there is no; trap handler installed.; =============== =============== ===========================================. Source Languages; ===========",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:419967,access,accessible,419967,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,2,['access'],['accessible']
Security,"t by 1. Possible solutions; ^^^^^^^^^^^^^^^^^^; Let's briefly consider possible options about how and what we have to implement; in order to create full-featured functions merging, and also what it would; mean for us. Equal function detection obviously supposes that a ""detector"" method to be; implemented and latter should answer the question ""whether functions are equal"".; This ""detector"" method consists of tiny ""sub-detectors"", which each answers; exactly the same question, but for function parts. As the second step, we should merge equal functions. So it should be a ""merger""; method. ""Merger"" accepts two functions *F1* and *F2*, and produces *F1F2*; function, the result of merging. Having such routines in our hands, we can process a whole module, and merge all; equal functions. In this case, we have to compare every function with every another function. As; the reader may notice, this way seems to be quite expensive. Of course we could; introduce hashing and other helpers, but it is still just an optimization, and; thus the level of O(N*N) complexity. Can we reach another level? Could we introduce logarithmical search, or random; access lookup? The answer is: ""yes"". Random-access; """"""""""""""""""""""""""; How it could this be done? Just convert each function to a number, and gather; all of them in a special hash-table. Functions with equal hashes are equal.; Good hashing means, that every function part must be taken into account. That; means we have to convert every function part into some number, and then add it; into the hash. The lookup-up time would be small, but such an approach adds some; delay due to the hashing routine. Logarithmical search; """"""""""""""""""""""""""""""""""""""""; We could introduce total ordering among the functions set, once ordered we; could then implement a logarithmical search. Lookup time still depends on N,; but adds a little of delay (*log(N)*). Present state; """"""""""""""""""""""""""; Both of the approaches (random-access and logarithmical) have been implemented; and te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:5411,hash,hashing,5411,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['hash'],['hashing']
Security,"t can only do so from the entry block. The ``func`` argument to '``llvm.localrecover``' must be a constant; bitcasted pointer to a function defined in the current module. The code; generator cannot determine the frame allocation offset of functions defined in; other modules. The ``fp`` argument to '``llvm.localrecover``' must be a frame pointer of a; call frame that is currently live. The return value of '``llvm.localaddress``'; is one way to produce such a value, but various runtimes also expose a suitable; pointer in platform-specific ways. The ``idx`` argument to '``llvm.localrecover``' indicates which alloca passed to; '``llvm.localescape``' to recover. It is zero-indexed. Semantics:; """""""""""""""""""". These intrinsics allow a group of functions to share access to a set of local; stack allocations of a one parent function. The parent function may call the; '``llvm.localescape``' intrinsic once from the function entry block, and the; child functions can use '``llvm.localrecover``' to access the escaped allocas.; The '``llvm.localescape``' intrinsic blocks inlining, as inlining changes where; the escaped allocas are allocated, which would break attempts to use; '``llvm.localrecover``'. '``llvm.seh.try.begin``' and '``llvm.seh.try.end``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.seh.try.begin(); declare void @llvm.seh.try.end(). Overview:; """""""""""""""""". The '``llvm.seh.try.begin``' and '``llvm.seh.try.end``' intrinsics mark; the boundary of a _try region for Windows SEH Asynchrous Exception Handling. Semantics:; """""""""""""""""""". When a C-function is compiled with Windows SEH Asynchrous Exception option,; -feh_asynch (aka MSVC -EHa), these two intrinsics are injected to mark _try; boundary and to prevent potential exceptions from being moved across boundary.; Any set of operations can then be confined to the region by reading their leaf; inputs via volatile loads and writing their root outputs via volatile",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:514951,access,access,514951,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"t don't modify memory. An example of; a ``MemoryUse`` is a ``load``, or a ``readonly`` function call. Every function that exists has a special ``MemoryDef`` called ``liveOnEntry``.; It dominates every ``MemoryAccess`` in the function that ``MemorySSA`` is being; run on, and implies that we've hit the top of the function. It's the only; ``MemoryDef`` that maps to no ``Instruction`` in LLVM IR. Use of; ``liveOnEntry`` implies that the memory being used is either undefined or; defined before the function begins. An example of all of this overlaid on LLVM IR (obtained by running ``opt; -passes='print<memoryssa>' -disable-output`` on an ``.ll`` file) is below. When; viewing this example, it may be helpful to view it in terms of clobbers.; The operands of a given ``MemoryAccess`` are all (potential) clobbers of said; ``MemoryAccess``, and the value produced by a ``MemoryAccess`` can act as a clobber; for other ``MemoryAccess``\ es. If a ``MemoryAccess`` is a *clobber* of another, it means that these two; ``MemoryAccess``\ es may access the same memory. For example, ``x = MemoryDef(y)``; means that ``x`` potentially modifies memory that ``y`` modifies/constrains; (or has modified / constrained).; In the same manner, ``a = MemoryPhi({BB1,b},{BB2,c})`` means that; anyone that uses ``a`` is accessing memory potentially modified / constrained; by either ``b`` or ``c`` (or both). And finally, ``MemoryUse(x)`` means; that this use accesses memory that ``x`` has modified / constrained; (as an example, think that if ``x = MemoryDef(...)``; and ``MemoryUse(x)`` are in the same loop, the use can't; be hoisted outside alone). Another useful way of looking at it is in terms of memory versions.; In that view, operands of a given ``MemoryAccess`` are the version; of the entire memory before the operation, and if the access produces; a value (i.e. ``MemoryDef/MemoryPhi``),; the value is the new version of the memory after the operation. .. code-block:: llvm. define void @foo() {; entry:; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:4695,access,access,4695,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['access'],['access']
Security,"t element) serving as the upper bound. This applies to all; types of arrays including constant-length arrays, variable-length arrays (VLAs),; and flexible array members annotated with `__counted_by`. In the following example, reference to ``vla`` promotes to ``int; *__bidi_indexable``, with ``&vla[n]`` as the upper bound and ``&vla[0]`` as the; lower bound. Then, it's copied to ``int *p``, which is implicitly ``int; *__bidi_indexable p``. Please note that value of ``n`` used to create the upper; bound is ``10``, not ``100``, in this case because ``10`` is the actual length; of ``vla``, the value of ``n`` at the time when the array is being allocated. .. code-block:: c. void foo(void) {; int n = 10;; int vla[n];; n = 100;; int *p = vla; // { .ptr: &vla[0], .upper: &vla[10], .lower: &vla[0] }; // it's `&vla[10]` because the value of `n` was 10 at the; // time when the array is actually allocated.; // ...; }. By promoting array references to ``__bidi_indexable``, all array accesses are; bounds checked in ``-fbounds-safety``, just as ``__bidi_indexable`` pointers; are. Maintaining correctness of bounds annotations; ---------------------------------------------. ``-fbounds-safety`` maintains correctness of bounds annotations by performing; additional checks when a pointer object and/or its related value containing the; bounds information is updated. For example, ``__single`` expresses an invariant that the pointer must either; point to a single valid object or be a null pointer. To maintain this invariant,; the compiler inserts checks when initializing a ``__single`` pointer, as shown; in the following example:. .. code-block:: c. void foo(void *__sized_by(size) vp, size_t size) {; // Inserted check:; // if ((int*)upper_bound(vp) - (int*)vp < sizeof(int) && !!vp) trap();; int *__single ip = (int *)vp;; }. Additionally, an explicit bounds annotation such as ``int *__counted_by(count); buf`` defines a relationship between two variables, ``buf`` and ``count``:; namely, that",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:35008,access,accesses,35008,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['access'],['accesses']
Security,"t executes on each single entry single exit region in the function.; ``RegionPass`` processes regions in nested order such that the outer most; region is processed last. ``RegionPass`` subclasses are allowed to update the region tree by using the; ``RGPassManager`` interface. You may override three virtual methods of; ``RegionPass`` to implement your own region pass. All these methods should; return ``true`` if they modified the program, or ``false`` if they did not. The ``doInitialization(Region *, RGPassManager &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Region *, RGPassManager &RGM);. The ``doInitialization`` method is designed to do simple initialization type of; stuff that does not depend on the functions being processed. The; ``doInitialization`` method call is not scheduled to overlap with any other; pass executions (thus it should be very fast). ``RPPassManager`` interface; should be used to access ``Function`` or ``Module`` level analysis information. .. _writing-an-llvm-pass-runOnRegion:. The ``runOnRegion`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnRegion(Region *, RGPassManager &RGM) = 0;. The ``runOnRegion`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a true value should be; returned if the region is modified. ``RGPassManager`` interface should be used to; update region tree. The ``doFinalization()`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization();. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnRegion; <writing-an-llvm-pass-runOnRegion>` for every region in the program being; compiled. The ``MachineFunctionPass`` class; ---------------------------------. A ``MachineFunctionPass`` is a part of the LLVM code generator that executes on; the machine-de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:23818,access,access,23818,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['access'],['access']
Security,"t factor costs than ``std::vector``. If possible, use ``std::vector`` or; something cheaper. .. _dss_list:. <list>; ^^^^^^. ``std::list`` is an extremely inefficient class that is rarely useful. It; performs a heap allocation for every element inserted into it, thus having an; extremely high constant factor, particularly for small data types.; ``std::list`` also only supports bidirectional iteration, not random access; iteration. In exchange for this high cost, std::list supports efficient access to both ends; of the list (like ``std::deque``, but unlike ``std::vector`` or; ``SmallVector``). In addition, the iterator invalidation characteristics of; std::list are stronger than that of a vector class: inserting or removing an; element into the list does not invalidate iterator or pointers to other elements; in the list. .. _dss_ilist:. llvm/ADT/ilist.h; ^^^^^^^^^^^^^^^^. ``ilist<T>`` implements an 'intrusive' doubly-linked list. It is intrusive,; because it requires the element to store and provide access to the prev/next; pointers for the list. ``ilist`` has the same drawbacks as ``std::list``, and additionally requires an; ``ilist_traits`` implementation for the element type, but it provides some novel; characteristics. In particular, it can efficiently store polymorphic objects,; the traits class is informed when an element is inserted or removed from the; list, and ``ilist``\ s are guaranteed to support a constant-time splice; operation. An ``ilist`` and an ``iplist`` are ``using`` aliases to one another and the; latter only currently exists for historical purposes. These properties are exactly what we want for things like ``Instruction``\ s and; basic blocks, which is why these are implemented with ``ilist``\ s. Related classes of interest are explained in the following subsections:. * :ref:`ilist_traits <dss_ilist_traits>`. * :ref:`llvm/ADT/ilist_node.h <dss_ilist_node>`. * :ref:`Sentinels <dss_ilist_sentinel>`. .. _dss_packedvector:. llvm/ADT/PackedVector.h; ^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:66745,access,access,66745,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['access']
Security,"t hash value, the string itself, and the data; for the current string value. .. code-block:: none. .------------.; 0x000034f0: | 0x00003500 | next pointer; | 0x12345678 | 32 bit hash; | ""erase"" | string value; | data[n] | HashData for this bucket; |------------|; 0x00003500: | 0x00003550 | next pointer; | 0x29273623 | 32 bit hash; | ""dump"" | string value; | data[n] | HashData for this bucket; |------------|; 0x00003550: | 0x00000000 | next pointer; | 0x82638293 | 32 bit hash; | ""main"" | string value; | data[n] | HashData for this bucket; `------------'. The problem with this layout for debuggers is that we need to optimize for the; negative lookup case where the symbol we're searching for is not present. So; if we were to lookup ""``printf``"" in the table above, we would make a 32-bit; hash for ""``printf``"", it might match ``bucket[3]``. We would need to go to; the offset 0x000034f0 and start looking to see if our 32 bit hash matches. To; do so, we need to read the next pointer, then read the hash, compare it, and; skip to the next bucket. Each time we are skipping many bytes in memory and; touching new pages just to do the compare on the full 32 bit hash. All of; these accesses then tell us that we didn't have a match. Name Hash Tables; """""""""""""""""""""""""""""""". To solve the issues mentioned above we have structured the hash tables a bit; differently: a header, buckets, an array of all unique 32 bit hash values,; followed by an array of hash value data offsets, one for each hash value, then; the data for all hash values:. .. code-block:: none. .-------------.; | HEADER |; |-------------|; | BUCKETS |; |-------------|; | HASHES |; |-------------|; | OFFSETS |; |-------------|; | DATA |; `-------------'. The ``BUCKETS`` in the name tables are an index into the ``HASHES`` array. By; making all of the full 32 bit hash values contiguous in memory, we allow; ourselves to efficiently check for a match while touching as little memory as; possible. Most often checking the 32 bit hash",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:62549,hash,hash,62549,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"t have; # an effect, which is fine.; # (Note that the option is very counter-intuitive: We turn *on* disabling it...); set(CMAKE_DISABLE_FIND_PACKAGE_CUDA ON). # will be set again in case NOT builtin_llvm; set(LLVM_DIR ""${CMAKE_BINARY_DIR}/interpreter/llvm-project/llvm""); if (clad); set(CLING_BUILD_PLUGINS ON); endif(). # We only use llvm/clang through TCling which is (with the help of core/meta) already taking a lock; # to serialize access to llvm. We can later review how to make this finer grained by using llvm's own locking; # mechanism.; set(LLVM_ENABLE_THREADS OFF CACHE BOOL """"). # The llvm::ReverseIterate<bool>::value symbol from llvm's SmallPtrSet.h; # somehow lands in our cling libraries on OS X and doesn't get hidden; # by visibility-inlines-hidden, so we suddenly have a global weak symbol; # from LLVM in cling which our visiblity=hidden compiled LLVM libraries; # reference. This is triggering some build system warnings like this:; # ld: warning: direct access in function '(anonymous namespace)::NewGVN::runGVN()'; # from file 'interpreter/llvm-project/llvm/lib/libLLVMScalarOpts.a(NewGVN.cpp.o)' to global weak symbol; # 'llvm::ReverseIterate<bool>::value' from file 'interpreter/llvm-project/llvm/lib/libclingUtils.a(AST.cpp.o)'; # means the weak symbol cannot be overridden at runtime. This was likely caused by different; # translation units being compiled with different visibility settings.; # There is no apparent reason why this is happening and it looks like a compiler bug,; # so let's just disable the part of the code that provides this symbol.; # As it's in the validation part of LLVM and not in something that providing functionality,; # this shouldn't cause any problems.; # TODO: We maybe can remove this code once we upgrade to LLVM>=6.0 as this symbol; # was introduced quite recently into LLVM 5.0 and probably is also causing problems; # for some other projects.; set(LLVM_ENABLE_ABI_BREAKING_CHECKS OFF CACHE BOOL """" FORCE); set(LLVM_ABI_BREAKING_CHECKS ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:3452,access,access,3452,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['access'],['access']
Security,"t in memory from the column data. A view can iterate over the entry range, over the field range, and over the range of a collection within an entry.; For instance, for a field `std::vector<float> pt`, a view can iterate over all `pt` values of all entries, or over the `pt` values of a particular entry. A view can safely outlive its originating reader.; Once the reader is deconstructed, any attempt to read data will throw an exception, but the view is still properly destructed. Views that originate from the same reader _cannot_ be used concurrently by different threads. Internal Classes; ----------------. ### RNTupleDS; The `RNTupleDS` class is an internal class that provides an RNTuple data source for RDataFrame.; It is part of the `ROOTDataFrame` library.; The RNTuple data source supports chains with a constructor that takes a list of input files.; The RNTuple data source also supports multi-threaded dataframes, parallelized on the file and cluster level. The data source exposes inner fields of complex collections.; For instance, if the data model contains a vector of `Event` classes, where each `Event` has `pt` and `eta` floats,; the dataframe can use the event vector itself (`Event` column) as well as the `float` columns `Event.pt` and `Event.eta`. ### RClusterPool; The RClusterPool is an internal class owned be a page source.; The cluster pool maintains an I/O thread that asynchronously prefetches the next few clusters.; Through `RPageSource::SetEntryRange()`, the cluster pool is instructed to not read beyond the given limit.; This is used in the RNTuple data source when multiple threads work on different clusters of the same file. ### RMiniFile; The RMiniFile is an internal class used to read and write RNTuple data in a ROOT file.; It provides a minimal subset of the `TFile` functionality.; Its purpose is to reduce the coupling between RNTuple and the ROOT I/O library. For writing data, the RMiniFile can either use a proper `TFile` (descendant) or a C file strea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:14792,expose,exposes,14792,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['expose'],['exposes']
Security,"t limited; to members of any race, ethnicity, culture, national origin, colour,; immigration status, social and economic class, educational level, sex, sexual; orientation, gender identity and expression, age, size, family status,; political belief, religion or lack thereof, and mental and physical ability. .. _be considerate:. * **Be considerate.** Your work will be used by other people, and you in turn; will depend on the work of others. Any decision you take will affect users; and colleagues, and you should take those consequences into account. Remember; that we're a world-wide community, so you might not be communicating in; someone else's primary language. .. _be respectful:. * **Be respectful.** Not all of us will agree all the time, but disagreement is; no excuse for poor behavior and poor manners. We might all experience some; frustration now and then, but we cannot allow that frustration to turn into; a personal attack. It's important to remember that a community where people; feel uncomfortable or threatened is not a productive one. Members of the LLVM; community should be respectful when dealing with other members as well as; with people outside the LLVM community. .. _be careful in the words that you choose and be kind to others:. * **Be careful in the words that you choose and be kind to others.** Do not; insult or put down other participants. Harassment and other exclusionary; behavior aren't acceptable. This includes, but is not limited to:. * Violent threats or language directed against another person.; * Discriminatory jokes and language.; * Posting sexually explicit or violent material.; * Posting (or threatening to post) other people's personally identifying; information (""doxing"").; * Personal insults, especially those using racist or sexist terms.; * Unwelcome sexual attention.; * Advocating for, or encouraging, any of the above behavior. In general, if someone asks you to stop, then stop. Persisting in such; behavior after being asked to stop i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst:3724,threat,threatened,3724,interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,1,['threat'],['threatened']
Security,"t making the change. Attribution of Changes; ----------------------. When contributors submit a patch to an LLVM project, other developers with; commit access may commit it for the author once appropriate (based on the; progression of code review, etc.). When doing so, it is important to retain; correct attribution of contributions to their contributors. However, we do not; want the source code to be littered with random attributions ""this code written; by J. Random Hacker"" (this is noisy and distracting). In practice, the revision; control system keeps a perfect history of who changed what, and the CREDITS.txt; file describes higher-level contributions. If you commit a patch for someone; else, please follow the attribution of changes in the simple manner as outlined; by the `commit messages`_ section. Overall, please do not add contributor names; to the source code. Also, don't commit patches authored by others unless they have submitted the; patch to the project or you have been authorized to submit them on their behalf; (you work together and your company authorized you to contribute the patches,; etc.). The author should first submit them to the relevant project's commit; list, development list, or LLVM bug tracker component. If someone sends you; a patch privately, encourage them to submit it to the appropriate list first. Our previous version control system (subversion) did not distinguish between the; author and the committer like git does. As such, older commits used a different; attribution mechanism. The previous method was to include ""Patch by John Doe.""; in a separate line of the commit message and there are automated processes that; rely on this format. .. _IR backwards compatibility:. IR Backwards Compatibility; --------------------------. When the IR format has to be changed, keep in mind that we try to maintain some; backwards compatibility. The rules are intended as a balance between convenience; for llvm users and not imposing a big burden on llvm d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:30567,authoriz,authorized,30567,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,2,['authoriz'],['authorized']
Security,"t overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %10",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65650,secur,security,65650,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,6,"['attack', 'inject', 'secur']","['attack', 'attacker', 'inject', 'injection', 'security']"
Security,"t syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should be accessed by other statements. If the statement that declare variable is wrapped into function the variables won't be accessible from outside anymore. In this case variables are extracted onto the global scope.; ; TODO: There should be dedicated entry for that in the docs; Builtins; Cling starts with very few builtins loaded. Users could extend the available builtins via extending the RuntimeUniverse.h, which is loaded at cling's startup.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:3907,access,accessed,3907,interpreter/cling/www/old/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html,2,['access'],"['accessed', 'accessible']"
Security,"t system, ``sizeof(Token)`` is currently 16 bytes. Tokens occur in two forms: :ref:`annotation tokens <AnnotationToken>` and; normal tokens. Normal tokens are those returned by the lexer, annotation; tokens represent semantic information and are produced by the parser, replacing; normal tokens in the token stream. Normal tokens contain the following; information:. * **A SourceLocation** --- This indicates the location of the start of the; token. * **A length** --- This stores the length of the token as stored in the; ``SourceBuffer``. For tokens that include them, this length includes; trigraphs and escaped newlines which are ignored by later phases of the; compiler. By pointing into the original source buffer, it is always possible; to get the original spelling of a token completely accurately. * **IdentifierInfo** --- If a token takes the form of an identifier, and if; identifier lookup was enabled when the token was lexed (e.g., the lexer was; not reading in ""raw"" mode) this contains a pointer to the unique hash value; for the identifier. Because the lookup happens before keyword; identification, this field is set even for language keywords like ""``for``"". * **TokenKind** --- This indicates the kind of token as classified by the; lexer. This includes things like ``tok::starequal`` (for the ""``*=``""; operator), ``tok::ampamp`` for the ""``&&``"" token, and keyword values (e.g.,; ``tok::kw_for``) for identifiers that correspond to keywords. Note that; some tokens can be spelled multiple ways. For example, C++ supports; ""operator keywords"", where things like ""``and``"" are treated exactly like the; ""``&&``"" operator. In these cases, the kind value is set to ``tok::ampamp``,; which is good for the parser, which doesn't have to consider both forms. For; something that cares about which form is used (e.g., the preprocessor; ""stringize"" operator) the spelling indicates the original form. * **Flags** --- There are currently four flags tracked by the; lexer/preprocessor syste",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:46258,hash,hash,46258,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['hash'],['hash']
Security,"t the optimizers; should perform tail call optimization. The ``tail`` marker is a hint that; `can be ignored <CodeGenerator.html#tail-call-optimization>`_. The; ``musttail`` marker means that the call must be tail call optimized in order; for the program to be correct. This is true even in the presence of; attributes like ""disable-tail-calls"". The ``musttail`` marker provides these; guarantees:. #. The call will not cause unbounded stack growth if it is part of a; recursive cycle in the call graph.; #. Arguments with the :ref:`inalloca <attr_inalloca>` or; :ref:`preallocated <attr_preallocated>` attribute are forwarded in place.; #. If the musttail call appears in a function with the ``""thunk""`` attribute; and the caller and callee both have varargs, then any unprototyped; arguments in register or memory are forwarded to the callee. Similarly,; the return value of the callee is returned to the caller's caller, even; if a void return type is in use. Both markers imply that the callee does not access allocas from the caller.; The ``tail`` marker additionally implies that the callee does not access; varargs from the caller. Calls marked ``musttail`` must obey the following; additional rules:. - The call must immediately precede a :ref:`ret <i_ret>` instruction,; or a pointer bitcast followed by a ret instruction.; - The ret instruction must return the (possibly bitcasted) value; produced by the call, undef, or void.; - The calling conventions of the caller and callee must match.; - The callee must be varargs iff the caller is varargs. Bitcasting a; non-varargs function to the appropriate varargs type is legal so; long as the non-varargs prefixes obey the other rules.; - The return type must not undergo automatic conversion to an `sret` pointer. In addition, if the calling convention is not `swifttailcc` or `tailcc`:. - All ABI-impacting function attributes, such as sret, byval, inreg,; returned, and inalloca, must match.; - The caller and callee prototypes must match. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:473619,access,access,473619,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"t width parameters for the left and right sides of the Gaussian core. The new `RooCrystalBall` class can substitute the `RooDSCBShape` and `RooSDSCBShape`, which were passed around in the community. ## 2D Graphics Libraries. - Add the method `AddPoint`to `TGraph(x,y)` and `TGraph2D(x,y,z)`, equivalent to `SetPoint(g->GetN(),x,y)`and `SetPoint(g->GetN(),x,y,z)`; - Option `E0` draws error bars and markers are drawn for bins with 0 contents. Now, combined; with options E1 and E2, it avoids error bars clipping. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ### Multithreaded support for FastCGI. Now when THttpServer creates FastCGI engine, 10 worker threads used to process requests; received via FastCGI channel. This significantly increase a performance, especially when; several clients are connected. ### Better security for THttpServer with webgui. If THttpServer created for use with webgui widgets (RBrowser, RCanvas, REve), it only will; provide access to the widgets via websocket connection - any other kind of requests like root.json; or exe.json will be refused completely. Combined with connection tokens and https protocol,; this makes usage of webgui components in public networks more secure. ### Enabled WLCG Bearer Tokens support in RDavix. Bearer tokens are part of WLCG capability-based infrastructure with capability-based scheme which uses an infrastructure that describes what the bearer is allowed to do as opposed to who that bearer is. Token discovery procedure are developed according WLCG Bearer Token Discovery specification document (https://github.com/WLCG-AuthZ-WG/bearer-token-discovery/blob/master/specification.md). Short overview:. 1. If the `BEARER_TOKEN` environment variable is set, then the value is taken to be the token contents.; 2. If the `BEARER_TOKEN_FILE` environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:25414,access,access,25414,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['access'],['access']
Security,"t would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive un",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:63620,secur,security,63620,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security']
Security,"t) so that they're accessible to ``VariableExprAST`` nodes. .. code-block:: c++. if (Value *RetVal = Body->codegen()) {; // Finish off the function.; Builder->CreateRet(RetVal);. // Validate the generated code, checking for consistency.; verifyFunction(*TheFunction);. return TheFunction;; }. Once the insertion point has been set up and the NamedValues map populated,; we call the ``codegen()`` method for the root expression of the function. If no; error happens, this emits code to compute the expression into the entry block; and returns the value that was computed. Assuming no error, we then create an; LLVM `ret instruction <../../LangRef.html#ret-instruction>`_, which completes the function.; Once the function is built, we call ``verifyFunction``, which is; provided by LLVM. This function does a variety of consistency checks on; the generated code, to determine if our compiler is doing everything; right. Using this is important: it can catch a lot of bugs. Once the; function is finished and validated, we return it. .. code-block:: c++. // Error reading body, remove function.; TheFunction->eraseFromParent();; return nullptr;; }. The only piece left here is handling of the error case. For simplicity,; we handle this by merely deleting the function we produced with the; ``eraseFromParent`` method. This allows the user to redefine a function; that they incorrectly typed in before: if we didn't delete it, it would; live in the symbol table, with a body, preventing future redefinition. This code does have a bug, though: If the ``FunctionAST::codegen()`` method; finds an existing IR Function, it does not validate its signature against the; definition's own prototype. This means that an earlier 'extern' declaration will; take precedence over the function definition's signature, which can cause; codegen to fail, for instance if the function arguments are named differently.; There are a number of ways to fix this bug, see what you can come up with! Here; is a testcase:. ::. e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:16350,validat,validated,16350,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['validat'],['validated']
Security,"t**: byte offset into the array or record, used to step back to the; parent array or record.; * **IsConst**: flag indicating if the field is const-qualified.; * **IsInitialized**: flag indicating whether the field or element was; initialized. For non-primitive fields, this is only relevant to determine; the dynamic type of objects during construction.; * **IsBase**: flag indicating whether the record is a base class. In that; case, the offset can be used to identify the derived class.; * **IsActive**: indicates if the field is the active field of a union.; * **IsMutable**: indicates if the field is marked as mutable. Inline descriptors are filled in by the `CtorFn` of blocks, which leaves storage; in an uninitialised, but valid state. Descriptors; -----------. Descriptors are generated at bytecode compilation time and contain information; required to determine if a particular memory access is allowed in constexpr.; They also carry all the information required to emit a diagnostic involving; a memory access, such as the declaration which originates the block.; Currently there is a single kind of descriptor encoding information for all; block types. Pointers; --------. Pointers, implemented in ``Pointer.h`` are represented as a tagged union.; Some of these may not yet be available in upstream ``clang``. * **BlockPointer**: used to reference memory allocated and managed by the; interpreter, being the only pointer kind which allows dereferencing in the; interpreter; * **ExternPointer**: points to memory which can be addressed, but not read by; the interpreter. It is equivalent to APValue, tracking a declaration and a path; of fields and indices into that allocation.; * **TargetPointer**: represents a target address derived from a base address; through pointer arithmetic, such as ``((int *)0x100)[20]``. Null pointers are; target pointers with a zero offset.; * **TypeInfoPointer**: tracks information for the opaque type returned by; ``typeid``; * **InvalidPointer**: is dum",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:8506,access,access,8506,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,1,['access'],['access']
Security,"t, integer arithmetic wrapping may occur, so the comparison may not; be meaningful. Can I do GEP with a different pointer type than the type of the underlying object?; ----------------------------------------------------------------------------------. Yes. There are no restrictions on bitcasting a pointer value to an arbitrary; pointer type. The types in a GEP serve only to define the parameters for the; underlying integer computation. They need not correspond with the actual type of; the underlying object. Furthermore, loads and stores don't have to use the same types as the type of; the underlying object. Types in this context serve only to specify memory size; and alignment. Beyond that there are merely a hint to the optimizer indicating; how the value will likely be used. Can I cast an object's address to integer and add it to null?; -------------------------------------------------------------. You can compute an address that way, but if you use GEP to do the add, you can't; use that pointer to actually access the object, unless the object is managed; outside of LLVM. The underlying integer computation is sufficiently defined; null has a defined; value --- zero --- and you can add whatever value you want to it. However, it's invalid to access (load from or store to) an LLVM-aware object; with such a pointer. This includes ``GlobalVariables``, ``Allocas``, and objects; pointed to by noalias pointers. If you really need this functionality, you can do the arithmetic with explicit; integer instructions, and use inttoptr to convert the result to an address. Most; of GEP's special aliasing rules do not apply to pointers computed from ptrtoint,; arithmetic, and inttoptr sequences. Can I compute the distance between two objects, and add that value to one address to compute the other address?; ---------------------------------------------------------------------------------------------------------------. As with arithmetic on null, you can use GEP to compute an address t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:15603,access,access,15603,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['access'],['access']
Security,"t-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:66523,attack,attack,66523,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['attack'],['attack']
Security,"t-unsigned-integer-truncation``,; ``-fsanitize=implicit-signed-integer-truncation``: Implicit conversion from; integer of larger bit width to smaller bit width, if that results in data; loss. That is, if the demoted value, after casting back to the original; width, is not equal to the original value before the downcast.; The ``-fsanitize=implicit-unsigned-integer-truncation`` handles conversions; between two ``unsigned`` types, while; ``-fsanitize=implicit-signed-integer-truncation`` handles the rest of the; conversions - when either one, or both of the types are signed.; Issues caught by these sanitizers are not undefined behavior,; but are often unintentional.; - ``-fsanitize=implicit-integer-sign-change``: Implicit conversion between; integer types, if that changes the sign of the value. That is, if the; original value was negative and the new value is positive (or zero),; or the original value was positive, and the new value is negative.; Issues caught by this sanitizer are not undefined behavior,; but are often unintentional.; - ``-fsanitize=integer-divide-by-zero``: Integer division by zero.; - ``-fsanitize=nonnull-attribute``: Passing null pointer as a function; parameter which is declared to never be null.; - ``-fsanitize=null``: Use of a null pointer or creation of a null; reference.; - ``-fsanitize=nullability-arg``: Passing null as a function parameter; which is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-assign``: Assigning null to an lvalue which; is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-return``: Returning null from a function with; a return type annotated with ``_Nonnull``.; - ``-fsanitize=objc-cast``: Invalid implicit cast of an ObjC object pointer; to an incompatible type. This is often unintentional, but is not undefined; behavior, therefore the check is not a part of the ``undefined`` group.; Currently only supported on Darwin.; - ``-fsanitize=object-size``: An attempt to potentially use bytes which; the optimizer ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:6105,sanitiz,sanitizer,6105,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['sanitiz'],['sanitizer']
Security,"t. !0 = !DICompileUnit(language: DW_LANG_C99, file: !1, producer: ""clang"",; isOptimized: true, flags: ""-O2"", runtimeVersion: 2,; splitDebugFilename: ""abc.debug"", emissionKind: FullDebug,; enums: !2, retainedTypes: !3, globals: !4, imports: !5,; macros: !6, dwoId: 0x0abcd). Compile unit descriptors provide the root scope for objects declared in a; specific compilation unit. File descriptors are defined using this scope. These; descriptors are collected by a named metadata node ``!llvm.dbg.cu``. They keep; track of global variables, type information, and imported entities (declarations; and namespaces). .. _DIFile:. DIFile; """""""""""". ``DIFile`` nodes represent files. The ``filename:`` can include slashes. .. code-block:: none. !0 = !DIFile(filename: ""path/to/file"", directory: ""/path/to/dir"",; checksumkind: CSK_MD5,; checksum: ""000102030405060708090a0b0c0d0e0f""). Files are sometimes used in ``scope:`` fields, and are the only valid target; for ``file:`` fields. The ``checksum:`` and ``checksumkind:`` fields are optional. If one of these; fields is present, then the other is required to be present as well. Valid; values for ``checksumkind:`` field are: {CSK_MD5, CSK_SHA1, CSK_SHA256}. .. _DIBasicType:. DIBasicType; """""""""""""""""""""". ``DIBasicType`` nodes represent primitive types, such as ``int``, ``bool`` and; ``float``. ``tag:`` defaults to ``DW_TAG_base_type``. .. code-block:: text. !0 = !DIBasicType(name: ""unsigned char"", size: 8, align: 8,; encoding: DW_ATE_unsigned_char); !1 = !DIBasicType(tag: DW_TAG_unspecified_type, name: ""decltype(nullptr)""). The ``encoding:`` describes the details of the type. Usually it's one of the; following:. .. code-block:: text. DW_ATE_address = 1; DW_ATE_boolean = 2; DW_ATE_float = 4; DW_ATE_signed = 5; DW_ATE_signed_char = 6; DW_ATE_unsigned = 7; DW_ATE_unsigned_char = 8. .. _DISubroutineType:. DISubroutineType; """""""""""""""""""""""""""""""". ``DISubroutineType`` nodes represent subroutine types. Their ``types:`` field; refers to a tuple; the first operan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:247664,checksum,checksum,247664,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['checksum'],"['checksum', 'checksumkind']"
Security,"t. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; level of indirection. On every counter access, we add a bias to the counter; address. This bias is stored in ``__llvm_profile_counter_bias`` symbol that's; provided by the profile runtime and is initially set to zero, meaning no; relocation. The runtime can map the profile into memory at arbitrary locations,; and set bias to the offset between the original and the new counter location,; at which point every subsequent counter access will be to the new location,; which allows updating profile directly akin to the continuous mode. The advantage of this approach is that doesn't require any special OS support.; The disadvantage is the extra overhead due to additional instructions required; for each counter access (overhead both in terms of binary size and performance); plus duplication of counters (i.e. one copy in the binary itself and another; copy that's mapped into memory). This implementation can be also enabled for; other platforms by passing the ``-runtime-counter-relocation`` option to the; backend during compilation. For a program such as the `Lit <https://llvm.org/docs/CommandGuide/lit.html>`_; testing tool which invokes other programs, it may be necessary to set; ``LLVM_PROFILE_FILE`` for each invocation. The pattern strings ""%p"" or ""%Nm""; may help to avoid corruption due to concurrency. Note that ""%p"" is also a Lit; token and needs to be escaped as ""%%p"". .. code-block:: console. % clang++ -fprofile-instr-generate -fcoverage-mapping -mllvm -runtime-counter-relocation foo.cc -o foo. Creating coverage reports; =========================. Raw profiles have to be **indexed** before they can be used to generate; coverage reports. This is done using the ""merge"" tool in ``llvm-profd",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:5044,access,access,5044,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['access'],['access']
Security,"t1<<el1|dataset2<<el2|"".; The datasets to be processed can also be specified on one or multiple lines in a text file.; Add; support for automatic download of a package when available on the; master but not locally. The downloaded packages are store under <sandbox>/packages/downloaded; and automatically checked for updates against the master repository. If; a local version of the same package is created (using the; UploadPackage) the entry in downloaded is; cleared, so that the behaviour is unchanged.; Add; the possibility to remap the server for the files in a dataset. This; allows, for example, to reuse the dataset information for the same; files stored in a different cluster.; Add a local cache for; TDataSetManagerFile. This is mainly used to improve the speed of; TDataSetManager::ShowDataSets, which is run very often by users and may; be very slow if the number of dataset is large. The cache is also used; to cache frequently received dataset objects.Add the possibility to audit the activity on the nodes via syslog. .; New packetizer TPacketizerFile generating packets which contain a single; file path to be used in processing single files. Used, for example, in; tasks generating files. The files are specified into a TMap - named; 'PROOF_FilesToProcess' - containing the list of files to be generated; per host (the key is the host name, the value the TList of TObjString; (or TFileInfo) with the files names - or a TFileCollection: the output; of TFileCollection::GetFilesPerServer() can be directly passed as files; map). Workers are first assigned files belonging to; the list with host name matching the worker name. The map is; distributed to the master via the input list.Add support for; automatic setting of pointer data members to the relevant object in the; output list. The use of fOutputList->FindObject(""name"") in; TSelector::Terminate is not needed anymore for pointer data members,; e.g. histograms.; Add the possibility to define an external list of environment; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:1781,audit,audit,1781,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,1,['audit'],['audit']
Security,"tListOfGeometries(); gROOT->GetListOfBrowsers(); gROOT->GetListOfMessageHandlers(); ```. These methods return a **`TSeqCollection`**, meaning a collection of; objects, and they can be used to do list operations such as finding an; object, or traversing the list and calling a method for each of the; members. See the **`TCollection`** class description for the full set; of methods supported for a collection. For example, to find a canvas; called `c1 `you can do`:`. ``` {.cpp}; root[] gROOT->GetListOfCanvases()->FindObject(""c1""); ```. This returns a pointer to a **`TObject`**, and before you can use it; as a canvas you need to cast it to a **`TCanvas*`.**. ### gFile. ***`gFile`*** is the pointer to the current opened file in the ROOT; session. ### gDirectory. ***`gDirectory`*** is a pointer to the current directory. The concept; and role of a directory is explained in the chapter ""Input/Output"". ### gPad. A graphic object is always drawn on the active pad. It is convenient; to access the active pad, no matter what it is. For that, we have; ***`gPad`*** that is always pointing to the active pad. For example,; if you want to change the fill color of the active pad to blue, but; you do not know its name, you can use ***`gPad`***. ``` {.cpp}; root[] gPad->SetFillColor(38); ```. To get the list of colors, if you have an open canvas, click in the; ""View"" menu, selecting the ""Colors"" entry. ### gRandom. ***`gRandom`*** is a pointer to the current random number generator.; By default, it points to a **`TRandom3`** object, based on the; ""Mersenne-Twister"" generator. This generator is very fast and has very; good random proprieties (a very long period of 10^600^). Setting the; seed to 0 implies that the seed will be uniquely generated using the; **`TUUID`**. Any other value will be used as a constant. The following; basic random distributions are provided: `Rndm()` or; `Uniform(min,max)`, `Gaus(mean,sigma)`, `Exp(tau)`,; `BreitWigner(mean,sigma)`, `Landau(mean,sigma)`, `Poisson(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:34233,access,access,34233,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['access'],['access']
Security,"t_err.push_back(0.1);; init_err.push_back(0.1);. // create minimizer (default constructor); VariableMetricMinimizer theMinimizer;. // minimize; FunctionMinimum min =; theMinimizer.minimize(theFCN, init_par, init_err);. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate standard minimization using MIGRAD; // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create MIGRAD minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate full interaction with parameters over subsequent; // minimizations. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // access parameter by name to set limits...; upar.setLimits(""mean"", mean-0.01, mean+0.01);. // ... or access parameter by index; upar.setLimits(1, rms-0.1, rms+0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // fix a parameter...; migrad.fix(""mean"");. // ... and minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;. // release a parameter...; migrad.release(""mean"");. // ... and fix another one; migrad.fix(1);. // and minimize again; FunctionMinimum min1 = migrad();. // output; std::cout<<""minimum1: ""<<min1<<std::endl;. // release the parameter...; migrad.release(1);. // ... and minimize with all three parameters; // (still with limits!); FunctionMinimum min2 = migrad();. // output; std::cout<<""minimum2: ""<<min2<<std::endl;. // remove all limits on parameters...; migrad.removeLimits(""mean"");; migrad.removeLimits(""sigma"");. // ... and minimize again with all three parameters; // (now without limits!); FunctionMinimum min3 = migrad();. // output; std::cout<<""minimum3: ""<<min3<<std::endl;; }. {; // demonstrate MINOS error analysis. // create Min",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:80139,access,access,80139,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['access'],['access']
Security,"ta file will be; generated for each object file. These ``.gcno`` files contain half of the; coverage data. The other half of the data comes from ``.gcda`` files that are; generated when you run the instrumented program, with a separate ``.gcda``; file for each object file. Each time you run the program, the execution counts; are summed into any existing ``.gcda`` files, so be sure to remove any old; files if you do not want their contents to be included. By default, the ``.gcda`` files are written into the same directory as the; object files, but you can override that by setting the ``GCOV_PREFIX`` and; ``GCOV_PREFIX_STRIP`` environment variables. The ``GCOV_PREFIX_STRIP``; variable specifies a number of directory components to be removed from the; start of the absolute path to the object file directory. After stripping those; directories, the prefix from the ``GCOV_PREFIX`` variable is added. These; environment variables allow you to run the instrumented program on a machine; where the original object file directories are not accessible, but you will; then need to copy the ``.gcda`` files back to the object file directories; where :program:`llvm-cov gcov` expects to find them. Once you have generated the coverage data files, run :program:`llvm-cov gcov`; for each main source file where you want to examine the coverage results. This; should be run from the same directory where you previously ran the; compiler. The results for the specified source file are written to a file named; by appending a ``.gcov`` suffix. A separate output file is also created for; each file included by the main source file, also with a ``.gcov`` suffix added. The basic content of an ``.gcov`` output file is a copy of the source file with; an execution count and line number prepended to every line. The execution; count is shown as ``-`` if a line does not contain any executable code. If; a line contains code but that code was never executed, the count is displayed; as ``#####``. OPTIONS; ^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst:2622,access,accessible,2622,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,1,['access'],['accessible']
Security,"ta, and may load from memory and; leak the loaded values through various side channels that survive even when the; speculative execution is unwound due to being incorrect. Mispredicted paths can; cause code to be executed with data inputs that never occur in correct; executions, making checks against malicious inputs ineffective and allowing; attackers to use malicious data inputs to leak secret data. Here is an example,; extracted and simplified from the Project Zero paper:; ```; struct array {; unsigned long length;; unsigned char data[];; };; struct array *arr1 = ...; // small array; struct array *arr2 = ...; // array of size 0x400; unsigned long untrusted_offset_from_caller = ...;; if (untrusted_offset_from_caller < arr1->length) {; unsigned char value = arr1->data[untrusted_offset_from_caller];; unsigned long index2 = ((value&1)*0x100)+0x200;; unsigned char value2 = arr2->data[index2];; }; ```. The key of the attack is to call this with `untrusted_offset_from_caller` that; is far outside of the bounds when the branch predictor will predict that it; will be in-bounds. In that case, the body of the `if` will be executed; speculatively, and may read secret data into `value` and leak it via a; cache-timing side channel when a dependent access is made to populate `value2`. ## High Level Mitigation Approach. While several approaches are being actively pursued to mitigate specific; branches and/or loads inside especially risky software (most notably various OS; kernels), these approaches require manual and/or static analysis aided auditing; of code and explicit source changes to apply the mitigation. They are unlikely; to scale well to large applications. We are proposing a comprehensive; mitigation approach that would apply automatically across an entire program; rather than through manual changes to the code. While this is likely to have a; high performance cost, some applications may be in a good position to take this; performance / security tradeoff. The specific ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:1959,attack,attack,1959,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attack']
Security,"ta; resides. *Target architecture specific DWARF address spaces may correspond to hardware; supported facilities such as memory utilizing base address registers, scratchpad; memory, and memory with special interleaving. The size of addresses in these; address spaces may vary. Their access and allocation may be hardware managed; with each thread or group of threads having access to independent storage. For; these reasons they may have properties that do not allow them to be viewed as; part of the unified global virtual address space accessible by all threads.*. *It is target architecture specific whether multiple DWARF address spaces are; supported and how source language memory spaces map to target architecture; specific DWARF address spaces. A target architecture may map multiple source; language memory spaces to the same target architecture specific DWARF address; class. Optimization may determine that variable lifetime and access pattern; allows them to be allocated in faster scratchpad memory represented by a; different DWARF address space than the default for the source language memory; space.*. Although DWARF address space identifiers are target architecture specific,; ``DW_ASPACE_LLVM_none`` is a common address space supported by all target; architectures, and defined as the target architecture default address space. DWARF address space identifiers are used by:. * The ``DW_AT_LLVM_address_space`` attribute. * The DWARF expression operations: ``DW_OP_aspace_bregx``,; ``DW_OP_form_aspace_address``, ``DW_OP_aspace_implicit_pointer``, and; ``DW_OP_xderef*``. * The CFI instructions: ``DW_CFA_def_aspace_cfa`` and; ``DW_CFA_def_aspace_cfa_sf``. .. note::. Currently, DWARF defines address class values as being target architecture; specific, and defines a DW_AT_address_class attribute. With the removal of; DW_AT_segment in DWARF 6, it is unclear how the address class is intended to; be used as the term is not used elsewhere. Should these be replaced by this; proposal'",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:149034,access,access,149034,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['access']
Security,"tack, and other context elements corresponding to the source language; thread of execution upon which the user is focused, if any. The resulting; value V\ :sub:`3` is the value in L\ :sub:`2` at the time of the call made; by the call site. The result of these attributes is undefined if the current call frame is not; for the subprogram containing the ``DW_TAG_call_site_parameter`` debugger; information entry or the current program location is not for the call site; containing the ``DW_TAG_call_site_parameter`` debugger information entry in; the current call frame. *The consumer may have to virtually unwind to the call site (see*; :ref:`amdgpu-dwarf-call-frame-information`\ *) in order to evaluate these; attributes. This will ensure the source language thread of execution upon; which the user is focused corresponds to the call site needed to evaluate; the expression.*. If it is not possible to avoid the expressions of these attributes from; accessing registers or memory locations that might be clobbered by the; subprogram being called by the call site, then the associated attribute; should not be provided. *The reason for the restriction is that the parameter may need to be; accessed during the execution of the callee. The consumer may virtually; unwind from the called subprogram back to the caller and then evaluate the; attribute expressions. The call frame information (see*; :ref:`amdgpu-dwarf-call-frame-information`\ *) will not be able to restore; registers that have been clobbered, and clobbered memory will no longer have; the value at the time of the call.*. 3. Each call site parameter entry may also have a ``DW_AT_call_parameter``; attribute which contains a reference to a ``DW_TAG_formal_parameter`` entry,; ``DW_AT_type attribute`` referencing the type of the parameter or; ``DW_AT_name`` attribute describing the parameter's name. *Examples using call site entries and related attributes are found in Appendix; D.15.*. .. _amdgpu-dwarf-lexical-block-entries:. A.3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:170829,access,accessing,170829,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['accessing']
Security,"tack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77033,sanitiz,sanitizers,77033,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['sanitiz'],['sanitizers']
Security,"tadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If loop versioning is necessary, this metadata defined the attributes; the non-distributed fallback version will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The attributes in this metadata is added to all followup loops of the; loop distribution pass. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.licm.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that loop-invariant code motion (LICM) should not be; performed on this loop. The metadata has a single operand which is the string; ``llvm.licm.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.licm.disable""}. Note that although it operates per loop it isn't given the llvm.loop prefix; as it is not affected by the ``llvm.loop.disable_nonforced`` metadata. '``llvm.access.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``llvm.access.group`` metadata can be attached to any instruction that; potentially accesses memory. It can point to a single distinct metadata; node, which we call access group. This node represents all memory access; instructions referring to it via ``llvm.access.group``. When an; instruction belongs to multiple access groups, it can also point to a; list of accesses groups, illustrated by the following example. .. code-block:: llvm. %val = load i32, ptr %arrayidx, !llvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:309970,access,access,309970,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"tal number of times the instruction; is executed, followed by uint64_t value and execution count pairs.; The value profiling kind is 0 for indirect call targets and 1 for memory; operations. For indirect call targets, each profile value is a hash; of the callee function name, and for memory operations each value is the; byte length. Note that the value counts do not need to add up to the total count; listed in the third operand (in practice only the top hottest values; are tracked and reported). Indirect call example:. .. code-block:: llvm. call void %f(), !prof !1; !1 = !{!""VP"", i32 0, i64 1600, i64 7651369219802541373, i64 1030, i64 -4377547752858689819, i64 410}. Note that the VP type is 0 (the second operand), which indicates this is; an indirect call value profile data. The third operand indicates that the; indirect call executed 1600 times. The 4th and 6th operands give the; hashes of the 2 hottest target functions' names (this is the same hash used; to represent function names in the profile database), and the 5th and 7th; operands give the execution count that each of the respective prior target; functions was called. .. _md_annotation:. '``annotation``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``annotation`` metadata can be used to attach a tuple of annotation strings; or a tuple of a tuple of annotation strings to any instruction. This metadata does; not impact the semantics of the program and may only be used to provide additional; insight about the program and transformations to users. Example:. .. code-block:: text. %a.addr = alloca ptr, align 8, !annotation !0; !0 = !{!""auto-init""}. Embedding tuple of strings example:. .. code-block:: text. %a.ptr = getelementptr ptr, ptr %base, i64 0. !annotation !0; !0 = !{!1}; !1 = !{!""gep offset"", !""0""}. '``func_sanitize``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``func_sanitize`` metadata is used to attach two values for the function; sanitizer instrumentation. The first value is the ubsan function signature.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:321787,hash,hashes,321787,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['hash'],"['hash', 'hashes']"
Security,"tance, *R*, from a set; of measurements. As a first step, a visualisation of the data is needed. Next, some; manipulations typically have to be applied, e.g. corrections or; parameter transformations. Quite often, these manipulations are complex; ones, and a powerful library of mathematical functions and procedures; should be provided - think for example of an integral or peak-search or; a Fourier transformation applied to an input spectrum to obtain the; actual measurement described by the model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:1493,access,access,1493,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['access'],['access']
Security,"tch* address register (an SP3 syntax).; [flat_scratch_hi] High 32 bits of *flat scratch* address register (an SP3 syntax).; ========================= =========================================================================. .. _amdgpu_synid_xnack:; .. _amdgpu_synid_xnack_mask:. xnack_mask; ----------. Xnack mask, 64-bits wide. Holds a 64-bit mask of which threads; received an *XNACK* due to a vector memory operation. For availability of *xnack* feature, refer to :ref:`this table<amdgpu-processors>`. ============================== =====================================================; Syntax Description; ============================== =====================================================; xnack_mask 64-bit *xnack mask* register.; [xnack_mask] 64-bit *xnack mask* register (an SP3 syntax).; [xnack_mask_lo,xnack_mask_hi] 64-bit *xnack mask* register (an SP3 syntax).; ============================== =====================================================. High and low 32 bits of *xnack mask* may be accessed as separate registers:. ===================== ==============================================================; Syntax Description; ===================== ==============================================================; xnack_mask_lo Low 32 bits of *xnack mask* register.; xnack_mask_hi High 32 bits of *xnack mask* register.; [xnack_mask_lo] Low 32 bits of *xnack mask* register (an SP3 syntax).; [xnack_mask_hi] High 32 bits of *xnack mask* register (an SP3 syntax).; ===================== ==============================================================. .. _amdgpu_synid_vcc:; .. _amdgpu_synid_vcc_lo:. vcc; ---. Vector condition code, 64-bits wide. A bit mask with one bit per thread;; it holds the result of a vector compare operation. Note that GFX10+ H/W does not use high 32 bits of *vcc* in *wave32* mode. ================ =========================================================================; Syntax Description; ================ ==============================================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst:16814,access,accessed,16814,interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,1,['access'],['accessed']
Security,"tcnt vmcnt(0)`` is required to ensure; synchronization between vector memory operations of different CUs. It; ensures a previous vector memory operation has completed before executing a; subsequent vector memory or LDS operation and so can be used to meet the; requirements of acquire and release.; * The L2 cache of one agent can be kept coherent with other agents by:; using the MTYPE RW (read-write) or MTYPE CC (cache-coherent) with the PTE; C-bit for memory local to the L2; and using the MTYPE NC (non-coherent) with; the PTE C-bit set or MTYPE UC (uncached) for memory not local to the L2. * Any local memory cache lines will be automatically invalidated by writes; from CUs associated with other L2 caches, or writes from the CPU, due to; the cache probe caused by coherent requests. Coherent requests are caused; by GPU accesses to pages with the PTE C-bit set, by CPU accesses over; XGMI, and by PCIe requests that are configured to be coherent requests.; * XGMI accesses from the CPU to local memory may be cached on the CPU.; Subsequent access from the GPU will automatically invalidate or writeback; the CPU cache due to the L2 probe filter and and the PTE C-bit being set.; * Since all work-groups on the same agent share the same L2, no L2; invalidation or writeback is required for coherence.; * To ensure coherence of local and remote memory writes of work-groups in; different agents a ``buffer_wbl2`` is required. It will writeback dirty L2; cache lines of MTYPE RW (used for local coarse grain memory) and MTYPE NC; ()used for remote coarse grain memory). Note that MTYPE CC (used for local; fine grain memory) causes write through to DRAM, and MTYPE UC (used for; remote fine grain memory) bypasses the L2, so both will never result in; dirty L2 cache lines.; * To ensure coherence of local and remote memory reads of work-groups in; different agents a ``buffer_invl2`` is required. It will invalidate L2; cache lines with MTYPE NC (used for remote coarse grain memory). Note tha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:238274,access,accesses,238274,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accesses']
Security,"tcnt`` instructions when there are; no intervening memory instructions which access the corresponding address; space. The code sequences in the table indicate what can be omitted for the; OpenCL memory. The target triple environment is used to determine if the; source language is OpenCL (see :ref:`amdgpu-opencl`). ``ds/flat_load/store/atomic`` instructions to local memory are termed LDS; operations. ``buffer/global/flat_load/store/atomic`` instructions to global memory are; termed vector memory operations. Private address space uses ``buffer_load/store`` using the scratch V#; (GFX6-GFX8), or ``scratch_load/store`` (GFX9-GFX11). Since only a single thread; is accessing the memory, atomic memory orderings are not meaningful, and all; accesses are treated as non-atomic. Constant address space uses ``buffer/global_load`` instructions (or equivalent; scalar memory instructions). Since the constant address space contents do not; change during the execution of a kernel dispatch it is not legal to perform; stores, and atomic memory orderings are not meaningful, and all accesses are; treated as non-atomic. A memory synchronization scope wider than work-group is not meaningful for the; group (LDS) address space and is treated as work-group. The memory model does not support the region address space which is treated as; non-atomic. Acquire memory ordering is not meaningful on store atomic instructions and is; treated as non-atomic. Release memory ordering is not meaningful on load atomic instructions and is; treated a non-atomic. Acquire-release memory ordering is not meaningful on load or store atomic; instructions and is treated as acquire and release respectively. The memory order also adds the single thread optimization constraints defined in; table; :ref:`amdgpu-amdhsa-memory-model-single-thread-optimization-constraints-table`. .. table:: AMDHSA Memory Model Single Thread Optimization Constraints; :name: amdgpu-amdhsa-memory-model-single-thread-optimization-constraints-ta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:203574,access,accesses,203574,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accesses']
Security,"te and the destructor).; Cling does not support such a multiplexing wrapper and alternatively; interface must be used (See TClass::New and TClass::Destructor for; example). The following interfaces are not yet available:. - DeleteVariable. They might be re-implemented in a later version. ### rootcling, rootcint and genreflex. rootcling is the successor to rootcint and it preserves its old commandline; arguments and provides more (see help). The executable rootcint still exists; but it is just a redirection to rootcling.; The following *backward incompatibilities* are present between rootcint in; version 5 and rootcling in version 6:. - rootcling does not support multiline \#pragma without a line; continuation as rootcint did (rootcint support \#pragma link with a; line continutation only in ROOT v5.34/02 and above).; - rootcling no longer re-\#defines the private and protected keywords; to public. In particular this means that code compiled as part of; the dictionary no longer has access to protected and private members; of a class (except where allowed by the C++ standard).; In particular, this means that the code used for read rules (\#pragma read); can no longer access private member unless they have been mentioned as a; target of the rule.; - rootcling no longer considers a friend declaration to be a; declaration for the friended function. In particular this means that; rootcling may now issue:. ``` {.cpp}; Error: in this version of ROOT, the option '!' used in a linkdef file; implies the actual existence of customized operators.; The following declaration is now required:; TBuffer &operator<<(TBuffer &,const THit *);; ```. if the operator `<<` declaration is missing. To steer the parsing done during the execution of rootcling, a new; macro: *\_\_ROOTCLING\_\_* is now defined during the parsing. The macros; *\_\_CINT\_\_* and *\_\_MAKECINT\_\_* are defined only when looking for; `#pragma` statement. The genreflex executable is still available, it preserves the sa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md:6414,access,access,6414,core/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md,1,['access'],['access']
Security,"te data for hash); |------------|; 0x00003500: | 0x00001203 | String offset into .debug_str (""collision""); | 0x00000002 | A 32 bit array count - number of HashData with name ""collision""; | 0x........ | HashData[0]; | 0x........ | HashData[1]; | 0x00001203 | String offset into .debug_str (""dump""); | 0x00000003 | A 32 bit array count - number of HashData with name ""dump""; | 0x........ | HashData[0]; | 0x........ | HashData[1]; | 0x........ | HashData[2]; | 0x00000000 | String offset into .debug_str (terminate data for hash); |------------|; 0x00003550: | 0x00001203 | String offset into .debug_str (""main""); | 0x00000009 | A 32 bit array count - number of HashData with name ""main""; | 0x........ | HashData[0]; | 0x........ | HashData[1]; | 0x........ | HashData[2]; | 0x........ | HashData[3]; | 0x........ | HashData[4]; | 0x........ | HashData[5]; | 0x........ | HashData[6]; | 0x........ | HashData[7]; | 0x........ | HashData[8]; | 0x00000000 | String offset into .debug_str (terminate data for hash); `------------'. So we still have all of the same data, we just organize it more efficiently for; debugger lookup. If we repeat the same ""``printf``"" lookup from above, we; would hash ""``printf``"" and find it matches ``BUCKETS[3]`` by taking the 32 bit; hash value and modulo it by ``n_buckets``. ``BUCKETS[3]`` contains ""6"" which; is the index into the ``HASHES`` table. We would then compare any consecutive; 32 bit hashes values in the ``HASHES`` array as long as the hashes would be in; ``BUCKETS[3]``. We do this by verifying that each subsequent hash value modulo; ``n_buckets`` is still 3. In the case of a failed lookup we would access the; memory for ``BUCKETS[3]``, and then compare a few consecutive 32 bit hashes; before we know that we have no match. We don't end up marching through; multiple words of memory and we really keep the number of processor data cache; lines being accessed as small as possible. The string hash that is used for these lookup tables is the Daniel J.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:67019,hash,hash,67019,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"te over an unordered collection, you are; not likely to retrieve elements in the same order they were added to the; collection. The following unordered collections are available:. - **`THashTable`**. - **`TMap`**. ## Iterators: Processing a Collection. The concept of processing all the members of a collection is generic,; i.e. independent of any specific representation of a collection. To; process each object in a collection one needs some type of cursor that; is initialized and then steps over each member of the collection in; turn. Collection objects could provide this service but there is a snag:; as there is only one collection object per collection there would only; be one cursor. Instead, to permit the use of as many cursors as; required, they are made separate classes called iterator. For each; collection class there is an associated iterator class that knows how to; sequentially retrieve each member in turn. The relationship between a; collection and its iterator is very close and may require that the; iterator has full access to the collection (i.e. it is a friend class).; In general iterator will be used via the **`TIter`** wrapper class. For; example:. - **`TList`** **`TListIter`**. - **`TMap`** **`TMapIter`**. ## Foundation Classes. All collections are based on the fundamental classes: **`TCollection`**; and **`TIterator`**. They are so generic that it is not possible to; create objects from them; they are only used as base classes for other; classes (i.e. they are abstract base classes). The **`TCollection`** class provides the basic protocol (i.e. the; minimum set of member functions) that all collection classes have to; implement. These include:. - `Add` `Adds another object to the collection.`. - `GetSize` `Returns the number of objects in the collection.`. - `Clear`; `Clears out the collection, but does not delete the removed objects.`. - `Delete`; `Clears out the collection and deletes the removed objects. This should only `; `be used if the collect",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:6047,access,access,6047,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['access'],['access']
Security,"te symbol; table and debugging information, even if this is later stripped from the binary. This specification uses the ELF Build ID as the sole means of identifying; binaries. Each binary relevant to the log must have been linked with a unique; Build ID. The symbolizing filter must have some means of mapping a Build ID back; to the original ELF binary (either the whole unstripped binary, or a stripped; binary paired with a separate debug file). Colorization; ============. The markup format supports a restricted subset of ANSI X3.64 SGR (Select Graphic; Rendition) control sequences. These are unlike other markup elements:. * They specify presentation details (bold or colors) rather than semantic; information. The association of semantic meaning with color (e.g. red for; errors) is chosen by the code doing the logging, rather than by the UI; presentation of the symbolizing filter. This is a concession to existing code; (e.g. LLVM sanitizer runtimes) that use specific colors and would require; substantial changes to generate semantic markup instead. * A single control sequence changes ""the state"", rather than being an; hierarchical structure that surrounds affected text. The filter processes ANSI SGR control sequences only within a single line. If a; control sequence to enter a bold or color state is encountered, it's expected; that the control sequence to reset to default state will be encountered before; the end of that line. If a ""dangling"" state is left at the end of a line, the; filter may reset to default state for the next line. An SGR control sequence is not interpreted inside any other markup element.; However, other markup elements may appear between SGR control sequences and the; color/bold state is expected to apply to the symbolic output that replaces the; markup element in the filter's output. The accepted SGR control sequences all have the form ``""\033[%um""`` (expressed here; using C string syntax), where ``%u`` is one of these:. ==== ==================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:5046,sanitiz,sanitizer,5046,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['sanitiz'],['sanitizer']
Security,"te vector: LAVector parameters:. -1.82079e-05; -1.20794e-05; 6.22382e-06; -3.0465e-05. minimum internal covariance matrix: LASymMatrix parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607 1 0.547723 8.39663e-18; 0.408248 0.547723 1 9.36796e-18; 1.35011e-18 8.39663e-18 9.36796e-18 1. MnGlobalCorrelationCoeff:. 0.408248; 0.547723; 0.621261; 0. ## CVS code repository ##. How to check out (–in) code from the CVS code repository is described at; the M homepage @bib-C++MINUIT. To get the source code from the CVS; repository one needs to do:. Kerberos IV authorization:. $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit. Anonymous read-only access (if it's enabled by the librarian, see; details):. $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login. (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS; password:cvs. $ cvs co MathLibs/Minuit. (If you want to check out a tagged version SEAL\_x\_x\_x of MINUIT, then; do. $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ). ## Create a tar.gz from CVS ##. Once the sources are checked out from the CVS code repository,. 1. change to the directory:. $ cd MathLibs/Minuit. 2. run autogen:. $ ./autogen. 3. create a new directory:. $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/. 4. run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL projec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:23959,authoriz,authorization,23959,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['authoriz'],['authorization']
Security,"te__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3677,attack,attacks,3677,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,2,"['attack', 'integrity']","['attacks', 'integrity']"
Security,"ted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are veri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68955,sanitiz,sanitized,68955,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['sanitiz'],['sanitized']
Security,"ted. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer lock is one; that allows simultaneous read access by many threads while restricting; write access to only one thread at a time. When any thread holds the; lock for reading, other threads can also acquire the lock reading. If; one thread holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Multithread Safe Levels`** - a possible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within the library. The preferred way of; providing this protection is to use mutex locks. The library also; locks an object before writing to it. The developer is not required; to explicitly lock or unlock a class object (static, global or; local) to perform a single operation on the object. Note that even; multithread safe level II hardly relieves the user",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:23662,access,access,23662,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['access'],['access']
Security,"tended to be used outside of ROOT, including: `gROOTLocal` and related functions, `TSchemaHelper`, `TSchemaMatch`, `TSchemaType`, `RStl`, `ROOT::TROOTAllocator`, `TSchemaRuleProcessor`, `TStdBitsetHelper`, `TInitBehavior`, `TDefaultInitBehavior`, `DefineBehavior`, `THnBaseBrowsable`, `THnBaseBinIter`, `GenericShowMembers`, `TOperatorNewHelper` and `BranchProxy` implementations classes. Several definition where moved from the global or ROOT namespace to the ROOT::Details namespace as they are intended to be used in 'expert' level code and have a lower level of backward compatibility requirement. This includes `TCollectionProxyInfo`, `TSchemaRuleSet`. ## Interpreter. ROOT can now dump the context of STL collections, for instance `map<string,int>`. A few ROOT types print their content, too. Fixed the handling of the current directory in `#include` of system headers, avoid problem with local files named `new` or `vector`. Fixed the issue with the ROOT special variable where the objects were read from the file at each and every access by caching those object. See [ROOT-7830] for example. This release contains several bug fixes and improvements, notably in unloading and performance. > NOTE: The GCC 5 ABI is *not* supported yet, due to a lack of support in clang. ## I/O Libraries. ### hadd. We extended the `hadd` options to allow more control on the compression settings use for the; output file. In particular the new option -fk allows for a copy of the input; files with no decompressions/recompression of the TTree baskets even if they; do not match the requested compression setting. New options:. - `-ff` allows to force the compression setting to match the one from the first input; - `-fk[0-209]` allows to keep all the basket compressed as is and to compress the meta data with the given compression setting or the compression setting of the first input file.; - `-a` option append to existing file; - The verbosity level is now optional after -v. ### Command line utilities. We",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:6475,access,access,6475,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['access'],['access']
Security,"tensions for files to be considered as ""main"". For example, if this option is configured to ``(Impl\.hpp)$``,; then a file ``ClassImpl.hpp`` is considered ""main"" (in addition to; ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and ""main; include file"" logic will be executed (with *IncludeIsMainRegex* setting; also being respected in later phase). Without this option set,; ``ClassImpl.hpp`` would not have the main include file put on top; before any other include. .. _IndentAccessModifiers:. **IndentAccessModifiers** (``Boolean``) :versionbadge:`clang-format 13` :ref:`¶ <IndentAccessModifiers>`; Specify whether access modifiers should have their own indentation level. When ``false``, access modifiers are indented (or outdented) relative to; the record members, respecting the ``AccessModifierOffset``. Record; members are indented one level below the record.; When ``true``, access modifiers get their own indentation level. As a; consequence, record members are always indented 2 levels below the record,; regardless of the access modifier presence. Value of the; ``AccessModifierOffset`` is ignored. .. code-block:: c++. false: true:; class C { vs. class C {; class D { class D {; void bar(); void bar();; protected: protected:; D(); D();; }; };; public: public:; C(); C();; }; };; void foo() { void foo() {; return 1; return 1;; } }. .. _IndentCaseBlocks:. **IndentCaseBlocks** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <IndentCaseBlocks>`; Indent case label blocks one level from the case label. When ``false``, the block following the case label uses the same; indentation level as for the case label, treating the case label the same; as an if-statement.; When ``true``, the block gets indented as a scope block. .. code-block:: c++. false: true:; switch (fool) { vs. switch (fool) {; case 1: { case 1:; bar(); {; } break; bar();; default: { }; plop(); break;; } default:; } {; plop();; }; }. .. _IndentCaseLabels:. **IndentCaseLabels** (``Boolean``) :versionbadge:`cla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:70247,access,access,70247,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['access'],['access']
Security,"tensions. If you specify a directory, the; files are expected in that directory with the same base name as the source; file. .. option:: -p, --preserve-paths. Preserve path components when naming the coverage output files. In addition; to the source file name, include the directories from the path to that; file. The directories are separate by ``#`` characters, with ``.`` directories; removed and ``..`` directories replaced by ``^`` characters. When used with; the --long-file-names option, this applies to both the main file name and the; included file name. .. option:: -r. Only dump files with relative paths or absolute paths with the prefix specified; by ``-s``. .. option:: -s <string>. Source prefix to elide. .. option:: -t, --stdout. Print to stdout instead of producing ``.gcov`` files. .. option:: -u, --unconditional-branches. Include unconditional branches in the output for the --branch-probabilities; option. .. option:: -version. Display the version of llvm-cov. .. option:: -x, --hash-filenames. Use md5 hash of file name when naming the coverage output files. The source; file name will be suffixed by ``##`` followed by MD5 hash calculated for it. EXIT STATUS; ^^^^^^^^^^^. :program:`llvm-cov gcov` returns 1 if it cannot read input files. Otherwise,; it exits with zero. .. program:: llvm-cov show. .. _llvm-cov-show:. SHOW COMMAND; ------------. SYNOPSIS; ^^^^^^^^. :program:`llvm-cov show` [*options*] -instr-profile *PROFILE* [*BIN*] [*-object BIN*]... [*-sources*] [*SOURCE*]... DESCRIPTION; ^^^^^^^^^^^. The :program:`llvm-cov show` command shows line by line coverage of the; binaries *BIN*... using the profile data *PROFILE*. It can optionally be; filtered to only show the coverage for the files listed in *SOURCE*.... *BIN* may be an executable, object file, dynamic library, or archive (thin or; otherwise). To use :program:`llvm-cov show`, you need a program that is compiled with; instrumentation to emit profile and coverage data. To build such a program with; ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst:5966,hash,hash-filenames,5966,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,1,['hash'],['hash-filenames']
Security,"ter group record frame references the page list envelopes for groups of clusters.; A cluster group record frame has the following contents followed by a page list envelope link. ```; 0 1 2 3; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | |; + Minimum Entry Number +; | |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | |; + Entry Span +; | |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | Number of clusters |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; ```. To compute the minimum entry number, take first entry number from all clusters in the cluster group,; and take the minimum among these numbers.; The entry span is the number of entries that are covered by this cluster group.; The entry range allows for finding the right page list for random access requests to entries.; The number of clusters information allows for using consistent cluster IDs; even if cluster groups are accessed non-sequentially. ### Page List Envelope. The page list envelope contains cluster summaries and page locations.; It has the following structure. - Header checksum (XxHash-3 64bit); - List frame of cluster summary record frames; - Nested list frame of page locations. #### Cluster Summary Record Frame; The cluster summary record frame contains the entry range of a cluster:. ```; 0 1 2 3; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | |; + First Entry Number +; | |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | Number of Entries |; + +-+-+-+-+-+-+-+-+; | | Flags |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; ```. The order of the cluster summaries defines the cluster IDs,; starting from the first cluster ID of the cluster group that corresponds to the page list. Flag 0x01 is reserved for a future specification ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:31892,access,accessed,31892,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['access'],['accessed']
Security,"ter to the Minimizer and Objective function of the last fit. The objective function depends on a reference to the data and the model function, therefore the objective function pointer is valid as far the data and the model function are maintained alive.; ; The library provides the implementation of standard objective function like the Chi2 function, the Poisson likelihood function (for binned likelihood fits) and the loh likelihood function (for unbinned fits). These standard objective functions can be created with or without gradient functionality. In the first case the minimization will be performed using the gradient provided by the function. These functions can also be used in specialized fitting methods like Fumili or the GSL non-linear least square.; . MathCore. Fixed a bug in setting the VEGAS integration mode in the GSLMCIntegrator class.; . Fumili. Add implementation of Minimizer interface using TFumili.; ; Minuit. In TMinuitMinimizer: do not delete the contained TMinuit reference, but maintain it alive, and accessible outside as gMinuit. It can then be used after fitting, for example for drawing contour plots. Add also support for Scan and Contour plots.; ; TLinearMinimizer: add support for robust fitting; . Minuit2. Add support to perform parallel minimization using a thread for each gradient calculation with openMP. In the ROOT environment the Minuit2 library can be built using openMP ( -fopenmp compilation flag for gcc) if the environment variables USE_PARALLEL_MINUIT2 and USE_OPENMP are set.; In the Minuit2 standalone built libraries (using autoconf) support for openMP is automatically enabled, whenever the compiler supports it (for example for gcc version >= 4.2). Some small changes have been applied in Minuit2 to make it thread safe. For example, when transforming from internal to external values, the parameter values are not cached anymore in MnUserTransformation class.; DavidonErrorUpdator: add an additional check to avoid a division by zero.; In M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html:2881,access,accessible,2881,math/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html,1,['access'],['accessible']
Security,"terType::get()`` and similar APIs are automatically converted into; opaque pointers. This simplifies migration and allows testing existing IR with; opaque pointers. .. code-block:: llvm. define i8* @test(i8* %p) {; %p2 = getelementptr i8, i8* %p, i64 1; ret i8* %p2; }. ; Is automatically converted into the following if -opaque-pointers; ; is enabled:. define ptr @test(ptr %p) {; %p2 = getelementptr i8, ptr %p, i64 1; ret ptr %p2; }. Migration Instructions; ======================. In order to support opaque pointers, two types of changes tend to be necessary.; The first is the removal of all calls to ``PointerType::getElementType()`` and; ``Type::getPointerElementType()``. In the LLVM middle-end and backend, this is usually accomplished by inspecting; the type of relevant operations instead. For example, memory access related; analyses and optimizations should use the types encoded in the load and store; instructions instead of querying the pointer type. Here are some common ways to avoid pointer element type accesses:. * For loads, use ``getType()``.; * For stores, use ``getValueOperand()->getType()``.; * Use ``getLoadStoreType()`` to handle both of the above in one call.; * For getelementptr instructions, use ``getSourceElementType()``.; * For calls, use ``getFunctionType()``.; * For allocas, use ``getAllocatedType()``.; * For globals, use ``getValueType()``.; * For consistency assertions, use; ``PointerType::isOpaqueOrPointeeTypeEquals()``.; * To create a pointer type in a different address space, use; ``PointerType::getWithSamePointeeType()``.; * To check that two pointers have the same element type, use; ``PointerType::hasSameElementTypeAs()``.; * While it is preferred to write code in a way that accepts both typed and; opaque pointers, ``Type::isOpaquePointerTy()`` and; ``PointerType::isOpaque()`` can be used to handle opaque pointers specially.; ``PointerType::getNonOpaquePointerElementType()`` can be used as a marker in; code-paths where opaque pointers have b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:6809,access,accesses,6809,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['access'],['accesses']
Security,"terate over a subrange of entries. Each subrange corresponds to a cluster in the TTree and is processed by a task, which can potentially be run in parallel with other tasks.; * Add a new implementation of a RW lock, `ROOT::TRWSpinLock`, which is based on a `ROOT::TSpinMutex`. `TRWSpinLock` tries to make faster the scenario when readers come and go but there is no writer, while still preventing starvation of writers. ## I/O Libraries. * Support I/O of `std::unique_ptr`s and STL collections thereof.; * Support I/O of `std::array`.; * Support I/O of `std::tuple`. The dictionary for those is never auto generated and thus requires explicit request of the dictionary for each std::tuple class template instantiation used, like most other class templates.; * Custom streamers need to #include TBuffer.h explicitly (see [section Core Libraries](#core-libs)); * Check and flag short reads as errors in the xroot plugins. This fixes [ROOT-3341].; * Added support for AWS temporary security credentials to TS3WebFile by allowing the security token to be given.; * Resolve an issue when space is freed in a large `ROOT` file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file [ROOT-8055]. - ##### TBufferJSON:; + support data members with `//[fN]` comment; + preliminary support of STL containers; + JSON data can be produced with `TObject::SaveAs()` method. ## TTree Libraries. * TChains can now be histogrammed without any C++ code, using the command line tool `rootdrawtree`. It is based on the new class `TSimpleAnalysis`.; * Do not automatically setup read cache during `TTree::Fill()`. This fixes [ROOT-8031].; * Make sure the option ""PARA"" in `TTree::Draw` is used with at least tow variables [ROOT-8196].; * The with `goff` option one can use as many variables as needed. There no more; limitation, like with the options `para`and `candle`.; * Fix detection of errors that appears in nested TTreeFormula [ROOT-8218]; * Better basket size optimization by ta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:8325,secur,security,8325,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,2,['secur'],['security']
Security,"terator op_end()`` - Get an iterator to the end of the operand list. Together, these methods make up the iterator based interface to the operands; of a ``User``. .. _Instruction:. The ``Instruction`` class; -------------------------. ``#include ""llvm/IR/Instruction.h""``. header source: `Instruction.h; <https://llvm.org/doxygen/Instruction_8h_source.html>`_. doxygen info: `Instruction Class; <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_. Superclasses: User_, Value_. The ``Instruction`` class is the common base class for all LLVM instructions.; It provides only a few methods, but is a very commonly used class. The primary; data tracked by the ``Instruction`` class itself is the opcode (instruction; type) and the parent BasicBlock_ the ``Instruction`` is embedded into. To; represent a specific type of instruction, one of many subclasses of; ``Instruction`` are used. Because the ``Instruction`` class subclasses the User_ class, its operands can; be accessed in the same way as for other ``User``\ s (with the; ``getOperand()``/``getNumOperands()`` and ``op_begin()``/``op_end()`` methods).; An important file for the ``Instruction`` class is the ``llvm/Instruction.def``; file. This file contains some meta-data about the various different types of; instructions in LLVM. It describes the enum values that are used as opcodes; (for example ``Instruction::Add`` and ``Instruction::ICmp``), as well as the; concrete sub-classes of ``Instruction`` that implement the instruction (for; example BinaryOperator_ and CmpInst_). Unfortunately, the use of macros in this; file confuses doxygen, so these enum values don't show up correctly in the; `doxygen output <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_. .. _s_Instruction:. Important Subclasses of the ``Instruction`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. _BinaryOperator:. * ``BinaryOperator``. This subclasses represents all two operand instructions whose operands must be; the same type, ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:146981,access,accessed,146981,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['accessed']
Security,"tes are used to spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU the kernarg backing memory is allocated in host memory accessed as; MTYPE UC (uncached) to avoid needing to invalidate the L2 cache. This also; causes it to be treated as non-volatile and so is not invalidated by; ``*_vol``.; * On APU the kernarg backing memory it is accessed as MTYPE CC (cache coherent); and so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX6-GFX9 are defined; in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table`. .. table:: AMDHSA Memory Model Code Sequences GFX6-GFX9; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table. ============ ============ ============== ========== ================================; LLVM Instr LLVM Memory LLVM Memory AMDGPU AMDGPU Machine Code; Ordering Sync Scope Address GFX6-GFX9; Space; ============ ============ ============== ========== =",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:210852,access,accessed,210852,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"tes locked and unlocked. A mutex is usually used to ensure; that only one thread at a time executes some critical section of code.; Before entering a critical section, a thread will attempt to lock the; mutex, which guards that section. If the mutex is already locked, the; thread will block until the mutex is unlocked, at which time it will; lock the mutex, execute the critical section, and unlock the mutex upon; leaving the critical section. A **`semaphore`** is a synchronization mechanism that starts out; initialized to some positive value. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continues. When a thread releases semaphore, the; semaphore count is incremented. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer lock is one; that allows simultaneous read access by many threads while restricting; write access to only one thread at a time. When any thread holds the; lock for reading, other threads can also acquire the lock reading. If; one thread holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Multithread Safe Levels`** - a possible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:22865,access,access,22865,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,2,['access'],['access']
Security,"tes. For example:. .. code-block:: c++. AliasResult alias(const Value *V1, unsigned V1Size,; const Value *V2, unsigned V2Size) {; if (...); return NoAlias;; ... // Couldn't determine a must or no-alias result.; return AliasAnalysis::alias(V1, V1Size, V2, V2Size);; }. In addition to analysis queries, you must make sure to unconditionally pass LLVM; `update notification`_ methods to the superclass as well if you override them,; which allows all alias analyses in a change to be updated. .. _update notification:. Updating analysis results for transformations; ---------------------------------------------. Alias analysis information is initially computed for a static snapshot of the; program, but clients will use this information to make transformations to the; code. All but the most trivial forms of alias analysis will need to have their; analysis results updated to reflect the changes made by these transformations. The ``AliasAnalysis`` interface exposes four methods which are used to; communicate program changes from the clients to the analysis implementations.; Various alias analysis implementations should use these methods to ensure that; their internal data structures are kept up-to-date as the program changes (for; example, when an instruction is deleted), and clients of alias analysis must be; sure to call these interfaces appropriately. The ``deleteValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``deleteValue`` method is called by transformations when they remove an; instruction or any other value from the program (including values that do not; use pointers). Typically alias analyses keep data structures that have entries; for each value in the program. When this method is called, they should remove; any entries for the specified value, if they exist. The ``copyValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^. The ``copyValue`` method is used when a new value is introduced into the; program. There is no way to introduce a value into the program that did not; exist befor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:14093,expose,exposes,14093,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['expose'],['exposes']
Security,"tf(""INIT: %p %p\n"", start, stop);; for (uint32_t *x = start; x < stop; x++); *x = ++N; // Guards should start from 1.; }. // This callback is inserted by the compiler on every edge in the; // control flow (some optimizations apply).; // Typically, the compiler will emit the code like this:; // if(*guard); // __sanitizer_cov_trace_pc_guard(guard);; // But for large functions it will emit a simple call:; // __sanitizer_cov_trace_pc_guard(guard);; extern ""C"" void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {; if (!*guard) return; // Duplicate the guard check.; // If you set *guard to 0 this code will not be called again for this edge.; // Now you can get the PC and do whatever you want:; // store it somewhere or symbolize it and print right away.; // The values of `*guard` are as you set them in; // __sanitizer_cov_trace_pc_guard_init and so you can make them consecutive; // and use them to dereference an array or a bit vector.; void *PC = __builtin_return_address(0);; char PcDescr[1024];; // This function is a part of the sanitizer run-time.; // To use it, link with AddressSanitizer or other sanitizer.; __sanitizer_symbolize_pc(PC, ""%p %F %L"", PcDescr, sizeof(PcDescr));; printf(""guard: %p %x PC %s\n"", guard, *guard, PcDescr);; }. .. code-block:: c++. // trace-pc-guard-example.cc; void foo() { }; int main(int argc, char **argv) {; if (argc > 1) foo();; }. .. code-block:: console. clang++ -g -fsanitize-coverage=trace-pc-guard trace-pc-guard-example.cc -c; clang++ trace-pc-guard-cb.cc trace-pc-guard-example.o -fsanitize=address; ASAN_OPTIONS=strip_path_prefix=`pwd`/ ./a.out. .. code-block:: console. INIT: 0x71bcd0 0x71bce0; guard: 0x71bcd4 2 PC 0x4ecd5b in main trace-pc-guard-example.cc:2; guard: 0x71bcd8 3 PC 0x4ecd9e in main trace-pc-guard-example.cc:3:7. .. code-block:: console. ASAN_OPTIONS=strip_path_prefix=`pwd`/ ./a.out with-foo. .. code-block:: console. INIT: 0x71bcd0 0x71bce0; guard: 0x71bcd4 2 PC 0x4ecd5b in main trace-pc-guard-example.cc:3; guard: 0x71bcdc ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:3079,sanitiz,sanitizer,3079,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['sanitiz'],['sanitizer']
Security,"th 32-bit and 64-bit object files.; any; Process all the supported object files. On AIX OS, the default is to process 32-bit object files only and to ignore; 64-bit objects. The can be changed by setting the OBJECT_MODE environment; variable. For example, OBJECT_MODE=64 causes :program:`llvm-nm` to process; 64-bit objects and ignore 32-bit objects. The -X flag overrides the OBJECT_MODE; variable. On other operating systems, the default is to process all object files: the; OBJECT_MODE environment variable is not supported. .. option:: --debug-syms, -a. Show all symbols, even those usually suppressed. .. option:: --defined-only, -U. Print only symbols defined in this file. .. option:: --demangle, -C. Demangle symbol names. .. option:: --dynamic, -D. Display dynamic symbols instead of normal symbols. .. option:: --export-symbols. Print sorted symbols with their visibility (if applicable), with duplicates; removed. .. option:: --extern-only, -g. Print only symbols whose definitions are external; that is, accessible from; other files. .. option:: --format=<format>, -f. Select an output format; *format* may be *sysv*, *posix*, *darwin*, *bsd* or; *just-symbols*.; The default is *bsd*. .. option:: --help, -h. Print a summary of command-line options and their meanings. .. option:: -j. Print just the symbol names. Alias for `--format=just-symbols``. .. option:: --line-numbers, -l. Use debugging information to print the filenames and line numbers where; symbols are defined. Undefined symbols have the location of their first; relocation printed instead. .. option:: -m. Use Darwin format. Alias for ``--format=darwin``. .. option:: --no-demangle. Don't demangle symbol names. This is the default. .. option:: --no-llvm-bc. Disable the LLVM bitcode reader. .. option:: --no-sort, -p. Show symbols in the order encountered. .. option:: --no-weak, -W. Don't print weak symbols. .. option:: --numeric-sort, -n, -v. Sort symbols by address. .. option:: --portability, -P. Use POSIX.2 output",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst:4336,access,accessible,4336,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst,1,['access'],['accessible']
Security,"th 4 pixels; distance in between, the `Help` menu - will be laid out to the right. The menu classes provide a very flexible menu system: you can enable,; disable, add or remove menu items dynamically. The method; `HideEntry(menuID)` hides the menu entry (the entry will not be shown in; the popup menu). To enable a hidden entry you should call; `EnableEntry(menuID)` method. By default all entries are enabled. The; method `DisableEntry(menuID)` helps you to disable a menu entry - it; will appear in sunken relieve. The `DeleteEntry(menuID)` method will; delete the specified entry from the menu. A few words about the menu design. A menu should be kept consistent and; simple. All related items need to be in a popup menu. The cascade menus; should be used judiciously. Try to limit them to one, maximum two; levels. There are some rules for naming the menu objects:. - Define unique names within a menu. - Use capitalized one-word names allowing the quick scan of the menu. - Define unique access key for any menu item. - Indicate by ellipsis (...) after the title with no space when a menu; item will pop-up a dialog box. The proper kind of graphical menus is a critical point to every; application success and depends of three main factors:. - number of presented items in the menu. - how often the menu is used. - how often the menu contents may change. ### Toolbar. ![](pictures/03000217.png). A toolbar (**`TGToolBar`**) is a composite frame that contains; **`TGPictureButton `**objects. It provides an easy and fast access to; most frequently used commands or options across multiple application; screens. Also, it invokes easily a sub application within an; application. All its functions can be obtained by application menus. It; is located horizontally at the top of the main window just below the; menu bar. All other subtask and sub-feature bars are positioned along; sides of window. ``` {.cpp}; // toolbar icon files; const char *xpms[] = {; ""x_pic.xpm"",; ""y_pic.xpm"",; ""z_pic.xpm"",;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:73754,access,access,73754,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['access'],['access']
Security,"th caution. The; guarantees in terms of synchronization are very weak, so make sure these are; only used in a pattern which you know is correct. Generally, these would; either be used for atomic operations which do not protect other memory (like; an atomic counter), or along with a ``fence``. Notes for optimizers; In terms of the optimizer, this can be treated as a read+write on the relevant; memory location (and alias analysis will take advantage of that). In addition,; it is legal to reorder non-atomic and Unordered loads around Monotonic; loads. CSE/DSE and a few other optimizations are allowed, but Monotonic; operations are unlikely to be used in ways which would make those; optimizations useful. Notes for code generation; Code generation is essentially the same as that for unordered for loads and; stores. No fences are required. ``cmpxchg`` and ``atomicrmw`` are required; to appear as a single operation. Acquire; -------. Acquire provides a barrier of the sort necessary to acquire a lock to access; other memory with normal loads and stores. Relevant standard; This corresponds to the C++/C ``memory_order_acquire``. It should also be; used for C++/C ``memory_order_consume``. Notes for frontends; If you are writing a frontend which uses this directly, use with caution.; Acquire only provides a semantic guarantee when paired with a Release; operation. Notes for optimizers; Optimizers not aware of atomics can treat this like a nothrow call. It is; also possible to move stores from before an Acquire load or read-modify-write; operation to after it, and move non-Acquire loads from before an Acquire; operation to after it. Notes for code generation; Architectures with weak memory ordering (essentially everything relevant today; except x86 and SPARC) require some sort of fence to maintain the Acquire; semantics. The precise fences required varies widely by architecture, but for; a simple implementation, most architectures provide a barrier which is strong; enough for eve",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:11540,access,access,11540,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['access'],['access']
Security,"that can be used.; Instead of each debug level being its own switch, we want to support the; following options, of which only one can be specified at a time:; ""``--debug-level=none``"", ""``--debug-level=quick``"",; ""``--debug-level=detailed``"". To do this, we use the exact same format as our; optimization level flags, but we also specify an option name. For this case,; the code looks like this:. .. code-block:: c++. enum DebugLev {; nodebuginfo, quick, detailed; };. // Enable Debug Options to be specified on the command line; cl::opt<DebugLev> DebugLevel(""debug_level"", cl::desc(""Set the debugging level:""),; cl::values(; clEnumValN(nodebuginfo, ""none"", ""disable debug information""),; clEnumVal(quick, ""enable quick debug information""),; clEnumVal(detailed, ""enable detailed debug information"")));. This definition defines an enumerated command line variable of type ""``enum; DebugLev``"", which works exactly the same way as before. The difference here is; just the interface exposed to the user of your program and the help output by; the ""``-help``"" option:. ::. USAGE: compiler [options] <input file>. OPTIONS:; Choose optimization level:; -g - No optimizations, enable debugging; -O1 - Enable trivial optimizations; -O2 - Enable default optimizations; -O3 - Enable expensive optimizations; -debug_level - Set the debugging level:; =none - disable debug information; =quick - enable quick debug information; =detailed - enable detailed debug information; -f - Enable binary output on terminals; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename; -quiet - Don't print informational messages. Again, the only structural difference between the debug level declaration and; the optimization level declaration is that the debug level declaration includes; an option name (``""debug_level""``), which automatically changes how the library; processes the argument. The CommandLine library supports both forms so that you; can choose the form most approp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:18007,expose,exposed,18007,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['expose'],['exposed']
Security,"the ""one's; complement"" operation, which is the ""~"" operator in C. Arguments:; """""""""""""""""""". The two arguments to the '``xor``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". The truth table used for the '``xor``' instruction is:. +-----+-----+-----+; | In0 | In1 | Out |; +-----+-----+-----+; | 0 | 0 | 0 |; +-----+-----+-----+; | 0 | 1 | 1 |; +-----+-----+-----+; | 1 | 0 | 1 |; +-----+-----+-----+; | 1 | 1 | 0 |; +-----+-----+-----+. Example:; """""""""""""""". .. code-block:: text. <result> = xor i32 4, %var ; yields i32:result = 4 ^ %var; <result> = xor i32 15, 40 ; yields i32:result = 39; <result> = xor i32 4, 8 ; yields i32:result = 12; <result> = xor i32 %V, -1 ; yields i32:result = ~%V. Vector Operations; -----------------. LLVM supports several instructions to represent vector operations in a; target-independent manner. These instructions cover the element-access; and vector-specific operations needed to process vectors effectively.; While LLVM does directly support these vector operations, many; sophisticated algorithms will want to use target-specific intrinsics to; take full advantage of a specific target. .. _i_extractelement:. '``extractelement``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = extractelement <n x <ty>> <val>, <ty2> <idx> ; yields <ty>; <result> = extractelement <vscale x n x <ty>> <val>, <ty2> <idx> ; yields <ty>. Overview:; """""""""""""""""". The '``extractelement``' instruction extracts a single scalar element; from a vector at a specified index. Arguments:; """""""""""""""""""". The first operand of an '``extractelement``' instruction is a value of; :ref:`vector <t_vector>` type. The second operand is an index indicating; the position from which to extract the element. The index may be a; variable of any integer type, and will be treated as an unsigned integer. Semantics:; """""""""""""""""""". The result is a scalar of the sam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:400604,access,access,400604,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"the array-to-pointer conversion applied?; Unknown. 702; CD2; Preferring conversion to std::initializer_list; Unknown. 703; CD2; Narrowing for literals that cannot be exactly represented; Unknown. 704; CD2; To which postfix-expressions does overload resolution apply?; Unknown. 705; CD2; Suppressing argument-dependent lookup via parentheses; Yes. 706; NAD; Use of auto with rvalue references; Unknown. 707; CD2; Undefined behavior in integral-to-floating conversions; Unknown. 708; open; Partial specialization of member templates of class templates; Not resolved. 709; C++11; Enumeration names as nested-name-specifiers in deduction failure; Unknown. 710; CD2; Data races during construction; Unknown. 711; CD2; auto with braced-init-list; Unknown. 712; CD3; Are integer constant operands of a conditional-expression “used?”; Partial. 713; CD2; Unclear note about cv-qualified function types; Unknown. 714; CD2; Static const data members and braced-init-lists; Unknown. 715; CD2; Class member access constant expressions; Unknown. 716; CD2; Specifications that should apply only to non-static union data members; Unknown. 717; CD2; Unintentional restrictions on the use of thread_local; Unknown. 718; NAD; Non-class, non-function friend declarations; Unknown. 719; CD2; Specifications for operator-function-id that should also apply to literal-operator-id; Unknown. 720; CD2; Need examples of lambda-expressions; Unknown. 721; CD2; Where must a variable be initialized to be used in a constant expression?; Unknown. 722; CD2; Can nullptr be passed to an ellipsis?; Unknown. 726; CD2; Atomic and non-atomic objects in the memory model; Unknown. 727; C++17; In-class explicit specializations; Partial. 728; NAD; Restrictions on local classes; Unknown. 729; CD3; Qualification conversions and handlers of reference-to-pointer type; Unknown. 730; CD2; Explicit specializations of members of non-template classes; Unknown. 731; CD2; Omitted reference qualification of member function type; Unknown. 732; C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:49149,access,access,49149,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['access'],['access']
Security,"the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits of the mask are on, the intrinsic is identical to a regular vector load or store. When all bits are off, no memory is accessed. .. _int_mload:. '``llvm.masked.load.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data is a vector of any integer, floating-point or pointer data type. ::. declare <16 x float> @llvm.masked.load.v16f32.p0(ptr <ptr>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.load.v2f64.p0(ptr <ptr>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); ;; The data is a vector of pointers; declare <8 x ptr> @llvm.masked.load.v8p0.p0(ptr <ptr>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads a vector from memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. The second operand is the alignment of the source location. It must be a power of two constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the base pointer and the type of the '``passthru``' operand are the same vector types. Semantics:; """""""""""""""""""". The '``llvm.masked.load``' intrinsic is designed for conditional reading of selected vector elements in a single IR operation. It is useful for targets that support vector masked loads and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differentl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:843883,access,accesses,843883,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accesses']
Security,"the backend so that it generates; code for the proper architecture. It's possible to override this on the; command line with the ``-mtriple`` command line option. .. _objectlifetime:. Object Lifetime; ----------------------. A memory object, or simply object, is a region of a memory space that is; reserved by a memory allocation such as :ref:`alloca <i_alloca>`, heap; allocation calls, and global variable definitions.; Once it is allocated, the bytes stored in the region can only be read or written; through a pointer that is :ref:`based on <pointeraliasing>` the allocation; value.; If a pointer that is not based on the object tries to read or write to the; object, it is undefined behavior. A lifetime of a memory object is a property that decides its accessibility.; Unless stated otherwise, a memory object is alive since its allocation, and; dead after its deallocation.; It is undefined behavior to access a memory object that isn't alive, but; operations that don't dereference it such as; :ref:`getelementptr <i_getelementptr>`, :ref:`ptrtoint <i_ptrtoint>` and; :ref:`icmp <i_icmp>` return a valid result.; This explains code motion of these instructions across operations that; impact the object's lifetime.; A stack object's lifetime can be explicitly specified using; :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` intrinsic function calls. .. _pointeraliasing:. Pointer Aliasing Rules; ----------------------. Any memory access must be done through a pointer value associated with; an address range of the memory access, otherwise the behavior is; undefined. Pointer values are associated with address ranges according; to the following rules:. - A pointer value is associated with the addresses associated with any; value it is *based* on.; - An address of a global variable is associated with the address range; of the variable's storage.; - The result value of an allocation instruction is associated with the; address range of the allocat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:140825,access,access,140825,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"the client side,; but does not wait that real update is completed. Avoids blocking of caller thread.; Have to be used if called from other web-based widget to avoid logical dead-locks.; In case of normal canvas just canvas->Update() is performed. - The Delaunay triangles (used by TGraph2D) were computed by the external package `triangle.c`; included in the ROOT distribution. This package had several issues:; - It was not maintained anymore.; - Its license was not compatible with LGPL; This code is now replaced by the [CDT package](https://github.com/artem-ogre/CDT) which is; properly maintained and has a license (MLP) compatible with LGPL. It will appear in 6.03.02. ## Machine Learning integration. - ROOT now offers functionality to extract batches of events out of a dataset for use in common ML training workflows. For example, one can generate PyTorch tensors from a TTree. The functionality is available through the `RBatchGenerator` class and can be seamlessly integrated in user code, for example:; ```python; # Returns two generators that return training and validation batches as PyTorch tensors.; gen_train, gen_validation = ROOT.TMVA.Experimental.CreatePyTorchGenerators(; tree_name, file_name, batch_size, chunk_size, target=target, validation_split=0.3); ```; The functionality is also available for TensorFlow datasets and Python generators of numpy arrays. See more in the `RBatchGenerator*` tutorials under the TMVA folder. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. - The default `TCanvas` and `TBrowser` is switched back to the traditional look. (`--web=off` is no longer needed). ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - The traditional versioning convention of ROOT (e.g. 6.28/10) has been changed to standard semantic versioning (6.28.10), i.e. the slash is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:21053,validat,validation,21053,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['validat'],['validation']
Security,"the cluster pool is instructed to not read beyond the given limit.; This is used in the RNTuple data source when multiple threads work on different clusters of the same file. ### RMiniFile; The RMiniFile is an internal class used to read and write RNTuple data in a ROOT file.; It provides a minimal subset of the `TFile` functionality.; Its purpose is to reduce the coupling between RNTuple and the ROOT I/O library. For writing data, the RMiniFile can either use a proper `TFile` (descendant) or a C file stream (only for new ROOT files with a single RNTuple).; For reading, the `RMiniFile` always uses an `RRawFile`. ### RRawFile; The RRawFile internal abstract class provides an interface to read byte ranges from a file, including vector reads.; Concrete implementations exist for local files, XRootD and HTTP (the latter two through the ROOT plugin mechanism).; The local file implementation on Linux uses uring for vector reads, if available.; `RRawFileTFile` wraps an existing `TFile` and provides access to the full set of implementations, e.g. `TMemFile`. Tooling; -------. ### RNTupleMerger; The `RNTupleMerger` is an internal class and part of the core RNTuple library.; It concatenates RNTuple data from several sources into a combined sink.; It implements ""fast merging"", i.e. copy-based merging that does not decompress and recompress pages.; The RNTupler merger is used by the `TFileMerger` and thus provides RNTuple merge support in `hadd` and `TBufferMerger`. ### RNTupleImporter; The RNTupleImporter creates RNTuple data sets from ROOT trees.; It is part of the `ROOTNTupleUtil` library. ### RNTupleInspector; The RNTupleInspector provides insights of an RNTuple, e.g. the distribution of data volume wrt. column types.; It is part of the `ROOTNTupleUtil` library. Ownership Model; ---------------. By default, objects involved in RNTuple I/O (objects read from disk or written to disk) are passed to RNTuple as shared pointers.; Both RNTuple or the application may create the obje",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:16300,access,access,16300,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['access'],['access']
Security,"the main one provides all functionality being; linked with the underlying ROOT visualization system. This library is; dynamically loaded by the plug-in manager only when drawing features are; requested. The geometrical structures that can be visualized are volumes; and volume hierarchies. The main component of the visualization system is volume primitive; painting in a ROOT pad. Starting from this one, several specific options; or subsystems are available, like: X3D viewing using hidden line and; surface removal algorithms, OpenGL viewing\* or ray tracing. The method TGeoManager::GetGeomPainter() loads the painting library in; memory. This is generally not needed since it is called automatically by; TGeoVolume::Draw() as well as by few other methods setting; visualization attributes. \anchor GP04a; ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ~~~{.cpp}; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; ~~~. Doing this ensures that the original top-level volume of the geometry is; drawn, even if another volume is currently the geometry `root`. OK, I; suppose you already did that with your simple geometry and immediately; noticed a new ROOT canvas popping-up and having some more or less; strange picture inside. Here are few questions that might come:. **Q:** ""The picture is strangely rotated; where are the coordinate axes?"". **A:** If drawn in a new canvas, any view has some default; viewpoint, center of view and size. One can then perform mouse/keyboard; actions to change them:. - Mouse left-click and drag will rotate the view;. - Some keys can be pressed when the view canvas is selected: J/K; zoom/un-zoom, U",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:98049,validat,validation,98049,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['validat'],['validation']
Security,"the new API ``ensureOptimizedUses()`` to keep the previous behavior and do a; one-time optimization of ``MemoryUse``\ s, if this was not done before.; New pass users are recommended to call ``ensureOptimizedUses()``. Initially it was not possible to optimize ``MemoryDef``\ s in the same way, as we; restricted ``MemorySSA`` to one operand per access.; This was changed and ``MemoryDef``\ s now keep two operands.; The first one, the defining access, is; always the previous ``MemoryDef`` or ``MemoryPhi`` in the same basic block, or; the last one in a dominating predecessor if the current block doesn't have any; other accesses writing to memory. This is needed for walking Def chains.; The second operand is the optimized access, if there was a previous call on the; walker's ``getClobberingMemoryAccess(MA)``. This API will cache information; as part of ``MA``.; Optimizing all ``MemoryDef``\ s has quadratic time complexity and is not done; by default. A walk of the uses for any MemoryDef can find the accesses that were optimized; to it.; A code snippet for such a walk looks like this:. .. code-block:: c++. MemoryDef *Def; // find who's optimized or defining for this MemoryDef; for (auto& U : Def->uses()) {; MemoryAccess *MA = cast<MemoryAccess>(Use.getUser());; if (auto *DefUser = cast_of_null<MemoryDef>MA); if (DefUser->isOptimized() && DefUser->getOptimized() == Def) {; // User who is optimized to Def; } else {; // User who's defining access is Def; optimized to something else or not optimized.; }; }. When ``MemoryUse``\ s are optimized, for a given store, you can find all loads; clobbered by that store by walking the immediate and transitive uses of; the store. .. code-block:: c++. checkUses(MemoryAccess *Def) { // Def can be a MemoryDef or a MemoryPhi.; for (auto& U : Def->uses()) {; MemoryAccess *MA = cast<MemoryAccess>(Use.getUser());; if (auto *MU = cast_of_null<MemoryUse>MA) {; // Process MemoryUse as needed.; }; else {; // Process MemoryDef or MemoryPhi as needed. /",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:12774,access,accesses,12774,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['access'],['accesses']
Security,"the object, unless the object is managed; outside of LLVM. The underlying integer computation is sufficiently defined; null has a defined; value --- zero --- and you can add whatever value you want to it. However, it's invalid to access (load from or store to) an LLVM-aware object; with such a pointer. This includes ``GlobalVariables``, ``Allocas``, and objects; pointed to by noalias pointers. If you really need this functionality, you can do the arithmetic with explicit; integer instructions, and use inttoptr to convert the result to an address. Most; of GEP's special aliasing rules do not apply to pointers computed from ptrtoint,; arithmetic, and inttoptr sequences. Can I compute the distance between two objects, and add that value to one address to compute the other address?; ---------------------------------------------------------------------------------------------------------------. As with arithmetic on null, you can use GEP to compute an address that way, but; you can't use that pointer to actually access the object if you do, unless the; object is managed outside of LLVM. Also as above, ptrtoint and inttoptr provide an alternative way to do this which; do not have this restriction. Can I do type-based alias analysis on LLVM IR?; ----------------------------------------------. You can't do type-based alias analysis using LLVM's built-in type system,; because LLVM has no restrictions on mixing types in addressing, loads or stores. LLVM's type-based alias analysis pass uses metadata to describe a different type; system (such as the C type system), and performs type-based aliasing on top of; that. Further details are in the; `language reference <LangRef.html#tbaa-metadata>`_. What happens if a GEP computation overflows?; --------------------------------------------. If the GEP lacks the ``inbounds`` keyword, the value is the result from; evaluating the implied two's complement integer computation. However, since; there's no guarantee of where an object will be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:16633,access,access,16633,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['access'],['access']
Security,"the pointer beyond the; terminator is not allowed. This is a generalization of ``__null_terminated``; which is defined as ``__terminated_by(0)``. Annotation for interoperating with bounds-unsafe code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A pointer with the ``__unsafe_indexable`` annotation behaves the same as a plain; C pointer. That is, the pointer does not have any bounds information and pointer; operations are not checked. ``__unsafe_indexable`` can be used to mark pointers from system headers or; pointers from code that has not adopted -fbounds safety. This enables; interoperation between code using ``-fbounds-safety`` and code that does not. Default pointer types; ---------------------. ABI visibility and default annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Requiring ``-fbounds-safety`` adopters to add bounds annotations to all pointers; in the codebase would be a significant adoption burden. To avoid this and to; secure all pointers by default, ``-fbounds-safety`` applies default bounds; annotations to pointer types.; Default annotations apply to pointer types of declarations. ``-fbounds-safety`` applies default bounds annotations to pointer types used in; declarations. The default annotations are determined by the ABI visibility of; the pointer. A pointer type is ABI-visible if changing its size or; representation affects the ABI. For instance, changing the size of a type used; in a function parameter will affect the ABI and thus pointers used in function; parameters are ABI-visible pointers. On the other hand, changing the types of; local variables won't have such ABI implications. Hence, ``-fbounds-safety``; considers the outermost pointer types of local variables as non-ABI visible. The; rest of the pointers such as nested pointer types, pointer types of global; variables, struct fields, and function prototypes are considered ABI-visible. All ABI-visible pointers are treated as ``__single`` by default unless annotated; otherwise. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:20225,secur,secure,20225,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['secur'],['secure']
Security,"the preceding fields; HeaderData header_data; // Implementation specific header data; };. The header starts with a 32 bit ""``magic``"" value which must be ``'HASH'``; encoded as an ASCII integer. This allows the detection of the start of the; hash table and also allows the table's byte order to be determined so the table; can be correctly extracted. The ""``magic``"" value is followed by a 16 bit; ``version`` number which allows the table to be revised and modified in the; future. The current version number is 1. ``hash_function`` is a ``uint16_t``; enumeration that specifies which hash function was used to produce this table.; The current values for the hash function enumerations include:. .. code-block:: c. enum HashFunctionType; {; eHashFunctionDJB = 0u, // Daniel J Bernstein hash function; };. ``bucket_count`` is a 32 bit unsigned integer that represents how many buckets; are in the ``BUCKETS`` array. ``hashes_count`` is the number of unique 32 bit; hash values that are in the ``HASHES`` array, and is the same number of offsets; are contained in the ``OFFSETS`` array. ``header_data_len`` specifies the size; in bytes of the ``HeaderData`` that is filled in by specialized versions of; this table. Fixed Lookup; """""""""""""""""""""""". The header is followed by the buckets, hashes, offsets, and hash value data. .. code-block:: c. struct FixedTable; {; uint32_t buckets[Header.bucket_count]; // An array of hash indexes into the ""hashes[]"" array below; uint32_t hashes [Header.hashes_count]; // Every unique 32 bit hash for the entire table is in this table; uint32_t offsets[Header.hashes_count]; // An offset that corresponds to each item in the ""hashes[]"" array above; };. ``buckets`` is an array of 32 bit indexes into the ``hashes`` array. The; ``hashes`` array contains all of the 32 bit hash values for all names in the; hash table. Each hash in the ``hashes`` table has an offset in the ``offsets``; array that points to the data for the hash value. This table setup makes it very eas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:70209,hash,hash,70209,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"the source field is present, consumers can use the embedded source; instead of attempting to discover the source on disk using the file path; provided by the* ``DW_LNCT_path`` *field. When the source field is absent,; consumers can access the file to get the source text.*. *This is particularly useful for programming languages that support runtime; compilation and runtime generation of source text. In these cases, the; source text does not reside in any permanent file. For example, the OpenCL; language [:ref:`OpenCL <amdgpu-dwarf-OpenCL>`] supports online compilation.*. 2. ``DW_LNCT_LLVM_is_MD5``. ``DW_LNCT_LLVM_is_MD5`` indicates if the ``DW_LNCT_MD5`` content kind, if; present, is valid: when 0 it is not valid and when 1 it is valid. If; ``DW_LNCT_LLVM_is_MD5`` content kind is not present, and ``DW_LNCT_MD5``; content kind is present, then the MD5 checksum is valid. ``DW_LNCT_LLVM_is_MD5`` is always paired with the ``DW_FORM_udata`` form. *This allows a compilation unit to have a mixture of files with and without; MD5 checksums. This can happen when multiple relocatable files are linked; together.*. .. _amdgpu-dwarf-call-frame-information:. A.6.4 Call Frame Information; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. note::. This section provides changes to existing call frame information and defines; instructions added by these extensions. Additional support is added for; address spaces. Register unwind DWARF expressions are generalized to allow any; location description, including those with composite and implicit location; descriptions. These changes would be incorporated into the DWARF Version 5 section 6.4. .. _amdgpu-dwarf-structure_of-call-frame-information:. A.6.4.1 Structure of Call Frame Information; +++++++++++++++++++++++++++++++++++++++++++. The register rules are:. *undefined*; A register that has this rule has no recoverable value in the previous frame.; The previous value of this register is the undefined location description (see; :ref:`amdgpu-dwarf-undefined-lo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:189799,checksum,checksums,189799,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['checksum'],['checksums']
Security,"the top of the function. It's the only; ``MemoryDef`` that maps to no ``Instruction`` in LLVM IR. Use of; ``liveOnEntry`` implies that the memory being used is either undefined or; defined before the function begins. An example of all of this overlaid on LLVM IR (obtained by running ``opt; -passes='print<memoryssa>' -disable-output`` on an ``.ll`` file) is below. When; viewing this example, it may be helpful to view it in terms of clobbers.; The operands of a given ``MemoryAccess`` are all (potential) clobbers of said; ``MemoryAccess``, and the value produced by a ``MemoryAccess`` can act as a clobber; for other ``MemoryAccess``\ es. If a ``MemoryAccess`` is a *clobber* of another, it means that these two; ``MemoryAccess``\ es may access the same memory. For example, ``x = MemoryDef(y)``; means that ``x`` potentially modifies memory that ``y`` modifies/constrains; (or has modified / constrained).; In the same manner, ``a = MemoryPhi({BB1,b},{BB2,c})`` means that; anyone that uses ``a`` is accessing memory potentially modified / constrained; by either ``b`` or ``c`` (or both). And finally, ``MemoryUse(x)`` means; that this use accesses memory that ``x`` has modified / constrained; (as an example, think that if ``x = MemoryDef(...)``; and ``MemoryUse(x)`` are in the same loop, the use can't; be hoisted outside alone). Another useful way of looking at it is in terms of memory versions.; In that view, operands of a given ``MemoryAccess`` are the version; of the entire memory before the operation, and if the access produces; a value (i.e. ``MemoryDef/MemoryPhi``),; the value is the new version of the memory after the operation. .. code-block:: llvm. define void @foo() {; entry:; %p1 = alloca i8; %p2 = alloca i8; %p3 = alloca i8; ; 1 = MemoryDef(liveOnEntry); store i8 0, ptr %p3; br label %while.cond. while.cond:; ; 6 = MemoryPhi({entry,1},{if.end,4}); br i1 undef, label %if.then, label %if.else. if.then:; ; 2 = MemoryDef(6); store i8 0, ptr %p1; br label %if.end. if.else:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:4958,access,accessing,4958,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['access'],['accessing']
Security,"the training input does not have good coverage; on all the hot functions.; ``inlinehint``; This attribute indicates that the source code contained a hint that; inlining this function is desirable (such as the ""inline"" keyword in; C/C++). It is just a hint; it imposes no requirements on the; inliner.; ``jumptable``; This attribute indicates that the function should be added to a; jump-instruction table at code-generation time, and that all address-taken; references to this function should be replaced with a reference to the; appropriate jump-instruction-table function pointer. Note that this creates; a new pointer for the original function, which means that code that depends; on function-pointer identity can break. So, any function annotated with; ``jumptable`` must also be ``unnamed_addr``.; ``memory(...)``; This attribute specifies the possible memory effects of the call-site or; function. It allows specifying the possible access kinds (``none``,; ``read``, ``write``, or ``readwrite``) for the possible memory location; kinds (``argmem``, ``inaccessiblemem``, as well as a default). It is best; understood by example:. - ``memory(none)``: Does not access any memory.; - ``memory(read)``: May read (but not write) any memory.; - ``memory(write)``: May write (but not read) any memory.; - ``memory(readwrite)``: May read or write any memory.; - ``memory(argmem: read)``: May only read argument memory.; - ``memory(argmem: read, inaccessiblemem: write)``: May only read argument; memory and only write inaccessible memory.; - ``memory(read, argmem: readwrite)``: May read any memory (default mode); and additionally write argument memory.; - ``memory(readwrite, argmem: none)``: May access any memory apart from; argument memory. The supported memory location kinds are:. - ``argmem``: This refers to accesses that are based on pointer arguments; to the function.; - ``inaccessiblemem``: This refers to accesses to memory which is not; accessible by the current module (before return from",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:84802,access,access,84802,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"the vector and scalar memory operations performed by wavefronts; executing with different L1 caches and the same L2 cache can be reordered; relative to each other.; * A ``s_waitcnt vmcnt(0)`` is required to ensure synchronization between; vector memory operations of different CUs. It ensures a previous vector; memory operation has completed before executing a subsequent vector memory; or LDS operation and so can be used to meet the requirements of acquire and; release.; * An L2 cache can be kept coherent with other L2 caches by using the MTYPE RW; (read-write) for memory local to the L2, and MTYPE NC (non-coherent) with; the PTE C-bit set for memory not local to the L2. * Any local memory cache lines will be automatically invalidated by writes; from CUs associated with other L2 caches, or writes from the CPU, due to; the cache probe caused by the PTE C-bit.; * XGMI accesses from the CPU to local memory may be cached on the CPU.; Subsequent access from the GPU will automatically invalidate or writeback; the CPU cache due to the L2 probe filter.; * To ensure coherence of local memory writes of CUs with different L1 caches; in the same agent a ``buffer_wbl2`` is required. It does nothing if the; agent is configured to have a single L2, or will writeback dirty L2 cache; lines if configured to have multiple L2 caches.; * To ensure coherence of local memory writes of CUs in different agents a; ``buffer_wbl2 sc1`` is required. It will writeback dirty L2 cache lines.; * To ensure coherence of local memory reads of CUs with different L1 caches; in the same agent a ``buffer_inv sc1`` is required. It does nothing if the; agent is configured to have a single L2, or will invalidate non-local L2; cache lines if configured to have multiple L2 caches.; * To ensure coherence of local memory reads of CUs in different agents a; ``buffer_inv sc0 sc1`` is required. It will invalidate non-local L2 cache; lines if configured to have multiple L2 caches. * PCIe access from the GPU to the CP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:288666,access,access,288666,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"the; code. You can either reply to these, or address them and mark them as; ""done"". Note that in-line replies are **not** sent straight away! They; become ""draft"" comments and you must click ""Submit"" at the bottom of the; page. Updating your change; ~~~~~~~~~~~~~~~~~~~~. If you make changes in response to a reviewer's comments, simply update; your branch with more commits and push to your fork. It may be a good; idea to answer the comments from the reviewer explicitly. Accepting a revision; ~~~~~~~~~~~~~~~~~~~~. When the reviewer is happy with the change, they will **Accept** the; revision. They may leave some more minor comments that you should; address, but at this point the review is complete. It's time to get it; merged!. Commit by proxy; ---------------. As this is your first change, you won't have access to merge it; yourself yet. The reviewer **doesn't know this**, so you need to tell; them! Leave a message on the review like:. Thanks @somellvmdev. I don't have commit access, can you land this; patch for me?. The pull-request will be closed and you will be notified by GitHub. Review expectations; -------------------. In order to make LLVM a long-term sustainable effort, code needs to be; maintainable and well tested. Code reviews help to achieve that goal.; Especially for new contributors, that often means many rounds of reviews; and push-back on design decisions that do not fit well within the; overall architecture of the project. For your first patches, this means:. - be kind, and expect reviewers to be kind in return - LLVM has a `Code; of Conduct <https://llvm.org/docs/CodeOfConduct.html>`__;. - be patient - understanding how a new feature fits into the; architecture of the project is often a time consuming effort, and; people have to juggle this with other responsibilities in their; lives; **ping the review once a week** when there is no response;. - if you can't agree, generally the best way is to do what the reviewer; asks; we optimize for readability ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:11441,access,access,11441,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['access'],['access']
Security,"their base class. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void sink(NonVirtual *x) {; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. alpha.cplusplus.InvalidatedIterator; (C++); Check for use of invalidated iterators. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. alpha.cplusplus.IteratorRange; (C++); Check for iterators used outside their valid ranges. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. alpha.cplusplus.MismatchedIterator; (C++); Check for use of iterators of different containers where iterators of the same; container are expected. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin(), v2.cbegin(), v1.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; }. alpha.cplusplus.Move; (C++); Method calls on a moved-from object and copying a moved-from object will be; reported. struct A {; void foo() {}; };. void f() {; A a;; A b = std::move(a); // note: 'a' became 'moved-from' here; a.foo(); // warn: method call on a 'moved-from' object 'a'; }. Dead Code Alpha Checkers. Name, DescriptionExample. alpha.deadcode.UnreachableCode; (C, C++, ObjC); Check unreachable code. // C; int test() {; int x = 1;; while(x);; return x; // warn; }. // C++; void test() {; int a = 2;. while (a > 1); a--;. if (a > 1); a++; // warn; }. // Objective-C; void test(id x) {; return;; [x retain]; // warn; }. LLVM Checkers. Name, Descriptio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:5806,access,accessed,5806,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['access'],['accessed']
Security,"their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a starting address and a size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this case, the ``basic-aa`` pass will disambiguate the stores to ``C[0]`` and; ``C[1]`` because they are accesses to two distinct locations one byte apart, and; the accesses are each one byte. In this case, the Loop Invariant Code Motion; (LICM) pass can use store motion to remove the stores from the loop. In; contrast, the following code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; ((short*)C)[0] = A[i]; /* Two byte store! */; C[1] = A[9-i]; /* One byte store */; }. In this case, the two stores to C do alias each other, because the access to the; ``&C[0]`` element is a two byte access. If size information wasn't available in; the query, even the first case would have to conservatively assume that the; accesses alias. .. _alias:. The ``alias`` method; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:4035,access,access,4035,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,2,['access'],['access']
Security,"then uses; SEH (``__try / __except``) to resume execution with new information in the child; frame. In other words, the successive unwinding approach is incompatible with Visual; C++ exceptions and general purpose Windows exception handling. Because the C++; exception object lives in stack memory, LLVM cannot provide a custom personality; function that uses landingpads. Similarly, SEH does not provide any mechanism; to rethrow an exception or continue unwinding. Therefore, LLVM must use the IR; constructs described later in this document to implement compatible exception; handling. SEH filter expressions; -----------------------. The SEH personality functions also use funclets to implement filter expressions,; which allow executing arbitrary user code to decide which exceptions to catch.; Filter expressions should not be confused with the ``filter`` clause of the LLVM; ``landingpad`` instruction. Typically filter expressions are used to determine; if the exception came from a particular DLL or code region, or if code faulted; while accessing a particular memory address range. LLVM does not currently have; IR to represent filter expressions because it is difficult to represent their; control dependencies. Filter expressions run during the first phase of EH,; before cleanups run, making it very difficult to build a faithful control flow; graph. For now, the new EH instructions cannot represent SEH filter; expressions, and frontends must outline them ahead of time. Local variables of; the parent function can be escaped and accessed using the ``llvm.localescape``; and ``llvm.localrecover`` intrinsics. New exception handling instructions; ------------------------------------. The primary design goal of the new EH instructions is to support funclet; generation while preserving information about the CFG so that SSA formation; still works. As a secondary goal, they are designed to be generic across MSVC; and Itanium C++ exceptions. They make very few assumptions about the da",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:24298,access,accessing,24298,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['access'],['accessing']
Security,"they wonder why the ``i64; 0`` index is needed. However, a closer inspection of how globals and GEPs work; reveals the need. Becoming aware of the following facts will dispel the; confusion:. #. The type of ``%MyStruct`` is *not* ``{ ptr, i32 }`` but rather ``ptr``.; That is, ``%MyStruct`` is a pointer (to a structure), not a structure itself. #. Point #1 is evidenced by noticing the type of the second operand of the GEP; instruction (``%MyStruct``) which is ``ptr``. #. The first index, ``i64 0`` is required to step over the global variable; ``%MyStruct``. Since the second argument to the GEP instruction must always; be a value of pointer type, the first index steps through that pointer. A; value of 0 means 0 elements offset from that pointer. #. The second index, ``i32 1`` selects the second field of the structure (the; ``i32``). What is dereferenced by GEP?; ----------------------------. Quick answer: nothing. The GetElementPtr instruction dereferences nothing. That is, it doesn't access; memory in any way. That's what the Load and Store instructions are for. GEP is; only involved in the computation of addresses. For example, consider this:. .. code-block:: text. @MyVar = external global { i32, ptr }; ...; %idx = getelementptr { i32, ptr }, ptr @MyVar, i64 0, i32 1; %arr = load ptr, ptr %idx; %idx = getelementptr [40 x i32], ptr %arr, i64 0, i64 17. In this example, we have a global variable, ``@MyVar``, which is a pointer to; a structure containing a pointer. Let's assume that this inner pointer points; to an array of type ``[40 x i32]``. The above IR will first compute the address; of the inner pointer, then load the pointer, and then compute the address of; the 18th array element. This cannot be expressed in a single GEP instruction, because it requires; a memory dereference in between. However, the following example would work; fine:. .. code-block:: text. @MyVar = external global { i32, [40 x i32 ] }; ...; %idx = getelementptr { i32, [40 x i32] }, ptr @MyVar, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:6405,access,access,6405,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['access'],['access']
Security,"thm to efficiently merge AliasSets when a pointer is; inserted into the AliasSetTracker that aliases multiple sets. The primary data; structure is a hash table mapping pointers to the AliasSet they are in. The AliasSetTracker class must maintain a list of all of the LLVM ``Value*``\s; that are in each AliasSet. Since the hash table already has entries for each; LLVM ``Value*`` of interest, the AliasesSets thread the linked list through; these hash-table nodes to avoid having to allocate memory unnecessarily, and to; make merging alias sets extremely efficient (the linked list merge is constant; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``AliasAnalysis`` class directly. Try to use the; higher-level methods when possible (e.g., use mod/ref information instead of the; `alias`_ method directly if possible) to get the best precision and efficiency. Existing alias analysis implementations and clients; ===================================================. If you're going to be working with the LLVM alias analysis infrastructure, you; should know what clients and implementations of alias analysis are available.; In particular, if you are implementing an alias analysis, you should be aware of; the `the clients`_ that are useful for monitoring and evaluating different; implementations. .. _various alias analysis implementations:. Available ``AliasAnalysis`` implementations; -------------------------------------------. This section lists the various implementations of the ``AliasAnalysis``; interface. All of these :ref:`chain <aliasanalysis-chaining>` to other; alias analysis implementations.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:22764,expose,exposed,22764,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['expose'],['exposed']
Security,"those on ``std::string``\ s. We can achieve this change simply by refining our; matcher. The rest of the rule remains unchanged:. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr(hasType(namedDecl(hasName(""std::string"")))); 	 .bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. Example: rewriting method calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:7851,access,accessor,7851,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['access'],['accessor']
Security,"threading constraints.; Attributes must be attached to named declarations, such as classes, methods,; and data members. Users are *strongly advised* to define macros for the various; attributes; example definitions can be found in :ref:`mutexheader`, below.; The following documentation assumes the use of macros. The attributes only control assumptions made by thread safety analysis and the; warnings it issues. They don't affect generated code or behavior at run-time. For historical reasons, prior versions of thread safety used macro names that; were very lock-centric. These macros have since been renamed to fit a more; general capability model. The prior names are still in use, and will be; mentioned under the tag *previously* where appropriate. GUARDED_BY(c) and PT_GUARDED_BY(c); ----------------------------------. ``GUARDED_BY`` is an attribute on data members, which declares that the data; member is protected by the given capability. Read operations on the data; require shared access, while write operations require exclusive access. ``PT_GUARDED_BY`` is similar, but is intended for use on pointers and smart; pointers. There is no constraint on the data member itself, but the *data that; it points to* is protected by the given capability. .. code-block:: c++. Mutex mu;; int *p1 GUARDED_BY(mu);; int *p2 PT_GUARDED_BY(mu);; unique_ptr<int> p3 PT_GUARDED_BY(mu);. void test() {; p1 = 0; // Warning!. *p2 = 42; // Warning!; p2 = new int; // OK. *p3 = 42; // Warning!; p3.reset(new int); // OK.; }. REQUIRES(...), REQUIRES_SHARED(...); -----------------------------------. *Previously*: ``EXCLUSIVE_LOCKS_REQUIRED``, ``SHARED_LOCKS_REQUIRED``. ``REQUIRES`` is an attribute on functions or methods, which; declares that the calling thread must have exclusive access to the given; capabilities. More than one capability may be specified. The capabilities; must be held on entry to the function, *and must still be held on exit*. ``REQUIRES_SHARED`` is similar, but requires only share",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:6981,access,access,6981,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,2,['access'],['access']
Security,"thus identifies a consistent version of; all LLVM sub-projects. Git does not use sequential integer revision number but instead uses a hash to; identify each commit. The loss of a sequential integer revision number has been a sticking point in; past discussions about Git:. - ""The 'branch' I most care about is mainline, and losing the ability to say; 'fixed in r1234' (with some sort of monotonically increasing number) would; be a tragic loss."" [LattnerRevNum]_; - ""I like those results sorted by time and the chronology should be obvious, but; timestamps are incredibly cumbersome and make it difficult to verify that a; given checkout matches a given set of results."" [TrickRevNum]_; - ""There is still the major regression with unreadable version numbers.; Given the amount of Bugzilla traffic with 'Fixed in...', that's a; non-trivial issue."" [JSonnRevNum]_; - ""Sequential IDs are important for LNT and llvmlab bisection tool."" [MatthewsRevNum]_. However, Git can emulate this increasing revision number:; ``git rev-list --count <commit-hash>``. This identifier is unique only; within a single branch, but this means the tuple `(num, branch-name)` uniquely; identifies a commit. We can thus use this revision number to ensure that e.g. `clang -v` reports a; user-friendly revision number (e.g. `main-12345` or `4.0-5321`), addressing; the objections raised above with respect to this aspect of Git. What About Branches and Merges?; -------------------------------. In contrast to SVN, Git makes branching easy. Git's commit history is; represented as a DAG, a departure from SVN's linear history. However, we propose; to mandate making merge commits illegal in our canonical Git repository. Unfortunately, GitHub does not support server side hooks to enforce such a; policy. We must rely on the community to avoid pushing merge commits. GitHub offers a feature called `Status Checks`: a branch protected by; `status checks` requires commits to be explicitly allowed before the push can happen.; W",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:5146,hash,hash,5146,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['hash'],['hash']
Security,"till have all of the same data, we just organize it more efficiently for; debugger lookup. If we repeat the same ""``printf``"" lookup from above, we; would hash ""``printf``"" and find it matches ``BUCKETS[3]`` by taking the 32 bit; hash value and modulo it by ``n_buckets``. ``BUCKETS[3]`` contains ""6"" which; is the index into the ``HASHES`` table. We would then compare any consecutive; 32 bit hashes values in the ``HASHES`` array as long as the hashes would be in; ``BUCKETS[3]``. We do this by verifying that each subsequent hash value modulo; ``n_buckets`` is still 3. In the case of a failed lookup we would access the; memory for ``BUCKETS[3]``, and then compare a few consecutive 32 bit hashes; before we know that we have no match. We don't end up marching through; multiple words of memory and we really keep the number of processor data cache; lines being accessed as small as possible. The string hash that is used for these lookup tables is the Daniel J.; Bernstein hash which is also used in the ELF ``GNU_HASH`` sections. It is a; very good hash for all kinds of names in programs with very few hash; collisions. Empty buckets are designated by using an invalid hash index of ``UINT32_MAX``. Details; ^^^^^^^. These name hash tables are designed to be generic where specializations of the; table get to define additional data that goes into the header (""``HeaderData``""),; how the string value is stored (""``KeyType``"") and the content of the data for each; hash value. Header Layout; """""""""""""""""""""""""". The header has a fixed part, and the specialized part. The exact format of the; header is:. .. code-block:: c. struct Header; {; uint32_t magic; // 'HASH' magic value to allow endian detection; uint16_t version; // Version number; uint16_t hash_function; // The hash function enumeration that was used; uint32_t bucket_count; // The number of buckets in this hash table; uint32_t hashes_count; // The total number of unique hash values and hash data offsets in this table; uint32_t heade",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:68027,hash,hash,68027,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"ting in the room next door; since 1995. **Andrei** and **Mihaela Gheata** (Alice collaboration) are co-authors; of the ROOT geometry classes and Virtual Monte-Carlo. They have been; working with the ROOT team since 2000. **Olivier Couet**, who after a successful development and maintenance; of PAW, has joined the ROOT team in 2000 and has been working on the; graphics sub-system. **Ilka Antcheva** has been working on the Graphical User Interface; classes. She is also responsible for this latest edition of the Users; Guide with a better style, improved index and several new chapters; (since 2002). **Bertrand Bellenot** has been developing and maintaining the Win32GDK; version of ROOT. Bertrand has also many other contributions like the; nice RootShower example (since 2001). **Valeriy Onoutchin** has been working on several ROOT packages, in; particular the graphics sub-system for Windows and the GUI Builder; (since 2000). **Gerri Ganis** has been working on the authentication procedures to; be used by the root daemons and the PROOF system (since 2002). **Maarten Ballintijn** (MIT) is one of the main developers of the; PROOF sub-system (since 1995). **Valeri Fine** (now at BNL) ported ROOT to Windows and contributed; largely to the 3-D graphics. He is currently working on the Qt layer; of ROOT (since 1995). **Victor Perevoztchikov** (BNL) worked on key elements of the I/O; system, in particular the improved support for STL collections; (1997-2001). **Nenad Buncic** developed the HTML documentation generation system; and integrated the X3D viewer inside ROOT (1995-1997). **Suzanne Panacek** was the author of the first version of this User's; Guide and very active in preparing tutorials and giving lectures about; ROOT (1999-2002). **Axel Naumann** has been developing further the HTML Reference Guide; and helps in porting ROOT under Windows (cygwin/gcc implementation); (since 2000). **Anna Kreshuk** has developed the Linear Fitter and Robust Fitter; classes as well as man",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:2993,authenticat,authentication,2993,documentation/users-guide/Preface.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md,1,['authenticat'],['authentication']
Security,"tings. The radio button ""All"" allows viewing all volumes down; to the selected depth. ""Leaves"" will draw only the deepest nodes; that have the selected depth or lower level ones that have no; daughters inside. ""Only"" will allow drawing only the edited; volume. The check button ""Raytrace"" will just draw the current; selection in solid mode using the ray-tracing algorithm provided by; TGeo. \image html geometry024.jpg width=600px; \image html geometry025.jpg ""Volume visualisation settings and division interface for volumes"" width=600px. - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""From"", ""Step""; and ""Nslices"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. \anchor GP08f; ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""Materials"" shutter item; category. Generally, for creating objects, the interface is always in; the TGeoManagerEditor in different categories - one should just; provide a name and requested parameters. 3. Create a shape that will be used for the top volume within the; ""Shapes"" category. For the moment, the shapes that have editors are; Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype,; Pcon, Torus and Sphere. 4. Create a medium from one of the existing materials from the; ""Medium"" category. You will notice that some categories as ""Volume""; and ""Medium"" are inactive at the beginning because at that time there; is no materi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:133960,validat,validate,133960,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['validat'],['validate']
Security,"tion going through jitted code has been repaired.; - Interpreted code is now optimized; `.O 0/1/2/3` can be used to change the optimization level, as well as `#pragma cling optimize`.; - The prompt colors are now much more visible, both on terminals with light and dark background.; - Significant speedup of `TMethodCall`.; - One can now run `.x 12file-with@funny=name.C`; it will expect a function called `_12file_with_funny_name()`. ## Core Libraries. - See ""Build, Configuration and Testing Infrastructure"" below for changes in the directory structure.; - libCling now exports only a minimal set of symbols.; - Add support for std::array_view also for C++11 builds. The implementation has been modified to work before C++14.; - Added TCollection::Notify to allow notifying more than one object.; ```{.cpp}; TList formulas;; // Add several TTreeFormula to the list;; chain.SetNotify(&formulas);; ```; - For classes that need the `ClassDef` support, `ClassDefInline(ClassName, Version)` now provides it without the need for a dictionary source: all members injected by this `ClassDef` flavor are generated by the interpreter. ### `TObjString` to `TString`. `TObjString::GetString()` now returns a `const TString&` to the `TString` inside the `TObjString`, instead of copying it.; This is to prevent very common misunderstanding of the interface. In several cases, the misunderstanding of the interface caused invalid memory accesses to the already destructed; temporary `TString` returned by `GetString()`, e.g. `objStr->GetString().Data()`. This will be fixed automatically by the; new return type. In rare cases, the caller expected `GetString()` to return a (non-const) reference to the embedded `TString`, e.g.; `objString->GetString().ReplaceAll(""a"", ""b""); // WRONG!` This will now fail to compile, instead of not doing what the author of the; code expected. Please fix that code by using the `TObjString::String()` interface, which returns a non-const `TString&`:; `objString->String().ReplaceA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:2890,inject,injected,2890,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['inject'],['injected']
Security,"tion matrix). ### Associated Function. One or more objects (typically a **`TF1\*`**) can be added to the list; of functions (`fFunctions`) associated to each histogram. A call to; `TH1::Fit` adds the fitted function to this list. Given a histogram; `h`, one can retrieve the associated function with:. ``` {.cpp}; TF1 *myfunc = h->GetFunction(""myfunc"");; ```. ### Access to the Fit Parameters and Results. If the histogram (or graph) is made persistent, the list of associated; functions is also persistent. Retrieve a pointer to the function with; the `TH1::GetFunction()` method. Then you can retrieve the fit; parameters from the function (**`TF1`**) with calls such as:. ``` {.cpp}; root[] TF1 *fit = hist->GetFunction(function_name);; root[] Double_t chi2 = fit->GetChisquare();; // value of the first parameter; root[] Double_t p1 = fit->GetParameter(0);; // error of the first parameter; root[] Double_t e1 = fit->GetParError(0);; ```. Using the fit option `S` one can access the full result of the fit including the covariance and correlation matrix.; See later the paragraph `TFitResult`. ### Associated Errors. By default, for each bin, the sum of weights is computed at fill time.; One can also call `TH1::Sumw2` to force the storage and computation of; the sum of the square of weights per bin. If Sumw2 has been called,; the error per bin is computed as the `sqrt(sum of squares of; weights)`; otherwise, the error is set equal to the; `sqrt(bin content)`. To return the error for a given bin number, do:. ``` {.cpp}; Double_t error = h->GetBinError(bin);; ```. Empty bins are excluded in the fit when using the Chi-square fit method.; When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to; use the Log-Likelihood method (option ‘`L`' or ""`WL`""), particularly in case of low statistics.; When the histogram has been filled with weights different than one, a weighted likelihood method can be used; and the errors retrieved from the fit are corr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:18293,access,access,18293,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['access'],['access']
Security,"tion tokens and https protocol,; this makes usage of webgui components in public networks more secure. ### Enabled WLCG Bearer Tokens support in RDavix. Bearer tokens are part of WLCG capability-based infrastructure with capability-based scheme which uses an infrastructure that describes what the bearer is allowed to do as opposed to who that bearer is. Token discovery procedure are developed according WLCG Bearer Token Discovery specification document (https://github.com/WLCG-AuthZ-WG/bearer-token-discovery/blob/master/specification.md). Short overview:. 1. If the `BEARER_TOKEN` environment variable is set, then the value is taken to be the token contents.; 2. If the `BEARER_TOKEN_FILE` environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.; 3. If the `XDG_RUNTIME_DIR` environment variable is set, then take the token from the contents of `$XDG_RUNTIME_DIR/bt_u$ID`(this additional location is intended to provide improved security for shared login environments as `$XDG_RUNTIME_DIR` is defined to be user-specific as opposed to a system-wide directory.).; 4. Otherwise, take the token from `/tmp/bt_u$ID`. ## GUI Libraries. ### RBrowser improvements. - central factory methods to handle browsing, editing and drawing of different classes; - simple possibility to extend RBrowser on user-defined classes; - support of web-based geometry viewer; - better support of TTree drawing; - server-side handling of code editor and image viewer widgets; - rbrowser content is fully recovered when web-browser is reloaded; - load of widgets code only when really required (shorter startup time for RBrowser). ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ### Major JSROOT update to version 6. - update all used libraries `d3.js`, `three.js`, `MathJax.js`, openui5; - change to Promise based interface for all async methods, remove call-back arguments; - change scripts",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:26591,secur,security,26591,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['secur'],['security']
Security,"tion unit; declaration <https://clang.llvm.org/doxygen/classclang_1_1TranslationUnitDecl.html>`_.; In this example, our first user written declaration is the `function; declaration <https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html>`_; of ""``f``"". The body of ""``f``"" is a `compound; statement <https://clang.llvm.org/doxygen/classclang_1_1CompoundStmt.html>`_,; whose child nodes are a `declaration; statement <https://clang.llvm.org/doxygen/classclang_1_1DeclStmt.html>`_; that declares our result variable, and the `return; statement <https://clang.llvm.org/doxygen/classclang_1_1ReturnStmt.html>`_. AST Context; ===========. All information about the AST for a translation unit is bundled up in; the class; `ASTContext <https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html>`_.; It allows traversal of the whole translation unit starting from; `getTranslationUnitDecl <https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html#abd909fb01ef10cfd0244832a67b1dd64>`_,; or to access Clang's `table of; identifiers <https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html#a4f95adb9958e22fbe55212ae6482feb4>`_; for the parsed translation unit. AST Nodes; =========. Clang's AST nodes are modeled on a class hierarchy that does not have a; common ancestor. Instead, there are multiple larger hierarchies for; basic node types like; `Decl <https://clang.llvm.org/doxygen/classclang_1_1Decl.html>`_ and; `Stmt <https://clang.llvm.org/doxygen/classclang_1_1Stmt.html>`_. Many; important AST nodes derive from; `Type <https://clang.llvm.org/doxygen/classclang_1_1Type.html>`_,; `Decl <https://clang.llvm.org/doxygen/classclang_1_1Decl.html>`_,; `DeclContext <https://clang.llvm.org/doxygen/classclang_1_1DeclContext.html>`_; or `Stmt <https://clang.llvm.org/doxygen/classclang_1_1Stmt.html>`_, with; some classes deriving from both Decl and DeclContext. There are also a multitude of nodes in the AST that are not part of a; larger hierarchy, and are only reachable from specific ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:3665,access,access,3665,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,1,['access'],['access']
Security,"tions at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU over XGMI or PCIe the kernarg backing memory is allocated in host; memory accessed as MTYPE UC (uncached) to avoid needing to invalidate the L2; cache. This also causes it to be treated as non-volatile and so is not; invalidated by ``*_vol``.; * On APU the kernarg backing memory is accessed as MTYPE CC (cache coherent) and; so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX90A are defined; in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx90a-table`. .. table:: AMDHSA Memory Model Code Sequences GFX90A; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx90a-table. ============ ============ ============== ========== ================================; LLVM Instr LLVM Memory LLVM Memory AMDGPU AMDGPU Machine Code; Ordering Sync Scope Address GFX90A; Space; ============ ============ ============== ========== ================================; **Non-Atomic**; ------------------------------------------------------------------------------------; load *none* *none* ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:241534,access,accessed,241534,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"tions at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU over XGMI or PCIe the kernarg backing memory is allocated in host; memory accessed as MTYPE UC (uncached) to avoid needing to invalidate the L2; cache. This also causes it to be treated as non-volatile and so is not; invalidated by ``*_vol``.; * On APU the kernarg backing memory is accessed as MTYPE CC (cache coherent) and; so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX940, GFX941, GFX942; are defined in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx940-gfx941-gfx942-table`. .. table:: AMDHSA Memory Model Code Sequences GFX940, GFX941, GFX942; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx940-gfx941-gfx942-table. ============ ============ ============== ========== ================================; LLVM Instr LLVM Memory LLVM Memory AMDGPU AMDGPU Machine Code; Ordering Sync Scope Address GFX940, GFX941, GFX942; Space; ============ ============ ============== ========== ================================; **Non-Atomic**; -----------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:291552,access,accessed,291552,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"tions within the same address space. ``wavefront-one-as`` Same as ``wavefront`` but only synchronizes with; other operations within the same address space. ``singlethread-one-as`` Same as ``singlethread`` but only synchronizes with; other operations within the same address space.; ======================= ===================================================. LLVM IR Intrinsics; ------------------. The AMDGPU backend implements the following LLVM IR intrinsics. *This section is WIP.*. .. table:: AMDGPU LLVM IR Intrinsics; :name: amdgpu-llvm-ir-intrinsics-table. ============================================== ==========================================================; LLVM Intrinsic Description; ============================================== ==========================================================; llvm.amdgcn.sqrt Provides direct access to v_sqrt_f64, v_sqrt_f32 and v_sqrt_f16; (on targets with half support). Performs sqrt function. llvm.amdgcn.log Provides direct access to v_log_f32 and v_log_f16; (on targets with half support). Performs log2 function. llvm.amdgcn.exp2 Provides direct access to v_exp_f32 and v_exp_f16; (on targets with half support). Performs exp2 function. :ref:`llvm.frexp <int_frexp>` Implemented for half, float and double. :ref:`llvm.log2 <int_log2>` Implemented for float and half (and vectors of float or; half). Not implemented for double. Hardware provides; 1ULP accuracy for float, and 0.51ULP for half. Float; instruction does not natively support denormal; inputs. :ref:`llvm.sqrt <int_sqrt>` Implemented for double, float and half (and vectors). :ref:`llvm.log <int_log>` Implemented for float and half (and vectors). :ref:`llvm.exp <int_exp>` Implemented for float and half (and vectors). :ref:`llvm.log10 <int_log10>` Implemented for float and half (and vectors). :ref:`llvm.exp2 <int_exp2>` Implemented for float and half (and vectors of float or; half). Not implemented for double. Hardware provides; 1ULP accuracy for float, and 0.51ULP for half. F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:35974,access,access,35974,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"tive at any given time. This; feature is designed to support incremental and atomic updates of the underlying; MSF file. While writing to an MSF file, if the active FPM is FPM1, you can; write your new modified bitfield to FPM2, and vice versa. Only when you commit; the file to disk do you need to swap the value in the SuperBlock to point to; the new ``FreeBlockMapBlock``. The Free Block Maps are stored as a series of single blocks throughout the file; at intervals of BlockSize. Because each FPM block is of size ``BlockSize``; bytes, it contains 8 times as many bits as an interval has blocks. This means; that the first block of each FPM refers to the first 8 intervals of the file; (the first 32768 blocks), the second block of each FPM refers to the next 8; blocks, and so on. This results in far more FPM blocks being present than are; required, but in order to maintain backwards compatibility the format must stay; this way. The Stream Directory; ====================; The Stream Directory is the root of all access to the other streams in an MSF; file. Beginning at byte 0 of the stream directory is the following structure:. .. code-block:: c++. struct StreamDirectory {; ulittle32_t NumStreams;; ulittle32_t StreamSizes[NumStreams];; ulittle32_t StreamBlocks[NumStreams][];; };. And this structure occupies exactly ``SuperBlock->NumDirectoryBytes`` bytes.; Note that each of the last two arrays is of variable length, and in particular; that the second array is jagged. **Example:** Suppose a hypothetical PDB file with a 4KiB block size, and 4; streams of lengths {1000 bytes, 8000 bytes, 16000 bytes, 9000 bytes}. Stream 0: ceil(1000 / 4096) = 1 block. Stream 1: ceil(8000 / 4096) = 2 blocks. Stream 2: ceil(16000 / 4096) = 4 blocks. Stream 3: ceil(9000 / 4096) = 3 blocks. In total, 10 blocks are used. Let's see what the stream directory might look; like:. .. code-block:: c++. struct StreamDirectory {; ulittle32_t NumStreams = 4;; ulittle32_t StreamSizes[] = {1000, 8000, 16000, 9",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst:5333,access,access,5333,interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst,1,['access'],['access']
Security,"to ""Needs Review"" and notify a knowledgeable reviewer.; Usually you will want to notify the person who approved the patch in Phabricator,; but you may use your best judgement on who a good reviewer would be. Once; you have identified the reviewer(s), assign the issue to them and mention; them (i.e @username) in a comment and ask them if the patch is safe to backport.; You should also review the bug yourself to ensure that it meets the requirements; for committing to the release branch. #. Once a bug has been reviewed, add the release:reviewed label and update the; issue's status to ""Needs Merge"". Check the pull request associated with the; issue. If all the tests pass, then the pull request can be merged. If not,; then add a comment on the issue asking someone to take a look at the failures. #. Once the pull request has been merged push it to the official release branch; with the script ``llvm/utils/git/sync-release-repo.sh``. Then add a comment to the issue stating that the fix has been merged along with; the git hashes from the release branch. Add the release:merged label to the issue; and close it. Release Patch Rules; -------------------. Below are the rules regarding patching the release branch:. #. Patches applied to the release branch may only be applied by the release; manager, the official release testers or the code owners with approval from; the release manager. #. Release managers are encouraged, but not required, to get approval from code; owners before approving patches. If there is no code owner or the code owner; is unreachable then release managers can ask approval from patch reviewers or; other developers active in that area. #. *Before RC1* Patches should be limited to bug fixes, important optimization; improvements, or completion of features that were started before the branch; was created. As with all phases, release managers and code owners can reject; patches that are deemed too invasive. #. *Before RC2* Patches should be limited to bug fixes o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:12355,hash,hashes,12355,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['hash'],['hashes']
Security,"to argv,; thereby working around the command-line length limits. Top-Level Classes and Functions; -------------------------------. Despite all of the built-in flexibility, the CommandLine option library really; only consists of one function `cl::ParseCommandLineOptions`_ and three main; classes: `cl::opt`_, `cl::list`_, and `cl::alias`_. This section describes; these three classes in detail. .. _cl::getRegisteredOptions:. The ``cl::getRegisteredOptions`` function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::getRegisteredOptions`` function is designed to give a programmer; access to declared non-positional command line options so that how they appear; in ``-help`` can be modified prior to calling `cl::ParseCommandLineOptions`_.; Note this method should not be called during any static initialisation because; it cannot be guaranteed that all options will have been initialised. Hence it; should be called from ``main``. This function can be used to gain access to options declared in libraries that; the tool writer may not have direct access to. The function retrieves a :ref:`StringMap <dss_stringmap>` that maps the option; string (e.g. ``-help``) to an ``Option*``. Here is an example of how the function could be used:. .. code-block:: c++. using namespace llvm;; int main(int argc, char **argv) {; cl::OptionCategory AnotherCategory(""Some options"");. StringMap<cl::Option*> &Map = cl::getRegisteredOptions();. //Unhide useful option and put it in a different category; assert(Map.count(""print-all-options"") > 0);; Map[""print-all-options""]->setHiddenFlag(cl::NotHidden);; Map[""print-all-options""]->setCategory(AnotherCategory);. //Hide an option we don't want to see; assert(Map.count(""enable-no-infs-fp-math"") > 0);; Map[""enable-no-infs-fp-math""]->setHiddenFlag(cl::Hidden);. //Change --version to --show-version; assert(Map.count(""version"") > 0);; Map[""version""]->setArgStr(""show-version"");. //Change --help description; assert(Map.count(""help"") > 0);; Map[""help""]->setDescrip",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:51753,access,access,51753,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,2,['access'],['access']
Security,"to do so:. #. Check the existing build configurations to make sure the one you are; interested in is not covered yet or gets built on your computer much; faster than on the existing one. We prefer faster builds so developers; will get feedback sooner after changes get committed. #. The computer you will be registering with the LLVM buildbot; infrastructure should have all dependencies installed and be able to; build your configuration successfully. Please check what degree; of parallelism (-j param) would give the fastest build. You can build; multiple configurations on one computer. #. Install buildbot-worker (currently we are using buildbot version 2.8.4).; This specific version can be installed using ``pip``, with a command such; as ``pip3 install buildbot-worker==2.8.4``. #. Create a designated user account, your buildbot-worker will be running under,; and set appropriate permissions. #. Choose the buildbot-worker root directory (all builds will be placed under; it), buildbot-worker access name and password the build master will be using; to authenticate your buildbot-worker. #. Create a buildbot-worker in context of that buildbot-worker account. Point it; to the **lab.llvm.org** port **9994** (see `Buildbot documentation,; Creating a worker; <http://docs.buildbot.net/current/tutorial/firstrun.html#creating-a-worker>`_; for more details) by running the following command:. .. code-block:: bash. $ buildbot-worker create-worker <buildbot-worker-root-directory> \; lab.llvm.org:9994 \; <buildbot-worker-access-name> \; <buildbot-worker-access-password>. Only once a new worker is stable, and; approval from Galina has been received (see last step) should it; be pointed at the main buildmaster. Now start the worker:. .. code-block:: bash. $ buildbot-worker start <buildbot-worker-root-directory>. This will cause your new worker to connect to the staging buildmaster; which is silent by default. Try this once then check the log file; ``<buildbot-worker-root-directory>/worke",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:3432,access,access,3432,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,3,"['access', 'authenticat', 'password']","['access', 'authenticate', 'password']"
Security,"to enable calling external functions.; If the library or its headers are installed in a custom; location, you can also set the variables FFI_INCLUDE_DIR and; FFI_LIBRARY_DIR to the directories where ffi.h and libffi.so can be found,; respectively. Defaults to OFF. **LLVM_ENABLE_IDE**:BOOL; Tell the build system that an IDE is being used. This in turn disables the; creation of certain convenience build system targets, such as the various; ``install-*`` and ``check-*`` targets, since IDEs don't always deal well with; a large number of targets. This is usually autodetected, but it can be; configured manually to explicitly control the generation of those targets. **LLVM_ENABLE_LIBCXX**:BOOL; If the host compiler and linker supports the stdlib flag, -stdlib=libc++ is; passed to invocations of both so that the project is built using libc++; instead of stdlibc++. Defaults to OFF. **LLVM_ENABLE_LLVM_LIBC**: BOOL; If the LLVM libc overlay is installed in a location where the host linker; can access it, all built executables will be linked against the LLVM libc; overlay before linking against the system libc. Defaults to OFF. **LLVM_ENABLE_LIBPFM**:BOOL; Enable building with libpfm to support hardware counter measurements in LLVM; tools.; Defaults to ON. **LLVM_ENABLE_LLD**:BOOL; This option is equivalent to `-DLLVM_USE_LINKER=lld`, except during a 2-stage; build where a dependency is added from the first stage to the second ensuring; that lld is built before stage2 begins. **LLVM_ENABLE_LTO**:STRING; Add ``-flto`` or ``-flto=`` flags to the compile and link command; lines, enabling link-time optimization. Possible values are ``Off``,; ``On``, ``Thin`` and ``Full``. Defaults to OFF. **LLVM_ENABLE_MODULES**:BOOL; Compile with `Clang Header Modules; <https://clang.llvm.org/docs/Modules.html>`_. **LLVM_ENABLE_PEDANTIC**:BOOL; Enable pedantic mode. This disables compiler-specific extensions, if; possible. Defaults to ON. **LLVM_ENABLE_PIC**:BOOL; Add the ``-fPIC`` flag to the comp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:22822,access,access,22822,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['access'],['access']
Security,"to get the animation effect. The option provided to all track-drawing methods can trigger different; track selections:. `default: `A track (or all primary tracks) drawn without daughters. `/D:` Track and first level descendents only are drawn. `/*: ` Track and all descendents are drawn. `/Ntype:` All tracks having `name=type` are drawn. Generally several options can be concatenated in the same string (E.g.; `""/D /Npion-""`). For animating tracks, additional options can be added:. `/G:`Geometry animate. Generally when drawing or animating tracks, one; has to first perform a normal drawing of the geometry as convenient. The; tracks will be drawn over the geometry. The geometry itself will be; animated (camera moving and rotating in order to ""catch"" the majority of; current track segments.). `/S:`Save all frames in gif format in the current folder. This option; allows creating a movie based on individual frames. ## Checking the Geometry. Several checking methods are accessible from the context menu of volume; objects or of the manager class. They generally apply only to the; visible parts of the drawn geometry in order to ease geometry checking,; and their implementation is in the **`TGeoChecker`** class. The checking; package contains an overlap checker and several utility methods that; generally have visualization outputs. ### The Overlap Checker. An overlap is any region in the Euclidian space being contained by more; than one positioned volume. Due to the containment scheme used by the; modeller, all points inside a volume have to be also contained by the; mother therefore are overlapping in that sense. This category of; overlaps is ignored due to the fact that any such point is treated as; belonging to the deepest node in the hierarchy. ![Extruding volumes](pictures/030001DE.png). A volume containment region is in fact the result of the subtraction of; all daughters. On the other hand, there are two other categories of; overlaps that are considered illegal since th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:129378,access,accessible,129378,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['access'],['accessible']
Security,"to the '``llvm.instrprof.increment``' intrinsic, but it stores zero to; the profiling variable to signify that the function has been covered. We store; zero because this is more efficient on some targets. '``llvm.instrprof.value.profile``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.value.profile(ptr <name>, i64 <hash>,; i64 <value>, i32 <value_kind>,; i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.value.profile``' intrinsic can be emitted by a; frontend for use with instrumentation based profiling. This will be; lowered by the ``-instrprof`` pass to find out the target values,; instrumented expressions take in a program at runtime. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. ``name`` should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. It; is an error if ``hash`` differs between two instances of; ``llvm.instrprof.*`` that refer to the same name. The third argument is the value of the expression being profiled. The profiled; expression's value should be representable as an unsigned 64-bit value. The; fourth argument represents the kind of value profiling that is being done. The; supported value profiling kinds are enumerated through the; ``InstrProfValueKind`` type declared in the; ``<include/llvm/ProfileData/InstrProf.h>`` header file. The last argument is the; index of the instrumented expression within ``name``. It should be >= 0. Semantics:; """""""""""""""""""". This intrinsic represents the point where a call to a runtime routine; should be inserted for value profiling of target expressions. ``-instrprof``; pass will generate the appropriate data structures and replace the; ``llvm.instrprof.value.profile`` intrinsic with the call to the profile; runtime ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:531004,hash,hash,531004,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['hash'],['hash']
Security,"togram, -I. Display a bucket list histogram for dynamic symbol hash tables. .. option:: --elf-linker-options. Display the linker options section. .. option:: --elf-output-style=<value>. Format ELF information in the specified style. Valid options are ``LLVM``,; ``GNU``, and ``JSON``. ``LLVM`` output is an expanded and structured format.; ``GNU`` (the default) output mimics the equivalent GNU :program:`readelf`; output. ``JSON`` is JSON formatted output intended for machine consumption. .. option:: --extra-sym-info. Display extra information (section name) when showing symbols. .. option:: --section-groups, -g. Display section groups. .. option:: --expand-relocs. When used with :option:`--relocations`, display each relocation in an expanded; multi-line format. .. option:: --file-header, -h. Display file headers. .. option:: --gnu-hash-table. Display the GNU hash table for dynamic symbols. .. option:: --hash-symbols. Display the expanded hash table with dynamic symbol data. .. option:: --hash-table. Display the hash table for dynamic symbols. .. option:: --headers, -e. Equivalent to setting: :option:`--file-header`, :option:`--program-headers`,; and :option:`--sections`. .. option:: --help. Display a summary of command line options. .. option:: --hex-dump=<section[,section,...]>, -x. Display the specified section(s) as hexadecimal bytes. ``section`` may be a; section index or section name. .. option:: --memtag. Display information about memory tagging present in the binary. This includes; various memtag-specific dynamic entries, decoded global descriptor sections,; and decoded Android-specific ELF notes. .. option:: --needed-libs. Display the needed libraries. .. option:: --no-demangle. Do not display demangled symbol names in the output. On by default. .. option:: --notes, -n. Display all notes. .. option:: --pretty-print. When used with :option:`--elf-output-style`, JSON output will be formatted in; a more readable format. .. option:: --program-headers, --segments, -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst:2563,hash,hash-table,2563,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst,1,['hash'],['hash-table']
Security,"token to open the actual RNTuple dataset with, e.g., RDF or an RNTupleReader,; and it provides the `Merge(...)` interface for the `TFileMerger`. ### RPageSource / Sink; The page source and sink can read and write pages and clusters from and to a storage backend.; There are concrete class implementations for an RNTuple stored in a ROOT file (local or remote), and for an RNTuple stored in a DAOS object store.; There is a virtual page sink for buffered writes, which also groups pages of the same column before flushing them to disk.; There is a virtual page source for aligned friend datasets (horizontal data combination). Page sources and sinks do not operate entry-based but based on pages/indices of columns.; For instance, there is no API in the page sink to write an entry, but only to write pages of columns.; The higher-level APIs, e.g. `RField`, `REntry`, `RNTupleWriter`, take care of presenting the available data as entries where necessary. The page source also gives access to an `RNTupleDescriptor` through a read/write lock guard.; The `RNTupleDescriptor` owned by the page source changes only when new cluster meta-data are loaded.; The header and the cluster group summary information is stable throughout its lifetime (cf. format specification). ### R{NTuple,Field,Column,Cluster,...}Descriptor; The descriptor classes provide read-only access to the on-disk meta-data of an RNTuple.; The meta-data include the schema (fields and columns), information about clusters and the page locations.; The descriptor classes are closely related to the format specification. For normal read and write tasks, access to the descriptor is not necessary.; One notable exception is bulk reading, where the descriptor can be used to determine entry boundaries of clusters.; The descriptors are used internally, e.g. to build an RNTupleModel from the on-disk information.; The descriptors are also useful for inspection purposes. The descriptor classes contain a copy of the meta-data; they are not ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:6549,access,access,6549,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['access'],['access']
Security,tools-extra/unittests/clang-doc/HTMLGeneratorTest.cpp; clang-tools-extra/unittests/clang-doc/MDGeneratorTest.cpp; clang-tools-extra/unittests/clang-doc/MergeTest.cpp; clang-tools-extra/unittests/clang-doc/SerializeTest.cpp; clang-tools-extra/unittests/clang-doc/YAMLGeneratorTest.cpp; clang-tools-extra/unittests/clang-tidy/AddConstTest.cpp; clang-tools-extra/unittests/clang-tidy/ClangTidyDiagnosticConsumerTest.cpp; clang-tools-extra/unittests/clang-tidy/ClangTidyTest.h; clang-tools-extra/unittests/clang-tidy/DeclRefExprUtilsTest.cpp; clang-tools-extra/unittests/clang-tidy/GlobListTest.cpp; clang-tools-extra/unittests/clang-tidy/OptionsProviderTest.cpp; clang-tools-extra/unittests/clang-tidy/OverlappingReplacementsTest.cpp; clang-tools-extra/unittests/clang-tidy/ReadabilityModuleTest.cpp; clang-tools-extra/unittests/clang-tidy/TransformerClangTidyCheckTest.cpp; compiler-rt/include/sanitizer/linux_syscall_hooks.h; compiler-rt/include/sanitizer/memprof_interface.h; compiler-rt/include/sanitizer/netbsd_syscall_hooks.h; compiler-rt/include/xray/xray_interface.h; compiler-rt/include/xray/xray_log_interface.h; compiler-rt/lib/asan/asan_activation.h; compiler-rt/lib/asan/asan_lock.h; compiler-rt/lib/asan/asan_mapping.h; compiler-rt/lib/asan/asan_mapping_sparc64.h; compiler-rt/lib/asan/asan_rtl_static.cpp; compiler-rt/lib/asan/tests/asan_globals_test.cpp; compiler-rt/lib/builtins/fp_extend.h; compiler-rt/lib/builtins/fp_lib.h; compiler-rt/lib/builtins/fp_mode.h; compiler-rt/lib/builtins/fp_trunc.h; compiler-rt/lib/builtins/int_endianness.h; compiler-rt/lib/builtins/int_math.h; compiler-rt/lib/builtins/int_types.h; compiler-rt/lib/builtins/int_util.h; compiler-rt/lib/builtins/unwind-ehabi-helpers.h; compiler-rt/lib/builtins/ppc/DD.h; compiler-rt/lib/dfsan/dfsan_allocator.cpp; compiler-rt/lib/dfsan/dfsan_allocator.h; compiler-rt/lib/dfsan/dfsan_chained_origin_depot.cpp; compiler-rt/lib/dfsan/dfsan_chained_origin_depot.h; compiler-rt/lib/dfsan/dfsan_flags.h; compiler-rt/lib/dfsa,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:89537,sanitiz,sanitizer,89537,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['sanitiz'],['sanitizer']
Security,"tor operates in C++ mode, utilizing C++ reference types, while; ``-fbounds-safety`` does not currently support C++. This means LLDB’s expression; evaluator can only evaluate a subset of the ``-fbounds-safety`` language model.; Specifically, it’s capable of evaluating the wide pointers that already exist in; the source code. All other expressions are evaluated according to C/C++; semantics. C++ support; ===========. C++ has multiple options to write code in a bounds-safe manner, such as; following the bounds-safety core guidelines and/or using hardened libc++ along; with the `C++ Safe Buffer model; <https://discourse.llvm.org/t/rfc-c-buffer-hardening/65734>`_. However, these; techniques may require ABI changes and may not be applicable to code; interoperating with C. When the ABI of an existing program needs to be preserved; and for headers shared between C and C++, ``-fbounds-safety`` offers a potential; solution. ``-fbounds-safety`` is not currently supported in C++, but we believe the; general approach would be applicable for future efforts. Upstreaming plan; ================. Gradual updates with experimental flag; --------------------------------------. The upstreaming will take place as a series of smaller PRs and we will guard our; implementation with an experimental flag ``-fexperimental-bounds-safety`` until; the usable model is fully upstreamed. Once the model is ready for use, we will; expose the flag ``-fbounds-safety``. Possible patch sets; -------------------. * External bounds annotations and the (late) parsing logic.; * Internal bounds annotations (wide pointers) and their parsing logic.; * Clang code generation for wide pointers with debug information.; * Pointer cast semantics involving bounds annotations (this could be divided; into multiple sub-PRs).; * CFG analysis for pairs of related pointer and count assignments and the likes.; * Bounds check expressions in AST and the Clang code generation (this could also; be divided into multiple sub-PRs). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:11435,expose,expose,11435,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['expose'],['expose']
Security,"tors** denote types; that contain a sequence of other type descriptors, at known offsets. These; contained type descriptors can either be struct type descriptors themselves; or scalar type descriptors. **Access tags** are metadata nodes attached to load and store instructions.; Access tags use type descriptors to describe the *location* being accessed; in terms of the type system of the higher level language. Access tags are; tuples consisting of a base type, an access type and an offset. The base; type is a scalar type descriptor or a struct type descriptor, the access; type is a scalar type descriptor, and the offset is a constant integer. The access tag ``(BaseTy, AccessTy, Offset)`` can describe one of two; things:. * If ``BaseTy`` is a struct type, the tag describes a memory access (load; or store) of a value of type ``AccessTy`` contained in the struct type; ``BaseTy`` at offset ``Offset``. * If ``BaseTy`` is a scalar type, ``Offset`` must be 0 and ``BaseTy`` and; ``AccessTy`` must be the same; and the access tag describes a scalar; access with scalar type ``AccessTy``. We first define an ``ImmediateParent`` relation on ``(BaseTy, Offset)``; tuples this way:. * If ``BaseTy`` is a scalar type then ``ImmediateParent(BaseTy, 0)`` is; ``(ParentTy, 0)`` where ``ParentTy`` is the parent of the scalar type as; described in the TBAA metadata. ``ImmediateParent(BaseTy, Offset)`` is; undefined if ``Offset`` is non-zero. * If ``BaseTy`` is a struct type then ``ImmediateParent(BaseTy, Offset)``; is ``(NewTy, NewOffset)`` where ``NewTy`` is the type contained in; ``BaseTy`` at offset ``Offset`` and ``NewOffset`` is ``Offset`` adjusted; to be relative within that inner type. A memory access with an access tag ``(BaseTy1, AccessTy1, Offset1)``; aliases a memory access with an access tag ``(BaseTy2, AccessTy2,; Offset2)`` if either ``(BaseTy1, Offset1)`` is reachable from ``(Base2,; Offset2)`` via the ``Parent`` relation or vice versa. As a concrete example, the type descripto",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:275329,access,access,275329,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['access'],['access']
Security,"tory(cont); add_subdirectory(dictgen); add_subdirectory(foundation); add_subdirectory(gui); add_subdirectory(imt); add_subdirectory(meta); add_subdirectory(metacling); add_subdirectory(multiproc); add_subdirectory(newdelete); add_subdirectory(rint); add_subdirectory(testsupport); add_subdirectory(textinput); add_subdirectory(thread); add_subdirectory(zip); add_subdirectory(lzma); add_subdirectory(lz4); add_subdirectory(zstd). add_subdirectory(macosx); add_subdirectory(unix); add_subdirectory(winnt). #-------------------------------------------------------------------------------. if (libcxx AND NOT APPLE); # In case we use libcxx and glibc together there is a mismatch of the; # signatures of functions in the header wchar.h. This macro tweaks the; # header in rootcling resource directory to be compatible with the one from; # libc++.; target_compile_definitions(Core PRIVATE __CORRECT_ISO_CPP_WCHAR_H_PROTO); endif(). if(MSVC); # Definitions of MATH Macros (required in MathCore) like M_PI are only; # exposed on Windows after defining the _USE_MATH_DEFINES macro. By; # specifying it as a property for Core, we ensure that the macros are; # properly exposed when using Modules on Windows.; target_compile_definitions(Core PRIVATE _USE_MATH_DEFINES); endif(). # Inclusion of `complex.h` causes havoc: `complex` and `I` become CPP macros.; # Darwin's complex.h does not implement C11's __STDC_NO_COMPLEX__, use the; # header guard instead. This prevents inclusion of complex.h in Darwin.pcm.; # GCC <=5 has _COMPLEX_H but none of the others.; # __CLANG_STDATOMIC_H prevents inclusion of stdatomic in our Darwin.pcm: its; # macros cause conflics with boost.; target_compile_definitions(Core PRIVATE; __STDC_NO_COMPLEX__; __COMPLEX_H__; _COMPLEX_H. __CLANG_STDATOMIC_H; ). if (runtime_cxxmodules); list(APPEND core_implicit_modules ""-mSystemByproducts""); # Force generation of _Builtin_intrinsics from Core.; list(APPEND core_implicit_modules ""-m"" ""_Builtin_intrinsics"" ""-mByproduct"" ""_Builtin_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/CMakeLists.txt:2702,expose,exposed,2702,core/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/CMakeLists.txt,1,['expose'],['exposed']
Security,"tracing is a quite known drawing technique based on tracking rays; from the eye position through all pixels of a view port device. The; pixel color is derived from the properties of the first crossed surface,; according some illumination model and material optical properties. While; there are currently existing quite sophisticated ray tracing models,; `TGeo` is currently using a very simple approach where the light; source is matching the eye position (no shadows or back-tracing of the; reflected ray). In future we are considering providing a base class in; order to be able to derive more complex models. Due to the fact that the number of rays that have to be tracked matches; the size in pixels of the pad, the time required by this algorithm is; proportional to the pad size. On the other hand, the speed is quite; acceptable for the default ROOT pad size and the images produced by; using this technique have high quality. Since the algorithm is; practically using all navigation features, producing ray-traced pictures; is also a geometry validation check. Ray tracing can be activated at; volume level as the normal `Draw()`. \image html geometry013.jpg ""Ray-traced view in a pad"". ~~~{.cpp}; myVolume->Raytrace(); ~~~. Once ray-tracing a view, this can be zoomed or rotated as a usual one.; Objects on the screen are no longer highlighted when picking the; vertices but the corresponding volumes is still accessible. \anchor GP04ca; #### Clipping Ray-traced Images. A ray-traced view can be `clipped` with any shape known by the modeller.; This means that the region inside the clipping shape is subtracted from; the current drawn geometry (become invisible). In order to activate; clipping, one has to first define the clipping shape(s):. 1. `TGeoShape *clip1, *clip2, ...`; One might switch between several clipping shapes. Note that these; shapes are considered defined in the current `MARS`. Composite shapes; may be used.; 2. `gGeoManager->SetClippingShape(clip1);`; One can activat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:104678,validat,validation,104678,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['validat'],['validation']
Security,"transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. The; ``AliasAnalysis`` interface also exposes some helper methods which allow you to; get mod/ref information for arbitrary instructions. All ``AliasAnalysis`` interfaces require that in queries involving multiple; values, values which are not :ref:`constants <constants>` are all; defined within the same function. Representation of Pointers; --------------------------. Most importantly, the ``AliasAnalysis`` class provides several methods which are; used to query whether or not two memory objects alias, whether function calls; can modify or read a memory object, etc. For all of these queries, memory; objects are represented as a pair of their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a starting address and a size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:2421,expose,exposes,2421,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['expose'],['exposes']
Security,"trictions without causing incorrect results. `std::map`; ----------. C++'s ``map`` is an associative container similar to Python's ``dict``,; albeit one that has stronger type constraints.; A ``map`` can be instantiated from a ``dict`` (and types can be inferred) or; from a collection of ``pair`` mappings. .. code-block:: python. >>> from cppyy.gbl.std import map; >>> m = map[str, int](*(""one"", 1), (""two"", 2))) # type explicit, from pairs; >>> print(m); { ""one"" => 1, ""two"" => 2 }; >>> m = map({1: ""one"", 2: ""two""}) # type implicit, from dict; >>> type(m); <class cppyy.gbl.std.map<int,std::string> at 0x12d068d60>; >>> print(m); { 1 => ""one"", 2 => ""two"" }; >>>. `std::string`; -------------. Python's `str` is a unicode type since Python3, whereas ``std::string`` is; single-byte char-based.; Having the two correctly interact therefore deserves it's own; :doc:`chapter <strings>`. `std::tuple`; ------------. C++ ``tuple`` is supported but it should be noted that its use, and in; particular instantiating (heavily overloaded) ``get<>`` functions for member; access is inefficient.; They are really only meant for use when you have to pass a ``tuple`` to C++; code; and if returned from a C++ function, it is easier to simply unpack them.; In all other cases, prefer Python's builtin ``tuple``.; Example usage:. .. code-block:: python. >>> from cppyy.gbl.std import make_tuple, get; >>> t = make_tuple(1, '2', 5.); >>> print(t); <cppyy.gbl.std.tuple<int,std::string,double> object at 0x12033ee70>; >>> len(t); 3; >>> get[0](t) # access with templated std::get<>; 1; >>> get[1](t); b'2'; >>> get[2](t); 5.0; >>> a, b, c = t # unpack through iteration; >>> print(a, b, c); 1 2 5.0; >>>. .. rubric:: Footnotes. .. [#f1] The meaning of ""temporary"" differs between Python and C++: in a statement such as ``func(std.vector[int]((1, 2, 3)))``, there is no temporary as far as Python is concerned, even as there clearly is in the case of a similar statement in C++. Thus that call will succeed even if `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst:8550,access,access,8550,bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,1,['access'],['access']
Security,"tring GetModifiers() that translates from bit-flag; options back to perl-style option characters. For all functions that do actual matching replaced the default value; of 'Int_t nMatchMax' argument from 30 to 10. PCRE internals require; the index buffer to be 3-times the number of allowed matches. This; multiplication is now performed in individual functions and nMatchMax; is really the number of allowed matches. Two function calls in; TString passing this number explicitly have been updated. TPMERegexp. New sub-class of TPRegexp with API closer to PERL.; Supports main Perl operations using regular expressions (Match,; Substitute and Split). To retrieve the results one can simply use; operator[] returning a TString. New tutorial regexp_pme.C. Meta. Add a new TClass interface to be able to trigger the ""auto addition of object; to a TDirectory object"". If a class has a member function:; DirectoryAutoAdd(TDirectory*); it will now be accessible (when the dictionary is generated via rootcint; for now) via TClass::GetDirectoryAutoAdd which return a wrapper with the; signature:; void (*)(void *this_obj,TDirectory *where_to_add). Extend #pragma create TClass; to namespaces.; Enable autoloading of the cintdlls.; rlibmap now handles #pragma create TClass; statements. Cont. Support for std algorithms and iterators for ROOT collection classes by Anar.; The background is the following. While working on the PROOF code I found; that enumerating TList is an inconvenient and a long operation, I had to; write the same code all over the place and make duplications. I tried; to use STD algorithms with it, namely std::for_each, and failed.; I therefore decided to enable std::for_each algorithm for ROOT; Containers/Iterators by making as few as possible changes, without rewriting; iterators at all. Now with only two simple lines of code one is able to; iterate through a container:. TIter iter(&list);; for_each(iter.Begin(), TIter::End(), SEnumFunctor());. or. for_each(iter.Begin(), inter_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html:3211,access,accessible,3211,core/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html,1,['access'],['accessible']
Security,"trinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare ptr @llvm.objc.storeWeak(ptr, ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_storeWeak <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-storeweak>`_. Preserving Debug Information Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These intrinsics are used to carry certain debuginfo together with; IR-level operations. For example, it may be desirable to; know the structure/union name and the original user-level field; indices. Such information got lost in IR GetElementPtr instruction; since the IR types are different from debugInfo types and unions; are converted to structs in IR. '``llvm.preserve.array.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <ret_type>; @llvm.preserve.array.access.index.p0s_union.anons.p0a10s_union.anons(<type> base,; i32 dim,; i32 index). Overview:; """""""""""""""""". The '``llvm.preserve.array.access.index``' intrinsic returns the getelementptr address; based on array base ``base``, array dimension ``dim`` and the last access index ``index``; into the array. The return type ``ret_type`` is a pointer type to the array element.; The array ``dim`` and ``index`` are preserved which is more robust than; getelementptr instruction which may be subject to compiler transformation.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide array or pointer debuginfo type.; The metadata is a ``DICompositeType`` or ``DIDerivedType`` representing the; debuginfo version of ``type``. Arguments:; """""""""""""""""""". The ``base`` is the array base address. The ``dim`` is the array dimension.; The ``base`` is a pointer if ``dim`` equals 0.; The ``index`` is the last access index into the array or pointer. The ``base`` argument must be annotated with an :ref:`elementtype; <attr_elementtype>` attribute at the call-site. This attribute specifies the; getelementptr ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:972767,access,access,972767,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"ts allow for some implementation freedom to the ``ilist`` how to; allocate and store the sentinel. The corresponding policy is dictated by; ``ilist_traits<T>``. By default a ``T`` gets heap-allocated whenever the need; for a sentinel arises. While the default policy is sufficient in most cases, it may break down when; ``T`` does not provide a default constructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:70522,access,accessed,70522,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['accessed']
Security,"ts both have an; attribute spelled ``GNU<""interrupt"">``, but with different parsing and semantic; requirements. To support this feature, an attribute inheriting from; ``TargetSpecificAttribute`` may specify a ``ParseKind`` field. This field; should be the same value between all arguments sharing a spelling, and; corresponds to the parsed attribute's ``Kind`` enumerator. This allows; attributes to share a parsed attribute kind, but have distinct semantic; attribute classes. For instance, ``ParsedAttr`` is the shared; parsed attribute kind, but ARMInterruptAttr and MSP430InterruptAttr are the; semantic attributes generated. By default, attribute arguments are parsed in an evaluated context. If the; arguments for an attribute should be parsed in an unevaluated context (akin to; the way the argument to a ``sizeof`` expression is parsed), set; ``ParseArgumentsAsUnevaluated`` to ``1``. If additional functionality is desired for the semantic form of the attribute,; the ``AdditionalMembers`` field specifies code to be copied verbatim into the; semantic attribute class object, with ``public`` access. If two or more attributes cannot be used in combination on the same declaration; or statement, a ``MutualExclusions`` definition can be supplied to automatically; generate diagnostic code. This will disallow the attribute combinations; regardless of spellings used. Additionally, it will diagnose combinations within; the same attribute list, different attribute list, and redeclarations, as; appropriate. Boilerplate; ^^^^^^^^^^^; All semantic processing of declaration attributes happens in `lib/Sema/SemaDeclAttr.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/lib/Sema/SemaDeclAttr.cpp>`_,; and generally starts in the ``ProcessDeclAttribute()`` function. If the; attribute has the ``SimpleHandler`` field set to ``1`` then the function to; process the attribute will be automatically generated, and nothing needs to be; done here. Otherwise, write a new ``handleYourAttr()`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:141608,access,access,141608,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['access'],['access']
Security,"ts in a single checkout makes cross-project refactoring; naturally simple:. * New sub-projects can be trivially split out for better reuse and/or layering; (e.g., to allow libSupport and/or LIT to be used by runtimes without adding a; dependency on LLVM).; * Changing an API in LLVM and upgrading the sub-projects will always be done in; a single commit, designing away a common source of temporary build breakage.; * Moving code across sub-project (during refactoring for instance) in a single; commit enables accurate `git blame` when tracking code change history.; * Tooling based on `git grep` works natively across sub-projects, allowing to; easier find refactoring opportunities across projects (for example reusing a; datastructure initially in LLDB by moving it into libSupport).; * Having all the sources present encourages maintaining the other sub-projects; when changing API. Finally, the monorepo maintains the property of the existing SVN repository that; the sub-projects move synchronously, and a single revision number (or commit; hash) identifies the state of the development across all projects. .. _build_single_project:. Building a single sub-project; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Even though there is a single source tree, you are not required to build; all sub-projects together. It is trivial to configure builds for a single; sub-project. For example::. mkdir build && cd build; # Configure only LLVM (default); cmake path/to/monorepo; # Configure LLVM and lld; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=lld; # Configure LLVM and clang; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=clang. .. _git-svn-mirror:. Outstanding Questions; ---------------------. Read-only sub-project mirrors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. With the Monorepo, it is undecided whether the existing single-subproject; mirrors (e.g. https://git.llvm.org/git/compiler-rt.git) will continue to; be maintained. Read/write SVN bridge; ^^^^^^^^^^^^^^^^^^^^^. GitHub supports a read/write SVN bridge ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:9891,hash,hash,9891,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['hash'],['hash']
Security,"ts the required signature. ``` {.cpp}; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::HepThreeVector q(1,2,3);; XYZVector v3(q);; ```. #### Coordinate Accessors. All coordinate accessors are available through the class; `ROOT::Math::`**`DisplacementVector3D`**:. ``` {.cpp}; //returns cartesian components for the cartesian vector v1; v1.X(); v1.Y(); v1.Z();; //returns cylindrical components for the cartesian vector v1; v1.Rho(); v1.Eta(); v1.Phi();; //returns cartesian components for the cylindrical vector r2; r2.X(); r2.Y(); r2.Z(); ```. In addition, all the 3 coordinates of the vector can be retrieved with; the `GetCoordinates` method:. ``` {.cpp}; double d[3];; //fill d array with (x,y,z) components of v1; v1.GetCoordinates(d);; //fill d array with (r,eta,phi) components of r2; r2.GetCoordinates(d);; std::vector vc(3);; //fill std::vector with (x,y,z) components of v1; v1.GetCoordinates(vc.begin(),vc.end());; ```. See the reference documentation of; `ROOT::Math::`**`DisplacementVector3D`** for more details on all the; coordinate accessors. #### Setter Methods. One can set only all the three coordinates via:. ``` {.cpp}; v1.SetCoordinates(c1,c2,c3); // (x,y,z) for a XYZVector; r2.SetCoordinates(c1,c2,c3); // r,theta,phi for a Polar3DVector; r2.SetXYZ(x,y,z); // 3 cartesian components for Polar3DVector; ```. Single coordinate setter methods are available for the basic vector; coordinates, like `SetX()` for a **`XYZVector`** or `SetR()` for a polar; vector. Attempting to do a `SetX()` on a polar vector will not compile. ``` {.cpp}; XYZVector v1;; v1.SetX(1); //OK setting x for a Cartesian vector; Polar3DVector v2;; v2.SetX(1); //ERROR: cannot set X for a Polar vector.; //Method will not compile; v2.SetR(1); //OK setting r for a Polar vector; ```. In addition, there are setter methods from C arrays or iterator. ``` {.cpp}; double d[3] = {1.,2.,3.};; XYZVector v;; // set (x,y,z) components of v using values from d; v.SetCoordinates(d);; ```. or, for example, fro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:80643,access,accessors,80643,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['access'],['accessors']
Security,"ts. llvm.amdgcn.sdot8 Provides direct access to v_dot8_u32_u4 across targets which; support such instructions. This performs signed dot product; with two i32 operands (holding a vector of 8 4bit values), summed; with the third i32 operand. The i1 fourth operand is used to clamp; the output.; When applicable (i.e. no clamping / operand modifiers), this is lowered; into v_dot8c_i32_i4 for targets which support it.; RDNA3 does not offer v_dot8_i32_i4, and rather offers; v_dot4_i32_iu4 which has operands to hold the signedness of the; vector operands. Thus, this intrinsic lowers to the signed version; of this instruction for gfx11 targets. llvm.amdgcn.sudot4 Provides direct access to v_dot4_i32_iu8 on gfx11 targets. This performs; dot product with two i32 operands (holding a vector of 4 8bit values), summed; with the fifth i32 operand. The i1 sixth operand is used to clamp; the output. The i1s preceding the vector operands decide the signedness. llvm.amdgcn.sudot8 Provides direct access to v_dot8_i32_iu4 on gfx11 targets. This performs; dot product with two i32 operands (holding a vector of 8 4bit values), summed; with the fifth i32 operand. The i1 sixth operand is used to clamp; the output. The i1s preceding the vector operands decide the signedness. llvm.amdgcn.sched_barrier Controls the types of instructions that may be allowed to cross the intrinsic; during instruction scheduling. The parameter is a mask for the instruction types; that can cross the intrinsic. - 0x0000: No instructions may be scheduled across sched_barrier.; - 0x0001: All, non-memory, non-side-effect producing instructions may be; scheduled across sched_barrier, *i.e.* allow ALU instructions to pass.; - 0x0002: VALU instructions may be scheduled across sched_barrier.; - 0x0004: SALU instructions may be scheduled across sched_barrier.; - 0x0008: MFMA/WMMA instructions may be scheduled across sched_barrier.; - 0x0010: All VMEM instructions may be scheduled across sched_barrier.; - 0x0020: VMEM read ins",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:41958,access,access,41958,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"ts::; :local:. Introduction; ============. This document describes the CommandLine argument processing library. It will; show you how to use it, and what it can do. The CommandLine library uses a; declarative approach to specifying the command line options that your program; takes. By default, these options declarations implicitly hold the value parsed; for the option declared (of course this `can be changed`_). Although there are a **lot** of command line argument parsing libraries out; there in many different languages, none of them fit well with what I needed. By; looking at the features and problems of other libraries, I designed the; CommandLine library to have the following features:. #. Speed: The CommandLine library is very quick and uses little resources. The; parsing time of the library is directly proportional to the number of; arguments parsed, not the number of options recognized. Additionally,; command line argument values are captured transparently into user defined; global variables, which can be accessed like any other variable (and with the; same performance). #. Type Safe: As a user of CommandLine, you don't have to worry about; remembering the type of arguments that you want (is it an int? a string? a; bool? an enum?) and keep casting it around. Not only does this help prevent; error prone constructs, it also leads to dramatically cleaner source code. #. No subclasses required: To use CommandLine, you instantiate variables that; correspond to the arguments that you would like to capture, you don't; subclass a parser. This means that you don't have to write **any**; boilerplate code. #. Globally accessible: Libraries can specify command line arguments that are; automatically enabled in any tool that links to the library. This is; possible because the application doesn't have to keep a list of arguments to; pass to the parser. This also makes supporting `dynamically loaded options`_; trivial. #. Cleaner: CommandLine supports enum and other types di",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:1133,access,accessed,1133,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['access'],['accessed']
Security,"ts; are accessed as negative offsets relative to ``DW_AT_frame_base``, and the; local variables and register spill slots are accessed as positive offsets; relative to ``DW_AT_frame_base``. 5. Function argument passing is implemented by copying the input physical; registers to virtual registers on entry. The register allocator can spill if; necessary. These are copied back to physical registers at call sites. The; net effect is that each function call can have these values in entirely; distinct locations. The IPRA can help avoid shuffling argument registers.; 6. Call sites are implemented by setting up the arguments at positive offsets; from SP. Then SP is incremented to account for the known frame size before; the call and decremented after the call. .. note::. The CFI will reflect the changed calculation needed to compute the CFA; from SP. 7. 4 byte spill slots are used in the stack frame. One slot is allocated for an; emergency spill slot. Buffer instructions are used for stack accesses and; not the ``flat_scratch`` instruction. .. TODO::. Explain when the emergency spill slot is used. .. TODO::. Possible broken issues:. - Stack arguments must be aligned to required alignment.; - Stack is aligned to max(16, max formal argument alignment); - Direct argument < 64 bits should check register budget.; - Register budget calculation should respect ``inreg`` for SGPR.; - SGPR overflow is not handled.; - struct with 1 member unpeeling is not checking size of member.; - ``sret`` is after ``this`` pointer.; - Caller is not implementing stack realignment: need an extra pointer.; - Should say AMDGPU passes FP rather than SP.; - Should CFI define CFA as address of locals or arguments. Difference is; apparent when have implemented dynamic alignment.; - If ``SCRATCH`` instruction could allow negative offsets, then can make FP be; highest address of stack frame and use negative offset for locals. Would; allow SP to be the same as FP and could support signal-handler-like as now; hav",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:400003,access,accesses,400003,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accesses']
Security,"ts; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:78952,hash,hash,78952,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,2,"['access', 'hash']","['access', 'hash']"
Security,"turn 0;; }. void previous_call_invalidation() {; char *p, *pp;. p = getenv(""VAR"");; setenv(""SOMEVAR"", ""VALUE"", /*overwrite = */1);; // call to 'setenv' may invalidate p. *p;; // dereferencing invalid pointer; }. The ``InvalidatingGetEnv`` option is available for treating ``getenv`` calls as; invalidating. When enabled, the checker issues a warning if ``getenv`` is called; multiple times and their results are used without first creating a copy.; This level of strictness might be considered overly pedantic for the commonly; used ``getenv`` implementations. To enable this option, use:; ``-analyzer-config security.cert.env.InvalidPtr:InvalidatingGetEnv=true``. By default, this option is set to *false*. When this option is enabled, warnings will be generated for scenarios like the; following:. .. code-block:: c. char* p = getenv(""VAR"");; char* pp = getenv(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:22294,secur,security,22294,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security']
Security,"turn since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU the kernarg backing memory is allocated in host memory accessed as; MTYPE UC (uncached) to avoid needing to invalidate the L2 cache. This also; causes it to be treated as non-volatile and so is not invalidated by; ``*_vol``.; * On APU the kernarg backing memory it is accessed as MTYPE CC (cache coherent); and so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX6-GFX9 are defined; in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table`. .. table:: AMDHSA Memory Model Code Sequences GFX6-GFX9; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table. ============ ============ ============== ========== ================================; LLVM Instr LLVM Memory LLVM Memory AMDGPU AMDGPU Machine Code; Ordering Sync Scope Address GFX6-GFX9; Space; ============ ============ ============== ========== ================================; **Non-Atomic**; ------------------------------------------------------------------------------------; load *none* *none* - global - !volatile & !nontemporal; - generic; - private 1. buffer/global/flat_load; - constant; - !volatile & nontemporal. 1. buffer/g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:211128,access,accessed,211128,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"turned,; if it is either a builtin type (int, long, float, double, and; `const char*` are supported), a Python type that can cross, or a ROOT; type. If a ROOT type is returned, an explicit cast to void\* is needed; to assign the return value to a local pointer (which may have a; different type), whereas builtin types will be cast implicitly, if; possible, to the type of the local variable to which they are assigned. `Bind(TObject* obj,const char* label)` - transfer a ROOT object from the; Cling to the Python interpreter, where it will be referenced with a; variable called ""`label`"". `Prompt()` - Transfer the interactive prompt to Python. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first with `gSystem->Load()` before use. Refer back to the other; example of the use of **`TPython`** that was given in ""Access to Python; from ROOT"". To show in detail how Python access can be used, an example Python; module is needed, as follows:. ``` {.cpp}; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; ```. This module can now be loaded into a Cling session, the class used to; instantiate objects, and their member functions called for showing how; different types can cross:. ``` {.cpp}; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; ```. Note that the `LoadMacro()` call makes the class automatically; available, such that it can be used directly. Otherwise, a; `gROOT->GetClass()` call is required first. #### Callbacks. The simplest way of setting a callback to Python from Cling, e.g. for a; button, is by providing the execution string. See for example; `tutorials/pyroot/demo.py` that comes with the ROOT installation:. ```",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:17546,access,access,17546,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['access'],['access']
Security,"ty Group to decide if such backporting should be done, and how far back.; * The Security Group figures out how the LLVM project’s own releases, as well as individual vendors’ releases, can be timed to patch the issue simultaneously.; * Embargo date can be delayed or pulled forward at the Security Group’s discretion.; * The issue champion obtains a CVE entry from MITRE_.; * Once the embargo expires, the patch is posted publicly according to LLVM’s usual code review process.; * All security issues (as well as nomination / removal discussions) become public within approximately fourteen weeks of the fix landing in the LLVM repository. Precautions should be taken to avoid disclosing particularly sensitive data included in the report (e.g. username and password pairs). Changes to the Policy; =====================. The LLVM Security Policy may be changed by majority vote of the LLVM Security Group. Such changes also need to be approved by the LLVM Board. What is considered a security issue?; ====================================. The LLVM Project has a significant amount of code, and not all of it is; considered security-sensitive. This is particularly true because LLVM is used in; a wide variety of circumstances: there are different threat models, untrusted; inputs differ, and the environment LLVM runs in is varied. Therefore, what the; LLVM Project considers a security issue is what its members have signed up to; maintain securely. As this security process matures, members of the LLVM community can propose that; a part of the codebase be designated as security-sensitive (or no longer; security-sensitive). This requires a rationale, and buy-in from the LLVM; community as for any RFC. In some cases, parts of the codebase could be handled; as security-sensitive but need significant work to get to the stage where that's; manageable. The LLVM community will need to decide whether it wants to invest in; making these parts of the code securable, and maintain these security; pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:14011,secur,security,14011,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security']
Security,"ty issue. An embargo may be lifted before the agreed-upon date if all vendors planning to ship a fix have already done so, and if the reporter does not object. Collaboration; -------------. Members of the LLVM Security Group are expected to:. * Promptly share any LLVM vulnerabilities they become aware of.; * Volunteer to drive issues forward.; * Help evaluate the severity of incoming issues.; * Help write and review patches to address security issues.; * Participate in the member nomination and removal processes. Discussion Medium; =================. *FUTURE*: this section needs more work! Where discussions occur is influenced by other factors that are still open in this document. We can finalize it later.; It seems like bugzilla and email don't meet security requirements. The medium used to host LLVM Security Group discussions is security-sensitive. It should therefore run on infrastructure which can meet our security expectations. We are currently using the `chromium issue tracker`_ (as the `llvm` project) to have security discussions:. * File security issues.; * Discuss security improvements to LLVM. When a new issue is filed, a template is provided to help issue reporters provide all relevant information. *FUTURE*: The `Github security`_ workflow allows publicly disclosing resolved security issues on the github project page, and we would be interested in adopting it for that purpose. However, it does not easily allow confidential reporting of security issues, as creating Github Security Advisories is currently restricted to Github project admins. That is why we have started with the `chromium issue tracker`_ instead. We also occasionally need to discuss logistics of the LLVM Security Group itself:. * Nominate new members.; * Propose member removal.; * Suggest policy changes. We often have these discussions publicly, in our :ref:`monthly public sync-up call <online-sync-ups>` and on the Discourse forums. For internal or confidential discussions, we also use a pri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:11041,secur,security,11041,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security']
Security,"ty. The ``#include`` mechanism works just fine. No Exposed Functions; --------------------. Any functions defined by system libraries (i.e. not defined by ``lib/Support``); must not be exposed through the ``lib/Support`` interface, even if the header; file for that function is not exposed. This prevents inadvertent use of system; specific functionality. For example, the ``stat`` system call is notorious for having variations in the; data it provides. ``lib/Support`` must not declare ``stat`` nor allow it to be; declared. Instead it should provide its own interface to discovering; information about files and directories. Those interfaces may be implemented in; terms of ``stat`` but that is strictly an implementation detail. The interface; provided by the Support Library must be implemented on all platforms (even; those without ``stat``). No Exposed Data; ---------------. Any data defined by system libraries (i.e. not defined by ``lib/Support``) must; not be exposed through the ``lib/Support`` interface, even if the header file; for that function is not exposed. As with functions, this prevents inadvertent; use of data that might not exist on all platforms. Minimize Soft Errors; --------------------. Operating system interfaces will generally provide error results for every; little thing that could go wrong. In almost all cases, you can divide these; error results into two groups: normal/good/soft and abnormal/bad/hard. That is,; some of the errors are simply information like ""file not found"", ""insufficient; privileges"", etc. while other errors are much harder like ""out of space"", ""bad; disk sector"", or ""system call interrupted"". We'll call the first group ""*soft*""; errors and the second group ""*hard*"" errors. ``lib/Support`` must always attempt to minimize soft errors. This is a design; requirement because the minimization of soft errors can affect the granularity; and the nature of the interface. In general, if you find that you're wanting to; throw soft errors, you ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:7006,expose,exposed,7006,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,2,['expose'],['exposed']
Security,"u can build; multiple configurations on one computer. #. Install buildbot-worker (currently we are using buildbot version 2.8.4).; This specific version can be installed using ``pip``, with a command such; as ``pip3 install buildbot-worker==2.8.4``. #. Create a designated user account, your buildbot-worker will be running under,; and set appropriate permissions. #. Choose the buildbot-worker root directory (all builds will be placed under; it), buildbot-worker access name and password the build master will be using; to authenticate your buildbot-worker. #. Create a buildbot-worker in context of that buildbot-worker account. Point it; to the **lab.llvm.org** port **9994** (see `Buildbot documentation,; Creating a worker; <http://docs.buildbot.net/current/tutorial/firstrun.html#creating-a-worker>`_; for more details) by running the following command:. .. code-block:: bash. $ buildbot-worker create-worker <buildbot-worker-root-directory> \; lab.llvm.org:9994 \; <buildbot-worker-access-name> \; <buildbot-worker-access-password>. Only once a new worker is stable, and; approval from Galina has been received (see last step) should it; be pointed at the main buildmaster. Now start the worker:. .. code-block:: bash. $ buildbot-worker start <buildbot-worker-root-directory>. This will cause your new worker to connect to the staging buildmaster; which is silent by default. Try this once then check the log file; ``<buildbot-worker-root-directory>/worker/twistd.log``. If your settings; are correct you will see a refused connection. This is good and expected,; as the credentials have not been established on both ends. Now stop the; worker and proceed to the next steps. #. Fill the buildbot-worker description and admin name/e-mail. Here is an; example of the buildbot-worker description::. Windows 7 x64; Core i7 (2.66GHz), 16GB of RAM. g++.exe (TDM-1 mingw32) 4.4.0; GNU Binutils 2.19.1; cmake version 2.8.4; Microsoft(R) 32-bit C/C++ Optimizing Compiler Version 16.00.40219.01 for 80x8",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:3957,access,access-name,3957,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,2,['access'],"['access-name', 'access-password']"
Security,"u must give the recipients all the rights that we gave; you. You must make sure that they, too, receive or can get the source; code. If you link other code with the library, you must provide; complete object files to the recipients, so that they can relink them; with the library after making changes to the library and recompiling; it. And you must show them these terms so they know their rights. We protect your rights with a two-step method: (1) we copyright the; library, and (2) we offer you this license, which gives you legal; permission to copy, distribute and/or modify the library. To protect each distributor, we want to make it very clear that; there is no warranty for the free library. Also, if the library is; modified by someone else and passed on, the recipients should know; that what they have is not the original version, so that the original; author's reputation will not be affected by problems that might be; introduced by others.; ; Finally, software patents pose a constant threat to the existence of; any free program. We wish to make sure that a company cannot; effectively restrict the users of a free program by obtaining a; restrictive license from a patent holder. Therefore, we insist that; any patent license obtained for a version of the library must be; consistent with the full freedom of use specified in this license. Most GNU software, including some libraries, is covered by the; ordinary GNU General Public License. This license, the GNU Lesser; General Public License, applies to certain designated libraries, and; is quite different from the ordinary General Public License. We use; this license for certain libraries in order to permit linking those; libraries into non-free programs. When a program is linked with a library, whether statically or using; a shared library, the combination of the two is legally speaking a; combined work, a derivative of the original library. The ordinary; General Public License therefore permits such linking only if th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt:2957,threat,threat,2957,LGPL2_1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt,1,['threat'],['threat']
Security,"ual destructor in their base class. .. code-block:: cpp. class NonVirtual {};; class NVDerived : public NonVirtual {};. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void foo() {; NonVirtual *x = create();; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. .. _alpha-cplusplus-InvalidatedIterator:. alpha.cplusplus.InvalidatedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of invalidated iterators. .. code-block:: cpp. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. .. _alpha-cplusplus-IteratorRange:. alpha.cplusplus.IteratorRange (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for iterators used outside their valid ranges. .. code-block:: cpp. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. .. _alpha-cplusplus-MismatchedIterator:. alpha.cplusplus.MismatchedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of iterators of different containers where iterators of the same container are expected. .. code-block:: cpp. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin(), v2.cbegin(), v1.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; }. .. _alpha-cplusplus-MisusedMovedObject:. alpha.cplusplus.MisusedMovedObject (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Method calls on a moved-from object and copying a moved-from object will be reported. .. code-block:: cpp. struct A {; v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:54496,access,accessed,54496,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['access'],['accessed']
Security,"ub.com/llvm/llvm-project/issues/75426>`_); - Fix an issue where clang cannot find conversion function with template; parameter when instantiation of template class.; Fixes (`#77583 <https://github.com/llvm/llvm-project/issues/77583>`_); - Fix an issue where CTAD fails for function-type/array-type arguments.; Fixes (`#51710 <https://github.com/llvm/llvm-project/issues/51710>`_); - Fix crashes when using the binding decl from an invalid structured binding.; Fixes (`#67495 <https://github.com/llvm/llvm-project/issues/67495>`_) and; (`#72198 <https://github.com/llvm/llvm-project/issues/72198>`_); - Fix assertion failure when call noreturn-attribute function with musttail; attribute.; Fixes (`#76631 <https://github.com/llvm/llvm-project/issues/76631>`_); - The MS ``__noop`` builtin without an argument list is now accepted; in the placement-args of new-expressions, matching MSVC's behaviour.; - Fix an issue that caused MS ``__decspec(property)`` accesses as well as; Objective-C++ property accesses to not be converted to a function call; to the getter in the placement-args of new-expressions.; Fixes (`#65053 <https://github.com/llvm/llvm-project/issues/65053>`_); - Fix an issue with missing symbol definitions when the first coroutine; statement appears in a discarded ``if constexpr`` branch.; Fixes (`#78290 <https://github.com/llvm/llvm-project/issues/78290>`_); - Fixed assertion failure with deleted overloaded unary operators.; Fixes (`#78314 <https://github.com/llvm/llvm-project/issues/78314>`_); - The XCOFF object file format does not support aliases to symbols having common; linkage. Clang now diagnoses the use of an alias for a common symbol when; compiling for AIX. - Clang now doesn't produce false-positive warning `-Wconstant-logical-operand`; for logical operators in C23.; Fixes (`#64356 <https://github.com/llvm/llvm-project/issues/64356>`_).; - Clang's ``-Wshadow`` no longer warns when an init-capture is named the same as; a class field unless the lambda can captu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:45105,access,accesses,45105,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,2,['access'],['accesses']
Security,"uc.edu>; Subject: another thought. I have a budding idea about making LLVM a little more ambitious: a; customizable runtime system that can be used to implement language-specific; virtual machines for many different languages. E.g., a C vm, a C++ vm, a; Java vm, a Lisp vm, .. The idea would be that LLVM would provide a standard set of runtime features; (some low-level like standard assembly instructions with code generation and; static and runtime optimization; some higher-level like type-safety and; perhaps a garbage collection library). Each language vm would select the; runtime features needed for that language, extending or customizing them as; needed. Most of the machine-dependent code-generation and optimization; features as well as low-level machine-independent optimizations (like PRE); could be provided by LLVM and should be sufficient for any language,; simplifying the language compiler. (This would also help interoperability; between languages.) Also, some or most of the higher-level; machine-independent features like type-safety and access safety should be; reusable by different languages, with minor extensions. The language; compiler could then focus on language-specific analyses and optimizations. The risk is that this sounds like a universal IR -- something that the; compiler community has tried and failed to develop for decades, and is; universally skeptical about. No matter what we say, we won't be able to; convince anyone that we have a universal IR that will work. We need to; think about whether LLVM is different or if has something novel that might; convince people. E.g., the idea of providing a package of separable; features that different languages select from. Also, using SSA with or; without type-safety as the intermediate representation. One interesting starting point would be to discuss how a JVM would be; implemented on top of LLVM a bit more. That might give us clues on how to; structure LLVM to support one or more language VMs. --Vikram. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt:1173,access,access,1173,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt,1,['access'],['access']
Security,"uckets in this hash table; uint32_t hashes_count; // The total number of unique hash values and hash data offsets in this table; uint32_t header_data_len; // The bytes to skip to get to the hash indexes (buckets) for correct alignment; // Specifically the length of the following HeaderData field - this does not; // include the size of the preceding fields; HeaderData header_data; // Implementation specific header data; };. The header starts with a 32 bit ""``magic``"" value which must be ``'HASH'``; encoded as an ASCII integer. This allows the detection of the start of the; hash table and also allows the table's byte order to be determined so the table; can be correctly extracted. The ""``magic``"" value is followed by a 16 bit; ``version`` number which allows the table to be revised and modified in the; future. The current version number is 1. ``hash_function`` is a ``uint16_t``; enumeration that specifies which hash function was used to produce this table.; The current values for the hash function enumerations include:. .. code-block:: c. enum HashFunctionType; {; eHashFunctionDJB = 0u, // Daniel J Bernstein hash function; };. ``bucket_count`` is a 32 bit unsigned integer that represents how many buckets; are in the ``BUCKETS`` array. ``hashes_count`` is the number of unique 32 bit; hash values that are in the ``HASHES`` array, and is the same number of offsets; are contained in the ``OFFSETS`` array. ``header_data_len`` specifies the size; in bytes of the ``HeaderData`` that is filled in by specialized versions of; this table. Fixed Lookup; """""""""""""""""""""""". The header is followed by the buckets, hashes, offsets, and hash value data. .. code-block:: c. struct FixedTable; {; uint32_t buckets[Header.bucket_count]; // An array of hash indexes into the ""hashes[]"" array below; uint32_t hashes [Header.hashes_count]; // Every unique 32 bit hash for the entire table is in this table; uint32_t offsets[Header.hashes_count]; // An offset that corresponds to each item in the ""hashes[",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:69904,hash,hash,69904,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"ude/llvm/Support`` and implemented in; ``lib/Support`` for all supported platforms. Don't Expose System Headers; ---------------------------. The Support Library must shield LLVM from **all** system headers. To obtain; system level functionality, LLVM source must; ``#include ""llvm/Support/Thing.h""`` and nothing else. This means that; ``Thing.h`` cannot expose any system header files. This protects LLVM from; accidentally using system specific functionality and only allows it via; the ``lib/Support`` interface. Use Standard C Headers; ----------------------. The **standard** C headers (the ones beginning with ""c"") are allowed to be; exposed through the ``lib/Support`` interface. These headers and the things they; declare are considered to be platform agnostic. LLVM source files may include; them directly or obtain their inclusion through ``lib/Support`` interfaces. Use Standard C++ Headers; ------------------------. The **standard** C++ headers from the standard C++ library and standard; template library may be exposed through the ``lib/Support`` interface. These; headers and the things they declare are considered to be platform agnostic.; LLVM source files may include them or obtain their inclusion through; ``lib/Support`` interfaces. High Level Interface; --------------------. The entry points specified in the interface of ``lib/Support`` must be aimed at; completing some reasonably high level task needed by LLVM. We do not want to; simply wrap each operating system call. It would be preferable to wrap several; operating system calls that are always used in conjunction with one another by; LLVM. For example, consider what is needed to execute a program, wait for it to; complete, and return its result code. On Unix, this involves the following; operating system calls: ``getenv``, ``fork``, ``execve``, and ``wait``. The; correct thing for ``lib/Support`` to provide is a function, say; ``ExecuteProgramAndWait``, that implements the functionality completely. what; we d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:3667,expose,exposed,3667,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['expose'],['exposed']
Security,"uding internal linkage). As a result, global symbols do; not describe a mangled name *or* an address, since symbols with internal linkage; need not have any mangling at all, and also may not have an address. Thus, all; global symbols simply refer directly to the full symbol record via a module/offset; combination. Similarly to :ref:`public symbols <public_symbols>`, all global symbols are contained; in a single :doc:`Globals Stream <GlobalStream>`, which contains a hash table mapping; fully qualified name to the corresponding record in the globals stream (which as; mentioned, then contains information allowing one to locate the full record in the; corresponding module symbol stream). Note that a consequence and limitation of this design is that program-wide lookup; by anything other than an exact textually matching fully-qualified name of whatever; the compiler decided to emit is impractical. This differs from DWARF, where even; though we don't necessarily have O(1) lookup by basename within a given scope (including; O(1) scope, we at least have O(n) access within a given scope). .. important::; Program-wide lookup of names by anything other than an exact textually matching fully; qualified name is not possible. S_GDATA32; ^^^^^^^^^^. S_GTHREAD32 (0x1113); ^^^^^^^^^^^^^^^^^^^^. S_PROCREF (0x1125); ^^^^^^^^^^^^^^^^^^. S_LPROCREF (0x1127); ^^^^^^^^^^^^^^^^^^^. S_GMANDATA (0x111d); ^^^^^^^^^^^^^^^^^^^. .. _module_symbols:. Module Symbols; --------------. S_END (0x0006); ^^^^^^^^^^^^^^. S_FRAMEPROC (0x1012); ^^^^^^^^^^^^^^^^^^^^. S_OBJNAME (0x1101); ^^^^^^^^^^^^^^^^^^. S_THUNK32 (0x1102); ^^^^^^^^^^^^^^^^^^. S_BLOCK32 (0x1103); ^^^^^^^^^^^^^^^^^^. S_LABEL32 (0x1105); ^^^^^^^^^^^^^^^^^^. S_REGISTER (0x1106); ^^^^^^^^^^^^^^^^^^^. S_BPREL32 (0x110b); ^^^^^^^^^^^^^^^^^^. S_LPROC32 (0x110f); ^^^^^^^^^^^^^^^^^^. S_GPROC32 (0x1110); ^^^^^^^^^^^^^^^^^^. S_REGREL32 (0x1111); ^^^^^^^^^^^^^^^^^^^. S_COMPILE2 (0x1116); ^^^^^^^^^^^^^^^^^^^. S_UNAMESPACE (0x1124); ^^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst:4596,access,access,4596,interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst,1,['access'],['access']
Security,ues relating to TR 10176:2003; Unknown. 1106; C++11; Need more detail in nullptr keyword description; Unknown. 1107; C++11; Overload resolution for user-defined integer literals; Unknown. 1108; NAD; User-defined literals have not been implemented; Unknown. 1109; C++11; When is “use” a reference to the ODR meaning?; Unknown. 1110; NAD; Incomplete return type should be allowed in decltype operand; Unknown. 1111; C++11; Remove dual-scope lookup of member template names; Clang 3.2. 1112; C++11; constexpr variables should have internal linkage like const; Unknown. 1113; C++11; Linkage of namespace member of unnamed namespace; Partial. 1114; C++11; Incorrect use of placement new in example; Unknown. 1115; C++11; C-compatible alignment specification; Unknown. 1116; CD4; Aliasing of union members; Unknown. 1117; C++11; Incorrect note about xvalue member access expressions; Unknown. 1118; NAD; Implicit lambda capture via explicit copy constructor; Unknown. 1119; C++11; Missing case in description of member access ambiguity; Unknown. 1120; C++11; reinterpret_cast and void*; Unknown. 1121; C++11; Unnecessary ambiguity error in formation of pointer to member; Unknown. 1122; C++11; Circular definition of std::size_t; Unknown. 1123; C++11; Destructors should be noexcept by default; Unknown. 1124; NAD; Error in description of value category of pointer-to-member expression; Unknown. 1125; C++11; Unclear definition of “potential constant expression”; Unknown. 1126; C++11; constexpr functions in const initializers; Unknown. 1127; C++11; Overload resolution in constexpr functions; Unknown. 1128; C++11; attribute-specifiers in decl-specifier-seqs; Unknown. 1129; C++11; Default nothrow for constexpr functions; Unknown. 1130; C++11; Function parameter type adjustments and decltype; Unknown. 1131; C++11; Template aliases in elaborated-type-specifiers; Unknown. 1132; NAD; Keyword vs attribute for noreturn; Unknown. 1133; C++11; Keywords vs attributes for control of hiding and overriding; U,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:74216,access,access,74216,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['access'],['access']
Security,"uests. Some servers, such as Amazon's,; respond to such kind of requests with the whole file contents. Other; servers, such as Huawei's, respond with the exact partial content; requested. Therefore, I added the possibility of configuring the; behavior via the ROOT configuration file: the identity of the; servers known to correctly support multi-range requests is; configurable. If the server is known to support this feature, ROOT; will send multi-range requests, otherwise it will issue multiple; single-range GET requests, which is also the default behavior.; - currently the virtual host syntax:; ""s3://mybucket.s3.amazonaws.com/path/to/my/file"" is not supported; but can be added if this is considered useful. The TAS3File class will be removed and should not have been used; directly by users anyway as it was only accessed via the plugin manager; in TFile::Open(). ### New HTTP Server package. A new HTTP Server package has been introduced. The idea behind such server is to provide direct access to the data from a running ROOT application. Any object can be streamed when requested and delivered to the browser. ##### Starting HTTP server. To start http server, at any time create instance; of the **`THttpServer`** class like:. ``` {.cpp}; serv = new THttpServer(""http:8080"");; ```. This will start civetweb-based http server on port 8080.; Then, one should be able to open address ""http://localhost:8080""; in any modern browser and browse objects created in application. By default, the server can access files, canvases and histograms via gROOT. All such objects can be displayed with JSRootIO graphics. At any time one could register other objects with the command:. ``` {.cpp}; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; ```. If the object content is changing in the application, like for example histograms being continuously filled, one could enable the monitoring flag in the browser, then the object view will be regularly updated. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md:3147,access,access,3147,net/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md,1,['access'],['access']
Security,"ug"", emissionKind: FullDebug,; enums: !2, retainedTypes: !3, globals: !4, imports: !5,; macros: !6, dwoId: 0x0abcd). Compile unit descriptors provide the root scope for objects declared in a; specific compilation unit. File descriptors are defined using this scope. These; descriptors are collected by a named metadata node ``!llvm.dbg.cu``. They keep; track of global variables, type information, and imported entities (declarations; and namespaces). .. _DIFile:. DIFile; """""""""""". ``DIFile`` nodes represent files. The ``filename:`` can include slashes. .. code-block:: none. !0 = !DIFile(filename: ""path/to/file"", directory: ""/path/to/dir"",; checksumkind: CSK_MD5,; checksum: ""000102030405060708090a0b0c0d0e0f""). Files are sometimes used in ``scope:`` fields, and are the only valid target; for ``file:`` fields. The ``checksum:`` and ``checksumkind:`` fields are optional. If one of these; fields is present, then the other is required to be present as well. Valid; values for ``checksumkind:`` field are: {CSK_MD5, CSK_SHA1, CSK_SHA256}. .. _DIBasicType:. DIBasicType; """""""""""""""""""""". ``DIBasicType`` nodes represent primitive types, such as ``int``, ``bool`` and; ``float``. ``tag:`` defaults to ``DW_TAG_base_type``. .. code-block:: text. !0 = !DIBasicType(name: ""unsigned char"", size: 8, align: 8,; encoding: DW_ATE_unsigned_char); !1 = !DIBasicType(tag: DW_TAG_unspecified_type, name: ""decltype(nullptr)""). The ``encoding:`` describes the details of the type. Usually it's one of the; following:. .. code-block:: text. DW_ATE_address = 1; DW_ATE_boolean = 2; DW_ATE_float = 4; DW_ATE_signed = 5; DW_ATE_signed_char = 6; DW_ATE_unsigned = 7; DW_ATE_unsigned_char = 8. .. _DISubroutineType:. DISubroutineType; """""""""""""""""""""""""""""""". ``DISubroutineType`` nodes represent subroutine types. Their ``types:`` field; refers to a tuple; the first operand is the return type, while the rest are the; types of the formal arguments in order. If the first operand is ``null``, that; represents a function with no ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:247825,checksum,checksumkind,247825,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['checksum'],['checksumkind']
Security,"ugh arrays from module ``array`` (or any; other builtin-type array that implements the Python buffer interface, such; as numpy arrays) and a low-level view type from ``cppyy`` for returns and; variable access (that implements the buffer interface as well).; Out-of-bounds checking is limited to those cases where the size is known at; compile time.; Example:. .. code-block:: python. >>> from cppyy.gbl import Concrete; >>> from array import array; >>> c = Concrete(); >>> c.array_method(array('d', [1., 2., 3., 4.]), 4); 1 2 3 4; >>> c.m_data[4] # static size is 4, so out of bounds; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; IndexError: buffer index out of range; >>>. Arrays of arrays are supported through the C++ low-level view objects.; This only works well if sizes are known at compile time or can be inferred.; If sizes are not known, the size is set to a large integer (depending on the; array element size) to allow access.; It is then up to the developer not to access the array out-of-bounds.; There is limited support for arrays of instances, but those should be avoided; in C++ anyway:. .. code-block:: python. >>> cppyy.cppdef('std::string str_array[3][2] = {{""aa"", ""bb""}, {""cc"", ""dd""}, {""ee"", ""ff""}};'); True; >>> type(cppyy.gbl.str_array[0][1]); <class cppyy.gbl.std.string at 0x7fd650ccb650>; >>> cppyy.gbl.str_array[0][1]; 'bb'; >>> cppyy.gbl.str_array[4][0]; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; IndexError: tuple index out of range; >>>. `Pointers`; """""""""""""""""""". When the C++ code takes a pointer or reference type to a specific builtin; type (such as an ``unsigned int`` for example), then types need to match; exactly.; ``cppyy`` supports the types provided by the standard modules ``ctypes`` and; ``array`` for those cases.; Example of using a reference to builtin:. .. code-block:: python. >>> from ctypes import c_uint; >>> u = c_uint(0); >>> c.uint_ref_assign(u, 42); >>> u.value; 42; >>>. For objects, an o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst:4141,access,access,4141,bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,1,['access'],['access']
Security,"uilder->GetInsertBlock()->getParent();. // Create an alloca for the variable in the entry block.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);. // Emit the start code first, without 'variable' in scope.; Value *StartVal = Start->codegen();; if (!StartVal); return nullptr;. // Store the value into the alloca.; Builder->CreateStore(StartVal, Alloca);; ... // Compute the end condition.; Value *EndCond = End->codegen();; if (!EndCond); return nullptr;. // Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.; Value *CurVar = Builder->CreateLoad(Alloca->getAllocatedType(), Alloca,; VarName.c_str());; Value *NextVar = Builder->CreateFAdd(CurVar, StepVal, ""nextvar"");; Builder->CreateStore(NextVar, Alloca);; ... This code is virtually identical to the code `before we allowed mutable; variables <LangImpl05.html#code-generation-for-the-for-loop>`_. The big difference is that we; no longer have to construct a PHI node, and we use load/store to access; the variable as needed. To support mutable argument variables, we need to also make allocas for; them. The code for this is also pretty simple:. .. code-block:: c++. Function *FunctionAST::codegen() {; ...; Builder->SetInsertPoint(BB);. // Record the function arguments in the NamedValues map.; NamedValues.clear();; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. if (Value *RetVal = Body->codegen()) {; ... For each argument, we make an alloca, store the input value to the; function into the alloca, and register the alloca as the memory location; for the argument. This method gets invoked by ``FunctionAST::codegen()``; right after it sets up the entry block for the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:15471,access,access,15471,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['access'],['access']
Security,"uint8_t) {}""); True; >>> cppyy.gbl.somefunc(2**16); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; ValueError: void ::somefunc(uint8_t) =>; ValueError: could not convert argument 1 (integer to character: value 65536 not in range [0,255]); >>>. But if other overloads are present that fail in a different way, the error; report will be a ``TypeError``:. .. code-block:: python. >>> cppyy.cppdef(r""""""; ... void somefunc(uint8_t) {}; ... void somefunc(std::string) {}""""""); True; >>> cppyy.gbl.somefunc(2**16); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; TypeError: none of the 2 overloaded methods succeeded. Full details:; void ::somefunc(std::string) =>; TypeError: could not convert argument 1; void ::somefunc(uint8_t) =>; ValueError: could not convert argument 1 (integer to character: value 65536 not in range [0,255]); >>>. Since C++ exceptions are converted to Python ones, there is an interplay; possible between the two as part of overload resolution and ``cppyy``; allows C++ exceptions as such, enabling detailed type disambiguation and; input validation.; (The original use case was for filling database fields, requiring an exact; field label and data type match.). If, however, all methods fail and there is only one C++ exception (the other; exceptions originating from argument conversion, never succeeding to call; into C++), this C++ exception will be preferentially reported and will have; the original C++ type. `Return values`; ---------------. Most return types are readily amenable to automatic memory management: builtin; returns, by-value returns, (const-)reference returns to internal data, smart; pointers, etc.; The important exception is pointer returns.; ; A function that returns a pointer to an object over which Python should claim; ownership, should have its ``__creates__`` flag set through its; :doc:`pythonization <pythonizations>`.; Well-written APIs will have clear clues in their naming convention about the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst:11921,validat,validation,11921,bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,1,['validat'],['validation']
Security,"uint8_t> Data);. void BLAKE3::update(StringRef Str);; ```; ```c; void llvm_blake3_hasher_update(; llvm_blake3_hasher *self,; const void *input,; size_t input_len);; ```. Add input to the hasher. This can be called any number of times. ---. ```c++; template <size_t NumBytes = LLVM_BLAKE3_OUT_LEN>; using BLAKE3Result = std::array<uint8_t, NumBytes>;. template <size_t NumBytes = LLVM_BLAKE3_OUT_LEN>; void BLAKE3::final(BLAKE3Result<NumBytes> &Result);. template <size_t NumBytes = LLVM_BLAKE3_OUT_LEN>; BLAKE3Result<NumBytes> BLAKE3::final();; ```; ```c; void llvm_blake3_hasher_finalize(; const llvm_blake3_hasher *self,; uint8_t *out,; size_t out_len);; ```. Finalize the hasher and return an output of any length, given in bytes.; This doesn't modify the hasher itself, and it's possible to finalize; again after adding more input. The constant `LLVM_BLAKE3_OUT_LEN` provides; the default output length, 32 bytes, which is recommended for most; callers. Outputs shorter than the default length of 32 bytes (256 bits) provide; less security. An N-bit BLAKE3 output is intended to provide N bits of; first and second preimage resistance and N/2 bits of collision; resistance, for any N up to 256. Longer outputs don't provide any; additional security. Shorter BLAKE3 outputs are prefixes of longer ones. Explicitly; requesting a short output is equivalent to truncating the default-length; output. (Note that this is different between BLAKE2 and BLAKE3.). ## Less Common API Functions. ```c; void llvm_blake3_hasher_init_keyed(; llvm_blake3_hasher *self,; const uint8_t key[LLVM_BLAKE3_KEY_LEN]);; ```. Initialize a `llvm_blake3_hasher` in the keyed hashing mode. The key must be; exactly 32 bytes. ---. ```c; void llvm_blake3_hasher_init_derive_key(; llvm_blake3_hasher *self,; const char *context);; ```. Initialize a `llvm_blake3_hasher` in the key derivation mode. The context; string is given as an initialization parameter, and afterwards input key; material should be given with `llvm_blake3_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md:3784,secur,security,3784,interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,1,['secur'],['security']
Security,"uish them from positive bins.; ; In THistPainter::PaintH3 the palette is drawn in case of option; COLZ. This is useful when a TTree 4D plot is painted with that option.; ; This image has been prodiced with the command:; ntuple->Draw(""px:py:pz:px*px"","""",""COLZ"");. TGraph2D. The operator ""="" was not correct. TGraph. Protection added in PaintPolyLineHatches (division by zero in some; cases).; All the graphical code has been moved from the TGraph classes to; TGraphPainter. TGraphPolar. Protection added in case a GraphPolar is plotted with option; ""E"" but has no errors defined.; The markers clipping (in TGraphPainter) was wrong in case of TGraphPolar.; The constructor's parameters naming was wrong.; Documentation: better example (easier to understand).; In the constructors some data members were not initialized. TPie. Add the TPie::GetEntries() method that return the number slices.; (Guido Volpi).; Implement Editors for TPie and TPieSlice (Guido Volpi). TPaletteAxis. Attributes are now accessible in the context menu.; (requested by Mathieu de Naurois <denauroi@in2p3.fr>). TPolyLine. Implement the possibility to draw TPolyLine in NDC coordinates; (it was partially done but the code was not used). Documentation. Better comments in THelix.; Option ""FUNC"" was not documented in THistPainter..; Update the help for animated gif generation in TPad.; Update TAttMarker documentation about the non scalable markers.; Re-writting of the THistPainter documentation. TCutG. The graphical cuts applied on histograms did not work when the cut name; contained a mix of lower and upper case characters. This problem occured; because the option used to draw an histogram was always converted into; lower case before begin stored in a pad (in Draw and DrawCopy). Now in; Draw() and DrawCopy() the AppendPad() procedure is called with the option; string not converted in lower; case. QT; Version 3 of QT is not supported anymore. If you install ROOT with the QT option; you must have QT version 4 already ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v520/index.html:5376,access,accessible,5376,graf2d/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v520/index.html,1,['access'],['accessible']
Security,"uivalent and are instead made available by; mapping them onto the following conventional functions:. =================== ===================; C++ Python; =================== ===================; ``operator=`` ``__assign__``; ``operator++(int)`` ``__postinc__``; ``operator++()`` ``__preinc__``; ``operator--(int)`` ``__postdec__``; ``operator--()`` ``__predec__``; ``unary operator*`` ``__deref__``; ``operator->`` ``__follow__``; ``operator&&`` ``__dand__``; ``operator||`` ``__dor__``; ``operator,`` ``__comma__``; =================== ===================. Here is an example of operator usage, using STL iterators directly (note that; this is not necessary in practice as STL and STL-like containers work; transparently in Python for-loops):. .. code-block:: python. >>> v = cppyy.gbl.std.vector[int](range(3)); >>> i = v.begin(); >>> while (i != v.end()):; ... print(i.__deref__()); ... _ = i.__preinc__(); ...; 0; 1; 2; >>>. Overridden ``operator new`` and ``operator delete``, as well as their array; equivalents, are not accessible but will be called as appropriate. `Templates`; -----------. Templated classes are instantiated using square brackets.; (For backwards compatibility reasons, parentheses work as well.); The instantiation of a templated class yields a class, which can then; be used to create instances. Templated classes need not pre-exist in the bound code, just their; declaration needs to be available.; This is true for e.g. all of STL:. .. code-block:: python. >>> cppyy.gbl.std.vector # template metatype; <cppyy.Template 'std::vector' object at 0x7fffed2674d0>; >>> cppyy.gbl.std.vector(int) # instantiates template -> class; <class cppyy.gbl.std.vector<int> at 0x1532190>; cppyy.gbl.std.vector[int]() # instantiates class -> object; <cppyy.gbl.std.vector<int> object at 0x2341ec0>; >>>. The template arguments may be actual types or their names as a string,; whichever is more convenient.; Thus, the following are equivalent:. .. code-block:: python. >>> from cppyy.gbl.s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:11024,access,accessible,11024,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['access'],['accessible']
Security,"uld be submitted when; command is executed with cmd.json requests. Introduce restriction rules for objects access with THttpServer::Restrict() method.; Up to now general read-only flag was applied - either; everything read-only or everything is fully accessible.; Now one could restrict access to different parts of; objects hierarchy or even fully 'hide' them from the client.; Restriction based on user account name, which is applied; when htdigest authentication is configured.; One also able to allow execution of selected methods. Implement multi.bin and multi.json requests.; One could request many items with single HTTP request.; Let optimize communication between server and client. With *SNIFF* tag in ClassDef() comments one could expose different properties,; which than exposed by the TRootSniffer to the client with h.json requests.; Such possibility ease implementation of client-side code for custom classes. Allow to bind http port with loopback address.; This restrict access to http server only from localhost.; One could either specify 'loopback' option in constructor:; new THttpServer(""http:8080?loopback""); or in clear text specify IP address to which http socket should be bind:; new THttpServer(""http:127.0.0.1:8080""); If host has several network interfaces, one could select one for binding:; new THttpServer(""http:192.168.1.17:8080""). ### TNetXNGFileStager; Fixed ROOT-7703. This restores the behavior of Locate() to that found with; TXNetFileStager: Rather than return only the xrootd server's reply, the endpoint; hostname is looked up and Locate() returns the full url, including the path. ### TWebFile; Fixed ROOT-7809. Returns an error for a redirect which does not specify the new; URI, rather than going into a loop. Fixed ROOT-7817. Avoid a crash under some circumstances when trying to open an; invalid path. ## GUI Libraries. ## Montecarlo Libraries. ## Multi-processing. With this version we introduce a new module, core/multiproc, for multi-processing on multi-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:20074,access,access,20074,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['access'],['access']
Security,"uld set the ``ASTNode`` field to; ``0`` to avoid polluting the AST. Note that anything inheriting from; ``TypeAttr`` or ``IgnoredAttr`` automatically do not generate an AST node. All; other attributes generate an AST node by default. The AST node is the semantic; representation of the attribute. The ``LangOpts`` field specifies a list of language options required by the; attribute. For instance, all of the CUDA-specific attributes specify ``[CUDA]``; for the ``LangOpts`` field, and when the CUDA language option is not enabled, an; ""attribute ignored"" warning diagnostic is emitted. Since language options are; not table generated nodes, new language options must be created manually and; should specify the spelling used by ``LangOptions`` class. Custom accessors can be generated for an attribute based on the spelling list; for that attribute. For instance, if an attribute has two different spellings:; 'Foo' and 'Bar', accessors can be created:; ``[Accessor<""isFoo"", [GNU<""Foo"">]>, Accessor<""isBar"", [GNU<""Bar"">]>]``; These accessors will be generated on the semantic form of the attribute,; accepting no arguments and returning a ``bool``. Attributes that do not require custom semantic handling should set the; ``SemaHandler`` field to ``0``. Note that anything inheriting from; ``IgnoredAttr`` automatically do not get a semantic handler. All other; attributes are assumed to use a semantic handler by default. Attributes; without a semantic handler are not given a parsed attribute ``Kind`` enumerator. ""Simple"" attributes, that require no custom semantic processing aside from what; is automatically provided, should set the ``SimpleHandler`` field to ``1``. Target-specific attributes may share a spelling with other attributes in; different targets. For instance, the ARM and MSP430 targets both have an; attribute spelled ``GNU<""interrupt"">``, but with different parsing and semantic; requirements. To support this feature, an attribute inheriting from; ``TargetSpecificAttribute`` m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:139631,access,accessors,139631,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['access'],['accessors']
Security,"uld then compare any consecutive; 32 bit hashes values in the ``HASHES`` array as long as the hashes would be in; ``BUCKETS[3]``. We do this by verifying that each subsequent hash value modulo; ``n_buckets`` is still 3. In the case of a failed lookup we would access the; memory for ``BUCKETS[3]``, and then compare a few consecutive 32 bit hashes; before we know that we have no match. We don't end up marching through; multiple words of memory and we really keep the number of processor data cache; lines being accessed as small as possible. The string hash that is used for these lookup tables is the Daniel J.; Bernstein hash which is also used in the ELF ``GNU_HASH`` sections. It is a; very good hash for all kinds of names in programs with very few hash; collisions. Empty buckets are designated by using an invalid hash index of ``UINT32_MAX``. Details; ^^^^^^^. These name hash tables are designed to be generic where specializations of the; table get to define additional data that goes into the header (""``HeaderData``""),; how the string value is stored (""``KeyType``"") and the content of the data for each; hash value. Header Layout; """""""""""""""""""""""""". The header has a fixed part, and the specialized part. The exact format of the; header is:. .. code-block:: c. struct Header; {; uint32_t magic; // 'HASH' magic value to allow endian detection; uint16_t version; // Version number; uint16_t hash_function; // The hash function enumeration that was used; uint32_t bucket_count; // The number of buckets in this hash table; uint32_t hashes_count; // The total number of unique hash values and hash data offsets in this table; uint32_t header_data_len; // The bytes to skip to get to the hash indexes (buckets) for correct alignment; // Specifically the length of the following HeaderData field - this does not; // include the size of the preceding fields; HeaderData header_data; // Implementation specific header data; };. The header starts with a 32 bit ""``magic``"" value which must be ``'H",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:68284,hash,hash,68284,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,2,['hash'],['hash']
Security,"uld this be done? Just convert each function to a number, and gather; all of them in a special hash-table. Functions with equal hashes are equal.; Good hashing means, that every function part must be taken into account. That; means we have to convert every function part into some number, and then add it; into the hash. The lookup-up time would be small, but such an approach adds some; delay due to the hashing routine. Logarithmical search; """"""""""""""""""""""""""""""""""""""""; We could introduce total ordering among the functions set, once ordered we; could then implement a logarithmical search. Lookup time still depends on N,; but adds a little of delay (*log(N)*). Present state; """"""""""""""""""""""""""; Both of the approaches (random-access and logarithmical) have been implemented; and tested and both give a very good improvement. What was most; surprising is that logarithmical search was faster; sometimes by up to 15%. The; hashing method needs some extra CPU time, which is the main reason why it works; slower; in most cases, total ""hashing"" time is greater than total; ""logarithmical-search"" time. So, preference has been granted to the ""logarithmical search"". Though in the case of need, *logarithmical-search* (read ""total-ordering"") could; be used as a milestone on our way to the *random-access* implementation. Every comparison is based either on the numbers or on the flags comparison. In; the *random-access* approach, we could use the same comparison algorithm.; During comparison, we exit once we find the difference, but here we might have; to scan the whole function body every time (note, it could be slower). Like in; ""total-ordering"", we will track every number and flag, but instead of; comparison, we should get the numbers sequence and then create the hash number.; So, once again, *total-ordering* could be considered as a milestone for even; faster (in theory) random-access approach. MergeFunctions, main fields and runOnModule; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; There are tw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:6589,hash,hashing,6589,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,2,['hash'],['hashing']
Security,"uled for May 29, 2012. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Bertrand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU/ATLAS, RooStats,; Sven Kreiss, NYU/ATLAS, RooStats,; Gena Kukartsev, CERN and FNAL/CMS, ; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Christian Gumpert, CERN and University Dresden/ATLAS, Math,; Wim Lavrijsen, LBNL, PyRoot,; Sergei Linev, GSI,; Lorenzo Moneta, CERN/SFT,; Axel Naumann, CERN/SFT,; Eddy Offermann, Renaissance, ; Giovanni Petrucciani, UCSD/CMS, RooStats, ; Fons Rademakers, CERN/SFT,; Paul Russo, FNAL, ; Joerg Stelzer, DESY/Atlas, TMVA, ; Alja Tadel, UCSD/CMS, Eve, ; Matevz Tadel, UCSD/CMS, Eve, ; Eckhard von Toerne, University Bonn, ATLAS, TMVA, ; Wouter Verkerke, NIKHEF/Atlas, RooFit, ; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v532/index.html:1280,authenticat,authentication,1280,doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v532/index.html,1,['authenticat'],['authentication']
Security,"ules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`_). Moved checkers; ^^^^^^^^^^^^^^. - Move checker ``alpha.unix.Errno`` out of the ``alpha`` package; to ``unix.Errno``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-errno-c>`__. - Move checker ``alpha.unix.StdCLibraryFunctions`` out of the ``alpha`` package; to ``unix.StdCLibraryFunctions``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-stdclibraryfunctions-c>`__. - Move checker ``alpha.security.cert.env.InvalidPtr`` out of the ``alpha``; package to ``security.cert.env.InvalidPtr``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__. - Move checker ``alpha.cplusplus.EnumCastOutOfRange`` out of the ``alpha``; package to ``optin.core.EnumCastOutOfRange``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#optin-core-enumcastoutofrange-c-c>`__. .. _release-notes-sanitizers:. Sanitizers; ----------. - ``-fsanitize=signed-integer-overflow`` now instruments ``__builtin_abs`` and; ``abs`` builtins. Python Binding Changes; ----------------------. Additional Information; ======================. A wide variety of additional information is available on the `Clang web; page <https://clang.llvm.org/>`_. The web page contains versions of the; API documentation which are up-to-date with the Git version of; the source code. You can access versions of these documents specific to; this release by going into the ""``clang/docs/``"" directory in the Clang; tree. If you have any questions or comments about Clang, please feel free to; contact us on the `Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:77421,sanitiz,sanitizers,77421,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,2,"['access', 'sanitiz']","['access', 'sanitizers']"
Security,ull pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to comma expressions; Unknown. 463; CD1; reinterpret_cast<T*>(0); N/A. 464; CD1; Wording nit on lifetime of temporaries to which references are bound; N/A. 465; NAD; May constructors of global objects call exit()?; N/A. 466; CD1; cv-qualifiers on pseudo-destructor type; No. 467; NAD; Jump past initialization of local static variable; Yes. 468; CD1; Allow ::template outside of templates; Yes (C++11 onwards). 469; NAD; Const template specializations and reference arguments; No. 470; CD1; Instantiation of members of an explicitly-instantiated class template; Yes. 471; NAD; Conflicting inherited access specifications; Clang 2.8. 472; drafting; Casting across protected inheritance; Not resolved. 473; NAD; Block-scope declarations of allocator functions; Unknown. 474; CD1; Block-scope extern declarations in namespace members; Clang 3.4. 475; C++11; When is std::uncaught_exception() true? (take 2); Unknown. 476; CD5; Determining the buffer size for placement new; Unknown. 477; CD1; Can virtual appear in a friend declaration?; Clang 3.5. 478; NAD; May a function parameter be an array of an abstract class type?; Yes. 479; CD1; Copy elision in exception handling; Clang 2.8. 480; CD1; Is a base of a virtual base also virtual?; Yes. 481; CD2; Scope of template parameters; Clang 2.8. 482; CD3; Qualified declarators in redeclarations; Clang 3.5. 483; CD3; Normative requirements on integral ranges; Yes. 484; CD1; Can a base-specifier name a cv-qualified class type?; Yes. 485; CD1; What is a “name”?; Yes. 486; CD1; Invalid return types and template argument deduction; Yes. 487; NAD; Oper,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:32212,access,access,32212,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['access'],['access']
Security,"ult, civetweb web server with port number 8080 will be started.; It gets access to files, canvases and trees, registered in gROOT.; One additionally could register other objects to the server:. root [1] serv->Register(""abc/fold1"", hpx);; root [2] serv->Register(""abc/fold2"", hpxpy);; root [3] serv->Register(""extra"", c1);. Once server running, just open in any browser page: http://yourhost:8080. Example macro: $ROOTSYS/tutorials/http/httpserver.C. FAST CGI:. Instead of running http server, one could use fast cgi interface; to normal web server like Apache or lighttpd or any other.; When creating server, one could specify:. root [0] serv = new THttpServer(""fastcgi:9000"");. This opens port 9000, which should be specified in web server configuration.; For instance, lighttpd.conf file could contain path like this:. fastcgi.server = (; ""/remote_scripts/"" =>; (( ""host"" => ""192.168.1.10"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ). In this case one should be able to access root application via address. http://your_lighttpd_host/remote_scripts/root.cgi/. AUTHOR:. Sergey Linev, S.Linev@gsi.de. CHANGES:. January 2015; - Provide exe.json request to execute arbitrary object method and return; result in JSON format. Server should run in non-readonly mode. Fall 2014; - Implement gzip for result of any submitted requests, automatically done ; when .gz extension is provided; - Provide access to arbitrary data member of objects, registered to the server; - Prevent data caching in the browser by setting no-cache header. April 2014; - In TCivetweb class support digest authentication method. User; can specify auth_file and auth_domain parameters to protect; access to the server; - Fix error in FastCgi, now correctly works with Apache; - Avoid direct usage of TASImage. March 2014; - Replace mongoose by civetweb due to more liberal MIT license.; Works out of the box while civetweb version fully corresponds to; previously used version of mongoose.; - Introduce TB",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt:1155,access,access,1155,net/http/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt,1,['access'],['access']
Security,"ults. `std::map`; ----------. C++'s ``map`` is an associative container similar to Python's ``dict``,; albeit one that has stronger type constraints.; A ``map`` can be instantiated from a ``dict`` (and types can be inferred) or; from a collection of ``pair`` mappings. .. code-block:: python. >>> from cppyy.gbl.std import map; >>> m = map[str, int](*(""one"", 1), (""two"", 2))) # type explicit, from pairs; >>> print(m); { ""one"" => 1, ""two"" => 2 }; >>> m = map({1: ""one"", 2: ""two""}) # type implicit, from dict; >>> type(m); <class cppyy.gbl.std.map<int,std::string> at 0x12d068d60>; >>> print(m); { 1 => ""one"", 2 => ""two"" }; >>>. `std::string`; -------------. Python's `str` is a unicode type since Python3, whereas ``std::string`` is; single-byte char-based.; Having the two correctly interact therefore deserves it's own; :doc:`chapter <strings>`. `std::tuple`; ------------. C++ ``tuple`` is supported but it should be noted that its use, and in; particular instantiating (heavily overloaded) ``get<>`` functions for member; access is inefficient.; They are really only meant for use when you have to pass a ``tuple`` to C++; code; and if returned from a C++ function, it is easier to simply unpack them.; In all other cases, prefer Python's builtin ``tuple``.; Example usage:. .. code-block:: python. >>> from cppyy.gbl.std import make_tuple, get; >>> t = make_tuple(1, '2', 5.); >>> print(t); <cppyy.gbl.std.tuple<int,std::string,double> object at 0x12033ee70>; >>> len(t); 3; >>> get[0](t) # access with templated std::get<>; 1; >>> get[1](t); b'2'; >>> get[2](t); 5.0; >>> a, b, c = t # unpack through iteration; >>> print(a, b, c); 1 2 5.0; >>>. .. rubric:: Footnotes. .. [#f1] The meaning of ""temporary"" differs between Python and C++: in a statement such as ``func(std.vector[int]((1, 2, 3)))``, there is no temporary as far as Python is concerned, even as there clearly is in the case of a similar statement in C++. Thus that call will succeed even if ``func`` takes a non-const reference.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst:9020,access,access,9020,bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,1,['access'],['access']
Security,"um class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matcher<Type>lValueReferenceTypeMatcher<LValueReferenceType>...; Matches lvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; struct A { int i; }; A::* ptr = A::i;; memberPointerType(); matches ""A::* ptr"". Matcher<Type>objcObjectPointerTypeMatcher<ObjCObjectPointerType>...; Matches an Objective-C o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:48889,inject,injectedClassNameType,48889,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['inject'],['injectedClassNameType']
Security,"ument, since the term; *Code Generation* better helps visualize the transformation that is enabling; AD support. ## Current Status of Code Generation in RooFit. RooFit is an extensive toolkit.; The initiative to add AD support/ Code Generation has been started, but has; not yet achieved full coverage for the models defined/maintained in RooFit. ## How Clad enables AD support using Source Code Transformation. [Clad] is a C++ plugin for Clang. It implements a technique called Source Code; Transformation to enable AD support. Source Code Transformation takes the source code (that needs to be; differentiated) as the input and generates an output code that represents the; derivative of the input. This output code can be used instead of the input; code for more efficient compilation. For more technical details, please see the following paper:. > [Automatic Differentiation of Binned Likelihoods with RooFit and Clad](https://arxiv.org/abs/2304.02650). ## Overview on RooFit implementation details to access source code transformation AD. In RooFit jargon, what is meant by a ""RooFit class"" is a class inheriting from; RooAbsArg that represents a mathematical function, a PDF, or any other; transformation of inputs that are also represented by RooAbsArg objects.; Almost all final classes deriving from RooAbsArg have RooAbsReal as an; intermediate base class, which is the base class for all RooAbsArg that; represent real-valued nodes in the computation graph.; As such RooFit objects are so prevalent in practice, the names RooAbsArg and; RooAbsReal are used interchangeably in this guide. Users take these classes to build a computational graph that represents the; PDF (also called ""model"") that they want to use for fitting the data.; The user then passes his final PDF and a RooAbsData object to the; RooAbsPdf::fitTo() method, which implicitly creates a negative-log likelihood; (NLL) that RooFit minimizes for parameter estimation.; The NLL object, internally created by RooAbsPdf::cre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:2882,access,access,2882,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['access'],['access']
Security,"umentation can be accepted in a format of a draft that can be further; refined during the implementation. Implementation guidelines; ^^^^^^^^^^^^^^^^^^^^^^^^^. This section explains how to extend clang with the new functionality. **Parsing functionality**. If an extension modifies the standard parsing it needs to be added to; the clang frontend source code. This also means that the associated macro; indicating the presence of the extension should be added to clang. The default flow for adding a new extension into the frontend is to; modify `OpenCLExtensions.def; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/OpenCLExtensions.def>`__,; containing the list of all extensions and optional features supported by; the frontend. This will add the macro automatically and also add a field in the target; options ``clang::TargetOptions::OpenCLFeaturesMap`` to control the exposure; of the new extension during the compilation. Note that by default targets like `SPIR-V`, `SPIR` or `X86` expose all the OpenCL; extensions. For all other targets the configuration has to be made explicitly. Note that the target extension support performed by clang can be overridden; with :option:`-cl-ext` command-line flags. .. _opencl_ext_libs:. **Library functionality**. If an extension adds functionality that does not modify standard language; parsing it should not require modifying anything other than header files and; ``OpenCLBuiltins.td`` detailed in :ref:`OpenCL builtins <opencl_builtins>`.; Most commonly such extensions add functionality via libraries (by adding; non-native types or functions) parsed regularly. Similar to other languages this; is the most common way to add new functionality. Clang has standard headers where new types and functions are being added,; for more details refer to; :ref:`the section on the OpenCL Header <opencl_header>`. The macros indicating; the presence of such extensions can be added in the standard header files; conditioned on target sp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:9126,expose,expose,9126,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,1,['expose'],['expose']
Security,"uments e.g. majority of CPU targets. **Example of Use**:. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable; void foo(int a, ...); // compiled - no diagnostic generated. #pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable; void bar(int a, ...); // error - variadic prototype is not allowed. ``__cl_clang_non_portable_kernel_param_types``; ----------------------------------------------. With this extension it is possible to enable the use of some restricted types; in kernel parameters specified in `C++ for OpenCL v1.0 s2.4; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html#kernel_function>`_.; The restrictions can be relaxed using regular OpenCL extension pragma mechanism; detailed in `the OpenCL Extension Specification, section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. This is not a conformant behavior and it can only be used when the; kernel arguments are not accessed on the host side or the data layout/size; between the host and device is known to be compatible. **Example of Use**:. .. code-block:: c++. // Plain Old Data type.; struct Pod {; int a;; int b;; };. // Not POD type because of the constructor.; // Standard layout type because there is only one access control.; struct OnlySL {; int a;; int b;; OnlySL() : a(0), b(0) {}; };. // Not standard layout type because of two different access controls.; struct NotSL {; int a;; private:; int b;; };. #pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : enable; kernel void kernel_main(; Pod a,. OnlySL b,; global NotSL *c,; global OnlySL *d; );; #pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : disable. Remove address space builtin function; -------------------------------------. ``__remove_address_space`` allows to derive types in C++ for OpenCL; that have address space qualifiers removed. This utility only affects; address space qualifiers, therefore, other type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:89759,access,accessed,89759,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['access'],['accessed']
Security,"unction, via pointer values not; *based* on the argument or return value. This guarantee only holds for; memory locations that are *modified*, by any means, during the execution of; the function. The attribute on a return value also has additional semantics; described below. The caller shares the responsibility with the callee for; ensuring that these requirements are met. For further details, please see; the discussion of the NoAlias response in :ref:`alias analysis <Must, May,; or No>`. Note that this definition of ``noalias`` is intentionally similar; to the definition of ``restrict`` in C99 for function arguments. For function return values, C99's ``restrict`` is not meaningful,; while LLVM's ``noalias`` is. Furthermore, the semantics of the ``noalias``; attribute on return values are stronger than the semantics of the attribute; when used on function arguments. On function return values, the ``noalias``; attribute indicates that the function acts like a system memory allocation; function, returning a pointer to allocated storage disjoint from the; storage for any other object accessible to the caller. .. _nocapture:. ``nocapture``; This indicates that the callee does not :ref:`capture <pointercapture>` the; pointer. This is not a valid attribute for return values.; This attribute applies only to the particular copy of the pointer passed in; this argument. A caller could pass two copies of the same pointer with one; being annotated nocapture and the other not, and the callee could validly; capture through the non annotated parameter. .. code-block:: llvm. define void @f(ptr nocapture %a, ptr %b) {; ; (capture %b); }. call void @f(ptr @glb, ptr @glb) ; well-defined. ``nofree``; This indicates that callee does not free the pointer argument. This is not; a valid attribute for return values. .. _nest:. ``nest``; This indicates that the pointer parameter can be excised using the; :ref:`trampoline intrinsics <int_trampoline>`. This is not a valid; attribute for return ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:59145,access,accessible,59145,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessible']
Security,"unctions starting with get or Get,; unless they are returning subclasses of OSIterator,; are assumed to be returning at +0.; That is, the caller has no reference; count obligations with respect to the reference count of the returned object; and should leave it untouched.; . All other functions are assumed to return at +1.; That is, the caller has an obligation to release such objects.; . Functions are assumed not to change the reference count of their parameters,; including the implicit this parameter.; . These summaries can be overriden with the following; attributes:; Attribute 'os_returns_retained'; The os_returns_retained attribute (accessed through the macro ; LIBKERN_RETURNS_RETAINED) plays a role identical to ns_returns_retained for functions; returning OSObject subclasses.; The attribute indicates that it is a callers responsibility to release the; returned object. Attribute 'os_returns_not_retained'; The os_returns_not_retained attribute (accessed through the macro ; LIBKERN_RETURNS_NOT_RETAINED) plays a role identical to ns_returns_not_retained for functions; returning OSObject subclasses.; The attribute indicates that the caller should not change the retain; count of the returned object. Example. class MyClass {; OSObject *f;; LIBKERN_RETURNS_NOT_RETAINED OSObject *myFieldGetter();; }. // Note that the annotation only has to be applied to the function declaration.; OSObject * MyClass::myFieldGetter() {; return f;; }. Attribute 'os_consumed'; Similarly to ns_consumed attribute,; os_consumed (accessed through LIBKERN_CONSUMED) attribute,; applied to a parameter,; indicates that the call to the function consumes the parameter:; the callee should either release it or store it and release it in the destructor,; while the caller should assume one is subtracted from the reference count; after the call. IOReturn addToList(LIBKERN_CONSUMED IOPMinformee *newInformee);. Attribute 'os_consumes_this'; Similarly to ns_consumes_self,; the os_consumes_self attribute indic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:15848,access,accessed,15848,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['access'],['accessed']
Security,"unicate how many source; language loop iterations are executing concurrently. See; ``DW_AT_LLVM_iterations`` in :ref:`amdgpu-dwarf-low-level-information`. 2.20 DWARF Operation to Create Runtime Overlay Composite Location Description; -----------------------------------------------------------------------------. It is common in SIMD vectorization for the compiler to generate code that; promotes portions of an array into vector registers. For example, if the; hardware has vector registers with 8 elements, and 8 wide SIMD instructions, the; compiler may vectorize a loop so that is executes 8 iterations concurrently for; each vectorized loop iteration. On the first iteration of the generated vectorized loop, iterations 0 to 7 of; the source language loop will be executed using SIMD instructions. Then on the; next iteration of the generated vectorized loop, iteration 8 to 15 will be; executed, and so on. If the source language loop accesses an array element based on the loop; iteration index, the compiler may read the element into a register for the; duration of that iteration. Next iteration it will read the next element into; the register, and so on. With SIMD, this generalizes to the compiler reading; array elements 0 to 7 into a vector register on the first vectorized loop; iteration, then array elements 8 to 15 on the next iteration, and so on. The DWARF location description for the array needs to express that all elements; are in memory, except the slice that has been promoted to the vector register.; The starting position of the slice is a runtime value based on the iteration; index modulo the vectorization size. This cannot be expressed by ``DW_OP_piece``; and ``DW_OP_bit_piece`` which only allow constant offsets to be expressed. Therefore, a new operator is defined that takes two location descriptions, an; offset and a size, and creates a composite that effectively uses the second; location description as an overlay of the first, positioned according to the; offs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:35567,access,accesses,35567,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['accesses']
Security,"unit tests for them.; Remove some unnecessary parts of the methods Multiply and Divide.; Implement the multiplication proposal in; <http://root.cern.ch/phpBB2/viewtopic.php?t=7692>, as weel; as implemeting unit tests for it.; Add a new method Fit() for fitting a THNSparse. By default the likelihood method is used. For using a least square; method (not really reccomended) if the histogram is really sparse, the option ""X"" must be used. . new classes TFitResult, TFitResultPtr. All the Fit methods of the Hist library instead of returning an integer now return a TFitResultPtr object. The TFitResultPtr is an object that converts automatically to an integer, which represents the status code of the fit. If the Fit method is used as before, there is a no visible change for the user.; When using the fit option ""S"", the TFitResultPtr will now contain a pointer to the new TFitResult class. It will behave as a smart pointer to TFitResult,; by using the -> operator the user can call the TFitResult methods or access directly the TFitResult object, by using the de-reference operator * or; TFitResultPtr::Get().; The TFitResult class derives from the ROOT::Math::FitResult, which contains all the result information from a fit and from TNamed. It provides then I/O capabilities for the FitResult object and convenience methods like Print(), Write(), GetCovarianceMatrix() and GetCorrelationMatrix() which return a TMatrixDSym object.; Example of usage:; ; TFitResult r = h->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Value(0); // retrieve the value for the parameter 0; Double_t err0 = r->Error(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. FitPanel. Added predefined 2D Functions.; Addition of new minimization algorithms from the GSL library and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:4932,access,access,4932,hist/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html,1,['access'],['access']
Security,"up can be in different CUs.; * All LDS operations of a CU are performed as wavefront wide operations in a; global order and involve no caching. Completion is reported to a wavefront in; execution order.; * The LDS memory has multiple request queues shared by the SIMDs of a; CU. Therefore, the LDS operations performed by different wavefronts of a; work-group can be reordered relative to each other, which can result in; reordering the visibility of vector memory operations with respect to LDS; operations of other wavefronts in the same work-group. A ``s_waitcnt; lgkmcnt(0)`` is required to ensure synchronization between LDS operations and; vector memory operations between wavefronts of a work-group, but not between; operations performed by the same wavefront.; * The vector memory operations are performed as wavefront wide operations and; completion is reported to a wavefront in execution order. The exception is; that ``flat_load/store/atomic`` instructions can report out of vector memory; order if they access LDS memory, and out of LDS operation order if they access; global memory.; * The vector memory operations access a single vector L1 cache shared by all; SIMDs a CU. Therefore:. * No special action is required for coherence between the lanes of a single; wavefront. * No special action is required for coherence between wavefronts in the same; work-group since they execute on the same CU. The exception is when in; tgsplit execution mode as wavefronts of the same work-group can be in; different CUs and so a ``buffer_inv sc0`` is required which will invalidate; the L1 cache. * A ``buffer_inv sc0`` is required to invalidate the L1 cache for coherence; between wavefronts executing in different work-groups as they may be; executing on different CUs. * Atomic read-modify-write instructions implicitly bypass the L1 cache.; Therefore, they do not use the sc0 bit for coherence and instead use it to; indicate if the instruction returns the original value being updated. They; d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:285913,access,access,285913,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,2,['access'],['access']
Security,"up can be in different CUs.; * All LDS operations of a CU are performed as wavefront wide operations in a; global order and involve no caching. Completion is reported to a wavefront in; execution order.; * The LDS memory has multiple request queues shared by the SIMDs of a; CU. Therefore, the LDS operations performed by different wavefronts of a; work-group can be reordered relative to each other, which can result in; reordering the visibility of vector memory operations with respect to LDS; operations of other wavefronts in the same work-group. A ``s_waitcnt; lgkmcnt(0)`` is required to ensure synchronization between LDS operations and; vector memory operations between wavefronts of a work-group, but not between; operations performed by the same wavefront.; * The vector memory operations are performed as wavefront wide operations and; completion is reported to a wavefront in execution order. The exception is; that ``flat_load/store/atomic`` instructions can report out of vector memory; order if they access LDS memory, and out of LDS operation order if they access; global memory.; * The vector memory operations access a single vector L1 cache shared by all; SIMDs a CU. Therefore:. * No special action is required for coherence between the lanes of a single; wavefront. * No special action is required for coherence between wavefronts in the same; work-group since they execute on the same CU. The exception is when in; tgsplit execution mode as wavefronts of the same work-group can be in; different CUs and so a ``buffer_wbinvl1_vol`` is required as described in; the following item. * A ``buffer_wbinvl1_vol`` is required for coherence between wavefronts; executing in different work-groups as they may be executing on different; CUs. * The scalar memory operations access a scalar L1 cache shared by all wavefronts; on a group of CUs. The scalar and vector L1 caches are not coherent. However,; scalar operations are used in a restricted way so do not impact the memory; model. S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:235765,access,access,235765,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,2,['access'],['access']
Security,"upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence of; a ``-fsanitize=`` option. There is no unused command line option warning. .. _ubsan-checks:. Available checks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitizes assume_aligned-like attributes.; - ``-fsanitize=bool``: Load of a ``bool`` value which is neither; ``true`` nor ``false``.; - ``-fsanitize=builtin``: Passing invalid values to compiler builtins.; - ``-fsanitize=bounds``: Out of bounds array indexing, in cases; where the array bound can be statically determined. The check includes; ``-fsanitize=array-bounds`` and ``-fsanitize=local-bounds``. Note that; ``-fsanitize=local-bounds`` is not included in ``-fsanitize=undefined``.; - ``-fsanitize=enum``: Load of a v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:3262,sanitiz,sanitizers,3262,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['sanitiz'],['sanitizers']
Security,"urity protocols in the list of protocols returned by the serverMake the readahead strategy more conservativeFix a rare race condition happening when destroying instances with outstanding open requestsEnforce cache coherency in the case of reads+writes in the same fileCorrectly guess the filesize of a file opened for writing in sync modeMake server host name check more flexible for GSI authenticationFix some relevant issues with cache handling on the client, including a rare but fatal bug in; determining the cache holes list and the end of a cache lookupMore complete detection of async read errorsGeneralFix problem in handling the return code; of X509_REQ_verify; in XrdCryptosslX509Req.ccAvoid SEGV when doing an lsd admin command with; authenticated xrootd clientsClose race conditions that allowed a supervisor/manager; to subscribe without declaring a data port. Initialize nostage state in; XrdCmsState to prevent erroneous state declaration during; initialization.Fix a problem with the subject name of proxies of level; > 1; this was creating a failure when a Globus application was; trying to use the proxy certificateFix a problem with cache refreshing in XrdSutCache; affecting automatic reloading of password filesFor now, turn off IPV6 processing as it seems to create; several problems.Fix a few issues with the available releases of gcc 4.4Fix a few issues with the 'icc' compilerFix several issues in GSI and PWD authentication modulesNew featuresNew File Residency Manager (frm), replacement for the MPS scriptsScripts are now provided toautomatically donwload a CRL certificate; (utils/getCRLcert)install the recommended verion of OpenSSL and build it; with the options optimal for usage in XROOTD/SCALLA; (utils/installOpenSSL.sh)install the recommended verion of OpenAFS and build it; with the options optimal for usage in; XROOTD/SCALLA (utils/installOpenAFS.sh)MiscellaneaTokenAuthz and CS2 modules are no longer part of the main; built; they have to be built externally. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v524/index.html:3167,certificate,certificateFix,3167,net/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v524/index.html,4,"['authenticat', 'certificate', 'password']","['authentication', 'certificate', 'certificateFix', 'password']"
Security,"use ICM, STCM, or CLM. --. We don't use ADD (LOGICAL) HIGH, SUBTRACT (LOGICAL) HIGH,; or COMPARE (LOGICAL) HIGH yet. --. DAGCombiner doesn't yet fold truncations of extended loads. Functions like:. unsigned long f (unsigned long x, unsigned short *y); {; return (x << 32) | *y;; }. therefore end up as:. sllg %r2, %r2, 32; llgh %r0, 0(%r3); lr %r2, %r0; br %r14. but truncating the load would give:. sllg %r2, %r2, 32; lh %r2, 0(%r3); br %r14. --. Functions like:. define i64 @f1(i64 %a) {; %and = and i64 %a, 1; ret i64 %and; }. ought to be implemented as:. lhi %r0, 1; ngr %r2, %r0; br %r14. but two-address optimizations reverse the order of the AND and force:. lhi %r0, 1; ngr %r0, %r2; lgr %r2, %r0; br %r14. CodeGen/SystemZ/and-04.ll has several examples of this. --. Out-of-range displacements are usually handled by loading the full; address into a register. In many cases it would be better to create; an anchor point instead. E.g. for:. define void @f4a(i128 *%aptr, i64 %base) {; %addr = add i64 %base, 524288; %bptr = inttoptr i64 %addr to i128 *; %a = load volatile i128 *%aptr; %b = load i128 *%bptr; %add = add i128 %a, %b; store i128 %add, i128 *%aptr; ret void; }. (from CodeGen/SystemZ/int-add-08.ll) we load %base+524288 and %base+524296; into separate registers, rather than using %base+524288 as a base for both. --. Dynamic stack allocations round the size to 8 bytes and then allocate; that rounded amount. It would be simpler to subtract the unrounded; size from the copy of the stack pointer and then align the result.; See CodeGen/SystemZ/alloca-01.ll for an example. --. If needed, we can support 16-byte atomics using LPQ, STPQ and CSDG. --. We might want to model all access registers and use them to spill; 32-bit values. --. We might want to use the 'overflow' condition of eg. AR to support; llvm.sadd.with.overflow.i32 and related instructions - the generated code; for signed overflow check is currently quite bad. This would improve; the results of using -ftrapv.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/README.txt:3552,access,access,3552,interpreter/llvm-project/llvm/lib/Target/SystemZ/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/README.txt,1,['access'],['access']
Security,"use the `TMatrixD` class family. - `type`<br>; Possible values are: `general` (`TMatrixD`), `symmetric` (`TMatrixDSym`) or `sparse` (`TMatrixDSparse`). - `size`<br>; Number of rows and columns. - `index`<br>; Range start of row and column index. By default these start at 0. - `sparse map`<br>; Only relevant for a sparse matrix. It indicates where elements are unequal 0. #### Accessing matrix properties. Use one of the following methods to access the information about the relevant matrix property:. - `Int_t GetRowLwb()`: Row lower-bound index. - `Int_t GetRowUpb()`: Row upper-bound index. - `Int_t GetNrows()`: Number of rows. - `Int_t GetColLwb()`: Column lower-bound index. - `Int_t GetColUpb()`: Column upper-bound index. - `Int_t GetNcols()`: Number of columns. - `Int_t GetNoElements()`: Number of elements, for a dense matrix this equals: `fNrows x fNcols`. - `Double_t GetTol()`: Tolerance number that is used in decomposition operations. - `Int_t *GetRowIndexArray()`: For sparse matrices, access to the row index of `fNrows+1` entries. - `Int_t *GetColIndexArray()`: For sparse matrices, access to the column index of `fNelems` entries. #### Setting matrix properties. Use one of the following methods to set a matrix property:. - `SetTol (Double_t tol)`<br>; Sets the tolerance number. - `ResizeTo (Int_t nrows,Int_t ncols, Int_t nr_nonzeros=-1)`<br>; Changes the matrix shape to `nrows x ncols`. Index will start at 0. - `ResizeTo(Int_t row_lwb,Int_t row_upb, Int_t col_lwb,Int_t col_upb, Int_t nr_nonzeros=-1)`<br>; Changes the matrix shape to `row_lwb:row_upb x col_lwb:col_upb`. - `SetRowIndexArray (Int_t *data)`<br>; For sparse matrices, it sets the row index. The array data should contain at least `fNrows+1` entries column lower-bound index. - `SetColIndexArray (Int_t *data)`<br>; For sparse matrices, it sets the column index. The array data should contain at least `fNelems` entries. - `SetSparseIndex (Int_t nelems new)`<br>; Allocates memory for a sparse map of `nelems_n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md:3093,access,access,3093,math/matrix/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md,1,['access'],['access']
Security,"use the branch buffers are optimized for homogeneous data; types. You can run the test programs on your architecture. The program; `Event` will report the write performance. You can measure the read; performance by executing the scripts `eventa` and `eventb`. The; performance depends not only of the processor type, but also of the disk; devices (local, NFS, AFS, etc.). ## Chains; \index{tree!chains}. A **`TChain`** object is a list of ROOT files containing the same tree.; As an example, assume we have three files called; `file1.root, file2.root, file3.root`. Each file contains one tree called; ""`T`"". We can create a chain with the following statements:. ``` {.cpp}; TChain chain(""T""); // name of the tree is the argument; chain.Add(""file1.root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; ```. The name of the **`TChain`** will be the same as the name of the tree;; in this case it will be `""T"". Note that two `objects can have the same; name as long as they are not histograms in the same directory, because; there, the histogram names are used to build a hash table. The class; **`TChain`** is derived from the class **`TTree`**. For example, to; generate a histogram corresponding to the attribute ""`x`"" in tree ""`T`""; by processing sequentially the three files of this chain, we can use the; `TChain::Draw` method. ``` {.cpp}; chain.Draw(""x"");; ```. When using a **`TChain`**, the branch address(es) must be set with:. ``` {.cpp}; chain.SetBranchAdress(branchname,...) // use this for TChain; ```. rather than:. ``` {.cpp}; branch->SetAddress(...); // this will not work; ```. The second form returns the pointer to the branch of the current; **`TTree`** in the chain, typically the first one. The information is; lost when the next **`TTree`** is loaded. The following statements; illustrate how to set the address of the object to be read and how to; loop on all events of all files of the chain. ``` {.cpp}; {; TChain chain(""T""); // create the chain with tree ""T""; chain.Add(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:140853,hash,hash,140853,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['hash'],['hash']
Security,"usion with the first index usually arises from thinking about the; GetElementPtr instruction as if it was a C index operator. They aren't the; same. For example, when we write, in ""C"":. .. code-block:: c++. AType *Foo;; ...; X = &Foo->F;. it is natural to think that there is only one index, the selection of the field; ``F``. However, in this example, ``Foo`` is a pointer. That pointer; must be indexed explicitly in LLVM. C, on the other hand, indices through it; transparently. To arrive at the same address location as the C code, you would; provide the GEP instruction with two index operands. The first operand indexes; through the pointer; the second operand indexes the field ``F`` of the; structure, just as if you wrote:. .. code-block:: c++. X = &Foo[0].F;. Sometimes this question gets rephrased as:. .. _GEP index through first pointer:. *Why is it okay to index through the first pointer, but subsequent pointers; won't be dereferenced?*. The answer is simply because memory does not have to be accessed to perform the; computation. The second operand to the GEP instruction must be a value of a; pointer type. The value of the pointer is provided directly to the GEP; instruction as an operand without any need for accessing memory. It must,; therefore be indexed and requires an index operand. Consider this example:. .. code-block:: c++. struct munger_struct {; int f1;; int f2;; };; void munge(struct munger_struct *P) {; P[0].f1 = P[1].f1 + P[2].f2;; }; ...; struct munger_struct Array[3];; ...; munge(Array);. In this ""C"" example, the front end compiler (Clang) will generate three GEP; instructions for the three indices through ""P"" in the assignment statement. The; function argument ``P`` will be the second operand of each of these GEP; instructions. The third operand indexes through that pointer. The fourth; operand will be the field offset into the ``struct munger_struct`` type, for; either the ``f1`` or ``f2`` field. So, in LLVM assembly the ``munge`` function; looks ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:2117,access,accessed,2117,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['access'],['accessed']
Security,"usses the key designs of ``-fbounds-safety``. The document is; subject to be actively updated with a more detailed specification. The; implementation plan can be found in :doc:`BoundsSafetyImplPlans`. Programming Model; =================. Overview; --------. ``-fbounds-safety`` ensures that pointers are not used to access memory beyond; their bounds by performing bounds checking. If a bounds check fails, the program; will deterministically trap before out-of-bounds memory is accessed. In our model, every pointer has an explicit or implicit bounds attribute that; determines its bounds and ensures guaranteed bounds checking. Consider the; example below where the ``__counted_by(count)`` annotation indicates that; parameter ``p`` points to a buffer of integers containing ``count`` elements. An; off-by-one error is present in the loop condition, leading to ``p[i]`` being; out-of-bounds access during the loop's final iteration. The compiler inserts a; bounds check before ``p`` is dereferenced to ensure that the access remains; within the specified bounds. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, unsigned count) {; // off-by-one error (i < count); for (unsigned i = 0; i <= count; ++i) {; // bounds check inserted:; // if (i >= count) trap();; p[i] = i;; }; }. A bounds annotation defines an invariant for the pointer type, and the model; ensures that this invariant remains true. In the example below, pointer ``p``; annotated with ``__counted_by(count)`` must always point to a memory buffer; containing at least ``count`` elements of the pointee type. Changing the value; of ``count``, like in the example below, may violate this invariant and permit; out-of-bounds access to the pointer. To avoid this, the compiler employs; compile-time restrictions and emits run-time checks as necessary to ensure the; new count value doesn't exceed the actual length of the buffer. Section; `Maintaining correctness of bounds annotations`_ provides more details a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:3689,access,access,3689,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['access'],['access']
Security,"ussions) become public within approximately fourteen weeks of the fix landing in the LLVM repository. Precautions should be taken to avoid disclosing particularly sensitive data included in the report (e.g. username and password pairs). Changes to the Policy; =====================. The LLVM Security Policy may be changed by majority vote of the LLVM Security Group. Such changes also need to be approved by the LLVM Board. What is considered a security issue?; ====================================. The LLVM Project has a significant amount of code, and not all of it is; considered security-sensitive. This is particularly true because LLVM is used in; a wide variety of circumstances: there are different threat models, untrusted; inputs differ, and the environment LLVM runs in is varied. Therefore, what the; LLVM Project considers a security issue is what its members have signed up to; maintain securely. As this security process matures, members of the LLVM community can propose that; a part of the codebase be designated as security-sensitive (or no longer; security-sensitive). This requires a rationale, and buy-in from the LLVM; community as for any RFC. In some cases, parts of the codebase could be handled; as security-sensitive but need significant work to get to the stage where that's; manageable. The LLVM community will need to decide whether it wants to invest in; making these parts of the code securable, and maintain these security; properties over time. In all cases the LLVM Security Group should be consulted,; since they'll be responding to security issues filed against these parts of the; codebase. If you're not sure whether an issue is in-scope for this security process or; not, err towards assuming that it is. The Security Group might agree or disagree; and will explain its rationale in the report, as well as update this document; through the above process. The security-sensitive parts of the LLVM Project currently are the following.; Note that this list can c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:14486,secur,security,14486,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,3,['secur'],"['security', 'security-sensitive']"
Security,"ust be as deterministic as possible. Non-determinism (e.g. random decisions not based on the input bytes) will make fuzzing inefficient.; * It must be fast. Try avoiding cubic or greater complexity, logging, or excessive memory consumption.; * Ideally, it should not modify any global state (although that's not strict).; * Usually, the narrower the target the better. E.g. if your target can parse several data formats, split it into several targets, one per format. Fuzzer Usage; ------------. Recent versions of Clang (starting from 6.0) include libFuzzer, and no extra installation is necessary. In order to build your fuzzer binary, use the `-fsanitize=fuzzer` flag during the; compilation and linking. In most cases you may want to combine libFuzzer with; AddressSanitizer_ (ASAN), UndefinedBehaviorSanitizer_ (UBSAN), or both. You can; also build with MemorySanitizer_ (MSAN), but support is experimental::. clang -g -O1 -fsanitize=fuzzer mytarget.c # Builds the fuzz target w/o sanitizers; clang -g -O1 -fsanitize=fuzzer,address mytarget.c # Builds the fuzz target with ASAN; clang -g -O1 -fsanitize=fuzzer,signed-integer-overflow mytarget.c # Builds the fuzz target with a part of UBSAN; clang -g -O1 -fsanitize=fuzzer,memory mytarget.c # Builds the fuzz target with MSAN. This will perform the necessary instrumentation, as well as linking with the libFuzzer library.; Note that ``-fsanitize=fuzzer`` links in the libFuzzer's ``main()`` symbol. If modifying ``CFLAGS`` of a large project, which also compiles executables; requiring their own ``main`` symbol, it may be desirable to request just the; instrumentation without linking::. clang -fsanitize=fuzzer-no-link mytarget.c. Then libFuzzer can be linked to the desired driver by passing in; ``-fsanitize=fuzzer`` during the linking stage. .. _libfuzzer-corpus:. Corpus; ------. Coverage-guided fuzzers like libFuzzer rely on a corpus of sample inputs for the; code under test. This corpus should ideally be seeded with a varied collectio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:3201,sanitiz,sanitizers,3201,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['sanitiz'],['sanitizers']
Security,"ust-In-Time (JIT); code generator that emits machine code and auxiliary structures as binary; output that can be written directly to memory. To do this, implement JIT code; generation by performing the following steps:. * Write an ``XXXCodeEmitter.cpp`` file that contains a machine function pass; that transforms target-machine instructions into relocatable machine; code. * Write an ``XXXJITInfo.cpp`` file that implements the JIT interfaces for; target-specific code-generation activities, such as emitting machine code and; stubs. * Modify ``XXXTargetMachine`` so that it provides a ``TargetJITInfo`` object; through its ``getJITInfo`` method. There are several different approaches to writing the JIT support code. For; instance, TableGen and target descriptor files may be used for creating a JIT; code generator, but are not mandatory. For the Alpha and PowerPC target; machines, TableGen is used to generate ``XXXGenCodeEmitter.inc``, which; contains the binary coding of machine instructions and the; ``getBinaryCodeForInstr`` method to access those codes. Other JIT; implementations do not. Both ``XXXJITInfo.cpp`` and ``XXXCodeEmitter.cpp`` must include the; ``llvm/CodeGen/MachineCodeEmitter.h`` header file that defines the; ``MachineCodeEmitter`` class containing code for several callback functions; that write data (in bytes, words, strings, etc.) to the output stream. Machine Code Emitter; --------------------. In ``XXXCodeEmitter.cpp``, a target-specific of the ``Emitter`` class is; implemented as a function pass (subclass of ``MachineFunctionPass``). The; target-specific implementation of ``runOnMachineFunction`` (invoked by; ``runOnFunction`` in ``MachineFunctionPass``) iterates through the; ``MachineBasicBlock`` calls ``emitInstruction`` to process each instruction and; emit binary code. ``emitInstruction`` is largely implemented with case; statements on the instruction types defined in ``XXXInstrInfo.h``. For; example, in ``X86CodeEmitter.cpp``, the ``emitInstruction",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:76569,access,access,76569,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['access'],['access']
Security,ustments and decltype; Unknown. 1131; C++11; Template aliases in elaborated-type-specifiers; Unknown. 1132; NAD; Keyword vs attribute for noreturn; Unknown. 1133; C++11; Keywords vs attributes for control of hiding and overriding; Unknown. 1134; C++11; When is an explicitly-defaulted function defined?; Unknown. 1135; C++11; Explicitly-defaulted non-public special member functions; Unknown. 1136; C++11; Explicitly-defaulted explicit constructors; Unknown. 1137; C++11; Explicitly-defaulted virtual special member functions; Unknown. 1138; C++11; Rvalue-ness check for rvalue reference binding is wrong; Unknown. 1139; C++11; Rvalue reference binding to scalar xvalues; Unknown. 1140; C++11; Incorrect redefinition of POD class; Unknown. 1141; NAD; Non-static data member initializers have not been implemented; Unknown. 1142; C++11; friend declaration of member function of containing class; Unknown. 1143; NAD; Move semantics for *this have not been implemented; Unknown. 1144; C++11; Remove access declarations; Unknown. 1145; C++11; Defaulting and triviality; Unknown. 1146; C++11; exception-specifications of defaulted functions; Unknown. 1147; C++11; Destructors should be default nothrow; Unknown. 1148; C++11; Copy elision and move construction of function parameters; Unknown. 1149; C++11; Trivial non-public copy operators in subobjects; Unknown. 1150; NAD; Inheriting constructors have not been implemented; Unknown. 1151; C++11; Overload resolution with initializer-list and non-list constructors; Unknown. 1152; C++11; Rules for determining existence of implicit conversion sequence; Unknown. 1153; C++11; Type matching in address of overloaded function; Unknown. 1154; C++11; Address of thread_local variable as non-type template argument; Unknown. 1155; C++11; Internal-linkage non-type template arguments; Unknown. 1156; C++11; Partial ordering in a non-call context; Unknown. 1157; open; Partial ordering of function templates is still underspecified; Not resolved. 1158; C++11; Re,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:75967,access,access,75967,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['access'],['access']
Security,"ut a; location description on the stack. Furthermore, debugger information entry; attributes such as ``DW_AT_data_member_location``, ``DW_AT_use_location``, and; ``DW_AT_vtable_elem_location`` are defined as pushing a location description on; the expression stack before evaluating the expression. DWARF Version 5 only allows the stack to contain values and so only a single; memory address can be on the stack. This makes these operations and attributes; incapable of handling location descriptions with multiple places, or places; other than memory. Since; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack`; allows the stack to contain location descriptions, the operations are; generalized to support location descriptions that can have multiple places. This; is backwards compatible with DWARF Version 5 and allows objects with multiple; places to be supported. For example, the expression that describes how to access; the field of an object can be evaluated with a location description that has; multiple places and will result in a location description with multiple places. With this change, the separate DWARF Version 5 sections that described DWARF; expressions and location lists are unified into a single section that describes; DWARF expressions in general. This unification is a natural consequence of, and; a necessity of, allowing location descriptions to be part of the evaluation; stack. See :ref:`amdgpu-dwarf-location-description`. 2.4 Generalize Offsetting of Location Descriptions; --------------------------------------------------. The ``DW_OP_plus`` and ``DW_OP_minus`` operations can be defined to operate on a; memory location description in the default target architecture specific address; space and a generic type value to produce an updated memory location; description. This allows them to continue to be used to offset an address. To generalize offsetting to any location description, including location; descriptions that describe when byt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:10180,access,access,10180,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['access']
Security,"ut does not currently extend to; multithreaded programs. This will be added in the future as there is; interest. .. _stack-map:. Computing stack maps; --------------------. LLVM automatically computes a stack map. One of the most important features; of a ``GCStrategy`` is to compile this information into the executable in; the binary representation expected by the runtime library. The stack map consists of the location and identity of each GC root in the; each function in the module. For each root:. * ``RootNum``: The index of the root. * ``StackOffset``: The offset of the object relative to the frame pointer. * ``RootMetadata``: The value passed as the ``%metadata`` parameter to the; ``@llvm.gcroot`` intrinsic. Also, for the function as a whole:. * ``getFrameSize()``: The overall size of the function's initial stack frame,; not accounting for any dynamic allocation. * ``roots_size()``: The count of roots in the function. To access the stack map, use ``GCFunctionMetadata::roots_begin()`` and; -``end()`` from the :ref:`GCMetadataPrinter <assembly>`:. .. code-block:: c++. for (iterator I = begin(), E = end(); I != E; ++I) {; GCFunctionInfo *FI = *I;; unsigned FrameSize = FI->getFrameSize();; size_t RootCount = FI->roots_size();. for (GCFunctionInfo::roots_iterator RI = FI->roots_begin(),; RE = FI->roots_end();; RI != RE; ++RI) {; int RootNum = RI->Num;; int RootStackOffset = RI->StackOffset;; Constant *RootMetadata = RI->Metadata;; }; }. If the ``llvm.gcroot`` intrinsic is eliminated before code generation by a; custom lowering pass, LLVM will compute an empty stack map. This may be useful; for collector plugins which implement reference counting or a shadow stack. .. _init-roots:. Initializing roots to null; ---------------------------. It is recommended that frontends initialize roots explicitly to avoid; potentially confusing the optimizer. This prevents the GC from visiting; uninitialized pointers, which will almost certainly cause it to crash. As a fallback, LLVM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:32782,access,access,32782,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['access'],['access']
Security,"ut to an output which has a register constraint, not a; memory constraint. Only a single input may be tied to an output. There is also an ""interesting"" feature which deserves a bit of explanation: if a; register class constraint allocates a register which is too small for the value; type operand provided as input, the input value will be split into multiple; registers, and all of them passed to the inline asm. However, this feature is often not as useful as you might think. Firstly, the registers are *not* guaranteed to be consecutive. So, on those; architectures that have instructions which operate on multiple consecutive; instructions, this is not an appropriate way to support them. (e.g. the 32-bit; SparcV8 has a 64-bit load, which instruction takes a single 32-bit register. The; hardware then loads into both the named register, and the next register. This; feature of inline asm would not be useful to support that.). A few of the targets provide a template string modifier allowing explicit access; to the second register of a two-register operand (e.g. MIPS ``L``, ``M``, and; ``D``). On such an architecture, you can actually access the second allocated; register (yet, still, not any subsequent ones). But, in that case, you're still; probably better off simply splitting the value into two separate operands, for; clarity. (e.g. see the description of the ``A`` constraint on X86, which,; despite existing only for use with this feature, is not really a good idea to; use). Indirect inputs and outputs; """""""""""""""""""""""""""""""""""""""""""""""""""""". Indirect output or input constraints can be specified by the ""``*``"" modifier; (which goes after the ""``=``"" in case of an output). This indicates that the asm; will write to or read from the contents of an *address* provided as an input; argument. (Note that in this way, indirect outputs act more like an *input* than; an output: just like an input, they consume an argument of the call expression,; rather than producing a return value. An indir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:215050,access,access,215050,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"ut,; size_t out_len);; ```. Finalize the hasher and return an output of any length, given in bytes.; This doesn't modify the hasher itself, and it's possible to finalize; again after adding more input. The constant `LLVM_BLAKE3_OUT_LEN` provides; the default output length, 32 bytes, which is recommended for most; callers. Outputs shorter than the default length of 32 bytes (256 bits) provide; less security. An N-bit BLAKE3 output is intended to provide N bits of; first and second preimage resistance and N/2 bits of collision; resistance, for any N up to 256. Longer outputs don't provide any; additional security. Shorter BLAKE3 outputs are prefixes of longer ones. Explicitly; requesting a short output is equivalent to truncating the default-length; output. (Note that this is different between BLAKE2 and BLAKE3.). ## Less Common API Functions. ```c; void llvm_blake3_hasher_init_keyed(; llvm_blake3_hasher *self,; const uint8_t key[LLVM_BLAKE3_KEY_LEN]);; ```. Initialize a `llvm_blake3_hasher` in the keyed hashing mode. The key must be; exactly 32 bytes. ---. ```c; void llvm_blake3_hasher_init_derive_key(; llvm_blake3_hasher *self,; const char *context);; ```. Initialize a `llvm_blake3_hasher` in the key derivation mode. The context; string is given as an initialization parameter, and afterwards input key; material should be given with `llvm_blake3_hasher_update`. The context string; is a null-terminated C string which should be **hardcoded, globally; unique, and application-specific**. The context string should not; include any dynamic input like salts, nonces, or identifiers read from a; database at runtime. A good default format for the context string is; `""[application] [commit timestamp] [purpose]""`, e.g., `""example.com; 2019-12-25 16:18:03 session tokens v1""`. This function is intended for application code written in C. For; language bindings, see `llvm_blake3_hasher_init_derive_key_raw` below. ---. ```c; void llvm_blake3_hasher_init_derive_key_raw(; llvm_blake3_ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md:4401,hash,hashing,4401,interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,1,['hash'],['hashing']
Security,"utes.html>`_, and; `GCC type attributes; <https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html>`_). As with the GCC; implementation, these attributes must appertain to the *declarator-id* in a; declaration, which means they must go either at the start of the declaration or; immediately after the name being declared. For example, this applies the GNU ``unused`` attribute to ``a`` and ``f``, and; also applies the GNU ``noreturn`` attribute to ``f``. .. code-block:: c++. [[gnu::unused]] int a, f [[gnu::noreturn]] ();. Target-Specific Extensions; ==========================. Clang supports some language features conditionally on some targets. ARM/AArch64 Language Extensions; -------------------------------. Memory Barrier Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^; Clang implements the ``__dmb``, ``__dsb`` and ``__isb`` intrinsics as defined; in the `Arm C Language Extensions; <https://github.com/ARM-software/acle/releases>`_.; Note that these intrinsics are implemented as motion barriers that block; reordering of memory accesses and side effect instructions. Other instructions; like simple arithmetic may be reordered around the intrinsic. If you expect to; have no reordering at all, use inline assembly instead. X86/X86-64 Language Extensions; ------------------------------. The X86 backend has these language extensions:. Memory references to specified segments; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Annotating a pointer with address space #256 causes it to be code generated; relative to the X86 GS segment register, address space #257 causes it to be; relative to the X86 FS segment, and address space #258 causes it to be; relative to the X86 SS segment. Note that this is a very very low-level; feature that should only be used if you know what you're doing (for example in; an OS kernel). Here is an example:. .. code-block:: c++. #define GS_RELATIVE __attribute__((address_space(256))); int foo(int GS_RELATIVE *P) {; return *P;; }. Which compiles to (on X86-32):. .. code-blo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:154885,access,accesses,154885,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['access'],['accesses']
Security,"uting inside that thread. Every (defined) read operation (load instructions, memcpy, atomic; loads/read-modify-writes, etc.) R reads a series of bytes written by; (defined) write operations (store instructions, atomic; stores/read-modify-writes, memcpy, etc.). For the purposes of this; section, initialized globals are considered to have a write of the; initializer which is atomic and happens before any other read or write; of the memory in question. For each byte of a read R, R\ :sub:`byte`; may see any write to the same byte, except:. - If write\ :sub:`1` happens before write\ :sub:`2`, and; write\ :sub:`2` happens before R\ :sub:`byte`, then; R\ :sub:`byte` does not see write\ :sub:`1`.; - If R\ :sub:`byte` happens before write\ :sub:`3`, then; R\ :sub:`byte` does not see write\ :sub:`3`. Given that definition, R\ :sub:`byte` is defined as follows:. - If R is volatile, the result is target-dependent. (Volatile is; supposed to give guarantees which can support ``sig_atomic_t`` in; C/C++, and may be used for accesses to addresses that do not behave; like normal memory. It does not generally provide cross-thread; synchronization.); - Otherwise, if there is no write to the same byte that happens before; R\ :sub:`byte`, R\ :sub:`byte` returns ``undef`` for that byte.; - Otherwise, if R\ :sub:`byte` may see exactly one write,; R\ :sub:`byte` returns the value written by that write.; - Otherwise, if R is atomic, and all the writes R\ :sub:`byte` may; see are atomic, it chooses one of the values written. See the :ref:`Atomic; Memory Ordering Constraints <ordering>` section for additional; constraints on how the choice is made.; - Otherwise R\ :sub:`byte` returns ``undef``. R returns the value composed of the series of bytes it read. This; implies that some bytes within the value may be ``undef`` **without**; the entire value being ``undef``. Note that this only defines the; semantics of the operation; it doesn't mean that targets will emit more; than one instruction to re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:150708,access,accesses,150708,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accesses']
Security,"valid ``using`` is the last method; * Filter -fno-plt (coming from anaconda builds; not understood by Cling); * Fixed memory leak in generic base ``__str__``. 2021-01-05: 1.9.2; -----------------. * Added ``cppyy.types`` module for exposing cppyy builtin types; * Improve numpy integration with custom ``__array__`` methods; * Allow operator overload resolution mixing class and global methods; * Installation fixes for PyPy when using pip. 2020-11-23: 1.9.1; -----------------. * Fix custom installer in pip sdist. 2020-11-22: 1.9.0; -----------------. * In-tree build resolving build/install order for PyPy with pyproject.toml; * ``std::string`` not converterd to ``str`` on function returns; * Cover more use cases where C string memory can be managed; * Automatic memory management of converted python functions; * Added pyinstaller hooks (https://stackoverflow.com/questions/64406727); * Support for enums in pseudo-constructors of aggregates; * Fixes for overloaded/split-access protected members in cross-inheritance; * Support for deep, mixed, hierarchies for multi-cross-inheritance; * Added tp_iter method to low level views. 2020-11-06: 1.8.6; -----------------. * Fix preprocessor macro of CPyCppyy header for Windows/MSVC. 2020-10-31: 1.8.5; -----------------. * Fix leaks when using vector iterators on Py3/Linux. 2020-10-10: 1.8.4; -----------------. * ``std::string`` globals/data members no longer automatically converted to ``str``; * New methods for std::string to allow ``str`` interchangability; * Added a ``decode`` method to ``std::string``; * Add pythonized ``__contains__`` to ``std::set``; * Fix constructor generation for aggregates with static data; * Fix performance bug when using implicit conversions; * Fix memory overwrite when parsing during sorting of methods; * PyPy pip install again falls back to setup.py install. 2020-09-21: 1.8.3; -----------------. * Add initializer constructors for PODs and aggregates; * Use actual underlying type for enums, where possible",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:9298,access,access,9298,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,1,['access'],['access']
Security,"valid code that produces this value. However, it may be useful; for testing purposes, to see how well does the analyzer model region extents. Example usage::. void foo() {; int x, *y;; size_t xs = clang_analyzer_getExtent(&x);; clang_analyzer_explain(xs); // expected-warning{{'4'}}; size_t ys = clang_analyzer_getExtent(&y);; clang_analyzer_explain(ys); // expected-warning{{'8'}}; }. - ``void clang_analyzer_printState();``. Dumps the current ProgramState to the stderr. Quickly lookup the program state; at any execution point without ViewExplodedGraph or re-compiling the program.; This is not very useful for writing tests (apart from testing how ProgramState; gets printed), but useful for debugging tests. Also, this method doesn't; produce a warning, so it gets printed on the console before all other; ExprInspection warnings. Example usage::. void foo() {; int x = 1;; clang_analyzer_printState(); // Read the stderr!; }. - ``void clang_analyzer_hashDump(int);``. The analyzer can generate a hash to identify reports. To debug what information; is used to calculate this hash it is possible to dump the hashed string as a; warning of an arbitrary expression using the function above. Example usage::. void foo() {; int x = 1;; clang_analyzer_hashDump(x); // expected-warning{{hashed string for x}}; }. - ``void clang_analyzer_denote(int, const char *);``. Denotes symbols with strings. A subsequent call to clang_analyzer_express(); will expresses another symbol in terms of these string. Useful for testing; relationships between different symbols. Example usage::. void foo(int x) {; clang_analyzer_denote(x, ""$x"");; clang_analyzer_express(x + 1); // expected-warning{{$x + 1}}; }. - ``void clang_analyzer_express(int);``. See clang_analyzer_denote(). - ``void clang_analyzer_isTainted(a single argument of any type);``. Queries the analyzer whether the expression used as argument is tainted or not.; This is useful in tests, where we don't want to issue warning for all tainted; express",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:8813,hash,hash,8813,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,1,['hash'],['hash']
Security,"valuation of Convolutional layer on GPU; - Several ML optimizers are now included and they can be used in addition to SGD. These are ADAM (the new default), ADAGRAD,; RMSPROP, ADADELTA. A new option, *Optimizer* has been added in the option string used to define the training strategy options.; - Add support for regression in MethodDL; - Use single precision (float) types as the fundamental type for the neural network architecture. Double precision could be enabled, but it will require recompiling TMVA. ; - Support inference (network evaluation) in batch mode in addition to single event. Batch mode evaluation is now the default when used within the `TMVA::Factory` class (i.e. when calling; `Factory::TestAllMethod()` or `Factory::EvaluateAllMethods()`; - Support splitting the overall training data in Train and Validation data. The train data is used for finding the optimal network weight and the validation data is used to monitor the validation; error. The weights which are giving a minimal validation error will be stored. For the splitting a new option, *ValidationSize* has been added to the global options for `MethodDL`.; The same option is also available in the `PyKeras` method of `PyMVA`; - The fast tanh implementation from VDT is now used as activation function when training the network on CPU.; - Using `Cblas` from the GSL library is supported for CPU training when no other Blas libraries are found. However, it is strongly recommended, to use an optimized Blas implementation such as `libopenblas`, that is; available in cvmfs.; - Add several performance optimizations for both CPU and GPU versions of `MethodDL`. . ### Other New TMVA Features. - Add a new option to the `DataLoader` to switch off computation of correlation matrix. The new option is called *CalcCorrelations* and it should be used when a large number of input variables are; provided, otherwise TMVA will spend a long time in setting up the data set before training. ; ; - Build configuration:; - Add new",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:14477,validat,validation,14477,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['validat'],['validation']
Security,"value is updated to equal; that SGPR number plus one. May be used to set the `.amdhsa_next_free_spgr` directive in; :ref:`amdhsa-kernel-directives-table`. May be set at any time, e.g. manually set to zero at the start of each kernel. .. _amdgpu-amdhsa-assembler-directives-v3-onwards:. Code Object V3 and Above Directives; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Directives which begin with ``.amdgcn`` are valid for all ``amdgcn``; architecture processors, and are not OS-specific. Directives which begin with; ``.amdhsa`` are specific to ``amdgcn`` architecture processors when the; ``amdhsa`` OS is specified. See :ref:`amdgpu-target-triples` and; :ref:`amdgpu-processors`. .. _amdgpu-assembler-directive-amdgcn-target:. .amdgcn_target <target-triple> ""-"" <target-id>; ++++++++++++++++++++++++++++++++++++++++++++++. Optional directive which declares the ``<target-triple>-<target-id>`` supported; by the containing assembler source file. Used by the assembler to validate; command-line options such as ``-triple``, ``-mcpu``, and; ``--offload-arch=<target-id>``. A non-canonical target ID is allowed. See; :ref:`amdgpu-target-triples` and :ref:`amdgpu-target-id`. .. note::. The target ID syntax used for code object V2 to V3 for this directive differs; from that used elsewhere. See :ref:`amdgpu-target-id-v2-v3`. .. _amdgpu-assembler-directive-amdhsa-code-object-version:. .amdhsa_code_object_version <version>; +++++++++++++++++++++++++++++++++++++. Optional directive which declares the code object version to be generated by the; assembler. If not present, a default value will be used. .amdhsa_kernel <name>; +++++++++++++++++++++. Creates a correctly aligned AMDHSA kernel descriptor and a symbol,; ``<name>.kd``, in the current location of the current section. Only valid when; the OS is ``amdhsa``. ``<name>`` must be a symbol that labels the first; instruction to execute, and does not need to be previously defined. Marks the beginning of a list of directives used to generate the bytes of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:439312,validat,validate,439312,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['validat'],['validate']
Security,"vate:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:62166,access,access,62166,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['access'],['access']
Security,"ve about working with the patch author to debug and test candidate; patches.; * Reverts should be reasonably timely. A change submitted two hours ago; can be reverted without prior discussion. A change submitted two years ago; should not be. Where exactly the transition point is is hard to say, but; it's probably in the handful of days in tree territory. If you are unsure,; we encourage you to reply to the commit thread, give the author a bit to; respond, and then proceed with the revert if the author doesn't seem to be; actively responding.; * When re-applying a reverted patch, the commit message should be updated to; indicate the problem that was addressed and how it was addressed. Obtaining Commit Access; -----------------------. We grant commit access to contributors with a track record of submitting high; quality patches. If you would like commit access, please send an email to; `Chris <mailto:clattner@llvm.org>`_ with your GitHub username. This is true; for former contributors with SVN access as well as new contributors. If; approved, a GitHub invitation will be sent to your GitHub account. In case you; don't get notification from GitHub, go to; `Invitation Link <https://github.com/orgs/llvm/invitation>`_ directly. Once; accept the invitation, you'll get commit access. Prior to obtaining commit access, it is common practice to request that; someone with commit access commits on your behalf. When doing so, please; provide the name and email address you would like to use in the Author; property of the commit. For external tracking purposes, committed changes are automatically reflected; on a commits mailing list soon after the commit lands (e.g. llvm-commits_).; Note that these mailing lists are moderated, and it is not unusual for a large; commit to require a moderator to approve the email, so do not be concerned if a; commit does not immediately appear in the archives. If you have recently been granted commit access, these policies apply:. #. You are granted *c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:23249,access,access,23249,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['access'],['access']
Security,"ve reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65843,inject,injected,65843,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['inject'],['injected']
Security,"ved the generated initializers for modules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`_). Moved checkers; ^^^^^^^^^^^^^^. - Move checker ``alpha.unix.Errno`` out of the ``alpha`` package; to ``unix.Errno``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-errno-c>`__. - Move checker ``alpha.unix.StdCLibraryFunctions`` out of the ``alpha`` package; to ``unix.StdCLibraryFunctions``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-stdclibraryfunctions-c>`__. - Move checker ``alpha.security.cert.env.InvalidPtr`` out of the ``alpha``; package to ``security.cert.env.InvalidPtr``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__. - Move checker ``alpha.cplusplus.EnumCastOutOfRange`` out of the ``alpha``; package to ``optin.core.EnumCastOutOfRange``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#optin-core-enumcastoutofrange-c-c>`__. .. _release-notes-sanitizers:. Sanitizers; ----------. - ``-fsanitize=signed-integer-overflow`` now instruments ``__builtin_abs`` and; ``abs`` builtins. Python Binding Changes; ----------------------. Additional Information; ======================. A wide variety of additional information is available on the `Clang web; page <https://clang.llvm.org/>`_. The web page contains versions of the; API documentation which are up-to-date with the Git version of; the source code. You can access versions of these documents specific to; this release by going into the ""``clang/docs/``"" directory in the Clang; tree. If you have any questions or comments about Clang, please feel free to; contact us on the `Discourse forums (Clang Frontend category); <http",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:77140,secur,security-cert-env-invalidptr,77140,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['secur'],['security-cert-env-invalidptr']
Security,"ven:. .. code-block:: llvm. define void @foo() {; %a = alloca i8; %b = alloca i8. ; 1 = MemoryDef(liveOnEntry); store i8 0, ptr %a; ; 2 = MemoryDef(1); store i8 0, ptr %b; }. The store to ``%a`` is clearly not a clobber for the store to ``%b``. It would; be the walker's goal to figure this out, and return ``liveOnEntry`` when queried; for the clobber of ``MemoryAccess`` ``2``. By default, ``MemorySSA`` provides a walker that can optimize ``MemoryDef``\ s; and ``MemoryUse``\ s by consulting whatever alias analysis stack you happen to; be using. Walkers were built to be flexible, though, so it's entirely reasonable; (and expected) to create more specialized walkers (e.g. one that specifically; queries ``GlobalsAA``, one that always stops at ``MemoryPhi`` nodes, etc). Default walker APIs; ^^^^^^^^^^^^^^^^^^^. There are two main APIs used to retrieve the clobbering access using the walker:. - ``MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA);`` return the; clobbering memory access for ``MA``, caching all intermediate results; computed along the way as part of each access queried. - ``MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, const MemoryLocation &Loc);``; returns the access clobbering memory location ``Loc``, starting at ``MA``.; Because this API does not request the clobbering access of a specific memory; access, there are no results that can be cached. Locating clobbers yourself; ^^^^^^^^^^^^^^^^^^^^^^^^^^. If you choose to make your own walker, you can find the clobber for a; ``MemoryAccess`` by walking every ``MemoryDef`` that dominates said; ``MemoryAccess``. The structure of ``MemoryDef``\ s makes this relatively simple;; they ultimately form a linked list of every clobber that dominates the; ``MemoryAccess`` that you're trying to optimize. In other words, the; ``definingAccess`` of a ``MemoryDef`` is always the nearest dominating; ``MemoryDef`` or ``MemoryPhi`` of said ``MemoryDef``. Use and Def optimization; ------------------------. ``M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:10001,access,access,10001,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,2,['access'],['access']
Security,"verage.html>`_,; to visualize and study your code coverage; (`example <https://github.com/google/fuzzer-test-suite/blob/master/tutorial/libFuzzerTutorial.md#visualizing-coverage>`_). User-supplied mutators; ----------------------. LibFuzzer allows to use custom (user-supplied) mutators, see; `Structure-Aware Fuzzing <https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md>`_; for more details. Startup initialization; ----------------------; If the library being tested needs to be initialized, there are several options. The simplest way is to have a statically initialized global object inside; `LLVMFuzzerTestOneInput` (or in global scope if that works for you):. .. code-block:: c++. extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {; static bool Initialized = DoInitialization();; ... Alternatively, you may define an optional init function and it will receive; the program arguments that you can read and modify. Do this **only** if you; really need to access ``argv``/``argc``. .. code-block:: c++. extern ""C"" int LLVMFuzzerInitialize(int *argc, char ***argv) {; ReadAndMaybeModify(argc, argv);; return 0;; }. Using libFuzzer as a library; ----------------------------; If the code being fuzzed must provide its own `main`, it's possible to; invoke libFuzzer as a library. Be sure to pass ``-fsanitize=fuzzer-no-link``; during compilation, and link your binary against the no-main version of; libFuzzer. On Linux installations, this is typically located at:. .. code-block:: bash. /usr/lib/<llvm-version>/lib/clang/<clang-version>/lib/linux/libclang_rt.fuzzer_no_main-<architecture>.a. If building libFuzzer from source, this is located at the following path; in the build output directory:. .. code-block:: bash. lib/linux/libclang_rt.fuzzer_no_main-<architecture>.a. From here, the code can do whatever setup it requires, and when it's ready; to start fuzzing, it can call `LLVMFuzzerRunDriver`, passing in the program; arguments and a callba",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:24383,access,access,24383,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['access'],['access']
Security,"verflow. Issues caught by this sanitizer are; not undefined behavior, but are often unintentional.; - ``-fsanitize=signed-integer-overflow``: Signed integer overflow, where the; result of a signed integer computation cannot be represented in its type.; This includes all the checks covered by ``-ftrapv``, as well as checks for; signed division overflow (``INT_MIN/-1``), but not checks for; lossy implicit conversions performed before the computation; (see ``-fsanitize=implicit-conversion``). Both of these two issues are; handled by ``-fsanitize=implicit-conversion`` group of checks.; - ``-fsanitize=unreachable``: If control flow reaches an unreachable; program point.; - ``-fsanitize=unsigned-integer-overflow``: Unsigned integer overflow, where; the result of an unsigned integer computation cannot be represented in its; type. Unlike signed integer overflow, this is not undefined behavior, but; it is often unintentional. This sanitizer does not check for lossy implicit; conversions performed before such a computation; (see ``-fsanitize=implicit-conversion``).; - ``-fsanitize=vla-bound``: A variable-length array whose bound; does not evaluate to a positive value.; - ``-fsanitize=vptr``: Use of an object whose vptr indicates that it is of; the wrong dynamic type, or that its lifetime has not begun or has ended.; Incompatible with ``-fno-rtti``. Link must be performed by ``clang++``, not; ``clang``, to make sure C++-specific parts of the runtime library and C++; standard libraries are present. You can also use the following check groups:; - ``-fsanitize=undefined``: All of the checks listed above other than; ``float-divide-by-zero``, ``unsigned-integer-overflow``,; ``implicit-conversion``, ``local-bounds`` and the ``nullability-*`` group; of checks.; - ``-fsanitize=undefined-trap``: Deprecated alias of; ``-fsanitize=undefined``.; - ``-fsanitize=implicit-integer-truncation``: Catches lossy integral; conversions. Enables ``implicit-signed-integer-truncation`` and; ``implicit-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:9471,sanitiz,sanitizer,9471,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['sanitiz'],['sanitizer']
Security,"version 5.16 and version 5.18 in addition to these notes. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities. Binaries for all supported platforms are available at:. http://root.cern.ch/root/Version520.html; Versions for AFS have also been updated. See the list of supported; platforms:; http://root.cern.ch/Welcome.html. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Ilka Antcheva,; Jean-Fran�ois Bastien, ; Bertrand Bellenot,; Rene Brun,; Philippe Canal,; Olivier Couet,; Valeri Fine,; Leo Franco, ; Gerri Ganis,; Andrei Gheata,; Mihaela Gheata,; David Gonzalez Maline, ; Andreas Hoecker, ; Jan Iwaszkiewicz, ; Lukasz Janyst, ; Anna Kreshuk, ; Wim Lavrijsen,; Sergei Linev,; Anar Manafov, ; Diego Marcos-Segura, ; Lorenzo Moneta,; Axel Naumann,; Mathieu de Naurois, ; Eddy Offermann, ; Valeriy Onuchin,; Timur Pocheptsov,; Fons Rademakers,; Paul Russo, ; Alja Tadel, ; Matevz Tadel, ; Wouter Verkerke, ; Guido Volpi, ; Hady Zalek . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v520/index.html:1112,authenticat,authentication,1112,doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v520/index.html,1,['authenticat'],['authentication']
Security,"verts automatically to an integer, which represents the status code of the fit. If the Fit method is used as before, there is a no visible change for the user.; When using the fit option ""S"", the TFitResultPtr will now contain a pointer to the new TFitResult class. It will behave as a smart pointer to TFitResult,; by using the -> operator the user can call the TFitResult methods or access directly the TFitResult object, by using the de-reference operator * or; TFitResultPtr::Get().; The TFitResult class derives from the ROOT::Math::FitResult, which contains all the result information from a fit and from TNamed. It provides then I/O capabilities for the FitResult object and convenience methods like Print(), Write(), GetCovarianceMatrix() and GetCorrelationMatrix() which return a TMatrixDSym object.; Example of usage:; ; TFitResult r = h->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Value(0); // retrieve the value for the parameter 0; Double_t err0 = r->Error(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. FitPanel. Added predefined 2D Functions.; Addition of new minimization algorithms from the GSL library and foreseen the addition of; genetic minimizers when will be released.; Fixed up to three bugs from the previous release; Added the Update Button. This way the user can update the content of the fitpanel with all the new objects and functions created in the current ROOT session.; Changed the way the TF1s were being copied internally. Instead of using TObject::Clone, now it's using the TF1 copy constructor. new tutorial rebin.C; This tutorial illustrates how to:. create a variable binwidth histogram with a binning such; that the population per bin is about the same.; rebin a variable binwidth histogram into another one. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:5466,access,access,5466,hist/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html,1,['access'],['access']
Security,"very; small trip counts. .. image:: epilogue-vectorization-cfg.png. Performance; -----------. This section shows the execution time of Clang on a simple benchmark:; `gcc-loops <https://github.com/llvm/llvm-test-suite/tree/main/SingleSource/UnitTests/Vectorizer>`_.; This benchmarks is a collection of loops from the GCC autovectorization; `page <http://gcc.gnu.org/projects/tree-ssa/vectorization.html>`_ by Dorit Nuzman. The chart below compares GCC-4.7, ICC-13, and Clang-SVN with and without loop vectorization at -O3, tuned for ""corei7-avx"", running on a Sandybridge iMac.; The Y-axis shows the time in msec. Lower is better. The last column shows the geomean of all the kernels. .. image:: gcc-loops.png. And Linpack-pc with the same configuration. Result is Mflops, higher is better. .. image:: linpack-pc.png. Ongoing Development Directions; ------------------------------. .. toctree::; :hidden:. VectorizationPlan. :doc:`VectorizationPlan`; Modeling the process and upgrading the infrastructure of LLVM's Loop Vectorizer. .. _slp-vectorizer:. The SLP Vectorizer; ==================. Details; -------. The goal of SLP vectorization (a.k.a. superword-level parallelism) is; to combine similar independent instructions; into vector instructions. Memory accesses, arithmetic operations, comparison; operations, PHI-nodes, can all be vectorized using this technique. For example, the following function performs very similar operations on its; inputs (a1, b1) and (a2, b2). The basic-block vectorizer may combine these; into vector operations. .. code-block:: c++. void foo(int a1, int a2, int b1, int b2, int *A) {; A[0] = a1*(a1 + b1);; A[1] = a2*(a2 + b2);; A[2] = a1*(a1 + b1);; A[3] = a2*(a2 + b2);; }. The SLP-vectorizer processes the code bottom-up, across basic blocks, in search of scalars to combine. Usage; ------. The SLP Vectorizer is enabled by default, but it can be disabled; through clang using the command line flag:. .. code-block:: console. $ clang -fno-slp-vectorize file.c; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:13449,access,accesses,13449,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['access'],['accesses']
Security,"view-ghash Emit type record hashes in a .debug$H section; -gcodeview Generate CodeView debug information; -gline-directives-only Emit debug line info directives only; -gline-tables-only Emit debug line number tables only; -miamcu Use Intel MCU ABI; -mllvm <value> Additional arguments to forward to LLVM's option processing; -nobuiltininc Disable builtin #include directories; -Qunused-arguments Don't emit warning for unused driver arguments; -R<remark> Enable the specified remark; --target=<value> Generate code for the given target; --version Print version information; -v Show commands to run and use verbose output; -W<warning> Enable the specified warning; -Xclang <arg> Pass <arg> to the clang compiler. The /clang: Option; ^^^^^^^^^^^^^^^^^^. When clang-cl is run with a set of ``/clang:<arg>`` options, it will gather all; of the ``<arg>`` arguments and process them as if they were passed to the clang; driver. This mechanism allows you to pass flags that are not exposed in the; clang-cl options or flags that have a different meaning when passed to the clang; driver. Regardless of where they appear in the command line, the ``/clang:``; arguments are treated as if they were passed at the end of the clang-cl command; line. The /Zc:dllexportInlines- Option; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This causes the class-level `dllexport` and `dllimport` attributes to not apply; to inline member functions, as they otherwise would. For example, in the code; below `S::foo()` would normally be defined and exported by the DLL, but when; using the ``/Zc:dllexportInlines-`` flag it is not:. .. code-block:: c. struct __declspec(dllexport) S {; void foo() {}; }. This has the benefit that the compiler doesn't need to emit a definition of; `S::foo()` in every translation unit where the declaration is included, as it; would otherwise do to ensure there's a definition in the DLL even if it's not; used there. If the declaration occurs in a header file that's widely used, this; can save signific",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:186494,expose,exposed,186494,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['expose'],['exposed']
Security,virtual function call”; Unknown. 1517; drafting; Unclear/missing description of behavior during construction/destruction; Not resolved. 1518; CD4; Explicit default constructors and copy-list-initialization; Clang 4. 1519; NAD; Conflicting default and variadic constructors; Unknown. 1520; NAD; Alias template specialization vs pack expansion; Unknown. 1521; drafting; T{expr} with reference types; Not resolved. 1522; CD3; Access checking for initializer_list array initialization; Unknown. 1523; CD5; Point of declaration in range-based for; Unknown. 1524; drafting; Incompletely-defined class template base; Not resolved. 1525; NAD; Array bound inference in temporary array; Unknown. 1526; dup; Dependent-class lookup in the current instantiation; Unknown. 1527; CD3; Assignment from braced-init-list; Unknown. 1528; CD3; Repeated cv-qualifiers in declarators; Unknown. 1529; drafting; Nomenclature for variable vs reference non-static data member; Not resolved. 1530; drafting; Member access in out-of-lifetime objects; Not resolved. 1531; CD3; Definition of “access” (verb); Unknown. 1532; CD3; Explicit instantiation and member templates; Unknown. 1533; CD3; Function pack expansion for member initialization; Unknown. 1534; dup; cv-qualification of prvalue of type “array of class”; Unknown. 1535; CD3; typeid in core constant expressions; Unknown. 1536; drafting; Overload resolution with temporary from initializer list; Not resolved. 1537; CD3; Optional compile-time evaluation of constant expressions; Unknown. 1538; CD3; C-style cast in braced-init-list assignment; Unknown. 1539; CD3; Definition of “character type”; Unknown. 1540; NAD; Use of address constants in constant expressions; Unknown. 1541; CD3; cv void return types; Unknown. 1542; drafting; Compound assignment of braced-init-list; Not resolved. 1543; CD3; Implicit conversion sequence for empty initializer list; Unknown. 1544; CD3; Linkage of member of unnamed namespace; Unknown. 1545; NAD; friend function templates defin,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:102977,access,access,102977,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['access'],['access']
Security,"visibility of the symbols automatically created when using binary; input or :option:`--add-symbol`. Valid options are:. - `default`; - `hidden`; - `internal`; - `protected`. The default is `default`. .. option:: --output-target <format>, -O. Write the output as the specified format. See `SUPPORTED FORMATS`_ for a list; of valid ``<format>`` values. If unspecified, the output format is assumed to; be the same as the value specified for :option:`--input-target` or the input; file's format if that option is also unspecified. .. option:: --pad-to <address>. For binary outputs, pad the output to the load address ``<address>`` using a value; of zero or the value specified by :option:`--gap-fill`. .. option:: --prefix-alloc-sections <prefix>. Add ``<prefix>`` to the front of the names of all allocatable sections in the; output. .. option:: --prefix-symbols <prefix>. Add ``<prefix>`` to the front of every symbol name in the output. .. option:: --preserve-dates, -p. Preserve access and modification timestamps in the output. .. option:: --rename-section <old>=<new>[,<flag>,...]. Rename sections called ``<old>`` to ``<new>`` in the output, and apply any; specified ``<flag>`` values. See :option:`--set-section-flags` for a list of; supported flags. Can be specified multiple times to rename multiple sections. .. option:: --set-section-type <section>=<type>. Set the type of section ``<section>`` to the integer ``<type>``. Can be; specified multiple times to update multiple sections. .. option:: --set-start-addr <addr>. Set the start address of the output to ``<addr>``. Overrides any previously; specified :option:`--change-start` or :option:`--adjust-start` options. .. option:: --split-dwo <dwo-file>. Equivalent to running :program:`llvm-objcopy` with :option:`--extract-dwo` and; ``<dwo-file>`` as the output file and no other options, and then with; :option:`--strip-dwo` on the input file. .. option:: --strip-dwo. Remove all DWARF .dwo sections from the output. .. option:: --strip-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-objcopy.rst:16007,access,access,16007,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-objcopy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-objcopy.rst,1,['access'],['access']
Security,"vm-jitlink`` to; connect to an already running executor via TCP on the given host and port. To; use this option you will need to start ``llvm-jitlink-executor`` manually with; ``listen=<host>:<port>`` as the first argument. Harness mode; ------------. The ``-harness`` option allows a set of input objects to be designated as a test; harness, with the regular object files implicitly treated as objects to be; tested. Definitions of symbols in the harness set override definitions in the; test set, and external references from the harness cause automatic scope; promotion of local symbols in the test set (these modifications to the usual; linker rules are accomplished via an ``ObjectLinkingLayer::Plugin`` installed by; ``llvm-jitlink`` when it sees the ``-harness`` option). With these modifications in place we can selectively test functions in an object; file by mocking those function's callees. For example, suppose we have an object; file, ``test_code.o``, compiled from the following C source (which we need not; have access to):. .. code-block:: c. void irrelevant_function() { irrelevant_external(); }. int function_to_mock(int X) {; return /* some function of X */;; }. static void function_to_test() {; ...; int Y = function_to_mock();; printf(""Y is %i\n"", Y);; }. If we want to know how ``function_to_test`` behaves when we change the behavior; of ``function_to_mock`` we can test it by writing a test harness:. .. code-block:: c. void function_to_test();. int function_to_mock(int X) {; printf(""used mock utility function\n"");; return 42;; }. int main(int argc, char *argv[]) {; function_to_test():; return 0;; }. Under normal circumstances these objects could not be linked together:; ``function_to_test`` is static and could not be resolved outside; ``test_code.o``, the two ``function_to_mock`` functions would result in a; duplicate definition error, and ``irrelevant_external`` is undefined.; However, using ``-harness`` and ``-phony-externals`` we can run this code; with:. .. co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:41271,access,access,41271,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['access'],['access']
Security,"vm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0, ptr %arrayidx1, !llvm.access.group !1; ...; br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; !1 = distinct !{}. It is also possible to have nested parallel loops:. .. code-block:: llvm. outer.for.body:; ...; %val1 = load i32, ptr %arrayidx3, !llvm.access.group !4; ...; br label %inner.for.body. inner.for.body:; ...; %val0 = load i32, ptr %arrayidx1, !llvm.access.group !3; ...; store i32 %val0, ptr %arrayidx2, !llvm.access.group !3; ...; br i1 %exitcond, label %inner.for.end, label %inner.for.body, !llvm.loop !1. inner.for.end:; ...; store i32 %val1, ptr %arrayidx4, !llvm.access.group !4; ...; br i1 %exitcond, label %outer.for.end, label %outer.for.body, !llvm.loop !2. outer.for.end: ; preds = %for.body; ...; !1 = distinct !{!1, !{!""llvm.loop.parallel_accesses"", !3}} ; metadata for the inner loop; !2 = distinct !{!2, !{!""llvm.loop.parallel_accesses"", !3, !4}} ; metadata for the outer loop; !3 = distinct !{} ; access group ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:313286,access,access,313286,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"vm.launder.invariant.group``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address; space. The returned pointer must belong to the same address space as the; argument. ::. declare ptr @llvm.launder.invariant.group.p0(ptr <ptr>). Overview:; """""""""""""""""". The '``llvm.launder.invariant.group``' intrinsic can be used when an invariant; established by ``invariant.group`` metadata no longer holds, to obtain a new; pointer value that carries fresh invariant group information. It is an; experimental intrinsic, which means that its semantics might change in the; future. Arguments:; """""""""""""""""""". The ``llvm.launder.invariant.group`` takes only one argument, which is a pointer; to the memory. Semantics:; """""""""""""""""""". Returns another pointer that aliases its argument but which is considered different; for the purposes of ``load``/``store`` ``invariant.group`` metadata.; It does not read any accessible memory and the execution can be speculated. '``llvm.strip.invariant.group``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address; space. The returned pointer must belong to the same address space as the; argument. ::. declare ptr @llvm.strip.invariant.group.p0(ptr <ptr>). Overview:; """""""""""""""""". The '``llvm.strip.invariant.group``' intrinsic can be used when an invariant; established by ``invariant.group`` metadata no longer holds, to obtain a new pointer; value that does not carry the invariant information. It is an experimental; intrinsic, which means that its semantics might change in the future. Arguments:; """""""""""""""""""". The ``llvm.strip.invariant.group`` takes only one argument, which is a pointer; to the memory. Semantics:; """""""""""""""""""". Returns another pointer that aliases its argument but which has no associated; ``invariant.group`` metadata.; It does not read any memory and can be speculated",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:866048,access,accessible,866048,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessible']
Security,"void @llvm.memset.inline.p0.p0.i64(ptr <dest>, i8 <val>,; i64 <len>, i1 <isvolatile>). Overview:; """""""""""""""""". The '``llvm.memset.inline.*``' intrinsics fill a block of memory with a; particular byte value and guarantees that no external functions are called. Note that, unlike the standard libc function, the ``llvm.memset.inline.*``; intrinsics do not return a value, take an extra isvolatile argument and the; pointer can be in specified address spaces. Arguments:; """""""""""""""""""". The first argument is a pointer to the destination to fill, the second; is the byte value with which to fill it, the third argument is a constant; integer argument specifying the number of bytes to fill, and the fourth; is a boolean indicating a volatile access. The :ref:`align <attr_align>` parameter attribute can be provided; for the first argument. If the ``isvolatile`` parameter is ``true``, the ``llvm.memset.inline`` call is; a :ref:`volatile operation <volatile>`. The detailed access behavior is not; very cleanly specified and it is unwise to depend on it. Semantics:; """""""""""""""""""". The '``llvm.memset.inline.*``' intrinsics fill ""len"" bytes of memory starting; at the destination location. If the argument is known to be; aligned to some boundary, this can be specified as an attribute on; the argument. ``len`` must be a constant expression.; If ``<len>`` is 0, it is no-op modulo the behavior of attributes attached to; the arguments.; If ``<len>`` is not a well-defined value, the behavior is undefined.; If ``<len>`` is not zero, ``<dest>`` should be well-defined, otherwise the; behavior is undefined. The behavior of '``llvm.memset.inline.*``' is equivalent to the behavior of; '``llvm.memset.*``', but the generated code is guaranteed not to call any; external functions. .. _int_sqrt:. '``llvm.sqrt.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.sqrt`` on any; floating-point or vector of floating-point type. Not all targets support;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:555797,access,access,555797,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"void foo(int x) {; assert(x);; //...; }. we compile this to:; _foo:; 	subl	$28, %esp; 	call	""L1$pb""; ""L1$pb"":; 	popl	%eax; 	cmpl	$0, 32(%esp); 	je	LBB1_2	# cond_true; LBB1_1:	# return; 	# ...; 	addl	$28, %esp; 	ret; LBB1_2:	# cond_true; ... The PIC base computation (call+popl) is only used on one path through the ; code, but is currently always computed in the entry block. It would be ; better to sink the picbase computation down into the block for the ; assertion, as it is the only one that uses it. This happens for a lot of ; code with early outs. Another example is loads of arguments, which are usually emitted into the ; entry block on targets like x86. If not used in all paths through a ; function, they should be sunk into the ones that do. In this case, whole-function-isel would also handle this. //===---------------------------------------------------------------------===//. Investigate lowering of sparse switch statements into perfect hash tables:; http://burtleburtle.net/bob/hash/perfect.html. //===---------------------------------------------------------------------===//. We should turn things like ""load+fabs+store"" and ""load+fneg+store"" into the; corresponding integer operations. On a yonah, this loop:. double a[256];; void foo() {; int i, b;; for (b = 0; b < 10000000; b++); for (i = 0; i < 256; i++); a[i] = -a[i];; }. is twice as slow as this loop:. long long a[256];; void foo() {; int i, b;; for (b = 0; b < 10000000; b++); for (i = 0; i < 256; i++); a[i] ^= (1ULL << 63);; }. and I suspect other processors are similar. On X86 in particular this is a; big win because doing this with integers allows the use of read/modify/write; instructions. //===---------------------------------------------------------------------===//. DAG Combiner should try to combine small loads into larger loads when ; profitable. For example, we compile this C++ example:. struct THotKey { short Key; bool Control; bool Shift; bool Alt; };; extern THotKey m_HotKey;; THotKey GetHotKey (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:13084,hash,hash,13084,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['hash'],['hash']
Security,"void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data as buffer size; }. Unix Alpha Checkers. Name, DescriptionExample. alpha.unix.BlockInCriticalSection; (C); Check for calls to blocking functions inside a critical section. Applies to:. lock; unlock; sleep; getc; fgets; read; revc; pthread_mutex_lock; pthread_mutex_unlock; mtx_lock; mtx_timedlock; mtx_trylock; mtx_unlock; lock_guard; uniq",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:11639,secur,security,11639,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['secur'],['security']
Security,"ware equipped with; incompatible firmware. If hardware has compatible firmware the 256 bytes at the; start of the kernel entry will be skipped. .. _amdgpu-amdhsa-kernel-prolog:. Kernel Prolog; ~~~~~~~~~~~~~. The compiler performs initialization in the kernel prologue depending on the; target and information about things like stack usage in the kernel and called; functions. Some of this initialization requires the compiler to request certain; User and System SGPRs be present in the; :ref:`amdgpu-amdhsa-initial-kernel-execution-state` via the; :ref:`amdgpu-amdhsa-kernel-descriptor`. .. _amdgpu-amdhsa-kernel-prolog-cfi:. CFI; +++. 1. The CFI return address is undefined. 2. The CFI CFA is defined using an expression which evaluates to a location; description that comprises one memory location description for the; ``DW_ASPACE_AMDGPU_private_lane`` address space address ``0``. .. _amdgpu-amdhsa-kernel-prolog-m0:. M0; ++. GFX6-GFX8; The M0 register must be initialized with a value at least the total LDS size; if the kernel may access LDS via DS or flat operations. Total LDS size is; available in dispatch packet. For M0, it is also possible to use maximum; possible value of LDS for given target (0x7FFF for GFX6 and 0xFFFF for; GFX7-GFX8).; GFX9-GFX11; The M0 register is not used for range checking LDS accesses and so does not; need to be initialized in the prolog. .. _amdgpu-amdhsa-kernel-prolog-stack-pointer:. Stack Pointer; +++++++++++++. If the kernel has function calls it must set up the ABI stack pointer described; in :ref:`amdgpu-amdhsa-function-call-convention-non-kernel-functions` by setting; SGPR32 to the unswizzled scratch offset of the address past the last local; allocation. .. _amdgpu-amdhsa-kernel-prolog-frame-pointer:. Frame Pointer; +++++++++++++. If the kernel needs a frame pointer for the reasons defined in; ``SIFrameLowering`` then SGPR33 is used and is always set to ``0`` in the; kernel prolog. If a frame pointer is not required then all uses of the frame",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:192700,access,access,192700,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"way to query the supported features of the compiler.; See `the C++ status page <https://clang.llvm.org/cxx_status.html#ts>`_ for; information on the version of SD-6 supported by each Clang release, and the; macros provided by that revision of the recommendations. C++98; -----. The features listed below are part of the C++98 standard. These features are; enabled by default when compiling C++ code. C++ exceptions; ^^^^^^^^^^^^^^. Use ``__has_feature(cxx_exceptions)`` to determine if C++ exceptions have been; enabled. For example, compiling code with ``-fno-exceptions`` disables C++; exceptions. C++ RTTI; ^^^^^^^^. Use ``__has_feature(cxx_rtti)`` to determine if C++ RTTI has been enabled. For; example, compiling code with ``-fno-rtti`` disables the use of RTTI. C++11; -----. The features listed below are part of the C++11 standard. As a result, all; these features are enabled with the ``-std=c++11`` or ``-std=gnu++11`` option; when compiling C++ code. C++11 SFINAE includes access control; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_access_control_sfinae)`` or; ``__has_extension(cxx_access_control_sfinae)`` to determine whether; access-control errors (e.g., calling a private constructor) are considered to; be template argument deduction errors (aka SFINAE errors), per `C++ DR1170; <http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1170>`_. C++11 alias templates; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_alias_templates)`` or; ``__has_extension(cxx_alias_templates)`` to determine if support for C++11's; alias declarations and alias templates is enabled. C++11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_alignas)`` or ``__has_extension(cxx_alignas)`` to; determine if support for alignment specifiers using ``alignas`` is enabled. Use ``__has_feature(cxx_alignof)`` or ``__has_extension(cxx_alignof)`` to; determine if support for the ``alignof`` keyword is enabled. C++11 attributes; ^^^^^^^^^^^^^^^^. Use ``__has_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:40139,access,access,40139,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['access'],['access']
Security,"when an expected type is used (often called; ""type confusion"").; * A hot case may be speculatively executed due to prediction instead of the; correct case for a switch statement implemented as a jump table.; * A hot common return address may be predicted incorrectly when returning from; a function. These code patterns are also vulnerable to Spectre variant #2, and as such are; best mitigated with a; [retpoline](https://support.google.com/faqs/answer/7625886) on x86 platforms.; When a mitigation technique like retpoline is used, speculation simply cannot; proceed through an indirect control flow edge (or it cannot be mispredicted in; the case of a filled RSB) and so it is also protected from variant #1 style; attacks. However, some architectures, micro-architectures, or vendors do not; employ the retpoline mitigation, and on future x86 hardware (both Intel and; AMD) it is expected to become unnecessary due to hardware-based mitigation. When not using a retpoline, these edges will need independent protection from; variant #1 style attacks. The analogous approach to that used for conditional; control flow should work:; ```; uintptr_t all_ones_mask = std::numerical_limits<uintptr_t>::max();; uintptr_t all_zeros_mask = 0;; void leak(int data);; void example(int* pointer1, int* pointer2) {; uintptr_t predicate_state = all_ones_mask;; switch (condition) {; case 0:; // Assuming ?: is implemented using branchless logic...; predicate_state = (condition != 0) ? all_zeros_mask : predicate_state;; // ... lots of code ...; //; // Harden the pointer so it can't be loaded; pointer1 &= predicate_state;; leak(*pointer1);; break;. case 1:; predicate_state = (condition != 1) ? all_zeros_mask : predicate_state;; // ... more code ...; //; // Alternative: Harden the loaded value; int value2 = *pointer2 & predicate_state;; leak(value2);; break;. // ...; }; }; ```. The core idea remains the same: validate the control flow using data-flow and; use that validation to check that loads cannot le",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:9650,attack,attacks,9650,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attacks']
Security,"when browser off; ```. If necessary, one also can automatically open ROOT file when web page is opened:. ```cpp; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; ```. ## Configuring user access. By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the **htdigest** utility. ```bash; [shell] htdigest -c .htdigest domain_name user_name; ```. It is recommended not to use special symbols in domain or user names. Several users can be add to the "".htdigest"" file. When starting the server, the following arguments should be specified:. ```cpp; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; ```. After that, the web browser will automatically request to input a name/password for the domain ""domain_name"". Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using `THttpServer::Restrict()` method. For instance, one could hide complete folder from 'guest' account:. ```cpp; serv->Restrict(""/Folder"", ""hidden=guest"");; ```. Or one could hide from all but 'admin' account:. ```cpp; serv->Restrict(""/Folder"", ""visible=admin"");; ```. Hidden folders or objects can not be accessed via http protocol. By default server runs in readonly mode and do not allow methods execution via 'exe.json' or 'exe.bin' requests. To allow such action, one could either grant generic access for all or one could allow to execute only special method:. ```cpp; serv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; ```. One could provide several options for the same item, separating them with '&' sign:. ```cpp; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; ```. Complete list of supported options could be found in [TRootSniffer:Restrict()](https://root.cern/doc/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:8816,authoriz,authorized,8816,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,2,"['access', 'authoriz']","['access', 'authorized']"
Security,"which is being miscompiled. The miscompilation debugger assumes that; the selected code generator is working properly. Advice for using bugpoint; =========================. ``bugpoint`` can be a remarkably useful tool, but it sometimes works in; non-obvious ways. Here are some hints and tips:. * In the code generator and miscompilation debuggers, ``bugpoint`` only works; with programs that have deterministic output. Thus, if the program outputs; ``argv[0]``, the date, time, or any other ""random"" data, ``bugpoint`` may; misinterpret differences in these data, when output, as the result of a; miscompilation. Programs should be temporarily modified to disable outputs; that are likely to vary from run to run. * In the `crash debugger`_, ``bugpoint`` does not distinguish different crashes; during reduction. Thus, if new crash or miscompilation happens, ``bugpoint``; will continue with the new crash instead. If you would like to stick to; particular crash, you should write check scripts to validate the error; message, see ``-compile-command`` in :doc:`CommandGuide/bugpoint`. * In the code generator and miscompilation debuggers, debugging will go faster; if you manually modify the program or its inputs to reduce the runtime, but; still exhibit the problem. * ``bugpoint`` is extremely useful when working on a new optimization: it helps; track down regressions quickly. To avoid having to relink ``bugpoint`` every; time you change your optimization however, have ``bugpoint`` dynamically load; your optimization with the ``-load`` option. * ``bugpoint`` can generate a lot of output and run for a long period of time.; It is often useful to capture the output of the program to file. For example,; in the C shell, you can run:. .. code-block:: console. $ bugpoint ... |& tee bugpoint.log. to get a copy of ``bugpoint``'s output in the file ``bugpoint.log``, as well; as on your terminal. * ``bugpoint`` cannot debug problems with the LLVM linker. If ``bugpoint``; crashes before you see",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:6450,validat,validate,6450,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['validat'],['validate']
Security,"which points into the callers parameter; with offset known to be inside of the ``offset`` range. ``calls`` will be; consumed and removed by thin link stage to update ``Param::offset`` so it; covers all accesses possible by ``calls``. Pointer parameter without corresponding ``Param`` is considered unsafe and we; assume that access with any offset is possible. Example:. If we have the following function:. .. code-block:: text. define i64 @foo(ptr %0, ptr %1, ptr %2, i8 %3) {; store ptr %1, ptr @x; %5 = getelementptr inbounds i8, ptr %2, i64 5; %6 = load i8, ptr %5; %7 = getelementptr inbounds i8, ptr %2, i8 %3; tail call void @bar(i8 %3, ptr %7); %8 = load i64, ptr %0; ret i64 %8; }. We can expect the record like this:. .. code-block:: text. params: ((param: 0, offset: [0, 7]),(param: 2, offset: [5, 5], calls: ((callee: ^3, param: 1, offset: [-128, 127])))). The function may access just 8 bytes of the parameter %0 . ``calls`` is empty,; so the parameter is either not used for function calls or ``offset`` already; covers all accesses from nested function calls.; Parameter %1 escapes, so access is unknown.; The function itself can access just a single byte of the parameter %2. Additional; access is possible inside of the ``@bar`` or ``^3``. The function adds signed; offset to the pointer and passes the result as the argument %1 into ``^3``.; This record itself does not tell us how ``^3`` will access the parameter.; Parameter %3 is not a pointer. .. _refs_summary:. Refs; ^^^^. The optional ``Refs`` field looks like:. .. code-block:: text. refs: ((Ref)[, (Ref)]*). where each ``Ref`` contains a reference to the summary id of the referenced; value (e.g. ``^1``). .. _typeidinfo_summary:. TypeIdInfo; ^^^^^^^^^^. The optional ``TypeIdInfo`` field, used for; `Control Flow Integrity <https://clang.llvm.org/docs/ControlFlowIntegrity.html>`_,; looks like:. .. code-block:: text. typeIdInfo: [(TypeTests)]?[, (TypeTestAssumeVCalls)]?[, (TypeCheckedLoadVCalls)]?[, (TypeTestAssumeConstV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:346016,access,accesses,346016,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accesses']
Security,"which points to a chain of entries for the bucket. Each bucket must; contain a next pointer, full 32 bit hash value, the string itself, and the data; for the current string value. .. code-block:: none. .------------.; 0x000034f0: | 0x00003500 | next pointer; | 0x12345678 | 32 bit hash; | ""erase"" | string value; | data[n] | HashData for this bucket; |------------|; 0x00003500: | 0x00003550 | next pointer; | 0x29273623 | 32 bit hash; | ""dump"" | string value; | data[n] | HashData for this bucket; |------------|; 0x00003550: | 0x00000000 | next pointer; | 0x82638293 | 32 bit hash; | ""main"" | string value; | data[n] | HashData for this bucket; `------------'. The problem with this layout for debuggers is that we need to optimize for the; negative lookup case where the symbol we're searching for is not present. So; if we were to lookup ""``printf``"" in the table above, we would make a 32-bit; hash for ""``printf``"", it might match ``bucket[3]``. We would need to go to; the offset 0x000034f0 and start looking to see if our 32 bit hash matches. To; do so, we need to read the next pointer, then read the hash, compare it, and; skip to the next bucket. Each time we are skipping many bytes in memory and; touching new pages just to do the compare on the full 32 bit hash. All of; these accesses then tell us that we didn't have a match. Name Hash Tables; """""""""""""""""""""""""""""""". To solve the issues mentioned above we have structured the hash tables a bit; differently: a header, buckets, an array of all unique 32 bit hash values,; followed by an array of hash value data offsets, one for each hash value, then; the data for all hash values:. .. code-block:: none. .-------------.; | HEADER |; |-------------|; | BUCKETS |; |-------------|; | HASHES |; |-------------|; | OFFSETS |; |-------------|; | DATA |; `-------------'. The ``BUCKETS`` in the name tables are an index into the ``HASHES`` array. By; making all of the full 32 bit hash values contiguous in memory, we allow; ourselves to efficien",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:62476,hash,hash,62476,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"will build just clang.; ninja check-clang This will run the clang tests. Clang Compiler Driver (Drop-in Substitute for GCC); The clang tool is the compiler driver and front-end, which is; designed to be a drop-in replacement for the gcc command. Here are; some examples of how to use the high-level driver:. $ cat t.c; #include <stdio.h>; int main(int argc, char **argv) { printf(""hello world\n""); }; $ clang t.c; $ ./a.out; hello world. The 'clang' driver is designed to work as closely to GCC as possible to; maximize portability. The only major difference between the two is that; Clang defaults to gnu99 mode while GCC defaults to gnu89 mode. If you see; weird link-time errors relating to inline functions, try passing -std=gnu89; to clang.; Examples of using Clang. $ cat ~/t.c; typedef float V __attribute__((vector_size(16)));; V foo(V a, V b) { return a+b*a; }. Preprocessing:. $ clang ~/t.c -E; # 1 ""/Users/sabre/t.c"" 1. typedef float V __attribute__((vector_size(16)));. V foo(V a, V b) { return a+b*a; }. Type checking:. $ clang -fsyntax-only ~/t.c. GCC options:. $ clang -fsyntax-only ~/t.c -pedantic; /Users/sabre/t.c:2:17: warning: extension used; typedef float V __attribute__((vector_size(16)));; ^; 1 diagnostic generated. Pretty printing from the AST:; Note, the -cc1 argument indicates the compiler front-end, and; not the driver, should be run. The compiler front-end has several additional; Clang specific features which are not exposed through the GCC compatible driver; interface. $ clang -cc1 ~/t.c -ast-print; typedef float V __attribute__(( vector_size(16) ));; V foo(V a, V b) {; return a + b * a;; }. Code generation with LLVM:. $ clang ~/t.c -S -emit-llvm -o -; define <4 x float> @foo(<4 x float> %a, <4 x float> %b) {; entry:; %mul = mul <4 x float> %b, %a; %add = add <4 x float> %mul, %a; ret <4 x float> %add; }; $ clang -fomit-frame-pointer -O3 -S -o - t.c # On x86_64; ...; _foo:; Leh_func_begin1:; 	mulps	%xmm0, %xmm1; 	addps	%xmm1, %xmm0; 	ret; Leh_func_end1:. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:8122,expose,exposed,8122,interpreter/llvm-project/clang/www/get_started.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html,1,['expose'],['exposed']
Security,"will decide together on where to; draw this line in individual cases. Where possible, any conversations with; offenders should not be done by people who know them, as it can be very; unpleasant for everyone involved. If a report is received concerning a committee member, that member must not be; involved in the response process. The rest of the committee will meet and; decide on the report without the reported committee member being present, and; will not share more information than they would have with a non-member. If a; member of the committee is found to have violated the CoC, they may no longer; be able to keep serving on the committee. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. However, the Code of Conduct Committee will always; comply with law enforcement when directed. In the case that a CoC committee; member is involved in a report, the member will be asked to recuse themselves; from ongoing conversations, and they will not have access to reports after the; enforcement decision has been made. . In the event of a temporary suspension or ban, the appropriate people must be; notified of the ban in order to restrict access to infrastructure or events.; These individuals will only be notified of the person's name and the; restrictions imposed. They will be under a confidentiality clause and not; allowed to respond to questions regarding the ban and should direct all; questions to the CoC committee. . .. _Transparency Reports:. Transparency Reports; ====================. Lack of transparency in the outcomes of our Code of Conduct incidents leaves; our community without an understanding of how or if the organizers worked to; resolve incidents. The CoC committee should aim to publish transparency; reports, if reports are received, after major events (such as the LLVM; Developers' meetings) and on the following dates: Jan 15, April 15, July 15,; Oct 15. . A transparency",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:11481,access,access,11481,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['access'],['access']
Security,"will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18625,access,access,18625,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['access'],['access']
Security,"wing experimental checkers (please provide feedback):. Warns about unsafe uses of CFArrayCreate, CFSetCreate, and CFDictionaryCreate; Warns about unsafe uses of getpw, gets, which are sources of buffer overflows; Warns about unsafe uses of mktemp and mktemps, which can lead to insecure temporary files; Warns about unsafe uses of vfork, which is insecure to use; Warns about not checking the return values of setuid, setgid, seteuid, setegid, setreuid, setregid (another security issue). checker-259; built: January 25, 2012; highlights:. Contains a newer version of the analyzer than the one shipped in Xcode 4.2.; Significant performance optimizations to reduce memory usage of the analyzer.; Tweaks to scan-build to have it work more easily with Xcode projects using Clang.; Numerous bug fixes to better support code using ARC. checker-258; built: October 13, 2011; highlights:. Contains a newer version of the analyzer than the one shipped in Xcode 4.2.; Adds a new security checker for looking at correct uses of the Mac OS KeyChain API.; Supports ARC (please file bugs where you see issues); Major under-the-cover changes. This should result in more precise results in some cases, but this is laying the groundwork for major improvements. Please file bugs where you see regressions or issues. checker-257; built: May 25, 2011; highlights:. The analyzer is now far more aggressive with checking conformance with Core Foundation conventions. Any function that returns a CF type must now obey the Core Foundation naming conventions, or use the cf_returns_retained or cf_returns_not_retained annotations.; Fixed a serious regression where the analyzer would not analyze Objective-C methods in class extensions.; Misc. bug fixes to improve analyzer precision.; . checker-256; built: April 13, 2011; highlights:. Lots of bug fixes and improvements to analyzer precision (fewer false positives, possibly more bugs found).; Introductory analysis support for C++ and Objective-C++. This build contains b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:10351,secur,security,10351,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,1,['secur'],['security']
Security,"with the abstract and opaque ``SCEV`` class.; Given this analysis, trip counts of loops and other important properties can be; obtained. This analysis is primarily useful for induction variable substitution and; strength reduction. ``scev-aa``: ScalarEvolution-based Alias Analysis; -------------------------------------------------. Simple alias analysis implemented in terms of ``ScalarEvolution`` queries. This differs from traditional loop dependence analysis in that it tests for; dependencies within a single iteration of a loop, rather than dependencies; between different iterations. ``ScalarEvolution`` has a more complete understanding of pointer arithmetic; than ``BasicAliasAnalysis``' collection of ad-hoc analyses. ``stack-safety``: Stack Safety Analysis; ---------------------------------------. The ``StackSafety`` analysis can be used to determine if stack allocated; variables can be considered safe from memory access bugs. This analysis' primary purpose is to be used by sanitizers to avoid unnecessary; instrumentation of safe variables. Transform Passes; ================. This section describes the LLVM Transform Passes. ``adce``: Aggressive Dead Code Elimination; ------------------------------------------. ADCE aggressively tries to eliminate code. This pass is similar to :ref:`DCE; <passes-dce>` but it assumes that values are dead until proven otherwise. This; is similar to :ref:`SCCP <passes-sccp>`, except applied to the liveness of; values. ``always-inline``: Inliner for ``always_inline`` functions; ----------------------------------------------------------. A custom inliner that handles only functions that are marked as ""always; inline"". ``argpromotion``: Promote 'by reference' arguments to scalars; -------------------------------------------------------------. This pass promotes ""by reference"" arguments to be ""by value"" arguments. In; practice, this means looking for internal functions that have pointer; arguments. If it can prove, through the use of ali",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:11639,sanitiz,sanitizers,11639,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['sanitiz'],['sanitizers']
Security,"work which are dealt with in parallel;; - The Async template function has been added the ROOT::Experimental namespace. The template function is analogous; to *std::async* but without the possibility of specifying the execution policy and without creating a thread but; directly submitting the work to the runtime in order to use the same pool as any other item of work spawned by ROOT.; - The TFuture template has been added to the ROOT::Experimental namespace. It represents a future and is compatible; with the ROOT::Experimental::Async function. It has the same properties of an STL future and can be initialised by; one of these classes. For example, *TFuture<int> = std::async(myfunc,a,b,c);*; - Reintroduced greedy reduction in TProcessExecutor.; - Fix empty chunks in the result vector of TThreadExecutor::Map. If the integer partition of the data in nChunks causes the existence of empty chunks (e.g the—rounded up—division of 12 elements in 5 chunks), the number of chunks is decreased to avoid empty chunks and, as a consequence, accesses to uninitialized memory in the reduction step. ## Language Bindings; - PyROOT now supports list initialisation with tuples. For example, suppose to have a function `void f(const TH1F& h)`. In C++, this can be invoked with this syntax: `f({""name"", ""title"", 64, -4, 4})`. In PyROOT this translates too `f(('name', 'title', 64, -4, 4))`. ## JavaScript ROOT. Upgrade JSROOT to v5.3.1. Following new features implemented:. - New supported classes:; - TGraphPolar; - TGraphTime; - TSpline3; - TSpline5; - TPolyLine3D; - TPolyMarker; - TEfficiency; - TH1K; - New supported options:; * ""PFC"" - auto fill color (histograms and graphs); * ""PLC"" - auto line color; * ""PMC"" - auto marker color; * ""A"" - fully disables axes drawing for histograms painters; * ""TEXT"" - for TH2Poly; * ""SAMES"" - draw stat box for superimposed histograms; * ""NOCOL"" - ignore stored in the TCanvas colors list; * ""NOPAL"" - ignore stored in the TCanvas color palette; - Improvements in e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:24756,access,accesses,24756,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['access'],['accesses']
Security,"write this as:. .. code-block:: c++. std::vector<foo> V;; for ( ... ) {; // make use of V.; V.clear();; }. Doing so will save (at least) one heap allocation and free per iteration of the; loop. .. _dss_deque:. <deque>; ^^^^^^^. ``std::deque`` is, in some senses, a generalized version of ``std::vector``.; Like ``std::vector``, it provides constant time random access and other similar; properties, but it also provides efficient access to the front of the list. It; does not guarantee continuity of elements within memory. In exchange for this extra flexibility, ``std::deque`` has significantly higher; constant factor costs than ``std::vector``. If possible, use ``std::vector`` or; something cheaper. .. _dss_list:. <list>; ^^^^^^. ``std::list`` is an extremely inefficient class that is rarely useful. It; performs a heap allocation for every element inserted into it, thus having an; extremely high constant factor, particularly for small data types.; ``std::list`` also only supports bidirectional iteration, not random access; iteration. In exchange for this high cost, std::list supports efficient access to both ends; of the list (like ``std::deque``, but unlike ``std::vector`` or; ``SmallVector``). In addition, the iterator invalidation characteristics of; std::list are stronger than that of a vector class: inserting or removing an; element into the list does not invalidate iterator or pointers to other elements; in the list. .. _dss_ilist:. llvm/ADT/ilist.h; ^^^^^^^^^^^^^^^^. ``ilist<T>`` implements an 'intrusive' doubly-linked list. It is intrusive,; because it requires the element to store and provide access to the prev/next; pointers for the list. ``ilist`` has the same drawbacks as ``std::list``, and additionally requires an; ``ilist_traits`` implementation for the element type, but it provides some novel; characteristics. In particular, it can efficiently store polymorphic objects,; the traits class is informed when an element is inserted or removed from the; list, an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:66147,access,access,66147,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['access']
Security,"ws; may require more extensive changes: please get involved if you are interested; in porting this feature. .. code-block:: console. # Step 2: Run the program.; % LLVM_PROFILE_FILE=""foo.profraw"" ./foo. Note that continuous mode is also used on Fuchsia where it's the only supported; mode, but the implementation is different. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; level of indirection. On every counter access, we add a bias to the counter; address. This bias is stored in ``__llvm_profile_counter_bias`` symbol that's; provided by the profile runtime and is initially set to zero, meaning no; relocation. The runtime can map the profile into memory at arbitrary locations,; and set bias to the offset between the original and the new counter location,; at which point every subsequent counter access will be to the new location,; which allows updating profile directly akin to the continuous mode. The advantage of this approach is that doesn't require any special OS support.; The disadvantage is the extra overhead due to additional instructions required; for each counter access (overhead both in terms of binary size and performance); plus duplication of counters (i.e. one copy in the binary itself and another; copy that's mapped into memory). This implementation can be also enabled for; other platforms by passing the ``-runtime-counter-relocation`` option to the; backend during compilation. For a program such as the `Lit <https://llvm.org/docs/CommandGuide/lit.html>`_; testing tool which invokes other programs, it may be necessary to set; ``LLVM_PROFILE_FILE`` for each invocation. The pattern strings ""%p"" or ""%Nm""; may help to avoid corruption due to concurrency. Note that ""%p"" is also a Lit; token and needs to be escaped as ""%%p"". ..",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:4762,access,access,4762,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['access'],['access']
Security,"wsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to `modules/gui.mjs` script like:. ```javascript; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; ```. In the main `<div>` element one can specify many custom parameters like one do it in URL string:. ```html; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; ```. ## Reading local ROOT files. JSROOT can read files from local file system using HTML5 FileReader functionality.; Main limitation here - user should interactively select files for reading.; There is button __""...""__ on the main JSROOT page, which starts file selection dialog.; If valid ROOT file is selected, JSROOT will be able to normally read content of such file. ## JSROOT with THttpServer. THttpServer provides http access to objects from running ROOT application.; JSROOT is used to implement the user interface in the web browsers. The layout of the main page coming from THttpServer is very similar to normal JSROOT page.; One could browse existing items and display them. A snapshot of running; server can be seen on the [demo page](https://root.cern/js/latest/httpserver.C/). One could also specify similar URL parameters to configure the displayed items and drawing options. It is also possible to display one single item from the THttpServer server like:. <https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz>. ## Data monitoring with JSROOT. ### Monitoring with http server. The best possibility to organize the monitoring of data from a running application; is to use THttpServer. In such case the client can always access the latest; changes and request only the items currently displayed in the browser.; To enable monitoring, one should activate the appropriate checkbox or; provide __m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:29798,access,access,29798,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['access'],['access']
Security,"x ``index``; into the array. The return type ``ret_type`` is a pointer type to the array element.; The array ``dim`` and ``index`` are preserved which is more robust than; getelementptr instruction which may be subject to compiler transformation.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide array or pointer debuginfo type.; The metadata is a ``DICompositeType`` or ``DIDerivedType`` representing the; debuginfo version of ``type``. Arguments:; """""""""""""""""""". The ``base`` is the array base address. The ``dim`` is the array dimension.; The ``base`` is a pointer if ``dim`` equals 0.; The ``index`` is the last access index into the array or pointer. The ``base`` argument must be annotated with an :ref:`elementtype; <attr_elementtype>` attribute at the call-site. This attribute specifies the; getelementptr element type. Semantics:; """""""""""""""""""". The '``llvm.preserve.array.access.index``' intrinsic produces the same result; as a getelementptr with base ``base`` and access operands ``{dim's 0's, index}``. '``llvm.preserve.union.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <type>; @llvm.preserve.union.access.index.p0s_union.anons.p0s_union.anons(<type> base,; i32 di_index). Overview:; """""""""""""""""". The '``llvm.preserve.union.access.index``' intrinsic carries the debuginfo field index; ``di_index`` and returns the ``base`` address.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide union debuginfo type.; The metadata is a ``DICompositeType`` representing the debuginfo version of ``type``.; The return type ``type`` is the same as the ``base`` type. Arguments:; """""""""""""""""""". The ``base`` is the union base address. The ``di_index`` is the field index in debuginfo. Semantics:; """""""""""""""""""". The '``llvm.preserve.union.access.index``' intrinsic returns the ``base`` address. '``llvm.preserve.struct.access.index``' Intrinsic; ^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:973930,access,access,973930,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"x and there's a lot going on inside it.; This makes it difficult to write a test that reliably tests a particular aspect; of its behaviour. For comparison, see the following diagram:. .. image:: testing-pass-level.png. Each of the grey boxes indicates an opportunity to serialize the current state; and test the behaviour between two points in the pipeline. The current state; can be serialized using ``-stop-before`` or ``-stop-after`` and loaded using; ``-start-before``, ``-start-after``, and ``-run-pass``. We can also go further still, as many of GlobalISel's passes are readily unit; testable:. .. image:: testing-unit-level.png. It's possible to create an imaginary target such as in `LegalizerHelperTest.cpp <https://github.com/llvm/llvm-project/blob/93b29d3882baf7df42e4e9bc26b977b00373ef56/llvm/unittests/CodeGen/GlobalISel/LegalizerHelperTest.cpp#L28-L57>`_; and perform a single step of the algorithm and check the result. The MIR and; FileCheck directives can be embedded using strings so you still have access to; the convenience available in llvm-lit. Debugging; ---------. One debugging technique that's proven particularly valuable is to use the; BlockExtractor to extract basic blocks into new functions. This can be used; to track down correctness bugs and can also be used to track down performance; regressions. It can also be coupled with function attributes to disable; GlobalISel for one or more of the extracted functions. .. image:: block-extract.png. The command to do the extraction is:. .. code-block:: shell. ./bin/llvm-extract -o - -S -b ‘foo:bb1;bb4’ <input> > extracted.ll. This particular example extracts two basic blocks from a function named ``foo``.; The new LLVM-IR can then be modified to add the ``failedISel`` attribute to the; extracted function containing bb4 to make that function use SelectionDAG. This can prevent some optimizations as GlobalISel is generally able to work on a; single function at a time. This technique can be repeated for different; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/Pipeline.rst:5035,access,access,5035,interpreter/llvm-project/llvm/docs/GlobalISel/Pipeline.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/Pipeline.rst,1,['access'],['access']
Security,"x have already done so, and if the reporter does not object. Collaboration; -------------. Members of the LLVM Security Group are expected to:. * Promptly share any LLVM vulnerabilities they become aware of.; * Volunteer to drive issues forward.; * Help evaluate the severity of incoming issues.; * Help write and review patches to address security issues.; * Participate in the member nomination and removal processes. Discussion Medium; =================. *FUTURE*: this section needs more work! Where discussions occur is influenced by other factors that are still open in this document. We can finalize it later.; It seems like bugzilla and email don't meet security requirements. The medium used to host LLVM Security Group discussions is security-sensitive. It should therefore run on infrastructure which can meet our security expectations. We are currently using the `chromium issue tracker`_ (as the `llvm` project) to have security discussions:. * File security issues.; * Discuss security improvements to LLVM. When a new issue is filed, a template is provided to help issue reporters provide all relevant information. *FUTURE*: The `Github security`_ workflow allows publicly disclosing resolved security issues on the github project page, and we would be interested in adopting it for that purpose. However, it does not easily allow confidential reporting of security issues, as creating Github Security Advisories is currently restricted to Github project admins. That is why we have started with the `chromium issue tracker`_ instead. We also occasionally need to discuss logistics of the LLVM Security Group itself:. * Nominate new members.; * Propose member removal.; * Suggest policy changes. We often have these discussions publicly, in our :ref:`monthly public sync-up call <online-sync-ups>` and on the Discourse forums. For internal or confidential discussions, we also use a private mailing list. Process; =======. The following process occurs on the discussion medium for each",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:11099,secur,security,11099,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security']
Security,"x parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607 1 0.547723 8.39663e-18; 0.408248 0.547723 1 9.36796e-18; 1.35011e-18 8.39663e-18 9.36796e-18 1. MnGlobalCorrelationCoeff:. 0.408248; 0.547723; 0.621261; 0. ## CVS code repository ##. How to check out (–in) code from the CVS code repository is described at; the M homepage @bib-C++MINUIT. To get the source code from the CVS; repository one needs to do:. Kerberos IV authorization:. $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit. Anonymous read-only access (if it's enabled by the librarian, see; details):. $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login. (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS; password:cvs. $ cvs co MathLibs/Minuit. (If you want to check out a tagged version SEAL\_x\_x\_x of MINUIT, then; do. $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ). ## Create a tar.gz from CVS ##. Once the sources are checked out from the CVS code repository,. 1. change to the directory:. $ cd MathLibs/Minuit. 2. run autogen:. $ ./autogen. 3. create a new directory:. $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/. 4. run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL project; @bib-SEAL at CERN @bib-CERN. ### From to ###. The program is entirely written in standard portable . M does not depend; on any ext",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:24075,access,access,24075,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['access'],['access']
Security,"xbins );; ]] >; </ioreadraw>. The variables in the rules have the following meaning:. * sourceClass - The field defines the on-disk class that is the input for the rule.; * source - A semicolon-separated list of values defining the source class data members; that need to be cached and accessible via object proxy when the rule is; executed. The values are either the names of the data members or the type-name; pairs (separated by a space). If types are specified then the ondisk structure; can be generated and used in the code snippet defined by the user.; * version - A list of versions of the source class that can be an input for this rule.; The list has to be enclosed in a square bracket and be a comma-separated; list of versions or version ranges. The version is an integer number, whereas; the version range is one of the following:; – ""a-b"" - a and b are integers and the expression means all the numbers between; and including a and b; – ""-a"" - a is an integer and the expression means all the version numbers smaller; than or equal to a; – ""a-"" - a is an integer and the expression means all the version numbers greater; than or equal to a; * checksum - A list of checksums of the source class that can be an input for this; rule. The list has to be enclosed in a square brackets and is a; comma-separated list of integers.; * targetClass - The field is obligatory and defines the name of the in-memory class that; this rule can be applied to.; * target - A semicolon-separated list of target class data member names that this rule; is capable of calculating.; * embed - This property tells the system if the rule should be written in the output; file is some objects of this class are serialized.; * include - A list of header files that should be included in order to provide the func-; tionality used in the code snippet; the list is comma delimited.; * code - An user specified code snippet. The user can assume that in the provided code snippet the following variables; will be defi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/DataModelEvolution.txt:3942,checksum,checksum,3942,io/doc/DataModelEvolution.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/DataModelEvolution.txt,2,['checksum'],"['checksum', 'checksums']"
Security,"xed addresses. This primarily consists of accesses; at compile-time constant offsets of global and local variables. Code which; needs this protection and intentionally stores secret data must ensure the; memory regions used for secret data are necessarily dynamic mappings or heap; allocations. This is an area which can be tuned to provide more comprehensive; protection at the cost of performance.; * [Hardened loads](#hardening-the-address-of-the-load) may still load data from; _valid_ addresses if not _attacker-controlled_ addresses. To prevent these; from reading secret data, the low 2gb of the address space and 2gb above and; below any executable pages should be protected. Credit:; * The core idea of tracing misspeculation through data and marking pointers to; block misspeculated loads was developed as part of a HACS 2018 discussion; between Chandler Carruth, Paul Kocher, Thomas Pornin, and several other; individuals.; * Core idea of masking out loaded bits was part of the original mitigation; suggested by Jann Horn when these attacks were reported. ### Indirect Branches, Calls, and Returns. It is possible to attack control flow other than conditional branches with; variant #1 style mispredictions.; * A prediction towards a hot call target of a virtual method can lead to it; being speculatively executed when an expected type is used (often called; ""type confusion"").; * A hot case may be speculatively executed due to prediction instead of the; correct case for a switch statement implemented as a jump table.; * A hot common return address may be predicted incorrectly when returning from; a function. These code patterns are also vulnerable to Spectre variant #2, and as such are; best mitigated with a; [retpoline](https://support.google.com/faqs/answer/7625886) on x86 platforms.; When a mitigation technique like retpoline is used, speculation simply cannot; proceed through an indirect control flow edge (or it cannot be mispredicted in; the case of a filled RSB) and so",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:8323,attack,attacks,8323,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attacks']
Security,"xpected-warning{{'4'}}; size_t ys = clang_analyzer_getExtent(&y);; clang_analyzer_explain(ys); // expected-warning{{'8'}}; }. - ``void clang_analyzer_printState();``. Dumps the current ProgramState to the stderr. Quickly lookup the program state; at any execution point without ViewExplodedGraph or re-compiling the program.; This is not very useful for writing tests (apart from testing how ProgramState; gets printed), but useful for debugging tests. Also, this method doesn't; produce a warning, so it gets printed on the console before all other; ExprInspection warnings. Example usage::. void foo() {; int x = 1;; clang_analyzer_printState(); // Read the stderr!; }. - ``void clang_analyzer_hashDump(int);``. The analyzer can generate a hash to identify reports. To debug what information; is used to calculate this hash it is possible to dump the hashed string as a; warning of an arbitrary expression using the function above. Example usage::. void foo() {; int x = 1;; clang_analyzer_hashDump(x); // expected-warning{{hashed string for x}}; }. - ``void clang_analyzer_denote(int, const char *);``. Denotes symbols with strings. A subsequent call to clang_analyzer_express(); will expresses another symbol in terms of these string. Useful for testing; relationships between different symbols. Example usage::. void foo(int x) {; clang_analyzer_denote(x, ""$x"");; clang_analyzer_express(x + 1); // expected-warning{{$x + 1}}; }. - ``void clang_analyzer_express(int);``. See clang_analyzer_denote(). - ``void clang_analyzer_isTainted(a single argument of any type);``. Queries the analyzer whether the expression used as argument is tainted or not.; This is useful in tests, where we don't want to issue warning for all tainted; expressions but only check for certain expressions.; This would help to reduce the *noise* that the `TaintTest` debug checker would; introduce and let you focus on the `expected-warning`'s that you really care; about. Example usage::. int read_integer() {; int n;; cla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:9097,hash,hashed,9097,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,1,['hash'],['hashed']
Security,"xt of the access operation.*. *These operations obtain a register location. To fetch the contents of a; register, it is necessary to use* ``DW_OP_regval_type``\ *, use one of the*; ``DW_OP_breg*`` *register-based addressing operations, or use* ``DW_OP_deref*``; *on a register location description.*. .. _amdgpu-dwarf-implicit-location-description-operations:. A.2.5.4.4.5 Implicit Location Description Operations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. note::. This section replaces DWARF Version 5 section 2.6.1.1.4. Implicit location storage represents a piece or all of an object which has no; actual location in the program but whose contents are nonetheless known, either; as a constant or can be computed from other locations and values in the program. An implicit location description specifies an implicit location storage. The bit; offset corresponds to a bit position within the implicit location storage. Bits; accessed using an implicit location description, access the corresponding; implicit storage value starting at the bit offset. 1. ``DW_OP_implicit_value``. ``DW_OP_implicit_value`` has two operands. The first is an unsigned LEB128; integer that represents a byte size S. The second is a block of bytes with a; length equal to S treated as a literal value V. An implicit location storage LS is created with the literal value V and a; size of S. It pushes location description L with one implicit location description SL; on the stack. SL specifies LS with a bit offset of 0. 2. ``DW_OP_stack_value``. ``DW_OP_stack_value`` pops one stack entry that must be a value V. An implicit location storage LS is created with the literal value V using; the size, encoding, and endianity specified by V's base type. It pushes a location description L with one implicit location description SL; on the stack. SL specifies LS with a bit offset of 0. *The* ``DW_OP_stack_value`` *operation specifies that the object does not; exist in memory, but its value is nonetheless kno",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:120786,access,accessed,120786,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,2,['access'],"['access', 'accessed']"
Security,"xt`` while another thread might be; modifying it. One way to do that is to always hold the JIT lock while accessing; IR outside the JIT (the JIT *modifies* the IR by adding ``CallbackVH``\ s).; Another way is to only call ``getPointerToFunction()`` from the; ``LLVMContext``'s thread. When the JIT is configured to compile lazily (using; ``ExecutionEngine::DisableLazyCompilation(false)``), there is currently a `race; condition <https://bugs.llvm.org/show_bug.cgi?id=5184>`_ in updating call sites; after a function is lazily-jitted. It's still possible to use the lazy JIT in a; threaded program if you ensure that only one thread at a time can call any; particular lazy stub and that the JIT lock guards any IR access, but we suggest; using only the eager JIT in threaded programs. .. _advanced:. Advanced Topics; ===============. This section describes some of the advanced or obscure API's that most clients; do not need to be aware of. These API's tend manage the inner workings of the; LLVM system, and only need to be accessed in unusual circumstances. .. _SymbolTable:. The ``ValueSymbolTable`` class; ------------------------------. The ``ValueSymbolTable`` (`doxygen; <https://llvm.org/doxygen/classllvm_1_1ValueSymbolTable.html>`__) class provides; a symbol table that the :ref:`Function <c_Function>` and Module_ classes use for; naming value definitions. The symbol table can provide a name for any Value_. Note that the ``SymbolTable`` class should not be directly accessed by most; clients. It should only be used when iteration over the symbol table names; themselves are required, which is very special purpose. Note that not all LLVM; Value_\ s have names, and those without names (i.e. they have an empty name) do; not exist in the symbol table. Symbol tables support iteration over the values in the symbol table with; ``begin/end/iterator`` and supports querying to see if a specific name is in the; symbol table (with ``lookup``). The ``ValueSymbolTable`` class exposes no; publ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:125474,access,accessed,125474,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['accessed']
Security,"y & xz & xt \\; yx & yy & yz & yt \\; zx & zy & zz & zt \\; tx & ty & tz & tt; \end{array}; \right|; $$. ### Declaration. By default it is initialized to the identity matrix, but it may also be; initialized by other **`TLorentzRotation`**, by a pure **`TRotation`**; or by a boost:. ``` {.cpp}; TLorentzRotation l; // l is initialized as identity; TLorentzRotation m(l);// m = l; TRotation r;; TLorentzRotation lr(r);; TLorentzRotation lb1(bx,by,bz);; TVector3 b;; TLorentzRotation lb2(b);; ```. The Matrix for a Lorentz boosts is:. $$; \left|; \begin{array}{cccc}; 1+gamma'*bx*bx & gamma'*bx*by & gamma'*bx*bz & gamma*bx \\; gamma'*bx*bz & 1+gamma'*by*by & gamma'*by*by & gamma*by \\; gamma'*bz*bx & gamma'*bz*by & 1+gamma'*bz*bz & gamma*bz \\; gamma*bx & gamma*by & gamma*bz & gamma; \end{array}; \right|; $$. with the boost vector `b=(bx,by,bz)`;; `gamma=1/Sqrt(1-beta*beta)`;` gamma'=(gamma-1)/beta*beta.`. ### Access to the Matrix Components/Comparisons. The access to the matrix components is possible with the methods `XX()`,; `XY()` ... `TT()`, and with the operator` (int,int)`:. ``` {.cpp}; Double_t xx;; TLorentzRotation l;; xx = l.XX(); // gets the xx component; xx = l(0,0); // gets the xx component; if (l == m) {...} // test for equality; if (l != m) {...} // test for inequality; if (l.IsIdentity()) {...} // test for identity; ```. ### Transformations of a Lorentz Rotation. There are four possibilities to find the product of two; **`TLorentzRotation`** transformations:. ``` {.cpp}; TLorentzRotation a,b,c;; c = b*a; // product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b; // a=a*b; c = a.Transform(b) // a=b*a then c=a; ```. Lorentz boosts:. ``` {.cpp}; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; ```. Rotations:. ``` {.cpp}; TVector3 axis;; l.RotateX(TMath::Pi()); // rotation around x-axis; l.Rotate(.5,axis); // rotation around specified vector; ```. Inverse transformation: use the method `Inverse() `to ret",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:16131,access,access,16131,documentation/users-guide/PhysicsVectors.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md,1,['access'],['access']
Security,"y be applied to one; parameter. .. _swiftasync:. ``swiftasync``; This indicates that the parameter is the asynchronous context parameter and; triggers the creation of a target-specific extended frame record to store; this pointer. This is not a valid attribute for return values and can only; be applied to one parameter. ``swifterror``; This attribute is motivated to model and optimize Swift error handling. It; can be applied to a parameter with pointer to pointer type or a; pointer-sized alloca. At the call site, the actual argument that corresponds; to a ``swifterror`` parameter has to come from a ``swifterror`` alloca or; the ``swifterror`` parameter of the caller. A ``swifterror`` value (either; the parameter or the alloca) can only be loaded and stored from, or used as; a ``swifterror`` argument. This is not a valid attribute for return values; and can only be applied to one parameter. These constraints allow the calling convention to optimize access to; ``swifterror`` variables by associating them with a specific register at; call boundaries rather than placing them in memory. Since this does change; the calling convention, a function which uses the ``swifterror`` attribute; on a parameter is not ABI-compatible with one which does not. These constraints also allow LLVM to assume that a ``swifterror`` argument; does not alias any other memory visible within a function and that a; ``swifterror`` alloca passed as an argument does not escape. ``immarg``; This indicates the parameter is required to be an immediate; value. This must be a trivial immediate integer or floating-point; constant. Undef or constant expressions are not valid. This is; only valid on intrinsic declarations and cannot be applied to a; call site or arbitrary function. ``noundef``; This attribute applies to parameters and return values. If the value; representation contains any undefined or poison bits, the behavior is; undefined. Note that this does not refer to padding introduced by the; type'",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:63780,access,access,63780,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"y generating standard dwarf; information, and contains enough information for non-dwarf targets to; translate it as needed. This section describes the forms used to represent C and C++ programs. Other; languages could pattern themselves after this (which itself is tuned to; representing programs in the same way that DWARF does), or they could choose; to provide completely different forms if they don't fit into the DWARF model.; As support for debugging information gets added to the various LLVM; source-language front-ends, the information used should be documented here. The following sections provide examples of a few C/C++ constructs and; the debug information that would best describe those constructs. The; canonical references are the ``DINode`` classes defined in; ``include/llvm/IR/DebugInfoMetadata.h`` and the implementations of the; helper functions in ``lib/IR/DIBuilder.cpp``. C/C++ source file information; -----------------------------. ``llvm::Instruction`` provides easy access to metadata attached with an; instruction. One can extract line number information encoded in LLVM IR using; ``Instruction::getDebugLoc()`` and ``DILocation::getLine()``. .. code-block:: c++. if (DILocation *Loc = I->getDebugLoc()) { // Here I is an LLVM instruction; unsigned Line = Loc->getLine();; StringRef File = Loc->getFilename();; StringRef Dir = Loc->getDirectory();; bool ImplicitCode = Loc->isImplicitCode();; }. When the flag ImplicitCode is true then it means that the Instruction has been; added by the front-end but doesn't correspond to source code written by the user. For example. .. code-block:: c++. if (MyBoolean) {; MyObject MO;; ...; }. At the end of the scope the MyObject's destructor is called but it isn't written; explicitly. This information is useful to avoid to have counters on brackets when; making code coverage. C/C++ global variable information; ---------------------------------. Given an integer global variable declared as follows:. .. code-block:: c. _Alignas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:41662,access,access,41662,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['access'],['access']
Security,"y instrumentation of 'safe' variables. SafeStack is going to be the; first user. 'safe' variables can be defined as variables that can not be used out-of-scope; (e.g. use-after-return) or accessed out of bounds. In the future it can be; extended to track other variable properties. E.g. we plan to extend; implementation with a check to make sure that variable is always initialized; before every read to optimize use-of-uninitialized-memory checks. How it works; ============. The analysis is implemented in two stages:. The intra-procedural, or 'local', stage performs a depth-first search inside; functions to collect all uses of each alloca, including loads/stores and uses as; arguments functions. After this stage we know which parts of the alloca are used; by functions itself but we don't know what happens after it is passed as; an argument to another function. The inter-procedural, or 'global', stage, resolves what happens to allocas after; they are passed as function arguments. This stage performs a depth-first search; on function calls inside a single module and propagates allocas usage through; functions calls. When used with ThinLTO, the global stage performs a whole program analysis over; the Module Summary Index. Testing; =======. The analysis is covered with lit tests. We expect that users can tolerate false classification of variables as; 'unsafe' when in-fact it's 'safe'. This may lead to inefficient code. However, we; can't accept false 'safe' classification which may cause sanitizers to miss actual; bugs in instrumented code. To avoid that we want additional validation tool. AddressSanitizer may help with this validation. We can instrument all variables; as usual but additionally store stack-safe information in the; ``ASanStackVariableDescription``. Then if AddressSanitizer detects a bug on; a 'safe' variable we can produce an additional report to let the user know that; probably Stack Safety Analysis failed and we should check for a bug in the; compiler.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackSafetyAnalysis.rst:1831,sanitiz,sanitizers,1831,interpreter/llvm-project/llvm/docs/StackSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackSafetyAnalysis.rst,3,"['sanitiz', 'validat']","['sanitizers', 'validation']"
Security,"y list of available options (--help-list-hidden for more); --version - Display the version of this program. .. END_FORMAT_HELP. When the desired code formatting style is different from the available options,; the style can be customized using the ``-style=""{key: value, ...}""`` option or; by putting your style configuration in the ``.clang-format`` or ``_clang-format``; file in your project's directory and using ``clang-format -style=file``. An easy way to create the ``.clang-format`` file is:. .. code-block:: console. clang-format -style=llvm -dump-config > .clang-format. Available style options are described in :doc:`ClangFormatStyleOptions`. .clang-format-ignore; ====================. You can create ``.clang-format-ignore`` files to make ``clang-format`` ignore; certain files. A ``.clang-format-ignore`` file consists of patterns of file path; names. It has the following format:. * A blank line is skipped.; * Leading and trailing spaces of a line are trimmed.; * A line starting with a hash (``#``) is a comment.; * A non-comment line is a single pattern.; * The slash (``/``) is used as the directory separator.; * A pattern is relative to the directory of the ``.clang-format-ignore`` file; (or the root directory if the pattern starts with a slash). Patterns; containing drive names (e.g. ``C:``) are not supported.; * Patterns follow the rules specified in `POSIX 2.13.1, 2.13.2, and Rule 1 of; 2.13.3 <https://pubs.opengroup.org/onlinepubs/9699919799/utilities/; V3_chap02.html#tag_18_13>`_.; * A pattern is negated if it starts with a bang (``!``). To match all files in a directory, use e.g. ``foo/bar/*``. To match all files in; the directory of the ``.clang-format-ignore`` file, use ``*``.; Multiple ``.clang-format-ignore`` files are supported similar to the; ``.clang-format`` files, with a lower directory level file voiding the higher; level ones. Vim Integration; ===============. There is an integration for :program:`vim` which lets you run the; :program:`clang-format`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:5438,hash,hash,5438,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['hash'],['hash']
Security,"y looking at each function body,; and the declarations (not the definitions) of all the functions it interacts; with.; In order to support such reasoning, it should be possible to summarize; the behavior of each function, with respect to reference count; of its returned values and attributes.; By default, the following summaries are assumed:. All functions starting with get or Get,; unless they are returning subclasses of OSIterator,; are assumed to be returning at +0.; That is, the caller has no reference; count obligations with respect to the reference count of the returned object; and should leave it untouched.; . All other functions are assumed to return at +1.; That is, the caller has an obligation to release such objects.; . Functions are assumed not to change the reference count of their parameters,; including the implicit this parameter.; . These summaries can be overriden with the following; attributes:; Attribute 'os_returns_retained'; The os_returns_retained attribute (accessed through the macro ; LIBKERN_RETURNS_RETAINED) plays a role identical to ns_returns_retained for functions; returning OSObject subclasses.; The attribute indicates that it is a callers responsibility to release the; returned object. Attribute 'os_returns_not_retained'; The os_returns_not_retained attribute (accessed through the macro ; LIBKERN_RETURNS_NOT_RETAINED) plays a role identical to ns_returns_not_retained for functions; returning OSObject subclasses.; The attribute indicates that the caller should not change the retain; count of the returned object. Example. class MyClass {; OSObject *f;; LIBKERN_RETURNS_NOT_RETAINED OSObject *myFieldGetter();; }. // Note that the annotation only has to be applied to the function declaration.; OSObject * MyClass::myFieldGetter() {; return f;; }. Attribute 'os_consumed'; Similarly to ns_consumed attribute,; os_consumed (accessed through LIBKERN_CONSUMED) attribute,; applied to a parameter,; indicates that the call to the function consumes the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:15531,access,accessed,15531,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['access'],['accessed']
Security,"y the application.; The caller has to ensure that the lifetime of the object lasts during the I/O operations. An RNTuple writer that is constructed without a `TFile` object (`RNTupleWriter::Recreate()`) assumes exclusive access to the underlying file.; An RNTuple writer that uses a `TFile` for writing (`RNTupleWriter::Append()`) assumes that the `TFile` object outlives the writer's lifetime.; The serial writer assumes exclusive access to the underlying file during construction, destruction and `Fill()` as well as `CommitCluster()` and `FlushCluster()`.; For `FlushColumns()` and `FillNoFlush()`, the sequential writer assumes exclusive access only if buffered writing is turned off.; The parallel writer assumes exclusive access to the underlying file during all operations on the writer (e.g. construction and destruction) and all operations on any created fill context (e.g. `Fill()` and `FlushCluster()`).; Notable exceptions are `FlushColumns()` and `FillNoFlush()` which are guaranteed to never access the underlying `TFile` during parallel writing (which is always buffered). A `TFile` does not take ownership of any `RNTuple` objects. When reading data, RNTuple uses the `RMiniFile` and `RRawFile` classes to open a given storage path and find the `RNTuple` anchor.; When creating a `RNTupleReader` from an existing anchor object, RNTuple uses `RRawFile` only for files of dynamic type `TFile`, `TDavixFile`, and `TNetXNGFile`.; In either case, the `RRawFile` owns its own file descriptor and does not interfere with `TFile` objects concurrently reading the file.; For anchors from files of other dynamic type, including all other `TFile` subclasses, the file is wrapped in a `RRawFileTFile` and access is shared. On-Disk Encoding; ----------------. ### Writing Case; The following steps are taken to write RNTuple data to disk:. 1. On creation of the RNTupleWriter, the header is written to disk; 2. Upon `RNTupleWriter::Fill()`, the RField<T> class _serializes_ the object into its colu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:18395,access,access,18395,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['access'],['access']
Security,"y used to reference objects in memory. Pointer types may have an optional address space attribute defining; the numbered address space where the pointed-to object resides. For; example, ``ptr addrspace(5)`` is a pointer to address space 5.; In addition to integer constants, ``addrspace`` can also reference one of the; address spaces defined in the :ref:`datalayout string<langref_datalayout>`.; ``addrspace(""A"")`` will use the alloca address space, ``addrspace(""G"")``; the default globals address space and ``addrspace(""P"")`` the program address; space. The default address space is number zero. The semantics of non-zero address spaces are target-specific. Memory; access through a non-dereferenceable pointer is undefined behavior in; any address space. Pointers with the bit-value 0 are only assumed to; be non-dereferenceable in address space 0, unless the function is; marked with the ``null_pointer_is_valid`` attribute. If an object can be proven accessible through a pointer with a; different address space, the access may be modified to use that; address space. Exceptions apply if the operation is ``volatile``. Prior to LLVM 15, pointer types also specified a pointee type, such as; ``i8*``, ``[4 x i32]*`` or ``i32 (i32*)*``. In LLVM 15, such ""typed; pointers"" are still supported under non-default options. See the; `opaque pointers document <OpaquePointers.html>`__ for more information. .. _t_target_type:. Target Extension Type; """""""""""""""""""""""""""""""""""""""""". :Overview:. Target extension types represent types that must be preserved through; optimization, but are otherwise generally opaque to the compiler. They may be; used as function parameters or arguments, and in :ref:`phi <i_phi>` or; :ref:`select <i_select>` instructions. Some types may be also used in; :ref:`alloca <i_alloca>` instructions or as global values, and correspondingly; it is legal to use :ref:`load <i_load>` and :ref:`store <i_store>` instructions; on them. Full semantics for these types are defined by the targe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:171792,access,accessible,171792,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['access'],"['access', 'accessible']"
Security,"y.p0.p0.i32(ptr <dest>, ptr <src>,; i32 <len>, i1 <isvolatile>); declare void @llvm.memcpy.p0.p0.i64(ptr <dest>, ptr <src>,; i64 <len>, i1 <isvolatile>). Overview:; """""""""""""""""". The '``llvm.memcpy.*``' intrinsics copy a block of memory from the; source location to the destination location. Note that, unlike the standard libc function, the ``llvm.memcpy.*``; intrinsics do not return a value, takes extra isvolatile; arguments and the pointers can be in specified address spaces. Arguments:; """""""""""""""""""". The first argument is a pointer to the destination, the second is a; pointer to the source. The third argument is an integer argument; specifying the number of bytes to copy, and the fourth is a; boolean indicating a volatile access. The :ref:`align <attr_align>` parameter attribute can be provided; for the first and second arguments. If the ``isvolatile`` parameter is ``true``, the ``llvm.memcpy`` call is; a :ref:`volatile operation <volatile>`. The detailed access behavior is not; very cleanly specified and it is unwise to depend on it. Semantics:; """""""""""""""""""". The '``llvm.memcpy.*``' intrinsics copy a block of memory from the source; location to the destination location, which must either be equal or; non-overlapping. It copies ""len"" bytes of memory over. If the argument is known; to be aligned to some boundary, this can be specified as an attribute on the; argument. If ``<len>`` is 0, it is no-op modulo the behavior of attributes attached to; the arguments.; If ``<len>`` is not a well-defined value, the behavior is undefined.; If ``<len>`` is not zero, both ``<dest>`` and ``<src>`` should be well-defined,; otherwise the behavior is undefined. .. _int_memcpy_inline:. '``llvm.memcpy.inline``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.memcpy.inline`` on any; integer bit width and for different address spaces. Not all targets; support all bit widths however. ::. declare void @llvm.memcpy.inline.p0.p0",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:547894,access,access,547894,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"yclass.cxx:98: warning:; converting from ""void (Myclass::*)(void *)""to ""void *"" ); ```. Strictly speaking, `Thread0` must be a static member function to be; called from a thread. Some compilers, for example `gcc` version 2.95.2,; may not allow the `(void(*) (void*))s` cast and just stop if `Thread0`; is not static. On the other hand, if `Thread0` is static, no compiler; warnings are generated at all. Because the `'this'` pointer is passed in; `'arg'` in the call to `Thread0(void *arg),` you have access to the; instance of the class even if `Thread0` is static. Using the `'this'`; pointer, non static members can still be read and written from; `Thread0`, as long as you have provided Getter and Setter methods for; these members. For example:. ``` {.cpp}; Bool_t state = arg->GetRunStatus();; arg->SetRunStatus(state);; ```. Second, the pointer to the current instance of `Myclass`, i.e. (void\*); this, has to be passed as first argument of the threaded function; Thread0 (C++ member functions internally expect this pointer as first; argument to have access to class members of the same instance).; `pthreads` are made for simple C functions and do not know about Thread0; being a member function of a class. Thus, you have to pass this; information by hand, if you want to access all members of the `Myclass`; instance from the Thread0 function. Note: Method Thread0 cannot be a virtual member function, since the cast; of `Thread0` to `void(*)` in the **`TThread`** constructor may raise; problems with C++ virtual function table. However, Thread0 may call; another virtual member function virtual void `Myclass::Func0()` which; then can be overridden in a derived class of `Myclass`. (See example; `TMhs3`). Class `Myclass` may also provide a method to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:15550,access,access,15550,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['access'],['access']
Security,"ymbolic; offsets start from the base region!. Region Invalidation; -------------------. Unlike binding invalidation, region invalidation occurs when the entire; contents of a region may have changed---say, because it has been passed to a; function the analyzer can model, like memcpy, or because its address has; escaped, usually as an argument to an opaque function call. In these cases we; need to throw away not just all bindings within the region itself, but within; its entire cluster, since neighboring regions may be accessed via pointer; arithmetic. Region invalidation typically does even more than this, however. Because it; usually represents the complete escape of a region from the analyzer's model,; its *contents* must also be transitively invalidated. (For example, if a region; ``p`` of type ``int **`` is invalidated, the contents of ``*p`` and ``**p`` may; have changed as well.) The algorithm that traverses this transitive closure of; accessible regions is known as ClusterAnalysis, and is also used for finding; all live bindings in the store (in order to throw away the dead ones). The name; ""ClusterAnalysis"" predates the cluster-based organization of bindings, but; refers to the same concept: during invalidation and liveness analysis, all; bindings within a cluster must be treated in the same way for a conservative; model of program behavior. Default Bindings; ----------------. Most bindings in RegionStore are simple scalar values -- integers and pointers.; These are known as ""Direct"" bindings. However, RegionStore supports a second; type of binding called a ""Default"" binding. These are used to provide values to; all the elements of an aggregate type (struct or array) without having to; explicitly specify a binding for each individual element. When there is no Direct binding for a particular region, the store manager; looks at each super-region in turn to see if there is a Default binding. If so,; this value is used as the value of the original region. The sea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:4491,access,accessible,4491,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,1,['access'],['accessible']
Security,"ynamic detection; of accesses to uninitialized memory) are enabled for this function.; ``sanitize_thread``; This attribute indicates that ThreadSanitizer checks; (dynamic thread safety analysis) are enabled for this function.; ``sanitize_hwaddress``; This attribute indicates that HWAddressSanitizer checks; (dynamic address safety analysis based on tagged pointers) are enabled for; this function.; ``sanitize_memtag``; This attribute indicates that MemTagSanitizer checks; (dynamic address safety analysis based on Armv8 MTE) are enabled for; this function.; ``speculative_load_hardening``; This attribute indicates that; `Speculative Load Hardening <https://llvm.org/docs/SpeculativeLoadHardening.html>`_; should be enabled for the function body. Speculative Load Hardening is a best-effort mitigation against; information leak attacks that make use of control flow; miss-speculation - specifically miss-speculation of whether a branch; is taken or not. Typically vulnerabilities enabling such attacks are; classified as ""Spectre variant #1"". Notably, this does not attempt to; mitigate against miss-speculation of branch target, classified as; ""Spectre variant #2"" vulnerabilities. When inlining, the attribute is sticky. Inlining a function that carries; this attribute will cause the caller to gain the attribute. This is intended; to provide a maximally conservative model where the code in a function; annotated with this attribute will always (even after inlining) end up; hardened.; ``speculatable``; This function attribute indicates that the function does not have any; effects besides calculating its result and does not have undefined behavior.; Note that ``speculatable`` is not enough to conclude that along any; particular execution path the number of calls to this function will not be; externally observable. This attribute is only valid on functions; and declarations, not on individual call sites. If a function is; incorrectly marked as speculatable and really does exhibit; unde",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:101553,attack,attacks,101553,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['attack'],['attacks']
Security,"you must give the recipients all the rights that we gave; you. You must make sure that they, too, receive or can get the source; code. If you link other code with the library, you must provide; complete object files to the recipients, so that they can relink them; with the library after making changes to the library and recompiling; it. And you must show them these terms so they know their rights. We protect your rights with a two-step method: (1) we copyright the; library, and (2) we offer you this license, which gives you legal; permission to copy, distribute and/or modify the library. To protect each distributor, we want to make it very clear that; there is no warranty for the free library. Also, if the library is; modified by someone else and passed on, the recipients should know; that what they have is not the original version, so that the original; author's reputation will not be affected by problems that might be; introduced by others. Finally, software patents pose a constant threat to the existence of; any free program. We wish to make sure that a company cannot; effectively restrict the users of a free program by obtaining a; restrictive license from a patent holder. Therefore, we insist that; any patent license obtained for a version of the library must be; consistent with the full freedom of use specified in this license. Most GNU software, including some libraries, is covered by the; ordinary GNU General Public License. This license, the GNU Lesser; General Public License, applies to certain designated libraries, and; is quite different from the ordinary General Public License. We use; this license for certain libraries in order to permit linking those; libraries into non-free programs. When a program is linked with a library, whether statically or using; a shared library, the combination of the two is legally speaking a; combined work, a derivative of the original library. The ordinary; General Public License therefore permits such linking only if the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT:5240,threat,threat,5240,interpreter/cling/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT,1,['threat'],['threat']
Security,"ype for pointer type kernel; argument. Must be a power; of 2. Only present if; "".value_kind"" is; ""dynamic_shared_pointer"".; "".address_space"" string Kernel argument address space; qualifier. Only present if; "".value_kind"" is ""global_buffer"" or; ""dynamic_shared_pointer"". Values; are:. - ""private""; - ""global""; - ""constant""; - ""local""; - ""generic""; - ""region"". .. TODO::. Is ""global_buffer"" only ""global""; or ""constant""? Is; ""dynamic_shared_pointer"" always; ""local""? Can HCC allow ""generic""?; How can ""private"" or ""region""; ever happen?. "".access"" string Kernel argument access; qualifier. Only present if; "".value_kind"" is ""image"" or; ""pipe"". Values; are:. - ""read_only""; - ""write_only""; - ""read_write"". .. TODO::. Does this apply to; ""global_buffer""?. "".actual_access"" string The actual memory accesses; performed by the kernel on the; kernel argument. Only present if; "".value_kind"" is ""global_buffer"",; ""image"", or ""pipe"". This may be; more restrictive than indicated; by "".access"" to reflect what the; kernel actual does. If not; present then the runtime must; assume what is implied by; "".access"" and "".is_const"" . Values; are:. - ""read_only""; - ""write_only""; - ""read_write"". "".is_const"" boolean Indicates if the kernel argument; is const qualified. Only present; if "".value_kind"" is; ""global_buffer"". "".is_restrict"" boolean Indicates if the kernel argument; is restrict qualified. Only; present if "".value_kind"" is; ""global_buffer"". "".is_volatile"" boolean Indicates if the kernel argument; is volatile qualified. Only; present if "".value_kind"" is; ""global_buffer"". "".is_pipe"" boolean Indicates if the kernel argument; is pipe qualified. Only present; if "".value_kind"" is ""pipe"". .. TODO::. Can ""global_buffer"" be pipe; qualified?. ====================== ============== ========= ================================. .. _amdgpu-amdhsa-code-object-metadata-v4:. Code Object V4 Metadata; +++++++++++++++++++++++. . warning::; Code object V4 is not the default code object version emitted by this versi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:139961,access,access,139961,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"ype}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to define the feature; test macro on a per-target basis if needed. When in doubt, being conservative is better than being aggressive. If we don't; claim support for the feature but it does useful things, users can still use it; and provide us with useful feedback on what is missing. But if we claim support; for a feature that has significant bugs, we've eliminated most of the utility; of having a feature testing macro at all because u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:163259,expose,expose,163259,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['expose'],['expose']
Security,"ysis results may be invalid.; PreservedAnalyses PA;; PA.preserve<DominatorAnalysis>();; return PA;. // We haven't made any control flow changes, any analyses that only care about the control flow are still valid.; PreservedAnalyses PA;; PA.preserveSet<CFGAnalyses>();; return PA;. The pass manager will call the analysis manager's ``invalidate()`` method; with the pass's returned ``PreservedAnalyses``. This can be also done; manually within the pass:. .. code-block:: c++. FooModulePass::run(Module& M, ModuleAnalysisManager& AM) {; auto &FAM = AM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();. // Invalidate all analysis results for function F1.; FAM.invalidate(F1, PreservedAnalyses::none());. // Invalidate all analysis results across the entire module.; AM.invalidate(M, PreservedAnalyses::none());. // Clear the entry in the analysis manager for function F2 if we've completely removed it from the module.; FAM.clear(F2);. ...; }. One thing to note when accessing inner level IR analyses is cached results for; deleted IR. If a function is deleted in a module pass, its address is still used; as the key for cached analyses. Take care in the pass to either clear the; results for that function or not use inner analyses at all. ``AM.invalidate(M, PreservedAnalyses::none());`` will invalidate the inner; analysis manager proxy which will clear all cached analyses, conservatively; assuming that there are invalid addresses used as keys for cached analyses.; However, if you'd like to be more selective about which analyses are; cached/invalidated, you can mark the analysis manager proxy as preserved,; essentially saying that all deleted entries have been taken care of manually.; This should only be done with measurable compile time gains as it can be tricky; to make sure all the right analyses are invalidated. Implementing Analysis Invalidation; ==================================. By default, an analysis is invalidated if ``PreservedAnalyses`` says that; analyses on t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:14044,access,accessing,14044,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['access'],['accessing']
Security,"zability.NonLocalizedStringChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns about uses of non-localized NSStrings passed to UI methods expecting localized NSStrings. .. code-block:: objc. NSString *alarmText =; NSLocalizedString(@""Enabled"", @""Indicates alarm is turned on"");; if (!isEnabled) {; alarmText = @""Disabled"";; }; UILabel *alarmStateLabel = [[UILabel alloc] init];. // Warning: User-facing text should use localized string macro; [alarmStateLabel setText:alarmText];. .. _optin-performance-GCDAntipattern:. optin.performance.GCDAntipattern; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for performance anti-patterns when using Grand Central Dispatch. .. _optin-performance-Padding:. optin.performance.Padding; """"""""""""""""""""""""""""""""""""""""""""""""""; Check for excessively padded structs. .. _optin-portability-UnixAPI:. optin.portability.UnixAPI; """"""""""""""""""""""""""""""""""""""""""""""""""; Finds implementation-defined behavior in UNIX/Posix functions. .. _security-checkers:. security; ^^^^^^^^. Security related checkers. .. _security-cert-env-InvalidPtr:. security.cert.env.InvalidPtr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Corresponds to SEI CERT Rules `ENV31-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV31-C.+Do+not+rely+on+an+environment+pointer+following+an+operation+that+may+invalidate+it>`_ and `ENV34-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV34-C.+Do+not+store+pointers+returned+by+certain+functions>`_. * **ENV31-C**:; Rule is about the possible problem with ``main`` function's third argument, environment pointer,; ""envp"". When environment array is modified using some modification function; such as ``putenv``, ``setenv`` or others, It may happen that memory is reallocated,; however ""envp"" is not updated to reflect the changes and points to old memory; region. * **ENV34-C**:; Some functions return a pointer to a statically allocated buffer.; Consequently, subsequent call of these functions will invalidate previous; pointer. These functions include:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:19771,secur,security,19771,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security']
Security,"ze=undefined``; option. Make sure to use ``clang++`` (not ``ld``) as a linker, so that your; executable is linked with proper UBSan runtime libraries, unless all enabled; checks use trap mode. You can use ``clang`` instead of ``clang++`` if you're; compiling/linking C code. .. code-block:: console. % cat test.cc; int main(int argc, char **argv) {; int k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2023,sanitiz,sanitize,2023,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['sanitiz'],['sanitize']
Security,"zed representation of a part of Clang's internal; representation. Each of the blocks corresponds to either a block or a record; within `LLVM's bitstream format <https://llvm.org/docs/BitCodeFormat.html>`_.; The contents of each of these logical blocks are described below. .. image:: PCHLayout.png. The ``llvm-objdump`` utility provides a ``-raw-clang-ast`` option to extract the; binary contents of the AST section from an object file container. The `llvm-bcanalyzer <https://llvm.org/docs/CommandGuide/llvm-bcanalyzer.html>`_; utility can be used to examine the actual structure of the bitstream for the AST; section. This information can be used both to help understand the structure of; the AST section and to isolate areas where the AST representation can still be; optimized, e.g., through the introduction of abbreviations. Metadata Block; ^^^^^^^^^^^^^^. The metadata block contains several records that provide information about how; the AST file was built. This metadata is primarily used to validate the use of; an AST file. For example, a precompiled header built for a 32-bit x86 target; cannot be used when compiling for a 64-bit x86 target. The metadata block; contains information about:. Language options; Describes the particular language dialect used to compile the AST file,; including major options (e.g., Objective-C support) and more minor options; (e.g., support for ""``//``"" comments). The contents of this record correspond to; the ``LangOptions`` class. Target architecture; The target triple that describes the architecture, platform, and ABI for; which the AST file was generated, e.g., ``i386-apple-darwin9``. AST version; The major and minor version numbers of the AST file format. Changes in the; minor version number should not affect backward compatibility, while changes; in the major version number imply that a newer compiler cannot read an older; precompiled header (and vice-versa). Original file name; The full path of the header that was used to generate the A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:7607,validat,validate,7607,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['validat'],['validate']
Security,zinghtml; sphinx-automodapi==0.16.0 \; --hash=sha256:68fc47064804604b90aa27c047016e86aaf970981d90a0082d5b5dd2e9d38afd \; --hash=sha256:6c673ef93066408e5ad3e2fa3533044d432a47fe6a826212b9ebf5f52a872554; # via -r requirements.txt; sphinx-basic-ng==1.0.0b2 \; --hash=sha256:9ec55a47c90c8c002b5960c57492ec3021f5193cb26cebc2dc4ea226848651c9 \; --hash=sha256:eb09aedbabfb650607e9b4b68c9d240b90b1e1be221d6ad71d61c52e29f7932b; # via furo; sphinx-bootstrap-theme==0.8.1 \; --hash=sha256:683e3b735448dadd0149f76edecf95ff4bd9157787e9e77e0d048ca6f1d680df \; --hash=sha256:6ef36206c211846ea6cbdb45bc85645578e7c62d0a883361181708f8b6ea743b; # via -r requirements.txt; sphinx-markdown-tables==0.0.17 \; --hash=sha256:2bd0c30779653e4dd120300cbd9ca412c480738cc2241f6dea477a883f299e04 \; --hash=sha256:6bc6d3d400eaccfeebd288446bc08dd83083367c58b85d40fe6c12d77ef592f1; # via -r requirements.txt; sphinxcontrib-applehelp==1.0.4 \; --hash=sha256:29d341f67fb0f6f586b23ad80e072c8e6ad0b48417db2bde114a4c9746feb228 \; --hash=sha256:828f867945bbe39817c210a1abfd1bc4895c8b73fcaade56d45357a348a07d7e; # via; # -r requirements.txt; # sphinx; sphinxcontrib-devhelp==1.0.5 \; --hash=sha256:63b41e0d38207ca40ebbeabcf4d8e51f76c03e78cd61abe118cf4435c73d4212 \; --hash=sha256:fe8009aed765188f08fcaadbb3ea0d90ce8ae2d76710b7e29ea7d047177dae2f; # via sphinx; sphinxcontrib-htmlhelp==2.0.4 \; --hash=sha256:6c26a118a05b76000738429b724a0568dbde5b72391a688577da08f11891092a \; --hash=sha256:8001661c077a73c29beaf4a79968d0726103c5605e27db92b9ebed8bab1359e9; # via sphinx; sphinxcontrib-jsmath==1.0.1 \; --hash=sha256:2ec2eaebfb78f3f2078e73666b1415417a116cc848b72e5172e596c871103178 \; --hash=sha256:a9925e4a4587247ed2191a22df5f6970656cb8ca2bd6284309578f2153e0c4b8; # via sphinx; sphinxcontrib-qthelp==1.0.6 \; --hash=sha256:62b9d1a186ab7f5ee3356d906f648cacb7a6bdb94d201ee7adf26db55092982d \; --hash=sha256:bf76886ee7470b934e363da7a954ea2825650013d367728588732c7350f49ea4; # via sphinx; sphinxcontrib-serializinghtml==1.1.9 \; --hash=sha256:0c64,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt:22319,hash,hash,22319,interpreter/llvm-project/llvm/docs/requirements-hashed.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt,2,['hash'],['hash']
Security,"{; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:64012,secur,security-cert-pos-,64012,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security-cert-pos-']
Security,"{Z3_FOUND}""). if( LLVM_TARGETS_TO_BUILD STREQUAL ""all"" ); set( LLVM_TARGETS_TO_BUILD ${LLVM_ALL_TARGETS} ); endif(). if(LLVM_EXPERIMENTAL_TARGETS_TO_BUILD STREQUAL ""all""); set(LLVM_EXPERIMENTAL_TARGETS_TO_BUILD ${LLVM_ALL_EXPERIMENTAL_TARGETS}); endif(). set(LLVM_TARGETS_TO_BUILD; ${LLVM_TARGETS_TO_BUILD}; ${LLVM_EXPERIMENTAL_TARGETS_TO_BUILD}); list(REMOVE_DUPLICATES LLVM_TARGETS_TO_BUILD). if (NOT CMAKE_SYSTEM_NAME MATCHES ""OS390""); option(LLVM_ENABLE_PIC ""Build Position-Independent Code"" ON); endif(); option(LLVM_ENABLE_MODULES ""Compile with C++ modules enabled."" OFF); if(${CMAKE_SYSTEM_NAME} MATCHES ""Darwin""); option(LLVM_ENABLE_MODULE_DEBUGGING ""Compile with -gmodules."" ON); else(); option(LLVM_ENABLE_MODULE_DEBUGGING ""Compile with -gmodules."" OFF); endif(); option(LLVM_ENABLE_LOCAL_SUBMODULE_VISIBILITY ""Compile with -fmodules-local-submodule-visibility."" ON); option(LLVM_ENABLE_LIBCXX ""Use libc++ if available."" OFF); option(LLVM_ENABLE_LLVM_LIBC ""Set to on to link all LLVM executables against LLVM libc, assuming it is accessible by the host compiler."" OFF); option(LLVM_STATIC_LINK_CXX_STDLIB ""Statically link the standard library."" OFF); option(LLVM_ENABLE_LLD ""Use lld as C and C++ linker."" OFF); option(LLVM_ENABLE_PEDANTIC ""Compile with pedantic enabled."" ON); option(LLVM_ENABLE_WERROR ""Fail and stop if a warning is triggered."" OFF). option(LLVM_ENABLE_DUMP ""Enable dump functions even when assertions are disabled"" OFF); option(LLVM_UNREACHABLE_OPTIMIZE ""Optimize llvm_unreachable() as undefined behavior (default), guaranteed trap when OFF"" ON). if( NOT uppercase_CMAKE_BUILD_TYPE STREQUAL ""DEBUG"" ); option(LLVM_ENABLE_ASSERTIONS ""Enable assertions"" OFF); else(); option(LLVM_ENABLE_ASSERTIONS ""Enable assertions"" ON); endif(). option(LLVM_ENABLE_EXPENSIVE_CHECKS ""Enable expensive checks"" OFF). # While adding scalable vector support to LLVM, we temporarily want to; # allow an implicit conversion of TypeSize to uint64_t, and to allow; # code to get the fixed number o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:24689,access,accessible,24689,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['access'],['accessible']
Security,"| 0x........ | HashData[1]; | 0x00001203 | String offset into .debug_str (""dump""); | 0x00000003 | A 32 bit array count - number of HashData with name ""dump""; | 0x........ | HashData[0]; | 0x........ | HashData[1]; | 0x........ | HashData[2]; | 0x00000000 | String offset into .debug_str (terminate data for hash); |------------|; 0x00003550: | 0x00001203 | String offset into .debug_str (""main""); | 0x00000009 | A 32 bit array count - number of HashData with name ""main""; | 0x........ | HashData[0]; | 0x........ | HashData[1]; | 0x........ | HashData[2]; | 0x........ | HashData[3]; | 0x........ | HashData[4]; | 0x........ | HashData[5]; | 0x........ | HashData[6]; | 0x........ | HashData[7]; | 0x........ | HashData[8]; | 0x00000000 | String offset into .debug_str (terminate data for hash); `------------'. So we still have all of the same data, we just organize it more efficiently for; debugger lookup. If we repeat the same ""``printf``"" lookup from above, we; would hash ""``printf``"" and find it matches ``BUCKETS[3]`` by taking the 32 bit; hash value and modulo it by ``n_buckets``. ``BUCKETS[3]`` contains ""6"" which; is the index into the ``HASHES`` table. We would then compare any consecutive; 32 bit hashes values in the ``HASHES`` array as long as the hashes would be in; ``BUCKETS[3]``. We do this by verifying that each subsequent hash value modulo; ``n_buckets`` is still 3. In the case of a failed lookup we would access the; memory for ``BUCKETS[3]``, and then compare a few consecutive 32 bit hashes; before we know that we have no match. We don't end up marching through; multiple words of memory and we really keep the number of processor data cache; lines being accessed as small as possible. The string hash that is used for these lookup tables is the Daniel J.; Bernstein hash which is also used in the ELF ``GNU_HASH`` sections. It is a; very good hash for all kinds of names in programs with very few hash; collisions. Empty buckets are designated by using an invalid hash ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:67204,hash,hash,67204,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,2,['hash'],['hash']
Security,"| | +-----------------------+ R; | | +--| BinaryIdOffset | |; | | | +-----------------------+ |; +---------------| TemporalProf- | |; | | | | | TracesOffset | |; | | | | +-----------------------+---+; | | | | | Profile Summary | |; | | | | +-----------------------+ P; | | +------>| Function data | A; | | | +-----------------------+ Y; | +---------->| MemProf profile data | L; | | +-----------------------+ O; | +->| Binary Ids | A; | +-----------------------+ D; +-------------->| Temporal profiles | |; +-----------------------+---+. Header; --------. ``Magic``; The purpose of the magic number is to be able to tell if the profile is an; indexed profile. ``Version``; Similar to raw profile version, the lower 32 bits specify the version of the; indexed profile and the most significant 32 bits are reserved to specify the; variant types of the profile. ``HashType``; The hashing scheme for on-disk hash table keys. Only MD5 hashing is used as of; writing. ``HashOffset``; An on-disk hash table stores the per-function profile records. This field records; the offset of this hash table's metadata (i.e., the number of buckets and; entries), which follows right after the payload of the entire hash table. ``MemProfOffset``; Records the byte offset of MemProf profiling data. ``BinaryIdOffset``; Records the byte offset of binary id sections. ``TemporalProfTracesOffset``; Records the byte offset of temporal profiles. Payload Sections; ------------------. (CS) Profile Summary; ^^^^^^^^^^^^^^^^^^^^^; This section is right after profile header. It stores the serialized profile; summary. For context-sensitive IR-based instrumentation PGO, this section stores; an additional profile summary corresponding to the context-sensitive profiles. Function data; ^^^^^^^^^^^^^^^^^^; This section stores functions and their profiling data as an on-disk hash table.; Profile data for functions with the same name are grouped together and share one; hash table entry (the functions may come from different s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst:14848,hash,hash,14848,interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst,1,['hash'],['hash']
Security,"} else {; fprintf(stderr, ""read failed: %s\n"", strerror(errno));; exit(1);; }; }. // Finalize the hash. Default output length is 32 bytes.; auto output = hasher.final();. // Print the hash as hexadecimal.; for (uint8_t byte : output) {; printf(""%02x"", byte);; }; printf(""\n"");; return 0;; }; ```. Using the C API:. ```c; #include ""llvm-c/blake3.h""; #include <errno.h>; #include <stdio.h>; #include <stdlib.h>; #include <string.h>; #include <unistd.h>. int main() {; // Initialize the hasher.; llvm_blake3_hasher hasher;; llvm_blake3_hasher_init(&hasher);. // Read input bytes from stdin.; unsigned char buf[65536];; while (1) {; ssize_t n = read(STDIN_FILENO, buf, sizeof(buf));; if (n > 0) {; llvm_blake3_hasher_update(&hasher, buf, n);; } else if (n == 0) {; break; // end of file; } else {; fprintf(stderr, ""read failed: %s\n"", strerror(errno));; exit(1);; }; }. // Finalize the hash. LLVM_BLAKE3_OUT_LEN is the default output length, 32 bytes.; uint8_t output[LLVM_BLAKE3_OUT_LEN];; llvm_blake3_hasher_finalize(&hasher, output, LLVM_BLAKE3_OUT_LEN);. // Print the hash as hexadecimal.; for (size_t i = 0; i < LLVM_BLAKE3_OUT_LEN; i++) {; printf(""%02x"", output[i]);; }; printf(""\n"");; return 0;; }; ```. # API. ## The Class/Struct. ```c++; class BLAKE3 {; // API; private:; llvm_blake3_hasher Hasher;; };; ```; ```c; typedef struct {; // private fields; } llvm_blake3_hasher;; ```. An incremental BLAKE3 hashing state, which can accept any number of; updates. This implementation doesn't allocate any heap memory, but; `sizeof(llvm_blake3_hasher)` itself is relatively large, currently 1912 bytes; on x86-64. This size can be reduced by restricting the maximum input; length, as described in Section 5.4 of [the BLAKE3; spec](https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf),; but this implementation doesn't currently support that strategy. ## Common API Functions. ```c++; BLAKE3::BLAKE3();. void BLAKE3::init();; ```; ```c; void llvm_blake3_hasher_init(; llvm_blake3_hasher *s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md:1647,hash,hasher,1647,interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,1,['hash'],['hasher']
Security,"}; x \\; y \\; z; \end{array}; \right|; $$. ``` {.cpp}; TRotation r;; TVector3 v(1,1,1);; v = r * v;; ```. You can also use the `Transform()` method or the `operator *=` of the; **`TVector3`** class:. ``` {.cpp}; TVector3 v;; TRotation r;; v.Transform(r);; ```. ## TLorentzVector. **`TLorentzVector`** is a general four-vector class, which can be used; either for the description of position and time (`x`, `y`, `z`, `t`) or; momentum and energy (`px`, `py`, `pz`, `E`). ### Declaration. **`TLorentzVector`** has been implemented as a set a **`TVector3`** and; a `Double_t` variable. By default, all components are initialized by; zero. ``` {.cpp}; TLorentzVector v1; // initialized by (0.,0.,0.,0.); TLorentzVector v2(1.,1.,1.,1.);; TLorentzVector v3(v1);; TLorentzVector v4(TVector3(1.,2.,3.),4.);; ```. For backward compatibility there are two constructors from a `Double_t`; and `Float_t` array. ### Access to Components. There are two sets of access functions to the components of a; **`TLorentzVector`**: `X()`, `Y()`, `Z()`, `T()` and `Px()`, `Py()`,; `Pz()` and `E()`. Both sets return the same values but the first set is; more relevant for use where **`TLorentzVector`** describes a combination; of position and time and the second set is more relevant where; **`TLorentzVector`** describes momentum and energy:. ``` {.cpp}; Double_t xx =v.X();; ...; Double_t tt = v.T();; Double_t px = v.Px();; ...; Double_t ee = v.E();; ```. The components of **`TLorentzVector`** can also accessed by index:. ``` {.cpp}; xx = v(0);orxx = v[0];; yy = v(1);yy = v[1];; zz = v(2);zz = v[2];; tt = v(3);tt = v[3];; ```. You can use the `Vect()` method to get the vector component of; **`TLorentzVector`**:. ``` {.cpp}; TVector3 p = v.Vect();; ```. For setting components there are two methods: `SetX(),.., SetPx(),..:`. ``` {.cpp}; v.SetX(1.); orv.SetPx(1.);; ......; v.SetT(1.);v.SetE(1.);; ```. To set more the one component by one call you can use the `SetVect()`; function for the **`TVector3`** part or ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:10049,access,access,10049,documentation/users-guide/PhysicsVectors.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md,1,['access'],['access']
Testability,"	ldr r2, [r2]; 	ldr r1, [r2, +r1, lsl #2]; 	tst r0, #128; 	movne r1, r1, lsr #2; 	ldr r0, LCPI1_1; 	and r0, r1, r0; 	bx lr. it saves an instruction and a register. //===---------------------------------------------------------------------===//. It might be profitable to cse MOVi16 if there are lots of 32-bit immediates; with the same bottom half. //===---------------------------------------------------------------------===//. Robert Muth started working on an alternate jump table implementation that; does not put the tables in-line in the text. This is more like the llvm; default jump table implementation. This might be useful sometime. Several; revisions of patches are on the mailing list, beginning at:; http://lists.llvm.org/pipermail/llvm-dev/2009-June/022763.html. //===---------------------------------------------------------------------===//. Make use of the ""rbit"" instruction. //===---------------------------------------------------------------------===//. Take a look at test/CodeGen/Thumb2/machine-licm.ll. ARM should be taught how; to licm and cse the unnecessary load from cp#1. //===---------------------------------------------------------------------===//. The CMN instruction sets the flags like an ADD instruction, while CMP sets; them like a subtract. Therefore to be able to use CMN for comparisons other; than the Z bit, we'll need additional logic to reverse the conditionals; associated with the comparison. Perhaps a pseudo-instruction for the comparison,; with a post-codegen pass to clean up and handle the condition codes?; See PR5694 for testcase. //===---------------------------------------------------------------------===//. Given the following on armv5:; int test1(int A, int B) {; return (A&-8388481)|(B&8388480);; }. We currently generate:; 	ldr	r2, .LCPI0_0; 	and	r0, r0, r2; 	ldr	r2, .LCPI0_1; 	and	r1, r1, r2; 	orr	r0, r1, r0; 	bx	lr. We should be able to replace the second ldr+and with a bic (i.e. reuse the; constant which was already loaded). Not s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt:17203,test,test,17203,interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,1,['test'],['test']
Testability," #. Download ``llvm-X.Y``, ``llvm-test-X.Y``, and the appropriate ``clang``; binary. Build LLVM. Run ``make check`` and the full LLVM test suite (``make; TEST=nightly report``). #. Download ``llvm-X.Y``, ``llvm-test-X.Y``, and the ``clang`` sources. Compile; everything. Run ``make check`` and the full LLVM test suite (``make; TEST=nightly report``). #. Download ``llvm-X.Y``, ``llvm-test-X.Y``, and the appropriate ``clang``; binary. Build whole programs with it (ex. Chromium, Firefox, Apache) for; your platform. #. Download ``llvm-X.Y``, ``llvm-test-X.Y``, and the appropriate ``clang``; binary. Build *your* programs with it and check for conformance and; performance regressions. #. Run the :doc:`release process <ReleaseProcess>`, if your platform is; *different* than that which is officially supported, and report back errors; only if they were not reported by the official release tester for that; architecture. We also ask that the OS distribution release managers test their packages with; the first candidate of every release, and report any *new* errors in GitHub.; If the bug can be reproduced with an unpatched upstream version of the release; candidate (as opposed to the distribution's own build), the priority should be; release blocker. During the first round of testing, all regressions must be fixed before the; second release candidate is tagged. In the subsequent stages, the testing is only to ensure that bug; fixes previously merged in have not created new major problems. *This is not; the time to solve additional and unrelated bugs!* If no patches are merged in,; the release is determined to be ready and the release manager may move onto the; next stage. Reporting Regressions; ---------------------. Every regression that is found during the tests (as per the criteria above),; should be filled in a bug in GitHub and added to the release milestone. If a bug can't be reproduced, or stops being a blocker, it should be removed; from the Milestone. Debugging can conti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:9177,test,test,9177,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['test'],['test']
Testability," #include in; ``llvm/lib/Passes/PassBuilder.cpp``:. .. code-block:: c++. #include ""llvm/Transforms/Utils/HelloWorld.h"". This should be all the code necessary for our pass, now it's time to compile; and run it. Running a pass with ``opt``; ---------------------------. Now that you have a brand new shiny pass, we can build :program:`opt` and use; it to run some LLVM IR through the pass. .. code-block:: console. $ ninja -C build/ opt; # or whatever build system/build directory you are using. $ cat /tmp/a.ll; define i32 @foo() {; %a = add i32 2, 3; ret i32 %a; }. define void @bar() {; ret void; }. $ build/bin/opt -disable-output /tmp/a.ll -passes=helloworld; foo; bar. Our pass ran and printed the names of functions as expected!. Testing a pass; --------------. Testing our pass is important to prevent future regressions. We'll add a lit; test at ``llvm/test/Transforms/Utils/helloworld.ll``. See; :doc:`TestingGuide` for more information on testing. .. code-block:: llvm. $ cat llvm/test/Transforms/Utils/helloworld.ll; ; RUN: opt -disable-output -passes=helloworld %s 2>&1 | FileCheck %s. ; CHECK: {{^}}foo{{$}}; define i32 @foo() {; %a = add i32 2, 3; ret i32 %a; }. ; CHECK-NEXT: {{^}}bar{{$}}; define void @bar() {; ret void; }. $ ninja -C build check-llvm; # runs our new test alongside all other llvm lit tests. FAQs; ====. Required passes; ---------------. A pass that defines a static ``isRequired()`` method that returns true is a required pass. For example:. .. code-block:: c++. class HelloWorldPass : public PassInfoMixin<HelloWorldPass> {; public:; PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);. static bool isRequired() { return true; }; };. A required pass is a pass that may not be skipped. An example of a required; pass is ``AlwaysInlinerPass``, which must always be run to preserve; ``alwaysinline`` semantics. Pass managers are required since they may contain; other required passes. An example of how a pass can be skipped is the ``optnone`` function; at",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst:6072,test,test,6072,interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,1,['test'],['test']
Testability," $ opt -debugify -pass-to-test -check-debugify sample.ll. This will inject synthetic DI to ``sample.ll`` run the ``pass-to-test`` and; then check for missing DI. The ``-check-debugify`` step can of course be; omitted in favor of more customizable FileCheck directives. Some other ways to run debugify are available:. .. code-block:: bash. # Same as the above example.; $ opt -enable-debugify -pass-to-test sample.ll. # Suppresses verbose debugify output.; $ opt -enable-debugify -debugify-quiet -pass-to-test sample.ll. # Prepend -debugify before and append -check-debugify -strip after; # each pass on the pipeline (similar to -verify-each).; $ opt -debugify-each -O2 sample.ll. In order for ``check-debugify`` to work, the DI must be coming from; ``debugify``. Thus, modules with existing DI will be skipped. ``debugify`` can be used to test a backend, e.g:. .. code-block:: bash. $ opt -debugify < sample.ll | llc -o -. There is also a MIR-level debugify pass that can be run before each backend; pass, see:; :ref:`Mutation testing for MIR-level transformations<MIRDebugify>`. ``debugify`` in regression tests; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The output of the ``debugify`` pass must be stable enough to use in regression; tests. Changes to this pass are not allowed to break existing tests. .. note::. Regression tests must be robust. Avoid hardcoding line/variable numbers in; check lines. In cases where this can't be avoided (say, if a test wouldn't; be precise enough), moving the test to its own file is preferred. .. _MIRDebugify:. Test original debug info preservation in optimizations; ------------------------------------------------------. In addition to automatically generating debug info, the checks provided by; the ``debugify`` utility pass can also be used to test the preservation of; pre-existing debug info metadata. It could be run as follows:. .. code-block:: bash. # Run the pass by checking original Debug Info preservation.; $ opt -verify-debuginfo-preserve -pass-to-test",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:13100,test,testing,13100,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['test'],['testing']
Testability," $0x10, %rdi. Example 3: benchmarking with memory annotations; -----------------------------------------------. Some snippets require memory setup in specific places to execute without; crashing. Setting up memory can be accomplished with the `LLVM-EXEGESIS-MEM-DEF`; and `LLVM-EXEGESIS-MEM-MAP` annotations. To execute the following snippet:. .. code-block:: none. movq $8192, %rax; movq (%rax), %rdi. We need to have at least eight bytes of memory allocated starting `0x2000`.; We can create the necessary execution environment with the following; annotations added to the snippet:. .. code-block:: none. # LLVM-EXEGESIS-MEM-DEF test1 4096 7fffffff; # LLVM-EXEGESIS-MEM-MAP test1 8192. movq $8192, %rax; movq (%rax), %rdi. EXAMPLE 4: analysis; -------------------. Assuming you have a set of benchmarked instructions (either latency or uops) as; YAML in file `/tmp/benchmarks.yaml`, you can analyze the results using the; following command:. .. code-block:: bash. $ llvm-exegesis --mode=analysis \; --benchmarks-file=/tmp/benchmarks.yaml \; --analysis-clusters-output-file=/tmp/clusters.csv \; --analysis-inconsistencies-output-file=/tmp/inconsistencies.html. This will group the instructions into clusters with the same performance; characteristics. The clusters will be written out to `/tmp/clusters.csv` in the; following format:. .. code-block:: none. cluster_id,opcode_name,config,sched_class; ...; 2,ADD32ri8_DB,,WriteALU,1.00; 2,ADD32ri_DB,,WriteALU,1.01; 2,ADD32rr,,WriteALU,1.01; 2,ADD32rr_DB,,WriteALU,1.00; 2,ADD32rr_REV,,WriteALU,1.00; 2,ADD64i32,,WriteALU,1.01; 2,ADD64ri32,,WriteALU,1.01; 2,MOVSX64rr32,,BSWAP32r_BSWAP64r_MOVSX64rr32,1.00; 2,VPADDQYrr,,VPADDBYrr_VPADDDYrr_VPADDQYrr_VPADDWYrr_VPSUBBYrr_VPSUBDYrr_VPSUBQYrr_VPSUBWYrr,1.02; 2,VPSUBQYrr,,VPADDBYrr_VPADDDYrr_VPADDQYrr_VPADDWYrr_VPSUBBYrr_VPSUBDYrr_VPSUBQYrr_VPSUBWYrr,1.01; 2,ADD64ri8,,WriteALU,1.00; 2,SETBr,,WriteSETCC,1.01; ... :program:`llvm-exegesis` will also analyze the clusters to point out; inconsistencies in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:7756,benchmark,benchmarks-file,7756,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,2,['benchmark'],"['benchmarks', 'benchmarks-file']"
Testability," $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ROOT_GENERATE_DICTIONARY(ElementStructDict ElementStruct.h LINKDEF ElementStructLinkDef.h OPTIONS -inlineInputHeader); ROOT_ADD_GTEST(testTOffsetGeneration TOffsetGeneration.cxx ElementStruct.cxx ElementStructDict.cxx; LIBRARIES RIO Tree MathCore; ); if(MSVC AND NOT CMAKE_GENERATOR MATCHES Ninja); add_custom_command(TARGET testTOffsetGeneration POST_BUILD; COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_BINARY_DIR}/libElementStructDict_rdict.pcm; ${CMAKE_CURRENT_BINARY_DIR}/$<CONFIG>/libElementStructDict_rdict.pcm); endif(); target_include_directories(testTOffsetGeneration PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}); ROOT_STANDARD_LIBRARY_PACKAGE(SillyStruct NO_INSTALL_HEADERS HEADERS ${CMAKE_CURRENT_SOURCE_DIR}/SillyStruct.h SOURCES SillyStruct.cxx LINKDEF SillyStructLinkDef.h DEPENDENCIES RIO); ROOT_ADD_GTEST(testBulkApi BulkApi.cxx LIBRARIES RIO Tree TreePlayer); #FIXME: tests are having timeout on 32bit CERN VM (in docker container everything is fine),; # to be reverted after investigation.; if(NOT CMAKE_SIZEOF_VOID_P EQUAL 4); ROOT_ADD_GTEST(testBulkApiMultiple BulkApiMultiple.cxx LIBRARIES RIO Tree TreePlayer TIMEOUT 3000); ROOT_ADD_GTEST(testBulkApiVarLength BulkApiVarLength.cxx LIBRARIES RIO Tree TreePlayer); ROOT_ADD_GTEST(testBulkApiSillyStruct BulkApiSillyStruct.cxx LIBRARIES RIO Tree TreePlayer SillyStruct); endif(); ROOT_ADD_GTEST(testTBasket TBasket.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(testTBranch TBranch.cxx LIBRARIES RIO Tree MathCore); ROOT_ADD_GTEST(testTIOFeatures TIOFeatures.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(testTTreeCluster TTreeClusterTest.cxx LIBRARIES RIO Tree MathCore); ROOT_ADD_GTEST(testTChainParsing TChainParsing.cxx LIBRARIES RIO Tree); if(imt); ROOT_ADD_GTEST(testTTreeImplicitMT ImplicitMT.cxx LIBRARIES RIO Tree); endif(); ROOT_ADD_GTEST(testTChainSaveAsCxx TChainSaveAsCxx.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(testTChainRegressions TChainRegressions.cxx",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/CMakeLists.txt:1076,test,tests,1076,tree/tree/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/CMakeLists.txt,1,['test'],['tests']
Testability," ${CMAKE_CURRENT_SOURCE_DIR}/stressLinear.cxx; FAILREGEX ""FAILED|Error in"" DEPENDS test-stresslinear LABELS longtest). #--stressGraphics------------------------------------------------------------------------------------; if(ROOT_opengl_FOUND); ROOT_EXECUTABLE(stressGraphics stressGraphics.cxx LIBRARIES Graf Gpad Postscript); if(MSVC); set_property(TARGET stressGraphics APPEND_STRING PROPERTY LINK_FLAGS ""/STACK:4000000""); endif(); # with ZLIB-CF(builtin_zlib) we have better compression ratio.; if(ZLIB_CF); configure_file(stressGraphics_builtinzlib.ref stressGraphics_builtinzlib.ref COPYONLY); else(); configure_file(stressGraphics.ref stressGraphics.ref COPYONLY); endif(); configure_file(stressGraphics_web.ref stressGraphics_web.ref COPYONLY); configure_file(${CMAKE_CURRENT_SOURCE_DIR}/../tutorials/graphics/earth.dat earth.dat COPYONLY); ROOT_ADD_TEST(test-stressgraphics; ENVIRONMENT LD_LIBRARY_PATH=${CMAKE_BINARY_DIR}/lib:$ENV{LD_LIBRARY_PATH}; COMMAND stressGraphics -b -k -p=sge; FAILREGEX ""FAILED|Error in""; LABELS longtest); ROOT_ADD_TEST(test-stressgraphics-interpreted; COMMAND ${ROOT_root_CMD} -b -q -l ${CMAKE_CURRENT_SOURCE_DIR}/stressGraphics.cxx; FAILREGEX ""FAILED|Error in""; DEPENDS test-stressgraphics); if(CHROME_EXECUTABLE); ROOT_ADD_TEST(test-stressgraphics-chrome; RUN_SERIAL; ENVIRONMENT LD_LIBRARY_PATH=${CMAKE_BINARY_DIR}/lib:$ENV{LD_LIBRARY_PATH}; COMMAND stressGraphics -b -k -p=sgc --web=chrome; FAILREGEX ""FAILED|Error in""; LABELS longtest); endif(); if(FIREFOX_EXECUTABLE AND NOT APPLE); ROOT_ADD_TEST(test-stressgraphics-firefox-skip3d; RUN_SERIAL; ENVIRONMENT LD_LIBRARY_PATH=${CMAKE_BINARY_DIR}/lib:$ENV{LD_LIBRARY_PATH}; COMMAND stressGraphics -b -k -p=sgf --web=firefox -skip3d; FAILREGEX ""FAILED|Error in""; LABELS longtest); endif(); endif(). #--stressHistogram------------------------------------------------------------------------------------; ROOT_EXECUTABLE(stressHistogram stressHistogram.cxx LIBRARIES Hist RIO); ROOT_ADD_TEST(test-stresshistogram C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/CMakeLists.txt:8470,test,test-stressgraphics,8470,test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/CMakeLists.txt,2,['test'],"['test-stressgraphics', 'test-stressgraphics-interpreted']"
Testability," % make check-llvm. In order to get reasonable testing performance, build LLVM and subprojects; in release mode, i.e. .. code-block:: bash. % cmake -DCMAKE_BUILD_TYPE=""Release"" -DLLVM_ENABLE_ASSERTIONS=On. If you have `Clang <https://clang.llvm.org/>`_ checked out and built, you; can run the LLVM and Clang tests simultaneously using:. .. code-block:: bash. % make check-all. To run the tests with Valgrind (Memcheck by default), use the ``LIT_ARGS`` make; variable to pass the required options to lit. For example, you can use:. .. code-block:: bash. % make check LIT_ARGS=""-v --vg --vg-leak"". to enable testing with valgrind and with leak checking enabled. To run individual tests or subsets of tests, you can use the ``llvm-lit``; script which is built as part of LLVM. For example, to run the; ``Integer/BitPacked.ll`` test by itself you can run:. .. code-block:: bash. % llvm-lit ~/llvm/test/Integer/BitPacked.ll. or to run all of the ARM CodeGen tests:. .. code-block:: bash. % llvm-lit ~/llvm/test/CodeGen/ARM. The regression tests will use the Python psutil module only if installed in a; **non-user** location. Under Linux, install with sudo or within a virtual; environment. Under Windows, install Python for all users and then run; ``pip install psutil`` in an elevated command prompt. For more information on using the :program:`lit` tool, see ``llvm-lit --help``; or the :doc:`lit man page <CommandGuide/lit>`. Debugging Information tests; ---------------------------. To run debugging information tests simply add the ``cross-project-tests``; project to your ``LLVM_ENABLE_PROJECTS`` define on the cmake; command-line. Regression test structure; =========================. The LLVM regression tests are driven by :program:`lit` and are located in the; ``llvm/test`` directory. This directory contains a large array of small tests that exercise; various features of LLVM and to ensure that regressions do not occur.; The directory is broken into several sub-directories, each focused on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:6271,test,test,6271,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['test']
Testability," %rbp'; [003] {Code} 'subq	$0x10, %rsp'; [003] {Code} 'movl	$0x0, -0x4(%rbp)'; [003] 5 {Line}; [003] {Code} 'movabsq	$0x0, %rdi'; [003] {Code} 'movb	$0x0, %al'; [003] {Code} 'callq	0x0'; [003] 6 {Line}; [003] {Code} 'xorl	%eax, %eax'; [003] {Code} 'addq	$0x10, %rsp'; [003] {Code} 'popq	%rbp'; [003] {Code} 'retq'; [003] 6 {Line}. DWARF - GCC (Linux); ^^^^^^^^^^^^^^^^^^^. .. code-block:: none. Logical View:; [000] {File} 'hello-world-dwarf-gcc.o' -> elf64-x86-64. [001] {CompileUnit} 'hello-world.cpp'; [002] {Producer} 'GNU C++14 9.3.0'; [002] 3 {Function} extern not_inlined 'main' -> 'int'; [003] 4 {Line}; [003] {Code} 'endbr64'; [003] {Code} 'pushq	%rbp'; [003] {Code} 'movq	%rsp, %rbp'; [003] 5 {Line}; [003] {Code} 'leaq	(%rip), %rdi'; [003] {Code} 'movl	$0x0, %eax'; [003] {Code} 'callq	0x0'; [003] 6 {Line}; [003] {Code} 'movl	$0x0, %eax'; [003] 7 {Line}; [003] {Code} 'popq	%rbp'; [003] {Code} 'retq'; [003] 7 {Line}. The logical views shows the intermixed lines and assembler instructions,; allowing to compare the code generated by the different toolchains. TEST CASE 3 - INCORRECT LEXICAL SCOPE FOR TYPEDEF; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The below example is used to show different output generated by; :program:`llvm-debuginfo-analyzer`. We compiled the example for an X86; Codeview and ELF targets with recent versions of Clang, GCC and MSVC; (-O0 -g). .. code-block:: c++. 1 int bar(float Input) { return (int)Input; }; 2; 3 unsigned foo(char Param) {; 4 typedef int INT; // ** Definition for INT **; 5 INT Value = Param;; 6 {; 7 typedef float FLOAT; // ** Definition for FLOAT **; 8 {; 9 FLOAT Added = Value + Param;; 10 Value = bar(Added);; 11 }; 12 }; 13 return Value + Param;; 14 }. The above test is used to illustrate a scope issue found in the Clang; compiler:; `PR44884 (Bugs LLVM) <https://bugs.llvm.org/show_bug.cgi?id=44884>`_ /; `PR44229 (GitHub LLVM) <https://github.com/llvm/llvm-project/issues/44229>`_. The lines 4 and 7 contains 2 typedefs, def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:35892,log,logical,35892,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['log'],['logical']
Testability," 'k': case 'K': Val *= 1024; break;. default:; // Print an error message if unrecognized character!; return O.error(""'"" + Arg + ""' value invalid for file size argument!"");; }; }; }. This function implements a very simple parser for the kinds of strings we are; interested in. Although it has some holes (it allows ""``123KKK``"" for example),; it is good enough for this example. Note that we use the option itself to print; out the error message (the ``error`` method always returns true) in order to get; a nice error message (shown below). Now that we have our parser class, we can; use it like this:. .. code-block:: c++. static cl::opt<unsigned, false, FileSizeParser>; MFS(""max-file-size"", cl::desc(""Maximum file size to accept""),; cl::value_desc(""size""));. Which adds this to the output of our program:. ::. OPTIONS:; -help - display available options (-help-hidden for more); ...; -max-file-size=<size> - Maximum file size to accept. And we can test that our parse works correctly now (the test program just prints; out the max-file-size argument value):. ::. $ ./test; MFS: 0; $ ./test -max-file-size=123MB; MFS: 128974848; $ ./test -max-file-size=3G; MFS: 3221225472; $ ./test -max-file-size=dog; -max-file-size option: 'dog' value invalid for file size argument!. It looks like it works. The error message that we get is nice and helpful, and; we seem to accept reasonable file sizes. This wraps up the ""custom parser""; tutorial. Exploiting external storage; ---------------------------. Several of the LLVM libraries define static ``cl::opt`` instances that will; automatically be included in any program that links with that library. This is; a feature. However, sometimes it is necessary to know the value of the command; line option outside of the library. In these cases the library does or should; provide an external storage location that is accessible to users of the; library. Examples of this include the ``llvm::DebugFlag`` exported by the; ``lib/Support/Debug.cpp`` file and the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:65946,test,test,65946,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,2,['test'],['test']
Testability," 'movl	%eax, -0x4(%rbp)'; [003] 9 {Line}; [003] {Code} 'movl	-0x4(%rbp), %eax'; [003] {Code} 'popq	%rbp'; [003] {Code} 'retq'; [003] 9 {Line}; [002] 1 {TypeAlias} 'INTPTR' -> '* const int'. On closer inspection, we can see what could be a potential debug issue:. .. code-block:: none. [003] {Block}; [003] 4 {TypeAlias} 'INTEGER' -> 'int'. The **'INTEGER'** definition is at level **[003]**, the same lexical; scope as the anonymous **{Block}** ('true' branch for the 'if' statement); whereas in the original source code the typedef statement is clearly; inside that block, so the **'INTEGER'** definition should also be at; level **[004]** inside the block. SELECT LOGICAL ELEMENTS; """"""""""""""""""""""""""""""""""""""""""""""; The following prints all *instructions*, *symbols* and *types* that; contain **'inte'** or **'movl'** in their names or types, using a tab; layout and given the number of matches. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level; --select-nocase --select-regex; --select=INTe --select=movl; --report=list; --print=symbols,types,instructions,summary; test-dwarf-clang.o. Logical View:; [000] {File} 'test-dwarf-clang.o'. [001] {CompileUnit} 'test.cpp'; [003] {Code} 'movl	$0x7, -0x1c(%rbp)'; [003] {Code} 'movl	$0x7, -0x4(%rbp)'; [003] {Code} 'movl	%eax, -0x4(%rbp)'; [003] {Code} 'movl	%esi, -0x14(%rbp)'; [003] {Code} 'movl	-0x14(%rbp), %eax'; [003] {Code} 'movl	-0x4(%rbp), %eax'; [003] 4 {TypeAlias} 'INTEGER' -> 'int'; [004] 5 {Variable} 'CONSTANT' -> 'const INTEGER'. -----------------------------; Element Total Found; -----------------------------; Scopes 3 0; Symbols 4 1; Types 2 1; Lines 17 6; -----------------------------; Total 26 8. COMPARISON MODE; ^^^^^^^^^^^^^^^; In this mode :program:`llvm-debuginfo-analyzer` compares logical views; to produce a report with the logical elements that are missing or added.; This a very powerful aid in finding semantic differences in the debug; information produced by different toolchain versions or even completely; differ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:27333,test,test-dwarf-clang,27333,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['test'],['test-dwarf-clang']
Testability," (Bugs LLVM) <https://bugs.llvm.org/show_bug.cgi?id=43860>`_ /; `PR43205 (GitHub) <https://github.com/llvm/llvm-project/issues/43205>`_. These are the logical views that :program:`llvm-debuginfo-analyzer`; generates for 3 different compilers (MSVC, Clang and GCC), emitting; different debug information formats (CodeView, DWARF) on different; platforms. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format,producer; --output-sort=name; --print=symbols; pr-43860-codeview-clang.o; pr-43860-codeview-msvc.o; pr-43860-dwarf-clang.o; pr-43860-dwarf-gcc.o. CODEVIEW - Clang (Windows); ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: none. Logical View:; [000] {File} 'pr-43860-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [002] {Producer} 'clang version 14.0.0'; [002] 2 {Function} inlined 'InlineFunction' -> 'int'; [003] {Parameter} '' -> 'int'; [002] {Function} extern not_inlined 'test' -> 'int'; [003] {Variable} 'A' -> 'int'; [003] {InlinedFunction} inlined 'InlineFunction' -> 'int'; [004] {Parameter} 'Param' -> 'int'; [004] {Variable} 'Var_1' -> 'int'; [004] {Variable} 'Var_2' -> 'int'; [003] {Parameter} 'Param_1' -> 'int'; [003] {Parameter} 'Param_2' -> 'int'. CODEVIEW - MSVC (Windows); ^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: none. Logical View:; [000] {File} 'pr-43860-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr-43860.cpp'; [002] {Producer} 'Microsoft (R) Optimizing Compiler'; [002] {Function} extern not_inlined 'InlineFunction' -> 'int'; [003] {Block}; [004] {Variable} 'Var_2' -> 'int'; [003] {Variable} 'Param' -> 'int'; [003] {Variable} 'Var_1' -> 'int'; [002] {Function} extern not_inlined 'test' -> 'int'; [003] {Variable} 'A' -> 'int'; [003] {Variable} 'Param_1' -> 'int'; [003] {Variable} 'Param_2' -> 'int'. DWARF - Clang (Linux); ^^^^^^^^^^^^^^^^^^^^^. .. code-block:: none. Logical View:; [000] {File} 'pr-43860-dwarf-clang.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [002] {Producer} 'clang version 14.0.0'; [0",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:50563,test,test,50563,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['test'],['test']
Testability," (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an; object are unrelated. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. alpha.core.FixedAddr; (C); Check for assignment of a fixed address to a pointer. void test() {; int *p;; p = (int *) 0x10000; // warn; }. alpha.core.IdenticalExpr; (C, C++); Warn about suspicious uses of identical expressions. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. alpha.core.PointerArithm; (C); Check for pointer arithmetic on locations other than array; elements. void test() {; int x;; int *p;; p = &x + 1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:2052,test,test,2052,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['test'],['test']
Testability," (Clang-specific); The 'cf_consumed' attribute is practically identical to ns_consumed. The attribute can be placed on a; specific parameter in either the declaration of a function or an Objective-C; method. It indicates to the static analyzer that the object reference is; implicitly passed to a call to CFRelease upon completion of the call; to the given function or method. The CoreFoundation framework defines a macro; CF_RELEASES_ARGUMENT that is functionally equivalent to the; CF_CONSUMED macro shown below.; Operationally this attribute is nearly identical to 'ns_consumed'.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_CONSUMED; #if __has_feature(attribute_cf_consumed); #define CF_CONSUMED __attribute__((cf_consumed)); #else; #define CF_CONSUMED; #endif; #endif. void consume_cf(id CF_CONSUMED x);; void consume_CFDate(CFDateRef CF_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_cf(x); // No leak!; }. void test2() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; consume_CFDate(date); // No leak, including under GC!. }. @interface Foo : NSObject; + (void) releaseArg:(CFDateRef) CF_CONSUMED x;; @end. void test_method() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; [Foo releaseArg:date]; // No leak!; }. Attribute 'ns_consumes_self'; (Clang-specific); The 'ns_consumes_self' attribute can be placed only on an Objective-C method; declaration. It indicates that the receiver of the message is; ""consumed"" (a single reference count decremented) after the message; is sent. This matches the semantics of all ""init"" methods.; One use of this attribute is declare your own init-like methods that do not; follow the standard Cocoa naming conventions.; Example. #ifndef __has_feature; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_CONSUMES_SELF; #if __has_feature((attribute_ns_consume",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:11953,test,test,11953,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['test'],['test']
Testability," (T::*imp)()) : object(obj), mp(imp) { }; ~AutoCleanup() { (object->*mp)(); }; };. Mutex mu;; void foo() {; mu.Lock();; AutoCleanup<Mutex>(&mu, &Mutex::Unlock);; // ...; } // Warning, mu is not unlocked. In this case, the destructor of ``Autocleanup`` calls ``mu.Unlock()``, so; the warning is bogus. However,; thread safety analysis cannot see the unlock, because it does not attempt to; inline the destructor. Moreover, there is no way to annotate the destructor,; because the destructor is calling a function that is not statically known.; This pattern is simply not supported. No alias analysis.; ------------------. The analysis currently does not track pointer aliases. Thus, there can be; false positives if two pointers both point to the same mutex. .. code-block:: c++. class MutexUnlocker {; Mutex* mu;. public:; MutexUnlocker(Mutex* m) RELEASE(m) : mu(m) { mu->Unlock(); }; ~MutexUnlocker() ACQUIRE(mu) { mu->Lock(); }; };. Mutex mutex;; void test() REQUIRES(mutex) {; {; MutexUnlocker munl(&mutex); // unlocks mutex; doSomeIO();; } // Warning: locks munl.mu; }. The MutexUnlocker class is intended to be the dual of the MutexLocker class,; defined in :ref:`mutexheader`. However, it doesn't work because the analysis; doesn't know that munl.mu == mutex. The SCOPED_CAPABILITY attribute handles; aliasing for MutexLocker, but does so only for that particular pattern. ACQUIRED_BEFORE(...) and ACQUIRED_AFTER(...) are currently unimplemented.; -------------------------------------------------------------------------. To be fixed in a future update. .. _mutexheader:. mutex.h; =======. Thread safety analysis can be used with any threading library, but it does; require that the threading API be wrapped in classes and methods which have the; appropriate annotations. The following code provides ``mutex.h`` as an example;; these methods should be filled in to call the appropriate underlying; implementation. .. code-block:: c++. #ifndef THREAD_SAFETY_ANALYSIS_MUTEX_H; #define THREAD_SAFE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:24094,test,test,24094,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['test'],['test']
Testability," (and accordingly the application; data) into disjoint sub-populations exhibiting significantly; different properties. The separation into phase space regions is; done by applying requirements on the input and/or spectator; variables. In each of these disjoint regions (each event must; belong to one and only one region), an independent training is; performed using the most appropriate MVA method, training; options and set of training variables in that zone. The division; into categories in presence of distinct sub-populations reduces; the correlations between the training variables, improves the; modelling, and hence increases the classification and regression; performance. Presently, the Category method works for; classification only, but regression will follow soon. Please; contact us if urgently needed. An example scripts and data files illustrating how the new; Category method is configured and used. Please check the macros; test/TMVAClassificationCategory.C and; test/TMVAClassificationCategoryApplication.C or the; corresponding executables.; Regression functionality for gradient boosted trees using a Huber loss function. Comments. On Input Data: . New TMVA event vector building. The code for splitting the input; data into training and test samples for all classes and the; mixing of those samples to one training and one test sample has; been rewritten completely. The new code is more performant and; has a clearer structure. This fixes several bugs which have been; reported by the TMVA users. On Minimization: . Variables, targets and spectators are now checked if they are; constant. (The execution of TMVA is stopped for variables and; targets, a warning is given for spectators.). On Regression:; ; The analysis type is no longer defined by calling a dedicated; TestAllMethods-member-function of the Factory, but with the; option ""AnalysisType"" in the Factory. The default value is; ""Auto"" where TMVA tries to determine the most suitable analysis; type from the targets",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html:1122,test,test,1122,tmva/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html,1,['test'],['test']
Testability," (e.g.; replacing globals, removing unused instructions, etc), similar to what; already exists, but with more in-depth minimization. Granted, if the community differs on this proposal, the legacy code could still; be present in the tool, but with the caveat of still being documented and; designed towards delta reduction. ### Command-Line Options; We are proposing to reduce the plethora of bugpoint’s options to just two: an; interesting-ness test and the arguments for said test, similar to other delta; reduction tools such as CReduce, Delta, and Lithium; the tool should feel less; cluttered, and there should also be no uncertainty about how to operate it. The interesting-ness test that’s going to be run to reduce the code is given; by name:; `--test=<test_name>`; If a `--test` option is not given, the program exits; this option is similar; to bugpoint’s current `-compile-custom` option, which lets the user run a; custom script. The interesting-ness test would be defined as a script that returns 0 when the; IR achieves a user-defined behaviour (e.g. failure to compile on clang) and a; nonzero value when otherwise. Leaving the user the freedom to determine what is; and isn’t interesting to the tool, and thus, streamlining the process of; reducing a test-case. If the test accepts any arguments (excluding the input ll/bc file), they are; given via the following flag:; `--test_args=<test_arguments>`; If unspecified, the test is run as given. It’s worth noting that the input file; would be passed as a parameter to the test, similar how `-compile-custom`; currently operates. ### Implementation; The tool would behave similar to CReduce’s functionality in that it would have a; list of passes that try to minimize the given test-case. We should be able to; modularize the tool’s behavior, as well as making it easier to maintain and; expand. The first version of this redesign would try to:. * Discard functions, instructions and metadata that don’t influence the; interesting-ness t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugpointRedesign.md:1643,test,test,1643,interpreter/llvm-project/llvm/docs/BugpointRedesign.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugpointRedesign.md,1,['test'],['test']
Testability," (in our case let us suppose it is `B\_3`). Since a node is just a; positioned volume, we can then get a pointer to the volume, medium or; material objects related to it. ""Deepest"" means that `B\_3` still; contains point `P` (as well as `A\_1` and `TOP\_1`), but none of the; daughters of volume `B` does. After finding out the node containing; the particle, one can check if the geometry state is different compared; to the last located point:. ~~~{.cpp}; Bool_t *TGeoManager::IsSameLocation(); ~~~. The algorithm for finding where a point is located in geometry is; presented in the figure 17-36. It always starts by checking if the last computed modeller state is the; answer. This optimizes the search when continuously tracking a particle.; The main actions performed are:. - moving up and down in the logical node tree while updating the; current node and its global matrix; - converting the global position into the local frame of the current; node/volume; - checking whether the local position lies within the geometrical; shape of the current volume - if this is the case continue the; search downwards for the daughters of the current node, otherwise; search upwards its containers until the top level is reached.; - the number of candidate nodes to be checked at a given level is; minimized by an additional optimization structure: voxels. This is; effective even in case there is only one daughter of the current; volume.; - in case the current node is declared as possibly overlapping, the; method FindInCluster() is invoked. This method checks all different; possibilities within the cluster of overlapping candidates. One of; the candidates is prioritized if one of the following conditions id; fulfilled (in order):; - Is declared as non-overlapping (these are anyway searched first); - Has at least one daughter that contains the current point; - Was already declared as containing the point at a previous step. \image html geometry016.png ""Finding the location of a point in the geom",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:117790,log,logical,117790,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['log'],['logical']
Testability," (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an; object are unrelated. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. alpha.core.FixedAddr; (C); Check for assignment of a fixed address to a pointer. void test() {; int *p;; p = (int *) 0x10000; // warn; }. alpha.core.IdenticalExpr; (C, C++); Warn about suspicious uses of identical expressions. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. alpha.core.PointerArithm; (C); Check for pointer arithmetic on locations other than array; elements. void test() {; int x;; int *p;; p = &x + 1; // warn; }. alpha.core.PointerSub; (C); Check for pointer subtractions on two pointers pointing to different memory; chunks. void test() {; int x, y;; int d = &y - &x; // warn; }. alpha.core.SizeofPtr; (C); Warn about unintended use of sizeof() on pointer; expressions. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. alpha.core.StackAddressAsyncEscape; (C); Check that addresses to stac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:2523,test,test,2523,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['test'],['test']
Testability, * - compiler-rt/lib/scudo/standalone; - `49`; - `48`; - `1`; - :part:`97%`; * - compiler-rt/lib/scudo/standalone/benchmarks; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/fuzz; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/include/scudo; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/scudo/standalone/tests; - `25`; - `24`; - `1`; - :part:`96%`; * - compiler-rt/lib/scudo/standalone/tools; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/stats; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/benchmarks; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/tsan/dd; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/go; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/tsan/rtl; - `59`; - `14`; - `45`; - :part:`23%`; * - compiler-rt/lib/tsan/rtl-old; - `61`; - `13`; - `48`; - :part:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; *,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:25326,test,tests,25326,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['test'],['tests']
Testability," * ``-DCMAKE_C_COMPILER_TARGET=""arm-linux-gnueabihf""``; * ``-DCMAKE_ASM_COMPILER_TARGET=""arm-linux-gnueabihf""``; * ``-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN=/path/to/dir/toolchain``; * ``-DCMAKE_SYSROOT=/path/to/dir/toolchain/arm-linux-gnueabihf/libc``. Once cmake has completed the builtins can be built with ``ninja builtins``. Testing compiler-rt builtins using qemu-arm; ===========================================; To test the builtins library we need to add a few more cmake flags to enable; testing and set up the compiler and flags for test case. We must also tell; cmake that we wish to run the tests on ``qemu-arm``. * ``-DCOMPILER_RT_EMULATOR=""qemu-arm -L /path/to/armhf/sysroot``; * ``-DCOMPILER_RT_INCLUDE_TESTS=ON``; * ``-DCOMPILER_RT_TEST_COMPILER=""/path/to/clang""``; * ``-DCOMPILER_RT_TEST_COMPILER_CFLAGS=""test-c-flags""``. The ``/path/to/armhf/sysroot`` should be the same as the one passed to; ``--sysroot`` in the ""build-c-flags"". The ""test-c-flags"" need to include the target, architecture, gcc-toolchain,; sysroot and arm/thumb state. The additional cmake defines such as; ``CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN`` do not apply when building the tests. If; you have put all of these in ""build-c-flags"" then these can be repeated. If you; wish to use lld to link the tests then add ``""-fuse-ld=lld``. Once cmake has completed the tests can be built and run using; ``ninja check-builtins``. Troubleshooting; ===============. The cmake try compile stage fails; ---------------------------------; At an early stage cmake will attempt to compile and link a simple C program to; test if the toolchain is working. This stage can often fail at link time if the ``--sysroot=`` and; ``--gcc-toolchain=`` options are not passed to the compiler. Check the; ``CMAKE_C_FLAGS`` and ``CMAKE_C_COMPILER_TARGET`` flags. It can be useful to build a simple example outside of cmake with your toolchain; to make sure it is working. For example: ``clang --target=arm-linux-gnueabi -march=armv7a --gcc-tool",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:5283,test,test-c-flags,5283,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,1,['test'],['test-c-flags']
Testability," **`TRotation`**; or by a boost:. ``` {.cpp}; TLorentzRotation l; // l is initialized as identity; TLorentzRotation m(l);// m = l; TRotation r;; TLorentzRotation lr(r);; TLorentzRotation lb1(bx,by,bz);; TVector3 b;; TLorentzRotation lb2(b);; ```. The Matrix for a Lorentz boosts is:. $$; \left|; \begin{array}{cccc}; 1+gamma'*bx*bx & gamma'*bx*by & gamma'*bx*bz & gamma*bx \\; gamma'*bx*bz & 1+gamma'*by*by & gamma'*by*by & gamma*by \\; gamma'*bz*bx & gamma'*bz*by & 1+gamma'*bz*bz & gamma*bz \\; gamma*bx & gamma*by & gamma*bz & gamma; \end{array}; \right|; $$. with the boost vector `b=(bx,by,bz)`;; `gamma=1/Sqrt(1-beta*beta)`;` gamma'=(gamma-1)/beta*beta.`. ### Access to the Matrix Components/Comparisons. The access to the matrix components is possible with the methods `XX()`,; `XY()` ... `TT()`, and with the operator` (int,int)`:. ``` {.cpp}; Double_t xx;; TLorentzRotation l;; xx = l.XX(); // gets the xx component; xx = l(0,0); // gets the xx component; if (l == m) {...} // test for equality; if (l != m) {...} // test for inequality; if (l.IsIdentity()) {...} // test for identity; ```. ### Transformations of a Lorentz Rotation. There are four possibilities to find the product of two; **`TLorentzRotation`** transformations:. ``` {.cpp}; TLorentzRotation a,b,c;; c = b*a; // product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b; // a=a*b; c = a.Transform(b) // a=b*a then c=a; ```. Lorentz boosts:. ``` {.cpp}; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; ```. Rotations:. ``` {.cpp}; TVector3 axis;; l.RotateX(TMath::Pi()); // rotation around x-axis; l.Rotate(.5,axis); // rotation around specified vector; ```. Inverse transformation: use the method `Inverse() `to return the inverse; transformation keeping the current one unchanged`.` The method; `Invert()` inverts the current **`TLorentzRotation`**:. ``` {.cpp}; l1 = l2.Inverse(); // l1 is inverse of l2, l2 unchanged; l1 = l2.Invert(); // invert l2, then l1=l2",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:16402,test,test,16402,documentation/users-guide/PhysicsVectors.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md,1,['test'],['test']
Testability," *re-configuration*, you must either: (1) have ``llvm-gcc``; you just built in your path, or (2) specify the directory where your; just-built ``llvm-gcc`` is installed using; ``--with-llvmgccdir=$LLVM_GCC_DIR``. You must also tell the configure machinery that the test suite is; available so it can be configured for your build tree:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT ; $LLVM_SRC_ROOT/configure [--with-llvmgccdir=$LLVM_GCC_DIR]. [Remember that ``$LLVM_GCC_DIR`` is the directory where you; *installed* llvm-gcc, not its src or obj directory.]. #. You can now run the test suite from your build tree as follows:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT/projects/test-suite; % make. Note that the second and third steps only need to be done once. After; you have the suite checked out and configured, you don't need to do it; again (unless the test code or configure script changes). Configuring External Tests; ==========================. In order to run the External tests in the ``test-suite`` module, you; must specify *--with-externals*. This must be done during the; *re-configuration* step (see above), and the ``llvm`` re-configuration; must recognize the previously-built ``llvm-gcc``. If any of these is; missing or neglected, the External tests won't work. * *--with-externals*. * *--with-externals=<directory>*. This tells LLVM where to find any external tests. They are expected to; be in specifically named subdirectories of <``directory``>. If; ``directory`` is left unspecified, ``configure`` uses the default value; ``/home/vadve/shared/benchmarks/speccpu2000/benchspec``. Subdirectory; names known to LLVM include:. * spec95. * speccpu2000. * speccpu2006. * povray31. Others are added from time to time, and can be determined from; ``configure``. Running Different Tests; =======================. In addition to the regular ""whole program"" tests, the ``test-suite``; module also provides a mechanism for compiling the programs in different; ways. If the variable TEST is de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:1954,test,tests,1954,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,2,['test'],"['test-suite', 'tests']"
Testability," + y*2;; Read function definition:; define double @testfunc(double %x, double %y) {; entry:; %multmp = fmul double %y, 2.000000e+00; %addtmp = fadd double %multmp, %x; ret double %addtmp; }. ready> testfunc(4, 10);; Read top-level expression:; define double @1() {; entry:; %calltmp = call double @testfunc(double 4.000000e+00, double 1.000000e+01); ret double %calltmp; }. Evaluated to 24.000000. ready> testfunc(5, 10);; ready> LLVM ERROR: Program used external function 'testfunc' which could not be resolved!. Function definitions and calls also work, but something went very wrong on that; last line. The call looks valid, so what happened? As you may have guessed from; the API a Module is a unit of allocation for the JIT, and testfunc was part; of the same module that contained anonymous expression. When we removed that; module from the JIT to free the memory for the anonymous expression, we deleted; the definition of ``testfunc`` along with it. Then, when we tried to call; testfunc a second time, the JIT could no longer find it. The easiest way to fix this is to put the anonymous expression in a separate; module from the rest of the function definitions. The JIT will happily resolve; function calls across module boundaries, as long as each of the functions called; has a prototype, and is added to the JIT before it is called. By putting the; anonymous expression in a different module we can delete it without affecting; the rest of the functions. In fact, we're going to go a step further and put every function in its own; module. Doing so allows us to exploit a useful property of the KaleidoscopeJIT; that will make our environment more REPL-like: Functions can be added to the; JIT more than once (unlike a module where every function must have a unique; definition). When you look up a symbol in KaleidoscopeJIT it will always return; the most recent definition:. ::. ready> def foo(x) x + 1;; Read function definition:; define double @foo(double %x) {; entry:; %addtmp = fa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:16786,test,testfunc,16786,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['test'],['testfunc']
Testability, - :good:`100%`; * - polly/lib/Analysis; - `9`; - `9`; - `0`; - :good:`100%`; * - polly/lib/CodeGen; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/lib/Exchange; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/External/isl; - `68`; - `1`; - `67`; - :part:`1%`; * - polly/lib/External/isl/imath; - `6`; - `1`; - `5`; - :part:`16%`; * - polly/lib/External/isl/imath_wrap; - `4`; - `0`; - `4`; - :none:`0%`; * - polly/lib/External/isl/include/isl; - `59`; - `9`; - `50`; - :part:`15%`; * - polly/lib/External/isl/interface; - `8`; - `1`; - `7`; - :part:`12%`; * - polly/lib/External/pet/include; - `1`; - `0`; - `1`; - :none:`0%`; * - polly/lib/External/ppcg; - `17`; - `0`; - `17`; - :none:`0%`; * - polly/lib/Plugin; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/Support; - `11`; - `11`; - `0`; - :good:`100%`; * - polly/lib/Transform; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/tools/GPURuntime; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/DeLICM; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Flatten; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Isl; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/ScheduleOptimizer; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/ScopPassManager; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/unittests/Support; - `1`; - `1`; - `0`; - :good:`100%`; * - pstl/include/pstl/internal; - `23`; - `16`; - `7`; - :part:`69%`; * - pstl/include/pstl/internal/omp; - `11`; - `8`; - `3`; - :part:`72%`; * - third-party/benchmark/cmake; - `5`; - `1`; - `4`; - :part:`20%`; * - third-party/benchmark/include/benchmark; - `1`; - `0`; - `1`; - :none:`0%`; * - third-party/benchmark/src; - `21`; - `21`; - `0`; - :good:`100%`; * - utils/bazel/llvm-project-overlay/clang/include/clang/Config; - `1`; - `1`; - `0`; - :good:`100%`; * - utils/bazel/llvm-project-overlay/llvm/include/llvm/Config; - `2`; - `1`; - `1`; - :part:`50%`; * - Total; - :total:`16432`; - :total:`8857`; - :total:`7575`; - :total:`53%`; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:125489,benchmark,benchmark,125489,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,4,['benchmark'],['benchmark']
Testability," - Release Testers). <https://discourse.llvm.org/c/infrastructure/release-testers/66>`_. The official testers list is in the file ``RELEASE_TESTERS.TXT``, in the ``LLVM``; repository. Community Testing; -----------------. Once all testing has been completed and appropriate bugs filed, the release; candidate tarballs are put on the website and the LLVM community is notified. We ask that all LLVM developers test the release in any the following ways:. #. Download ``llvm-X.Y``, ``llvm-test-X.Y``, and the appropriate ``clang``; binary. Build LLVM. Run ``make check`` and the full LLVM test suite (``make; TEST=nightly report``). #. Download ``llvm-X.Y``, ``llvm-test-X.Y``, and the ``clang`` sources. Compile; everything. Run ``make check`` and the full LLVM test suite (``make; TEST=nightly report``). #. Download ``llvm-X.Y``, ``llvm-test-X.Y``, and the appropriate ``clang``; binary. Build whole programs with it (ex. Chromium, Firefox, Apache) for; your platform. #. Download ``llvm-X.Y``, ``llvm-test-X.Y``, and the appropriate ``clang``; binary. Build *your* programs with it and check for conformance and; performance regressions. #. Run the :doc:`release process <ReleaseProcess>`, if your platform is; *different* than that which is officially supported, and report back errors; only if they were not reported by the official release tester for that; architecture. We also ask that the OS distribution release managers test their packages with; the first candidate of every release, and report any *new* errors in GitHub.; If the bug can be reproduced with an unpatched upstream version of the release; candidate (as opposed to the distribution's own build), the priority should be; release blocker. During the first round of testing, all regressions must be fixed before the; second release candidate is tagged. In the subsequent stages, the testing is only to ensure that bug; fixes previously merged in have not created new major problems. *This is not; the time to solve additional and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:8750,test,test-X,8750,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['test'],['test-X']
Testability," - Shape; - Custom; - Error; - Log. #### SOFIE Keras Parser; - The Swish Activation function is now supported in the SOFIE Keras parser. ## 2D Graphics Libraries. - Introduce `TAxis::ChangeLabelByValue` to set custom label defined by axis value. It works also; when axis zooming changes and position and index of correspondent axis label changes as well.; `TAxis::ChangeLabel` method to change axis label by index works as before. - Introduce `TCanvas::SaveAll` method. Allows to store several pads at once into different image file formats.; File name can include printf qualifier to code pad number. Also allows to store all pads in single PDF; or single ROOT file. Significantly improves performance when creating many image files using web graphics. - Introduce `TCanvas::UpdateAsync` method. In case of web-based canvas triggers update of the canvas on the client side,; but does not wait that real update is completed. Avoids blocking of caller thread.; Have to be used if called from other web-based widget to avoid logical dead-locks.; In case of normal canvas just canvas->Update() is performed. - The Delaunay triangles (used by TGraph2D) were computed by the external package `triangle.c`; included in the ROOT distribution. This package had several issues:; - It was not maintained anymore.; - Its license was not compatible with LGPL; This code is now replaced by the [CDT package](https://github.com/artem-ogre/CDT) which is; properly maintained and has a license (MLP) compatible with LGPL. It will appear in 6.03.02. ## Machine Learning integration. - ROOT now offers functionality to extract batches of events out of a dataset for use in common ML training workflows. For example, one can generate PyTorch tensors from a TTree. The functionality is available through the `RBatchGenerator` class and can be seamlessly integrated in user code, for example:; ```python; # Returns two generators that return training and validation batches as PyTorch tensors.; gen_train, gen_validation ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:20142,log,logical,20142,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['log'],['logical']
Testability, - `0`; - `1`; - :none:`0%`; * - libc/benchmarks; - `15`; - `14`; - `1`; - :part:`93%`; * - libc/benchmarks/automemcpy/include/automemcpy; - `4`; - `4`; - `0`; - :good:`100%`; * - libc/benchmarks/automemcpy/lib; - `5`; - `5`; - `0`; - :good:`100%`; * - libc/benchmarks/automemcpy/unittests; - `2`; - `2`; - `0`; - :good:`100%`; * - libc/config/linux; - `1`; - `1`; - `0`; - :good:`100%`; * - libc/fuzzing/math; - `6`; - `6`; - `0`; - :good:`100%`; * - libc/fuzzing/stdlib; - `3`; - `3`; - `0`; - :good:`100%`; * - libc/fuzzing/string; - `3`; - `2`; - `1`; - :part:`66%`; * - libc/include; - `1`; - `1`; - `0`; - :good:`100%`; * - libc/include/llvm-libc-macros; - `2`; - `2`; - `0`; - :good:`100%`; * - libc/include/llvm-libc-macros/linux; - `1`; - `1`; - `0`; - :good:`100%`; * - libc/include/llvm-libc-types; - `28`; - `28`; - `0`; - :good:`100%`; * - libc/loader/linux/aarch64; - `1`; - `1`; - `0`; - :good:`100%`; * - libc/loader/linux/x86_64; - `1`; - `1`; - `0`; - :good:`100%`; * - libc/src/assert; - `3`; - `1`; - `2`; - :part:`33%`; * - libc/src/ctype; - `32`; - `32`; - `0`; - :good:`100%`; * - libc/src/errno; - `4`; - `4`; - `0`; - :good:`100%`; * - libc/src/fcntl; - `3`; - `3`; - `0`; - :good:`100%`; * - libc/src/fcntl/linux; - `3`; - `3`; - `0`; - :good:`100%`; * - libc/src/fenv; - `28`; - `28`; - `0`; - :good:`100%`; * - libc/src/inttypes; - `6`; - `6`; - `0`; - :good:`100%`; * - libc/src/math; - `91`; - `91`; - `0`; - :good:`100%`; * - libc/src/math/aarch64; - `10`; - `10`; - `0`; - :good:`100%`; * - libc/src/math/generic; - `94`; - `94`; - `0`; - :good:`100%`; * - libc/src/math/x86_64; - `3`; - `3`; - `0`; - :good:`100%`; * - libc/src/signal; - `8`; - `8`; - `0`; - :good:`100%`; * - libc/src/signal/linux; - `10`; - `10`; - `0`; - :good:`100%`; * - libc/src/stdio; - `3`; - `3`; - `0`; - :good:`100%`; * - libc/src/stdlib; - `46`; - `46`; - `0`; - :good:`100%`; * - libc/src/stdlib/linux; - `2`; - `2`; - `0`; - :good:`100%`; * - libc/src/string; - `61`; - `61`; - `0`; - :g,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:32546,assert,assert,32546,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['assert'],['assert']
Testability," - ``__xray_log_init_mode(...)``: This function allows for initializing and; re-initializing an installed logging implementation. See; ``xray/xray_log_interface.h`` for details, part of the XRay compiler-rt; installation. Once a logging implementation has been initialized, it can be ""stopped"" by; finalizing the implementation through the ``__xray_log_finalize()`` function.; The finalization routine is the opposite of the initialization. When finalized,; an implementation's data can be cleared out through the; ``__xray_log_flushLog()`` function. For implementations that support in-memory; processing, these should register an iterator function to provide access to the; data via the ``__xray_log_set_buffer_iterator(...)`` which allows code calling; the ``__xray_log_process_buffers(...)`` function to deal with the data in; memory. All of this is better explained in the ``xray/xray_log_interface.h`` header. Basic Mode; ----------. XRay supports a basic logging mode which will trace the application's; execution, and periodically append to a single log. This mode can be; installed/enabled by setting ``xray_mode=xray-basic`` in the ``XRAY_OPTIONS``; environment variable. Combined with ``patch_premain=true`` this can allow for; tracing applications from start to end. Like all the other modes installed through ``__xray_log_select_mode(...)``, the; implementation can be configured through the ``__xray_log_init_mode(...)``; function, providing the mode string and the flag options. Basic-mode specific; defaults can be provided in the ``XRAY_BASIC_OPTIONS`` environment variable. Flight Data Recorder Mode; -------------------------. XRay supports a logging mode which allows the application to only capture a; fixed amount of memory's worth of events. Flight Data Recorder (FDR) mode works; very much like a plane's ""black box"" which keeps recording data to memory in a; fixed-size circular queue of buffers, and have the data available; programmatically until the buffers are finalized a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst:8129,log,logging,8129,interpreter/llvm-project/llvm/docs/XRay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst,2,['log'],"['log', 'logging']"
Testability," ----------------------------------------------------. So far we have seen how the CommandLine library handles builtin types like; ``std::string``, ``bool`` and ``int``, but how does it handle things it doesn't; know about, like enums or '``int*``'s?. The answer is that it uses a table-driven generic parser (unless you specify; your own parser, as described in the `Extension Guide`_). This parser maps; literal strings to whatever type is required, and requires you to tell it what; this mapping should be. Let's say that we would like to add four optimization levels to our optimizer,; using the standard flags ""``-g``"", ""``-O0``"", ""``-O1``"", and ""``-O2``"". We; could easily implement this with boolean options like above, but there are; several problems with this strategy:. #. A user could specify more than one of the options at a time, for example,; ""``compiler -O3 -O2``"". The CommandLine library would not be able to catch; this erroneous input for us. #. We would have to test 4 different variables to see which ones are set. #. This doesn't map to the numeric levels that we want... so we cannot easily; see if some level >= ""``-O1``"" is enabled. To cope with these problems, we can use an enum value, and have the CommandLine; library fill it in with the appropriate level directly, which is used like this:. .. code-block:: c++. enum OptLevel {; g, O1, O2, O3; };. cl::opt<OptLevel> OptimizationLevel(cl::desc(""Choose optimization level:""),; cl::values(; clEnumVal(g , ""No optimizations, enable debugging""),; clEnumVal(O1, ""Enable trivial optimizations""),; clEnumVal(O2, ""Enable default optimizations""),; clEnumVal(O3, ""Enable expensive optimizations"")));. ...; if (OptimizationLevel >= O2) doPartialRedundancyElimination(...);; ... This declaration defines a variable ""``OptimizationLevel``"" of the; ""``OptLevel``"" enum type. This variable can be assigned any of the values that; are listed in the declaration. The CommandLine library enforces that; the user can only specify one of the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:14279,test,test,14279,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['test'],['test']
Testability," ---------------. .. option:: -h, --help. Show the :program:`lit` help message. .. option:: -j N, --workers=N. Run ``N`` tests in parallel. By default, this is automatically chosen to; match the number of detected available CPUs. .. option:: --config-prefix=NAME. Search for :file:`{NAME}.cfg` and :file:`{NAME}.site.cfg` when searching for; test suites, instead of :file:`lit.cfg` and :file:`lit.site.cfg`. .. option:: -D NAME[=VALUE], --param NAME[=VALUE]. Add a user defined parameter ``NAME`` with the given ``VALUE`` (or the empty; string if not given). The meaning and use of these parameters is test suite; dependent. .. _output-options:. OUTPUT OPTIONS; --------------. .. option:: -q, --quiet. Suppress any output except for test failures. .. option:: -s, --succinct. Show less output, for example don't show information on tests that pass.; Also show a progress bar, unless ``--no-progress-bar`` is specified. .. option:: -v, --verbose. Show more information on test failures, for example the entire test output; instead of just the test result. Each command is printed before it is executed. This can be valuable for; debugging test failures, as the last printed command is the one that failed.; Moreover, :program:`lit` inserts ``'RUN: at line N'`` before each; command pipeline in the output to help you locate the source line of; the failed command. .. option:: -vv, --echo-all-commands. Deprecated alias for -v. .. option:: -a, --show-all. Enable -v, but for all tests not just failed tests. .. option:: --no-progress-bar. Do not use curses based progress bar. .. option:: --show-unsupported. Show the names of unsupported tests. .. option:: --show-xfail. Show the names of tests that were expected to fail. .. _execution-options:. EXECUTION OPTIONS; -----------------. .. option:: --path=PATH. Specify an additional ``PATH`` to use when searching for executables in tests. .. option:: --vg. Run individual tests under valgrind (using the memcheck tool). The; ``--error-exitcode`` argum",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:3308,test,test,3308,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,3,['test'],['test']
Testability," --max-pass-iterations=<int>. Maximum number of times to run the full set of delta passes (default=5). .. option:: --mtriple=<string> . Set the target triple. .. option:: --preserve-debug-environment. Don't disable features used for crash debugging (crash reports, llvm-symbolizer and core dumps). .. option:: --print-delta-passes . Print list of delta passes, passable to --delta-passes as a comma separated liste. .. option:: --skip-delta-passes=<string> . Delta passes to not run, separated by commas. By default, run all delta passes. .. option:: --starting-granularity-level=<uint>. Number of times to divide chunks prior to first test. Note : Granularity refers to the level of detail at which the reduction process operates.; A lower granularity means that the reduction process operates at a more coarse-grained level,; while a higher granularity means that it operates at a more fine-grained level. .. option:: --test=<string> . Name of the interesting-ness test to be run. .. option:: --test-arg=<string> . Arguments passed onto the interesting-ness test. .. option:: --verbose . Print extra debugging information.; ; .. option:: --write-tmp-files-as-bitcode . Always write temporary files as bitcode instead of textual IR. .. option:: -x={ir|mir}. Input language as ir or mir. EXIT STATUS; ------------. :program:`llvm-reduce` returns 0 under normal operation. It returns a non-zero; exit code if there were any errors. EXAMPLE; -------. :program:`llvm-reduce` can be used to simplify a test that causes a; compiler crash. For example, let's assume that `opt` is crashing on the IR file; `test.ll` with error message `Assertion failed at line 1234 of; WhateverFile.cpp`, when running at `-O2`. The test case of `test.ll` can be reduced by invoking the following; command:. .. code-block:: bash. $(LLVM_BUILD_FOLDER)/bin/llvm-reduce --test=script.sh <path to>/test.ll. The shell script passed to the option `test` consists of the; following:. .. code-block:: bash. $(LLVM_BUILD_FOLDER)/bin/o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst:2396,test,test-arg,2396,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst,1,['test'],['test-arg']
Testability," --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commit CI uses a recent; nightly build of Clang from LLVM's main; branch. These configurations do not use the Clang changes in the; patch. They only use the libc++ changes.; The ""Bootstrapping build"" builds Clang and uses it to build and; test libc++. This build does use the Clang changes in the patch.; Libc++ supports multiple versions of Clang. Therefore when a patch changes; the diagnostics it might be required to use a regex in the; ""expected"" tests to make it pass the CI.; Libc++ has more; ; documentation about the pre-commit CI. F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:7853,test,tests,7853,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,1,['test'],['tests']
Testability," -SIGUSR1 /path/to/fuzzer/binary`` to stop the merge gracefully. Example:. .. code-block:: console. % rm -f SomeLocalPath; % ./my_fuzzer CORPUS1 CORPUS2 -merge=1 -merge_control_file=SomeLocalPath; ...; MERGE-INNER: using the control file 'SomeLocalPath'; ...; # While this is running, do `killall -SIGUSR1 my_fuzzer` in another console; ==9015== INFO: libFuzzer: exiting as requested. # This will leave the file SomeLocalPath with the partial state of the merge.; # Now, you can continue the merge by executing the same command. The merge; # will continue from where it has been interrupted.; % ./my_fuzzer CORPUS1 CORPUS2 -merge=1 -merge_control_file=SomeLocalPath; ...; MERGE-OUTER: non-empty control file provided: 'SomeLocalPath'; MERGE-OUTER: control file ok, 32 files total, first not processed file 20; ... Options; =======. To run the fuzzer, pass zero or more corpus directories as command line; arguments. The fuzzer will read test inputs from each of these corpus; directories, and any new test inputs that are generated will be written; back to the first corpus directory:. .. code-block:: console. ./fuzzer [-flag1=val1 [-flag2=val2 ...] ] [dir1 [dir2 ...] ]. If a list of files (rather than directories) are passed to the fuzzer program,; then it will re-run those files as test inputs but will not perform any fuzzing.; In this mode the fuzzer binary can be used as a regression test (e.g. on a; continuous integration system) to check the target function and saved inputs; still work. The most important command line options are:. ``-help``; Print help message (``-help=1``).; ``-seed``; Random seed. If 0 (the default), the seed is generated.; ``-runs``; Number of individual test runs, -1 (the default) to run indefinitely.; ``-max_len``; Maximum length of a test input. If 0 (the default), libFuzzer tries to guess; a good value based on the corpus (and reports it).; ``-len_control``; Try generating small inputs first, then try larger inputs over time.; Specifies the rate at whi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:9506,test,test,9506,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,2,['test'],['test']
Testability," -cc1 -analyze -analyzer-checker=core test.c; $ lldb -- clang -cc1 -analyze -analyzer-checker=core test.c. Otherwise, if your command line contains --analyze,; the actual clang instance would be run in a separate process. In; order to debug it, use the -### flag for obtaining; the command line of the child process:. $ clang --analyze test.c -\#\#\#. Below we describe a few useful command line arguments, all of which assume that; you are running clang -cc1. Narrowing Down the Problem; While investigating a checker-related issue, instruct the analyzer to only; execute a single checker:. $ clang -cc1 -analyze -analyzer-checker=osx.KeychainAPI test.c. If you are experiencing a crash, to see which function is failing while; processing a large file use the -analyzer-display-progress; option.; To selectively analyze only the given function, use the; -analyze-function option:. $ clang -cc1 -analyze -analyzer-checker=core test.c -analyzer-display-progress; ANALYZE (Syntax): test.c foo; ANALYZE (Syntax): test.c bar; ANALYZE (Path, Inline_Regular): test.c bar; ANALYZE (Path, Inline_Regular): test.c foo; $ clang -cc1 -analyze -analyzer-checker=core test.c -analyzer-display-progress -analyze-function=foo; ANALYZE (Syntax): test.c foo; ANALYZE (Path, Inline_Regular): test.c foo. Note: a fully qualified function name has to be used when selecting; C++ functions and methods, Objective-C methods and blocks, e.g.:. $ clang -cc1 -analyze -analyzer-checker=core test.cc -analyze-function='foo(int)'. The fully qualified name can be found from the; -analyzer-display-progress output. The bug reporter mechanism removes path diagnostics inside intermediate; function calls that have returned by the time the bug was found and contain; no interesting pieces. Usually it is up to the checkers to produce more; interesting pieces by adding custom BugReporterVisitor objects.; However, you can disable path pruning while debugging with the; -analyzer-config prune-paths=false option. Visualizing the An",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:19996,test,test,19996,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['test'],['test']
Testability," -q -l ${CMAKE_CURRENT_SOURCE_DIR}/stressHistoFit.cxx; FAILREGEX ""FAILED|Error in"" DEPENDS test-stresshistofit ); endif(); endif(). #--stressEntryList---------------------------------------------------------------------------; ROOT_EXECUTABLE(stressEntryList stressEntryList.cxx LIBRARIES MathCore Tree Hist); ROOT_ADD_TEST(test-stressentrylist COMMAND stressEntryList -b FAILREGEX ""FAILED|Error in""); ROOT_ADD_TEST(test-stressentrylist-interpreted COMMAND ${ROOT_root_CMD} -b -q -l ${CMAKE_CURRENT_SOURCE_DIR}/stressEntryList.cxx; FAILREGEX ""FAILED|Error in"" DEPENDS test-stressentrylist). #--stressIterators---------------------------------------------------------------------------; ROOT_EXECUTABLE(stressIterators stressIterators.cxx LIBRARIES Core); ROOT_ADD_TEST(test-stressiterators COMMAND stressIterators FAILREGEX ""FAILED|Error in""); ROOT_ADD_TEST(test-stressiterators-interpreted COMMAND ${ROOT_root_CMD} -b -q -l ${CMAKE_CURRENT_SOURCE_DIR}/stressIterators.cxx; FAILREGEX ""FAILED|Error in"" DEPENDS test-stressiterators). #--stressInterpreter-------------------------------------------------------------------------; ROOT_EXECUTABLE(stressInterpreter stressInterpreter.cxx LIBRARIES Core); if(WIN32); set(cleantmpfiles POSTCMD cmd /c del AutoDict_*); endif(); ROOT_ADD_TEST(test-stressinterpreter COMMAND stressInterpreter; WORKING_DIR ${CMAKE_BINARY_DIR}; PRECMD ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/stressInterpreter.cxx; $<TARGET_FILE_DIR:stressInterpreter>/stressInterpreter.cxx; ${cleantmpfiles}; FAILREGEX Error|FAILED). #--stressHepix-------------------------------------------------------------------------------; ROOT_EXECUTABLE(stressHepix stressHepix.cxx LIBRARIES Core); #ROOT_ADD_TEST(test-stressHepix COMMAND stressHepix FAILREGEX ""FAILED|Error in""). #--stressProof-------------------------------------------------------------------------------; if(proof AND NOT WIN32); add_custom_target(TestData COMMAND ${CMAKE_COMMAND} -DDST=${CMAKE_SOURCE_DIR}/files -P ${",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/CMakeLists.txt:14386,test,test-stressiterators,14386,test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/CMakeLists.txt,1,['test'],['test-stressiterators']
Testability," . TMVA. TMVA version 4.1.0 is included in this root release. The most; important new feature is the support for simulataneous classification ; of multiple output classes for several multi-variate methods. ; A lot of effort went into consolidation of the software,; i.e. method performance and robustness, and framework; stability. The changes with respect to ROOT 5.27 / TMVA 4.0.7 are; in detail:. Framework. Multi-class support. The support of multiple; output classes (i.e., more than a single background and signal; class) has been enabled for these methods: MLP (NN), BDTG,; FDA.; The multiclass; functionality can be enabled with the Factory option; ""AnalysisType=multiclass"". Training data is; specified with an additional classname, e.g. via; factory->AddTree(tree,""classname"");. After the; training a genetic algorithm is invoked to determine the best; cuts for selecting a specific class, based on the figure of; merit: purity*efficiency. TMVA comes with two examples in; $ROOTSYS/tmva/test: TMVAMulticlass.C; and TMVAMulticlassApplication.C. New TMVA event vector building. The code; for splitting the input data into training and test samples for; all classes and the mixing of those samples to one training and; one test sample has been rewritten completely. The new code is; more performant and has a clearer structure. This fixes several; bugs which have been reported by some users of TMVA.; Code and performance test framework: A unit; test framework for daily software and method performance; validation has been implemented.; . Methods. BDT Automatic parameter optimisation for building the; tree architecture: The optimisation procedure uses the; performance of the trained classifier on the ""test sample"" for; finding the set of optimal parameters. Two different methods to; traverse the parameter space are available (scanning, genetic; algorithm). Currently parameter optimization is implemented only; for these three parameters that influence the tree architectur:; the maximu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v528/index.html:997,test,test,997,tmva/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v528/index.html,1,['test'],['test']
Testability," .. _int_vp_lshr:. '``llvm.vp.lshr.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x i32> @llvm.vp.lshr.v16i32 (<16 x i32> <left_op>, <16 x i32> <right_op>, <16 x i1> <mask>, i32 <vector_length>); declare <vscale x 4 x i32> @llvm.vp.lshr.nxv4i32 (<vscale x 4 x i32> <left_op>, <vscale x 4 x i32> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>); declare <256 x i64> @llvm.vp.lshr.v256i64 (<256 x i64> <left_op>, <256 x i64> <right_op>, <256 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". Vector-predicated logical right-shift. Arguments:; """""""""""""""""""". The first two operands and the result have the same vector of integer type. The; third operand is the vector mask and has the same number of elements as the; result vector type. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.lshr``' intrinsic computes the logical right shift; (:ref:`lshr <i_lshr>`) of the first operand by the second operand on each; enabled lane. The result on disabled lanes is a; :ref:`poison value <poisonvalues>`. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x i32> @llvm.vp.lshr.v4i32(<4 x i32> %a, <4 x i32> %b, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = lshr <4 x i32> %a, %b; %also.r = select <4 x i1> %mask, <4 x i32> %t, <4 x i32> poison. .. _int_vp_shl:. '``llvm.vp.shl.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x i32> @llvm.vp.shl.v16i32 (<16 x i32> <left_op>, <16 x i32> <right_op>, <16 x i1> <mask>, i32 <vector_length>); declare <vscale x 4 x i32> @llvm.vp.shl.nxv4i32 (<vscale x 4 x i32> <left_op>, <vscale x 4 x i32> <right_op>, <vscale x 4 x i1> <mask>, i32 <vector_length>); declare <256 x i64> @llvm.vp.shl.v256i64 (<256 x i64> <left_op>, <256 x i64> <right_op>, <256 x i1> <mask>, i32 <vector_length>). Over",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:709879,log,logical,709879,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['log'],['logical']
Testability," .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. .. _security-insecureAPI-vfork:. security.insecureAPI.vfork (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'vfork' function. .. code-block:: c. void test() {; vfork(); // warn; }. .. _security-insecureAPI-DeprecatedOrUnsafeBufferHandling:. security.insecureAPI.DeprecatedOrUnsafeBufferHandling (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on occurrences of unsafe or deprecated buffer handling functions, which now have a secure variant: ``sprintf, fprintf, vsprintf, scanf, wscanf, fscanf, fwscanf, vscanf, vwscanf, vfscanf, vfwscanf, sscanf, swscanf, vsscanf, vswscanf, swprintf, snprintf, vswprintf, vsnprintf, memcpy, memmove, strncpy, strncat, memset``. .. code-block:: c. void test() {; char b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:24582,test,test,24582,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability," / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.NullDereference; (C, C++, ObjC); Check for dereferences of null pointers. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. core.StackAddressEscape; (C); Check that addresses of stack memory do not escape the function. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. core.UndefinedBinaryOperatorResult; (C); Check for undefined results of binary operators. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. core.VLASize; (C); Check for declarations of VLA of undefined or zero size. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. core.uninitialized.ArraySubscript; (C); Check for uninitialized values used as array subscripts. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. core.uninitialized.Assign; (C); Check for assigning uninitialized values. void test() {; int x;; x |= 1; // warn: left expression is uninitialized; }. core.uninitialized.Branch; (C); Check for uninitialized values used as branch conditions. void test() {; int x;; if (x) // warn; return;; }. core.uninitialized.CapturedBlockVariable; (C); Check for blocks that capture uninitialized values. void test() {; int x;; ^{ i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:3847,test,test,3847,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability," // warn; c -= 1;; return c;; }. different.LogicalOpUselessArg; (C); The second operand of a && operator has no impact on; expression result. void test(unsigned a) {; if (a<7 && a<10) {}; // warn; }. different.SameResLogicalExpr; (C); An expression is always evaluated to true/false. void test() {; int i = 0;; if (i != 0) {}; // warn; }. void test(int i) {; if (i == 0 && i == 1) {}; // warn; }. void test(int i) {; if (i < 0 || i >= 0) {}; // warn; }. different.OpPrecedenceAssignCmp; (C, C++); Comparison operation has higher precedence then assignment. Boolean value is; assigned to a variable of other type. Parenthesis may bee required around an; assignment. int f();. void test(int x, int y) {; bool b;; if((b = x != y)) {} // ok; if((x = f() != y)) {} // warn; }. different.OpPrecedenceIifShift; (C, C++); ?: has lower precedence then <<.; Source: Stephen C. Dewhurst ""C++ Gotchas: Avoiding Common Problems in Coding; and Design"", advise 15. #include <iostream>. void test(int a) {; std::cout << a ? ""a"" : ""b""; // warn; }. void test(int a) {; a << a > 7 ? 1 : 2; // warn; }. different.ObjectUnused; (C++); The object was created but is not being used. struct S {; int x, y;; S(int xx, int yy) : x(xx), y(yy) {}; S(int xx) {; S(xx, 0); // warn; }; };. #include <exception>. void test() {; std::exception();; // warn (did you mean 'throw std::exception()'?); }. different.StaticArrayPtrCompare; (C); Pointer to static array is being compared to NULL. May the subscripting is; missing. void test() {; int a[1][1];; if (a[0] == 0) {}; // warn; }. different.ConversionToBool; (C, C++); Odd implicit conversion to boolean.; Note: possibly merge with ; alpha.core.BoolAssignment. bool test() {; return 1.; // warn; }. bool test() {; return """"; // warn; }. different.ArrayBound; (C++); Out-of-bound dynamic array access.; Note: possibly an enhancement to ; alpha.security.ArrayBoundV2. void test() {; int *p = new int[1];; int i = 1;; if(p[i]) {}; // warn; delete[] p;; }. different.StrcpyInputSize; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:23298,test,test,23298,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability," // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. ..",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:23750,test,test,23750,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability," 0 skipped ==========``. Alternatives to manual installation; ===================================; Instead of the steps above, to simplify the installation procedure you can use; `Chocolatey <https://chocolatey.org/>`_ as package manager.; After the `installation <https://chocolatey.org/install>`_ of Chocolatey,; run these commands in an admin shell to install the required tools:. .. code-block:: bat. choco install -y git cmake python3; pip3 install psutil. There is also a Windows; `Dockerfile <https://github.com/llvm/llvm-zorg/blob/main/buildbot/google/docker/windows-base-vscode2019/Dockerfile>`_; with the entire build tool chain. This can be used to test the build with a; tool chain different from your host installation or to create build servers. Next steps; ==========; 1. Read the documentation.; 2. Seriously, read the documentation.; 3. Remember that you were warned twice about reading the documentation. Test LLVM on the command line:; ------------------------------; The LLVM tests can be run by changing directory to the llvm source; directory and running:. .. code-block:: bat. c:\llvm> python ..\build\Release\bin\llvm-lit.py llvm\test. This example assumes that Python is in your PATH variable, which would be; after **Add Python to the PATH** was selected during Python installation.; If you had opened a command window prior to Python installation, you would; have to close and reopen it to get the updated PATH. A specific test or test directory can be run with:. .. code-block:: bat. c:\llvm> python ..\build\Release\bin\llvm-lit.py llvm\test\Transforms\Util. Build the LLVM Suite:; ---------------------; * The projects may still be built individually, but to build them all do; not just select all of them in batch build (as some are meant as; configuration projects), but rather select and build just the; ``ALL_BUILD`` project to build everything, or the ``INSTALL`` project,; which first builds the ``ALL_BUILD`` project, then installs the LLVM; headers, libs, and ot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:8954,test,tests,8954,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['test'],['tests']
Testability," 0' .; Extend the functionality of the dataset API to obtaine; information on per-server base; add also two new methods:. TProof::SetDataSetTreeName(<dataset>,<treename>):; set/change the default tree name in the TFileCollection;; TProof::ExistsDataSet(<dataset>):; check; by-name the availability of a given dataset;. In ProofBench, . Load the macro before executing it. This allows to; circumvent a problem recently fixed giving less dependency on the; server version.; In make_dset.C, simplification of the body and of the; signature, eliminating one redundant argument. In TProofOutputFile, improve flexibility in defining the; URL for the local files server. The ""LOCALDATASERVER"" env is tested,; which can defined with placeholders via the xpd.putenv directive in the; xrootd/xproofd config files.; Improving parsing of lines with memory info.; This solves occasional crashes while generating the memory; plots.; In TProofMgr::GetSessionLogs:. add the possibility to postpone the retrieval of the; logs files when the TProofLog object is created. This improved; functionality is exploited in the log window.; add decoding of the session starting time and full; information about the master URL. Enable new xrootd configuration options, including the; possibility to set the compiler and linker; Cleanup of the TProofMgr functions DetachSession and; ShutdownSession, and better handling of the internal list registration,; to fix potential segvs when reopening a PROOF session inside the same; ROOT session.; Optimize the way results are transferred and merged:. Output objects are added to the same TMessage until a; HWM is reached (default 1MB; controlled by 'ProofServ.MsgSizeHWM');; this limits the number of transfers in the case of large numbers of; small objects.; Reasonably small histograms (GetSize() <; MsgSizeHWM) are merged in one-go at the end instead of one-by-one to; exploit, for example, the better performance of TH1::Merge on the full; list of histos.; Add possibility to comp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:6115,log,logs,6115,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['log'],['logs']
Testability," 0, i32 1 ; <i16*> [#uses=1]; %7 = bitcast i16* %6 to i32* ; <i32*> [#uses=2]; %8 = load i32* %7, align 1 ; <i32> [#uses=1]; %9 = and i32 %8, -131073 ; <i32> [#uses=1]; store i32 %9, i32* %7, align 1; ret void; }. LLVM currently emits this:. movq bfi(%rip), %rax; andl $-65537, 8(%rax); movq bfi(%rip), %rax; andl $-131073, 8(%rax); ret. It could narrow the loads and stores to emit this:. movq bfi(%rip), %rax; andb $-2, 10(%rax); movq bfi(%rip), %rax; andb $-3, 10(%rax); ret. The trouble is that there is a TokenFactor between the store and the; load, making it non-trivial to determine if there's anything between; the load and the store which would prohibit narrowing. //===---------------------------------------------------------------------===//. This code:; void foo(unsigned x) {; if (x == 0) bar();; else if (x == 1) qux();; }. currently compiles into:; _foo:; 	movl	4(%esp), %eax; 	cmpl	$1, %eax; 	je	LBB0_3; 	testl	%eax, %eax; 	jne	LBB0_4. the testl could be removed:; _foo:; 	movl	4(%esp), %eax; 	cmpl	$1, %eax; 	je	LBB0_3; 	jb	LBB0_4. 0 is the only unsigned number < 1. //===---------------------------------------------------------------------===//. This code:. %0 = type { i32, i1 }. define i32 @add32carry(i32 %sum, i32 %x) nounwind readnone ssp {; entry:; %uadd = tail call %0 @llvm.uadd.with.overflow.i32(i32 %sum, i32 %x); %cmp = extractvalue %0 %uadd, 1; %inc = zext i1 %cmp to i32; %add = add i32 %x, %sum; %z.0 = add i32 %add, %inc; ret i32 %z.0; }. declare %0 @llvm.uadd.with.overflow.i32(i32, i32) nounwind readnone. compiles to:. _add32carry: ## @add32carry; 	addl	%esi, %edi; 	sbbl	%ecx, %ecx; 	movl	%edi, %eax; 	subl	%ecx, %eax; 	ret. But it could be:. _add32carry:; 	leal	(%rsi,%rdi), %eax; 	cmpl	%esi, %eax; 	adcl	$0, %eax; 	ret. //===---------------------------------------------------------------------===//. The hot loop of 256.bzip2 contains code that looks a bit like this:. int foo(char *P, char *Q, int x, int y) {; if (P[0] != Q[0]); return P[0] < Q[0];; if (P[1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:38832,test,testl,38832,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['test'],['testl']
Testability," 0.90 s.(21.3 |; | | MB | MB/s) | MB/s) | MB/s) | MB/s) |; | Split = 1 | | | | | |; +------------+--------+---------------+---------------+----------------+----------------+; | Comp = 2 | 13.78 | 11.34s.(1.7 | 9.51 s.(2.0 | 2.17 s.(8.8 | 2.17 s.(8.8 |; | | MB | MB/s) | MB/s) | MB/s) | MB/s) |; | Split = 1 | | | | | |; +------------+--------+---------------+---------------+----------------+----------------+. The **Total Time** is the real time in seconds to run the program.; **Effective time** is the real time minus the time spent in non I/O; operations (essentially the random number generator). The program; `Event` generates in average 600 tracks per event. Each track has 17; data members. The read benchmark runs in the interactive version of; ROOT. The ‘Total Time to Read All' is the real time reported by the; execution of the script `&ROOTSYS/test/eventa`. We did not correct this time for the overhead coming from the; interpreter itself. The **Total time to read sample** is the execution; time of the script `$ROOTSYS/test/eventb`. This script loops on all; events. For each event, the branch containing the number of tracks is; read. In case the number of tracks is less than 585, the full event is; read in memory. This test is obviously not possible in non-split mode.; In non-split mode, the full event must be read in memory. The times; reported in the table correspond to complete I/O operations necessary to; deal with **machine independent binary files**. On **Linux**, this also; includes byte-swapping operations. The ROOT file allows for direct; access to any event in the file and direct access to any part of an; event when split=1. Note also that the uncompressed file generated with split=0 is 48.7; Mbytes and only 47.17 Mbytes for the option split=1. The difference in; size is due to the object identification mechanism overhead when the; event is written to a single buffer. This overhead does not exist in; split mode because the branch buffers are optimized for h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:138853,test,test,138853,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['test'],['test']
Testability," 0; Symbols 4 1; Types 2 1; Lines 17 6; -----------------------------; Total 26 8. COMPARISON MODE; ^^^^^^^^^^^^^^^; In this mode :program:`llvm-debuginfo-analyzer` compares logical views; to produce a report with the logical elements that are missing or added.; This a very powerful aid in finding semantic differences in the debug; information produced by different toolchain versions or even completely; different toolchains altogether (For example a compiler producing DWARF; can be directly compared against a completely different compiler that; produces CodeView). Given the previous example we found the above debug information issue; (related to the previous invalid scope location for the **'typedef int; INTEGER'**) by comparing against another compiler. Using GCC to generate test-dwarf-gcc.o, we can apply a selection pattern; with the printing mode to obtain the following logical view output. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level; --select-regex --select-nocase --select=INTe; --report=list; --print=symbols,types; test-dwarf-clang.o test-dwarf-gcc.o. Logical View:; [000] {File} 'test-dwarf-clang.o'. [001] {CompileUnit} 'test.cpp'; [003] 4 {TypeAlias} 'INTEGER' -> 'int'; [004] 5 {Variable} 'CONSTANT' -> 'const INTEGER'. Logical View:; [000] {File} 'test-dwarf-gcc.o'. [001] {CompileUnit} 'test.cpp'; [004] 4 {TypeAlias} 'INTEGER' -> 'int'; [004] 5 {Variable} 'CONSTANT' -> 'const INTEGER'. The output shows that both objects contain the same elements. But the; **'typedef INTEGER'** is located at different scope level. The GCC; generated object, shows **'4'**, which is the correct value. Note that there is no requirement that GCC must produce identical or; similar DWARF to Clang to allow the comparison. We're only comparing; the semantics. The same case when comparing CodeView debug information; generated by MSVC and Clang. There are 2 comparison methods: logical view and logical elements. LOGICAL VIEW; """"""""""""""""""""""""; It compares the logical view a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:28903,test,test-dwarf-clang,28903,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['test'],['test-dwarf-clang']
Testability," 32 files total, first not processed file 20; ... Options; =======. To run the fuzzer, pass zero or more corpus directories as command line; arguments. The fuzzer will read test inputs from each of these corpus; directories, and any new test inputs that are generated will be written; back to the first corpus directory:. .. code-block:: console. ./fuzzer [-flag1=val1 [-flag2=val2 ...] ] [dir1 [dir2 ...] ]. If a list of files (rather than directories) are passed to the fuzzer program,; then it will re-run those files as test inputs but will not perform any fuzzing.; In this mode the fuzzer binary can be used as a regression test (e.g. on a; continuous integration system) to check the target function and saved inputs; still work. The most important command line options are:. ``-help``; Print help message (``-help=1``).; ``-seed``; Random seed. If 0 (the default), the seed is generated.; ``-runs``; Number of individual test runs, -1 (the default) to run indefinitely.; ``-max_len``; Maximum length of a test input. If 0 (the default), libFuzzer tries to guess; a good value based on the corpus (and reports it).; ``-len_control``; Try generating small inputs first, then try larger inputs over time.; Specifies the rate at which the length limit is increased (smaller == faster).; Default is 100. If 0, immediately try inputs with size up to max_len.; ``-timeout``; Timeout in seconds, default 1200. If an input takes longer than this timeout,; the process is treated as a failure case.; ``-rss_limit_mb``; Memory usage limit in Mb, default 2048. Use 0 to disable the limit.; If an input requires more than this amount of RSS memory to execute,; the process is treated as a failure case.; The limit is checked in a separate thread every second.; If running w/o ASAN/MSAN, you may use 'ulimit -v' instead.; ``-malloc_limit_mb``; If non-zero, the fuzzer will exit if the target tries to allocate this; number of Mb with one malloc call.; If zero (default) same limit as rss_limit_mb is applied",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:10346,test,test,10346,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['test'],['test']
Testability," 4 {TypeAlias} 'INTEGER' -> 'int'. (1) Added Types:; +[003] 4 {TypeAlias} 'INTEGER' -> 'int'. ----------------------------------------; Element Expected Missing Added; ----------------------------------------; Scopes 4 0 0; Symbols 0 0 0; Types 2 1 1; Lines 0 0 0; ----------------------------------------; Total 6 1 1. As the *Reference* and *Target* are switched, the *Added Types* from; the first case now are listed as *Missing Types*. TEST CASE 2 - ASSEMBLER INSTRUCTIONS; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The below example is used to show different output generated by; :program:`llvm-debuginfo-analyzer`. We compiled the example for an X86; Codeview and ELF targets with recent versions of Clang, GCC and MSVC; (-O0 -g) for Windows and Linux. .. code-block:: c++. 1 extern int printf(const char * format, ... );; 2; 3 int main(); 4 {; 5 printf(""Hello, World\n"");; 6 return 0;; 7 }. These are the logical views that :program:`llvm-debuginfo-analyzer`; generates for 3 different compilers (MSVC, Clang and GCC), emitting; different debug information formats (CodeView, DWARF) on Windows and; Linux. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format,producer; --print=lines,instructions; hello-world-codeview-clang.o; hello-world-codeview-msvc.o; hello-world-dwarf-clang.o; hello-world-dwarf-gcc.o. CodeView - Clang (Windows); ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: none. Logical View:; [000] {File} 'hello-world-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'hello-world.cpp'; [002] {Producer} 'clang version 14.0.0'; [002] {Function} extern not_inlined 'main' -> 'int'; [003] 4 {Line}; [003] {Code} 'subq	$0x28, %rsp'; [003] {Code} 'movl	$0x0, 0x24(%rsp)'; [003] 5 {Line}; [003] {Code} 'leaq	(%rip), %rcx'; [003] {Code} 'callq	0x0'; [003] 6 {Line}; [003] {Code} 'xorl	%eax, %eax'; [003] {Code} 'addq	$0x28, %rsp'; [003] {Code} 'retq'. CodeView - MSVC (Windows); ^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: none. Logical View:; [000] {File} 'hello-world-code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:33062,log,logical,33062,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['log'],['logical']
Testability," 8 bytes each. - ``Metadata Records``: Metadata records serve many purposes. Mostly, they; capture information that may be too costly to record for each function, but; that is required to contextualize the fine-grained timings. They also are used; as markers for user-defined Event Data payloads. Metadata records have 16; bytes each. - ``Event Data``: Free form data may be associated with events that are traced; by the binary and encode data defined by a handler function. Event data is; always preceded with a marker record which indicates how large it is. - ``Function Arguments``: The arguments to some functions are included in the; trace. These are either pointer addresses or primitives that are read and; logged independently of their types in a high level language. To the tracer,; they are all numbers. Function Records that have attached arguments will; indicate their presence on the function entry record. We only support logging; contiguous function argument sequences starting with argument zero, which will; be the ""this"" pointer for member function invocations. For example, we don't; support logging the first and third argument. A reader of the memory format must maintain a state machine. The format makes no; attempt to pad for alignment, and it is not seekable. Function Records; ----------------. Function Records have an 8 byte layout. This layout encodes information to; reconstruct a call stack of instrumented function and their durations. +---------------+--------------+-----------------------------------------------+; | Field | Size (bits) | Description |; +===============+==============+===============================================+; | discriminant | ``1`` | Indicates whether a reader should read a |; | | | Function or Metadata record. Set to ``0`` for |; | | | Function records. |; +---------------+--------------+-----------------------------------------------+; | action | ``3`` | Specifies whether the function is being |; | | | entered, exited, or is a no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayFDRFormat.rst:4509,log,logging,4509,interpreter/llvm-project/llvm/docs/XRayFDRFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayFDRFormat.rst,1,['log'],['logging']
Testability," : NSObject; + (void) releaseArg:(id) NS_CONSUMED x;; + (void) releaseSecondArg:(id)x second:(id) NS_CONSUMED y;; @end. void test_method() {; id x = [[NSObject alloc] init];; [Foo releaseArg:x]; // No leak!; }. void test_method2() {; id a = [[NSObject alloc] init];; id b = [[NSObject alloc] init];; [Foo releaseSecondArg:a second:b]; // 'a' is leaked, but 'b' is released.; }. Attribute 'cf_consumed'; (Clang-specific); The 'cf_consumed' attribute is practically identical to ns_consumed. The attribute can be placed on a; specific parameter in either the declaration of a function or an Objective-C; method. It indicates to the static analyzer that the object reference is; implicitly passed to a call to CFRelease upon completion of the call; to the given function or method. The CoreFoundation framework defines a macro; CF_RELEASES_ARGUMENT that is functionally equivalent to the; CF_CONSUMED macro shown below.; Operationally this attribute is nearly identical to 'ns_consumed'.; Example. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef CF_CONSUMED; #if __has_feature(attribute_cf_consumed); #define CF_CONSUMED __attribute__((cf_consumed)); #else; #define CF_CONSUMED; #endif; #endif. void consume_cf(id CF_CONSUMED x);; void consume_CFDate(CFDateRef CF_CONSUMED x);. void test() {; id x = [[NSObject alloc] init];; consume_cf(x); // No leak!; }. void test2() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; consume_CFDate(date); // No leak, including under GC!. }. @interface Foo : NSObject; + (void) releaseArg:(CFDateRef) CF_CONSUMED x;; @end. void test_method() {; CFDateRef date = CFDateCreate(0, CFAbsoluteTimeGetCurrent());; [Foo releaseArg:date]; // No leak!; }. Attribute 'ns_consumes_self'; (Clang-specific); The 'ns_consumes_self' attribute can be placed only on an Objective-C method; declaration. It indicates that the receiver of the message is; ""consumed"" (a single refer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:11585,test,test,11585,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['test'],['test']
Testability," ; CHECK-DAG: vmov.32 [[REG2]][1]; vmov.32 d0[1]; vmov.32 d0[0]. While this other code, will not:. .. code-block:: text. ; CHECK-DAG: vmov.32 [[REG2:d[0-9]+]][0]; ; CHECK-DAG: vmov.32 [[REG2]][1]; vmov.32 d1[1]; vmov.32 d0[0]. While this can be very useful, it's also dangerous, because in the case of; register sequence, you must have a strong order (read before write, copy before; use, etc). If the definition your test is looking for doesn't match (because; of a bug in the compiler), it may match further away from the use, and mask; real bugs away. In those cases, to enforce the order, use a non-DAG directive between DAG-blocks. A ``CHECK-DAG:`` directive skips matches that overlap the matches of any; preceding ``CHECK-DAG:`` directives in the same ``CHECK-DAG:`` block. Not only; is this non-overlapping behavior consistent with other directives, but it's; also necessary to handle sets of non-unique strings or patterns. For example,; the following directives look for unordered log entries for two tasks in a; parallel program, such as the OpenMP runtime:. .. code-block:: text. // CHECK-DAG: [[THREAD_ID:[0-9]+]]: task_begin; // CHECK-DAG: [[THREAD_ID]]: task_end; //; // CHECK-DAG: [[THREAD_ID:[0-9]+]]: task_begin; // CHECK-DAG: [[THREAD_ID]]: task_end. The second pair of directives is guaranteed not to match the same log entries; as the first pair even though the patterns are identical and even if the text; of the log entries is identical because the thread ID manages to be reused. The ""CHECK-LABEL:"" directive; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Sometimes in a file containing multiple tests divided into logical blocks, one; or more ``CHECK:`` directives may inadvertently succeed by matching lines in a; later block. While an error will usually eventually be generated, the check; flagged as causing the error may not actually bear any relationship to the; actual source of the problem. In order to produce better error messages in these cases, the ""``CHECK-LABEL:``""; directive ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:20773,log,log,20773,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['log'],['log']
Testability, <https://cmake.org/cmake/help/v3.13/generator/Ninja.html#fortran-support>`_; for details. * 503.bwaves_r/603.bwaves_s; * 507.cactuBSSN_r; * 521.wrf_r/621.wrf_s; * 527.cam4_r/627.cam4_s; * 628.pop2_s; * 548.exchange2_r/648.exchange2_s; * 549.fotonik3d_r/649.fotonik3d_s; * 554.roms_r/654.roms_s. SPEC OMP2012; ------------; https://www.spec.org/omp2012/. * 350.md; * 351.bwaves; * 352.nab; * 357.bt331; * 358.botsalgn; * 359.botsspar; * 360.ilbdc; * 362.fma3d; * 363.swim; * 367.imagick; * 370.mgrid331; * 371.applu331; * 372.smithwa; * 376.kdtree. OpenCV; ------; https://opencv.org/. OpenMP 4.x SIMD Benchmarks; --------------------------; https://github.com/flwende/simd_benchmarks. PWM-benchmarking; ----------------; https://github.com/tbepler/PWM-benchmarking. SLAMBench; ---------; https://github.com/pamela-project/slambench. FireHose; --------; http://firehose.sandia.gov/. A Benchmark for the C/C++ Standard Library; ------------------------------------------; https://github.com/hiraditya/std-benchmark. OpenBenchmarking.org CPU / Processor Suite; ------------------------------------------; https://openbenchmarking.org/suite/pts/cpu. This is a subset of the; `Phoronix Test Suite <https://github.com/phoronix-test-suite/phoronix-test-suite/>`_; and is itself a collection of benchmark suites. Parboil Benchmarks; ------------------; http://impact.crhc.illinois.edu/parboil/parboil.aspx. MachSuite; ---------; https://breagen.github.io/MachSuite/. Rodinia; -------; http://lava.cs.virginia.edu/Rodinia/download_links.htm. Rodinia has already been partially included in; MultiSource/Benchmarks/Rodinia. Benchmarks still missing are:. * streamcluster; * particlefilter; * nw; * nn; * myocyte; * mummergpu; * lud; * leukocyte; * lavaMD; * kmeans; * hotspot3D; * heartwall; * cfd; * bfs; * b+tree. vecmathlib tests harness; ------------------------; https://bitbucket.org/eschnett/vecmathlib/wiki/Home. PARSEC; ------; http://parsec.cs.princeton.edu/. Graph500 reference implementations; ----,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst:2200,benchmark,benchmark,2200,interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst,1,['benchmark'],['benchmark']
Testability," <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. * The taintedness property is not propagated through function calls which are; unknown (or too complex) to the analyzer, unless there is a specific; propagation rule built-in to the checker or given in the YAML configuration; file. This causes potential true positive findings to be lost. alpha.unix; ^^^^^^^^^^. .. _alpha-unix-BlockInCriticalSection:. alpha.unix.BlockInCriticalSection (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for calls to blocking functions inside a critical section.; Applies to: ``lock, unlock, sleep, getc, fgets, read, recv, pthread_mutex_lock,``; `` pthread_mutex_unlock, mtx_lock, mtx_timedlock, mtx_trylock, mtx_unlock, lock_guard, unique_lock``. .. code-block:: c. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();; }. .. _alpha-unix-Chroot:. alpha.unix.Chroot (C); """"""""""""""""""""""""""""""""""""""""""; Check improper use of chroot. .. code-block:: c. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. .. _alpha-unix-PthreadLock:. alpha.unix.PthreadLock (C); """"""""""""""""""""""""""""""""""""""""""""""""""""; Simple lock -> unlock checker.; Applies to: ``pthread_mutex_lock, pthread_rwlock_rdlock, pthread_rwlock_wrlock, lck_mtx_lock, lck_rw_lock_exclusive``; ``lck_rw_lock_shared, pthread_mutex_trylock, pthread_rwlock_tryrdlock, pthread_rwlock_tryrwlock, lck_mtx_try_lock,; lck_rw_try_lock_exclusive, lck_rw_try_lock_shared, pthread_mutex_unlock, pthread_rwlock_unlock, lck_mtx_unlock, lck_rw_done``. .. code-block:: c. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:74863,test,test,74863,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability," = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. osx.coreFoundation.containers.PointerSizedValues; (C); Warns if CFArray, CFDictionary, CFSet are; created with non-pointer-size values. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // warn; }. Security Checkers. Name, DescriptionExample. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:21623,test,test,21623,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability," A few developers in the community have dedicated time to validate the release; candidates and volunteered to be the official release testers for each; architecture. These will be the ones testing, generating and uploading the official binaries; to the server, and will be the minimum tests *necessary* for the release to; proceed. This will obviously not cover all OSs and distributions, so additional community; validation is important. However, if community input is not reached before the; release is out, all bugs reported will have to go on the next stable release. The official release managers are:. * Even releases: Tom Stellard (tstellar@redhat.com); * Odd releases: Tobias Hieta (tobias@hieta.se). The official release testers are volunteered from the community and have; consistently validated and released binaries for their targets/OSs. To contact; them, you should post on the `Discourse forums (Project; Infrastructure - Release Testers). <https://discourse.llvm.org/c/infrastructure/release-testers/66>`_. The official testers list is in the file ``RELEASE_TESTERS.TXT``, in the ``LLVM``; repository. Community Testing; -----------------. Once all testing has been completed and appropriate bugs filed, the release; candidate tarballs are put on the website and the LLVM community is notified. We ask that all LLVM developers test the release in any the following ways:. #. Download ``llvm-X.Y``, ``llvm-test-X.Y``, and the appropriate ``clang``; binary. Build LLVM. Run ``make check`` and the full LLVM test suite (``make; TEST=nightly report``). #. Download ``llvm-X.Y``, ``llvm-test-X.Y``, and the ``clang`` sources. Compile; everything. Run ``make check`` and the full LLVM test suite (``make; TEST=nightly report``). #. Download ``llvm-X.Y``, ``llvm-test-X.Y``, and the appropriate ``clang``; binary. Build whole programs with it (ex. Chromium, Firefox, Apache) for; your platform. #. Download ``llvm-X.Y``, ``llvm-test-X.Y``, and the appropriate ``clang``; binary. Build *your* ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:7821,test,testers,7821,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['test'],['testers']
Testability," A few notes about CMake Caches:. - Order of command line arguments is important. - -D arguments specified before -C are set before the cache is processed and; can be read inside the cache file; - -D arguments specified after -C are set after the cache is processed and; are unset inside the cache file. - All -D arguments will override cache file settings; - CMAKE_TOOLCHAIN_FILE is evaluated after both the cache file and the command; line arguments; - It is recommended that all -D options should be specified *before* -C. For more information about some of the advanced build configurations supported; via Cache files see :doc:`AdvancedBuilds`. Executing the Tests; ===================. Testing is performed when the *check-all* target is built. For instance, if you are; using Makefiles, execute this command in the root of your build directory:. .. code-block:: console. $ make check-all. On Visual Studio, you may run tests by building the project ""check-all"".; For more information about testing, see the :doc:`TestingGuide`. Cross compiling; ===============. See `this wiki page <https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/CrossCompiling>`_ for; generic instructions on how to cross-compile with CMake. It goes into detailed; explanations and may seem daunting, but it is not. On the wiki page there are; several examples including toolchain files. Go directly to the; ``Information how to set up various cross compiling toolchains`` section; for a quick solution. Also see the `LLVM-related variables`_ section for variables used when; cross-compiling. Embedding LLVM in your project; ==============================. From LLVM 3.5 onwards the CMake build system exports LLVM libraries as; importable CMake targets. This means that clients of LLVM can now reliably use; CMake to develop their own LLVM-based projects against an installed version of; LLVM regardless of how it was built. Here is a simple example of a CMakeLists.txt file that imports the LLVM libraries; and u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:40206,test,testing,40206,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['test'],['testing']
Testability," ABI breaking; change. ELF STUB FORMAT; ---------------. A minimum ELF file that can be used by linker should have following sections properly populated:. * ELF header. * Section headers. * Dynamic symbol table (``.dynsym`` section). * Dynamic string table (``.dynstr`` section). * Dynamic table (``.dynamic`` section). + ``DT_SYMTAB`` entry. + ``DT_STRTAB`` entry. + ``DT_STRSZ`` entry. + ``DT_NEEDED`` entries. (optional). + ``DT_SONAME`` entry. (optional). * Section header string table (``.shstrtab`` section). This ELF file may have compatibility issues with ELF analysis tools that rely on the program headers.; Linkers like LLD work fine with such a minimum ELF file without errors. OPTIONS; -------. .. option:: --input-format=[IFS|ELF|OtherObjectFileFormats]. Specify input file format. Currently, only text IFS files and ELF shared; object files are supported. This flag is optional as the input format can be; inferred. .. option:: --output-elf=<output-filename>. Specify the output file for ELF shared object stub. .. option:: --output-ifs=<output-filename>. Specify the output file for text IFS. .. option:: --output-tbd=<output-filename>. Specify the output file for Apple TAPI tbd. .. option:: --arch=[x86_64|AArch64|...]. This flag is optional and it should only be used when reading an IFS file; which does not define the ``Arch`` (architecture). This flag defines the; architecture of the output file, and can be any string supported by ELF; 'e_machine' field. If the value is conflicting with the IFS file, an error; will be reported and the program will stop. .. option:: --endianness=[little|big]. This flag is optional and it should only be used when reading an IFS file; which does not define the ``Endianness``. This flag defines the endianness of; the output file. If the value is conflicting with the IFS file, an error; will be reported and the program will stop. .. option:: --bitwidth=[32|64]. This flag is optional and it should only be used when reading an IFS file; wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ifs.rst:3702,stub,stub,3702,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ifs.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-ifs.rst,1,['stub'],['stub']
Testability," ABI is a work in progress. If you don't require MSVC ABI compatibility or don't; want to use Microsoft's C and C++ runtimes, the mingw32 toolchain might be a; better fit for your project. Second, Clang implements many MSVC language extensions, such as; ``__declspec(dllexport)`` and a handful of pragmas. These are typically; controlled by ``-fms-extensions``. Third, MSVC accepts some C++ code that Clang will typically diagnose as; invalid. When these constructs are present in widely included system headers,; Clang attempts to recover and continue compiling the user's program. Most; parsing and semantic compatibility tweaks are controlled by; ``-fms-compatibility`` and ``-fdelayed-template-parsing``, and they are a work; in progress. Finally, there is :ref:`clang-cl`, a driver program for clang that attempts to; be compatible with MSVC's cl.exe. ABI features; ============. The status of major ABI-impacting C++ features:. * Record layout: :good:`Complete`. We've tested this with a fuzzer and have; fixed all known bugs. * Class inheritance: :good:`Mostly complete`. This covers all of the standard; OO features you would expect: virtual method inheritance, multiple; inheritance, and virtual inheritance. Every so often we uncover a bug where; our tables are incompatible, but this is pretty well in hand. This feature; has also been fuzz tested. * Name mangling: :good:`Ongoing`. Every new C++ feature generally needs its own; mangling. For example, member pointer template arguments have an interesting; and distinct mangling. Fortunately, incorrect manglings usually do not result; in runtime errors. Non-inline functions with incorrect manglings usually; result in link errors, which are relatively easy to diagnose. Incorrect; manglings for inline functions and templates result in multiple copies in the; final image. The C++ standard requires that those addresses be equal, but few; programs rely on this. * Member pointers: :good:`Mostly complete`. Standard C++ member pointers a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:1617,test,tested,1617,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,1,['test'],['tested']
Testability," API under test.; Like this:. .. code-block:: c++. // fuzz_target.cc; extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {; DoSomethingInterestingWithMyAPI(Data, Size);; return 0; // Values other than 0 and -1 are reserved for future use.; }. Note that this fuzz target does not depend on libFuzzer in any way; and so it is possible and even desirable to use it with other fuzzing engines; e.g. AFL_ and/or Radamsa_. Some important things to remember about fuzz targets:. * The fuzzing engine will execute the fuzz target many times with different inputs in the same process.; * It must tolerate any kind of input (empty, huge, malformed, etc).; * It must not `exit()` on any input.; * It may use threads but ideally all threads should be joined at the end of the function.; * It must be as deterministic as possible. Non-determinism (e.g. random decisions not based on the input bytes) will make fuzzing inefficient.; * It must be fast. Try avoiding cubic or greater complexity, logging, or excessive memory consumption.; * Ideally, it should not modify any global state (although that's not strict).; * Usually, the narrower the target the better. E.g. if your target can parse several data formats, split it into several targets, one per format. Fuzzer Usage; ------------. Recent versions of Clang (starting from 6.0) include libFuzzer, and no extra installation is necessary. In order to build your fuzzer binary, use the `-fsanitize=fuzzer` flag during the; compilation and linking. In most cases you may want to combine libFuzzer with; AddressSanitizer_ (ASAN), UndefinedBehaviorSanitizer_ (UBSAN), or both. You can; also build with MemorySanitizer_ (MSAN), but support is experimental::. clang -g -O1 -fsanitize=fuzzer mytarget.c # Builds the fuzz target w/o sanitizers; clang -g -O1 -fsanitize=fuzzer,address mytarget.c # Builds the fuzz target with ASAN; clang -g -O1 -fsanitize=fuzzer,signed-integer-overflow mytarget.c # Builds the fuzz target with a part of UBSAN; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:2414,log,logging,2414,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['log'],['logging']
Testability," AddInputData and those found in the file defined bySetInputDataFile.  . Improvements:. More; complete set of tests in test/stressProof . To run with PROOF-Lite pass; the argument 'lite' as master URL, e.g. './stressProof lite'.Possibility; to control on the client via rc variable the location of the sandbox,; package directory, cache and dataset directory (the latters two only; for PROOF-Lite); the variable names are 'Proof.Sandbox', ; 'Proof.PackageDir', 'Proof.CacheDir' and 'Proof.DataSetDir'. The default location of the sandbox has been changed from ""~/proof"" to ""~/.proof"" to avoid interferences with possible users' working areas.XrdProofd plug-in. Overall refactorization for easier; maintainance and improved solidity; Improved format of printout messages: all information; messages contain now the tag 'xpd-I' and all error messages the; tag 'xpd-E', so that they can easily be grepped out from the; log file.; . Log sending. Implement selective sending of logs from workers to master to avoid duplicating; too many text lines on the master log. Logs are now sent only after Exec, Print; requests and in case an error (level >= kError) occured. Of course, the full; logs can always be retrieved via TProofMgr::GetSessionLogs; . Log retrieval:. for 'grep' operations, use the system 'grep' command; via 'popen'; instead of a handmade filtering; this implies that the full grep; functionality is now available; set the default number of displayed lines to 100; instead of 10. Improve diagnostic in case of worker death: clients will; now; receive a message containing the low level reason for the failure and a; hint for getting more informationIn; TProofOutputFile, support the ""<user>"" and ""<group>""; placeholders in the output file name to automatically re-direct the; output to an area specific to the logged user.; Addition of a new class TProofProgressStatus, which is used to keep; the query progress stauts in all the TProofPlayer objects and in the; TPacketizerAdaptive. It is a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:4792,log,logs,4792,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,2,['log'],"['log', 'logs']"
Testability," As you contribute code, this code will likely fix an issue or add a feature.; Whatever it is: this requires you to add a new test, or to extend an existing test. Depending on the size and complexity; of this test, it exists either in the `test/` subdirectory of each part of ROOT (see for instance; [`tree/dataframe/test`](https://github.com/root-project/root/tree/master/tree/dataframe/test)), or in; [roottest](https://github.com/root-project/roottest.git). Tests in `test/` subdirectories are unit tests, mostly based on; [Google Test](https://github.com/google/googletest) and easily extended. Tests in; [roottest](https://github.com/root-project/roottest.git) are more involved (e.g., tests requiring custom dictionaries or; data files). When you create a branch in the main ROOT repository (i.e., this repository) and add a test to `roottest`,; make sure to do this under the same branch name (and open a PR for it). Our CI infrastructure automatically picks up the; changes defined in the `roottest` PR based on this branch name, and uses that for testing your PR here. ## Continuous Integration. To prevent bad surprises and make a better first impression, we; strongly encourage new developers to [run the tests](https://root.cern/for_developers/run_the_tests/); _before_ submitting a pull request. ROOT has automated CI tests :cop: that are used for pull requests:; - *Build and test*: a [Jenkins-based CI workflow](https://github.com/phsft-bot/build-configuration/blob/master/README.md); as well as a GitHub Actions CI workflow tests PRs automatically; only a; [project member](https://github.com/orgs/root-project/people) is allowed to initiate this build.; The results are posted to the pull request.; Compared to ROOT's nightly builds, PRs are tested with less tests, on less platforms.; - *Formatting check*: `clang-format` automatically checks that a PR; [follows](https://github.com/root-project/root/blob/master/.clang-format) ROOT's; [coding conventions](https://root.cern/contrib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md:6460,test,testing,6460,CONTRIBUTING.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md,1,['test'],['testing']
Testability," Autoconf usage is deprecated as of 3.8. Building LLVM/Clang in ``Release`` mode is preferred since it consumes; a lot less memory. Otherwise, the building process will very likely; fail due to insufficient memory. It's also a lot quicker to only build; the relevant back-ends (ARM and AArch64), since it's very unlikely that; you'll use an ARM board to cross-compile to other arches. If you're; running Compiler-RT tests, also include the x86 back-end, or some tests; will fail. .. code-block:: bash. cmake $LLVM_SRC_DIR -DCMAKE_BUILD_TYPE=Release \; -DLLVM_TARGETS_TO_BUILD=""ARM;X86;AArch64"". Other options you can use are:. .. code-block:: bash. Use Ninja instead of Make: ""-G Ninja""; Build with assertions on: ""-DLLVM_ENABLE_ASSERTIONS=True""; Local (non-sudo) install path: ""-DCMAKE_INSTALL_PREFIX=$HOME/llvm/install""; CPU flags: ""DCMAKE_C_FLAGS=-mcpu=cortex-a15"" (same for CXX_FLAGS). After that, just typing ``make -jN`` or ``ninja`` will build everything.; ``make -jN check-all`` or ``ninja check-all`` will run all compiler tests. For; running the test suite, please refer to :doc:`TestingGuide`. #. If you are building LLVM/Clang on an ARM board with 1G of memory or less,; please use ``gold`` rather then GNU ``ld``. In any case it is probably a good; idea to set up a swap partition, too. .. code-block:: bash. $ sudo ln -sf /usr/bin/ld /usr/bin/ld.gold. #. ARM development boards can be unstable and you may experience that cores; are disappearing, caches being flushed on every big.LITTLE switch, and; other similar issues. To help ease the effect of this, set the Linux; scheduler to ""performance"" on **all** cores using this little script:. .. code-block:: bash. # The code below requires the package 'cpufrequtils' to be installed.; for ((cpu=0; cpu<`grep -c proc /proc/cpuinfo`; cpu++)); do; sudo cpufreq-set -c $cpu -g performance; done. Remember to turn that off after the build, or you may risk burning your; CPU. Most modern kernels don't need that, so only use it if you have; p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildOnARM.rst:1984,test,tests,1984,interpreter/llvm-project/llvm/docs/HowToBuildOnARM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildOnARM.rst,1,['test'],['tests']
Testability," BUILTINS Vc); target_include_directories(testVc SYSTEM BEFORE PRIVATE ${Vc_INCLUDE_DIRS}); ROOT_ADD_TEST(test-Vc COMMAND testVc FAILREGEX ""FAILED|Error in""); endif(). #--VecCore basic test------------------------------------------------------------------------------; if(ROOT_veccore_FOUND); ROOT_EXECUTABLE(test-veccore test-veccore.cxx LIBRARIES ${VecCore_LIBRARIES} BUILTINS VECCORE); target_include_directories(test-veccore BEFORE PRIVATE ${VecCore_INCLUDE_DIRS}); target_compile_definitions(test-veccore PRIVATE ${VecCore_DEFINITIONS}); if(VecCore_Vc_FOUND); ROOT_ADD_TEST(VecCore COMMAND test-veccore REGEX ""Vc""); else(); ROOT_ADD_TEST(VecCore COMMAND test-veccore REGEX ""Scalar""); endif(); endif(). #--Vc GenVector test-----------------------------------------------------------------------------------; if(ROOT_vc_FOUND); ROOT_EXECUTABLE(testGenVectorVc testGenVectorVc.cxx LIBRARIES Physics GenVector ${Vc_LIBRARIES} BUILTINS Vc); target_include_directories(testGenVectorVc SYSTEM BEFORE PRIVATE ${Vc_INCLUDE_DIRS}); ROOT_ADD_TEST(test-GenVector-Vc COMMAND testGenVectorVc FAILREGEX ""FAILED|Error in""); endif(). #--g2root------------------------------------------------------------------------------------------; if(TARGET g2root); ROOT_ADD_TEST(test-g2root COMMAND g2root); endif(). #--periodic----------------------------------------------------------------------------------------; if (NOT cxxmodules); # There are two problems with this test and cxxmodules. First, it picks up a; # header files from $ROOTSYS/include and builds a library. Naturally, we should; # build pcm files, however, building module MathCore requires specific -I to; # build the needed VecCore and Vc components. This test does not have access; # to the include relevant include paths. Secondly, if we want to reuse the; # modules from ROOT which makes most sense we can't because we get a hard; # error such as: fatal error: malformed or corrupted AST file:; # 'SourceLocation remap refers to unknown module, cann",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/CMakeLists.txt:18892,test,testGenVectorVc,18892,test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/CMakeLists.txt,3,['test'],"['test-GenVector-Vc', 'testGenVectorVc']"
Testability," Benchmarks; ------------------; http://impact.crhc.illinois.edu/parboil/parboil.aspx. MachSuite; ---------; https://breagen.github.io/MachSuite/. Rodinia; -------; http://lava.cs.virginia.edu/Rodinia/download_links.htm. Rodinia has already been partially included in; MultiSource/Benchmarks/Rodinia. Benchmarks still missing are:. * streamcluster; * particlefilter; * nw; * nn; * myocyte; * mummergpu; * lud; * leukocyte; * lavaMD; * kmeans; * hotspot3D; * heartwall; * cfd; * bfs; * b+tree. vecmathlib tests harness; ------------------------; https://bitbucket.org/eschnett/vecmathlib/wiki/Home. PARSEC; ------; http://parsec.cs.princeton.edu/. Graph500 reference implementations; ----------------------------------; https://github.com/graph500/graph500/tree/v2-spec. NAS Parallel Benchmarks; -----------------------; https://www.nas.nasa.gov/publications/npb.html. The official benchmark is written in Fortran, but an unofficial; C-translation is available as well:; https://github.com/benchmark-subsetting/NPB3.0-omp-C. DARPA HPCS SSCA#2 C/OpenMP reference implementation; ---------------------------------------------------; http://www.highproductivity.org/SSCABmks.htm. This web site does not exist any more, but there seems to be a copy of; some of the benchmarks; https://github.com/gtcasl/hpc-benchmarks/tree/master/SSCA2v2.2. Kokkos; ------; https://github.com/kokkos/kokkos-kernels/tree/master/perf_test; https://github.com/kokkos/kokkos/tree/master/benchmarks. PolyMage; --------; https://github.com/bondhugula/polymage-benchmarks. PolyBench; ---------; https://sourceforge.net/projects/polybench/. A modified version of Polybench 3.2 is already presented in; SingleSource/Benchmarks/Polybench. A newer version 4.2.1 is available. High Performance Geometric Multigrid; ------------------------------------; https://crd.lbl.gov/departments/computer-science/PAR/research/hpgmg/. RAJA Performance Suite; ----------------------; https://github.com/LLNL/RAJAPerf. CORAL-2 Benchmarks; ---------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst:3498,benchmark,benchmark-subsetting,3498,interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/TestSuite.rst,1,['benchmark'],['benchmark-subsetting']
Testability," Build whole programs with it (ex. Chromium, Firefox, Apache) for; your platform. #. Download ``llvm-X.Y``, ``llvm-test-X.Y``, and the appropriate ``clang``; binary. Build *your* programs with it and check for conformance and; performance regressions. #. Run the :doc:`release process <ReleaseProcess>`, if your platform is; *different* than that which is officially supported, and report back errors; only if they were not reported by the official release tester for that; architecture. We also ask that the OS distribution release managers test their packages with; the first candidate of every release, and report any *new* errors in GitHub.; If the bug can be reproduced with an unpatched upstream version of the release; candidate (as opposed to the distribution's own build), the priority should be; release blocker. During the first round of testing, all regressions must be fixed before the; second release candidate is tagged. In the subsequent stages, the testing is only to ensure that bug; fixes previously merged in have not created new major problems. *This is not; the time to solve additional and unrelated bugs!* If no patches are merged in,; the release is determined to be ready and the release manager may move onto the; next stage. Reporting Regressions; ---------------------. Every regression that is found during the tests (as per the criteria above),; should be filled in a bug in GitHub and added to the release milestone. If a bug can't be reproduced, or stops being a blocker, it should be removed; from the Milestone. Debugging can continue, but on trunk. Backport Requests; -----------------. Instructions for requesting a backport to a stable branch can be found :doc:`here <GitHub>`. Triaging Bug Reports for Releases; ---------------------------------. This section describes how to triage bug reports:. #. Search for bugs with a Release Milestone that have not been added to the; ""Release Status"" github project:. https://github.com/llvm/llvm-project/issues?q=is%3Ai",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:9601,test,testing,9601,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['test'],['testing']
Testability," C &c) {; i = c.i;; throw 1; // warn; j = c.j;; };; };. class C {; public:; int i, j;; C &operator=(const C &c) {; i = c.i;; throw 1; // warn; j = c.j;; };; };. undefbehavior.ValarrayArgBound; (C++); Undefined behavior: the value of the n argument passed; to valarray constructor is greater than the number of values; pointed to by the first argument (source).; Source: C++03 26.3.2.1p4; C++11 26.6.2.2p4. #include <valarray>. struct S {; int i;; S(int ii) : i(ii) {};; };. void test(void) {; S s[] = { S(1), S(2) };; std::valarray<S> v(s,3); // warn; }. undefbehavior.ValarrayLengthDiffer; (C++); Undefined behavior: valarray operands are of different length.; Source: C++03 26.3.2.2p1, 26.3.2.6p3, 26.3.3.1p3, 26.3.3.2p3;; C++11 defined (26.6.2.3p1), 26.6.2.7p3, 26.6.3.1p3,; 26.6.3.2p3. // C++03; #include <valarray>. void test(void) {; std::valarray<int> a(0, 1), b(0, 2);; a = b; // warn; b.resize(1);; a = b; // ok; }. // C++03, C++11; #include <valarray>. void test(void) {; std::valarray<int> a(0, 1), b(0, 2);; a *= b; // warn; }. // C++03, C++11; #include <valarray>. void test(void) {; std::valarray<int> a(0, 1), b(0, 2);; a = a + b; // warn; }. // C++03, C++11; #include <valarray>. void test(void) {; std::valarray<int> a(0, 1), b(0, 2);; std::valarray<bool> c(false, 1);; c = a == b; // warn; }. undefbehavior.ValarrayZeroLength; (C++); Undefined behavior: calling sum()/min()/; max() methods of a zero length valarray the behavior is; undefined.; Source: C++03 26.3.2.7p2, p3, p4; C++11 26.6.2.8p5, p6,; p7. #include <valarray>. void test(void) {; std::valarray<int> v(0, 0);; v.sum(); // warn; }. undefbehavior.ValarrayBadIndirection; (C++); Undefined behavior: element is specified more than once in an indirection.; Source: C++03 26.3.9.2p2, 26.3.9.3p2; C++11 26.6.9.2p2,; 26.6.9.3p2. #include <valarray>. void test() {; // '1' is specified more then once; size_t addr[] = {0, 1, 1};; std::valarray<size_t>indirect(addr, 3);; std::valarray<int> a(0, 5), b(1, 3);; a[indirect] = b; /",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:16282,test,test,16282,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability," C++03 20.4.5p1; C++11 auto_ptr is deprecated (D.10). #include <stdlib.h>; #include <memory>. void test() {; std::auto_ptr<int> p1(new int); // Ok; std::auto_ptr<int> p2(new int[3]); // warn; }. #include <stdlib.h>; #include <memory>. void test() {; std::auto_ptr<int> p((int *)malloc(sizeof(int))); // warn; }. dead code. Name, DescriptionExampleProgress. deadcode.UnmodifiedVariable; (C, C++); A variable is never modified but was not declared const and is not a; reference.(opt-in checker). extern int computeDelta();. int test(bool cond) {; int i = 0;; if (cond) {; const int delta = computeDelta();; // warn: forgot to modify 'i'; }; return i;; }. PR16890. deadcode.IdempotentOperations; (C); Warn about idempotent operations. void test() {; int x = 7;; x = x; // warn: value is always the same; }. void test() {; int x = 7;; x /= x; // warn: value is always 1; }. void test() {; int x = 7, one = 1;; x *= one; // warn: right op is always 1; }. void test() {; int x = 7, zero = 0;; x = x - zero;; // warn: the right operand to '-' is always 0; }. removed from alpha.deadcode.* at; r198476. POSIX. Name, DescriptionExampleProgress. posix.Errno; (C); Record that errno is non-zero when certain functions; fail. #include <stdlib.h>. int readWrapper(int fd, int *count) {; int lcount = read(fd, globalBuf, sizeof(globalBuf));; if (lcount < 0); return errno;; *count = lcount;; return 0;; }. void use(int fd) {; int count;; if (!readWrapper(fd, &count)); print(""%d"", count); // should not warn; }. PR18701. undefined behavior. Name, DescriptionExampleProgress. undefbehavior.ExitInDtor; (C++); Undefined behavior: std::exit() is called to end the program during; the destruction of an object with static storage duration.; Source: C++11 3.6.1p4. #include <cstdlib>. class A {; public:; ~A() {; std::exit(1); // warn; }; };. undefbehavior.LocalStaticDestroyed; (C++); Undefined behavior: function containing a definition of static local object is; called during the destruction of an object with stati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:4781,test,test,4781,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability," C++23; Fix for ""needed for constant evaluation""; Unknown. 2648; C++23; Correspondence of surrogate call function and conversion function; Unknown. 2649; C++23; Incorrect note about implicit conversion sequence; Unknown. 2650; C++23; Incorrect example for ill-formed non-type template arguments; Clang 17. 2651; C++23; Conversion function templates and ""noexcept""; Unknown. 2652; C++23; Overbroad definition of __STDCPP_BFLOAT16_T__; Unknown. 2653; C++23; Can an explicit object parameter have a default argument?; Clang 18. 2654; C++23; Un-deprecation of compound volatile assignments; Clang 16. 2655; NAD; Instantiation of default arguments in lambda-expressions; Unknown. 2656; drafting; Converting consteval lambda to function pointer in non-immediate context; Not resolved. 2657; tentatively ready; Cv-qualification adjustment when binding reference to temporary; Unknown. 2658; C++23; Trivial copying of unions in core constant expressions; Unknown. 2659; C++23; Missing feature-test macro for lifetime extension in range-for loop; Unknown. 2660; open; Confusing term ""this parameter""; Not resolved. 2661; open; Missing disambiguation rule for pure-specifier vs. brace-or-equal-initializer; Not resolved. 2662; C++23; Example for member access control vs. overload resolution; Unknown. 2663; DRWP; Example for member redeclarations with using-declarations; Unknown. 2664; C++23; Deduction failure in CTAD for alias templates; Unknown. 2665; NAD; Replacing a subobject with a complete object; Unknown. 2666; open; Lifetime extension through static_cast; Not resolved. 2667; C++23; Named module imports do not import macros; Unknown. 2668; tentatively ready; co_await in a lambda-expression; Unknown. 2669; open; Lifetime extension for aggregate initialization; Not resolved. 2670; open; Programs and translation units; Not resolved. 2671; open; friend named by a template-id; Not resolved. 2672; DR; Lambda body SFINAE is still required, contrary to intent and note; Clang 18. 2673; C++23; User-d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:183392,test,test,183392,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['test'],['test']
Testability," C;; return static_cast<A*>(b); // warn; }. #include <new>. class A {; public:; ~A();; };. class B : public A {};. class C {};. A* test() {; B *b = new B;; new(b) C;; return dynamic_cast<A*>(b); // warn; }. undefbehavior.ObjLocChanges; (C++); Undefined behavior: the program must ensure that an object occupies the same; storage location when the implicit or explicit destructor call takes place.; Source: C++11 3.8p8. #include <new>. class A {};. class B {; public:; ~B();; };. void test() {; B b;; new (&b) A;; } // warn. #include <new>. class A {};. class B {; public:; ~B();; };. void test() {; B *b = new B;; new (b) A;; delete b; // warn; }. undefbehavior.ExprEvalOrderUndef; (C, C++03); Undefined behavior: a scalar object shall have its stored value modified at; most once by the evaluation of an expression.; Note: most cases are currently handled by the Clang core (search for 'multiple; unsequenced modifications' warning in Clang tests).; Source: C++03 5p4. int test () {; int i = 0;; i = ++i + 1; // warn; return i;; }. undefbehavior.StaticInitReentered; (C++); Undefined behavior: static declaration is re-entered while the object is being; initialized.; Source: C++11 6.7p4. int test(int i) {; static int s = test(2 * i); // warn; return i + 1;; }. undefbehavior.ConstModified; (C, C++); Undefined behavior: const object is being modified.; Source: C++03 7.1.5.1p4, C++11 7.1.6.1p4. void test() {; const int *cp = new const int (0);; int *p = const_cast<int *>(cp);; *p = 1; // warn; delete p;; }. class C {; public :; int i;; C();; };. void test() {; const C cb;. C* cp = const_cast<C *>(&cb);; cp->i = 1; // warn; }. undefbehavior.DeadDestructed; (C++); Undefined behavior: the destructor is invoked for an object whose lifetime; has ended.; Source: C++11 12.4p14. class A {; public:; void f();; A();; ~A();; };. void test() {; A a;; a.~A();; } // warn. undefbehavior.MethodCallBeforeBaseInit; (C++); Undefined behavior: calls member function but base not yet initialized.; Source: C+",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:8800,test,test,8800,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability," CMAKE_CXX_FLAGS_RELWITHDEBINFO ""${CMAKE_CXX_FLAGS_RELWITHDEBINFO}""); endif(); # replace dashes in the -EH* and -GR* flags with slashes (/EH* /GR*); string(REPLACE "" -EH"" "" /EH"" CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS}""); string(REPLACE "" -GR"" "" /GR"" CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS}""); set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} /ignore:4049,4206,4217,4221""); set(CMAKE_SHARED_LINKER_FLAGS ""${CMAKE_SHARED_LINKER_FLAGS} /ignore:4049,4206,4217,4221""); set(CMAKE_MODULE_LINKER_FLAGS ""${CMAKE_MODULE_LINKER_FLAGS} /ignore:4049,4206,4217,4221""); endif(). set(LLVM_TARGETS_TO_BUILD ${ROOT_CLING_TARGET} CACHE STRING ""Semicolon-separated list of targets to build, or \""all\"".""). if(clingtest); message(""-- cling test suite enabled: llvm / clang symbols in libCling will be visible!""); set(CLING_INCLUDE_TESTS ON CACHE BOOL """" FORCE); # The path to cling passed through environment variable only relevant when building; # against external llvm. In that case, cling's testsuite cannot deduce the binary; # of cling relatively to the llvm tools folder.; if (NOT builtin_llvm); set(CLINGTEST_EXECUTABLE CLING=${CMAKE_CURRENT_BINARY_DIR}/llvm-project/llvm/${CMAKE_CFG_INTDIR}/bin/cling); endif(); ROOT_ADD_TEST(clingtest-check-cling COMMAND ${CMAKE_COMMAND} --build ${CMAKE_BINARY_DIR} --target check-cling; ENVIRONMENT ${CLINGTEST_EXECUTABLE}); else(); #---Build LLVM/Clang with symbol visibility=hidden--------------------------------------------------; set(CMAKE_CXX_VISIBILITY_PRESET hidden); set(CMAKE_C_VISIBILITY_PRESET hidden); endif(); if (NOT MSVC AND NOT APPLE); # Requires the linker to resolve the symbol internally and prevents; # conflicts when linked with another software using also LLVM like in; # the problem reported for Julia in; # https://github.com/JuliaHEP/ROOT.jl/issues/17#issuecomment-882719292; # Only needed for Linux: Mac uses linker namespaces and Windows explicit export/import; string(APPEND CMAKE_SHARED_LINKER_FLAGS "" -Wl,-Bsymbolic""); ROOT_ADD_CXX_FLAG(CMAKE_CXX_FL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:6655,test,testsuite,6655,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['test'],['testsuite']
Testability, COMMAND testDerivativesCpu). # DNN - Backpropagation CPU; ROOT_EXECUTABLE(testBackpropagationCpu TestBackpropagationCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Backpropagation-Cpu COMMAND testBackpropagationCpu). # DNN - BackpropagationDL CPU; ROOT_EXECUTABLE(testBackpropagationDLCpu TestBackpropagationDLCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Backpropagation-DL-Cpu COMMAND testBackpropagationDLCpu). # DNN - Batch normalization; ROOT_EXECUTABLE(testBatchNormalizationCpu TestBatchNormalizationCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-BatchNormalization-Cpu COMMAND testBatchNormalizationCpu). # DNN - Optimization CPU; ROOT_EXECUTABLE(testOptimizationCpu TestOptimizationCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Optimization-Cpu COMMAND testOptimizationCpu). # DNN - MethodDL SGD Optimization CPU; ROOT_EXECUTABLE(testMethodDLSGDOptimizationCpu TestMethodDLSGDOptimizationCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-MethodDL-SGD-Optimization-Cpu COMMAND testMethodDLSGDOptimizationCpu). # DNN - MethodDL Adam Optimization CPU; ROOT_EXECUTABLE(testMethodDLAdamOptimizationCpu TestMethodDLAdamOptimizationCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-MethodDL-Adam-Optimization-Cpu COMMAND testMethodDLAdamOptimizationCpu TIMEOUT 1800). # DNN - MethodDL Adagrad Optimization CPU; ROOT_EXECUTABLE(testMethodDLAdagradOptimizationCpu TestMethodDLAdagradOptimizationCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-MethodDL-Adagrad-Optimization-Cpu COMMAND testMethodDLAdagradOptimizationCpu). # DNN - MethodDL RMSProp Optimization CPU; ROOT_EXECUTABLE(testMethodDLRMSPropOptimizationCpu TestMethodDLRMSPropOptimizationCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-MethodDL-RMSProp-Optimization-Cpu COMMAND testMethodDLRMSPropOptimizationCpu). # DNN - MethodDL Adadelta Optimization CPU; ROOT_EXECUTABLE(testMethodDLAdadeltaOptimizationCpu TestMethodDLAdadeltaOptimizationCpu.cxx LIBRARIES ${Libraries});,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt:5755,test,testMethodDLSGDOptimizationCpu,5755,tmva/tmva/test/DNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt,1,['test'],['testMethodDLSGDOptimizationCpu']
Testability, CUDA::cudart). set(DNN_CUDA_LIBRARIES ${CUDA_CUBLAS_LIBRARIES} ). add_executable(testIm2ColCuda TestIm2ColCuda.cxx); target_link_libraries(testIm2ColCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-Im2ColCuda COMMAND testIm2ColCuda). add_executable(testPoolingLayerCuda TestPoolingLayerCuda.cxx); target_link_libraries(testPoolingLayerCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-PoolingLayerCuda COMMAND testPoolingLayerCuda). add_executable(testReshapeCuda TestReshapeCuda.cxx); target_link_libraries(testReshapeCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ReshapeCuda COMMAND testReshapeCuda). add_executable(testConvLayerCuda TestConvLayerCuda.cxx); target_link_libraries(testConvLayerCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ConvLayerCuda COMMAND testConvLayerCuda). add_executable(testForwardPassCuda TestForwardPassCuda.cxx); target_link_libraries(testForwardPassCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ForwardCuda COMMAND testForwardPassCuda). add_executable(testRotateWeightsCuda TestRotateWeightsCuda.cxx); target_link_libraries(testRotateWeightsCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-RotateWeightsCuda COMMAND testRotateWeightsCuda). add_executable(testConvBackpropagationCuda TestConvBackpropagationCuda.cxx); target_link_libraries(testConvBackpropagationCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ConvBackpropagationCuda COMMAND testConvBackpropagationCuda). if (tmva-cudnn). add_executable(testForwardPassCudnn TestForwardPassCudnn.cxx); target_link_libraries(testForwardPassCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ForwardCudnn COMMAND testForwardPassCudnn). add_executable(testConvBackpropagationCudnn TestConvBackpropagationCudnn.cxx); target_link_libraries(testConvBackpropagationCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ConvBackpropagationCud,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt:1509,test,testForwardPassCuda,1509,tmva/tmva/test/DNN/CNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt,2,['test'],['testForwardPassCuda']
Testability," Controlling implementation limits; ---------------------------------. .. option:: -fopenmp-use-tls. Controls code generation for OpenMP threadprivate variables. In presence of; this option all threadprivate variables are generated the same way as thread; local variables, using TLS support. If `-fno-openmp-use-tls`; is provided or target does not support TLS, code generation for threadprivate; variables relies on OpenMP runtime library. .. _opencl:. OpenCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl; $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. Compiling to bitcode can be done as follows:. .. code-block:: console. $ clang -c -emit-llvm test.cl. This will produce a file `test.bc` that can be used in vendor toolchains; to perform machine code generation. Note that if compiled to bitcode for generic targets such as SPIR/SPIR-V,; portable IR is produced that can be used with various vendor; tools as well as open source tools such as `SPIRV-LLVM Translator; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_; to produce SPIR-V binary. More details are provided in `the offline; compilation from OpenCL kernel sources into SPIR-V using open source; tools; <https://github.com/KhronosGroup/OpenCL-Guide/blob/main/chapters/os_tooling.md>`_.; From clang 1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:140926,test,test,140926,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['test'],['test']
Testability," DistributionExample CMake cache file located at; clang/cmake/caches/DistributionExample.cmake. The following command will perform; and install the distribution build:. .. code-block:: console. $ cmake -G Ninja -C <path to clang>/cmake/caches/DistributionExample.cmake <path to LLVM source>; $ ninja stage2-distribution; $ ninja stage2-install-distribution. Difference between ``install`` and ``install-distribution``; -----------------------------------------------------------. One subtle but important thing to note is the difference between the ``install``; and ``install-distribution`` targets. The ``install`` target is expected to; install every part of LLVM that your build is configured to generate except the; LLVM testing tools. Alternatively the ``install-distribution`` target, which is; recommended for building distributions, only installs specific parts of LLVM as; specified at configuration time by *LLVM_DISTRIBUTION_COMPONENTS*. Additionally by default the ``install`` target will install the LLVM testing; tools as the public tools. This can be changed well by setting; *LLVM_INSTALL_TOOLCHAIN_ONLY* to ``On``. The LLVM tools are intended for; development and testing of LLVM, and should only be included in distributions; that support LLVM development. When building with *LLVM_DISTRIBUTION_COMPONENTS* the build system also; generates a ``distribution`` target which builds all the components specified in; the list. This is a convenience build target to allow building just the; distributed pieces without needing to build all configured targets. .. _Multi-distribution configurations:. Multi-distribution configurations; ---------------------------------. The ``install-distribution`` target described above is for building a single; distribution. LLVM's build system also supports building multiple distributions,; which can be used to e.g. have one distribution containing just tools and; another for libraries (to enable development). These are configured by setting; the *",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:3603,test,testing,3603,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['test'],['testing']
Testability," Do not treat the specified tests as ``XFAIL``. The environment variable; ``LIT_XFAIL_NOT`` can also be used in place of this option. The syntax is the; same as for :option:`--xfail` and ``LIT_XFAIL``. :option:`--xfail-not` and; ``LIT_XFAIL_NOT`` always override all other ``XFAIL`` specifications,; including an :option:`--xfail` appearing later on the command line. The; primary purpose is to suppress an ``XPASS`` result without modifying a test; case that uses the ``XFAIL`` directive. ADDITIONAL OPTIONS; ------------------. .. option:: --debug. Run :program:`lit` in debug mode, for debugging configuration issues and; :program:`lit` itself. .. option:: --show-suites. List the discovered test suites and exit. .. option:: --show-tests. List all of the discovered tests and exit. EXIT STATUS; -----------. :program:`lit` will exit with an exit code of 1 if there are any FAIL or XPASS; results. Otherwise, it will exit with the status 0. Other exit codes are used; for non-test related failures (for example a user error or an internal program; error). .. _test-discovery:. TEST DISCOVERY; --------------. The inputs passed to :program:`lit` can be either individual tests, or entire; directories or hierarchies of tests to run. When :program:`lit` starts up, the; first thing it does is convert the inputs into a complete list of tests to run; as part of *test discovery*. In the :program:`lit` model, every test must exist inside some *test suite*.; :program:`lit` resolves the inputs specified on the command line to test suites; by searching upwards from the input path until it finds a :file:`lit.cfg` or; :file:`lit.site.cfg` file. These files serve as both a marker of test suites; and as configuration files which :program:`lit` loads in order to understand; how to find and run the tests inside the test suite. Once :program:`lit` has mapped the inputs into test suites it traverses the; list of inputs adding tests for individual files and recursively searching for; tests in directori",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:10859,test,test,10859,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['test']
Testability," Either set LLVM_INCLUDE_UTILS to On, or set LLVM_INCLUDE_TESTS to Off.""); endif(); endif(). # Use LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION instead of LLVM_INCLUDE_UTILS because it is not really a util; if (LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION); add_subdirectory(utils/LLVMVisualizers); endif(). foreach( binding ${LLVM_BINDINGS_LIST} ); if( EXISTS ""${LLVM_MAIN_SRC_DIR}/bindings/${binding}/CMakeLists.txt"" ); add_subdirectory(bindings/${binding}); endif(); endforeach(). add_subdirectory(projects). if( LLVM_INCLUDE_TOOLS ); add_subdirectory(tools); endif(). if( LLVM_INCLUDE_RUNTIMES ); add_subdirectory(runtimes); endif(). if( LLVM_INCLUDE_EXAMPLES ); add_subdirectory(examples); endif(). if( LLVM_INCLUDE_TESTS ); set(LLVM_GTEST_RUN_UNDER; """" CACHE STRING; ""Define the wrapper program that LLVM unit tests should be run under.""); if(EXISTS ${LLVM_MAIN_SRC_DIR}/projects/test-suite AND TARGET clang); include(LLVMExternalProjectUtils); llvm_ExternalProject_Add(test-suite ${LLVM_MAIN_SRC_DIR}/projects/test-suite; USE_TOOLCHAIN; EXCLUDE_FROM_ALL; NO_INSTALL; ALWAYS_CLEAN); endif(); add_subdirectory(utils/lit); add_subdirectory(test); add_subdirectory(unittests). if (WIN32); # This utility is used to prevent crashing tests from calling Dr. Watson on; # Windows.; add_subdirectory(utils/KillTheDoctor); endif(). umbrella_lit_testsuite_end(check-all); get_property(LLVM_ALL_LIT_DEPENDS GLOBAL PROPERTY LLVM_ALL_LIT_DEPENDS); get_property(LLVM_ALL_ADDITIONAL_TEST_DEPENDS; GLOBAL PROPERTY LLVM_ALL_ADDITIONAL_TEST_DEPENDS); add_custom_target(test-depends; DEPENDS ${LLVM_ALL_LIT_DEPENDS} ${LLVM_ALL_ADDITIONAL_TEST_DEPENDS}); set_target_properties(test-depends PROPERTIES FOLDER ""Tests""); add_dependencies(check-all test-depends); endif(). if (LLVM_INCLUDE_DOCS); add_subdirectory(docs); endif(). add_subdirectory(cmake/modules). # Do this last so that all lit targets have already been created.; if (LLVM_INCLUDE_UTILS); add_subdirectory(utils/llvm-lit); endif(). if (NOT LLVM_INSTALL_TOOLCHAIN_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:50457,test,test-suite,50457,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,4,['test'],"['test', 'test-suite']"
Testability," FILE:test.elf 0x400490; DATA BUILDID:123456789abcdef 0x601028. $ llvm-symbolizer < addr3.txt; baz(); /tmp/test.cpp:11:0. bar; 6295592 4. Example 5 - CODE and DATA prefixes:. .. code-block:: console. $ llvm-symbolizer --obj=test.elf ""CODE 0x400490"" ""DATA 0x601028""; baz(); /tmp/test.cpp:11:0. bar; 6295592 4. $ cat addr4.txt; CODE test.elf 0x4004a0; DATA inlined.elf 0x601028. $ llvm-symbolizer < addr4.txt; main; /tmp/test.cpp:15:0. bar; 6295592 4. Example 6 - path-style options:. This example uses the same source file as above, but the source file's; full path is /tmp/foo/test.cpp and is compiled as follows. The first case; shows the default absolute path, the second --basenames, and the third; shows --relativenames. .. code-block:: console. $ pwd; /tmp; $ clang -g foo/test.cpp -o test.elf; $ llvm-symbolizer --obj=test.elf 0x4004a0; main; /tmp/foo/test.cpp:15:0; $ llvm-symbolizer --obj=test.elf 0x4004a0 --basenames; main; test.cpp:15:0; $ llvm-symbolizer --obj=test.elf 0x4004a0 --relativenames; main; foo/test.cpp:15:0. Example 7 - Addresses as symbol names:. .. code-block:: console. $ llvm-symbolizer --obj=test.elf main; main; /tmp/test.cpp:14:0; $ llvm-symbolizer --obj=test.elf ""CODE foz""; foz; /tmp/test.h:1:0. OPTIONS; -------. .. option:: --adjust-vma <offset>. Add the specified offset to object file addresses when performing lookups.; This can be used to perform lookups as if the object were relocated by the; offset. .. option:: --basenames, -s. Print just the file's name without any directories, instead of the; absolute path. .. option:: --build-id. Look up the object using the given build ID, specified as a hexadecimal; string. Mutually exclusive with :option:`--obj`. .. option:: --color [=<always|auto|never>]. Specify whether to use color in :option:`--filter-markup` mode. Defaults to; ``auto``, which detects whether standard output supports color. Specifying; ``--color`` alone is equivalent to ``--color=always``. .. option:: --debug-file-directory <path>. Provi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst:4554,test,test,4554,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,1,['test'],['test']
Testability," FIXME: these directions are outdated and won't work. Figure out; what the correct thing to do is, and write it down here. #. Configure and build ``llvm``. #. Configure and build ``llvm-gcc``. #. Install ``llvm-gcc`` somewhere. #. *Re-configure* ``llvm`` from the top level of each build tree (LLVM; object directory tree) in which you want to run the test suite, just; as you do before building LLVM. During the *re-configuration*, you must either: (1) have ``llvm-gcc``; you just built in your path, or (2) specify the directory where your; just-built ``llvm-gcc`` is installed using; ``--with-llvmgccdir=$LLVM_GCC_DIR``. You must also tell the configure machinery that the test suite is; available so it can be configured for your build tree:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT ; $LLVM_SRC_ROOT/configure [--with-llvmgccdir=$LLVM_GCC_DIR]. [Remember that ``$LLVM_GCC_DIR`` is the directory where you; *installed* llvm-gcc, not its src or obj directory.]. #. You can now run the test suite from your build tree as follows:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT/projects/test-suite; % make. Note that the second and third steps only need to be done once. After; you have the suite checked out and configured, you don't need to do it; again (unless the test code or configure script changes). Configuring External Tests; ==========================. In order to run the External tests in the ``test-suite`` module, you; must specify *--with-externals*. This must be done during the; *re-configuration* step (see above), and the ``llvm`` re-configuration; must recognize the previously-built ``llvm-gcc``. If any of these is; missing or neglected, the External tests won't work. * *--with-externals*. * *--with-externals=<directory>*. This tells LLVM where to find any external tests. They are expected to; be in specifically named subdirectories of <``directory``>. If; ``directory`` is left unspecified, ``configure`` uses the default value; ``/home/vadve/shared/benchmarks/speccpu2000/be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:1552,test,test,1552,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,1,['test'],['test']
Testability," Fidelity; --------------------. So far in our examples, we haven't been getting full coverage of the functions; we have in the binary. To get that, we need to modify the compiler flags so; that we can instrument more (if not all) the functions we have in the binary.; We have two options for doing that, and we explore both of these below. Instruction Threshold; `````````````````````. The first ""blunt"" way of doing this is by setting the minimum threshold for; function bodies to 1. We can do that with the; ``-fxray-instruction-threshold=N`` flag when building our binary. We rebuild; ``llc`` with this option and observe the results:. ::. $ rm CMakeCache.txt; $ cmake -GNinja ../llvm -DCMAKE_BUILD_TYPE=Release \; -DCMAKE_C_FLAGS_RELEASE=""-fxray-instrument -fxray-instruction-threshold=1"" \; -DCMAKE_CXX_FLAGS=""-fxray-instrument -fxray-instruction-threshold=1""; $ ninja llc; $ XRAY_OPTIONS=""patch_premain=true"" ./bin/llc input.ll; ==69819==XRay: Log file in 'xray-log.llc.5rqxkU'. $ llvm-xray account xray-log.llc.5rqxkU --top=10 --sort=sum --sortorder=dsc --instr_map=./bin/llc; Functions with latencies: 36652; funcid count [ min, med, 90p, 99p, max] sum function; 75 1 [ 0.672368, 0.672368, 0.672368, 0.672368, 0.672368] 0.672368 llc.cpp:271:0: main; 78 1 [ 0.626455, 0.626455, 0.626455, 0.626455, 0.626455] 0.626455 llc.cpp:381:0: compileModule(char**, llvm::LLVMContext&); 139617 1 [ 0.472618, 0.472618, 0.472618, 0.472618, 0.472618] 0.472618 LegacyPassManager.cpp:1723:0: llvm::legacy::PassManager::run(llvm::Module&); 139610 1 [ 0.472618, 0.472618, 0.472618, 0.472618, 0.472618] 0.472618 LegacyPassManager.cpp:1681:0: llvm::legacy::PassManagerImpl::run(llvm::Module&); 139612 1 [ 0.470948, 0.470948, 0.470948, 0.470948, 0.470948] 0.470948 LegacyPassManager.cpp:1564:0: (anonymous namespace)::MPPassManager::runOnModule(llvm::Module&); 139607 2 [ 0.147345, 0.315994, 0.315994, 0.315994, 0.315994] 0.463340 LegacyPassManager.cpp:1530:0: llvm::FPPassManager::runOnModule(llvm::Module&); 1396",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayExample.rst:8304,log,log,8304,interpreter/llvm-project/llvm/docs/XRayExample.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayExample.rst,1,['log'],['log']
Testability," Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 : Purge, Reuse of gaps in TFile......................... OK; Test 4 : Test of 2-d histograms, functions, 2-d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subdirectories in a Root file.................... OK; Test 7 : TNtuple, selections, TCutG, TEventList.......... OK; Test 8 : Trees split and compression modes..................... OK; Test 9 : Analyze Event.root file of stress 8................... OK; Test 10 : Create 10 files starting from Event.root.............. OK; Test 11 : Test chains of Trees using the 10 files............... OK; Test 12 : Compare histograms of test 9 and 11................... OK; Test 13 : Test merging files of a chain......................... OK; Test 14 : Check correct rebuilt of Event.root in test 13........ OK; Test 15 : Divert Tree branches to separate files................ OK; Test 16 : Cling test (3 nested loops) with LHCb trigger.......... OK; ******************************************************************; * IRIX64 fnpat1 6.5 01221553 IP27; ******************************************************************; stress : Total I/O = 75.3 Mbytes, I = 59.2, O = 16.1; stress : Compr I/O = 75.7 Mbytes, I = 60.0, O = 15.7; stress : Real Time = 307.61 seconds Cpu Time = 292.82 seconds; ******************************************************************; * ROOTMARKS = 53.7 * Root2.25/00 20000710/1022; ```. ### guitest - A Graphical User Interface; \index{GUI application}. The `guitest` example, created by compiling `guitest.cxx`, tests and; illustrates the use of the native GUI widgets such as cascading menus,; dialog boxes, sliders and tab panels. It is a very useful example to; study when designing a GUI. Some examples of the output of `guitest` are; shown next. To run it type `guitest` at the system prompt in the; `$ROOTSYS/test` directory. We have included an entire chapter on this; sub",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:15801,test,test,15801,documentation/users-guide/TutorialsandTests.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md,1,['test'],['test']
Testability," For example, avoid specifying ``--line-length`` even; though it does not default to 80. The default rules can change between major; versions of black. In order to avoid unnecessary churn in the formatting rules,; we currently use black version 23.x in LLVM. When contributing a patch unrelated to formatting, you should format only the; Python code that the patch modifies. For this purpose, use the `darker; <https://pypi.org/project/darker/>`_ utility, which runs default black rules; over only the modified Python code. Doing so should ensure the patch will pass; the Python format checks in LLVM's pre-commit CI, which also uses darker. When; contributing a patch specifically for reformatting Python files, use black,; which currently only supports formatting entire files. Here are some quick examples, but see the black and darker documentation for; details:. .. code-block:: bash. $ pip install black=='23.*' darker # install black 23.x and darker; $ darker test.py # format uncommitted changes; $ darker -r HEAD^ test.py # also format changes from last commit; $ black test.py # format entire file. Instead of individual file names, you can specify directories to; darker, and it will find the changed files. However, if a directory is; large, like a clone of the LLVM repository, darker can be painfully; slow. In that case, you might wish to use git to list changed files.; For example:. .. code-block:: bash. $ darker -r HEAD^ $(git diff --name-only --diff-filter=d HEAD^). Mechanical Source Issues; ========================. Source Code Formatting; ----------------------. Commenting; ^^^^^^^^^^. Comments are important for readability and maintainability. When writing comments,; write them as English prose, using proper capitalization, punctuation, etc.; Aim to describe what the code is trying to do and why, not *how* it does it at; a micro level. Here are a few important things to document:. .. _header file comment:. File Headers; """""""""""""""""""""""". Every source file should have a h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:6205,test,test,6205,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['test'],['test']
Testability," For simple caching, the caching logic can be separated from the; mathematical code that is being moved to `MathFuncs.h`, so that it can; retained in the original file. For more complicated scenarios, the `code` variable can be used to identify; use cases (parts of the mathematical code in `evaluate()`) that should be; supported, while other parts that are explicitly not be supported (e.g., using; `if code==1 {...} else if code==2 {...}`). ### Can classes using Numerical Integration support AD?. So far, no. This needs further exploration. Hint: classes using Numerical; Integration can be identified with the absence of the `analyticalIntegral()`; function. ### Why is my code falling back to Numeric Differentiation?. If you call in to an external Math library, and you use a function that has a; customized variant with an already defined custom derivative, then you may see; a warning like ""falling back to Numeric Differentiation"". In most such cases,; your derivative should still work, since Numeric Differentiation is already; well-tested in Clad. To handle this, either define a custom derivative for that external function,; or find a way to expose it to Clad. An example of this can be seen with `gamma_cdf()` in MathFuncs.h`,; for which the custom derivative is not supported, but in this specific; instance, it falls back to Numeric Differentiation and works fine, since `; gamma_cdf()` doesn't have a lot of parameters. > In such cases, Numeric Differentiation fallback is only used for that; specific function. In above example, `gamma_cdf()` falls back to Numeric; Differentiation but other functions in `MathFuncs.h` will still be; able to use AD. This is because Clad is going to assume that you have a; derivative for this `gamma_cdf()` function, and the remaining functions will; use AD as expected. In the end, the remaining functions (including; `gamma_cdf()`) will try to fall back to Numeric Differentiation. However, if you want to add pure AD support, you need to make s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:27802,test,tested,27802,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['test'],['tested']
Testability," Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:5894,test,tests,5894,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,2,['test'],['tests']
Testability," However this solution would be somewhat fragile (how do you update a script; installed on every developer machine?) and prevents SVN access to the; repository. What About Commit Emails?; -------------------------. We will need a new bot to send emails for each commit. This proposal leaves the; email format unchanged besides the commit URL. Straw Man Migration Plan; ========================. Step #1 : Before The Move; -------------------------. 1. Update docs to mention the move, so people are aware of what is going on.; 2. Set up a read-only version of the GitHub project, mirroring our current SVN; repository.; 3. Add the required bots to implement the commit emails, as well as the; umbrella repository update (if the multirepo is selected) or the read-only; Git views for the sub-projects (if the monorepo is selected). Step #2 : Git Move; ------------------. 4. Update the buildbots to pick up updates and commits from the GitHub; repository. Not all bots have to migrate at this point, but it'll help; provide infrastructure testing.; 5. Update Phabricator to pick up commits from the GitHub repository.; 6. LNT and llvmlab have to be updated: they rely on unique monotonically; increasing integer across branch [MatthewsRevNum]_.; 7. Instruct downstream integrators to pick up commits from the GitHub; repository.; 8. Review and prepare an update for the LLVM documentation. Until this point nothing has changed for developers, it will just; boil down to a lot of work for buildbot and other infrastructure; owners. The migration will pause here until all dependencies have cleared, and all; problems have been solved. Step #3: Write Access Move; --------------------------. 9. Collect developers' GitHub account information, and add them to the project.; 10. Switch the SVN repository to read-only and allow pushes to the GitHub repository.; 11. Update the documentation.; 12. Mirror Git to SVN. Step #4 : Post Move; -------------------. 13. Archive the SVN repository.; 14. Update lin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:7289,test,testing,7289,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['test'],['testing']
Testability," IOReturn; (any typedef to kern_return_t) success is defined as having an output of zero (kIOReturnSuccess is zero).; For all others, success is non-zero (e.g. non-nullptr for pointers); 3. Retained out parameters on zero return; The annotation LIBKERN_RETURNS_RETAINED_ON_ZERO states; that a retained object is written into if and only if the function returns a zero value:. bool OSUnserializeXML(void *data, LIBKERN_RETURNS_RETAINED_ON_ZERO OSString **errString);. Then the caller has to release an object if the function has returned zero.; 4. Retained out parameters on non-zero return; Similarly, LIBKERN_RETURNS_RETAINED_ON_NONZERO specifies that a; retained object is written into the parameter if and only if the function has; returned a non-zero value.; Note that for non-retained out parameters conditionals do not matter, as the; caller has no obligations regardless of whether an object is written into or; not. Custom Assertion Handlers. The analyzer exploits code assertions by pruning off paths where the; assertion condition is false. The idea is capture any program invariants; specified in the assertion that the developer may know but is not immediately; apparent in the code itself. In this way assertions make implicit assumptions; explicit in the code, which not only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:19644,assert,assertions,19644,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,2,['assert'],"['assertion', 'assertions']"
Testability," IPSCCP does not currently propagate argument dependent constants through; functions where it does not not all of the callers. This includes functions; with normal external linkage as well as templates, C99 inline functions etc.; Specifically, it does nothing to:. define i32 @test(i32 %x, i32 %y, i32 %z) nounwind {; entry:; %0 = add nsw i32 %y, %z ; %1 = mul i32 %0, %x ; %2 = mul i32 %y, %z ; %3 = add nsw i32 %1, %2 ; ret i32 %3; }. define i32 @test2() nounwind {; entry:; %0 = call i32 @test(i32 1, i32 2, i32 4) nounwind; ret i32 %0; }. It would be interesting extend IPSCCP to be able to handle simple cases like; this, where all of the arguments to a call are constant. Because IPSCCP runs; before inlining, trivial templates and inline functions are not yet inlined.; The results for a function + set of constant arguments should be memoized in a; map. //===---------------------------------------------------------------------===//. The libcall constant folding stuff should be moved out of SimplifyLibcalls into; libanalysis' constantfolding logic. This would allow IPSCCP to be able to; handle simple things like this:. static int foo(const char *X) { return strlen(X); }; int bar() { return foo(""abcd""); }. //===---------------------------------------------------------------------===//. function-attrs doesn't know much about memcpy/memset. This function should be; marked readnone rather than readonly, since it only twiddles local memory, but; function-attrs doesn't handle memset/memcpy/memmove aggressively:. struct X { int *p; int *q; };; int foo() {; int i = 0, j = 1;; struct X x, y;; int **p;; y.p = &i;; x.q = &j;; p = __builtin_memcpy (&x, &y, sizeof (int *));; return **p;; }. This can be seen at:; $ clang t.c -S -o - -mkernel -O0 -emit-llvm | opt -function-attrs -S. //===---------------------------------------------------------------------===//. Missed instcombine transformation:; define i1 @a(i32 %x) nounwind readnone {; entry:; %cmp = icmp eq i32 %x, 30; %sub = add i3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:46634,log,logic,46634,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['log'],['logic']
Testability," If the :option:`-o` option is omitted, then :program:`llvm-mc` will send its; output to standard output if the input is from standard input. If the; :option:`-o` option specifies ""``-``"", then the output will also be sent to; standard output. If no :option:`-o` option is specified and an input file other than ""``-``"" is; specified, then :program:`llvm-mc` creates the output filename by taking the; input filename, removing any existing ``.s`` extension, and adding a ``.o``; suffix. Other :program:`llvm-mc` options are described below. End-user Options; ~~~~~~~~~~~~~~~~. .. option:: --help. Display available options (--help-hidden for more). .. option:: -o <filename>. Use ``<filename>`` as the output filename. See the summary above for more; details. .. option:: --arch=<string>. Target arch to assemble for, see -version for available targets. .. option:: --as-lex. Apply the assemblers ""lexer"" to break the input into tokens and print each of; them out. This is intended to help develop and test an assembler; implementation. .. option:: --assemble. Assemble assembly file (default), and print the result to assembly. This is; useful to design and test instruction parsers, and can be a useful tool when; combined with other llvm-mc flags. For example, this option may be useful to; transcode assembly from different dialects, e.g. on Intel where you can use; -output-asm-variant=1 to translate from AT&T to Intel assembly syntax. It can; also be combined with --show-encoding to understand how instructions are; encoded. .. option:: --disassemble. Parse a series of hex bytes, and print the result out as assembly syntax. .. option:: --mdis. Marked up disassembly of string of hex bytes. .. option:: --cdis. Colored disassembly of string of hex bytes. .. option:: --filetype=[asm,null,obj]. Sets the output filetype. Setting this flag to `asm` will make the tool output; text assembly. Setting this flag to `obj` will make the tool output an object; file. Setting it to `null` causes no o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mc.rst:1705,test,test,1705,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mc.rst,1,['test'],['test']
Testability," It also shows, that the CodeView debug information does not generate; source code line numbers for the those logical symbols. The logical; view is sorted by the types name. TEST CASE 6 - FULL LOGICAL VIEW; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; For advanced users, :program:`llvm-debuginfo-analyzer` can display low; level information that includes offsets within the debug information; section, debug location operands, linkage names, etc. .. code-block:: none. llvm-debuginfo-analyzer --attribute=all; --print=all; test-dwarf-clang.o. Logical View:; [0x0000000000][000] {File} 'test-dwarf-clang.o' -> elf64-x86-64. [0x000000000b][001] {CompileUnit} 'test.cpp'; [0x000000000b][002] {Producer} 'clang version 12.0.0'; {Directory} ''; {File} 'test.cpp'; {Public} 'foo' [0x0000000000:0x000000003a]; [0x000000000b][002] {Range} Lines 2:9 [0x0000000000:0x000000003a]; [0x00000000bc][002] {BaseType} 'bool'; [0x0000000099][002] {BaseType} 'int'; [0x00000000b5][002] {BaseType} 'unsigned int'. [0x00000000a0][002] {Source} '/test.cpp'; [0x00000000a0][002] 1 {TypeAlias} 'INTPTR' -> [0x00000000ab]'* const int'; [0x000000002a][002] 2 {Function} extern not_inlined 'foo' -> [0x0000000099]'int'; [0x000000002a][003] {Range} Lines 2:9 [0x0000000000:0x000000003a]; [0x000000002a][003] {Linkage} 0x2 '_Z3fooPKijb'; [0x0000000071][003] {Block}; [0x0000000071][004] {Range} Lines 5:8 [0x000000001c:0x000000002f]; [0x000000007e][004] 5 {Variable} 'CONSTANT' -> [0x00000000c3]'const INTEGER'; [0x000000007e][005] {Coverage} 100.00%; [0x000000007f][005] {Location}; [0x000000007f][006] {Entry} Stack Offset: -28 (0xffffffffffffffe4) [DW_OP_fbreg]; [0x000000001c][004] 5 {Line} {NewStatement} '/test.cpp'; [0x000000001c][004] {Code} 'movl	$0x7, -0x1c(%rbp)'; [0x0000000023][004] 6 {Line} {NewStatement} '/test.cpp'; [0x0000000023][004] {Code} 'movl	$0x7, -0x4(%rbp)'; [0x000000002a][004] {Code} 'jmp	0x6'; [0x000000002f][004] 8 {Line} {NewStatement} '/test.cpp'; [0x000000002f][004] {Code} 'movl	-0x14(%rbp), %eax'; [0x00000",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:55635,test,test,55635,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['test'],['test']
Testability," LLVM runtimes."" ON); option(LLVM_BUILD_RUNTIMES; ""Build the LLVM runtimes. If OFF, just generate build targets."" ON). option(LLVM_BUILD_RUNTIME; ""Build the LLVM runtime libraries."" ON); option(LLVM_BUILD_EXAMPLES; ""Build the LLVM example programs. If OFF, just generate build targets."" OFF); option(LLVM_INCLUDE_EXAMPLES ""Generate build targets for the LLVM examples"" ON). if(LLVM_BUILD_EXAMPLES); add_compile_definitions(BUILD_EXAMPLES); endif(LLVM_BUILD_EXAMPLES). option(LLVM_BUILD_TESTS; ""Build LLVM unit tests. If OFF, just generate build targets."" OFF); option(LLVM_INCLUDE_TESTS ""Generate build targets for the LLVM unit tests."" ON). option(LLVM_INSTALL_GTEST; ""Install the llvm gtest library. This should be on if you want to do; stand-alone builds of the other projects and run their unit tests."" OFF). option(LLVM_BUILD_BENCHMARKS ""Add LLVM benchmark targets to the list of default; targets. If OFF, benchmarks still could be built using Benchmarks target."" OFF); option(LLVM_INCLUDE_BENCHMARKS ""Generate benchmark targets. If OFF, benchmarks can't be built."" ON). option (LLVM_BUILD_DOCS ""Build the llvm documentation."" OFF); option (LLVM_INCLUDE_DOCS ""Generate build targets for llvm documentation."" ON); option (LLVM_ENABLE_DOXYGEN ""Use doxygen to generate llvm API documentation."" OFF); option (LLVM_ENABLE_SPHINX ""Use Sphinx to generate llvm documentation."" OFF); option (LLVM_ENABLE_OCAMLDOC ""Build OCaml bindings documentation."" ON); option (LLVM_ENABLE_BINDINGS ""Build bindings."" ON). set(LLVM_INSTALL_DOXYGEN_HTML_DIR ""${CMAKE_INSTALL_DOCDIR}/llvm/doxygen-html""; CACHE STRING ""Doxygen-generated HTML documentation install directory""); set(LLVM_INSTALL_OCAMLDOC_HTML_DIR ""${CMAKE_INSTALL_DOCDIR}/llvm/ocaml-html""; CACHE STRING ""OCamldoc-generated HTML documentation install directory""). option (LLVM_BUILD_EXTERNAL_COMPILER_RT; ""Build compiler-rt as an external project."" OFF). option (LLVM_VERSION_PRINTER_SHOW_HOST_TARGET_INFO; ""Show target and host info when tools are invoked wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:32170,benchmark,benchmark,32170,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['benchmark'],['benchmark']
Testability," Logical View:; [000] {File} 'pr-43860-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [004] {Variable} 'Var_1' -> 'int'; [004] {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr-43860.cpp'; [003] {Variable} 'Var_1' -> 'int'; [004] {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-dwarf-clang.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [004] {Variable} 'Var_1' -> 'int'; [003] 3 {Variable} 'Var_1' -> 'int'; [005] {Variable} 'Var_2' -> 'int'; [004] 5 {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-dwarf-gcc.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [004] {Variable} 'Var_1' -> 'int'; [003] 3 {Variable} 'Var_1' -> 'int'; [005] {Variable} 'Var_2' -> 'int'; [004] 5 {Variable} 'Var_2' -> 'int'. It also shows, that the CodeView debug information does not generate; source code line numbers for the those logical symbols. The logical; view is sorted by the types name. TEST CASE 6 - FULL LOGICAL VIEW; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; For advanced users, :program:`llvm-debuginfo-analyzer` can display low; level information that includes offsets within the debug information; section, debug location operands, linkage names, etc. .. code-block:: none. llvm-debuginfo-analyzer --attribute=all; --print=all; test-dwarf-clang.o. Logical View:; [0x0000000000][000] {File} 'test-dwarf-clang.o' -> elf64-x86-64. [0x000000000b][001] {CompileUnit} 'test.cpp'; [0x000000000b][002] {Producer} 'clang version 12.0.0'; {Directory} ''; {File} 'test.cpp'; {Public} 'foo' [0x0000000000:0x000000003a]; [0x000000000b][002] {Range} Lines 2:9 [0x0000000000:0x000000003a]; [0x00000000bc][002] {BaseType} 'bool'; [0x0000000099][002] {BaseType} 'int'; [0x00000000b5][002] {BaseType} 'unsigned int'. [0x00000000a0][002] {Source} '/test.cpp'; [0x00000000a0][002] 1 {TypeAlias} 'INTPTR' -> [0x00000000ab]'* const int'; [0x000000002a][002] 2 {Function} extern not_inline",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:54752,log,logical,54752,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['log'],['logical']
Testability," Manual; ================. This section acts as internal documentation for OpenCL features design; as well as some important implementation aspects. It is primarily targeted; at the advanced users and the toolchain developers integrating frontend; functionality as a component. OpenCL Metadata; ---------------. Clang uses metadata to provide additional OpenCL semantics in IR needed for; backends and OpenCL runtime. Each kernel will have function metadata attached to it, specifying the arguments.; Kernel argument metadata is used to provide source level information for querying; at runtime, for example using the `clGetKernelArgInfo; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.2.pdf#167>`_; call. Note that ``-cl-kernel-arg-info`` enables more information about the original; kernel code to be added e.g. kernel parameter names will appear in the OpenCL; metadata along with other information. The IDs used to encode the OpenCL's logical address spaces in the argument info; metadata follows the SPIR address space mapping as defined in the SPIR; specification `section 2.2; <https://www.khronos.org/registry/spir/specs/spir_spec-2.0.pdf#18>`_. OpenCL Specific Options; -----------------------. In addition to the options described in :doc:`UsersManual` there are the; following options specific to the OpenCL frontend. All the options in this section are frontend-only and therefore if used; with regular clang driver they require frontend forwarding, e.g. ``-cc1``; or ``-Xclang``. .. _opencl_finclude_default_header:. .. option:: -finclude-default-header. Adds most of builtin types and function declarations during compilations. By; default the OpenCL headers are not loaded by the frontend and therefore certain; builtin types and most of builtin functions are not declared. To load them; automatically this flag can be passed to the frontend (see also :ref:`the; section on the OpenCL Header <opencl_header>`):. .. code-block:: console. $ clang -Xclang -finclude-default-header",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:2166,log,logical,2166,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,1,['log'],['logical']
Testability," MatchFinder::MatchCallback {; public :; virtual void run(const MatchFinder::MatchResult &Result) {; if (const ForStmt *FS = Result.Nodes.getNodeAs<clang::ForStmt>(""forLoop"")); FS->dump();; }; };. And change ``main()`` to:. .. code-block:: c++. int main(int argc, const char **argv) {; auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory);; if (!ExpectedParser) {; // Fail gracefully for unsupported options.; llvm::errs() << ExpectedParser.takeError();; return 1;; }; CommonOptionsParser& OptionsParser = ExpectedParser.get();; ClangTool Tool(OptionsParser.getCompilations(),; OptionsParser.getSourcePathList());. LoopPrinter Printer;; MatchFinder Finder;; Finder.addMatcher(LoopMatcher, &Printer);. return Tool.run(newFrontendActionFactory(&Finder).get());; }. Now, you should be able to recompile and run the code to discover for; loops. Create a new file with a few examples, and test out our new; handiwork:. .. code-block:: console. cd ~/clang-llvm/build/; ninja loop-convert; vim ~/test-files/simple-loops.cc; bin/loop-convert ~/test-files/simple-loops.cc. Step 3.5: More Complicated Matchers; ===================================. Our simple matcher is capable of discovering for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same vari",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:10414,test,test-files,10414,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['test'],['test-files']
Testability," Memory Management Annotations. Attribute 'os_returns_retained'; Attribute 'os_returns_not_retained'; Attribute 'os_consumed'; Attribute 'os_consumes_this'; Out Parameters. Custom Assertion Handlers. Attribute 'noreturn'; Attribute 'analyzer_noreturn'. Annotations to Enhance Generic Checks. Null Pointer Checking; Attribute 'nonnull'; The analyzer recognizes the GCC attribute 'nonnull', which indicates that a; function expects that a given function parameter is not a null pointer. Specific; details of the syntax of using the 'nonnull' attribute can be found in GCC's; documentation.; Both the Clang compiler and GCC will flag warnings for simple cases where a; null pointer is directly being passed to a function with a 'nonnull' parameter; (e.g., as a constant). The analyzer extends this checking by using its deeper; symbolic analysis to track what pointer values are potentially null and then; flag warnings when they are passed in a function call via a 'nonnull'; parameter.; Example. $ cat test.m; int bar(int*p, int q, int *r) __attribute__((nonnull(1,3)));. int foo(int *p, int *q) {; return !p ? bar(q, 2, p); : bar(p, 2, q);; }. Running scan-build over this source produces the following; output:. Mac OS X API Annotations. Cocoa & Core Foundation Memory Management; Annotations. The analyzer supports the proper management of retain counts for; both Cocoa and Core Foundation objects. This checking is largely based on; enforcing Cocoa and Core Foundation naming conventions for Objective-C methods; (Cocoa) and C functions (Core Foundation). Not strictly following these; conventions can cause the analyzer to miss bugs or flag false positives.; One can educate the analyzer (and others who read your code) about methods or; functions that deviate from the Cocoa and Core Foundation conventions using the; attributes described here. However, you should consider using proper naming; conventions or the objc_method_family; attribute, if applicable.; Attribute 'ns_returns_retained'; (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:2283,test,test,2283,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['test'],['test']
Testability," MyClass *obj = 0;; obj->x = 1; // warn; }. core.StackAddressEscape; (C); Check that addresses of stack memory do not escape the function. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. core.UndefinedBinaryOperatorResult; (C); Check for undefined results of binary operators. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. core.VLASize; (C); Check for declarations of VLA of undefined or zero size. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. core.uninitialized.ArraySubscript; (C); Check for uninitialized values used as array subscripts. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. core.uninitialized.Assign; (C); Check for assigning uninitialized values. void test() {; int x;; x |= 1; // warn: left expression is uninitialized; }. core.uninitialized.Branch; (C); Check for uninitialized values used as branch conditions. void test() {; int x;; if (x) // warn; return;; }. core.uninitialized.CapturedBlockVariable; (C); Check for blocks that capture uninitialized values. void test() {; int x;; ^{ int y = x; }(); // warn; }. core.uninitialized.UndefReturn; (C); Check for uninitialized values being returned to the caller. int test() {; int x;; return x; // warn; }. C++ Checkers. Name, DescriptionExample. cplusplus.NewDelete; (C++); Check for double-free, use-after-free and offset problems involving C++ ; delete. void f(int *p);. void testUseMiddleArgAfterDelete(int *p) {; delete p;; f(p); // warn: use after free; }. class SomeClass {; public:; void f();; };. void test() {; SomeClass *c = new SomeClass;; delete c;; c->f(); // warn: use after free; }. void test() {; int *p = (int *)__builtin_alloca(sizeof(int));; delete p; // warn: deleting memory allocated by alloca; }. void test()",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:4532,test,test,4532,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability," MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.NullDereference; (C, C++, ObjC); Check for dereferences of null pointers. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. core.StackAddressEscape; (C); Check that addresses of stack memory do not escape the function. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. core.UndefinedBinaryOperatorResult; (C); Check for undefined results of binary operators. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. core.VLASize; (C); Check for declarations of VLA of undefined or zero size. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. core.uninitialized.ArraySubscript; (C); Check for uninitialized values used as array subscripts. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. core.uninitialized.Assign; (C); Check for assigning uninitialized values. void test() {; int x;; x |= 1; // warn: left expres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:3555,test,test,3555,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability," MyJIT J = ...;. auto &JITStdLibJD = ... ;. JITStdLibJD.define(absoluteSymbols(SymbolMap({; { Mangle(""__MyJITInstance""),; { ExecutorAddr::fromPtr(&J), JITSymbolFlags() } }; });. Aliases and Reexports; ---------------------. Aliases and reexports allow you to define new symbols that map to existing; symbols. This can be useful for changing linkage relationships between symbols; across sessions without having to recompile code. For example, imagine that; JIT'd code has access to a log function, ``void log(const char*)`` for which; there are two implementations in the JIT standard library: ``log_fast`` and; ``log_detailed``. Your JIT can choose which one of these definitions will be; used when the ``log`` symbol is referenced by setting up an alias at JIT startup; time:. .. code-block:: c++. auto &JITStdLibJD = ... ;. auto LogImplementationSymbol =; Verbose ? Mangle(""log_detailed"") : Mangle(""log_fast"");. JITStdLibJD.define(; symbolAliases(SymbolAliasMap({; { Mangle(""log""),; { LogImplementationSymbol; JITSymbolFlags::Exported | JITSymbolFlags::Callable } }; });. The ``symbolAliases`` function allows you to define aliases within a single; JITDylib. The ``reexports`` function provides the same functionality, but; operates across JITDylib boundaries. E.g. .. code-block:: c++. auto &JD1 = ... ;; auto &JD2 = ... ;. // Make 'bar' in JD2 an alias for 'foo' from JD1.; JD2.define(; reexports(JD1, SymbolAliasMap({; { Mangle(""bar""), { Mangle(""foo""), JITSymbolFlags::Exported } }; });. The reexports utility can be handy for composing a single JITDylib interface by; re-exporting symbols from several other JITDylibs. .. _Laziness:. Laziness; ========. Laziness in ORC is provided by a utility called ""lazy reexports"". A lazy; reexport is similar to a regular reexport or alias: It provides a new name for; an existing symbol. Unlike regular reexports however, lookups of lazy reexports; do not trigger immediate materialization of the reexported symbol. Instead, they; only trigger materializ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:15902,log,log,15902,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['log'],['log']
Testability," NSAutoreleasePool in Objective-C; GC mode (-fobjc-gc compiler option). void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. osx.cocoa.NSError; (ObjC); Check usage of NSError** parameters. @interface A : NSObject; - (void)foo:(NSError **)error;; @end. @implementation A; - (void)foo:(NSError **)error {; // warn: method accepting NSError** should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError **)error;; @end. @implementation A; - (BOOL)foo:(NSError **)error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. osx.cocoa.NilArg; (ObjC); Check for prohibited nil arguments in specific Objective-C method calls:; - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. osx.cocoa.ObjCGenerics; (ObjC); Check for type errors when using Objective-C generics. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. osx.cocoa.RetainCount; (ObjC); Check for leaks and violations of the Cocoa Memory Management rules. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. osx.cocoa.SelfInit; (ObjC); Check that self is properly initialized inside an initializer; method. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @en",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:17753,test,test,17753,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability," New class TProofDataSetManager definining the interface; of PROOF to dataset metainfo database; New class TProofDataSetManagerFile implementating; TProofDataSetManager using the file system as back-end;  the; separation is needed to load dataset menagers using different backends;; for example ATLAS foresees to have a MySQL-based implementation.; The instance of the appropriate TProofDataSetManager is; instantiated via the plugin manager; by default an instance; of TProofDataSetManagerFile; managing the <sandbox>/datasets; area is created. The directive 'Proof.DataSetManager' can be used to; modify the settings for TProofDataSetManagerFile or to load a; different dataset manager; for example, to '/pool/datasets' as area for; the dataset information, the following directive can be added to the; xrootd config file; xpd.putrc Proof.DataSetManager file dir:/pool/datasets. Interface to TProofMgr::GetSessionLogs() in the dialog; box. The graphics layout of the logbox has been re-designed, with new; buttons to grep the logs and to save them to a file. It is also; possible to choose the range of lines to be displayed and the subset of; nodes.; ; Support for connection control base on the UNIX group; (new directive 'xpd.allowedgroups; <grp1>,<grp2>, ...'). Improvements:. ; In the case of mismatch between the expected and actual; number of processed events, send back to the client the list of failed; packets.; Implement the classic strategy of the TPacketizer in; TPacketizerAdaptive; the strategy can be changed from adaptive; (default) to TPacketizer with: ""PROOF_PacketizerStrategy"" parameter to; PROOF; The max workers per node can now be also set in the; xrootd config file with.        xpd.putrc ; Packetizer.MaxWorkersPerNode: <desired number>. Make fCacheDir and fPackageDir controllable via directive; . Fixes. ; Two memory leaks in TProofServ affecting repeated runs; withing the same session. Fix a problem cleaning-up the input list on the workers; ; The type of ""PROOF_MaxSl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v520/index.html:1020,log,logbox,1020,proof/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v520/index.html,2,['log'],"['logbox', 'logs']"
Testability," No 1 − Cost parameter. Tol No 0.01 − Tolerance parameter. MaxIter No 1000 − Maximum number of training loops. Configuration options for MVA method :. Configuration options reference for MVA method: CFMlpANN. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NCycles No 3000 − Number of training cycles. HiddenLayers No N,N-1 − Specification of hidden layer architecture. Configuration options for MVA method :. Configuration options reference for MVA method: KNN. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:9265,test,testing,9265,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['test'],['testing']
Testability," No None None, Gauss, LinNeighbors Kernel type used. TargetSelection No Mean Mean, Mpv Target selection method. Configuration options for MVA method :. Configuration options reference for MVA method: TMlpANN. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NCycles No 200 − Number of training cycles. HiddenLayers No N,N-1 − Specification of hidden layer architecture (N stands for number of variables; any integers may also be used). ValidationFraction No 0.5 − Fraction of events in training tree used for cross validation. LearningMethod No Stochastic Stochastic, Batch, SteepestDescent, RibierePolak, FletcherReeves, BFGS Learning method. Configuration options for setup and tuning of specific fitter :. Configuration options reference for fitting method: Simulated Annealing (SA). Option Array Default value Predefined values Description. MaxCalls No 100000 − Maximum number of minimisation calls. InitialTemp No 1e+06 − Initial temperature. MinTemp No 1e-06 − Mimimum temperature. Eps No 1e-10 − Epsilon. TempScale No 1 − Temperature scale. AdaptiveSpeed No 1 − Adaptive speed. TempAdaptiveStep No 0.009875 − Step made in each generation temperature adaptive. UseDefaultSca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:28683,test,testing,28683,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['test'],['testing']
Testability," ON). option(LLVM_INCLUDE_RUNTIMES ""Generate build targets for the LLVM runtimes."" ON); option(LLVM_BUILD_RUNTIMES; ""Build the LLVM runtimes. If OFF, just generate build targets."" ON). option(LLVM_BUILD_RUNTIME; ""Build the LLVM runtime libraries."" ON); option(LLVM_BUILD_EXAMPLES; ""Build the LLVM example programs. If OFF, just generate build targets."" OFF); option(LLVM_INCLUDE_EXAMPLES ""Generate build targets for the LLVM examples"" ON). if(LLVM_BUILD_EXAMPLES); add_compile_definitions(BUILD_EXAMPLES); endif(LLVM_BUILD_EXAMPLES). option(LLVM_BUILD_TESTS; ""Build LLVM unit tests. If OFF, just generate build targets."" OFF); option(LLVM_INCLUDE_TESTS ""Generate build targets for the LLVM unit tests."" ON). option(LLVM_INSTALL_GTEST; ""Install the llvm gtest library. This should be on if you want to do; stand-alone builds of the other projects and run their unit tests."" OFF). option(LLVM_BUILD_BENCHMARKS ""Add LLVM benchmark targets to the list of default; targets. If OFF, benchmarks still could be built using Benchmarks target."" OFF); option(LLVM_INCLUDE_BENCHMARKS ""Generate benchmark targets. If OFF, benchmarks can't be built."" ON). option (LLVM_BUILD_DOCS ""Build the llvm documentation."" OFF); option (LLVM_INCLUDE_DOCS ""Generate build targets for llvm documentation."" ON); option (LLVM_ENABLE_DOXYGEN ""Use doxygen to generate llvm API documentation."" OFF); option (LLVM_ENABLE_SPHINX ""Use Sphinx to generate llvm documentation."" OFF); option (LLVM_ENABLE_OCAMLDOC ""Build OCaml bindings documentation."" ON); option (LLVM_ENABLE_BINDINGS ""Build bindings."" ON). set(LLVM_INSTALL_DOXYGEN_HTML_DIR ""${CMAKE_INSTALL_DOCDIR}/llvm/doxygen-html""; CACHE STRING ""Doxygen-generated HTML documentation install directory""); set(LLVM_INSTALL_OCAMLDOC_HTML_DIR ""${CMAKE_INSTALL_DOCDIR}/llvm/ocaml-html""; CACHE STRING ""OCamldoc-generated HTML documentation install directory""). option (LLVM_BUILD_EXTERNAL_COMPILER_RT; ""Build compiler-rt as an external project."" OFF). option (LLVM_VERSION_PRINTER_SHOW_HOST",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:32065,benchmark,benchmarks,32065,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['benchmark'],['benchmarks']
Testability," Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.NullDereference; (C, C++, ObjC); Check for dereferences of null pointers. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. core.StackAddressEscape; (C); Check that addresses of stack memory do not escape the function. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. core.UndefinedBinaryOperatorResult; (C); Check for undefined results of binary operators. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. core.VLASize; (C); Check for declarations of VLA of undefined or zero size. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. core.uninitialized.ArraySubscript; (C); Check for uninitialized values used as array subscripts. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. core.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:3437,test,test,3437,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability," On Windows, %/T but a ``:`` is removed if its the second character.; Otherwise, %T but with a single leading ``/`` removed.; ======================= ==============. Other substitutions are provided that are variations on this base set and; further substitution patterns can be defined by each test module. See the; modules :ref:`local-configuration-files`. More detailed information on substitutions can be found in the; :doc:`../TestingGuide`. TEST RUN OUTPUT FORMAT; ~~~~~~~~~~~~~~~~~~~~~~. The :program:`lit` output for a test run conforms to the following schema, in; both short and verbose modes (although in short mode no PASS lines will be; shown). This schema has been chosen to be relatively easy to reliably parse by; a machine (for example in buildbot log scraping), and for other tools to; generate. Each test result is expected to appear on a line that matches:. .. code-block:: none. <result code>: <test name> (<progress info>). where ``<result-code>`` is a standard test result such as PASS, FAIL, XFAIL,; XPASS, UNRESOLVED, or UNSUPPORTED. The performance result codes of IMPROVED and; REGRESSED are also allowed. The ``<test name>`` field can consist of an arbitrary string containing no; newline. The ``<progress info>`` field can be used to report progress information such; as (1/300) or can be empty, but even when empty the parentheses are required. Each test result may include additional (multiline) log information in the; following format:. .. code-block:: none. <log delineator> TEST '(<test name>)' <trailing delineator>; ... log message ...; <log delineator>. where ``<test name>`` should be the name of a preceding reported test, ``<log; delineator>`` is a string of ""*"" characters *at least* four characters long; (the recommended length is 20), and ``<trailing delineator>`` is an arbitrary; (unparsed) string. The following is an example of a test run output which consists of four tests A,; B, C, and D, and a log message for the failing test C:. .. code-block:: no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:22694,test,test,22694,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['test']
Testability," PointerAuth; ScudoHardenedAllocator; MemTagSanitizer; Security; SecurityTransparencyReports; SegmentedStacks; StackMaps; SpeculativeLoadHardening; Statepoints; SymbolizerMarkupFormat; SystemLibrary; TestingGuide; TransformMetadata; TypeMetadata; XRay; XRayExample; XRayFDRFormat; YamlIO. API Reference; -------------. `Doxygen generated documentation <https://llvm.org/doxygen/>`_; (`classes <https://llvm.org/doxygen/inherits.html>`_). :doc:`HowToUseAttributes`; Answers some questions about the new Attributes infrastructure. LLVM Reference; --------------. ======================; Command Line Utilities; ======================. :doc:`LLVM Command Guide <CommandGuide/index>`; A reference manual for the LLVM command line utilities (""man"" pages for LLVM; tools). :doc:`Bugpoint`; Automatic bug finder and test-case reducer description and usage; information. :doc:`OptBisect`; A command line option for debugging optimization-induced failures. :doc:`SymbolizerMarkupFormat`; A reference for the log symbolizer markup accepted by ``llvm-symbolizer``. :doc:`The Microsoft PDB File Format <PDB/index>`; A detailed description of the Microsoft PDB (Program Database) file format. ==================; Garbage Collection; ==================. :doc:`GarbageCollection`; The interfaces source-language compilers should use for compiling GC'd; programs. :doc:`Statepoints`; This describes a set of experimental extensions for garbage; collection support. =========; LibFuzzer; =========. :doc:`LibFuzzer`; A library for writing in-process guided fuzzers. :doc:`FuzzingLLVM`; Information on writing and using Fuzzers to find bugs in LLVM. ========; LLVM IR; ========. :doc:`LLVM Language Reference Manual <LangRef>`; Defines the LLVM intermediate representation and the assembly form of the; different nodes. :doc:`InAlloca`; Description of the ``inalloca`` argument attribute. :doc:`BitCodeFormat`; This describes the file format and encoding used for LLVM ""bc"" files. :doc:`Machine IR (MIR) Format Referen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:1559,log,log,1559,interpreter/llvm-project/llvm/docs/Reference.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst,1,['log'],['log']
Testability," Position-Independent Code"" ON); endif(); option(LLVM_ENABLE_MODULES ""Compile with C++ modules enabled."" OFF); if(${CMAKE_SYSTEM_NAME} MATCHES ""Darwin""); option(LLVM_ENABLE_MODULE_DEBUGGING ""Compile with -gmodules."" ON); else(); option(LLVM_ENABLE_MODULE_DEBUGGING ""Compile with -gmodules."" OFF); endif(); option(LLVM_ENABLE_LOCAL_SUBMODULE_VISIBILITY ""Compile with -fmodules-local-submodule-visibility."" ON); option(LLVM_ENABLE_LIBCXX ""Use libc++ if available."" OFF); option(LLVM_ENABLE_LLVM_LIBC ""Set to on to link all LLVM executables against LLVM libc, assuming it is accessible by the host compiler."" OFF); option(LLVM_STATIC_LINK_CXX_STDLIB ""Statically link the standard library."" OFF); option(LLVM_ENABLE_LLD ""Use lld as C and C++ linker."" OFF); option(LLVM_ENABLE_PEDANTIC ""Compile with pedantic enabled."" ON); option(LLVM_ENABLE_WERROR ""Fail and stop if a warning is triggered."" OFF). option(LLVM_ENABLE_DUMP ""Enable dump functions even when assertions are disabled"" OFF); option(LLVM_UNREACHABLE_OPTIMIZE ""Optimize llvm_unreachable() as undefined behavior (default), guaranteed trap when OFF"" ON). if( NOT uppercase_CMAKE_BUILD_TYPE STREQUAL ""DEBUG"" ); option(LLVM_ENABLE_ASSERTIONS ""Enable assertions"" OFF); else(); option(LLVM_ENABLE_ASSERTIONS ""Enable assertions"" ON); endif(). option(LLVM_ENABLE_EXPENSIVE_CHECKS ""Enable expensive checks"" OFF). # While adding scalable vector support to LLVM, we temporarily want to; # allow an implicit conversion of TypeSize to uint64_t, and to allow; # code to get the fixed number of elements from a possibly scalable vector.; # This CMake flag enables a more strict mode where it asserts that the type; # is not a scalable vector type.; #; # Enabling this flag makes it easier to find cases where the compiler makes; # assumptions on the size being 'fixed size', when building tests for; # SVE/SVE2 or other scalable vector architectures.; option(LLVM_ENABLE_STRICT_FIXED_SIZE_VECTORS; ""Enable assertions that type is not scalable in implicit conve",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:25068,assert,assertions,25068,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['assert'],['assertions']
Testability," Provide access to arbitrary data member of objects, registered to the server; - Prevent data caching in the browser by setting no-cache header. April 2014; - In TCivetweb class support digest authentication method. User; can specify auth_file and auth_domain parameters to protect; access to the server; - Fix error in FastCgi, now correctly works with Apache; - Avoid direct usage of TASImage. March 2014; - Replace mongoose by civetweb due to more liberal MIT license.; Works out of the box while civetweb version fully corresponds to; previously used version of mongoose.; - Introduce TBufferJSON class to store arbitrary ROOT object; into JSON format. It is not one-to-one storage (like XML), but; rather JS-like structures. For instance, all TCollections converted; into JavaScript Array. Produced JS object is similar to JSRootIO.; - Process get.json request, which returns object in JSON form.; It can be used directly is script without special I/O of Bertrand.; - Use get.json on browser side to simplify logic. No need for extra; requests for streamer infos.; - Process get.xml request, provide full object streaming via TBufferXML.; It is complete object data, but with many custom-streamer data.; - Significant redesign of I/O part of JSRootIO code. Main change -; introduce JSROOTIO.TBuffer class which has similar functionality as; original TBufferFile class. Eliminate many places with duplicated code; - In JSRootIO avoid objects cloning when object referenced several times; - Treat special cases (collection, arrays) in one place.; This is major advantage, while any new classes should be implemented once.; - Object representation, produced by JSRootIO is similar to; objects, produced by TBufferJSON class. By this one can exchange; I/O engine and use same JavaSctript graphic for display.; - More clear functions to display different elements of the file.; In the future functions should be fully separated from I/O part; and organized in similar way as online part.; - Eliminate ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt:2578,log,logic,2578,net/http/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt,1,['log'],['logic']
Testability," ROOT_ADD_TEST(test-stressfit-interpreted COMMAND ${ROOT_root_CMD} -b -q -l ${CMAKE_CURRENT_SOURCE_DIR}/stressFit.cxx; FAILREGEX ""FAILED|Error in"" DEPENDS test-stressfit). #--stressHistoFit-----------------------------------------------------------------------------; if(ROOT_unuran_FOUND); ROOT_EXECUTABLE(stressHistoFit stressHistoFit.cxx LIBRARIES MathCore Matrix Unuran Tree Gpad); ROOT_ADD_TEST(test-stresshistofit COMMAND stressHistoFit FAILREGEX ""FAILED|Error in"" LABELS longtest); if(NOT MSVC OR llvm13_broken_tests); ROOT_ADD_TEST(test-stresshistofit-interpreted COMMAND ${ROOT_root_CMD} -b -q -l ${CMAKE_CURRENT_SOURCE_DIR}/stressHistoFit.cxx; FAILREGEX ""FAILED|Error in"" DEPENDS test-stresshistofit ); endif(); endif(). #--stressEntryList---------------------------------------------------------------------------; ROOT_EXECUTABLE(stressEntryList stressEntryList.cxx LIBRARIES MathCore Tree Hist); ROOT_ADD_TEST(test-stressentrylist COMMAND stressEntryList -b FAILREGEX ""FAILED|Error in""); ROOT_ADD_TEST(test-stressentrylist-interpreted COMMAND ${ROOT_root_CMD} -b -q -l ${CMAKE_CURRENT_SOURCE_DIR}/stressEntryList.cxx; FAILREGEX ""FAILED|Error in"" DEPENDS test-stressentrylist). #--stressIterators---------------------------------------------------------------------------; ROOT_EXECUTABLE(stressIterators stressIterators.cxx LIBRARIES Core); ROOT_ADD_TEST(test-stressiterators COMMAND stressIterators FAILREGEX ""FAILED|Error in""); ROOT_ADD_TEST(test-stressiterators-interpreted COMMAND ${ROOT_root_CMD} -b -q -l ${CMAKE_CURRENT_SOURCE_DIR}/stressIterators.cxx; FAILREGEX ""FAILED|Error in"" DEPENDS test-stressiterators). #--stressInterpreter-------------------------------------------------------------------------; ROOT_EXECUTABLE(stressInterpreter stressInterpreter.cxx LIBRARIES Core); if(WIN32); set(cleantmpfiles POSTCMD cmd /c del AutoDict_*); endif(); ROOT_ADD_TEST(test-stressinterpreter COMMAND stressInterpreter; WORKING_DIR ${CMAKE_BINARY_DIR}; PRECMD ${CMAKE_COMMAND} -E copy $",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/CMakeLists.txt:13700,test,test-stressentrylist,13700,test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/CMakeLists.txt,2,['test'],"['test-stressentrylist', 'test-stressentrylist-interpreted']"
Testability, ROOT_EXECUTABLE(testActivationFunctionsCpu TestActivationFunctionsCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Activation-Functions-Cpu COMMAND testActivationFunctionsCpu). # DNN - Loss Functions CPU; ROOT_EXECUTABLE(testLossFunctionsCpu TestLossFunctionsCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Loss-Functions-Cpu COMMAND testLossFunctionsCpu). # DNN - Derivatives CPU; ROOT_EXECUTABLE(testDerivativesCpu TestDerivativesCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Derivatives-Cpu COMMAND testDerivativesCpu). # DNN - Backpropagation CPU; ROOT_EXECUTABLE(testBackpropagationCpu TestBackpropagationCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Backpropagation-Cpu COMMAND testBackpropagationCpu). # DNN - BackpropagationDL CPU; ROOT_EXECUTABLE(testBackpropagationDLCpu TestBackpropagationDLCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Backpropagation-DL-Cpu COMMAND testBackpropagationDLCpu). # DNN - Batch normalization; ROOT_EXECUTABLE(testBatchNormalizationCpu TestBatchNormalizationCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-BatchNormalization-Cpu COMMAND testBatchNormalizationCpu). # DNN - Optimization CPU; ROOT_EXECUTABLE(testOptimizationCpu TestOptimizationCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Optimization-Cpu COMMAND testOptimizationCpu). # DNN - MethodDL SGD Optimization CPU; ROOT_EXECUTABLE(testMethodDLSGDOptimizationCpu TestMethodDLSGDOptimizationCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-MethodDL-SGD-Optimization-Cpu COMMAND testMethodDLSGDOptimizationCpu). # DNN - MethodDL Adam Optimization CPU; ROOT_EXECUTABLE(testMethodDLAdamOptimizationCpu TestMethodDLAdamOptimizationCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-MethodDL-Adam-Optimization-Cpu COMMAND testMethodDLAdamOptimizationCpu TIMEOUT 1800). # DNN - MethodDL Adagrad Optimization CPU; ROOT_EXECUTABLE(testMethodDLAdagradOptimizationCpu TestMethodDLAdagradOptimizationCpu.cxx LIBRARIES ${Libraries}); ROO,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt:5204,test,testBatchNormalizationCpu,5204,tmva/tmva/test/DNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt,1,['test'],['testBatchNormalizationCpu']
Testability, ROOT_EXECUTABLE(testReshape TestReshape.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Reshape COMMAND testReshape). ROOT_EXECUTABLE(testRotWeights TestRotateWeights.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-RotWeights COMMAND testRotWeights). #-- features not implemeted in ref architectures; #ROOT_EXECUTABLE(testForwardPass TestForwardPass.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-CNN-Forward COMMAND testForwardPass). #ROOT_EXECUTABLE(testConvNetLoss TestConvNetLoss.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-CNN-Loss COMMAND testConvNetLoss). #ROOT_EXECUTABLE(testConvNetPred TestConvNetPrediction.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-CNN-Pred COMMAND testConvNetPred). #ROOT_EXECUTABLE(testDLMinimization TestMinimization.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-CNN-Minimization COMMAND testDLMinimization). #ROOT_EXECUTABLE(testTensorDataLoader TestTensorDataLoader.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-Tensor-Data-Loader COMMAND testTensorDataLoader). endif(). #--- CPU tests. ----------------------------; if ((BLAS_FOUND OR mathmore) AND imt AND tmva-cpu). ROOT_EXECUTABLE(testIm2ColCpu TestIm2ColCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Im2Col-CPU COMMAND testIm2ColCpu). ROOT_EXECUTABLE(testPoolingLayerCpu TestPoolingLayerCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-PoolingLayer-CPU COMMAND testPoolingLayerCpu). ROOT_EXECUTABLE(testConvLayerCpu TestConvLayerCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-ConvLayer-CPU COMMAND testConvLayerCpu). ROOT_EXECUTABLE(testRotWeightsCpu TestRotateWeightsCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-RotWeights-CPU COMMAND testRotWeightsCpu). ROOT_EXECUTABLE(testForwardPassCpu TestForwardPassCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Forward-CPU COMMAND testForwardPassCpu). ROOT_EXECUTABLE(testConvNetLossCpu TestConvNetLossCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TES,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt:4711,test,testTensorDataLoader,4711,tmva/tmva/test/DNN/CNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt,1,['test'],['testTensorDataLoader']
Testability," RooFit::Detail::CodeSquashContext. b - RooFuncWrapper. ### a. RooFit::Detail::CodeSquashContext. > [roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h](https://github.com/root-project/root/blob/master/roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h). It handles how to create a C++ function out of the compute graph (which is; created with different RooFit classes). This C++ function will be independent; of these RooFit classes. RooFit::Detail::CodeSquashContext helps traverse the compute graph received from RooFit and; then it translates that into a single piece of code (a C++ function), that can; then be differentiated using Clad. It also helps evaluate the model. In RooFit, evaluation is done using the 'evaluate()' function. It also; performs a lot of book-keeping, caching, etc. that is required for RooFit (but; not necessarily for AD). A new `translate()` function is added to RooFit classes that includes a call; to this `evaluate()` function. `translate()` helps implement the Code; Squashing logic. All RooFit classes that should support AD need to use this; function. It creates a string of code, which is then just-in-time compiled; using Cling (C++ interpreter for ROOT). For each of the `translate()`; functions, it is important to call `addResult()` since this is what enables; the squashing to happen. #### Helper Functions. - **RooFit::Detail::CodeSquashContext**: this class maintains the context for squashing of; RooFit models into code. It keeps track of the results of various; expressions to avoid redundant calculations. - **Loop Scopes()**: `beginloop()` and `endloop()` are used to create a scope; for iterating over vector observables (collections of data). This is; especially useful when dealing with data that comes in sets or arrays. - **addToGlobalScope()**: helps add code statements to the global scope; (e.g., to declare variables). - **addToCodeBody()**: adds the input string to the squashed code body. If a; class implements a translate funct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:30808,log,logic,30808,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['log'],['logic']
Testability," SPIR-V binaries, Clang uses the external ``llvm-spirv`` tool from the; `SPIRV-LLVM-Translator repo; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_. Prior to the generation of SPIR-V binary with Clang, ``llvm-spirv``; should be built or installed. Please refer to `the following instructions; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#build-instructions>`_; for more details. Clang will expect the ``llvm-spirv`` executable to; be present in the ``PATH`` environment variable. Clang uses ``llvm-spirv``; with `the widely adopted assembly syntax package; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/#build-with-spirv-tools>`_. `The versioning; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/releases>`_ of; ``llvm-spirv`` is aligned with Clang major releases. The same applies to the; main development branch. It is therefore important to ensure the ``llvm-spirv``; version is in alignment with the Clang version. For troubleshooting purposes; ``llvm-spirv`` can be `tested in isolation; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#test-instructions>`_. Example usage for OpenCL kernel compilation:. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:166513,test,tested,166513,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['test'],['tested']
Testability, Surya S Dwivedi; ############################################################################. set(Libraries TMVA). # LSTM - Forward Reference; #ROOT_EXECUTABLE(testLSTMForwardPass TestLSTMForwardPass.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-LSTM-Forward COMMAND testLSTMForwardPass). # LSTM - Backpropagation Reference; #ROOT_EXECUTABLE(testLSTMBackpropagation TestLSTMBackpropagation.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-LSTM-Backpropagation COMMAND testLSTMBackpropagation). # LSTM - Full Test Reference; #ROOT_EXECUTABLE(testFullLSTM TestFullLSTM.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-LSTM-FullLSTM COMMAND testFullLSTM). #--- CUDA tests. ---------------------------; if (tmva-gpu AND tmva-cudnn); list(APPEND Libraries CUDA::cuda_driver CUDA::cudart). set(DNN_CUDA_LIBRARIES ${CUDA_CUBLAS_LIBRARIES} ). add_executable(testLSTMForwardPassCudnn TestLSTMForwardPassCudnn.cxx); target_link_libraries(testLSTMForwardPassCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-LSTM-Forwaed-Cudnn COMMAND testLSTMForwardPassCudnn). add_executable(testLSTMBackpropagationCudnn TestLSTMBackpropagationCudnn.cxx); target_link_libraries(testLSTMBackpropagationCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-LSTM-BackpropagationCudnn COMMAND testLSTMBackpropagationCudnn); # Test crashes on ubuntu2404-cuda-12.6.1. See root-project/root#16790:; set_tests_properties(TMVA-DNN-LSTM-BackpropagationCudnn PROPERTIES DISABLED True). # LSTM - Full Test GPU; add_executable(testFullLSTMCudnn TestFullLSTMCudnn.cxx); target_link_libraries(testFullLSTMCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-LSTM-Full-Cudnn COMMAND testFullLSTMCudnn). endif (tmva-gpu AND tmva-cudnn). #--- CPU tests. ----------------------------; if (BLAS_FOUND AND imt). # LSTM - Forward CPU; ROOT_EXECUTABLE(testLSTMForwardPassCpu TestLSTMForwardPassCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-LSTM-Forward-Cpu COMMAND testLSTMForwardP,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/CMakeLists.txt:1089,test,testLSTMForwardPassCudnn,1089,tmva/tmva/test/DNN/LSTM/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/CMakeLists.txt,2,['test'],['testLSTMForwardPassCudnn']
Testability," TProof::AddInputData(TObject *); if the input-data objects are in a; file you can use TProof::SetInputDataFile(const char *file); the final; set of input-data objects is assembled from the objects added via; AddInputData and those found in the file defined bySetInputDataFile.  . Improvements:. More; complete set of tests in test/stressProof . To run with PROOF-Lite pass; the argument 'lite' as master URL, e.g. './stressProof lite'.Possibility; to control on the client via rc variable the location of the sandbox,; package directory, cache and dataset directory (the latters two only; for PROOF-Lite); the variable names are 'Proof.Sandbox', ; 'Proof.PackageDir', 'Proof.CacheDir' and 'Proof.DataSetDir'. The default location of the sandbox has been changed from ""~/proof"" to ""~/.proof"" to avoid interferences with possible users' working areas.XrdProofd plug-in. Overall refactorization for easier; maintainance and improved solidity; Improved format of printout messages: all information; messages contain now the tag 'xpd-I' and all error messages the; tag 'xpd-E', so that they can easily be grepped out from the; log file.; . Log sending. Implement selective sending of logs from workers to master to avoid duplicating; too many text lines on the master log. Logs are now sent only after Exec, Print; requests and in case an error (level >= kError) occured. Of course, the full; logs can always be retrieved via TProofMgr::GetSessionLogs; . Log retrieval:. for 'grep' operations, use the system 'grep' command; via 'popen'; instead of a handmade filtering; this implies that the full grep; functionality is now available; set the default number of displayed lines to 100; instead of 10. Improve diagnostic in case of worker death: clients will; now; receive a message containing the low level reason for the failure and a; hint for getting more informationIn; TProofOutputFile, support the ""<user>"" and ""<group>""; placeholders in the output file name to automatically re-direct the; output ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:4735,log,log,4735,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,1,['log'],['log']
Testability, TestConvBackpropagationCudnn.cxx); target_link_libraries(testConvBackpropagationCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ConvBackpropagationCudnn COMMAND testConvBackpropagationCudnn). add_executable(testConvLayerCudnn TestConvLayerCudnn.cxx); target_link_libraries(testConvLayerCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ConvLayerCudnn COMMAND testConvLayerCudnn). add_executable(testPoolingLayerCudnn TestPoolingLayerCudnn.cxx); target_link_libraries(testPoolingLayerCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-PoolingLayerCudnn COMMAND testPoolingLayerCudnn). # test mixed architecture Cudnn Cpu; add_executable(testMixedArchitectures TestMixedArchitectures.cxx); target_link_libraries(testMixedArchitectures ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-MixedArchitectures COMMAND testMixedArchitectures). endif(). include_directories(${CUDA_INCLUDE_DIRS}). endif(). #-- -test of reference architecture; if (Test_Reference). ROOT_EXECUTABLE(testIm2Col TestIm2Col.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Im2Col COMMAND testIm2Col). ROOT_EXECUTABLE(testPoolingLayer TestPoolingLayer.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-PoolingLayer COMMAND testPoolingLayer). ROOT_EXECUTABLE(testReshape TestReshape.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Reshape COMMAND testReshape). ROOT_EXECUTABLE(testRotWeights TestRotateWeights.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-RotWeights COMMAND testRotWeights). #-- features not implemeted in ref architectures; #ROOT_EXECUTABLE(testForwardPass TestForwardPass.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-CNN-Forward COMMAND testForwardPass). #ROOT_EXECUTABLE(testConvNetLoss TestConvNetLoss.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-CNN-Loss COMMAND testConvNetLoss). #ROOT_EXECUTABLE(testConvNetPred TestConvNetPrediction.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt:3362,test,test,3362,tmva/tmva/test/DNN/CNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt,1,['test'],['test']
Testability, TestConvNetPrediction.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-CNN-Pred COMMAND testConvNetPred). #ROOT_EXECUTABLE(testDLMinimization TestMinimization.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-CNN-Minimization COMMAND testDLMinimization). #ROOT_EXECUTABLE(testTensorDataLoader TestTensorDataLoader.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-Tensor-Data-Loader COMMAND testTensorDataLoader). endif(). #--- CPU tests. ----------------------------; if ((BLAS_FOUND OR mathmore) AND imt AND tmva-cpu). ROOT_EXECUTABLE(testIm2ColCpu TestIm2ColCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Im2Col-CPU COMMAND testIm2ColCpu). ROOT_EXECUTABLE(testPoolingLayerCpu TestPoolingLayerCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-PoolingLayer-CPU COMMAND testPoolingLayerCpu). ROOT_EXECUTABLE(testConvLayerCpu TestConvLayerCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-ConvLayer-CPU COMMAND testConvLayerCpu). ROOT_EXECUTABLE(testRotWeightsCpu TestRotateWeightsCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-RotWeights-CPU COMMAND testRotWeightsCpu). ROOT_EXECUTABLE(testForwardPassCpu TestForwardPassCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Forward-CPU COMMAND testForwardPassCpu). ROOT_EXECUTABLE(testConvNetLossCpu TestConvNetLossCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Loss-CPU COMMAND testConvNetLossCpu). ROOT_EXECUTABLE(testConvNetPredCpu TestConvNetPredictionCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Pred-CPU COMMAND testConvNetPredCpu). ROOT_EXECUTABLE(testReshapeCpu TestReshapeCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Reshape-CPU COMMAND testReshapeCpu). #-- need to be fixed; #ROOT_EXECUTABLE(testTensorDataLoaderCpu TestTensorDataLoaderCpu.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-Tensor-Data-Loader-CPU COMMAND testTensorDataLoaderCpu). #ROOT_EXECUTABLE(testDLMinimizationCpu TestMinimizationCpu.cxx LIBRARIES ${Libraries,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt:5298,test,testRotWeightsCpu,5298,tmva/tmva/test/DNN/CNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt,1,['test'],['testRotWeightsCpu']
Testability," Tests are identified by the test suite they are contained within, and the; relative path inside that suite. Note that the relative path may not refer to; an actual file on disk; some test formats (such as *GoogleTest*) define; ""virtual tests"" which have a path that contains both the path to the actual; test file and a subpath to identify the virtual test. .. _local-configuration-files:. LOCAL CONFIGURATION FILES; ~~~~~~~~~~~~~~~~~~~~~~~~~. When :program:`lit` loads a subdirectory in a test suite, it instantiates a; local test configuration by cloning the configuration for the parent directory; --- the root of this configuration chain will always be a test suite. Once the; test configuration is cloned :program:`lit` checks for a *lit.local.cfg* file; in the subdirectory. If present, this file will be loaded and can be used to; specialize the configuration for each individual directory. This facility can; be used to define subdirectories of optional tests, or to change other; configuration parameters --- for example, to change the test format, or the; suffixes which identify test files. SUBSTITUTIONS; ~~~~~~~~~~~~~. :program:`lit` allows patterns to be substituted inside RUN commands. It also; provides the following base set of substitutions, which are defined in; TestRunner.py:. ======================= ==============; Macro Substitution; ======================= ==============; %s source path (path to the file currently being run); %S source dir (directory of the file currently being run); %p same as %S; %{pathsep} path separator; %{fs-src-root} root component of file system paths pointing to the LLVM checkout; %{fs-tmp-root} root component of file system paths pointing to the test's temporary directory; %{fs-sep} file system path separator; %t temporary file name unique to the test; %basename_t The last path component of %t but without the ``.tmp`` extension; %T parent directory of %t (not unique, deprecated, do not use); %% %; %/s %s but ``\`` is replaced by ``/``;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:18793,test,tests,18793,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,3,['test'],"['test', 'tests']"
Testability," The PROOF core modules, however, are built. Namely, PROOF-Lite will be; available even when Xrootd is not.; New functionality. Creating PAR packages from ROOT data files: it is now possible to; use TFile::MakeProject to create a PAR file to read the file.; Add support for backend-dependent record formatting of PROOF monitoring.; This is achieved by introducing a new layer, described by the abstract; interface TProofMonSender, with the record format defined in the backend; implemenation (currently TProofMonSenderML, for MonaLisa, and; TProofMonSenderSQL, for SQL backends). Currently three types of records; are sent: 'summary' (derived from what was currently posted), 'dataset',; with entries per dataset processed in the query, and 'files', with; entries per file processed in the query. In SQL terms, each of this; records corresponds to a different table. Sending of any of the three; records can be toggled independently.; In TProofMgr, add 'ping' functionality to test in non-blocking way if; a PROOF service is listening at a given port of a given host.; Improvements. In PROOF-Bench, file generation, add the possibility to change; only the generating function, passed as TMacro. Add also check on the; free space on the device and skip file generation if less than 10% or; less than 1 GB.; Record in TStatus also the max memory usage on the master and printed; via TStatus::Print; this allow a quick visualisation of the overall; memory usage at the end of the query.; Import version 0.9.6 of afdsmgrd; Make sure that the name(s) of the processed dataset(s) are registered; in the TFileInfo objects being processed, so that it can be used for; monitoring.; In XrdProofd, add possibility to skip the checks for the data; directories during session startup, as they may significantly slowdown; the startup process is the medium is busy. In such a case, admins; are responsible to create the directories in advance; the session; releated part fo the path is created by the session once u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html:1189,test,test,1189,proof/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html,1,['test'],['test']
Testability," The feature tag is described along with the language feature below. The feature name or extension name can also be specified with a preceding and; following ``__`` (double underscore) to avoid interference from a macro with; the same name. For instance, ``__cxx_rvalue_references__`` can be used instead; of ``cxx_rvalue_references``. ``__has_cpp_attribute``; -----------------------. This function-like macro is available in C++20 by default, and is provided as an; extension in earlier language standards. It takes a single argument that is the; name of a double-square-bracket-style attribute. The argument can either be a; single identifier or a scoped identifier. If the attribute is supported, a; nonzero value is returned. If the attribute is a standards-based attribute, this; macro returns a nonzero value based on the year and month in which the attribute; was voted into the working draft. See `WG21 SD-6; <https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations>`_; for the list of values returned for standards-based attributes. If the attribute; is not supported by the current compilation target, this macro evaluates to 0.; It can be used like this:. .. code-block:: c++. #ifndef __has_cpp_attribute // For backwards compatibility; #define __has_cpp_attribute(x) 0; #endif. ...; #if __has_cpp_attribute(clang::fallthrough); #define FALLTHROUGH [[clang::fallthrough]]; #else; #define FALLTHROUGH; #endif; ... The attribute scope tokens ``clang`` and ``_Clang`` are interchangeable, as are; the attribute scope tokens ``gnu`` and ``__gnu__``. Attribute tokens in either; of these namespaces can be specified with a preceding and following ``__``; (double underscore) to avoid interference from a macro with the same name. For; instance, ``gnu::__const__`` can be used instead of ``gnu::const``. ``__has_c_attribute``; ---------------------. This function-like macro takes a single argument that is the name of an; attribute exposed with the double square-bracke",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:5537,test,test-recommendations,5537,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['test'],['test-recommendations']
Testability," The logical view includes the following **logical elements**: *type*,; *scope*, *symbol* and *line*, which are the basic software elements used; in the C/C++ programming language. Each logical element has a set of; **attributes**, such as *types*, *classes*, *functions*, *variables*,; *parameters*, etc. The :option:`--attribute` can be used to specify which; attributes to include when printing a logical element. A logical element; may have a **kind** that describes specific types of elements. For; instance, a *scope* could have a kind value of *function*, *class*,; *namespace*. :program:`llvm-debuginfo-analyzer` defaults to print a pre-defined; layout of logical elements and attributes. The command line options can; be used to control the printed elements (:option:`--print`), using a; specific layout (:option:`--report`), matching a given pattern; (:option:`--select`, :option:`--select-offsets`). Also, the output can; be limited to specified logical elements using (:option:`--select-lines`,; :option:`--select-scopes`, :option:`--select-symbols`,; :option:`--select-types`). :program:`llvm-debuginfo-analyzer` can also compare a set of logical; views (:option:`--compare`), to find differences and identify possible; debug information syntax issues (:option:`--warning`) in any object file. OPTIONS; -------; :program:`llvm-debuginfo-analyzer` options are separated into several; categories, each tailored to a different purpose:. * :ref:`general_` - Standard LLVM options to display help, version, etc.; * :ref:`attributes_` - Describe how to include different details when; printing an element.; * :ref:`print_` - Specify which elements will be included when printing; the view.; * :ref:`output_` - Describe the supported formats when printing the view.; * :ref:`report_` - Describe the format layouts for view printing.; * :ref:`select_` - Allows to use specific criteria or conditions to; select which elements to print.; * :ref:`compare_` - Compare logical views and print missin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:2069,log,logical,2069,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['log'],['logical']
Testability," The recommended way to examine output to figure out if the test passes is using; the :doc:`FileCheck tool <CommandGuide/FileCheck>`. *[The usage of grep in RUN; lines is deprecated - please do not send or commit patches that use it.]*. Put related tests into a single file rather than having a separate file per; test. Check if there are files already covering your feature and consider; adding your code there instead of creating a new file. Generating assertions in regression tests; -----------------------------------------. Some regression test cases are very large and complex to write/update by hand.; In that case to reduce the human work we can use the scripts available in; llvm/utils/ to generate the assertions. For example to generate assertions in an :program:`llc`-based test, after; adding one or more RUN lines use:. .. code-block:: bash. % llvm/utils/update_llc_test_checks.py --llc-binary build/bin/llc test.ll. This will generate FileCheck assertions, and insert a ``NOTE:`` line at the; top to indicate that assertions were automatically generated. If you want to update assertions in an existing test case, pass the `-u` option; which first checks the ``NOTE:`` line exists and matches the script name. Sometimes a test absolutely depends on hand-written assertions and should not; have assertions automatically generated. In that case, add the text ``NOTE: Do; not autogenerate`` to the first line, and the scripts will skip that test. It; is a good idea to explain why generated assertions will not work for the test; so future developers will understand what is going on. These are the most common scripts and their purposes/applications in generating; assertions:. .. code-block:: none. update_analyze_test_checks.py; opt -passes='print<cost-model>'. update_cc_test_checks.py; C/C++, or clang/clang++ (IR checks). update_llc_test_checks.py; llc (assembly checks). update_mca_test_checks.py; llvm-mca. update_mir_test_checks.py; llc (MIR checks). update_test_checks.py; opt. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:11665,assert,assertions,11665,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,2,['assert'],['assertions']
Testability," The user code does not need to check if the API names are defined, because; these names are automatically replaced by ``(0)`` or the equivalence of noop; if the ``clang`` is not compiling for profile generation. Such replacement can happen because ``clang`` adds one of two macros depending; on the ``-fprofile-generate`` and the ``-fprofile-use`` flags. * ``__LLVM_INSTR_PROFILE_GENERATE``: defined when one of; ``-fprofile[-instr]-generate``/``-fcs-profile-generate`` is in effect.; * ``__LLVM_INSTR_PROFILE_USE``: defined when one of; ``-fprofile-use``/``-fprofile-instr-use`` is in effect. The two macros can be used to provide more flexibiilty so a user program; can execute code specifically intended for profile generate or profile use.; For example, a user program can have special logging during profile generate:. .. code-block:: c. #if __LLVM_INSTR_PROFILE_GENERATE; expensive_logging_of_full_program_state();; #endif. The logging is automatically excluded during a normal build of the program,; hence it does not impact performance during a normal execution. It is advised to use such fine tuning only in a program's cold regions. The weak; symbols can introduce extra control flow (the ``if`` checks), while the macros; (hence declarations they guard in ``profile/instr_prof_interface.h``); can change the control flow of the functions that use them between profile; generation and profile use (which can lead to discarded counters in such; functions). Using these APIs in the program's cold regions introduces less; overhead and leads to more optimized code. Disabling Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^. In certain situations, it may be useful to disable profile generation or use; for specific files in a build, without affecting the main compilation flags; used for the other files in the project. In these cases, you can use the flag ``-fno-profile-instr-generate`` (or; ``-fno-profile-generate``) to disable profile generation, and; ``-fno-profile-instr-use`` (or ``-fno-pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:114290,log,logging,114290,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['log'],['logging']
Testability," ThinLTO and PGO. All were built with `-march=haswell` to give access to BMI2; instructions, and benchmarks were run on large Haswell servers. We collected; data both with an `lfence`-based mitigation and load hardening as presented; here. The summary is that mitigating with load hardening is 1.77x faster than; mitigating with `lfence`, and the overhead of load hardening compared to a; normal program is likely between a 10% overhead and a 50% overhead with most; large applications seeing a 30% overhead or less. | Benchmark | `lfence` | Load Hardening | Mitigated Speedup |; | -------------------------------------- | -------: | -------------: | ----------------: |; | Google microbenchmark suite | -74.8% | -36.4% | **2.5x** |; | Large server QPS (using ThinLTO & PGO) | -62% | -29% | **1.8x** |. Below is a visualization of the microbenchmark suite results which helps show; the distribution of results that is somewhat lost in the summary. The y-axis is; a log-scale speedup ratio of load hardening relative to `lfence` (up -> faster; -> better). Each box-and-whiskers represents one microbenchmark which may have; many different metrics measured. The red line marks the median, the box marks; the first and third quartiles, and the whiskers mark the min and max. ![Microbenchmark result visualization](speculative_load_hardening_microbenchmarks.png). We don't yet have benchmark data on SPEC or the LLVM test suite, but we can; work on getting that. Still, the above should give a pretty clear; characterization of the performance, and specific benchmarks are unlikely to; reveal especially interesting properties. ### Future Work: Fine Grained Control and API-Integration. The performance overhead of this technique is likely to be very significant and; something users wish to control or reduce. There are interesting options here; that impact the implementation strategy used. One particularly appealing option is to allow both opt-in and opt-out of this; mitigation at reasonably fine gra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:48157,log,log-scale,48157,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['log'],['log-scale']
Testability," This is new method particularly useful for producing the expected limit bands where one needs to generate background-only pseudo-experiments in the same way that was used for the primary limit calculation. HypoTestResult. In the process of writing the new HypoTestInverter the conventions for p-values, CLb, CLs+b, and CLs were revisited. The situation is complicated by the fact that when performing a hypothesis test for discovery the null is background-only, but when performing an inverted hypothesis test the null is a signal+background model. The new convention is that the p-value for both the null and the alternate are taken from the same tail (as specified by the test statistic). Both CLs+b and CLb are equivalent to these p-values, and the HypoTestResult has a simple switch SetBackgroundIsAlt() to specify the pairing between (null p-value, alternate p-value) and (CLb, CLs+b). HypoTestInverter, HypoTestInverterResult, HypoTestInverterPlot. These classes have been rewritten for using them with the new hypothesis test calculators. The HypoTestInverter; class can now be constructed by any generic HypoTestCalculator, and both the HybridCalculator and the new; FrequentistCalculator are supported. The HypoTestInverter class can be constructed in two ways: either passing an; HypoTestCalculator and a data set or by passing the model for the signal, for the background and a data set.; In the first case the user configure the HypoTestCalculator before passing to the HypoTestInverter.; It must be configured using as null model the signal plus background model as alternate model the background; model. Optionally the user can pass the parameter to scan, if it is not passed, the first parameter of interest of the; null model will be used. In the second case (when passing directly the model and the data) the HypoTestInverter; can be configured to use either the frequentist or the hybrid calculator. The user can then configure the class; afterwards. For example set the test statis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html:3410,test,test,3410,roofit/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html,1,['test'],['test']
Testability," To compare, in English, we; live; > more or less happily with the absurd rules for ""to be"" (am, are, is, been,; > was, were, ...) and all attempts to simplify are treated with contempt or; > (preferably) humor. It be a curious world and it always beed."". Although you have to remember that his situation was considerably; different than ours. He was in a position where he was designing a high; level language that had to be COMPATIBLE with C. Our language is such; that a new person would have to learn the new, different, syntax; anyways. Making them learn about the type system does not seem like much; of a stretch from learning the opcodes and how SSA form works, and how; everything ties together... > > Basically, my argument for this type construction system is that it is; > > VERY simple to use and understand (although it IS different than C, it is; > > very simple and straightforward, which C is NOT). In fact, I would assert; > > that most programmers TODAY do not understand pointers to member; > > functions, and have to look up an example when they have to write them. > Again, I don't disagree with this at all. But to some extent this; > particular problem is inherently difficult. Your syntax for the above; > example may be easier for you to read because this is the way you have been; > thinking about it. Honestly, I don't find it much easier than the C syntax.; > In either case, I would have to look up an example to write pointers to; > member functions. I would argue that because the lexical structure of the language is self; consistent, any person who spent a significant amount of time programming; in LLVM directly would understand how to do it without looking it up in a; manual. The reason this does not work for C is because you rarely have to; declare these pointers, and the syntax is inconsistent with the method; declaration and calling syntax. > But pointers to member functions are nowhere near as common as arrays. Very true. If you're implementing an object",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt:1180,assert,assert,1180,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp4.txt,1,['assert'],['assert']
Testability," Tool developers, not on; end users of these tools. Clang Tools Organization; ========================. Clang Tools are CLI or GUI programs that are intended to be directly; used by C++ developers. That is they are *not* primarily for use by; Clang developers, although they are hopefully useful to C++ developers; who happen to work on Clang, and we try to actively dogfood their; functionality. They are developed in three components: the underlying; infrastructure for building a standalone tool based on Clang, core; shared logic used by many different tools in the form of refactoring and; rewriting libraries, and the tools themselves. The underlying infrastructure for Clang Tools is the; :doc:`LibTooling <LibTooling>` platform. See its documentation for much; more detailed information about how this infrastructure works. The; common refactoring and rewriting toolkit-style library is also part of; LibTooling organizationally. A few Clang Tools are developed along side the core Clang libraries as; examples and test cases of fundamental functionality. However, most of; the tools are developed in a side repository to provide easy separation; from the core libraries. We intentionally do not support public; libraries in the side repository, as we want to carefully review and; find good APIs for libraries as they are lifted out of a few tools and; into the core Clang library set. Regardless of which repository Clang Tools' code resides in, the; development process and practices for all Clang Tools are exactly those; of Clang itself. They are entirely within the Clang *project*,; regardless of the version control scheme. Core Clang Tools; ================. The core set of Clang tools that are within the main repository are; tools that very specifically complement, and allow use and testing of; *Clang* specific functionality. ``clang-check``; ---------------. :doc:`ClangCheck` combines the LibTooling framework for running a; Clang tool with the basic Clang diagnostics by synt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst:1846,test,test,1846,interpreter/llvm-project/clang/docs/ClangTools.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTools.rst,1,['test'],['test']
Testability," Treating the annotations as type; sugars means two types with incompatible external bounds annotations may be; considered canonically the same types. This is sometimes necessary, for example,; to make the ``__counted_by`` and friends not participate in function; overloading. However, this design requires a separate logic to walk through the; entire type hierarchy to check type compatibility of bounds annotations. Late parsing for C; ==================. A bounds annotation such as ``__counted_by(count)`` can be added to type of a; struct field declaration where count is another field of the same struct; declared later. Similarly, the annotation may apply to type of a function; parameter declaration which precedes the parameter count in the same function.; This means parsing the argument of bounds annotations must be done after the; parser has the whole context of a struct or a function declaration. Clang has; late parsing logic for C++ declaration attributes that require late parsing,; while the C declaration attributes and C/C++ type attributes do not have the; same logic. This requires introducing late parsing logic for C/C++ type; attributes. Internal bounds annotations; ===========================. ``__indexable`` and ``__bidi_indexable`` alter pointer representations to be; equivalent to a struct with the pointer and the corresponding bounds fields.; Despite this difference in their representations, they are still pointers in; terms of types of operations that are allowed and their semantics. For instance,; a pointer dereference on a ``__bidi_indexable`` pointer will return the; dereferenced value same as plain C pointers, modulo the extra bounds checks; being performed before dereferencing the wide pointer. This means mapping the; wide pointers to struct types with equivalent layout won’t be sufficient. To; represent the wide pointers in Clang AST, we add an extra field in the; PointerType class to indicate the internal bounds of the pointer. This ensures; poin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:1904,log,logic,1904,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,2,['log'],['logic']
Testability," We can finalize it later.; It seems like bugzilla and email don't meet security requirements. The medium used to host LLVM Security Group discussions is security-sensitive. It should therefore run on infrastructure which can meet our security expectations. We are currently using the `chromium issue tracker`_ (as the `llvm` project) to have security discussions:. * File security issues.; * Discuss security improvements to LLVM. When a new issue is filed, a template is provided to help issue reporters provide all relevant information. *FUTURE*: The `Github security`_ workflow allows publicly disclosing resolved security issues on the github project page, and we would be interested in adopting it for that purpose. However, it does not easily allow confidential reporting of security issues, as creating Github Security Advisories is currently restricted to Github project admins. That is why we have started with the `chromium issue tracker`_ instead. We also occasionally need to discuss logistics of the LLVM Security Group itself:. * Nominate new members.; * Propose member removal.; * Suggest policy changes. We often have these discussions publicly, in our :ref:`monthly public sync-up call <online-sync-ups>` and on the Discourse forums. For internal or confidential discussions, we also use a private mailing list. Process; =======. The following process occurs on the discussion medium for each reported issue:. * A security issue reporter (not necessarily an LLVM contributor) reports an issue.; * Within two business days, a member of the Security Group is put in charge of driving the issue to an acceptable resolution. This champion doesn’t need to be the same person for each issue. This person can self-nominate.; * Members of the Security Group discuss in which circumstances (if any) an issue is relevant to security, and determine if it is a security issue.; * Negotiate an embargo date for public disclosure, with a default minimum time limit of ninety days.; * Security Grou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:11695,log,logistics,11695,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['log'],['logistics']
Testability," When appending a ""++"", the class will be compiled and dynamically; loaded. ``` {.cpp}; root[] T->Process(""MySelector.C+"","""",1000,100);; ```. When appending a ""+"", the class will also be compiled and dynamically; loaded. When it is called again, it recompiles only if the macro; (`MySelector.C`) has changed since it was compiled last. If not, it; loads the existing library. The next example shows how to create a; selector with a pointer:. ``` {.cpp}; MySelector *selector = (MySelector *)TSelector::GetSelector(""MySelector.C+"");; T->Process(selector);; ```. `Using this form, you can do things like:`. ``` {.cpp}; selector->public_attribute1 = init_value;; for (int i=0; i<limit; i++) {; T->Process(selector);; selector->public_attribute1 =; function(selector->public_attribute2);; }; ```. `TTree::Process()` is aware of PROOF, ROOT parallel processing facility.; If PROOF is setup, it divides the processing amongst the slave CPUs. ### Performance Benchmarks; \index{benchmarks}. The program `$ROOTSYS/test/bench.cxx` compares the I/O performance of; STL vectors to the ROOT native **`TClonesArray`**`s` collection class.; It creates trees with and without compression for the following cases:; `vector<THit>`, `vector<THit*>`, `TClonesArray(`**`TObjHit`**`)`; not split `TClonesArray(`**`TObjHit`**`)` split. The next graphs show the two columns on the right which represent the split and; non-split **`TClonesArray`**, are significantly lower than the vectors. The most; significant difference is in reading a file without compression. The file size with compression, write times with and without compression; and the read times with and without compression all favor the; **`TClonesArray`**. ## Impact of Compression on I/O. This benchmark illustrates the pros and cons of the compression option.; We recommend using compression when the time spent in I/O is small; compared to the total processing time. In this case, if the I/O; operation is increased by a factor of 5 it is still a small pe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:135169,test,test,135169,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['test'],['test']
Testability," When calling 'clang_analyzer_warnOnDeadSymbol(x)', if value of 'x' is a; symbol, then this symbol is marked by the ExprInspection checker. Then,; during each garbage collection run, the checker sees if the marked symbol is; being collected and issues the 'SYMBOL DEAD' warning if it does.; This way you know where exactly, up to the line of code, the symbol dies. It is unlikely that you call this function after the symbol is already dead,; because the very reference to it as the function argument prevents it from; dying. However, if the argument is not a symbol but a concrete value,; no warning would be issued. Example usage::. do {; int x = generate_some_integer();; clang_analyzer_warnOnDeadSymbol(x);; } while(0); // expected-warning{{SYMBOL DEAD}}. - ``void clang_analyzer_explain(a single argument of any type);``. This function explains the value of its argument in a human-readable manner; in the warning message. You can make as many overrides of its prototype; in the test code as necessary to explain various integral, pointer,; or even record-type values. To simplify usage in C code (where overloading; the function declaration is not allowed), you may append an arbitrary suffix; to the function name, without affecting functionality. Example usage::. void clang_analyzer_explain(int);; void clang_analyzer_explain(void *);. // Useful in C code; void clang_analyzer_explain_int(int);. void foo(int param, void *ptr) {; clang_analyzer_explain(param); // expected-warning{{argument 'param'}}; clang_analyzer_explain_int(param); // expected-warning{{argument 'param'}}; if (!ptr); clang_analyzer_explain(ptr); // expected-warning{{memory address '0'}}; }. - ``void clang_analyzer_dump( /* a single argument of any type */);``. Similar to clang_analyzer_explain, but produces a raw dump of the value,; same as SVal::dump(). Example usage::. void clang_analyzer_dump(int);; void foo(int x) {; clang_analyzer_dump(x); // expected-warning{{reg_$0<x>}}; }. - ``size_t clang_analyzer_getEx",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:6608,test,test,6608,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,1,['test'],['test']
Testability," When describing the failure of static assertion of `==` expression, clang prints the integer; representation of the value as well as its character representation when; the user-provided expression is of character type. If the character is; non-printable, clang now shows the escpaed character.; Clang also prints multi-byte characters if the user-provided expression; is of multi-byte character type. *Example Code*:. .. code-block:: c++. static_assert(""A\n""[1] == U'🌍');. *BEFORE*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''; ' == 127757'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~. *AFTER*:. .. code-block:: text. source:1:15: error: static assertion failed due to requirement '""A\n""[1] == U'\U0001f30d''; 1 | static_assert(""A\n""[1] == U'🌍');; | ^~~~~~~~~~~~~~~~~; source:1:24: note: expression evaluates to ''\n' (0x0A, 10) == U'🌍' (0x1F30D, 127757)'; 1 | static_assert(""A\n""[1] == U'🌍');; | ~~~~~~~~~^~~~~~~~; - Clang now always diagnoses when using non-standard layout types in ``offsetof`` .; (`#64619 <https://github.com/llvm/llvm-project/issues/64619>`_); - Clang now diagnoses redefined defaulted constructor when redefined; defaulted constructor with different exception specs.; (`#69094 <https://github.com/llvm/llvm-project/issues/69094>`_); - Clang now diagnoses use of variable-length arrays in C++ by default (and; under ``-Wall`` in GNU++ mode). This is an extension supported by Clang and; GCC, but is very easy to accidentally use without realizing it's a; nonportable construct that has different semantics from a constant-sized; array. (`#62836 <https://github.com/llvm/llvm-project/issues/62836>`_). - Clang changed the order in which it displays candidate functions on overloading failures.; Previously, Clang used definition of ordering from the C++ Standard. The order defined in; t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:26544,assert,assertion,26544,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['assert'],['assertion']
Testability," When this option is; enabled, :program:`lit` will also automatically provide a ""``vg_leak``""; feature that can be used to conditionally disable (or expect failure in); certain tests. .. option:: --time-tests. Track the wall time individual tests take to execute and includes the results; in the summary output. This is useful for determining which tests in a test; suite take the most time to execute. .. option:: --ignore-fail. Exit with status zero even if some tests fail. .. _selection-options:. SELECTION OPTIONS; -----------------. By default, `lit` will run failing tests first, then run tests in descending; execution time order to optimize concurrency. The execution order can be; changed using the :option:`--order` option. The timing data is stored in the `test_exec_root` in a file named; `.lit_test_times.txt`. If this file does not exist, then `lit` checks the; `test_source_root` for the file to optionally accelerate clean builds. .. option:: --shuffle. Run the tests in a random order, not failing/slowest first. Deprecated,; use :option:`--order` instead. .. option:: --per-test-coverage. Emit the necessary test coverage data, divided per test case (involves; setting a unique value to LLVM_PROFILE_FILE for each RUN). The coverage; data files will be emitted in the directory specified by `config.test_exec_root`. .. option:: --max-failures N. Stop execution after the given number ``N`` of failures.; An integer argument should be passed on the command line; prior to execution. .. option:: --max-tests=N. Run at most ``N`` tests and then terminate. .. option:: --max-time=N. Spend at most ``N`` seconds (approximately) running tests and then terminate.; Note that this is not an alias for :option:`--timeout`; the two are; different kinds of maximums. .. option:: --num-shards=M. Divide the set of selected tests into ``M`` equal-sized subsets or; ""shards"", and run only one of them. Must be used with the; ``--run-shard=N`` option, which selects the shard to run. The environm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:5810,test,tests,5810,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['tests']
Testability," Windows, make sure your core.autocrlf setting; is false. Run CMake to generate the Visual Studio solution and project files:; ; cd llvm-project; mkdir build (for building without polluting the source dir); cd build. If you are using Visual Studio 2019:; cmake -DLLVM_ENABLE_PROJECTS=clang -G ""Visual Studio 16 2019"" -A x64 -Thost=x64 ..\llvm; -Thost=x64 is required, since the 32-bit linker will run out of memory.; ; To generate x86 binaries instead of x64, pass -A Win32.; See the LLVM CMake guide for; more information on other configuration options for CMake.; The above, if successful, will have created an LLVM.sln file in the; build directory.; . Build Clang:; ; Open LLVM.sln in Visual Studio.; Build the ""clang"" project for just the compiler driver and front end, or; the ""ALL_BUILD"" project to build everything, including tools. Try it out (assuming you added llvm/debug/bin to your path). (See the; running examples from above.); See ; Hacking on clang - Testing using Visual Studio on Windows for information; on running regression tests on Windows. Using Ninja alongside Visual Studio; We recommend that developers who want the fastest incremental builds use the; Ninja build system. You can use the; generated Visual Studio project files to edit Clang source code and generate a; second build directory next to it for running the tests with these steps:. Check out clang and LLVM as described above; Open a developer command prompt with the appropriate environment.; ; If you open the start menu and search for ""Command Prompt"", you should; see shortcuts created by Visual Studio to do this. To use native x64; tools, choose the one titled ""x64 Native Tools Command Prompt for VS; 2017"".; Alternatively, launch a regular cmd prompt and run the; appropriate vcvarsall.bat incantation. To get the 2017 x64 tools, this; would be:; ""C:\Program Files (x86)\Microsoft Visual; Studio\2017\Community\VC\Auxiliary\Build\vcvarsall.bat"" x64. mkdir build_ninja (or build, or use your own; organizat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:5518,test,tests,5518,interpreter/llvm-project/clang/www/get_started.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html,1,['test'],['tests']
Testability," You can generate an input MIR file for the test by using the ``-stop-after`` or; ``-stop-before`` option in llc. For example, if you would like to write a test; for the post register allocation pseudo instruction expansion pass, you can; specify the machine copy propagation pass in the ``-stop-after`` option, as it; runs just before the pass that we are trying to test:. ``llc -stop-after=machine-cp bug-trigger.ll -o test.mir``. If the same pass is run multiple times, a run index can be included; after the name with a comma. ``llc -stop-after=dead-mi-elimination,1 bug-trigger.ll -o test.mir``. After generating the input MIR file, you'll have to add a run line that uses; the ``-run-pass`` option to it. In order to test the post register allocation; pseudo instruction expansion pass on X86-64, a run line like the one shown; below can be used:. ``# RUN: llc -o - %s -mtriple=x86_64-- -run-pass=postrapseudos | FileCheck %s``. The MIR files are target dependent, so they have to be placed in the target; specific test directories (``lib/CodeGen/TARGETNAME``). They also need to; specify a target triple or a target architecture either in the run line or in; the embedded LLVM IR module. Simplifying MIR files; ^^^^^^^^^^^^^^^^^^^^^. The MIR code coming out of ``-stop-after``/``-stop-before`` is very verbose;; Tests are more accessible and future proof when simplified:. - Use the ``-simplify-mir`` option with llc. - Machine function attributes often have default values or the test works just; as well with default values. Typical candidates for this are: `alignment:`,; `exposesReturnsTwice`, `legalized`, `regBankSelected`, `selected`.; The whole `frameInfo` section is often unnecessary if there is no special; frame usage in the function. `tracksRegLiveness` on the other hand is often; necessary for some passes that care about block livein lists. - The (global) `liveins:` list is typically only interesting for early; instruction selection passes and can be removed when testing late",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:2790,test,test,2790,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['test'],['test']
Testability," Zaks and Jordan Rose presented at the; `2012 LLVM Developers' Meeting <https://llvm.org/devmtg/2012-11/>`_). .. code-block:: c. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. .. _alpha-unix-Stream:. alpha.unix.Stream (C); """"""""""""""""""""""""""""""""""""""""""; Check stream handling functions: ``fopen, tmpfile, fclose, fread, fwrite, fseek, ftell, rewind, fgetpos,``; ``fsetpos, clearerr, feof, ferror, fileno``. .. code-block:: c. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTerminated:. alpha.unix.cstring.NotNullTerminated (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for arguments which are not null-terminated strings; applies to: ``strlen, strnlen, strcpy, strncpy, strcat, strncat, wcslen, wcsnlen``. .. code-block:: c. void test() {; int y = strlen((char *)&test); // warn; }. .. _alpha-unix-cstring-OutOfBounds:. alpha.unix.cstring.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for out-of-bounds access in string functions, such as:; ``memcpy, bcopy, strcpy, strncpy,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:77519,test,test,77519,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability," [; {; ""Column"": 3,; ""Discriminator"": 0,; ""FileName"": ""/tmp/test.cpp"",; ""FunctionName"": ""foo()"",; ""Line"": 6,; ""StartAddress"": ""0x400486"",; ""StartFileName"": ""/tmp/test.cpp"",; ""StartLine"": 5; }; ]; }; ]. .. option:: --pretty-print, -p. Print human readable output. If :option:`--inlining` is specified, the; enclosing scope is prefixed by (inlined by).; For JSON output, the option will cause JSON to be indented and split over; new lines. Otherwise, the JSON output will be printed in a compact form. .. code-block:: console. $ llvm-symbolizer --obj=inlined.elf 0x4004be --inlining --pretty-print; baz() at /tmp/test.cpp:11:18; (inlined by) main at /tmp/test.cpp:15:0. .. option:: --print-address, --addresses, -a. Print address before the source code location. Defaults to false. .. code-block:: console. $ llvm-symbolizer --obj=inlined.elf --print-address 0x4004be; 0x4004be; baz(); /tmp/test.cpp:11:18; main; /tmp/test.cpp:15:0. $ llvm-symbolizer --obj=inlined.elf 0x4004be --pretty-print --print-address; 0x4004be: baz() at /tmp/test.cpp:11:18; (inlined by) main at /tmp/test.cpp:15:0. .. option:: --print-source-context-lines <N>. Print ``N`` lines of source context for each symbolized address. .. code-block:: console. $ llvm-symbolizer --obj=test.elf 0x400490 --print-source-context-lines=3; baz(); /tmp/test.cpp:11:0; 10 : volatile int k = 42;; 11 >: return foz() + k;; 12 : }. .. option:: --relativenames. Print the file's path relative to the compilation directory, instead; of the absolute path. If the command-line to the compiler included; the full path, this will be the same as the default. .. option:: --verbose. Print verbose address, line and column information. .. code-block:: console. $ llvm-symbolizer --obj=inlined.elf --verbose 0x4004be; baz(); Filename: /tmp/test.cpp; Function start filename: /tmp/test.cpp; Function start line: 9; Function start address: 0x4004b6; Line: 11; Column: 18; main; Filename: /tmp/test.cpp; Function start filename: /tmp/test.cpp; Function start ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst:11475,test,test,11475,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,1,['test'],['test']
Testability," [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:10648,test,test,10648,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['test'],['test']
Testability," ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::getRegisteredOptions`` function is designed to give a programmer; access to declared non-positional command line options so that how they appear; in ``-help`` can be modified prior to calling `cl::ParseCommandLineOptions`_.; Note this method should not be called during any static initialisation because; it cannot be guaranteed that all options will have been initialised. Hence it; should be called from ``main``. This function can be used to gain access to options declared in libraries that; the tool writer may not have direct access to. The function retrieves a :ref:`StringMap <dss_stringmap>` that maps the option; string (e.g. ``-help``) to an ``Option*``. Here is an example of how the function could be used:. .. code-block:: c++. using namespace llvm;; int main(int argc, char **argv) {; cl::OptionCategory AnotherCategory(""Some options"");. StringMap<cl::Option*> &Map = cl::getRegisteredOptions();. //Unhide useful option and put it in a different category; assert(Map.count(""print-all-options"") > 0);; Map[""print-all-options""]->setHiddenFlag(cl::NotHidden);; Map[""print-all-options""]->setCategory(AnotherCategory);. //Hide an option we don't want to see; assert(Map.count(""enable-no-infs-fp-math"") > 0);; Map[""enable-no-infs-fp-math""]->setHiddenFlag(cl::Hidden);. //Change --version to --show-version; assert(Map.count(""version"") > 0);; Map[""version""]->setArgStr(""show-version"");. //Change --help description; assert(Map.count(""help"") > 0);; Map[""help""]->setDescription(""Shows help"");. cl::ParseCommandLineOptions(argc, argv, ""This is a small program to demo the LLVM CommandLine API"");; ...; }. .. _cl::ParseCommandLineOptions:. The ``cl::ParseCommandLineOptions`` function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::ParseCommandLineOptions`` function is designed to be called directly; from ``main``, and is used to fill in the values of all of the command line; option variables once ``argc`` and ``argv`` are availa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:52274,assert,assert,52274,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['assert'],['assert']
Testability," _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""; Check when casting a malloc'ed type ``T``, whether the size is a multiple of the size of ``T``. .. code-block:: c. void test() {; int *x = (int *) malloc(11); // warn; }. .. _alpha-core-CastToStruct:. alpha.core.CastToStruct (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cast from non-struct pointer to struct pointer. .. code-block:: cpp. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. .. _alpha-core-Conversion:. alpha.core.Conversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Loss of sign/precision in implicit conversions. .. code-block:: c. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. .. _alp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:48147,test,test,48147,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability," _webkit-UncountedLambdaCapturesChecker:. webkit.UncountedLambdaCapturesChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Raw pointers and references to uncounted types can't be captured in lambdas. Only ref-counted types are allowed. .. code-block:: cpp. struct RefCntbl {; void ref() {}; void deref() {}; };. void foo(RefCntbl* a, RefCntbl& b) {; [&, a](){ // warn about 'a'; do_something(b); // warn about 'b'; };; };. .. _alpha-checkers:. Experimental Checkers; ---------------------. *These are checkers with known issues or limitations that keep them from being on by default. They are likely to have false positives. Bug reports and especially patches are welcome.*. alpha.clone; ^^^^^^^^^^^. .. _alpha-clone-CloneChecker:. alpha.clone.CloneChecker (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports similar pieces of code. .. code-block:: c. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. alpha.core; ^^^^^^^^^^. .. _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:47094,log,log,47094,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['log'],['log']
Testability," `GitHub Issues <https://github.com/llvm/llvm-project/issues>`_ that; result from your change. We prefer for this to be handled before submission but understand that it isn't; possible to test all of this for every submission. Our build bots and nightly; testing infrastructure normally finds these problems. A good rule of thumb is; to check the nightly testers for regressions the day after your change. Build; bots will directly email you if a group of commits that included yours caused a; failure. You are expected to check the build bot messages to see if they are; your fault and, if so, fix the breakage. Commits that violate these quality standards (e.g. are very broken) may be; reverted. This is necessary when the change blocks other developers from making; progress. The developer is welcome to re-commit the change after the problem has; been fixed. .. _commit messages:. Commit messages; ---------------. Although we don't enforce the format of commit messages, we prefer that; you follow these guidelines to help review, search in logs, email formatting; and so on. These guidelines are very similar to rules used by other open source; projects. Most importantly, the contents of the message should be carefully written to; convey the rationale of the change (without delving too much in detail). It; also should avoid being vague or overly specific. For example, ""bits were not; set right"" will leave the reviewer wondering about which bits, and why they; weren't right, while ""Correctly set overflow bits in TargetInfo"" conveys almost; all there is to the change. Below are some guidelines about the format of the message itself:. * Separate the commit message into title and body separated by a blank line. * If you're not the original author, ensure the 'Author' property of the commit is; set to the original author and the 'Committer' property is set to yourself.; You can use a command similar to; ``git commit --amend --author=""John Doe <jdoe@llvm.org>""`` to correct the; auth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:14969,log,logs,14969,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['log'],['logs']
Testability," ``%C`` example, the optimizer is; allowed to assume that the '``undef``' operand could be the same as; ``%Y`` if ``%Y`` is provably not '``poison``', allowing the whole '``select``'; to be eliminated. This is because '``poison``' is stronger than '``undef``'. .. code-block:: llvm. %A = xor undef, undef. %B = undef; %C = xor %B, %B. %D = undef; %E = icmp slt %D, 4; %F = icmp gte %D, 4. Safe:; %A = undef; %B = undef; %C = undef; %D = undef; %E = undef; %F = undef. This example points out that two '``undef``' operands are not; necessarily the same. This can be surprising to people (and also matches; C semantics) where they assume that ""``X^X``"" is always zero, even if; ``X`` is undefined. This isn't true for a number of reasons, but the; short answer is that an '``undef``' ""variable"" can arbitrarily change; its value over its ""live range"". This is true because the variable; doesn't actually *have a live range*. Instead, the value is logically; read from arbitrary registers that happen to be around when needed, so; the value is not necessarily consistent over time. In fact, ``%A`` and; ``%C`` need to have the same semantics or the core LLVM ""replace all; uses with"" concept would not hold. To ensure all uses of a given register observe the same value (even if; '``undef``'), the :ref:`freeze instruction <i_freeze>` can be used. .. code-block:: llvm. %A = sdiv undef, %X; %B = sdiv %X, undef; Safe:; %A = 0; b: unreachable. These examples show the crucial difference between an *undefined value*; and *undefined behavior*. An undefined value (like '``undef``') is; allowed to have an arbitrary bit-pattern. This means that the ``%A``; operation can be constant folded to '``0``', because the '``undef``'; could be zero, and zero divided by any value is zero.; However, in the second example, we can make a more aggressive; assumption: because the ``undef`` is allowed to be an arbitrary value,; we are allowed to assume that it could be zero. Since a divide by zero; has *undefined be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:194176,log,logically,194176,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['log'],['logically']
Testability," ``Kind`` check inside ``classof`` needs to be a bit more; complicated. The situation differs from the example above in that. * Since the class is concrete, it must itself have an entry in the ``Kind``; enum because it is possible to have objects with this class as a dynamic; type. * Since the class has children, the check inside ``classof`` must take them; into account. Say that ``SpecialSquare`` and ``OtherSpecialSquare`` derive; from ``Square``, and so ``ShapeKind`` becomes:. .. code-block:: c++. enum ShapeKind {; SK_Square,; + SK_SpecialSquare,; + SK_OtherSpecialSquare,; SK_Circle; }. Then in ``Square``, we would need to modify the ``classof`` like so:. .. code-block:: c++. - static bool classof(const Shape *S) {; - return S->getKind() == SK_Square;; - }; + static bool classof(const Shape *S) {; + return S->getKind() >= SK_Square &&; + S->getKind() <= SK_OtherSpecialSquare;; + }. The reason that we need to test a range like this instead of just equality; is that both ``SpecialSquare`` and ``OtherSpecialSquare`` ""is-a""; ``Square``, and so ``classof`` needs to return ``true`` for them. This approach can be made to scale to arbitrarily deep hierarchies. The; trick is that you arrange the enum values so that they correspond to a; preorder traversal of the class hierarchy tree. With that arrangement, all; subclass tests can be done with two comparisons as shown above. If you just; list the class hierarchy like a list of bullet points, you'll get the; ordering right::. | Shape; | Square; | SpecialSquare; | OtherSpecialSquare; | Circle. A Bug to be Aware Of; --------------------. The example just given opens the door to bugs where the ``classof``\s are; not updated to match the ``Kind`` enum when adding (or removing) classes to; (from) the hierarchy. Continuing the example above, suppose we add a ``SomewhatSpecialSquare`` as; a subclass of ``Square``, and update the ``ShapeKind`` enum like so:. .. code-block:: c++. enum ShapeKind {; SK_Square,; SK_SpecialSquare,; SK_Ot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst:8279,test,test,8279,interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,1,['test'],['test']
Testability," ``debugify``. Thus, modules with existing DI will be skipped. ``debugify`` can be used to test a backend, e.g:. .. code-block:: bash. $ opt -debugify < sample.ll | llc -o -. There is also a MIR-level debugify pass that can be run before each backend; pass, see:; :ref:`Mutation testing for MIR-level transformations<MIRDebugify>`. ``debugify`` in regression tests; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The output of the ``debugify`` pass must be stable enough to use in regression; tests. Changes to this pass are not allowed to break existing tests. .. note::. Regression tests must be robust. Avoid hardcoding line/variable numbers in; check lines. In cases where this can't be avoided (say, if a test wouldn't; be precise enough), moving the test to its own file is preferred. .. _MIRDebugify:. Test original debug info preservation in optimizations; ------------------------------------------------------. In addition to automatically generating debug info, the checks provided by; the ``debugify`` utility pass can also be used to test the preservation of; pre-existing debug info metadata. It could be run as follows:. .. code-block:: bash. # Run the pass by checking original Debug Info preservation.; $ opt -verify-debuginfo-preserve -pass-to-test sample.ll. # Check the preservation of original Debug Info after each pass.; $ opt -verify-each-debuginfo-preserve -O2 sample.ll. Limit number of observed functions to speed up the analysis:. .. code-block:: bash. # Test up to 100 functions (per compile unit) per pass.; $ opt -verify-each-debuginfo-preserve -O2 -debugify-func-limit=100 sample.ll. Please do note that running ``-verify-each-debuginfo-preserve`` on big projects; could be heavily time consuming. Therefore, we suggest using; ``-debugify-func-limit`` with a suitable limit number to prevent extremely long; builds. Furthermore, there is a way to export the issues that have been found into; a JSON file as follows:. .. code-block:: bash. $ opt -verify-debuginfo-preserve -verify-d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:13855,test,test,13855,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['test'],['test']
Testability," ``llvm/lib/ExecutionEngine/``. Libraries for directly executing bitcode at runtime in interpreted and; JIT-compiled scenarios. ``llvm/lib/Support/``. Source code that corresponding to the header files in ``llvm/include/ADT/``; and ``llvm/include/Support/``. ``llvm/bindings``; ----------------------. Contains bindings for the LLVM compiler infrastructure to allow; programs written in languages other than C or C++ to take advantage of the LLVM; infrastructure.; LLVM project provides language bindings for OCaml and Python. ``llvm/projects``; -----------------. Projects not strictly part of LLVM but shipped with LLVM. This is also the; directory for creating your own LLVM-based projects which leverage the LLVM; build system. ``llvm/test``; -------------. Feature and regression tests and other sanity checks on LLVM infrastructure. These; are intended to run quickly and cover a lot of territory without being exhaustive. ``test-suite``; --------------. A comprehensive correctness, performance, and benchmarking test suite; for LLVM. This comes in a ``separate git repository; <https://github.com/llvm/llvm-test-suite>``, because it contains a; large amount of third-party code under a variety of licenses. For; details see the :doc:`Testing Guide <TestingGuide>` document. .. _tools:. ``llvm/tools``; --------------. Executables built out of the libraries; above, which form the main part of the user interface. You can always get help; for a tool by typing ``tool_name -help``. The following is a brief introduction; to the most important tools. More detailed information is in; the `Command Guide <CommandGuide/index.html>`_. ``bugpoint``. ``bugpoint`` is used to debug optimization passes or code generation backends; by narrowing down the given test case to the minimum number of passes and/or; instructions that still cause a problem, whether it is a crash or; miscompilation. See `<HowToSubmitABug.html>`_ for more information on using; ``bugpoint``. ``llvm-ar``. The archiver produces ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:38232,benchmark,benchmarking,38232,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,2,"['benchmark', 'test']","['benchmarking', 'test']"
Testability," a ``RecordDecl`` AST node).; However, we can now define ``X::f`` out-of-line:. .. code-block:: c++. void X::f(int x = 17) { /* ... */ }. This definition of ""``f``"" has different lexical and semantic contexts. The; lexical context corresponds to the declaration context in which the actual; declaration occurred in the source code, e.g., the translation unit containing; ``X``. Thus, this declaration of ``X::f`` can be found by traversing the; declarations provided by [``decls_begin()``, ``decls_end()``) in the; translation unit. The semantic context of ``X::f`` corresponds to the class ``X``, since this; member function is (semantically) a member of ``X``. Lookup of the name ``f``; into the ``DeclContext`` associated with ``X`` will then return the definition; of ``X::f`` (including information about the default argument). Transparent Declaration Contexts; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In C and C++, there are several contexts in which names that are logically; declared inside another declaration will actually ""leak"" out into the enclosing; scope from the perspective of name lookup. The most obvious instance of this; behavior is in enumeration types, e.g.,. .. code-block:: c++. enum Color {; Red,; Green,; Blue; };. Here, ``Color`` is an enumeration, which is a declaration context that contains; the enumerators ``Red``, ``Green``, and ``Blue``. Thus, traversing the list of; declarations contained in the enumeration ``Color`` will yield ``Red``,; ``Green``, and ``Blue``. However, outside of the scope of ``Color`` one can; name the enumerator ``Red`` without qualifying the name, e.g.,. .. code-block:: c++. Color c = Red;. There are other entities in C++ that provide similar behavior. For example,; linkage specifications that use curly braces:. .. code-block:: c++. extern ""C"" {; void f(int);; void g(int);; }; // f and g are visible here. For source-level accuracy, we treat the linkage specification and enumeration; type as a declaration context in which its enclosed de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:79040,log,logically,79040,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['log'],['logically']
Testability," a binary with SSL; support. #### Ubuntu/Debian; On Debian, Ubuntu, Linux Mint, CrunchBang, or any other distro based on Debian; which supports APT package manager, you can install all the required packages by:; ```sh; sudo apt-get update; sudo apt-get install git g++ debhelper devscripts gnupg python; ```; You are not required to do this manually since CPT can do this for you automatically. ###### Setting up:; Make sure GnuPG is properly set up with your correct fingerprint. These; credentials are needed to sign the Debian package and create Debian changelogs.; On a build machine (Electric Commander), make sure the fingerprint is of the; user who is supposed to sign the official uploads. You might also want to; configure GnuPG to not ask for the passphrase while signing the Debian package. The [Ubuntu Packaging Guide] contains a quick guide on creating a GPG key on an; Ubuntu system. To test if you have successfully set up your GnuPG key, use the following command:; ```sh; gpg --fingerprint; ```; Again, all these checks are performed by default when you launch CPT with ```-c``` option.; [Ubuntu Packaging Guide]:http://packaging.ubuntu.com/html/getting-set-up.html#create-your-gpg-key. #### Windows; CPT is meant to be executed on cmd.exe prompt. Make sure you have set the; environment properly before continuing.; Below is a list of required packages for Windows (Win32-x86):. [MSYS Git] for Windows. [Python] for Windows. Microsoft Visual Studio 11 (2012), with Microsoft Visual C++ 2012. [MSYS Git]:http://msysgit.github.io/; [Python]:https://www.python.org/. ###### Setting Up:; Unlike other UNIX-like platforms, Windows requires you to follow some rules.; Do not ignore this section unless you want CPT to fail mid-way with wierd; errors. You should require these instructions only once. * While installing the packages make sure the executable is in a path that; doesn't contain spaces. For example, you should install Python in a path like. ```sh; C:\Python27; ```; rather t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md:3250,test,test,3250,interpreter/cling/tools/packaging/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md,1,['test'],['test']
Testability," a change in the; numbering, but because all optimizations above the limit are skipped this; is not a problem. When an opt-bisect index value refers to an entire invocation of the run; function for a pass, the pass will query whether or not it should be skipped; each time it is invoked and each invocation will be assigned a unique value.; For example, if a FunctionPass is used with a module containing three functions; a different index value will be assigned to the pass for each of the functions; as the pass is run. The pass may be run on two functions but skipped for the; third. If the pass internally performs operations on a smaller IR unit the pass must be; specifically instrumented to enable bisection at this finer level of granularity; (see below for details). Example Usage; =============. .. code-block:: console. $ opt -O2 -o test-opt.bc -opt-bisect-limit=16 test.ll. BISECT: running pass (1) Simplify the CFG on function (g); BISECT: running pass (2) SROA on function (g); BISECT: running pass (3) Early CSE on function (g); BISECT: running pass (4) Infer set function attributes on module (test.ll); BISECT: running pass (5) Interprocedural Sparse Conditional Constant Propagation on module (test.ll); BISECT: running pass (6) Global Variable Optimizer on module (test.ll); BISECT: running pass (7) Promote Memory to Register on function (g); BISECT: running pass (8) Dead Argument Elimination on module (test.ll); BISECT: running pass (9) Combine redundant instructions on function (g); BISECT: running pass (10) Simplify the CFG on function (g); BISECT: running pass (11) Remove unused exception handling info on SCC (<<null function>>); BISECT: running pass (12) Function Integration/Inlining on SCC (<<null function>>); BISECT: running pass (13) Deduce function attributes on SCC (<<null function>>); BISECT: running pass (14) Remove unused exception handling info on SCC (f); BISECT: running pass (15) Function Integration/Inlining on SCC (f); BISECT: running pass (16) Deduc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst:5424,test,test,5424,interpreter/llvm-project/llvm/docs/OptBisect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst,1,['test'],['test']
Testability," a change to Clang, so we; should build it. Finally, create a symlink (or a copy) of; llvm-project/build/compile-commands.json into llvm-project/:. .. code:: console. $ ln -s build/compile_commands.json ../. (This isn't strictly necessary for building and testing, but allows; tools like clang-tidy, clang-query, and clangd to work in your source; tree). Build and test; --------------. Finally, we can build the code! It's important to do this first, to; ensure we're in a good state before making changes. But what to build?; In ninja, you specify a **target**. If we just want to build the clang; binary, our target name is ""clang"" and we run:. .. code:: console. $ ninja clang. The first time we build will be very slow - Clang + LLVM is a lot of; code. But incremental builds are fast: ninja will only rebuild the parts; that have changed. When it finally finishes you should have a working; clang binary. Try running:. .. code:: console. $ bin/clang --version. There's also a target for building and running all the clang tests:. .. code:: console. $ ninja check-clang. This is a common pattern in LLVM: check-llvm is all the checks for core,; other projects have targets like check-lldb. Making changes; ==============. Edit; ----. We need to find the file containing the error message. .. code:: console. $ git grep ""all paths through this function"" ..; ../clang/include/clang/Basic/DiagnosticSemaKinds.td: ""all paths through this function will call itself"">,. The string that appears in DiagnosticSemaKinds.td is the one that is; printed by Clang. \*.td files define tables - in this case it's a list; of warnings and errors clang can emit and their messages. Let's update; the message in your favorite editor:. .. code:: console. $ vi ../clang/include/clang/Basic/DiagnosticSemaKinds.td. Find the message (it should be under; ``warn_infinite_recursive_function``). Change the message to ""in order to; understand recursion, you must first understand recursion"". Test again; ----------. To ver",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:5127,test,tests,5127,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['test'],['tests']
Testability," a function that throws an exception in order to unwind the JIT'd; code's stack. Now we can construct our CompileOnDemandLayer. Following the pattern from; previous layers we start by passing a reference to the next layer down in our; stack -- the OptimizeLayer. Next we need to supply a 'partitioning function':; when a not-yet-compiled function is called, the CompileOnDemandLayer will call; this function to ask us what we would like to compile. At a minimum we need to; compile the function being called (given by the argument to the partitioning; function), but we could also request that the CompileOnDemandLayer compile other; functions that are unconditionally called (or highly likely to be called) from; the function being called. For KaleidoscopeJIT we'll keep it simple and just; request compilation of the function that was called. Next we pass a reference to; our CompileCallbackManager. Finally, we need to supply an ""indirect stubs; manager builder"": a utility function that constructs IndirectStubManagers, which; are in turn used to build the stubs for the functions in each module. The; CompileOnDemandLayer will call the indirect stub manager builder once for each; call to addModule, and use the resulting indirect stubs manager to create; stubs for all functions in all modules in the set. If/when the module set is; removed from the JIT the indirect stubs manager will be deleted, freeing any; memory allocated to the stubs. We supply this function by using the; createLocalIndirectStubsManagerBuilder utility. .. code-block:: c++. // ...; if (auto Sym = CODLayer.findSymbol(Name, false)); // ...; return cantFail(CODLayer.addModule(std::move(Ms),; std::move(Resolver)));; // ... // ...; return CODLayer.findSymbol(MangledNameStream.str(), true);; // ... // ...; CODLayer.removeModule(H);; // ... Finally, we need to replace the references to OptimizeLayer in our addModule,; findSymbol, and removeModule methods. With that, we're up and running. **To be done:**. ** Chapter con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst:6944,stub,stubs,6944,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT3.rst,2,['stub'],['stubs']
Testability," a good idea to use a trailing wildcard to allow for; unexpected suffixes. Also, it's generally better to write regular expressions that use entire; triple components, than to do something clever to shorten them. For; example, to match both freebsd and netbsd in an expression, you could write; ``target={{.*(free|net)bsd.*}}`` and that would work. However, it would; prevent a ``grep freebsd`` from finding this test. Better to use:; ``target={{.+-freebsd.*}} || target={{.+-netbsd.*}}``. Substitutions; -------------. Besides replacing LLVM tool names the following substitutions are performed in; RUN lines:. ``%%``; Replaced by a single ``%``. This allows escaping other substitutions. ``%s``; File path to the test case's source. This is suitable for passing on the; command line as the input to an LLVM tool. Example: ``/home/user/llvm/test/MC/ELF/foo_test.s``. ``%S``; Directory path to the test case's source. Example: ``/home/user/llvm/test/MC/ELF``. ``%t``; File path to a temporary file name that could be used for this test case.; The file name won't conflict with other test cases. You can append to it; if you need multiple temporaries. This is useful as the destination of; some redirected output. Example: ``/home/user/llvm.build/test/MC/ELF/Output/foo_test.s.tmp``. ``%T``; Directory of ``%t``. Deprecated. Shouldn't be used, because it can be easily; misused and cause race conditions between tests. Use ``rm -rf %t && mkdir %t`` instead if a temporary directory is necessary. Example: ``/home/user/llvm.build/test/MC/ELF/Output``. ``%{pathsep}``. Expands to the path separator, i.e. ``:`` (or ``;`` on Windows). ``${fs-src-root}``; Expands to the root component of file system paths for the source directory,; i.e. ``/`` on Unix systems or ``C:\`` (or another drive) on Windows. ``${fs-tmp-root}``; Expands to the root component of file system paths for the test's temporary; directory, i.e. ``/`` on Unix systems or ``C:\`` (or another drive) on; Windows. ``${fs-sep}``; Expands t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:24233,test,test,24233,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['test']
Testability," a prefix. For; instance:. .. code-block:: c++. enum {; MaxSize = 42,; Density = 12; };. As an exception, classes that mimic STL classes can have member names in STL's; style of lower-case words separated by underscores (e.g. ``begin()``,; ``push_back()``, and ``empty()``). Classes that provide multiple; iterators should add a singular prefix to ``begin()`` and ``end()``; (e.g. ``global_begin()`` and ``use_begin()``). Here are some examples:. .. code-block:: c++. class VehicleMaker {; ...; Factory<Tire> F; // Avoid: a non-descriptive abbreviation.; Factory<Tire> Factory; // Better: more descriptive.; Factory<Tire> TireFactory; // Even better: if VehicleMaker has more than one; // kind of factories.; };. Vehicle makeVehicle(VehicleType Type) {; VehicleMaker M; // Might be OK if scope is small.; Tire Tmp1 = M.makeTire(); // Avoid: 'Tmp1' provides no information.; Light Headlight = M.makeLight(""head""); // Good: descriptive.; ...; }. Assert Liberally; ^^^^^^^^^^^^^^^^. Use the ""``assert``"" macro to its fullest. Check all of your preconditions and; assumptions, you never know when a bug (not necessarily even yours) might be; caught early by an assertion, which reduces debugging time dramatically. The; ""``<cassert>``"" header file is probably already included by the header files you; are using, so it doesn't cost anything to use it. To further assist with debugging, make sure to put some kind of error message in; the assertion statement, which is printed if the assertion is tripped. This; helps the poor debugger make sense of why an assertion is being made and; enforced, and hopefully what to do about it. Here is one complete example:. .. code-block:: c++. inline Value *getOperand(unsigned I) {; assert(I < Operands.size() && ""getOperand() out of range!"");; return Operands[I];; }. Here are more examples:. .. code-block:: c++. assert(Ty->isPointerType() && ""Can't allocate a non-pointer type!"");. assert((Opcode == Shl || Opcode == Shr) && ""ShiftInst Opcode invalid!"");. assert(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:44987,assert,assert,44987,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['assert'],['assert']
Testability," a sink node. Like; addTransition, this returns an ExplodedNode with the updated; state, which can then be passed to the BugReport constructor. After a BugReport is created, it should be passed to the analyzer core; by calling CheckerContext::emitReport. AST Visitors; Some checks might not require path-sensitivity to be effective. Simple AST walk; might be sufficient. If that is the case, consider implementing a Clang; compiler warning. On the other hand, a check might not be acceptable as a compiler; warning; for example, because of a relatively high false positive rate. In this; situation, AST callbacks checkASTDecl and; checkASTCodeBody are your best friends. Testing; Every patch should be well tested with Clang regression tests. The checker tests; live in clang/test/Analysis folder. To run all of the analyzer tests,; execute the following from the clang build directory:; ; $ bin/llvm-lit -sv ../llvm/tools/clang/test/Analysis; ; Useful Commands/Debugging Hints; Attaching the Debugger; When your command contains the -cc1 flag, you can attach the; debugger to it directly:. $ gdb --args clang -cc1 -analyze -analyzer-checker=core test.c; $ lldb -- clang -cc1 -analyze -analyzer-checker=core test.c. Otherwise, if your command line contains --analyze,; the actual clang instance would be run in a separate process. In; order to debug it, use the -### flag for obtaining; the command line of the child process:. $ clang --analyze test.c -\#\#\#. Below we describe a few useful command line arguments, all of which assume that; you are running clang -cc1. Narrowing Down the Problem; While investigating a checker-related issue, instruct the analyzer to only; execute a single checker:. $ clang -cc1 -analyze -analyzer-checker=osx.KeychainAPI test.c. If you are experiencing a crash, to see which function is failing while; processing a large file use the -analyzer-display-progress; option.; To selectively analyze only the given function, use the; -analyze-function option:. $ clang -c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:18806,test,test,18806,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['test'],['test']
Testability," a so-called sink node, a node from which no further analysis will be; performed. This is done by calling the ; CheckerContext::generateSink function; this function is the same as the; addTransition function, but marks the state as a sink node. Like; addTransition, this returns an ExplodedNode with the updated; state, which can then be passed to the BugReport constructor. After a BugReport is created, it should be passed to the analyzer core; by calling CheckerContext::emitReport. AST Visitors; Some checks might not require path-sensitivity to be effective. Simple AST walk; might be sufficient. If that is the case, consider implementing a Clang; compiler warning. On the other hand, a check might not be acceptable as a compiler; warning; for example, because of a relatively high false positive rate. In this; situation, AST callbacks checkASTDecl and; checkASTCodeBody are your best friends. Testing; Every patch should be well tested with Clang regression tests. The checker tests; live in clang/test/Analysis folder. To run all of the analyzer tests,; execute the following from the clang build directory:; ; $ bin/llvm-lit -sv ../llvm/tools/clang/test/Analysis; ; Useful Commands/Debugging Hints; Attaching the Debugger; When your command contains the -cc1 flag, you can attach the; debugger to it directly:. $ gdb --args clang -cc1 -analyze -analyzer-checker=core test.c; $ lldb -- clang -cc1 -analyze -analyzer-checker=core test.c. Otherwise, if your command line contains --analyze,; the actual clang instance would be run in a separate process. In; order to debug it, use the -### flag for obtaining; the command line of the child process:. $ clang --analyze test.c -\#\#\#. Below we describe a few useful command line arguments, all of which assume that; you are running clang -cc1. Narrowing Down the Problem; While investigating a checker-related issue, instruct the analyzer to only; execute a single checker:. $ clang -cc1 -analyze -analyzer-checker=osx.KeychainAPI test.c. If yo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:18632,test,tests,18632,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,2,['test'],"['test', 'tests']"
Testability," a specific bug in LLVM. The language they are; written in depends on the part of LLVM being tested. These tests are driven by; the :doc:`Lit <CommandGuide/lit>` testing tool (which is part of LLVM), and; are located in the ``llvm/test`` directory. Typically when a bug is found in LLVM, a regression test containing just; enough code to reproduce the problem should be written and placed; somewhere underneath this directory. For example, it can be a small; piece of LLVM IR distilled from an actual application or benchmark. Testing Analysis; ----------------. An analysis is a pass that infer properties on some part of the IR and not; transforming it. They are tested in general using the same infrastructure as the; regression tests, by creating a separate ""Printer"" pass to consume the analysis; result and print it on the standard output in a textual format suitable for; FileCheck.; See `llvm/test/Analysis/BranchProbabilityInfo/loop.ll <https://github.com/llvm/llvm-project/blob/main/llvm/test/Analysis/BranchProbabilityInfo/loop.ll>`_; for an example of such test. ``test-suite``; --------------. The test suite contains whole programs, which are pieces of code which; can be compiled and linked into a stand-alone program that can be; executed. These programs are generally written in high level languages; such as C or C++. These programs are compiled using a user specified compiler and set of; flags, and then executed to capture the program output and timing; information. The output of these programs is compared to a reference; output to ensure that the program is being compiled correctly. In addition to compiling and executing programs, whole program tests; serve as a way of benchmarking LLVM performance, both in terms of the; efficiency of the programs generated as well as the speed with which; LLVM compiles, optimizes, and generates code. The test-suite is located in the ``test-suite``; `repository on GitHub <https://github.com/llvm/llvm-test-suite.git>`_. See the :doc:`T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:3032,test,test,3032,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['test']
Testability, add_executable(testOptimizationCudnn TestOptimizationCudnn.cxx); TARGET_LINK_LIBRARIES(testOptimizationCudnn ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-Optimization-Cudnn COMMAND testOptimizationCudnn). # DNN - TensorDataLoader Cudnn; #add_executable(testTensorDataLoaderCudnn TestTensorDataLoaderCudnn.cxx); #TARGET_LINK_LIBRARIES(testTensorDataLoaderCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); #ROOT_ADD_TEST(TMVA-DNN-TensorDataLoaderCudnn COMMAND testTensorDataLoaderCudnn). endif(). endif (). #--- CPU tests. ----------------------------; #; # always run the Cpu tests. If tmva-cpu is off (no Blas or no imt); # they will work using TMatrix operations. # DNN - Arithmetic Functions CPU; ROOT_EXECUTABLE(testArithmeticCpu TestMatrixArithmeticCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Arithmetic-Cpu COMMAND testArithmeticCpu). # DNN - Activation Functions CPU; ROOT_EXECUTABLE(testActivationFunctionsCpu TestActivationFunctionsCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Activation-Functions-Cpu COMMAND testActivationFunctionsCpu). # DNN - Loss Functions CPU; ROOT_EXECUTABLE(testLossFunctionsCpu TestLossFunctionsCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Loss-Functions-Cpu COMMAND testLossFunctionsCpu). # DNN - Derivatives CPU; ROOT_EXECUTABLE(testDerivativesCpu TestDerivativesCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Derivatives-Cpu COMMAND testDerivativesCpu). # DNN - Backpropagation CPU; ROOT_EXECUTABLE(testBackpropagationCpu TestBackpropagationCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Backpropagation-Cpu COMMAND testBackpropagationCpu). # DNN - BackpropagationDL CPU; ROOT_EXECUTABLE(testBackpropagationDLCpu TestBackpropagationDLCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Backpropagation-DL-Cpu COMMAND testBackpropagationDLCpu). # DNN - Batch normalization; ROOT_EXECUTABLE(testBatchNormalizationCpu TestBatchNormalizationCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-BatchNormalization-Cpu COMM,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt:4363,test,testActivationFunctionsCpu,4363,tmva/tmva/test/DNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt,1,['test'],['testActivationFunctionsCpu']
Testability," add_llvm_install_targets(install-llvm-libraries; DEPENDS llvm-libraries; COMPONENT llvm-libraries); endif(). get_property(LLVM_LIBS GLOBAL PROPERTY LLVM_LIBS); if(LLVM_LIBS); list(REMOVE_DUPLICATES LLVM_LIBS); foreach(lib ${LLVM_LIBS}); add_dependencies(llvm-libraries ${lib}); if (NOT LLVM_ENABLE_IDE); add_dependencies(install-llvm-libraries install-${lib}); add_dependencies(install-llvm-libraries-stripped install-${lib}-stripped); endif(); endforeach(); endif(); endif(). # This must be at the end of the LLVM root CMakeLists file because it must run; # after all targets are created.; llvm_distribution_add_targets(); process_llvm_pass_plugins(GEN_CONFIG); include(CoverageReport). # This allows us to deploy the Universal CRT DLLs by passing -DCMAKE_INSTALL_UCRT_LIBRARIES=ON to CMake; if (MSVC AND CMAKE_HOST_SYSTEM_NAME STREQUAL ""Windows"" AND CMAKE_INSTALL_UCRT_LIBRARIES); include(InstallRequiredSystemLibraries); endif(). if (LLVM_INCLUDE_BENCHMARKS); # Override benchmark defaults so that when the library itself is updated these; # modifications are not lost.; set(BENCHMARK_ENABLE_TESTING OFF CACHE BOOL ""Disable benchmark testing"" FORCE); set(BENCHMARK_ENABLE_EXCEPTIONS OFF CACHE BOOL ""Disable benchmark exceptions"" FORCE); set(BENCHMARK_ENABLE_INSTALL OFF CACHE BOOL ""Don't install benchmark"" FORCE); set(BENCHMARK_DOWNLOAD_DEPENDENCIES OFF CACHE BOOL ""Don't download dependencies"" FORCE); set(BENCHMARK_ENABLE_GTEST_TESTS OFF CACHE BOOL ""Disable Google Test in benchmark"" FORCE); set(BENCHMARK_ENABLE_WERROR ${LLVM_ENABLE_WERROR} CACHE BOOL; ""Handle -Werror for Google Benchmark based on LLVM_ENABLE_WERROR"" FORCE); # Since LLVM requires C++11 it is safe to assume that std::regex is available.; set(HAVE_STD_REGEX ON CACHE BOOL ""OK"" FORCE); add_subdirectory(${LLVM_THIRD_PARTY_DIR}/benchmark; ${CMAKE_CURRENT_BINARY_DIR}/third-party/benchmark); add_subdirectory(benchmarks); endif(). if (LLVM_INCLUDE_UTILS AND LLVM_INCLUDE_TOOLS); add_subdirectory(utils/llvm-locstats); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:54007,benchmark,benchmark,54007,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,9,"['benchmark', 'test']","['benchmark', 'benchmarks', 'testing']"
Testability," although we run them much more often than nightly. Unit tests; ----------. Unit tests are written using `Google Test <https://github.com/google/googletest/blob/master/docs/primer.md>`_; and `Google Mock <https://github.com/google/googletest/blob/master/docs/gmock_for_dummies.md>`_; and are located in the ``llvm/unittests`` directory.; In general unit tests are reserved for targeting the support library and other; generic data structure, we prefer relying on regression tests for testing; transformations and analysis on the IR. Regression tests; ----------------. The regression tests are small pieces of code that test a specific; feature of LLVM or trigger a specific bug in LLVM. The language they are; written in depends on the part of LLVM being tested. These tests are driven by; the :doc:`Lit <CommandGuide/lit>` testing tool (which is part of LLVM), and; are located in the ``llvm/test`` directory. Typically when a bug is found in LLVM, a regression test containing just; enough code to reproduce the problem should be written and placed; somewhere underneath this directory. For example, it can be a small; piece of LLVM IR distilled from an actual application or benchmark. Testing Analysis; ----------------. An analysis is a pass that infer properties on some part of the IR and not; transforming it. They are tested in general using the same infrastructure as the; regression tests, by creating a separate ""Printer"" pass to consume the analysis; result and print it on the standard output in a textual format suitable for; FileCheck.; See `llvm/test/Analysis/BranchProbabilityInfo/loop.ll <https://github.com/llvm/llvm-project/blob/main/llvm/test/Analysis/BranchProbabilityInfo/loop.ll>`_; for an example of such test. ``test-suite``; --------------. The test suite contains whole programs, which are pieces of code which; can be compiled and linked into a stand-alone program that can be; executed. These programs are generally written in high level languages; such as C or C++. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:2335,test,test,2335,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['test']
Testability," an ``llvm::StringRef`` (equal to; ``llvm::StringRef()`` if the symbol has no name), and accessible via the; ``getName`` method. * ``Linkage`` is one of *Strong* or *Weak*, and is accessible via the; ``getLinkage`` method. The ``JITLinkContext`` can use this flag to determine; whether this symbol definition should be kept or dropped. * ``Scope`` is one of *Default*, *Hidden*, or *Local*, and is accessible via; the ``getScope`` method. The ``JITLinkContext`` can use this to determine; who should be able to see the symbol. A symbol with default scope should be; globally visible. A symbol with hidden scope should be visible to other; definitions within the same simulated dylib (e.g. ORC ``JITDylib``) or; executable, but not from elsewhere. A symbol with local scope should only be; visible within the current ``LinkGraph``. * ``Callable`` is a boolean which is set to true if this symbol can be called,; and is accessible via the ``isCallable`` method. This can be used to; automate the introduction of call-stubs for lazy compilation. * ``Live`` is a boolean that can be set to mark this symbol as root for; dead-stripping purposes (see :ref:`generic_link_algorithm`). JITLink's; dead-stripping algorithm will propagate liveness flags through the graph to; all reachable symbols before deleting any symbols (and blocks) that are not; marked live. * ``Edge`` -- A quad of an ``Offset`` (implicitly from the start of the; containing ``Block``), a ``Kind`` (describing the relocation type), a; ``Target``, and an ``Addend``. Edges represent relocations, and occasionally other relationships, between; blocks and symbols. * ``Offset``, accessible via ``getOffset``, is an offset from the start of the; ``Block`` containing the ``Edge``. * ``Kind``, accessible via ``getKind`` is a relocation type -- it describes; what kinds of changes (if any) should be made to block content at the given; ``Offset`` based on the address of the ``Target``. * ``Target``, accessible via ``getTarget``, is a pointe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:11134,stub,stubs,11134,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['stub'],['stubs']
Testability," analysis of each; individual test case. Defaults to OFF. **LLVM_BUILD_LLVM_DYLIB**:BOOL; If enabled, the target for building the libLLVM shared library is added.; This library contains all of LLVM's components in a single shared library.; Defaults to OFF. This cannot be used in conjunction with BUILD_SHARED_LIBS.; Tools will only be linked to the libLLVM shared library if LLVM_LINK_LLVM_DYLIB; is also ON.; The components in the library can be customised by setting LLVM_DYLIB_COMPONENTS; to a list of the desired components.; This option is not available on Windows. **LLVM_BUILD_TESTS**:BOOL; Include LLVM unit tests in the 'all' build target. Defaults to OFF. Targets; for building each unit test are generated in any case. You can build a; specific unit test using the targets defined under *unittests*, such as; ADTTests, IRTests, SupportTests, etc. (Search for ``add_llvm_unittest`` in; the subdirectories of *unittests* for a complete list of unit tests.) It is; possible to build all unit tests with the target *UnitTests*. **LLVM_BUILD_TOOLS**:BOOL; Build LLVM tools. Defaults to ON. Targets for building each tool are generated; in any case. You can build a tool separately by invoking its target. For; example, you can build *llvm-as* with a Makefile-based system by executing *make; llvm-as* at the root of your build directory. **LLVM_CCACHE_BUILD**:BOOL; If enabled and the ``ccache`` program is available, then LLVM will be; built using ``ccache`` to speed up rebuilds of LLVM and its components.; Defaults to OFF. The size and location of the cache maintained; by ``ccache`` can be adjusted via the LLVM_CCACHE_MAXSIZE and LLVM_CCACHE_DIR; options, which are passed to the CCACHE_MAXSIZE and CCACHE_DIR environment; variables, respectively. **LLVM_CREATE_XCODE_TOOLCHAIN**:BOOL; macOS Only: If enabled CMake will generate a target named; 'install-xcode-toolchain'. This target will create a directory at; $CMAKE_INSTALL_PREFIX/Toolchains containing an xctoolchain directory which ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:17085,test,tests,17085,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['test'],['tests']
Testability, analyzer checkers. .. option:: -gen-clang-comment-html-tags. Generate efficient matchers for HTML tag names that are used in; documentation comments. .. option:: -gen-clang-comment-html-tags-properties. Generate efficient matchers for HTML tag properties. .. option:: -gen-clang-comment-html-named-character-references. Generate function to translate named character references to UTF-8 sequences. .. option:: -gen-clang-comment-command-info. Generate command properties for commands that are used in documentation comments. .. option:: -gen-clang-comment-command-list. Generate list of commands that are used in documentation comments. .. option:: -gen-clang-opencl-builtins. Generate OpenCL builtin declaration handlers. .. option:: -gen-arm-neon. Generate ``arm_neon.h`` for Clang. .. option:: -gen-arm-fp16. Generate ``arm_fp16.h`` for Clang. .. option:: -gen-arm-bf16. Generate ``arm_bf16.h`` for Clang. .. option:: -gen-arm-neon-sema. Generate ARM NEON sema support for Clang. .. option:: -gen-arm-neon-test. Generate ARM NEON tests for Clang. .. option:: -gen-arm-sve-header. Generate ``arm_sve.h`` for Clang. .. option:: -gen-arm-sve-builtins. Generate ``arm_sve_builtins.inc`` for Clang. .. option:: -gen-arm-sve-builtin-codegen. Generate ``arm_sve_builtin_cg_map.inc`` for Clang. .. option:: -gen-arm-sve-typeflags. Generate ``arm_sve_typeflags.inc`` for Clang. .. option:: -gen-arm-sve-sema-rangechecks. Generate ``arm_sve_sema_rangechecks.inc`` for Clang. .. option:: -gen-arm-mve-header. Generate ``arm_mve.h`` for Clang. .. option:: -gen-arm-mve-builtin-def. Generate ARM MVE builtin definitions for Clang. .. option:: -gen-arm-mve-builtin-sema. Generate ARM MVE builtin sema checks for Clang. .. option:: -gen-arm-mve-builtin-codegen. Generate ARM MVE builtin code-generator for Clang. .. option:: -gen-arm-mve-builtin-aliases. Generate list of valid ARM MVE builtin aliases for Clang. .. option:: -gen-arm-cde-header. Generate ``arm_cde.h`` for Clang. .. option:: -gen-arm-cde-builtin,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst:6177,test,test,6177,interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/tblgen.rst,1,['test'],['test']
Testability," and *types* that; contain **'inte'** or **'movl'** in their names or types, using a tab; layout and given the number of matches. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level; --select-nocase --select-regex; --select=INTe --select=movl; --report=list; --print=symbols,types,instructions,summary; test-dwarf-clang.o. Logical View:; [000] {File} 'test-dwarf-clang.o'. [001] {CompileUnit} 'test.cpp'; [003] {Code} 'movl	$0x7, -0x1c(%rbp)'; [003] {Code} 'movl	$0x7, -0x4(%rbp)'; [003] {Code} 'movl	%eax, -0x4(%rbp)'; [003] {Code} 'movl	%esi, -0x14(%rbp)'; [003] {Code} 'movl	-0x14(%rbp), %eax'; [003] {Code} 'movl	-0x4(%rbp), %eax'; [003] 4 {TypeAlias} 'INTEGER' -> 'int'; [004] 5 {Variable} 'CONSTANT' -> 'const INTEGER'. -----------------------------; Element Total Found; -----------------------------; Scopes 3 0; Symbols 4 1; Types 2 1; Lines 17 6; -----------------------------; Total 26 8. COMPARISON MODE; ^^^^^^^^^^^^^^^; In this mode :program:`llvm-debuginfo-analyzer` compares logical views; to produce a report with the logical elements that are missing or added.; This a very powerful aid in finding semantic differences in the debug; information produced by different toolchain versions or even completely; different toolchains altogether (For example a compiler producing DWARF; can be directly compared against a completely different compiler that; produces CodeView). Given the previous example we found the above debug information issue; (related to the previous invalid scope location for the **'typedef int; INTEGER'**) by comparing against another compiler. Using GCC to generate test-dwarf-gcc.o, we can apply a selection pattern; with the printing mode to obtain the following logical view output. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level; --select-regex --select-nocase --select=INTe; --report=list; --print=symbols,types; test-dwarf-clang.o test-dwarf-gcc.o. Logical View:; [000] {File} 'test-dwarf-clang.o'. [001] {CompileUnit} 'test.cpp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:28021,log,logical,28021,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,2,['log'],['logical']
Testability," and don't; inherently leak data, this is expected to be prohibitively expensive given the; attack it is defending against. ## Implementation Details. There are a number of complex details impacting the implementation of this; technique, both on a particular architecture and within a particular compiler.; We discuss proposed implementation techniques for the x86 architecture and the; LLVM compiler. These are primarily to serve as an example, as other; implementation techniques are very possible. ### x86 Implementation Details. On the x86 platform we break down the implementation into three core; components: accumulating the predicate state through the control flow graph,; checking the loads, and checking control transfers between procedures. #### Accumulating Predicate State. Consider baseline x86 instructions like the following, which test three; conditions and if all pass, loads data from memory and potentially leaks it; through some side channel:; ```; # %bb.0: # %entry; pushq %rax; testl %edi, %edi; jne .LBB0_4; # %bb.1: # %then1; testl %esi, %esi; jne .LBB0_4; # %bb.2: # %then2; testl %edx, %edx; je .LBB0_3; .LBB0_4: # %exit; popq %rax; retq; .LBB0_3: # %danger; movl (%rcx), %edi; callq leak; popq %rax; retq; ```. When we go to speculatively execute the load, we want to know whether any of; the dynamically executed predicates have been misspeculated. To track that,; along each conditional edge, we need to track the data which would allow that; edge to be taken. On x86, this data is stored in the flags register used by the; conditional jump instruction. Along both edges after this fork in control flow,; the flags register remains alive and contains data that we can use to build up; our accumulated predicate state. We accumulate it using the x86 conditional; move instruction which also reads the flag registers where the state resides.; These conditional move instructions are known to not be predicted on any x86; processors, making them immune to misprediction tha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:15319,test,testl,15319,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['test'],['testl']
Testability," and handles error conditions in the same way. '``llvm.experimental.constrained.exp2``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.exp2(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.exp2``' intrinsic computes the base-2; exponential of the specified value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``exp2`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.log``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.log(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.log``' intrinsic computes the base-e; logarithm of the specified value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``log`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.log10``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.log10(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.log10``' intrinsic computes the base-10; logarithm of the specified value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:897136,log,log,897136,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['log'],['log']
Testability," and linked into a stand-alone program that can be; executed. These programs are generally written in high level languages; such as C or C++. These programs are compiled using a user specified compiler and set of; flags, and then executed to capture the program output and timing; information. The output of these programs is compared to a reference; output to ensure that the program is being compiled correctly. In addition to compiling and executing programs, whole program tests; serve as a way of benchmarking LLVM performance, both in terms of the; efficiency of the programs generated as well as the speed with which; LLVM compiles, optimizes, and generates code. The test-suite is located in the ``test-suite``; `repository on GitHub <https://github.com/llvm/llvm-test-suite.git>`_. See the :doc:`TestSuiteGuide` for details. Debugging Information tests; ---------------------------. The test suite contains tests to check quality of debugging information.; The test are written in C based languages or in LLVM assembly language. These tests are compiled and run under a debugger. The debugger output; is checked to validate of debugging information. See README.txt in the; test suite for more information. This test suite is located in the; ``cross-project-tests/debuginfo-tests`` directory. Quick start; ===========. The tests are located in two separate repositories. The unit and; regression tests are in the main ""llvm""/ directory under the directories; ``llvm/unittests`` and ``llvm/test`` (so you get these tests for free with the; main LLVM tree). Use ``make check-all`` to run the unit and regression tests; after building LLVM. The ``test-suite`` module contains more comprehensive tests including whole C; and C++ programs. See the :doc:`TestSuiteGuide` for details. Unit and Regression tests; -------------------------. To run all of the LLVM unit tests use the check-llvm-unit target:. .. code-block:: bash. % make check-llvm-unit. To run all of the LLVM regression tests use the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:4198,test,test,4198,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['test']
Testability," and links them together into a single module, called the test program. If any; LLVM passes are specified on the command line, it runs these passes on the test; program. If any of the passes crash, or if they produce malformed output (which; causes the verifier to abort), ``bugpoint`` starts the `crash debugger`_. Otherwise, if the ``-output`` option was not specified, ``bugpoint`` runs the; test program with the ""safe"" backend (which is assumed to generate good code) to; generate a reference output. Once ``bugpoint`` has a reference output for the; test program, it tries executing it with the selected code generator. If the; selected code generator crashes, ``bugpoint`` starts the `crash debugger`_ on; the code generator. Otherwise, if the resulting output differs from the; reference output, it assumes the difference resulted from a code generator; failure, and starts the `code generator debugger`_. Finally, if the output of the selected code generator matches the reference; output, ``bugpoint`` runs the test program after all of the LLVM passes have; been applied to it. If its output differs from the reference output, it assumes; the difference resulted from a failure in one of the LLVM passes, and enters the; `miscompilation debugger`_. Otherwise, there is no problem ``bugpoint`` can; debug. .. _crash debugger:. Crash debugger; --------------. If an optimizer or code generator crashes, ``bugpoint`` will try as hard as it; can to reduce the list of passes (for optimizer crashes) and the size of the; test program. First, ``bugpoint`` figures out which combination of optimizer; passes triggers the bug. This is useful when debugging a problem exposed by; ``opt``, for example, because it runs over 38 passes. Next, ``bugpoint`` tries removing functions from the test program, to reduce its; size. Usually it is able to reduce a test program to a single function, when; debugging intraprocedural optimizations. Once the number of functions has been; reduced, it attempts to d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:2717,test,test,2717,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['test'],['test']
Testability," and stores as appropriate.; This is just the standard SSA construction algorithm to construct ""pruned"" SSA; form. ``memcpyopt``: MemCpy Optimization; ----------------------------------. This pass performs various transformations related to eliminating ``memcpy``; calls, or transforming sets of stores into ``memset``\ s. ``mergefunc``: Merge Functions; ------------------------------. This pass looks for equivalent functions that are mergeable and folds them. Total-ordering is introduced among the functions set: we define comparison; that answers for every two functions which of them is greater. It allows to; arrange functions into the binary tree. For every new function we check for equivalent in tree. If equivalent exists we fold such functions. If both functions are overridable,; we move the functionality into a new internal function and leave two; overridable thunks to it. If there is no equivalent, then we add this function to tree. Lookup routine has O(log(n)) complexity, while whole merging process has; complexity of O(n*log(n)). Read; :doc:`this <MergeFunctions>`; article for more details. ``mergereturn``: Unify function exit nodes; ------------------------------------------. Ensure that functions have at most one ``ret`` instruction in them.; Additionally, it keeps track of which node is the new exit node of the CFG. ``partial-inliner``: Partial Inliner; ------------------------------------. This pass performs partial inlining, typically by inlining an ``if`` statement; that surrounds the body of the function. ``reassociate``: Reassociate expressions; ----------------------------------------. This pass reassociates commutative expressions in an order that is designed to; promote better constant propagation, GCSE, :ref:`LICM <passes-licm>`, PRE, etc. For example: 4 + (x + 5) ⇒ x + (4 + 5). In the implementation of this algorithm, constants are assigned rank = 0,; function arguments are rank = 1, and other values are assigned ranks; corresponding to the reverse",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:31728,log,log,31728,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,2,['log'],['log']
Testability," and the resultant program could be used just like the standard ``grep``; tool. Positional arguments are sorted by their order of construction. This means that; command line options will be ordered according to how they are listed in a .cpp; file, but will not have an ordering defined if the positional arguments are; defined in multiple .cpp files. The fix for this problem is simply to define; all of your positional arguments in one .cpp file. Specifying positional options with hyphens; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Sometimes you may want to specify a value to your positional argument that; starts with a hyphen (for example, searching for '``-foo``' in a file). At; first, you will have trouble doing this, because it will try to find an argument; named '``-foo``', and will fail (and single quotes will not save you). Note; that the system ``grep`` has the same problem:. ::. $ spiffygrep '-foo' test.txt; Unknown command line argument '-foo'. Try: spiffygrep -help'. $ grep '-foo' test.txt; grep: illegal option -- f; grep: illegal option -- o; grep: illegal option -- o; Usage: grep -hblcnsviw pattern file . . . The solution for this problem is the same for both your tool and the system; version: use the '``--``' marker. When the user specifies '``--``' on the; command line, it is telling the program that all options after the '``--``'; should be treated as positional arguments, not options. Thus, we can use it; like this:. ::. $ spiffygrep -- -foo test.txt; ...output... Determining absolute position with getPosition(); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Sometimes an option can affect or modify the meaning of another option. For; example, consider ``gcc``'s ``-x LANG`` option. This tells ``gcc`` to ignore the; suffix of subsequent positional arguments and force the file to be interpreted; as if it contained source code in language ``LANG``. In order to handle this; properly, you need to know the absolute position of each argument, especially; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:28134,test,test,28134,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['test'],['test']
Testability," and the validator; asserts/crashes on invalid inputs, in-process fuzzing is not applicable.; * Bugs in the target library may accumulate without being detected. E.g. a memory; corruption that goes undetected at first and then leads to a crash while; testing another input. This is why it is highly recommended to run this; in-process fuzzer with all sanitizers to detect most bugs on the spot.; * It is harder to protect the in-process fuzzer from excessive memory; consumption and infinite loops in the target library (still possible).; * The target library should not have significant global state that is not; reset between the runs.; * Many interesting target libraries are not designed in a way that supports; the in-process fuzzer interface (e.g. require a file path instead of a; byte array).; * If a single test run takes a considerable fraction of a second (or; more) the speed benefit from the in-process fuzzer is negligible.; * If the target library runs persistent threads (that outlive; execution of one test) the fuzzing results will be unreliable. Q. So, what exactly this Fuzzer is good for?; --------------------------------------------. This Fuzzer might be a good choice for testing libraries that have relatively; small inputs, each input takes < 10ms to run, and the library code is not expected; to crash on invalid inputs.; Examples: regular expression matchers, text or binary format parsers, compression,; network, crypto. Q. LibFuzzer crashes on my complicated fuzz target (but works fine for me on smaller targets).; ----------------------------------------------------------------------------------------------. Check if your fuzz target uses ``dlclose``.; Currently, libFuzzer doesn't support targets that call ``dlclose``,; this may be fixed in future. Trophies; ========; * Thousands of bugs found on OSS-Fuzz: https://opensource.googleblog.com/2017/05/oss-fuzz-five-months-later-and.html. * GLIBC: https://sourceware.org/glibc/wiki/FuzzingLibc. * MUSL LIBC: `[1] <htt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:30446,test,test,30446,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['test'],['test']
Testability," anonymous instructions; -----------------------------------------------------. This is a little utility pass that gives instructions names, this is mostly; useful when diffing the effect of an optimization because deleting an unnamed; instruction can change all other instruction numbering, making the diff very; noisy. .. _passes-verify:. ``verify``: Module Verifier; ---------------------------. Verifies an LLVM IR code. This is useful to run after an optimization which is; undergoing testing. Note that llvm-as verifies its input before emitting; bitcode, and also that malformed bitcode is likely to make LLVM crash. All; language front-ends are therefore encouraged to verify their output before; performing optimizing transformations. #. Both of a binary operator's parameters are of the same type.; #. Verify that the indices of mem access instructions match other operands.; #. Verify that arithmetic and other things are only performed on first-class; types. Verify that shifts and logicals only happen on integrals f.e.; #. All of the constants in a switch statement are of the correct type.; #. The code is in valid SSA form.; #. It is illegal to put a label into any other type (like a structure) or to; return one.; #. Only phi nodes can be self referential: ``%x = add i32 %x``, ``%x`` is; invalid.; #. PHI nodes must have an entry for each predecessor, with no extras.; #. PHI nodes must be the first thing in a basic block, all grouped together.; #. PHI nodes must have at least one entry.; #. All basic blocks should only end with terminator insts, not contain them.; #. The entry node to a function must not have predecessors.; #. All Instructions must be embedded into a basic block.; #. Functions cannot take a void-typed parameter.; #. Verify that a function's argument list agrees with its declared type.; #. It is illegal to specify a name for a void value.; #. It is illegal to have an internal global value with no initializer.; #. It is illegal to have a ``ret`` instruct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:41563,log,logicals,41563,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['log'],['logicals']
Testability," another nested redefinition.; `Issue 41302 <https://github.com/llvm/llvm-project/issues/41302>`_; - Fixed a crash when ``-ast-dump=json`` was used for code using class; template deduction guides.; - Fixed a crash when a lambda marked as ``static`` referenced a captured; variable in an expression.; `Issue 74608 <https://github.com/llvm/llvm-project/issues/74608>`_; - Fixed a crash with modules and a ``constexpr`` destructor.; `Issue 68702 <https://github.com/llvm/llvm-project/issues/68702>`_. OpenACC Specific Changes; ------------------------; - OpenACC Implementation effort is beginning with semantic analysis and parsing; of OpenACC pragmas. The ``-fopenacc`` flag was added to enable these new,; albeit incomplete changes. The ``_OPENACC`` macro is currently defined to; ``1``, as support is too incomplete to update to a standards-required value.; - Added ``-fexperimental-openacc-macro-override``, a command line option to; permit overriding the ``_OPENACC`` macro to be any digit-only value specified; by the user, which permits testing the compiler against existing OpenACC; workloads in order to evaluate implementation progress. Target Specific Changes; -----------------------. AMDGPU Support; ^^^^^^^^^^^^^^; - Use pass-by-reference (byref) in stead of pass-by-value (byval) for struct; arguments in C ABI. Callee is responsible for allocating stack memory and; copying the value of the struct if modified. Note that AMDGPU backend still; supports byval for struct arguments.; - The default value for ``-mcode-object-version`` is now 5.; See `AMDHSA Code Object V5 Metadata <https://llvm.org/docs/AMDGPUUsage.html#code-object-v5-metadata>`_; for more details. X86 Support; ^^^^^^^^^^^. - Added option ``-m[no-]evex512`` to disable ZMM and 64-bit mask instructions; for AVX512 features.; - Support ISA of ``USER_MSR``.; * Support intrinsic of ``_urdmsr``.; * Support intrinsic of ``_uwrmsr``.; - Support ISA of ``AVX10.1``.; - ``-march=pantherlake`` and ``-march=clearwaterforest`` ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:59017,test,testing,59017,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['test'],['testing']
Testability," any bugs fixed and any new; features added. Some tips for getting your testcase approved:. * All feature and regression test cases are added to the ``llvm/test``; directory. The appropriate sub-directory should be selected (see the; :doc:`Testing Guide <TestingGuide>` for details). * Test cases should be written in :doc:`LLVM assembly language <LangRef>`. * Test cases, especially for regressions, should be reduced as much as possible,; by :doc:`bugpoint <Bugpoint>` or manually. It is unacceptable to place an; entire failing program into ``llvm/test`` as this creates a *time-to-test*; burden on all developers. Please keep them short. * Avoid adding links to resources that are not available to the entire; community, such as links to private bug trackers, internal corporate; documentation, etc. Instead, add sufficient comments to the test to provide; the context behind such links. Note that llvm/test and clang/test are designed for regression and small feature; tests only. More extensive test cases (e.g., entire applications, benchmarks,; etc) should be added to the ``llvm-test`` test suite. The llvm-test suite is; for coverage (correctness, performance, etc) testing, not feature or regression; testing. Release Notes; -------------. Many projects in LLVM communicate important changes to users through release; notes, typically found in ``docs/ReleaseNotes.rst`` for the project. Changes to; a project that are user-facing, or that users may wish to know about, should be; added to the project's release notes at the author's or code reviewer's; discretion, preferably as part of the commit landing the changes. Examples of; changes that would typically warrant adding a release note (this list is not; exhaustive):. * Adding, removing, or modifying command-line options.; * Adding, removing, or regrouping a diagnostic.; * Fixing a bug that potentially has significant user-facing impact (please link; to the issue fixed in the bug database).; * Adding or removing optimizations th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:10561,test,test,10561,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['test'],['test']
Testability," anything.; 4. The alignment inference code cannot handle loads from globals in non-static; mode because it doesn't look through the extra dyld stub load. If you try; vec_align.ll without -relocation-model=static, you'll see what I mean. //===---------------------------------------------------------------------===//. We should lower store(fneg(load p), q) into an integer load+xor+store, which; eliminates a constant pool load. For example, consider:. define i64 @ccosf(float %z.0, float %z.1) nounwind readonly {; entry:; %tmp6 = fsub float -0.000000e+00, %z.1		; <float> [#uses=1]; %tmp20 = tail call i64 @ccoshf( float %tmp6, float %z.0 ) nounwind readonly; ret i64 %tmp20; }; declare i64 @ccoshf(float %z.0, float %z.1) nounwind readonly. This currently compiles to:. LCPI1_0:					# <4 x float>; 	.long	2147483648	# float -0; 	.long	2147483648	# float -0; 	.long	2147483648	# float -0; 	.long	2147483648	# float -0; _ccosf:; 	subl	$12, %esp; 	movss	16(%esp), %xmm0; 	movss	%xmm0, 4(%esp); 	movss	20(%esp), %xmm0; 	xorps	LCPI1_0, %xmm0; 	movss	%xmm0, (%esp); 	call	L_ccoshf$stub; 	addl	$12, %esp; 	ret. Note the load into xmm0, then xor (to negate), then store. In PIC mode,; this code computes the pic base and does two loads to do the constant pool ; load, so the improvement is much bigger. The tricky part about this xform is that the argument load/store isn't exposed; until post-legalize, and at that point, the fneg has been custom expanded into ; an X86 fxor. This means that we need to handle this case in the x86 backend; instead of in target independent code. //===---------------------------------------------------------------------===//. Non-SSE4 insert into 16 x i8 is atrociously bad. //===---------------------------------------------------------------------===//. <2 x i64> extract is substantially worse than <2 x f64>, even if the destination; is memory. //===---------------------------------------------------------------------===//. INSERTPS can match any insert (extract, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt:13171,stub,stub,13171,interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,1,['stub'],['stub']
Testability," appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162782,test,tests,162782,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['test'],['tests']
Testability," are accessed through the ``ASTContext`` class, which implicitly creates; and uniques them as they are needed. Types have a couple of non-obvious; features: 1) they do not capture type qualifiers like ``const`` or ``volatile``; (see :ref:`QualType <QualType>`), and 2) they implicitly capture typedef; information. Once created, types are immutable (unlike decls). Typedefs in C make semantic analysis a bit more complex than it would be without; them. The issue is that we want to capture typedef information and represent it; in the AST perfectly, but the semantics of operations need to ""see through""; typedefs. For example, consider this code:. .. code-block:: c++. void func() {; typedef int foo;; foo X, *Y;; typedef foo *bar;; bar Z;; *X; // error; **Y; // error; **Z; // error; }. The code above is illegal, and thus we expect there to be diagnostics emitted; on the annotated lines. In this example, we expect to get:. .. code-block:: text. test.c:6:1: error: indirection requires pointer operand ('foo' invalid); *X; // error; ^~; test.c:7:1: error: indirection requires pointer operand ('foo' invalid); **Y; // error; ^~~; test.c:8:1: error: indirection requires pointer operand ('foo' invalid); **Z; // error; ^~~. While this example is somewhat silly, it illustrates the point: we want to; retain typedef information where possible, so that we can emit errors about; ""``std::string``"" instead of ""``std::basic_string<char, std:...``"". Doing this; requires properly keeping typedef information (for example, the type of ``X``; is ""``foo``"", not ""``int``""), and requires properly propagating it through the; various operators (for example, the type of ``*Y`` is ""``foo``"", not; ""``int``""). In order to retain this information, the type of these expressions; is an instance of the ``TypedefType`` class, which indicates that the type of; these expressions is a typedef for ""``foo``"". Representing types like this is great for diagnostics, because the; user-specified type is always immediate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:62253,test,test,62253,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['test'],['test']
Testability," args*. Pass all arguments specified after **--tool-args** to the LLVM tool under test; (**llc**, **lli**, etc.) whenever it runs. You should use this option in the; following way:. .. code-block:: bash. bugpoint [bugpoint args] --tool-args -- [tool args]. The ""``--``"" right after the **--tool-args** option tells **bugpoint** to; consider any options starting with ""``-``"" to be part of the **--tool-args**; option, not as options to **bugpoint** itself. (See **--args**, above.). **--safe-tool-args** *tool args*. Pass all arguments specified after **--safe-tool-args** to the ""safe"" execution; tool. **--gcc-tool-args** *gcc tool args*. Pass all arguments specified after **--gcc-tool-args** to the invocation of; **gcc**. **--opt-args** *opt args*. Pass all arguments specified after **--opt-args** to the invocation of **opt**. **--disable-{dce,simplifycfg}**. Do not run the specified passes to clean up and reduce the size of the test; program. By default, **bugpoint** uses these passes internally when attempting to; reduce test programs. If you're trying to find a bug in one of these passes,; **bugpoint** may crash. **--enable-valgrind**. Use valgrind to find faults in the optimization phase. This will allow; bugpoint to find otherwise asymptomatic problems caused by memory; mis-management. **-find-bugs**. Continually randomize the specified passes and run them on the test program; until a bug is found or the user kills **bugpoint**. **-help**. Print a summary of command line options. **--input** *filename*. Open *filename* and redirect the standard input of the test program, whenever; it runs, to come from that file. **--load** *plugin*. Load the dynamic object *plugin* into **bugpoint** itself. This object should; register new optimization passes. Once loaded, the object will add new command; line options to enable various optimizations. To see the new complete list of; optimizations, use the **-help** and **--load** options together; for example:. .. code-block:: bash",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst:2685,test,test,2685,interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/bugpoint.rst,1,['test'],['test']
Testability," argument allows you to specify (without the trailing; ""``:``"") one or more prefixes to match. Multiple prefixes are useful for tests; which might change for different run options, but most lines remain the same. FileCheck does not permit duplicate prefixes, even if one is a check prefix; and one is a comment prefix (see :option:`--comment-prefixes` below). .. option:: --check-prefixes prefix1,prefix2,... An alias of :option:`--check-prefix` that allows multiple prefixes to be; specified as a comma separated list. .. option:: --comment-prefixes prefix1,prefix2,... By default, FileCheck ignores any occurrence in ``match-filename`` of any check; prefix if it is preceded on the same line by ""``COM:``"" or ""``RUN:``"". See the; section `The ""COM:"" directive`_ for usage details. These default comment prefixes can be overridden by; :option:`--comment-prefixes` if they are not appropriate for your testing; environment. However, doing so is not recommended in LLVM's LIT-based test; suites, which should be easier to maintain if they all follow a consistent; comment style. In that case, consider proposing a change to the default; comment prefixes instead. .. option:: --allow-unused-prefixes. This option controls the behavior when using more than one prefix as specified; by :option:`--check-prefix` or :option:`--check-prefixes`, and some of these; prefixes are missing in the test file. If true, this is allowed, if false,; FileCheck will report an error, listing the missing prefixes. The default value; is false. .. option:: --input-file filename. File to check (defaults to stdin). .. option:: --match-full-lines. By default, FileCheck allows matches of anywhere on a line. This; option will require all positive matches to cover an entire; line. Leading and trailing whitespace is ignored, unless; :option:`--strict-whitespace` is also specified. (Note: negative; matches from ``CHECK-NOT`` are not affected by this option!). Passing this option is equivalent to inserting ``{{^ *}}`` or",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:2425,test,test,2425,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['test'],['test']
Testability," argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``exp2`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.log``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.log(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.log``' intrinsic computes the base-e; logarithm of the specified value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``log`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.log10``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.log10(<type> <op1>,; metadata <rounding mode>,; metadata <exception behavior>). Overview:; """""""""""""""""". The '``llvm.experimental.constrained.log10``' intrinsic computes the base-10; logarithm of the specified value. Arguments:; """""""""""""""""""". The first argument and the return value are floating-point numbers of the same; type. The second and third arguments specify the rounding mode and exception; behavior as described above. Semantics:; """""""""""""""""""". This function returns the same values as the libm ``log10`` functions; would, and handles error conditions in the same way. '``llvm.experimental.constrained.log2``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <type>; @llvm.experimental.constrained.log2(<type> <op1>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:897632,log,log,897632,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['log'],['log']
Testability," as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data->Draw(""Current/Potential:Temperature""); ```. It should have become clear from these examples how to navigate in such; a multi-dimensional space of variables and unveil relations between; variables using n-tuples. ### Reading N-tuples. For completeness, you find here a small macro to read the data back from; a ROOT n-tuple. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_from_file.C; ```. The macro shows the easiest way of accessing the content of a n-tuple:; after loading the n-tuple, its branches are assigned to variables and; `GetEntry(long)` automatically fills them with the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as another type than they have been written, e.g. when storing a; variable as float and reading it as double. List of variable types that can be used to define the type of a bra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:4391,log,logic,4391,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['log'],['logic']
Testability, as `External/SPEC/README`). ### Common CMake Flags. - `-GNinja`. Generate build files for the ninja build tool. - `-Ctest-suite/cmake/caches/<cachefile.cmake>`. Use a CMake cache. The test-suite comes with several CMake caches which; predefine common or tricky build configurations. Displaying and Analyzing Results; --------------------------------. The `compare.py` script displays and compares result files. A result file is; produced when invoking lit with the `-o filename.json` flag. Example usage:. - Basic Usage:. ```text; % test-suite/utils/compare.py baseline.json; Warning: 'test-suite :: External/SPEC/CINT2006/403.gcc/403.gcc.test' has No metrics!; Tests: 508; Metric: exec_time. Program baseline. INT2006/456.hmmer/456.hmmer 1222.90; INT2006/464.h264ref/464.h264ref 928.70; ...; baseline; count 506.000000; mean 20.563098; std 111.423325; min 0.003400; 25% 0.011200; 50% 0.339450; 75% 4.067200; max 1222.896800; ```. - Show compile_time or text segment size metrics:. ```bash; % test-suite/utils/compare.py -m compile_time baseline.json; % test-suite/utils/compare.py -m size.__text baseline.json; ```. - Compare two result files and filter short running tests:. ```bash; % test-suite/utils/compare.py --filter-short baseline.json experiment.json; ...; Program baseline experiment diff. SingleSour.../Benchmarks/Linpack/linpack-pc 5.16 4.30 -16.5%; MultiSourc...erolling-dbl/LoopRerolling-dbl 7.01 7.86 12.2%; SingleSour...UnitTests/Vectorizer/gcc-loops 3.89 3.54 -9.0%; ...; ```. - Merge multiple baseline and experiment result files by taking the minimum; runtime each:. ```bash; % test-suite/utils/compare.py base0.json base1.json base2.json vs exp0.json exp1.json exp2.json; ```. ### Continuous Tracking with LNT. LNT is a set of client and server tools for continuously monitoring; performance. You can find more information at; [https://llvm.org/docs/lnt](https://llvm.org/docs/lnt). The official LNT instance; of the LLVM project is hosted at [http://lnt.llvm.org](http://lnt.llv,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:7900,test,test-suite,7900,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['test'],['test-suite']
Testability," as for example `POCL <http://portablecl.org/>`_, can be used. This target does not support multiple memory segments and, therefore, the fake; address space map can be added using the :ref:`-ffake-address-space-map; <opencl_fake_address_space_map>` flag. All known OpenCL extensions and features are set to supported in the generic targets,; however :option:`-cl-ext` flag can be used to toggle individual extensions and; features. .. _opencl_header:. OpenCL Header; -------------. By default Clang will include standard headers and therefore most of OpenCL; builtin functions and types are available during compilation. The; default declarations of non-native compiler types and functions can be disabled; by using flag :option:`-cl-no-stdinc`. The following example demonstrates that OpenCL kernel sources with various; standard builtin functions can be compiled without the need for an explicit; includes or compiler flags. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 test.cl. More information about the default headers is provided in :doc:`OpenCLSupport`. OpenCL Extensions; -----------------. Most of the ``cl_khr_*`` extensions to OpenCL C from `the official OpenCL; registry <https://www.khronos.org/registry/OpenCL/>`_ are available and; configured per target depending on the support available in the specific; architecture. It is possible to alter the default extensions setting per target using; ``-cl-ext`` flag. (See :ref:`flags description <opencl_cl_ext>` for more details). Vendor extensions can be added flexibly by declaring the list of types and; functions associated with each extensions enclosed within the following; compiler pragma directives:. .. code-block:: c. #pragma OPENCL EXTENSION the_new_extension_name : begin; // declare types and functions associated with the extension here; #pragma OPENCL EXTENSION the_new_extension_name : end. For example, parsing the follo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:147492,test,test,147492,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['test'],['test']
Testability," as identity; TLorentzRotation m(l);// m = l; TRotation r;; TLorentzRotation lr(r);; TLorentzRotation lb1(bx,by,bz);; TVector3 b;; TLorentzRotation lb2(b);; ```. The Matrix for a Lorentz boosts is:. $$; \left|; \begin{array}{cccc}; 1+gamma'*bx*bx & gamma'*bx*by & gamma'*bx*bz & gamma*bx \\; gamma'*bx*bz & 1+gamma'*by*by & gamma'*by*by & gamma*by \\; gamma'*bz*bx & gamma'*bz*by & 1+gamma'*bz*bz & gamma*bz \\; gamma*bx & gamma*by & gamma*bz & gamma; \end{array}; \right|; $$. with the boost vector `b=(bx,by,bz)`;; `gamma=1/Sqrt(1-beta*beta)`;` gamma'=(gamma-1)/beta*beta.`. ### Access to the Matrix Components/Comparisons. The access to the matrix components is possible with the methods `XX()`,; `XY()` ... `TT()`, and with the operator` (int,int)`:. ``` {.cpp}; Double_t xx;; TLorentzRotation l;; xx = l.XX(); // gets the xx component; xx = l(0,0); // gets the xx component; if (l == m) {...} // test for equality; if (l != m) {...} // test for inequality; if (l.IsIdentity()) {...} // test for identity; ```. ### Transformations of a Lorentz Rotation. There are four possibilities to find the product of two; **`TLorentzRotation`** transformations:. ``` {.cpp}; TLorentzRotation a,b,c;; c = b*a; // product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b; // a=a*b; c = a.Transform(b) // a=b*a then c=a; ```. Lorentz boosts:. ``` {.cpp}; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; ```. Rotations:. ``` {.cpp}; TVector3 axis;; l.RotateX(TMath::Pi()); // rotation around x-axis; l.Rotate(.5,axis); // rotation around specified vector; ```. Inverse transformation: use the method `Inverse() `to return the inverse; transformation keeping the current one unchanged`.` The method; `Invert()` inverts the current **`TLorentzRotation`**:. ``` {.cpp}; l1 = l2.Inverse(); // l1 is inverse of l2, l2 unchanged; l1 = l2.Invert(); // invert l2, then l1=l2; ```. The matrix for the inverse transformation of a **`TLorentzRotation`** is; as f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:16492,test,test,16492,documentation/users-guide/PhysicsVectors.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md,1,['test'],['test']
Testability," as separate efforts to integrate LLVM development with local practices. It is the responsibility of each sub-community to care about their own parts; and the intersection of that with the core tier and other peripheral parts. There are three main groups of code that fit in this category:; * Code that is making its way into LLVM, via the `experimental <https://llvm.org/docs/DeveloperPolicy.html#introducing-new-components-into-llvm>`_; roadmap or similar efforts.; * Code that is making its way out of LLVM, via deprecation, replacement or; bit-rot, and will be removed if the sub-community that cares about it; cannot maintain it.; * Code that isn't meant to be in LLVM core and can coexist with the code in; the core tier (and others in the peripheral tier) long term, without causing; breakages or disturbances. What is covered; ---------------. The peripheral tier is composed of:; * Experimental targets and options that haven't been enable by default yet.; * Main repository projects that don't get released or regularly tested.; * Legacy tools and scripts that aren't used in upstream validation.; * Alternative build systems (ex. GN, Bazel) and related infrastructure.; * Tools support (ex. gdb scripts, editor configuration, helper scripts). Requirements; ------------. Code in this tier must:; * Have a clear benefit for residing in the main repository, catering to an; active sub-community (upstream or downstream).; * Be actively maintained by such sub-community and have its problems addressed; in a timely manner. Code in this tier must **not**:; * Break or invalidate core tier code or infrastructure. If that happens; accidentally, reverting functionality and working on the issues offline; is the only acceptable course of action.; * Negatively affect development of core tier code, with the sub-community; involved responsible for making changes to address specific concerns.; * Negatively affect other peripheral tier code, with the sub-communities; involved tasked to resolve th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst:4502,test,tested,4502,interpreter/llvm-project/llvm/docs/SupportPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportPolicy.rst,1,['test'],['tested']
Testability," as source and destination; arguments. If a copy operation takes a safepoint it might need to relocate the; underlying source and destination objects. This requires the corresponding base; pointers to be available in the copy operation. In order to make the base; pointers available RewriteStatepointsForGC replaces derived pointers with base; pointer and offset pairs. For example:. .. code-block:: llvm. declare void @__llvm_memcpy_element_unordered_atomic_safepoint_1(; i8 addrspace(1)* %dest_base, i64 %dest_offset,; i8 addrspace(1)* %src_base, i64 %src_offset,; i64 %length). .. _PlaceSafepoints:. PlaceSafepoints; ^^^^^^^^^^^^^^^^. The pass PlaceSafepoints inserts safepoint polls sufficient to ensure running; code checks for a safepoint request on a timely manner. This pass is expected; to be run before RewriteStatepointsForGC and thus does not produce full; relocation sequences. As an example, given input IR of the following:. .. code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @foo(); ret void; }. declare void @do_safepoint(); define void @gc.safepoint_poll() {; call void @do_safepoint(); ret void; }. This pass would produce the following IR:. .. code-block:: llvm. define void @test() gc ""statepoint-example"" {; call void @do_safepoint(); call void @foo(); ret void; }. In this case, we've added an (unconditional) entry safepoint poll. Note that; despite appearances, the entry poll is not necessarily redundant. We'd have to; know that ``foo`` and ``test`` were not mutually recursive for the poll to be; redundant. In practice, you'd probably want to your poll definition to contain; a conditional branch of some form. At the moment, PlaceSafepoints can insert safepoint polls at method entry and; loop backedges locations. Extending this to work with return polls would be; straight forward if desired. PlaceSafepoints includes a number of optimizations to avoid placing safepoint; polls at particular sites unless needed to ensure timely execution o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:31818,test,test,31818,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['test'],['test']
Testability," as the first line of the; method. If that still doesn't remove enough, then change the caller of; ``InstCombiner::DoOneIteration``, ``InstCombiner::runOnFunction`` to limit the; number of iterations. You may also find it useful to use ""``-stats``"" now to see what parts of; instcombine are firing. This can guide where to put additional reporting code. At this point, if the amount of transformations is still too large, then; inserting code to limit whether or not to execute the body of the code in the; visit function can be helpful. Add a static counter which is incremented on; every invocation of the function. Then add code which simply returns false on; desired ranges. For example:. .. code-block:: c++. static int calledCount = 0;; calledCount++;; LLVM_DEBUG(if (calledCount < 212) return false);; LLVM_DEBUG(if (calledCount > 217) return false);; LLVM_DEBUG(if (calledCount == 213) return false);; LLVM_DEBUG(if (calledCount == 214) return false);; LLVM_DEBUG(if (calledCount == 215) return false);; LLVM_DEBUG(if (calledCount == 216) return false);; LLVM_DEBUG(dbgs() << ""visitXOR calledCount: "" << calledCount << ""\n"");; LLVM_DEBUG(dbgs() << ""I: ""; I->dump());. could be added to ``visitXOR`` to limit ``visitXor`` to being applied only to; calls 212 and 217. This is from an actual test case and raises an important; point---a simple binary search may not be sufficient, as transformations that; interact may require isolating more than one call. In TargetLowering, use; ``return SDNode();`` instead of ``return false;``. Now that the number of transformations is down to a manageable number, try; examining the output to see if you can figure out which transformations are; being done. If that can be figured out, then do the usual debugging. If which; code corresponds to the transformation being performed isn't obvious, set a; breakpoint after the call count based disabling and step through the code.; Alternatively, you can use ""``printf``"" style debugging to report waypoints.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst:10673,test,test,10673,interpreter/llvm-project/llvm/docs/Bugpoint.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Bugpoint.rst,1,['test'],['test']
Testability," assertions and should not; have assertions automatically generated. In that case, add the text ``NOTE: Do; not autogenerate`` to the first line, and the scripts will skip that test. It; is a good idea to explain why generated assertions will not work for the test; so future developers will understand what is going on. These are the most common scripts and their purposes/applications in generating; assertions:. .. code-block:: none. update_analyze_test_checks.py; opt -passes='print<cost-model>'. update_cc_test_checks.py; C/C++, or clang/clang++ (IR checks). update_llc_test_checks.py; llc (assembly checks). update_mca_test_checks.py; llvm-mca. update_mir_test_checks.py; llc (MIR checks). update_test_checks.py; opt. Precommit workflow for tests; ----------------------------. If the test does not crash, assert, or infinite loop, commit the test with; baseline check-lines first. That is, the test will show a miscompile or; missing optimization. Add a ""TODO"" or ""FIXME"" comment to indicate that; something is expected to change in a test. A follow-up patch with code changes to the compiler will then show check-line; differences to the tests, so it is easier to see the effect of the patch.; Remove TODO/FIXME comments added in the previous step if a problem is solved. Baseline tests (no-functional-change or NFC patch) may be pushed to main; without pre-commit review if you have commit access. Best practices for regression tests; -----------------------------------. - Use auto-generated check lines (produced by the scripts mentioned above); whenever feasible.; - Include comments about what is tested/expected in a particular test. If there; are relevant issues in the bug tracker, add references to those bug reports; (for example, ""See PR999 for more details"").; - Avoid undefined behavior and poison/undef values unless necessary. For; example, do not use patterns like ``br i1 undef``, which are likely to break; as a result of future optimizations.; - Minimize tests by removing u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:13023,test,test,13023,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['test']
Testability," automatically and supported as well; 2. Fix - better selection of Y range for log scale; 3. Provide JSROOT.parse_multi function to correctly parse response of multi.json request,; support it in the JSROOT.NewHttpRequest method as well.; 4. Fix - correctly calculate integral for TH1; 5. Partially support new TFormula with complex C code inside. ## Changes in 4.8.0; 1. Many improvements in the I/O part; - support most of STL containers; - support TMap and TClonesArray containers; - all kind of multidimensional arrays; - correct treatment of foreign classes; - supports different versions of class in the same file; - support members like ClassName* fField; //[fCnt]; - support const char*; - support fixed-size array of TString, TObject and TNamed; 2. Many new draw options for different classes are supported:; - TGraph - 'z', 'x', '||', '[]', '>', '|>', '5', 'X+', 'Y+'; - TH1 - '*', 'L', 'LF2', 'B', 'B1', 'TEXT', 'E0', 'E3', 'E4', 'EX0', 'X+', 'Y+'; - TH2 - 'E', 'col1', 'box', 'box1', 'surf3', 'surf7', 'base0'; - TH2 - 'same' with 'box', 'col', 'cont', 'lego', 'surf'; - TH3 - 'scat', use by default; - TF1/TF2 - 'nosave' to ignore saved buffer; - TCanvas - logx/y/z, gridx/y, tickx/y; - THStack - 'lego' and other 3D draw options; 3. Implement drawing of TProfile2D, TF2, TGraph2D, TGraph2DErrors and TMarker; 4. Fix - correctly place TGAxis relative to frame (when exists); 5. When superimpose items, one can specify individual options; ...&item=histo1+histo2&opt=hist+e1; ...&item=[histo1,histo2]&opt=[hist,e1]; 6. Support loading of TStyle object, providing in URL; ...&style=item_name or ...&style=json_file_name; All values are copied directly to JSROOT.gStyle object.; 7. Add callback argument into JSROOT.draw() function.; Function will be called after drawing of object is completed.; Painter for drawn object will be provided as first argument (or null in case of error).; 8. Improve cleanup of JSROOT objects. ## Changes in 4.7.1; 1. Workaround for MathJax output - scaling not a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:50336,log,logx,50336,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['log'],['logx']
Testability," axis; - grid - enable grid for X and Y axes; - tickx - enable ticks for X axis; - ticky - enable ticks for X axis; - tick - enable ticks for X and Y axes; - rx - reverse X axis; - ry - reverse Y axis; - rotate - rotate frame; - fixframe - disable interactive moving of the frame; - nozoomx - disable zooming on X axis; - nozoomy - disable zooming on Y axis; - cpXY - create palette XY for the canvas like cp50; - nopalette - ignore palette stored with TCanvas; - nocolors - ignore colors list stored with TCanvas; - lcolors - use only locally colors list stored with TCanvas; - nomargins - clear frame margins. ## Superimposing draw objects. In the URL string one could use ""+"" sign to specify objects superposition:. - [item=hpx+hprof](https://root.cern/js/latest/?file=../files/hsimple.root&item=hpx+hprof). With similar syntax one could specify individual draw options for superimposed objects. - [item=hpx+hprof&opt=logy+hist](https://root.cern/js/latest/?file=../files/hsimple.root&item=hpx+hprof&opt=logy+hist). Here ""logy"" option will be used for ""hpx1"" item and ""hist"" option for ""hprof;1"" item. While draw option can include ""+"" sign itself, for superposition one could specify arrays of items and draw options like:. - [item=[hpx;1,hprof;1]&opt=[logy,hist]](https://root.cern/js/latest/?file=../files/hsimple.root&item=[hpx;1,hprof;1]&opt=[logy,hist]). ## TTree draw. JSROOT provides possibility to display TTree data, using [TTree::Draw](https://root.cern/doc/master/classTTree.html) syntax:. - [opt=px](https://root.cern/js/latest/?file=../files/hsimple.root&item=ntuple;1&opt=px); - [opt=px:py](https://root.cern/js/latest/?file=../files/hsimple.root&item=ntuple;1&opt=px:py); - [opt=px:py:pz](https://root.cern/js/latest/?file=../files/hsimple.root&item=ntuple;1&opt=px:py:pz). It is also possible to use branch by id number specifying name like ""br_0"", ""br_1"" and so on:. - [opt=br_0:br_1](https://root.cern/js/latest/?file=../files/hsimple.root&item=ntuple&opt=br_0:br_1). Histogram r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:14227,log,logy,14227,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['log'],['logy']
Testability," b(0, 2);; a = a + b; // warn; }. // C++03, C++11; #include <valarray>. void test(void) {; std::valarray<int> a(0, 1), b(0, 2);; std::valarray<bool> c(false, 1);; c = a == b; // warn; }. undefbehavior.ValarrayZeroLength; (C++); Undefined behavior: calling sum()/min()/; max() methods of a zero length valarray the behavior is; undefined.; Source: C++03 26.3.2.7p2, p3, p4; C++11 26.6.2.8p5, p6,; p7. #include <valarray>. void test(void) {; std::valarray<int> v(0, 0);; v.sum(); // warn; }. undefbehavior.ValarrayBadIndirection; (C++); Undefined behavior: element is specified more than once in an indirection.; Source: C++03 26.3.9.2p2, 26.3.9.3p2; C++11 26.6.9.2p2,; 26.6.9.3p2. #include <valarray>. void test() {; // '1' is specified more then once; size_t addr[] = {0, 1, 1};; std::valarray<size_t>indirect(addr, 3);; std::valarray<int> a(0, 5), b(1, 3);; a[indirect] = b; //warn; }. #include <valarray>. void test() {; // '1' is specified more then once; size_t addr[] = {0, 1, 1};; std::valarray<size_t>indirect(addr, 3);; std::valarray<int> a(0, 5), b(1, 3);; a[indirect] *= b; //warn; }. undefbehavior.IosBaseDestroyedBeforeInit; (C++); Undefined behavior: ios_base object is destroyed before; initialization have taken place. basic_ios::init should be call to; initialize ios_base members.; Source: C++03 27.4.2.7p1, 27.4.4.1p2; C++11 27.5.3.7p1,; 27.5.5.2p2. #include <ios>. using namespace std;; template <class T, class Traits = std::char_traits<T> >; class my_stream1 : public std::basic_ios<T, Traits> {; };. template <class T, class Traits = std::char_traits<T> >; class my_stream2 : public std::basic_ios<T, Traits> {; class my_streambuf; : public std::basic_streambuf<T, Traits> {; };; public:; my_stream2() {; this->init(new my_streambuf);; }; };. void test() {; my_stream1<char> *p1 = new my_stream1<char>;; my_stream2<char> *p2 = new my_stream2<char>;; delete p1; // warn; delete p2; // ok; }. undefbehavior.IosBaseUsedBeforeInit; (C++11); Undefined behavior: ios_base object is use",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:17351,test,test,17351,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability," b. Hidden Surface Mode rRotate about zz c. Move object down uAuto-rotate about x1 2 3. Move object up iAuto-rotate about y4 5 6. Move object left lAuto-rotate about z7 8 9. Move object right hToggle controls styleo. Move object forward jToggle stereo displays. Move object backward kToggle blue stereo viewd. Adjust focus (stereo mode) [ ] { }Toggle double bufferf. Rotate object Left mouse button down + move. ### Common 3D Viewer Architecture. The 3D Viewer Architecture provides a common mechanism for viewer; clients to publish 3D objects to it. It enables:. - Decoupling of producers (geometry packages etc) who model collection; of 3D objects from consumers (viewers) which display them. - Producer code free of explicit drawing commands & viewer specific; branching. - Support differing viewers and clients capabilities, e.g. - Mix of native (in viewer) shapes and generic client side; tessellation. - Local/global frame object description. - Bounding boxes. - Placing copies sharing common geometry (logical/physical shapes). The architecture consists of:. - **`TVirtualViewer3D`** interface: An abstract handle to the viewer,; allowing client to add objects, test preferences etc. - **`TBuffer3D`** class hierarchy: Used to describe 3D objects; (""shapes"") - filled /added by negotiation with viewer via; **`TVirtualViewer3D`**. A typical interaction between viewer and client using these, taken from; **`TGeoPainter`** is:. ``` {.cpp}; TVirtualViewer3D * viewer = gPad->GetViewer3D();; // Does viewer prefer local frame positions?; Bool_t localFrame = viewer->PreferLocalFrame();; // Perform first fetch of buffer from the shape and try adding it to the viewer; const TBuffer3D &buffer = shape.GetBuffer3D(TBuffer3D::kCore |; TBuffer3D::kBoundingBox |; TBuffer3D::kShapeSpecific,; localFrame);; Int_t reqSections = viewer->AddObject(buffer, &addDaughters);. // If the viewer requires additional sections fetch from the shape; // (if possible) and add again; if (reqSections != TBuffer3D::kN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:122597,log,logical,122597,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['log'],['logical']
Testability," be called.; }. memory.DstBufferTooSmall; (C, C++); Destination buffer passed to memory function is too small.; Note: security.insecureAPI.strcpy currently warns; on usage of strcpy and suggests to replace it.; Note: alpha.unix.CStringChecker contains some similar checks.; Source: CWE-120. void test() {; const char* s1 = ""abc"";; char *s2 = new char;; strcpy(s2, s1); // warn; }. void test() {; int* p1 = new int[3];; int* p2 = new int;; memcpy(p2, p1, 3); // warn; }. memory.NegativeArraySize; (C, C++); 'n' is used to specify the buffer size may be negative.; Note: possibly an enhancement to ; alpha.security.MallocOverflow.; Source: CWE-20,; Example 2. void test() {; int *p;; int n1 = -1;; p = new int[n1]; // warn; }. memory.ZeroAlloc; (C, C++); Allocation of zero bytes.; Note: an enhancement to unix.Malloc.; Note: unix.API perform C-checks for zero; allocation. This should be moved to unix.Malloc.; Source: C++03 3.7.3.1p2; C++11 3.7.4.1p2. #include <stdlib.h>. void test() {; int *p = malloc(0); // warn; free(p);; }. void test() {; int *p = new int[0]; // warn; delete[] p;; }. D6178. constructors/destructors. Name, DescriptionExampleProgress. ctordtor.ExptInsideDtor; (C++); It is dangerous to let an exception leave a destructor.; Using try..catch solves the problem.; Source: Scott Meyers ""More Effective C++"", item 11: Prevent exceptions from; leaving destructors. class A {; A() {}; ~A() { throw 1; } // warn; };. void f() throw(int);. class A {; A() {}; ~A() { f(); } // warn; };. ctordtor.PlacementSelfCopy; (C++11); For a placement copy or move, it is almost certainly an error if the; constructed object is also the object being copied from. class A {};. void test(A *dst, A *src) {; ::new (dst) A(*dst); // warn (should be 'src'); }. exceptions. Name, DescriptionExampleProgress. exceptions.ThrowSpecButNotThrow; (C++); Function declaration has a throw(type) specifier but the; function do not throw exceptions. void test() throw(int) {; } // warn. exceptions.NoThrowSpecButThr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:2054,test,test,2054,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability," be determined. For example, this occurs when the test; could not be run, the test itself is invalid, or the test was interrupted. **UNSUPPORTED**. The test is not supported in this environment. This is used by test formats; which can report unsupported tests. **TIMEOUT**. The test was run, but it timed out before it was able to complete. This is; considered a failure. Depending on the test format tests may produce additional information about; their status (generally only for failures). See the :ref:`output-options`; section for more information. .. _lit-infrastructure:. LIT INFRASTRUCTURE; ------------------. This section describes the :program:`lit` testing architecture for users interested in; creating a new :program:`lit` testing implementation, or extending an existing one. :program:`lit` proper is primarily an infrastructure for discovering and running; arbitrary tests, and to expose a single convenient interface to these; tests. :program:`lit` itself doesn't know how to run tests, rather this logic is; defined by *test suites*. TEST SUITES; ~~~~~~~~~~~. As described in :ref:`test-discovery`, tests are always located inside a *test; suite*. Test suites serve to define the format of the tests they contain, the; logic for finding those tests, and any additional information to run the tests. :program:`lit` identifies test suites as directories containing ``lit.cfg`` or; ``lit.site.cfg`` files (see also :option:`--config-prefix`). Test suites are; initially discovered by recursively searching up the directory hierarchy for; all the input files passed on the command line. You can use; :option:`--show-suites` to display the discovered test suites at startup. Once a test suite is discovered, its config file is loaded. Config files; themselves are Python modules which will be executed. When the config file is; executed, two important global variables are predefined:. **lit_config**. The global **lit** configuration object (a *LitConfig* instance), which defines; the b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:14091,test,tests,14091,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,3,"['log', 'test']","['logic', 'test', 'tests']"
Testability," be ended early or not. . When undertaking an immediate response, document the action and notify the; committee within 24 hours. . Response Procedure; ==================. The following is a summary of the steps the committee takes when responding to; a reported incident. . 1. Determine if there is a need for an :ref:`immediate response<Immediate; Response Checklist>`. 2. :ref:`Acknowledge the report<Receiving a report>` within 24 hours. 3. :ref:`Discuss the incident report<Incident Response Assessment>`, gather; more information, and determine a :ref:`resolution<Resolutions>`. 4. During this process, the :ref:`reporter will be informed of the; resolution<Following Up With the Reportee>` and feedback is requested. This; feedback may or may not be used to re-evaluate the resolution. 5. Inform the reportee of the resolution. The reportee is provided options to; :ref:`appeal<Appeal Process>`. . 6. The :ref:`resolution<Resolutions>` is implemented. 7. All reports, data, notes, and resolutions are logged in a private location; (e.g., Google Drive or other database). The committee will never make public statements about a resolution and will; only publish :ref:`transparency reports<Transparency Reports>`. If a public; statement is necessary and requested by the committee, it will be given by the; LLVM Foundation Board of Directors. Report Acknowledgement; ======================. When a report is received, the committee will reply to the reporter to confirm; receipt within 24 hours of the incident being reported. . This acknowledgement will contain:. * Acknowledgement of the incident report; * Next steps of the committee for responding to the incident; * Reminder of confidentiality policy regarding the report and parties involved. All incident reports should be assessed if they require immediate response and; acted on accordingly. .. _Incident Response Assessment:. Incident Response Assessment; ============================. The committee will assess the incident and determi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:3944,log,logged,3944,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['log'],['logged']
Testability," bf, Double_t epsilon) {; //return kTRUE if absolute difference between af and bf is less than epsilon; Bool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec) {; //return kTRUE if relative difference between af and bf is less than relPrec. TMatrix. Various changes to the Sparse Matrix classes:; ; Fixed Savannah bugs 45807,45502 and 45415; added a Streamer function to TMatrixTSparse to remove a memory; leak.; Added vector functionality as proposed by Peter D Barnes from LNL; (http://root.cern.ch/phpBB2/viewtopic.php?t=8351).; ; double s = v1 * M * v2; // Mult Function : e.g., physics matrix element; TMatrixD M = v1' * v2 // outer product of v1 and v2; . SMatrix. Use specialized structures for building automatically static; tables for mapping the indices conversion from standard row-wise one to the; compact one used internally for storing the memory of a symmetrix matrix. This change gives an; improvements of around 10-20% in the Kalman filter test (testKalman.cxx) and in the matrix operations test. Minuit. Implement in the TMinuitMinimizer class the method SetPrecision() using the ""SET EPS"" Minuit command; Fix a problem when using the user provided gradient in TMinuitMinimizer. The gradient calculation is always forced, i.e. Minuit will always use the derivatives calculations provided by the user. This is now the same behavior as in Minuit2Minimizer.; Implement in TMinuitMinimizer a method to retrieve the variable name given the index.; Fix a printout in TMinuit::mnscan and a problem observed with valgrind. Minuit2. Fix a bug in MnFunctionCross. ; Add a protection against very small step sizes which can cause; nan values in InitialGradientCalculator.; Implement a new function in the MnUserTransformation class, FindIndex(name), which returns -1 when the parameter name does not exist.; Implement new methods in Minuit2Minimizer as requested by the Minimizer interface:; SetPrecision(double eps) to change the precision value used internally in Minuit2 (in MnPrecisi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v526/index.html:1129,test,test,1129,math/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v526/index.html,1,['test'],['test']
Testability," block with `num-repetitions` instructions (repeating the snippet; `num-repetitions`/`snippet size` times). `loop` will, optionally, duplicate the; snippet until the loop body contains at least `loop-body-size` instructions,; and then wrap the result in a loop which will execute `num-repetitions`; instructions (thus, again, repeating the snippet; `num-repetitions`/`snippet size` times). The `loop` mode, especially with loop; unrolling tends to better hide the effects of the CPU frontend on architectures; that cache decoded instructions, but consumes a register for counting; iterations. If performing an analysis over many opcodes, it may be best to; instead use the `min` mode, which will run each other mode,; and produce the minimal measured result. .. option:: --num-repetitions=<Number of repetitions>. Specify the target number of executed instructions. Note that the actual; repetition count of the snippet will be `num-repetitions`/`snippet size`.; Higher values lead to more accurate measurements but lengthen the benchmark. .. option:: --loop-body-size=<Preferred loop body size>. Only effective for `-repetition-mode=[loop|min]`.; Instead of looping over the snippet directly, first duplicate it so that the; loop body contains at least this many instructions. This potentially results; in loop body being cached in the CPU Op Cache / Loop Cache, which allows to; which may have higher throughput than the CPU decoders. .. option:: --max-configs-per-opcode=<value>. Specify the maximum configurations that can be generated for each opcode.; By default this is `1`, meaning that we assume that a single measurement is; enough to characterize an opcode. This might not be true of all instructions:; for example, the performance characteristics of the LEA instruction on X86; depends on the value of assigned registers and immediates. Setting a value of; `-max-configs-per-opcode` larger than `1` allows `llvm-exegesis` to explore; more configurations to discover if some register or im",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:13431,benchmark,benchmark,13431,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['benchmark'],['benchmark']
Testability," block. ### TODO list. As this is an experimental work in progress so there are some items we still need; to tackle:. * As mentioned in test llvm/test/DebugInfo/assignment-tracking/X86/diamond-3.ll,; the analysis should treat escaping calls like untagged stores. * The system expects locals to be backed by a local alloca. This isn't always; the case - sometimes a pointer to storage is passed into a function; (e.g. sret, byval). We need to be able to handle those cases. See; llvm/test/DebugInfo/Generic/assignment-tracking/track-assignments.ll and; clang/test/CodeGen/assignment-tracking/assignment-tracking.cpp for examples. * `trackAssignments` doesn't yet work for variables that have their; `llvm.dbg.declare` location modified by a `DIExpression`, e.g. when the; address of the variable is itself stored in an `alloca` with the; `llvm.dbg.declare` using `DIExpression(DW_OP_deref)`. See `indirectReturn` in; llvm/test/DebugInfo/Generic/assignment-tracking/track-assignments.ll and in; clang/test/CodeGen/assignment-tracking/assignment-tracking.cpp for an; example. * In order to solve the first bullet-point we need to be able to specify that a; memory location is available without using a `DIAssignID`. This is because; the storage address is not computed by an instruction (it's an argument; value) and therefore we have nowhere to put the metadata attachment. To solve; this we probably need another marker intrinsic to denote ""the variable's; stack home is X address"" - similar to `llvm.dbg.declare` except that it needs; to compose with `llvm.dbg.assign` intrinsics such that the stack home address; is only selected as a location for the variable when the `llvm.dbg.assign`; intrinsics agree it should be. * Given the above (a special ""the stack home is X"" intrinsic), and the fact; that we can only track assignments with fixed offsets and sizes, I think we; can probably get rid of the address and address-expression part, since it; will always be computable with the info we have.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:10362,test,test,10362,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,1,['test'],['test']
Testability," both left and right *GEPs*, then compare it as; numbers, and return comparison result. Otherwise treat it like a regular operation (see previous paragraph). cmpOperation; ------------; Compares instruction opcodes and some important operation properties. 1. Compare opcodes, if it differs return the result. 2. Compare number of operands. If it differs – return the result. 3. Compare operation types, use *cmpType*. All the same – if types are; different, return result. 4. Compare *subclassOptionalData*, get it with ``getRawSubclassOptionalData``; method, and compare it like a numbers. 5. Compare operand types. 6. For some particular instructions, check equivalence (relation in our case) of; some significant attributes. For example, we have to compare alignment for; ``load`` instructions. O(log(N)); ---------; Methods described above implement order relationship. And latter, could be used; for nodes comparison in a binary tree. So we can organize functions set into; the binary tree and reduce the cost of lookup procedure from; O(N*N) to O(log(N)). Merging process, mergeTwoFunctions; ==================================; Once *MergeFunctions* detected that current function (*G*) is equal to one that; were analyzed before (function *F*) it calls ``mergeTwoFunctions(Function*,; Function*)``. Operation affects ``FnTree`` contents with next way: *F* will stay in; ``FnTree``. *G* being equal to *F* will not be added to ``FnTree``. Calls of; *G* would be replaced with something else. It changes bodies of callers. So,; functions that calls *G* would be put into ``Deferred`` set and removed from; ``FnTree``, and analyzed again. The approach is next:. 1. Most wished case: when we can use alias and both of *F* and *G* are weak. We; make both of them with aliases to the third strong function *H*. Actually *H*; is *F*. See below how it's made (but it's better to look straight into the; source code). Well, this is a case when we can just replace *G* with *F*; everywhere, we use ``rep",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:26000,log,log,26000,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['log'],['log']
Testability," browser to examine the split tree:. ``` {.cpp}; > Event 400 1 1 1; ```. ``` {.cpp}; > root; root[] TFile f(""Event.root""); root[] TBrowser browser; ```. ![](pictures/080001FB.png). ### stress - Test and Benchmark. The executable stress is created by compiling `stress.cxx`. It completes; sixteen tests covering the following capabilities of the ROOT framework. - Functions, Random Numbers, Histogram Fits. - Size & compression factor of a ROOT file. - Purge, Reuse of gaps in **`TFile`**. - 2D Histograms, Functions, 2D Fits. - Graphics & PostScript. - Subdirectories in a ROOT file. - **`TNtuple`**, Selections, **`TCutG`**, **`TEventList`**. - Split and Compression modes for Trees. - Analyze `Event.root` file of stress 8. - Create 10 files starting from `Event.root`. - Test chains of Trees using the 10 files. - Compare histograms of test 9 and 11. - Merging files of a chain. - Check correct rebuilt of `Event.root` in test 13. - Divert Tree branches to separate files. - Cling test (3 nested loops) with `LHCb` trigger. The program stress takes one argument, the number of events to process.; The default is 1000 events. Be aware that executing stress with 1000; events*will create several files consuming about 100 MB of disk space;*; running stress with 30 events will consume about 20 MB. The disk space; is released once stress is done. There are two ways to run `stress`:. From the system prompt or from the ROOT prompt using the interpreter. ``` {.cpp}; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; ```. Start ROOT with the batch mode option (-b) to suppress the graphic; output. ``` {.cpp}; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; ```. The output of stress includes a pass/fail conclusion for each test, the; total number of bytes read and written, and the elapsed real and CPU; time. It also calculates a performance index for your machine relative; to a referenc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:13382,test,test,13382,documentation/users-guide/TutorialsandTests.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md,1,['test'],['test']
Testability," but allowing *only* relocatable values.; - ``X``: Allows an operand of any kind, no constraint whatsoever. Typically; useful to pass a label for an asm branch or call. .. FIXME: but that surely isn't actually okay to jump out of an asm; block without telling llvm about the control transfer???). - ``{register-name}``: Requires exactly the named physical register. Other constraints are target-specific:. AArch64:. - ``z``: An immediate integer 0. Outputs ``WZR`` or ``XZR``, as appropriate.; - ``I``: An immediate integer valid for an ``ADD`` or ``SUB`` instruction,; i.e. 0 to 4095 with optional shift by 12.; - ``J``: An immediate integer that, when negated, is valid for an ``ADD`` or; ``SUB`` instruction, i.e. -1 to -4095 with optional left shift by 12.; - ``K``: An immediate integer that is valid for the 'bitmask immediate 32' of a; logical instruction like ``AND``, ``EOR``, or ``ORR`` with a 32-bit register.; - ``L``: An immediate integer that is valid for the 'bitmask immediate 64' of a; logical instruction like ``AND``, ``EOR``, or ``ORR`` with a 64-bit register.; - ``M``: An immediate integer for use with the ``MOV`` assembly alias on a; 32-bit register. This is a superset of ``K``: in addition to the bitmask; immediate, also allows immediate integers which can be loaded with a single; ``MOVZ`` or ``MOVL`` instruction.; - ``N``: An immediate integer for use with the ``MOV`` assembly alias on a; 64-bit register. This is a superset of ``L``.; - ``Q``: Memory address operand must be in a single register (no; offsets). (However, LLVM currently does this for the ``m`` constraint as; well.); - ``r``: A 32 or 64-bit integer register (W* or X*).; - ``Uci``: Like r, but restricted to registers 8 to 11 inclusive.; - ``Ucj``: Like r, but restricted to registers 12 to 15 inclusive.; - ``w``: A 32, 64, or 128-bit floating-point, SIMD or SVE vector register.; - ``x``: Like w, but restricted to registers 0 to 15 inclusive.; - ``y``: Like w, but restricted to SVE vector registers",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:222418,log,logical,222418,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['log'],['logical']
Testability," but does require some; information to be set. This information is gathered via ``cmake``; and is written to a file, ``test/lit.site.cfg.py`` in the build directory.; The ``llvm/test`` Makefile does this work for you. In order for the regression tests to work, each directory of tests must; have a ``lit.local.cfg`` file. :program:`lit` looks for this file to determine; how to run the tests. This file is just Python code and thus is very; flexible, but we've standardized it for the LLVM regression tests. If; you're adding a directory of tests, just copy ``lit.local.cfg`` from; another directory to get running. The standard ``lit.local.cfg`` simply; specifies which files to look in for tests. Any directory that contains; only directories does not need the ``lit.local.cfg`` file. Read the :doc:`Lit; documentation <CommandGuide/lit>` for more information. Each test file must contain lines starting with ""RUN:"" that tell :program:`lit`; how to run it. If there are no RUN lines, :program:`lit` will issue an error; while running a test. RUN lines are specified in the comments of the test program using the; keyword ``RUN`` followed by a colon, and lastly the command (pipeline); to execute. Together, these lines form the ""script"" that :program:`lit`; executes to run the test case. The syntax of the RUN lines is similar to a; shell's syntax for pipelines including I/O redirection and variable; substitution. However, even though these lines may *look* like a shell; script, they are not. RUN lines are interpreted by :program:`lit`.; Consequently, the syntax differs from shell in a few ways. You can specify; as many RUN lines as needed. :program:`lit` performs substitution on each RUN line to replace LLVM tool names; with the full paths to the executable built for each tool (in; ``$(LLVM_OBJ_ROOT)/bin``). This ensures that :program:`lit` does; not invoke any stray LLVM tools in the user's path during testing. Each RUN line is executed on its own, distinct from other lines unless; i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:8442,test,test,8442,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['test']
Testability," but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^. The ``-steens-aa`` pass implements a variation on the well-known ""Steensgaard's; algorithm"" for interprocedural alias analysis. Steensgaard's algorithm is a; unification-based, flow-insensitive, context-insensitive, and field-insensitive; alias analysis that is also very scalable (effectively linear time). The LLVM ``-steens-aa`` pass implements a ""speculatively field-**sensitive**""; version of Steensgaard's algorithm using the Data Structure Analysis framework.; This gives it substantially more precision than the standard algorithm while; maintaining excellent analysis scalability. .. note::. ``-steens-aa`` is available in the optional ""poolalloc"" module. It is not part; of the LLVM core. The ``-ds-aa`` pass; ^^^^^^^^^^^^^^^^^^^. The ``-ds-aa`` pass implements the full Data Structure Analysis algorithm. Data; Structure Analysis is a modular unification-based, flow-insensitive,; context-**sensitive**, and speculatively field-**sensitive** alias; analysis that is also quite scalable, usually at ``O(n * log(n))``. This algorithm is capable of responding to a full variety of alias analysis; queries, and can provide context-sensitive mod/ref information as well. The; only major facility not implemented so far is support for must-alias; information. .. note::. ``-ds-aa`` is available in the optional ""poolalloc"" module. It is not part of; the LLVM core. The ``-scev-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-scev-aa`` pass implements AliasAnalysis queries by translating them into; ScalarEvolution queries. This gives it a more complete understanding of; ``getelementptr`` instructions and loop induction variables than other alias; analyses have. Alias analysis driven transformations; -------------------------------------. LLVM includes several alias-analysis driven transformations which can be used; with any of the implementations above. The ``-adce`` pass; ^^^^^^^^^^^^^^^^^^. The ``-adce`` pass, wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:26445,log,log,26445,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['log'],['log']
Testability," by M. Winkler and F. James.; More information on the new C++ version can be found on the; [MINUIT Web Site](http://www.cern.ch/minuit). Minuit2, originally developed in the SEAL project, is now distributed within %ROOT.; The API has been then changed in this new version to follow the %ROOT coding convention; (function names starting with capital letters) and the classes have been moved inside; the namespace _ROOT::Minuit2_. In addition, the %ROOT distribution contains classes; needed to integrate Minuit2 in the %ROOT framework. A new class has been introduced, ROOT::Minuit2::Minuit2Minimizer, which implements; the interface ROOT::Math::Minimizer. Within %ROOT, it can be instantiates also using; the %ROOT plug-in manager. This class provides a convenient entry point for using Minuit2\.; An example of using this interface is the %ROOT tutorial _tutorials/fit/NumericalMinimization.C_; or the Minuit2 test program; [<tt>testMinimize.cxx</tt>](https://github.com/cxx-hep/root-cern/blob/master/math/minuit2/test/testMinimize.cxx). A standalone version of Minuit2 (independent of %ROOT) can be easily built and installed using `CMake`. See this [`README`](https://github.com/root-project/root/blob/master/math/minuit2/README.md) for the instructions on how to get the sources, building and installing a stand-alone Minuit2. The [Minuit2 User Guide](https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html); provides all the information needed for using directly (without add-on packages like %ROOT) Minuit2. ## References. 1. F. James, _Fortran MINUIT Reference Manual_ ([html](https://cern-tex.web.cern.ch/cern-tex/minuit/minmain.html));; 2. F. James and M. Winkler, _C++ MINUIT User's Guide_ ([html](https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html) and [pdf](https://root.cern/root/htmldoc/guides/minuit2/Minuit2.pdf));; 3. F. James, _Minuit Tutorial on Function Minimization_ ([pdf](http://seal.cern.ch/documents/minuit/mntutorial.pdf));; 4. F. James, _The Interpretation of Er",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.md:1589,test,test,1589,math/minuit2/doc/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.md,2,['test'],"['test', 'testMinimize']"
Testability," by new[] in; a shared_ptr one should use a custom deleter that calls ; delete[]..; Source: C++03 20.4.5p1; C++11 auto_ptr is deprecated (D.10). #include <stdlib.h>; #include <memory>. void test() {; std::auto_ptr<int> p1(new int); // Ok; std::auto_ptr<int> p2(new int[3]); // warn; }. #include <stdlib.h>; #include <memory>. void test() {; std::auto_ptr<int> p((int *)malloc(sizeof(int))); // warn; }. dead code. Name, DescriptionExampleProgress. deadcode.UnmodifiedVariable; (C, C++); A variable is never modified but was not declared const and is not a; reference.(opt-in checker). extern int computeDelta();. int test(bool cond) {; int i = 0;; if (cond) {; const int delta = computeDelta();; // warn: forgot to modify 'i'; }; return i;; }. PR16890. deadcode.IdempotentOperations; (C); Warn about idempotent operations. void test() {; int x = 7;; x = x; // warn: value is always the same; }. void test() {; int x = 7;; x /= x; // warn: value is always 1; }. void test() {; int x = 7, one = 1;; x *= one; // warn: right op is always 1; }. void test() {; int x = 7, zero = 0;; x = x - zero;; // warn: the right operand to '-' is always 0; }. removed from alpha.deadcode.* at; r198476. POSIX. Name, DescriptionExampleProgress. posix.Errno; (C); Record that errno is non-zero when certain functions; fail. #include <stdlib.h>. int readWrapper(int fd, int *count) {; int lcount = read(fd, globalBuf, sizeof(globalBuf));; if (lcount < 0); return errno;; *count = lcount;; return 0;; }. void use(int fd) {; int count;; if (!readWrapper(fd, &count)); print(""%d"", count); // should not warn; }. PR18701. undefined behavior. Name, DescriptionExampleProgress. undefbehavior.ExitInDtor; (C++); Undefined behavior: std::exit() is called to end the program during; the destruction of an object with static storage duration.; Source: C++11 3.6.1p4. #include <cstdlib>. class A {; public:; ~A() {; std::exit(1); // warn; }; };. undefbehavior.LocalStaticDestroyed; (C++); Undefined behavior: function containing a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:4701,test,test,4701,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability," call `resize()` to let JSROOT adjust drawing size. One should do:. ```javascript; resize(""drawing"");; ```. As second argument one could specify exact size for draw elements like:. ```javascript; resize(""drawing"", { width: 500, height: 200 });; ```. To correctly cleanup JSROOT drawings from HTML element, one should call:. ```javascript; cleanup(""drawing"");; ```. ### File API. JSROOT defines the TFile class, which can be used to access binary ROOT files.; One should always remember that all I/O operations are asynchronous in JSROOT.; Therefore promises are used to retrieve results when the I/O operation is completed.; For example, reading an object from a file and displaying it will look like:. ```javascript; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; console.log('drawing completed');; ```. Here is [running example](https://root.cern/js/latest/api.htm#custom_html_read_root_file) and [source code](https://github.com/root-project/jsroot/blob/master/demo/read_file.htm). ### TTree API. Simple TTree::Draw operation can be performed with following code:. ```javascript; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; draw(""drawing"", tree, ""px:py::pz>5"");; ```. To get access to selected branches, one should use `TSelector` class:. ```javascript; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; import { TSelector, treeProcess } from 'https://root.cern/js/latest/modules/tree.mjs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = awai",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:40324,log,log,40324,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['log'],['log']
Testability," callee (int32 arg1, int32 arg2);; int caller (int32 arg1, int32 arg2) {; return callee(arg1,arg2);; }. Here we don't need to write any variables to the top of the stack; since they don't overwrite each other. int callee (int32 arg1, int32 arg2);; int caller (int32 arg1, int32 arg2) {; return callee(arg2,arg1);; }. Here we need to push the arguments because they overwrite each; other. //===---------------------------------------------------------------------===//. main (); {; int i = 0;; unsigned long int z = 0;. do {; z -= 0x00004000;; i++;; if (i > 0x00040000); abort ();; } while (z > 0);; exit (0);; }. gcc compiles this to:. _main:; 	subl	$28, %esp; 	xorl	%eax, %eax; 	jmp	L2; L3:; 	cmpl	$262144, %eax; 	je	L10; L2:; 	addl	$1, %eax; 	cmpl	$262145, %eax; 	jne	L3; 	call	L_abort$stub; L10:; 	movl	$0, (%esp); 	call	L_exit$stub. llvm:. _main:; 	subl	$12, %esp; 	movl	$1, %eax; 	movl	$16384, %ecx; LBB1_1:	# bb; 	cmpl	$262145, %eax; 	jge	LBB1_4	# cond_true; LBB1_2:	# cond_next; 	incl	%eax; 	addl	$4294950912, %ecx; 	cmpl	$16384, %ecx; 	jne	LBB1_1	# bb; LBB1_3:	# bb11; 	xorl	%eax, %eax; 	addl	$12, %esp; 	ret; LBB1_4:	# cond_true; 	call	L_abort$stub. 1. LSR should rewrite the first cmp with induction variable %ecx.; 2. DAG combiner should fold; leal 1(%eax), %edx; cmpl $262145, %edx; =>; cmpl $262144, %eax. //===---------------------------------------------------------------------===//. define i64 @test(double %X) {; 	%Y = fptosi double %X to i64; 	ret i64 %Y; }. compiles to:. _test:; 	subl	$20, %esp; 	movsd	24(%esp), %xmm0; 	movsd	%xmm0, 8(%esp); 	fldl	8(%esp); 	fisttpll	(%esp); 	movl	4(%esp), %edx; 	movl	(%esp), %eax; 	addl	$20, %esp; 	#FP_REG_KILL; 	ret. This should just fldl directly from the input stack slot. //===---------------------------------------------------------------------===//. This code:; int foo (int x) { return (x & 65535) | 255; }. Should compile into:. _foo:; movzwl 4(%esp), %eax; orl $255, %eax; ret. instead of:; _foo:; 	movl	$65280, %eax; 	andl	4(%esp), ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:20070,stub,stub,20070,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['stub'],['stub']
Testability," calling convention), ``cc 11`` (HiPE calling convention), ``tailcc``, or; ``swifttailcc``. * The call is a tail call - in tail position (ret immediately follows call and; ret uses value of call or is void). * Option ``-tailcallopt`` is enabled or the calling convention is ``tailcc``. * Platform-specific constraints are met. x86/x86-64 constraints:. * No variable argument lists are used. * On x86-64 when generating GOT/PIC code only module-local calls (visibility =; hidden or protected) are supported. PowerPC constraints:. * No variable argument lists are used. * No byval parameters are used. * On ppc32/64 GOT/PIC only module-local calls (visibility = hidden or protected); are supported. WebAssembly constraints:. * No variable argument lists are used. * The 'tail-call' target attribute is enabled. * The caller and callee's return types must match. The caller cannot; be void unless the callee is, too. AArch64 constraints:. * No variable argument lists are used. Example:. Call as ``llc -tailcallopt test.ll``. .. code-block:: llvm. declare fastcc i32 @tailcallee(i32 inreg %a1, i32 inreg %a2, i32 %a3, i32 %a4). define fastcc i32 @tailcaller(i32 %in1, i32 %in2) {; %l1 = add i32 %in1, %in2; %tmp = tail call fastcc i32 @tailcallee(i32 inreg %in1, i32 inreg %in2, i32 %in1, i32 %l1); ret i32 %tmp; }. Implications of ``-tailcallopt``:. To support tail call optimization in situations where the callee has more; arguments than the caller a 'callee pops arguments' convention is used. This; currently causes each ``fastcc`` call that is not tail call optimized (because; one or more of above constraints are not met) to be followed by a readjustment; of the stack. So performance might be worse in such cases. Sibling call optimization; -------------------------. Sibling call optimization is a restricted form of tail call optimization.; Unlike tail call optimization described in the previous section, it can be; performed automatically on any tail calls when ``-tailcallopt`` option is no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:87524,test,test,87524,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['test'],['test']
Testability," can also be specified in; the ``SubjectList``. The diagnostics generated for subject list violations are; calculated automatically or specified by the subject list itself. If a; previously unused Decl node is added to the ``SubjectList``, the logic used to; automatically determine the diagnostic parameter in `utils/TableGen/ClangAttrEmitter.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/utils/TableGen/ClangAttrEmitter.cpp>`_; may need to be updated. By default, all subjects in the SubjectList must either be a Decl node defined; in ``DeclNodes.td``, or a statement node defined in ``StmtNodes.td``. However,; more complex subjects can be created by creating a ``SubsetSubject`` object.; Each such object has a base subject which it appertains to (which must be a; Decl or Stmt node, and not a SubsetSubject node), and some custom code which is; called when determining whether an attribute appertains to the subject. For; instance, a ``NonBitField`` SubsetSubject appertains to a ``FieldDecl``, and; tests whether the given FieldDecl is a bit field. When a SubsetSubject is; specified in a SubjectList, a custom diagnostic parameter must also be provided. Diagnostic checking for attribute subject lists for declaration and statement; attributes is automated except when ``HasCustomParsing`` is set to ``1``. Documentation; ~~~~~~~~~~~~~; All attributes must have some form of documentation associated with them.; Documentation is table generated on the public web server by a server-side; process that runs daily. Generally, the documentation for an attribute is a; stand-alone definition in `include/clang/Basic/AttrDocs.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/AttrDocs.td>`_; that is named after the attribute being documented. If the attribute is not for public consumption, or is an implicitly-created; attribute that has no visible spelling, the documentation list can specify the; ``InternalOnly`` object. Otherwise, the attribute should ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:133868,test,tests,133868,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['test'],['tests']
Testability," can be either ``c`` or; ``fastcc``. * The call is a tail call - in tail position (ret immediately follows call and; ret uses value of call or is void). * Caller and callee have matching return type or the callee result is not used. * If any of the callee arguments are being passed in stack, they must be; available in caller's own incoming argument stack and the frame offsets must; be the same. Example:. .. code-block:: llvm. declare i32 @bar(i32, i32). define i32 @foo(i32 %a, i32 %b, i32 %c) {; entry:; %0 = tail call i32 @bar(i32 %a, i32 %b); ret i32 %0; }. The X86 backend; ---------------. The X86 code generator lives in the ``lib/Target/X86`` directory. This code; generator is capable of targeting a variety of x86-32 and x86-64 processors, and; includes support for ISA extensions such as MMX and SSE. X86 Target Triples supported; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The following are the known target triples that are supported by the X86; backend. This is not an exhaustive list, and it would be useful to add those; that people test. * **i686-pc-linux-gnu** --- Linux. * **i386-unknown-freebsd5.3** --- FreeBSD 5.3. * **i686-pc-cygwin** --- Cygwin on Win32. * **i686-pc-mingw32** --- MingW on Win32. * **i386-pc-mingw32msvc** --- MingW crosscompiler on Linux. * **i686-apple-darwin*** --- Apple Darwin on X86. * **x86_64-unknown-linux-gnu** --- Linux. X86 Calling Conventions supported; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The following target-specific calling conventions are known to backend:. * **x86_StdCall** --- stdcall calling convention seen on Microsoft Windows; platform (CC ID = 64). * **x86_FastCall** --- fastcall calling convention seen on Microsoft Windows; platform (CC ID = 65). * **x86_ThisCall** --- Similar to X86_StdCall. Passes first argument in ECX,; others via stack. Callee is responsible for stack cleaning. This convention is; used by MSVC by default for methods in its ABI (CC ID = 70). .. _X86 addressing mode:. Representing X86 addressing modes in MachineInstrs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:89727,test,test,89727,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['test'],['test']
Testability," can be retrieved; using ``getParamElementType()``. This attribute is required in cases where; the intrinsic does not naturally encode a needed element type. This is also; used for inline assembly. Note that some of the methods mentioned above only exist to support both typed; and opaque pointers at the same time, and will be dropped once the migration; has completed. For example, ``isOpaqueOrPointeeTypeEquals()`` becomes; meaningless once all pointers are opaque. While direct usage of pointer element types is immediately apparent in code,; there is a more subtle issue that opaque pointers need to contend with: A lot; of code assumes that pointer equality also implies that the used load/store; type or GEP source element type is the same. Consider the following examples; with typed and opaque pointers:. .. code-block:: llvm. define i32 @test(i32* %p) {; store i32 0, i32* %p; %bc = bitcast i32* %p to i64*; %v = load i64, i64* %bc; ret i64 %v; }. define i32 @test(ptr %p) {; store i32 0, ptr %p; %v = load i64, ptr %p; ret i64 %v; }. Without opaque pointers, a check that the pointer operand of the load and; store are the same also ensures that the accessed type is the same. Using a; different type requires a bitcast, which will result in distinct pointer; operands. With opaque pointers, the bitcast is not present, and this check is no longer; sufficient. In the above example, it could result in store to load forwarding; of an incorrect type. Code making such assumptions needs to be adjusted to; check the accessed type explicitly:; ``LI->getType() == SI->getValueOperand()->getType()``. Frontends; ---------. Frontends need to be adjusted to track pointee types independently of LLVM,; insofar as they are necessary for lowering. For example, clang now tracks the; pointee type in the ``Address`` structure. Frontends using the C API through an FFI interface should be aware that a; number of C API functions are deprecated and will be removed as part of the; opaque pointer transi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:9055,test,test,9055,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['test'],['test']
Testability," can catch a lot of bugs. Once the; function is finished and validated, we return it. .. code-block:: c++. // Error reading body, remove function.; TheFunction->eraseFromParent();; return nullptr;; }. The only piece left here is handling of the error case. For simplicity,; we handle this by merely deleting the function we produced with the; ``eraseFromParent`` method. This allows the user to redefine a function; that they incorrectly typed in before: if we didn't delete it, it would; live in the symbol table, with a body, preventing future redefinition. This code does have a bug, though: If the ``FunctionAST::codegen()`` method; finds an existing IR Function, it does not validate its signature against the; definition's own prototype. This means that an earlier 'extern' declaration will; take precedence over the function definition's signature, which can cause; codegen to fail, for instance if the function arguments are named differently.; There are a number of ways to fix this bug, see what you can come up with! Here; is a testcase:. ::. extern foo(a); # ok, defines foo.; def foo(b) b; # Error: Unknown variable name. (decl using 'a' takes precedence). Driver Changes and Closing Thoughts; ===================================. For now, code generation to LLVM doesn't really get us much, except that; we can look at the pretty IR calls. The sample code inserts calls to; codegen into the ""``HandleDefinition``"", ""``HandleExtern``"" etc; functions, and then dumps out the LLVM IR. This gives a nice way to look; at the LLVM IR for simple functions. For example:. ::. ready> 4+5;; Read top-level expression:; define double @0() {; entry:; ret double 9.000000e+00; }. Note how the parser turns the top-level expression into anonymous; functions for us. This will be handy when we add `JIT; support <LangImpl04.html#adding-a-jit-compiler>`_ in the next chapter. Also note that the; code is very literally transcribed, no optimizations are being performed; except simple constant folding d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:17328,test,testcase,17328,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['test'],['testcase']
Testability," can of course be; omitted in favor of more customizable FileCheck directives. Some other ways to run debugify are available:. .. code-block:: bash. # Same as the above example.; $ opt -enable-debugify -pass-to-test sample.ll. # Suppresses verbose debugify output.; $ opt -enable-debugify -debugify-quiet -pass-to-test sample.ll. # Prepend -debugify before and append -check-debugify -strip after; # each pass on the pipeline (similar to -verify-each).; $ opt -debugify-each -O2 sample.ll. In order for ``check-debugify`` to work, the DI must be coming from; ``debugify``. Thus, modules with existing DI will be skipped. ``debugify`` can be used to test a backend, e.g:. .. code-block:: bash. $ opt -debugify < sample.ll | llc -o -. There is also a MIR-level debugify pass that can be run before each backend; pass, see:; :ref:`Mutation testing for MIR-level transformations<MIRDebugify>`. ``debugify`` in regression tests; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The output of the ``debugify`` pass must be stable enough to use in regression; tests. Changes to this pass are not allowed to break existing tests. .. note::. Regression tests must be robust. Avoid hardcoding line/variable numbers in; check lines. In cases where this can't be avoided (say, if a test wouldn't; be precise enough), moving the test to its own file is preferred. .. _MIRDebugify:. Test original debug info preservation in optimizations; ------------------------------------------------------. In addition to automatically generating debug info, the checks provided by; the ``debugify`` utility pass can also be used to test the preservation of; pre-existing debug info metadata. It could be run as follows:. .. code-block:: bash. # Run the pass by checking original Debug Info preservation.; $ opt -verify-debuginfo-preserve -pass-to-test sample.ll. # Check the preservation of original Debug Info after each pass.; $ opt -verify-each-debuginfo-preserve -O2 sample.ll. Limit number of observed functions to speed up the analysis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:13301,test,tests,13301,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['test'],['tests']
Testability," cannot be stored on regular basis due; to the large size of the latter, one cannot directly assign state; numbers. If the size of the expansion proves however to be small; enough (less than about 50 million objects), a parallel structure; storing these state indices is built and stored in memory. In such; case each state automatically gets an index that can be retrieved; after any state initialization. These indices can prove to be quite; useful for being able to keep track of the navigation history and; force certain states. Let's illustrate how this works with a simple; example:; - Suppose we have a simple geometry with a volume B positioned twice; inside a container A. Then A is positioned twice in a top container; T. The complete list of logical nodes is: `T_1`, `A_1`, `A_2`,; `B_1`, `B_2`. On the other hand we will have more states than; logical nodes:; - `/T_1`- 1 state at level = 0; - `/T_1/A_1,/T_1/A_2`- 2 states at level = 1; - `/T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2` - 4 states at; level = 2; - All these states will get automatic numbers, starting with 0; corresponding to the top-level state and ending with an integer; corresponding to Ntotal\_states-1. The mapping from a given logical; node to a state number is generally not possible, as for the node; B\_1 that appears as current node for 2 different states. The; numbering order of states is therefore not important, but it can be; used as in the following lines:. ``` {.cpp}; gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization; ```. - Current `global transformation`. This represents the transformation; from `MARS` to the local reference of the current node, being the; product of all local mother-daughter transformations in the branch.; The global transformation can be referenced or copied:. ``` {.cpp}; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:110434,log,logical,110434,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['log'],['logical']
Testability," cannot be stored on regular basis due; to the large size of the latter, one cannot directly assign state; numbers. If the size of the expansion proves however to be small; enough (less than about 50 million objects), a parallel structure; storing these state indices is built and stored in memory. In such; case each state automatically gets an index that can be retrieved; after any state initialization. These indices can prove to be quite; useful for being able to keep track of the navigation history and; force certain states. Let's illustrate how this works with a simple; example:; - Suppose we have a simple geometry with a volume B positioned twice; inside a container A. Then A is positioned twice in a top container; T. The complete list of logical nodes is: `T_1`, `A_1`, `A_2`,; `B_1`, `B_2`. On the other hand we will have more states than; logical nodes:; - `/T_1`- 1 state at level = 0; - `/T_1/A_1,/T_1/A_2`- 2 states at level = 1; - `/T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2` - 4 states at; level = 2; - All these states will get automatic numbers, starting with 0; corresponding to the top-level state and ending with an integer; corresponding to Ntotal\_states-1. The mapping from a given logical; node to a state number is generally not possible, as for the node; B\_1 that appears as current node for 2 different states. The; numbering order of states is therefore not important, but it can be; used as in the following lines:. ~~~{.cpp}; gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization; ~~~. - Current `global transformation`. This represents the transformation; from `MARS` to the local reference of the current node, being the; product of all local mother-daughter transformations in the branch.; The global transformation can be referenced or copied:. ~~~{.cpp}; co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:70837,log,logical,70837,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['log'],['logical']
Testability," cd $LLVM_OBJ_ROOT ; $LLVM_SRC_ROOT/configure [--with-llvmgccdir=$LLVM_GCC_DIR]. [Remember that ``$LLVM_GCC_DIR`` is the directory where you; *installed* llvm-gcc, not its src or obj directory.]. #. You can now run the test suite from your build tree as follows:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT/projects/test-suite; % make. Note that the second and third steps only need to be done once. After; you have the suite checked out and configured, you don't need to do it; again (unless the test code or configure script changes). Configuring External Tests; ==========================. In order to run the External tests in the ``test-suite`` module, you; must specify *--with-externals*. This must be done during the; *re-configuration* step (see above), and the ``llvm`` re-configuration; must recognize the previously-built ``llvm-gcc``. If any of these is; missing or neglected, the External tests won't work. * *--with-externals*. * *--with-externals=<directory>*. This tells LLVM where to find any external tests. They are expected to; be in specifically named subdirectories of <``directory``>. If; ``directory`` is left unspecified, ``configure`` uses the default value; ``/home/vadve/shared/benchmarks/speccpu2000/benchspec``. Subdirectory; names known to LLVM include:. * spec95. * speccpu2000. * speccpu2006. * povray31. Others are added from time to time, and can be determined from; ``configure``. Running Different Tests; =======================. In addition to the regular ""whole program"" tests, the ``test-suite``; module also provides a mechanism for compiling the programs in different; ways. If the variable TEST is defined on the ``gmake`` command line, the; test system will include a Makefile named; ``TEST.<value of TEST variable>.Makefile``. This Makefile can modify; build rules to yield different results. For example, the LLVM nightly tester uses ``TEST.nightly.Makefile`` to; create the nightly test reports. To run the nightly tests, run; ``gmake TEST=nightly``. Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:2352,test,tests,2352,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,1,['test'],['tests']
Testability," change from Phabricator; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. On a clean Git repository on an up to date ``main`` branch run the; following (where ``<Revision>`` is the Phabricator review number):. ::. arc patch D<Revision>. This will create a new branch called ``arcpatch-D<Revision>`` based on the; current ``main`` and will create a commit corresponding to ``D<Revision>`` with a; commit message derived from information in the Phabricator review. Check you are happy with the commit message and amend it if necessary.; For example, ensure the 'Author' property of the commit is set to the original author.; You can use a command to correct the author property if it is incorrect:. ::. git commit --amend --author=""John Doe <jdoe@llvm.org>"". Then, make sure the commit is up-to-date, and commit it. This can be done by running; the following:. ::. git pull --rebase https://github.com/llvm/llvm-project.git main; git show # Ensure the patch looks correct.; ninja check-$whatever # Rerun the appropriate tests if needed.; git push https://github.com/llvm/llvm-project.git HEAD:main. Abandoning a change; -------------------. If you decide you should not commit the patch, you should explicitly abandon; the review so that reviewers don't think it is still open. In the web UI,; scroll to the bottom of the page where normally you would enter an overall; comment. In the drop-down Action list, which defaults to ""Comment,"" you should; select ""Abandon Revision"" and then enter a comment explaining why. Click the; Submit button to finish closing the review. Status; ------. Please let us know whether you like it and what could be improved! We're still; working on setting up a bug tracker, but you can email klimek-at-google-dot-com; and chandlerc-at-gmail-dot-com and CC the llvm-dev mailing list with questions; until then. We also could use help implementing improvements. This sadly is; really painful and hard because the Phabricator codebase is in PHP and not as; testable as you mig",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:15989,test,tests,15989,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['test'],['tests']
Testability," change, we can build clang and manually check that it; works. .. code:: console. $ ninja clang; $ bin/clang -Wall ~/test.cc; /path/test.cc:1:124: warning: in order to understand recursion, you must; first understand recursion [-Winfinite-recursion]. We should also run the tests to make sure we didn't break something. .. code:: console. $ ninja check-clang. Notice that it is much faster to build this time, but the tests take; just as long to run. Ninja doesn't know which tests might be affected,; so it runs them all. .. code:: console. ********************; Testing Time: 408.84s; ********************; Failing Tests (1):; Clang :: SemaCXX/warn-infinite-recursion.cpp. Well, that makes sense… and the test output suggests it's looking for; the old string ""call itself"" and finding our new message instead.; Note that more tests may fail in a similar way as new tests are; added time to time. Let's fix it by updating the expectation in the test. .. code:: console. $ vi ../clang/test/SemaCXX/warn-infinite-recursion.cpp. Everywhere we see `// expected-warning{{call itself}}` (or something similar; from the original warning text), let's replace it with; `// expected-warning{{to understand recursion}}`. Now we could run **all** the tests again, but this is a slow way to; iterate on a change! Instead, let's find a way to re-run just the; specific test. There are two main types of tests in LLVM:. - **lit tests** (e.g. SemaCXX/warn-infinite-recursion.cpp). These are fancy shell scripts that run command-line tools and verify the; output. They live in files like; clang/**test**/FixIt/dereference-addressof.c. Re-run like this:. .. code:: console. $ bin/llvm-lit -v ../clang/test/SemaCXX/warn-infinite-recursion.cpp. - **unit tests** (e.g. ToolingTests/ReplacementTest.CanDeleteAllText). These are C++ programs that call LLVM functions and verify the results.; They live in suites like ToolingTests. Re-run like this:. .. code:: console. $ ninja ToolingTests && tools/clang/unittests/Tooling",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:7092,test,test,7092,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['test'],['test']
Testability," check-llvm is all the checks for core,; other projects have targets like check-lldb. Making changes; ==============. Edit; ----. We need to find the file containing the error message. .. code:: console. $ git grep ""all paths through this function"" ..; ../clang/include/clang/Basic/DiagnosticSemaKinds.td: ""all paths through this function will call itself"">,. The string that appears in DiagnosticSemaKinds.td is the one that is; printed by Clang. \*.td files define tables - in this case it's a list; of warnings and errors clang can emit and their messages. Let's update; the message in your favorite editor:. .. code:: console. $ vi ../clang/include/clang/Basic/DiagnosticSemaKinds.td. Find the message (it should be under; ``warn_infinite_recursive_function``). Change the message to ""in order to; understand recursion, you must first understand recursion"". Test again; ----------. To verify our change, we can build clang and manually check that it; works. .. code:: console. $ ninja clang; $ bin/clang -Wall ~/test.cc; /path/test.cc:1:124: warning: in order to understand recursion, you must; first understand recursion [-Winfinite-recursion]. We should also run the tests to make sure we didn't break something. .. code:: console. $ ninja check-clang. Notice that it is much faster to build this time, but the tests take; just as long to run. Ninja doesn't know which tests might be affected,; so it runs them all. .. code:: console. ********************; Testing Time: 408.84s; ********************; Failing Tests (1):; Clang :: SemaCXX/warn-infinite-recursion.cpp. Well, that makes sense… and the test output suggests it's looking for; the old string ""call itself"" and finding our new message instead.; Note that more tests may fail in a similar way as new tests are; added time to time. Let's fix it by updating the expectation in the test. .. code:: console. $ vi ../clang/test/SemaCXX/warn-infinite-recursion.cpp. Everywhere we see `// expected-warning{{call itself}}` (or something simila",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:6224,test,test,6224,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['test'],['test']
Testability, clang/lib/Tooling; - `16`; - `7`; - `9`; - :part:`43%`; * - clang/lib/Tooling/ASTDiff; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/Tooling/Core; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/lib/Tooling/DependencyScanning; - `5`; - `4`; - `1`; - :part:`80%`; * - clang/lib/Tooling/DumpTool; - `4`; - `3`; - `1`; - :part:`75%`; * - clang/lib/Tooling/Inclusions; - `3`; - `3`; - `0`; - :good:`100%`; * - clang/lib/Tooling/Refactoring; - `5`; - `3`; - `2`; - :part:`60%`; * - clang/lib/Tooling/Refactoring/Extract; - `2`; - `1`; - `1`; - :part:`50%`; * - clang/lib/Tooling/Refactoring/Rename; - `5`; - `2`; - `3`; - :part:`40%`; * - clang/lib/Tooling/Syntax; - `7`; - `6`; - `1`; - :part:`85%`; * - clang/lib/Tooling/Syntax/Pseudo; - `8`; - `8`; - `0`; - :good:`100%`; * - clang/lib/Tooling/Transformer; - `7`; - `4`; - `3`; - :part:`57%`; * - clang/tools/amdgpu-arch; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/apinotes-test; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/arcmt-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/c-index-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-check; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-diff; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-extdef-mapping; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-format; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/tools/clang-format/fuzzer; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-fuzzer; - `6`; - `4`; - `2`; - :part:`66%`; * - clang/tools/clang-fuzzer/fuzzer-initialize; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-cxx; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/tools/clang-fuzzer/handle-llvm; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/tools/clang-fuzzer/proto-to-cxx; - `5`; - `0`; - `5`; - :none:`0%`; * - clang/tools/clang-fuzzer/proto-to-llvm; - `3`; - `0`; - `3`; - :none:`0%`; * - clang/tools/clang-import-test; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/tools/clang-linker,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:10874,test,test,10874,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['test'],['test']
Testability," code level. Handles; assembly and object-file emission. ``llvm/lib/ExecutionEngine/``. Libraries for directly executing bitcode at runtime in interpreted and; JIT-compiled scenarios. ``llvm/lib/Support/``. Source code that corresponding to the header files in ``llvm/include/ADT/``; and ``llvm/include/Support/``. ``llvm/bindings``; ----------------------. Contains bindings for the LLVM compiler infrastructure to allow; programs written in languages other than C or C++ to take advantage of the LLVM; infrastructure.; LLVM project provides language bindings for OCaml and Python. ``llvm/projects``; -----------------. Projects not strictly part of LLVM but shipped with LLVM. This is also the; directory for creating your own LLVM-based projects which leverage the LLVM; build system. ``llvm/test``; -------------. Feature and regression tests and other sanity checks on LLVM infrastructure. These; are intended to run quickly and cover a lot of territory without being exhaustive. ``test-suite``; --------------. A comprehensive correctness, performance, and benchmarking test suite; for LLVM. This comes in a ``separate git repository; <https://github.com/llvm/llvm-test-suite>``, because it contains a; large amount of third-party code under a variety of licenses. For; details see the :doc:`Testing Guide <TestingGuide>` document. .. _tools:. ``llvm/tools``; --------------. Executables built out of the libraries; above, which form the main part of the user interface. You can always get help; for a tool by typing ``tool_name -help``. The following is a brief introduction; to the most important tools. More detailed information is in; the `Command Guide <CommandGuide/index.html>`_. ``bugpoint``. ``bugpoint`` is used to debug optimization passes or code generation backends; by narrowing down the given test case to the minimum number of passes and/or; instructions that still cause a problem, whether it is a crash or; miscompilation. See `<HowToSubmitABug.html>`_ for more information on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:38156,test,test-suite,38156,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['test'],['test-suite']
Testability," code that corresponding to the header files in ``llvm/include/ADT/``; and ``llvm/include/Support/``. ``llvm/bindings``; ----------------------. Contains bindings for the LLVM compiler infrastructure to allow; programs written in languages other than C or C++ to take advantage of the LLVM; infrastructure.; LLVM project provides language bindings for OCaml and Python. ``llvm/projects``; -----------------. Projects not strictly part of LLVM but shipped with LLVM. This is also the; directory for creating your own LLVM-based projects which leverage the LLVM; build system. ``llvm/test``; -------------. Feature and regression tests and other sanity checks on LLVM infrastructure. These; are intended to run quickly and cover a lot of territory without being exhaustive. ``test-suite``; --------------. A comprehensive correctness, performance, and benchmarking test suite; for LLVM. This comes in a ``separate git repository; <https://github.com/llvm/llvm-test-suite>``, because it contains a; large amount of third-party code under a variety of licenses. For; details see the :doc:`Testing Guide <TestingGuide>` document. .. _tools:. ``llvm/tools``; --------------. Executables built out of the libraries; above, which form the main part of the user interface. You can always get help; for a tool by typing ``tool_name -help``. The following is a brief introduction; to the most important tools. More detailed information is in; the `Command Guide <CommandGuide/index.html>`_. ``bugpoint``. ``bugpoint`` is used to debug optimization passes or code generation backends; by narrowing down the given test case to the minimum number of passes and/or; instructions that still cause a problem, whether it is a crash or; miscompilation. See `<HowToSubmitABug.html>`_ for more information on using; ``bugpoint``. ``llvm-ar``. The archiver produces an archive containing the given LLVM bitcode files,; optionally with an index for faster lookup. ``llvm-as``. The assembler transforms the human readable LLV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:38340,test,test-suite,38340,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['test'],['test-suite']
Testability," code. It's distinctive enough that character sequences that look like the start; or end of a markup element should rarely if ever appear incidentally in logging; text. It's specifically intended not to require sanitizing plain text, such as; the HTML/XML requirement to replace ``<`` with ``&lt;`` and the like. :doc:`llvm-symbolizer <CommandGuide/llvm-symbolizer>` includes a symbolizing; filter via its ``--filter-markup`` option. Also, LLVM utilites emit stack; traces as markup when the ``LLVM_ENABLE_SYMBOLIZER_MARKUP`` environment; variable is set. Scope and assumptions; =====================. A symbolizing filter implementation will be independent both of the target; operating system and machine architecture where the logs are generated and of; the host operating system and machine architecture where the filter runs. This format assumes that the symbolizing filter processes intact whole lines. If; long lines might be split during some stage of a logging pipeline, they must be; reassembled to restore the original line breaks before feeding lines into the; symbolizing filter. Most markup elements must appear entirely on a single line; (often with other text before and/or after the markup element). There are some; markup elements that are specified to span lines, with line breaks in the middle; of the element. Even in those cases, the filter is not expected to handle line; breaks in arbitrary places inside a markup element, but only inside certain; fields. This format assumes that the symbolizing filter processes a coherent stream of; log lines from a single process address space context. If a logging stream; interleaves log lines from more than one process, these must be collated into; separate per-process log streams and each stream processed by a separate; instance of the symbolizing filter. Because the kernel and user processes use; disjoint address regions in most operating systems, a single user process; address space plus the kernel address space can be treate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:2372,log,logging,2372,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['log'],['logging']
Testability, comes with several CMake caches which; predefine common or tricky build configurations. Displaying and Analyzing Results; --------------------------------. The `compare.py` script displays and compares result files. A result file is; produced when invoking lit with the `-o filename.json` flag. Example usage:. - Basic Usage:. ```text; % test-suite/utils/compare.py baseline.json; Warning: 'test-suite :: External/SPEC/CINT2006/403.gcc/403.gcc.test' has No metrics!; Tests: 508; Metric: exec_time. Program baseline. INT2006/456.hmmer/456.hmmer 1222.90; INT2006/464.h264ref/464.h264ref 928.70; ...; baseline; count 506.000000; mean 20.563098; std 111.423325; min 0.003400; 25% 0.011200; 50% 0.339450; 75% 4.067200; max 1222.896800; ```. - Show compile_time or text segment size metrics:. ```bash; % test-suite/utils/compare.py -m compile_time baseline.json; % test-suite/utils/compare.py -m size.__text baseline.json; ```. - Compare two result files and filter short running tests:. ```bash; % test-suite/utils/compare.py --filter-short baseline.json experiment.json; ...; Program baseline experiment diff. SingleSour.../Benchmarks/Linpack/linpack-pc 5.16 4.30 -16.5%; MultiSourc...erolling-dbl/LoopRerolling-dbl 7.01 7.86 12.2%; SingleSour...UnitTests/Vectorizer/gcc-loops 3.89 3.54 -9.0%; ...; ```. - Merge multiple baseline and experiment result files by taking the minimum; runtime each:. ```bash; % test-suite/utils/compare.py base0.json base1.json base2.json vs exp0.json exp1.json exp2.json; ```. ### Continuous Tracking with LNT. LNT is a set of client and server tools for continuously monitoring; performance. You can find more information at; [https://llvm.org/docs/lnt](https://llvm.org/docs/lnt). The official LNT instance; of the LLVM project is hosted at [http://lnt.llvm.org](http://lnt.llvm.org). External Suites; ---------------. External suites such as SPEC can be enabled by either. - placing (or linking) them into the `test-suite/test-suite-externals/xxx` directory (example: `te,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:8095,test,test-suite,8095,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['test'],['test-suite']
Testability," comment, please look at:; >; > http://www.research.att.com/~bs/devXinterview.html. I read this argument. Even before that, I was already in agreement with you; and him that the C declarator syntax is difficult and confusing. But in fact, if you read the entire answer carefully, he came to the same; conclusion I do: that you have to go with familiar syntax over logical; syntax because familiarity is such a strong force:. ""However, familiarity is a strong force. To compare, in English, we; live; more or less happily with the absurd rules for ""to be"" (am, are, is, been,; was, were, ...) and all attempts to simplify are treated with contempt or; (preferably) humor. It be a curious world and it always beed."". > Basically, my argument for this type construction system is that it is; > VERY simple to use and understand (although it IS different than C, it is; > very simple and straightforward, which C is NOT). In fact, I would assert; > that most programmers TODAY do not understand pointers to member; > functions, and have to look up an example when they have to write them. Again, I don't disagree with this at all. But to some extent this; particular problem is inherently difficult. Your syntax for the above; example may be easier for you to read because this is the way you have been; thinking about it. Honestly, I don't find it much easier than the C syntax.; In either case, I would have to look up an example to write pointers to; member functions. But pointers to member functions are nowhere near as common as arrays. And; the old array syntax:; type [ int, int, ...]; is just much more familiar and clear to people than anything new you; introduce, no matter how logical it is. Introducing a new syntax that may; make function pointers easier but makes arrays much more difficult seems; very risky to me. > In my opinion, it is critically important to have clear and concise type; > specifications, because types are going to be all over the programs. I absolutely agree. But the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt:1115,assert,assert,1115,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-02-06-TypeNotationDebateResp1.txt,1,['assert'],['assert']
Testability," compare. .. option:: --compare=<value[,value,...]>. With **value** being one of the options in the following list. .. code-block:: text. =all: Include all the below elements. .. code-block:: text. =lines: Include lines.; =scopes: Include scopes.; =symbols: Include symbols.; =types: Include types. :program:`llvm-debuginfo-analyzer` takes the first binary file on the; command line as the **reference** and the second one as the **target**.; To get a more descriptive report, the comparison is done twice. The; reference and target views are swapped, in order to produce those; **missing** elements from the target view and those **added** elements; to the reference view. See :option:`--report` options on how to describe the comparison; reports. .. _warning_:. WARNING; ~~~~~~~; When reading the input object files, :program:`llvm-debuginfo-analyzer`; can detect issues in the raw debug information. These may not be; considered fatal to the purpose of printing a logical view but they can; give an indication about the quality and potentially expose issues with; the generated debug information. The following options describe the warnings to be recorded for later; printing, if they are requested by :option:`--print`. .. option:: --warning=<value[,value,...]>. With **value** being one of the options in the following list. .. code-block:: text. =all: Include all the below warnings. The following options collect additional information during the creation; of the logical view, to include invalid coverage values and locations; for symbols; invalid code ranges; lines that are zero. .. code-block:: text. =coverages: Invalid symbol coverages values.; =lines: Debug lines that are zero.; =locations: Invalid symbol locations.; =ranges: Invalid code ranges. .. _internal_:. INTERNAL; ~~~~~~~~; For a better understanding of the logical view, access to more detailed; internal information could be needed. Such data would help to identify; debug information processed or incorrect logical element ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:21474,log,logical,21474,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['log'],['logical']
Testability," compiler and set of; flags, and then executed to capture the program output and timing; information. The output of these programs is compared to a reference; output to ensure that the program is being compiled correctly. In addition to compiling and executing programs, whole program tests; serve as a way of benchmarking LLVM performance, both in terms of the; efficiency of the programs generated as well as the speed with which; LLVM compiles, optimizes, and generates code. The test-suite is located in the ``test-suite``; `repository on GitHub <https://github.com/llvm/llvm-test-suite.git>`_. See the :doc:`TestSuiteGuide` for details. Debugging Information tests; ---------------------------. The test suite contains tests to check quality of debugging information.; The test are written in C based languages or in LLVM assembly language. These tests are compiled and run under a debugger. The debugger output; is checked to validate of debugging information. See README.txt in the; test suite for more information. This test suite is located in the; ``cross-project-tests/debuginfo-tests`` directory. Quick start; ===========. The tests are located in two separate repositories. The unit and; regression tests are in the main ""llvm""/ directory under the directories; ``llvm/unittests`` and ``llvm/test`` (so you get these tests for free with the; main LLVM tree). Use ``make check-all`` to run the unit and regression tests; after building LLVM. The ``test-suite`` module contains more comprehensive tests including whole C; and C++ programs. See the :doc:`TestSuiteGuide` for details. Unit and Regression tests; -------------------------. To run all of the LLVM unit tests use the check-llvm-unit target:. .. code-block:: bash. % make check-llvm-unit. To run all of the LLVM regression tests use the check-llvm target:. .. code-block:: bash. % make check-llvm. In order to get reasonable testing performance, build LLVM and subprojects; in release mode, i.e. .. code-block:: bash. % cmake -D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:4410,test,test,4410,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['test']
Testability, compiler-rt/lib/scudo/standalone/tests/common_test.cpp; compiler-rt/lib/scudo/standalone/tests/flags_test.cpp; compiler-rt/lib/scudo/standalone/tests/list_test.cpp; compiler-rt/lib/scudo/standalone/tests/map_test.cpp; compiler-rt/lib/scudo/standalone/tests/memtag_test.cpp; compiler-rt/lib/scudo/standalone/tests/mutex_test.cpp; compiler-rt/lib/scudo/standalone/tests/primary_test.cpp; compiler-rt/lib/scudo/standalone/tests/quarantine_test.cpp; compiler-rt/lib/scudo/standalone/tests/release_test.cpp; compiler-rt/lib/scudo/standalone/tests/report_test.cpp; compiler-rt/lib/scudo/standalone/tests/scudo_unit_test.h; compiler-rt/lib/scudo/standalone/tests/scudo_unit_test_main.cpp; compiler-rt/lib/scudo/standalone/tests/secondary_test.cpp; compiler-rt/lib/scudo/standalone/tests/size_class_map_test.cpp; compiler-rt/lib/scudo/standalone/tests/stats_test.cpp; compiler-rt/lib/scudo/standalone/tests/strings_test.cpp; compiler-rt/lib/scudo/standalone/tests/vector_test.cpp; compiler-rt/lib/scudo/standalone/tests/wrappers_cpp_test.cpp; compiler-rt/lib/scudo/standalone/tests/wrappers_c_test.cpp; compiler-rt/lib/scudo/standalone/tools/compute_size_class_config.cpp; compiler-rt/lib/tsan/rtl/tsan_fd.h; compiler-rt/lib/tsan/rtl/tsan_ignoreset.h; compiler-rt/lib/tsan/rtl/tsan_ilist.h; compiler-rt/lib/tsan/rtl/tsan_interface_ann.h; compiler-rt/lib/tsan/rtl/tsan_mman.h; compiler-rt/lib/tsan/rtl/tsan_mutexset.h; compiler-rt/lib/tsan/rtl/tsan_ppc_regs.h; compiler-rt/lib/tsan/rtl/tsan_rtl_access.cpp; compiler-rt/lib/tsan/rtl/tsan_shadow.h; compiler-rt/lib/tsan/rtl/tsan_stack_trace.h; compiler-rt/lib/tsan/rtl/tsan_suppressions.h; compiler-rt/lib/tsan/rtl/tsan_symbolize.h; compiler-rt/lib/tsan/rtl/tsan_trace.h; compiler-rt/lib/tsan/rtl/tsan_vector_clock.h; compiler-rt/lib/tsan/rtl-old/tsan_fd.h; compiler-rt/lib/tsan/rtl-old/tsan_ignoreset.h; compiler-rt/lib/tsan/rtl-old/tsan_ilist.h; compiler-rt/lib/tsan/rtl-old/tsan_interface_ann.h; compiler-rt/lib/tsan/rtl-old/tsan_mman.h; compiler-rt/lib/tsa,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:103597,test,tests,103597,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['test'],['tests']
Testability," compiler-rt; projects/debuginfo-tests debuginfo-tests; projects/libclc libclc; projects/libcxx libcxx; projects/libcxxabi libcxxabi; projects/libunwind libunwind; tools/lld lld; tools/lldb lldb; projects/openmp openmp; tools/polly polly; projects/myproj local/myproj. If a submodule path does not appear in the map, the tools assumes it; should be placed in the same place in the monorepo. That means if you; use the ""nested sources"" layout in your umrella, you *must* provide; map entries for all of the projects in your umbrella (except llvm).; Otherwise trees from submodule updates will appear underneath llvm in; the zippped history. Because llvm is itself the umbrella, we use --subdir to write its; content into ``llvm`` in the zippped history::. # Import any non-LLVM repositories the umbrella references.; git -C my-monorepo remote add localrepo \; https://my.local.mirror.org/localrepo.git; git fetch localrepo. subprojects=( clang clang-tools-extra compiler-rt debuginfo-tests libclc; libcxx libcxxabi libunwind lld lldb llgo llvm openmp; parallel-libs polly pstl ). # Import histories for upstream split projects (this was probably; # already done for the ``migrate-downstream-fork.py`` run).; for project in ${subprojects[@]}; do; git remote add upstream/split/${project} \; https://github.com/llvm-mirror/${subproject}.git; git fetch umbrella/split/${project}; done. # Import histories for downstream split projects (this was probably; # already done for the ``migrate-downstream-fork.py`` run).; for project in ${subprojects[@]}; do; git remote add local/split/${project} \; https://my.local.mirror.org/${subproject}.git; git fetch local/split/${project}; done. # Import umbrella history. We want this under a different refspec; # so zip-downstream-fork.py knows what it is.; git -C my-monorepo remote add umbrella \; https://my.local.mirror.org/llvm.git; git fetch umbrella. # Create the submodule map.; echo ""tools/clang clang"" > my-monorepo/submodule-map.txt; echo ""tools/clang/too",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:31966,test,tests,31966,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['test'],['tests']
Testability," conditions. void test() {; int x;; if (x) // warn; return;; }. core.uninitialized.CapturedBlockVariable; (C); Check for blocks that capture uninitialized values. void test() {; int x;; ^{ int y = x; }(); // warn; }. core.uninitialized.UndefReturn; (C); Check for uninitialized values being returned to the caller. int test() {; int x;; return x; // warn; }. C++ Checkers. Name, DescriptionExample. cplusplus.NewDelete; (C++); Check for double-free, use-after-free and offset problems involving C++ ; delete. void f(int *p);. void testUseMiddleArgAfterDelete(int *p) {; delete p;; f(p); // warn: use after free; }. class SomeClass {; public:; void f();; };. void test() {; SomeClass *c = new SomeClass;; delete c;; c->f(); // warn: use after free; }. void test() {; int *p = (int *)__builtin_alloca(sizeof(int));; delete p; // warn: deleting memory allocated by alloca; }. void test() {; int *p = new int;; delete p;; delete p; // warn: attempt to free released; }. void test() {; int i;; delete &i; // warn: delete address of local; }. void test() {; int *p = new int[1];; delete[] (++p);; // warn: argument to 'delete[]' is offset by 4 bytes; // from the start of memory allocated by 'new[]'; }. cplusplus.NewDeleteLeaks; (C++); Check for memory leaks. Traces memory managed by new/; delete. void test() {; int *p = new int;; } // warn. Dead Code Checkers. Name, DescriptionExample. deadcode.DeadStores; (C); Check for values stored to variables that are never read afterwards. void test() {; int x;; x = 1; // warn; }. Nullability Checkers. Name, DescriptionExample. nullability.NullPassedToNonnull; (ObjC); Warns when a null pointer is passed to a pointer which has a; _Nonnull type. if (name != nil); return;; // Warning: nil passed to a callee that requires a non-null 1st parameter; NSString *greeting = [@""Hello "" stringByAppendingString:name];. nullability.NullReturnedFromNonnull; (ObjC); Warns when a null pointer is returned from a function that has; _Nonnull return type. - (nonnull id)fi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:5652,test,test,5652,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability," console. clang -cl-std=clc++ test.cl. If there are any global objects to be initialized, the final binary will; contain the ``_GLOBAL__sub_I_test.cl`` kernel to be enqueued. Note that the manual workaround only applies to objects declared at the; program scope. There is no manual workaround for the construction of static; objects with non-trivial constructors inside functions. Global destructors can not be invoked manually in the OpenCL v2.0 drivers.; However, all memory used for program scope objects should be released on; ``clReleaseProgram``. Libraries; ^^^^^^^^^; Limited experimental support of C++ standard libraries for OpenCL is; described in :doc:`OpenCLSupport` page. .. _target_features:. Target-Specific Features and Limitations; ========================================. CPU Architectures Features and Limitations; ------------------------------------------. X86; ^^^. The support for X86 (both 32-bit and 64-bit) is considered stable on; Darwin (macOS), Linux, FreeBSD, and Dragonfly BSD: it has been tested; to correctly compile many large C, C++, Objective-C, and Objective-C++; codebases. On ``x86_64-mingw32``, passing i128(by value) is incompatible with the; Microsoft x64 calling convention. You might need to tweak; ``WinX86_64ABIInfo::classify()`` in lib/CodeGen/Targets/X86.cpp. For the X86 target, clang supports the `-m16` command line; argument which enables 16-bit code output. This is broadly similar to; using ``asm("".code16gcc"")`` with the GNU toolchain. The generated code; and the ABI remains 32-bit but the assembler emits instructions; appropriate for a CPU running in 16-bit mode, with address-size and; operand-size prefixes to enable 32-bit addressing and operations. Several micro-architecture levels as specified by the x86-64 psABI are defined.; They are cumulative in the sense that features from previous levels are; implicitly included in later levels. - ``-march=x86-64``: CMOV, CMPXCHG8B, FPU, FXSR, MMX, FXSR, SCE, SSE, SSE2; - ``-march=x86-64-v2`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:156718,test,tested,156718,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['test'],['tested']
Testability," contains whole programs, which are pieces of code which; can be compiled and linked into a stand-alone program that can be; executed. These programs are generally written in high level languages; such as C or C++. These programs are compiled using a user specified compiler and set of; flags, and then executed to capture the program output and timing; information. The output of these programs is compared to a reference; output to ensure that the program is being compiled correctly. In addition to compiling and executing programs, whole program tests; serve as a way of benchmarking LLVM performance, both in terms of the; efficiency of the programs generated as well as the speed with which; LLVM compiles, optimizes, and generates code. The test-suite is located in the ``test-suite``; `repository on GitHub <https://github.com/llvm/llvm-test-suite.git>`_. See the :doc:`TestSuiteGuide` for details. Debugging Information tests; ---------------------------. The test suite contains tests to check quality of debugging information.; The test are written in C based languages or in LLVM assembly language. These tests are compiled and run under a debugger. The debugger output; is checked to validate of debugging information. See README.txt in the; test suite for more information. This test suite is located in the; ``cross-project-tests/debuginfo-tests`` directory. Quick start; ===========. The tests are located in two separate repositories. The unit and; regression tests are in the main ""llvm""/ directory under the directories; ``llvm/unittests`` and ``llvm/test`` (so you get these tests for free with the; main LLVM tree). Use ``make check-all`` to run the unit and regression tests; after building LLVM. The ``test-suite`` module contains more comprehensive tests including whole C; and C++ programs. See the :doc:`TestSuiteGuide` for details. Unit and Regression tests; -------------------------. To run all of the LLVM unit tests use the check-llvm-unit target:. .. code-block:: bash.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:4124,test,test,4124,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,2,['test'],"['test', 'tests']"
Testability," coverage summaries to just the listed directories. If unset,; coverage reports will include all sources identified by the tooling. **LLVM_INDIVIDUAL_TEST_COVERAGE**:BOOL; Enable individual test case coverage. When set to ON, code coverage data for; each test case will be generated and stored in a separate directory under the; config.test_exec_root path. This feature allows code coverage analysis of each; individual test case. Defaults to OFF. **LLVM_BUILD_LLVM_DYLIB**:BOOL; If enabled, the target for building the libLLVM shared library is added.; This library contains all of LLVM's components in a single shared library.; Defaults to OFF. This cannot be used in conjunction with BUILD_SHARED_LIBS.; Tools will only be linked to the libLLVM shared library if LLVM_LINK_LLVM_DYLIB; is also ON.; The components in the library can be customised by setting LLVM_DYLIB_COMPONENTS; to a list of the desired components.; This option is not available on Windows. **LLVM_BUILD_TESTS**:BOOL; Include LLVM unit tests in the 'all' build target. Defaults to OFF. Targets; for building each unit test are generated in any case. You can build a; specific unit test using the targets defined under *unittests*, such as; ADTTests, IRTests, SupportTests, etc. (Search for ``add_llvm_unittest`` in; the subdirectories of *unittests* for a complete list of unit tests.) It is; possible to build all unit tests with the target *UnitTests*. **LLVM_BUILD_TOOLS**:BOOL; Build LLVM tools. Defaults to ON. Targets for building each tool are generated; in any case. You can build a tool separately by invoking its target. For; example, you can build *llvm-as* with a Makefile-based system by executing *make; llvm-as* at the root of your build directory. **LLVM_CCACHE_BUILD**:BOOL; If enabled and the ``ccache`` program is available, then LLVM will be; built using ``ccache`` to speed up rebuilds of LLVM and its components.; Defaults to OFF. The size and location of the cache maintained; by ``ccache`` can be adjusted",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:16701,test,tests,16701,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['test'],['tests']
Testability," critical section. Applies to:. lock; unlock; sleep; getc; fgets; read; revc; pthread_mutex_lock; pthread_mutex_unlock; mtx_lock; mtx_timedlock; mtx_trylock; mtx_unlock; lock_guard; unique_lock. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();; }. alpha.unix.Chroot; (C); Check improper use of chroot. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. alpha.unix.PthreadLock; (C); Simple lock -> unlock checker; applies to:; pthread_mutex_lock; pthread_rwlock_rdlock; pthread_rwlock_wrlock; lck_mtx_lock; lck_rw_lock_exclusive; lck_rw_lock_shared; pthread_mutex_trylock; pthread_rwlock_tryrdlock; pthread_rwlock_tryrwlock; lck_mtx_try_lock; lck_rw_try_lock_exclusive; lck_rw_try_lock_shared; pthread_mutex_unlock; pthread_rwlock_unlock; lck_mtx_unlock; lck_rw_done. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. alpha.unix.SimpleStream; (C); Check for misuses of stream APIs:; fopen; fclose(demo checker, the subject of the demo; (Slides; ,Video); by Anna Zaks and Jordan Rose presented at the ; 2012 LLVM Developers' Meeting). void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:13405,test,test,13405,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['test'],['test']
Testability," default. .. option:: -register-file-stats. Enable register file usage statistics. .. option:: -dispatch-stats. Enable extra dispatch statistics. This view collects and analyzes instruction; dispatch events, as well as static/dynamic dispatch stall events. This view; is disabled by default. .. option:: -scheduler-stats. Enable extra scheduler statistics. This view collects and analyzes instruction; issue events. This view is disabled by default. .. option:: -retire-stats. Enable extra retire control unit statistics. This view is disabled by default. .. option:: -instruction-info. Enable the instruction info view. This is enabled by default. .. option:: -show-encoding. Enable the printing of instruction encodings within the instruction info view. .. option:: -show-barriers. Enable the printing of LoadBarrier and StoreBarrier flags within the; instruction info view. .. option:: -all-stats. Print all hardware statistics. This enables extra statistics related to the; dispatch logic, the hardware schedulers, the register file(s), and the retire; control unit. This option is disabled by default. .. option:: -all-views. Enable all the view. .. option:: -instruction-tables. Prints resource pressure information based on the static information; available from the processor model. This differs from the resource pressure; view because it doesn't require that the code is simulated. It instead prints; the theoretical uniform distribution of resource pressure for every; instruction in sequence. .. option:: -bottleneck-analysis. Print information about bottlenecks that affect the throughput. This analysis; can be expensive, and it is disabled by default. Bottlenecks are highlighted; in the summary view. Bottleneck analysis is currently not supported for; processors with an in-order backend. .. option:: -json. Print the requested views in valid JSON format. The instructions and the; processor resources are printed as members of special top level JSON objects.; The individual views re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:6163,log,logic,6163,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['log'],['logic']
Testability," defvar suffix = ""_suffstring"";; defvar some_ints = [0, 1, 2, 3];. def name # suffix {; }. foreach i = [1, 2] in {; def rec # i {; }; }. The first ``def`` does not use the value of the ``suffix`` variable. The; second def does use the value of the ``i`` iterator variable, because it is not a; global name. The following records are produced. .. code-block:: text. def namesuffix {; }; def rec1 {; }; def rec2 {; }. Here is a second example illustrating the paste operator in field value expressions. .. code-block:: text. def test {; string strings = suffix # suffix;; list<int> integers = some_ints # [4, 5, 6];; }. The ``strings`` field expression uses ``suffix`` on both sides of the paste; operator. It is evaluated normally on the left hand side, but taken verbatim; on the right hand side. The ``integers`` field expression uses the value of; the ``some_ints`` variable and a literal list. The following record is; produced. .. code-block:: text. def test {; string strings = ""_suffstringsuffix"";; list<int> ints = [0, 1, 2, 3, 4, 5, 6];; }. Appendix C: Sample Record; =========================. One target machine supported by LLVM is the Intel x86. The following output; from TableGen shows the record that is created to represent the 32-bit; register-to-register ADD instruction. .. code-block:: text. def ADD32rr {	// InstructionEncoding Instruction X86Inst I ITy Sched BinOpRR BinOpRR_RF; int Size = 0;; string DecoderNamespace = """";; list<Predicate> Predicates = [];; string DecoderMethod = """";; bit hasCompleteDecoder = 1;; string Namespace = ""X86"";; dag OutOperandList = (outs GR32:$dst);; dag InOperandList = (ins GR32:$src1, GR32:$src2);; string AsmString = ""add{l}	{$src2, $src1|$src1, $src2}"";; EncodingByHwMode EncodingInfos = ?;; list<dag> Pattern = [(set GR32:$dst, EFLAGS, (X86add_flag GR32:$src1, GR32:$src2))];; list<Register> Uses = [];; list<Register> Defs = [EFLAGS];; int CodeSize = 3;; int AddedComplexity = 0;; bit isPreISelOpcode = 0;; bit isReturn = 0;; bit isBranch =",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:74941,test,test,74941,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['test'],['test']
Testability," delete. void f(int *p);. void testUseMiddleArgAfterDelete(int *p) {; delete p;; f(p); // warn: use after free; }. class SomeClass {; public:; void f();; };. void test() {; SomeClass *c = new SomeClass;; delete c;; c->f(); // warn: use after free; }. void test() {; int *p = (int *)__builtin_alloca(sizeof(int));; delete p; // warn: deleting memory allocated by alloca; }. void test() {; int *p = new int;; delete p;; delete p; // warn: attempt to free released; }. void test() {; int i;; delete &i; // warn: delete address of local; }. void test() {; int *p = new int[1];; delete[] (++p);; // warn: argument to 'delete[]' is offset by 4 bytes; // from the start of memory allocated by 'new[]'; }. cplusplus.NewDeleteLeaks; (C++); Check for memory leaks. Traces memory managed by new/; delete. void test() {; int *p = new int;; } // warn. Dead Code Checkers. Name, DescriptionExample. deadcode.DeadStores; (C); Check for values stored to variables that are never read afterwards. void test() {; int x;; x = 1; // warn; }. Nullability Checkers. Name, DescriptionExample. nullability.NullPassedToNonnull; (ObjC); Warns when a null pointer is passed to a pointer which has a; _Nonnull type. if (name != nil); return;; // Warning: nil passed to a callee that requires a non-null 1st parameter; NSString *greeting = [@""Hello "" stringByAppendingString:name];. nullability.NullReturnedFromNonnull; (ObjC); Warns when a null pointer is returned from a function that has; _Nonnull return type. - (nonnull id)firstChild {; id result = nil;; if ([_children count] > 0); result = _children[0];. // Warning: nil returned from a method that is expected; // to return a non-null value; return result;; }. nullability.NullableDereferenced; (ObjC); Warns when a nullable pointer is dereferenced. struct LinkedList {; int data;; struct LinkedList *next;; };. struct LinkedList * _Nullable getNext(struct LinkedList *l);. void updateNextData(struct LinkedList *list, int newData) {; struct LinkedList *next = getNext(li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:6166,test,test,6166,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability," different output generated by; :program:`llvm-debuginfo-analyzer`. We compiled the example for an X86; Codeview and ELF targets with recent versions of Clang, GCC and MSVC; (-O0 -g). .. code-block:: c++. 1 int bar(float Input) { return (int)Input; }; 2; 3 unsigned foo(char Param) {; 4 typedef int INT; // ** Definition for INT **; 5 INT Value = Param;; 6 {; 7 typedef float FLOAT; // ** Definition for FLOAT **; 8 {; 9 FLOAT Added = Value + Param;; 10 Value = bar(Added);; 11 }; 12 }; 13 return Value + Param;; 14 }. The above test is used to illustrate a scope issue found in the Clang; compiler:; `PR44884 (Bugs LLVM) <https://bugs.llvm.org/show_bug.cgi?id=44884>`_ /; `PR44229 (GitHub LLVM) <https://github.com/llvm/llvm-project/issues/44229>`_. The lines 4 and 7 contains 2 typedefs, defined at different lexical; scopes. .. code-block:: c++. 4 typedef int INT;; 7 typedef float FLOAT;. These are the logical views that :program:`llvm-debuginfo-analyzer`; generates for 3 different compilers (MSVC, Clang and GCC), emitting; different debug information formats (CodeView, DWARF) on different; platforms. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format,producer; --print=symbols,types,lines; --output-sort=kind; pr-44884-codeview-clang.o; pr-44884-codeview-msvc.o; pr-44884-dwarf-clang.o; pr-44884-dwarf-gcc.o. CodeView - Clang (Windows); ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: none. Logical View:; [000] {File} 'pr-44884-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-44884.cpp'; [002] {Producer} 'clang version 14.0.0'; [002] {Function} extern not_inlined 'bar' -> 'int'; [003] {Parameter} 'Input' -> 'float'; [003] 1 {Line}; [002] {Function} extern not_inlined 'foo' -> 'unsigned'; [003] {Block}; [004] {Variable} 'Added' -> 'float'; [004] 9 {Line}; [004] 10 {Line}; [003] {Parameter} 'Param' -> 'char'; [003] {TypeAlias} 'FLOAT' -> 'float'; [003] {TypeAlias} 'INT' -> 'int'; [003] {Variable} 'Value' -> 'int'; [003] 3 {Line}; [003] 5 {Line}; [003] 13 {L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:37072,log,logical,37072,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['log'],['logical']
Testability," different results. For example, the LLVM nightly tester uses ``TEST.nightly.Makefile`` to; create the nightly test reports. To run the nightly tests, run; ``gmake TEST=nightly``. There are several TEST Makefiles available in the tree. Some of them are; designed for internal LLVM research and will not work outside of the; LLVM research group. They may still be valuable, however, as a guide to; writing your own TEST Makefile for any optimization or analysis passes; that you develop with LLVM. Generating Test Output; ======================. There are a number of ways to run the tests and generate output. The; most simple one is simply running ``gmake`` with no arguments. This will; compile and run all programs in the tree using a number of different; methods and compare results. Any failures are reported in the output,; but are likely drowned in the other output. Passes are not reported; explicitly. Somewhat better is running ``gmake TEST=sometest test``, which runs the; specified test and usually adds per-program summaries to the output; (depending on which sometest you use). For example, the ``nightly`` test; explicitly outputs TEST-PASS or TEST-FAIL for every test after each; program. Though these lines are still drowned in the output, it's easy; to grep the output logs in the Output directories. Even better are the ``report`` and ``report.format`` targets (where; ``format`` is one of ``html``, ``csv``, ``text`` or ``graphs``). The; exact contents of the report are dependent on which ``TEST`` you are; running, but the text results are always shown at the end of the run and; the results are always stored in the ``report.<type>.format`` file (when; running with ``TEST=<type>``). The ``report`` also generate a file; called ``report.<type>.raw.out`` containing the output of the entire; test run. Writing Custom Tests for the test-suite; =======================================. Assuming you can run the test suite, (e.g.; ""``gmake TEST=nightly report``"" should work), it is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:4111,test,test,4111,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,2,['test'],['test']
Testability," different; file format is specified, :program:`llvm-size` falls back to ``berkeley``; format. When producing ``darwin`` format, the tool displays information about; segments and sections:. .. code-block:: console. $ llvm-size --format=darwin macho.obj macho2.obj; macho.obj:; Segment : 12; Section (__TEXT, __text): 4; Section (__DATA, __data): 8; total 12; total 12; macho2.obj:; Segment : 48; Section (__TEXT, __text): 16; Section (__DATA, __data): 32; total 48; total 48. .. option:: --help, -h. Display a summary of command line options. .. option:: -m. Equivalent to :option:`--format` with a value of ``darwin``. .. option:: -o. Equivalent to :option:`--radix` with a value of ``8``. .. option:: --radix=<value>. Display size information in the specified radix. Permitted values are ``8``,; ``10`` (the default) and ``16`` for octal, decimal and hexadecimal output; respectively. Example:. .. code-block:: console. $ llvm-size --radix=8 test.o; text data bss oct hex filename; 0152 04 04 162 72 test.o. $ llvm-size --radix=10 test.o; text data bss dec hex filename; 106 4 4 114 72 test.o. $ llvm-size --radix=16 test.o; text data bss dec hex filename; 0x6a 0x4 0x4 114 72 test.o. .. option:: --totals, -t. Applies only to ``berkeley`` output format. Display the totals for all listed; fields, in addition to the individual file listings. Example:. .. code-block:: console. $ llvm-size --totals test.elf test2.o; text data bss dec hex filename; 182 16 5 203 cb test.elf; 82 8 1 91 5b test2.o; 264 24 6 294 126 (TOTALS). .. option:: --version. Display the version of the :program:`llvm-size` executable. .. option:: -x. Equivalent to :option:`--radix` with a value of ``16``. .. option:: @<FILE>. Read command-line options from response file ``<FILE>``. EXIT STATUS; -----------. :program:`llvm-size` exits with a non-zero exit code if there is an error.; Otherwise, it exits with code 0. BUGS; ----. To report bugs, please visit <https://github.com/llvm/llvm-project/labels/tools:llvm-size/>.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-size.rst:3568,test,test,3568,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-size.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-size.rst,6,['test'],['test']
Testability," directory. The appropriate sub-directory should be selected (see the; :doc:`Testing Guide <TestingGuide>` for details). * Test cases should be written in :doc:`LLVM assembly language <LangRef>`. * Test cases, especially for regressions, should be reduced as much as possible,; by :doc:`bugpoint <Bugpoint>` or manually. It is unacceptable to place an; entire failing program into ``llvm/test`` as this creates a *time-to-test*; burden on all developers. Please keep them short. * Avoid adding links to resources that are not available to the entire; community, such as links to private bug trackers, internal corporate; documentation, etc. Instead, add sufficient comments to the test to provide; the context behind such links. Note that llvm/test and clang/test are designed for regression and small feature; tests only. More extensive test cases (e.g., entire applications, benchmarks,; etc) should be added to the ``llvm-test`` test suite. The llvm-test suite is; for coverage (correctness, performance, etc) testing, not feature or regression; testing. Release Notes; -------------. Many projects in LLVM communicate important changes to users through release; notes, typically found in ``docs/ReleaseNotes.rst`` for the project. Changes to; a project that are user-facing, or that users may wish to know about, should be; added to the project's release notes at the author's or code reviewer's; discretion, preferably as part of the commit landing the changes. Examples of; changes that would typically warrant adding a release note (this list is not; exhaustive):. * Adding, removing, or modifying command-line options.; * Adding, removing, or regrouping a diagnostic.; * Fixing a bug that potentially has significant user-facing impact (please link; to the issue fixed in the bug database).; * Adding or removing optimizations that have widespread impact or enables new; programming paradigms.; * Modifying a C stable API.; * Notifying users about a potentially disruptive change expected to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:10676,test,test,10676,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,3,['test'],"['test', 'testing']"
Testability," do end up instrumenting with XRay) then we need to enable XRay; at application start. To do this, XRay checks the ``XRAY_OPTIONS`` environment; variable. ::. # The following doesn't create an XRay trace by default.; $ ./bin/llc input.ll. # We need to set the XRAY_OPTIONS to enable some features.; $ XRAY_OPTIONS=""patch_premain=true xray_mode=xray-basic verbosity=1"" ./bin/llc input.ll; ==69819==XRay: Log file in 'xray-log.llc.m35qPB'. At this point we now have an XRay trace we can start analysing. The ``llvm-xray`` Tool; ----------------------. Having a trace then allows us to do basic accounting of the functions that were; instrumented, and how much time we're spending in parts of the code. To make; sense of this data, we use the ``llvm-xray`` tool which has a few subcommands; to help us understand our trace. One of the things we can do is to get an accounting of the functions that have; been instrumented. We can see an example accounting with ``llvm-xray account``:. ::. $ llvm-xray account xray-log.llc.m35qPB --top=10 --sort=sum --sortorder=dsc --instr_map=./bin/llc; Functions with latencies: 29; funcid count [ min, med, 90p, 99p, max] sum function; 187 360 [ 0.000000, 0.000001, 0.000014, 0.000032, 0.000075] 0.001596 LLLexer.cpp:446:0: llvm::LLLexer::LexIdentifier(); 85 130 [ 0.000000, 0.000000, 0.000018, 0.000023, 0.000156] 0.000799 X86ISelDAGToDAG.cpp:1984:0: (anonymous namespace)::X86DAGToDAGISel::Select(llvm::SDNode*); 138 130 [ 0.000000, 0.000000, 0.000017, 0.000155, 0.000155] 0.000774 SelectionDAGISel.cpp:2963:0: llvm::SelectionDAGISel::SelectCodeCommon(llvm::SDNode*, unsigned char const*, unsigned int); 188 103 [ 0.000000, 0.000000, 0.000003, 0.000123, 0.000214] 0.000737 LLParser.cpp:2692:0: llvm::LLParser::ParseValID(llvm::ValID&, llvm::LLParser::PerFunctionState*); 88 1 [ 0.000562, 0.000562, 0.000562, 0.000562, 0.000562] 0.000562 X86ISelLowering.cpp:83:0: llvm::X86TargetLowering::X86TargetLowering(llvm::X86TargetMachine const&, llvm::X86Subtarget const&); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayExample.rst:2796,log,log,2796,interpreter/llvm-project/llvm/docs/XRayExample.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayExample.rst,1,['log'],['log']
Testability," do not split the header; ```. ### Streamers with Special Additions. Most of the time you can let `rootcling` generate a `Streamer` for you.; However if you want to write your own `Streamer `you can do so. For some; classes, it may be necessary to execute some code before or after the; read or write block in the automatic `Streamer`. For example after the; execution of the read block, one can initialize some non persistent; members. There are two reasons why you would need to write your own; Streamer: 1) if you have a non-persistent data member that you want to; initialize to a value depending on the read data members; 2) if you want; or need to handle the schema evolution on your own. Note that an alternative; for those cases is to consider write a schema evolution rule. First, you need to tell `rootcling` not to build a `Streamer `for you.; The input to the `rootcling` command (in the `makefile`) is a list of; classes in a `LinkDef.h` file. For example, the list of classes for; `Event` is listed in `$ROOTSYS/test/EventLinkDef.h`. The ""`-`"" at the; end of the class name tells `rootcling` not to generate a `Streamer`. In; the example, you can see the `Event` class is the only one for which; `rootcling` is instructed not to generate a `Streamer`. ``` {.cpp}; #ifdef __ROOTCLING__. #pragma link off all globals;; #pragma link off all classes;; #pragma link off all functions;; #pragma link C++ class EventHeader+;; #pragma link C++ class Event-;; #pragma link C++ class HistogramManager+;; #pragma link C++ class Track+;. #endif; #pragma link C++ class EventHeader+;; ```. The ""`+`"" sign tells `rootcling` to use the new `Streamer `system; introduced in ROOT 3.0. The following is an example of a customized; `Streamer `for `Event`. The `Streamer` takes a **`TBuffer`** as a; parameter, and first checks to see if this is a case of reading or; writing the buffer. ``` {.cpp}; void Event::Streamer(TBuffer &R__b) {; if (R__b.IsReading()) {; Event::Class()->ReadBuffer(R__b, this);; f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:49995,test,test,49995,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['test'],['test']
Testability," do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:4228,test,test,4228,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,1,['test'],['test']
Testability," draw options:; - ""RX"" and ""RY"" for TGraph to reverse axis; - ""noopt"" for TGraph to disable drawing optimization; - ""CPN"" for TCanvas to create color palette from N last colors; - ""line"" for TGraph2D; * New features:; - support LZ4 compression; - tooltips and zooming in TGraphPolar drawings; - TPavesText with multiple underlying paves; - implement all fill styles; - draw borders for TWbox; - draw all objects from TList/TObjArray as they appear in list of primitives; - let enable/disable highlight of extra objects in geometry viewer; - draw axis labels on both sides when pad.fTick[x/y] > 1; - make drawing of TCanvas with many primitives smoother; - add fOptTitle, fOptLogx/y/z fields in JSROOT.gStyle; * Behavior changes:; - disable automatic frame adjustment, can be enabled with ""&adjframe"" parameter in URL; - when drawing TH2/TH3 scatter plots, always generate same ""random"" pattern; - use barwidth/baroffset parameters in lego plots; * Bug fixes:; - use same number of points to draw lines and markers on the TGraph; - correctly draw filled TArrow endings; - let combine ""L"" or ""C"" TGraph draw option with others; - correct positioning of custom axis labels; - correctly toggle lin/log axes in lego plot; - let correctly change marker attributes interactively ; - monitoring mode in draw.htm page; - zooming in colz palette; - support both 9.x and 10.x jsdom version in Node.js (#149); - draw axis main line with appropriate attributes (#150); - use axis color when drawing grids lines (#150); - when set pad logx/logy, reset existing user ranges in pad; - avoid too deep calling stack when drawing many graphs or histos (#154); - correctly (re)draw tooltips on canvas with many subpads. ## Code Examples. - New graphics tutorial AtlasExample.C illustrating the ATLAS style.; - New TLazyDS tutorial added tdf015_LazyDataSource.C.; - Show how to inspect a `TCutFlowReport` object. ## Class Reference Guide. - Replace low resolution images with bigger ones more suited for modern screens. ##",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:16816,log,log,16816,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['log'],['log']
Testability," dropped during upgrades. * Non-debug metadata is defined to be safe to drop, so a valid way to upgrade; it is to drop it. That is not very user friendly and a bit more effort is; expected, but no promises are made. C API Changes; -------------. * Stability Guarantees: The C API is, in general, a ""best effort"" for stability.; This means that we make every attempt to keep the C API stable, but that; stability will be limited by the abstractness of the interface and the; stability of the C++ API that it wraps. In practice, this means that things; like ""create debug info"" or ""create this type of instruction"" are likely to be; less stable than ""take this IR file and JIT it for my current machine"". * Release stability: We won't break the C API on the release branch with patches; that go on that branch, with the exception that we will fix an unintentional; C API break that will keep the release consistent with both the previous and; next release. * Testing: Patches to the C API are expected to come with tests just like any; other patch. * Including new things into the API: If an LLVM subcomponent has a C API already; included, then expanding that C API is acceptable. Adding C API for; subcomponents that don't currently have one needs to be discussed on the; `LLVM Discourse forums`_ for design and maintainability feedback prior to implementation. * Documentation: Any changes to the C API are required to be documented in the; release notes so that it's clear to external users who do not follow the; project how the C API is changing and evolving. .. _toolchain:. Updating Toolchain Requirements; -------------------------------. We intend to require newer toolchains as time goes by. This means LLVM's; codebase can use newer versions of C++ as they get standardized. Requiring newer; toolchains to build LLVM can be painful for those building LLVM; therefore, it; will only be done through the following process:. * It is a general goal to support LLVM and GCC versions from the las",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:33346,test,tests,33346,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['test'],['tests']
Testability," dumps). .. option:: --print-delta-passes . Print list of delta passes, passable to --delta-passes as a comma separated liste. .. option:: --skip-delta-passes=<string> . Delta passes to not run, separated by commas. By default, run all delta passes. .. option:: --starting-granularity-level=<uint>. Number of times to divide chunks prior to first test. Note : Granularity refers to the level of detail at which the reduction process operates.; A lower granularity means that the reduction process operates at a more coarse-grained level,; while a higher granularity means that it operates at a more fine-grained level. .. option:: --test=<string> . Name of the interesting-ness test to be run. .. option:: --test-arg=<string> . Arguments passed onto the interesting-ness test. .. option:: --verbose . Print extra debugging information.; ; .. option:: --write-tmp-files-as-bitcode . Always write temporary files as bitcode instead of textual IR. .. option:: -x={ir|mir}. Input language as ir or mir. EXIT STATUS; ------------. :program:`llvm-reduce` returns 0 under normal operation. It returns a non-zero; exit code if there were any errors. EXAMPLE; -------. :program:`llvm-reduce` can be used to simplify a test that causes a; compiler crash. For example, let's assume that `opt` is crashing on the IR file; `test.ll` with error message `Assertion failed at line 1234 of; WhateverFile.cpp`, when running at `-O2`. The test case of `test.ll` can be reduced by invoking the following; command:. .. code-block:: bash. $(LLVM_BUILD_FOLDER)/bin/llvm-reduce --test=script.sh <path to>/test.ll. The shell script passed to the option `test` consists of the; following:. .. code-block:: bash. $(LLVM_BUILD_FOLDER)/bin/opt -O2 -disable-output $1 \; |& grep ""Assertion failed at line 1234 of WhateverFile.cpp"". (In this script, `grep` exits with 0 if it finds the string and that; becomes the whole script's status.). This example can be generalized to other tools that process IR files,; for example `llc`.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst:2897,test,test,2897,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst,7,['test'],['test']
Testability," during the; code review stage and do not pollute the main branch. Our goal with pre-merge testing is to report most true problems while strongly; minimizing the number of false positive reports. Our goal is that problems; reported are always actionable. If you notice a false positive, please report; it so that we can identify the cause. If you notice issues or have an idea on how to improve pre-merge checks, please; `create a new issue <https://github.com/google/llvm-premerge-checks/issues/new>`_; or give a ❤️ to an existing one. Requirements; ^^^^^^^^^^^^. To get a patch on Phabricator tested, the build server must be able to apply the; patch to the checked out git repository. Please make sure that either:. * You set a git hash as ``sourceControlBaseRevision`` in Phabricator which is; available on the GitHub repository,; * **or** you define the dependencies of your patch in Phabricator,; * **or** your patch can be applied to the main branch. Only then can the build server apply the patch locally and run the builds and; tests. Accessing build results; ^^^^^^^^^^^^^^^^^^^^^^^; Phabricator will automatically trigger a build for every new patch you upload or; modify. Phabricator shows the build results at the top of the entry. Clicking on; the links (in the red box) will show more details:. .. image:: Phabricator_premerge_results.png. The CI will compile and run tests, run clang-format and clang-tidy on lines; changed. If a unit test failed, this is shown below the build status. You can also expand; the unit test to see the details:. .. image:: Phabricator_premerge_unit_tests.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might be able to improve in the future. Operational Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:11783,test,tests,11783,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['test'],['tests']
Testability," e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:34067,test,test,34067,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['test'],['test']
Testability," enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells CMake to pass the variables on to the instrumented; stage two build. And the CLANG_PGO_TRAINING_DEPS option let's you specify; additional build targets to build before building the external project. The; LLVM Test Suite requires compiler-rt to build, so we need to add the; `runtimes` target as a dependency. After configuration, building the stage2-instrumented-generate-profdata target; will automatically build the stage1 compiler, build the instrumented compiler; with the stage1 compiler, and then run the instrumented compiler against the; perf training data:. .. code-block:: console. $ ninja stage2-instrumented-generate-profdata. If you let that run for a few hours or so, it will place a profdata file in your; build directory. This takes a really long time because it builds clang twice,; and you *must* have compiler-rt in your build tree. This process uses any source files under the perf-t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:6899,test,test-suite,6899,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['test'],['test-suite']
Testability," environment variable; ``LIT_RUN_SHARD`` can also be used in place of this option. .. option:: --timeout=N. Spend at most ``N`` seconds (approximately) running each individual test.; ``0`` means no time limit, and ``0`` is the default. Note that this is not an; alias for :option:`--max-time`; the two are different kinds of maximums. .. option:: --filter=REGEXP. Run only those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER`` can be also used in place; of this option, which is especially useful in environments where the call; to ``lit`` is issued indirectly. .. option:: --filter-out=REGEXP. Filter out those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER_OUT`` can be also used in; place of this option, which is especially useful in environments where the; call to ``lit`` is issued indirectly. .. option:: --xfail=LIST. Treat those tests whose name is in the semicolon separated list ``LIST`` as; ``XFAIL``. This can be helpful when one does not want to modify the test; suite. The environment variable ``LIT_XFAIL`` can be also used in place of; this option, which is especially useful in environments where the call to; ``lit`` is issued indirectly. A test name can specified as a file name relative to the test suite directory.; For example:. .. code-block:: none. LIT_XFAIL=""affinity/kmp-hw-subset.c;offloading/memory_manager.cpp"". In this case, all of the following tests are treated as ``XFAIL``:. .. code-block:: none. libomp :: affinity/kmp-hw-subset.c; libomptarget :: nvptx64-nvidia-cuda :: offloading/memory_manager.cpp; libomptarget :: x86_64-pc-linux-gnu :: offloading/memory_manager.cpp. Alternatively, a test name can be specified as the full test name; reported in LIT output. For example, we can adjust the previous; example not to treat the ``nvptx64-nvidia-cuda`` version of; ``offloading/memory_manager.cpp`` as XFAIL:. .. code-block:: none. L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:8714,test,tests,8714,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['tests']
Testability," example the following; toy program that we build with XRay instrumentation, we can see how the; generated graph may be a helpful indicator of where time is being spent for the; application. .. code-block:: c++. // sample.cc; #include <iostream>; #include <thread>. [[clang::xray_always_instrument]] void f() {; std::cerr << '.';; }. [[clang::xray_always_instrument]] void g() {; for (int i = 0; i < 1 << 10; ++i) {; std::cerr << '-';; }; }. int main(int argc, char* argv[]) {; std::thread t1([] {; for (int i = 0; i < 1 << 10; ++i); f();; });; std::thread t2([] {; g();; });; t1.join();; t2.join();; std::cerr << '\n';; }. We then build the above with XRay instrumentation:. ::. $ clang++ -o sample -O3 sample.cc -std=c++11 -fxray-instrument -fxray-instruction-threshold=1; $ XRAY_OPTIONS=""patch_premain=true xray_mode=xray-basic"" ./sample. We can then explore the graph rendering of the trace generated by this sample; application. We assume you have the graphviz tools available in your system,; including both ``unflatten`` and ``dot``. If you prefer rendering or exploring; the graph using another tool, then that should be feasible as well. ``llvm-xray; graph`` will create DOT format graphs which should be usable in most graph; rendering applications. One example invocation of the ``llvm-xray graph``; command should yield some interesting insights to the workings of C++; applications:. ::. $ llvm-xray graph xray-log.sample.* -m sample --color-edges=sum --edge-label=sum \; | unflatten -f -l10 | dot -Tsvg -o sample.svg. Next Steps; ----------. If you have some interesting analyses you'd like to implement as part of the; llvm-xray tool, please feel free to propose them on the llvm-dev@ mailing list.; The following are some ideas to inspire you in getting involved and potentially; making things better. - Implement a query/filtering library that allows for finding patterns in the; XRay traces.; - Collecting function call stacks and how often they're encountered in the; XRay trace.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayExample.rst:15486,log,log,15486,interpreter/llvm-project/llvm/docs/XRayExample.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRayExample.rst,1,['log'],['log']
Testability," example, lets say we are developing a replacement for the standard; Unix Bourne shell (``/bin/sh``). To run ``/bin/sh``, first you specify options; to the shell itself (like ``-x`` which turns on trace output), then you specify; the name of the script to run, then you specify arguments to the script. These; arguments to the script are parsed by the Bourne shell command line option; processor, but are not interpreted as options to the shell itself. Using the; CommandLine library, we would specify this as:. .. code-block:: c++. cl::opt<string> Script(cl::Positional, cl::desc(""<input script>""), cl::init(""-""));; cl::list<string> Argv(cl::ConsumeAfter, cl::desc(""<program arguments>...""));; cl::opt<bool> Trace(""x"", cl::desc(""Enable trace output""));. which automatically provides the help output:. ::. USAGE: spiffysh [options] <input script> <program arguments>... OPTIONS:; -help - display available options (-help-hidden for more); -x - Enable trace output. At runtime, if we run our new shell replacement as ```spiffysh -x test.sh -a -x; -y bar``', the ``Trace`` variable will be set to true, the ``Script`` variable; will be set to ""``test.sh``"", and the ``Argv`` list will contain ``[""-a"", ""-x"",; ""-y"", ""bar""]``, because they were specified after the last positional argument; (which is the script name). There are several limitations to when ``cl::ConsumeAfter`` options can be; specified. For example, only one ``cl::ConsumeAfter`` can be specified per; program, there must be at least one `positional argument`_ specified, there must; not be any `cl::list`_ positional arguments, and the ``cl::ConsumeAfter`` option; should be a `cl::list`_ option. .. _can be changed:; .. _Internal vs External Storage:. Internal vs External Storage; ----------------------------. By default, all command line options automatically hold the value that they; parse from the command line. This is very convenient in the common case,; especially when combined with the ability to define command line option",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:32285,test,test,32285,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['test'],['test']
Testability," expressions and compile time; constants are available in an unreduced form in the AST. This makes; Clang's AST a good fit for refactoring tools. Documentation for all Clang AST nodes is available via the generated; `Doxygen <https://clang.llvm.org/doxygen>`_. The doxygen online; documentation is also indexed by your favorite search engine, which will; make a search for clang and the AST node's class name usually turn up; the doxygen of the class you're looking for (for example, search for:; clang ParenExpr). Examining the AST; =================. A good way to familiarize yourself with the Clang AST is to actually look; at it on some simple example code. Clang has a builtin AST-dump mode,; which can be enabled with the flag ``-ast-dump``. Let's look at a simple example AST:. ::. $ cat test.cc; int f(int x) {; int result = (x / 42);; return result;; }. # Clang by default is a frontend for many tools; -Xclang is used to pass; # options directly to the C++ frontend.; $ clang -Xclang -ast-dump -fsyntax-only test.cc; TranslationUnitDecl 0x5aea0d0 <<invalid sloc>>; ... cutting out internal declarations of clang ...; `-FunctionDecl 0x5aeab50 <test.cc:1:1, line:4:1> f 'int (int)'; |-ParmVarDecl 0x5aeaa90 <line:1:7, col:11> x 'int'; `-CompoundStmt 0x5aead88 <col:14, line:4:1>; |-DeclStmt 0x5aead10 <line:2:3, col:24>; | `-VarDecl 0x5aeac10 <col:3, col:23> result 'int'; | `-ParenExpr 0x5aeacf0 <col:16, col:23> 'int'; | `-BinaryOperator 0x5aeacc8 <col:17, col:21> 'int' '/'; | |-ImplicitCastExpr 0x5aeacb0 <col:17> 'int' <LValueToRValue>; | | `-DeclRefExpr 0x5aeac68 <col:17> 'int' lvalue ParmVar 0x5aeaa90 'x' 'int'; | `-IntegerLiteral 0x5aeac90 <col:21> 'int' 42; `-ReturnStmt 0x5aead68 <line:3:3, col:10>; `-ImplicitCastExpr 0x5aead50 <col:10> 'int' <LValueToRValue>; `-DeclRefExpr 0x5aead28 <col:10> 'int' lvalue Var 0x5aeac10 'result' 'int'. The toplevel declaration in; a translation unit is always the `translation unit; declaration <https://clang.llvm.org/doxygen/classclang_1_1Tra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:1756,test,test,1756,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,1,['test'],['test']
Testability," finds a :file:`lit.cfg` or; :file:`lit.site.cfg` file. These files serve as both a marker of test suites; and as configuration files which :program:`lit` loads in order to understand; how to find and run the tests inside the test suite. Once :program:`lit` has mapped the inputs into test suites it traverses the; list of inputs adding tests for individual files and recursively searching for; tests in directories. This behavior makes it easy to specify a subset of tests to run, while still; allowing the test suite configuration to control exactly how tests are; interpreted. In addition, :program:`lit` always identifies tests by the test; suite they are in, and their relative path inside the test suite. For; appropriately configured projects, this allows :program:`lit` to provide; convenient and flexible support for out-of-tree builds. .. _test-status-results:. TEST STATUS RESULTS; -------------------. Each test ultimately produces one of the following eight results:. **PASS**. The test succeeded. **FLAKYPASS**. The test succeeded after being re-run more than once. This only applies to; tests containing an ``ALLOW_RETRIES:`` annotation. **XFAIL**. The test failed, but that is expected. This is used for test formats which allow; specifying that a test does not currently work, but wish to leave it in the test; suite. **XPASS**. The test succeeded, but it was expected to fail. This is used for tests which; were specified as expected to fail, but are now succeeding (generally because; the feature they test was broken and has been fixed). **FAIL**. The test failed. **UNRESOLVED**. The test result could not be determined. For example, this occurs when the test; could not be run, the test itself is invalid, or the test was interrupted. **UNSUPPORTED**. The test is not supported in this environment. This is used by test formats; which can report unsupported tests. **TIMEOUT**. The test was run, but it timed out before it was able to complete. This is; considered a failure. De",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:12463,test,test,12463,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['test']
Testability," flag for obtaining; the command line of the child process:. $ clang --analyze test.c -\#\#\#. Below we describe a few useful command line arguments, all of which assume that; you are running clang -cc1. Narrowing Down the Problem; While investigating a checker-related issue, instruct the analyzer to only; execute a single checker:. $ clang -cc1 -analyze -analyzer-checker=osx.KeychainAPI test.c. If you are experiencing a crash, to see which function is failing while; processing a large file use the -analyzer-display-progress; option.; To selectively analyze only the given function, use the; -analyze-function option:. $ clang -cc1 -analyze -analyzer-checker=core test.c -analyzer-display-progress; ANALYZE (Syntax): test.c foo; ANALYZE (Syntax): test.c bar; ANALYZE (Path, Inline_Regular): test.c bar; ANALYZE (Path, Inline_Regular): test.c foo; $ clang -cc1 -analyze -analyzer-checker=core test.c -analyzer-display-progress -analyze-function=foo; ANALYZE (Syntax): test.c foo; ANALYZE (Path, Inline_Regular): test.c foo. Note: a fully qualified function name has to be used when selecting; C++ functions and methods, Objective-C methods and blocks, e.g.:. $ clang -cc1 -analyze -analyzer-checker=core test.cc -analyze-function='foo(int)'. The fully qualified name can be found from the; -analyzer-display-progress output. The bug reporter mechanism removes path diagnostics inside intermediate; function calls that have returned by the time the bug was found and contain; no interesting pieces. Usually it is up to the checkers to produce more; interesting pieces by adding custom BugReporterVisitor objects.; However, you can disable path pruning while debugging with the; -analyzer-config prune-paths=false option. Visualizing the Analysis; To dump the AST, which often helps understanding how the program should; behave:. $ clang -cc1 -ast-dump test.c. To view/dump CFG use debug.ViewCFG or debug.DumpCFG; checkers:. $ clang -cc1 -analyze -analyzer-checker=debug.ViewCFG test.c. ExplodedGr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:20260,test,test,20260,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['test'],['test']
Testability," flags for test case. We must also tell; cmake that we wish to run the tests on ``qemu-arm``. * ``-DCOMPILER_RT_EMULATOR=""qemu-arm -L /path/to/armhf/sysroot``; * ``-DCOMPILER_RT_INCLUDE_TESTS=ON``; * ``-DCOMPILER_RT_TEST_COMPILER=""/path/to/clang""``; * ``-DCOMPILER_RT_TEST_COMPILER_CFLAGS=""test-c-flags""``. The ``/path/to/armhf/sysroot`` should be the same as the one passed to; ``--sysroot`` in the ""build-c-flags"". The ""test-c-flags"" need to include the target, architecture, gcc-toolchain,; sysroot and arm/thumb state. The additional cmake defines such as; ``CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN`` do not apply when building the tests. If; you have put all of these in ""build-c-flags"" then these can be repeated. If you; wish to use lld to link the tests then add ``""-fuse-ld=lld``. Once cmake has completed the tests can be built and run using; ``ninja check-builtins``. Troubleshooting; ===============. The cmake try compile stage fails; ---------------------------------; At an early stage cmake will attempt to compile and link a simple C program to; test if the toolchain is working. This stage can often fail at link time if the ``--sysroot=`` and; ``--gcc-toolchain=`` options are not passed to the compiler. Check the; ``CMAKE_C_FLAGS`` and ``CMAKE_C_COMPILER_TARGET`` flags. It can be useful to build a simple example outside of cmake with your toolchain; to make sure it is working. For example: ``clang --target=arm-linux-gnueabi -march=armv7a --gcc-toolchain=/path/to/gcc-toolchain --sysroot=/path/to/gcc-toolchain/arm-linux-gnueabihf/libc helloworld.c``. Clang uses the host header files; --------------------------------; On debian based systems it is possible to install multiarch support for; arm-linux-gnueabi and arm-linux-gnueabihf. In many cases clang can successfully; use this multiarch support when ``--gcc-toolchain=`` and ``--sysroot=`` are not supplied.; Unfortunately clang adds ``/usr/local/include`` before; ``/usr/include/arm-linux-gnueabihf`` leading to errors when",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:5920,test,test,5920,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,1,['test'],['test']
Testability," for OpenCL:. .. code-block:: console. $ clang --target=spir-unknown-unknown -c -emit-llvm -Xclang -finclude-default-header -fmodules -fimplicit-module-maps -fmodules-cache-path=<path to the generated module> test.cl. Another way to circumvent long parsing latency for the OpenCL builtin; declarations is to use mechanism enabled by :ref:`-fdeclare-opencl-builtins; <opencl_fdeclare_opencl_builtins>` flag that is available as an alternative; feature. .. _opencl_fdeclare_opencl_builtins:. .. option:: -fdeclare-opencl-builtins. In addition to regular header includes with builtin types and functions using; :ref:`-finclude-default-header <opencl_finclude_default_header>`, clang; supports a fast mechanism to declare builtin functions with; ``-fdeclare-opencl-builtins``. This does not declare the builtin types and; therefore it has to be used in combination with ``-finclude-default-header``; if full functionality is required. **Example of Use**:. .. code-block:: console. $ clang -Xclang -fdeclare-opencl-builtins test.cl. .. _opencl_fake_address_space_map:. .. option:: -ffake-address-space-map. Overrides the target address space map with a fake map.; This allows adding explicit address space IDs to the bitcode for non-segmented; memory architectures that do not have separate IDs for each of the OpenCL; logical address spaces by default. Passing ``-ffake-address-space-map`` will; add/override address spaces of the target compiled for with the following values:; ``1-global``, ``2-constant``, ``3-local``, ``4-generic``. The private address; space is represented by the absence of an address space attribute in the IR (see; also :ref:`the section on the address space attribute <opencl_addrsp>`). .. code-block:: console. $ clang -cc1 -ffake-address-space-map test.cl. .. _opencl_builtins:. OpenCL builtins; ---------------. **Clang builtins**. There are some standard OpenCL functions that are implemented as Clang builtins:. - All pipe functions from `section 6.13.16.2/6.13.16.3; <http",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:4994,test,test,4994,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,1,['test'],['test']
Testability," for a problem?; ---------------------------------------------------------. * If the test inputs are validated by the target library and the validator; asserts/crashes on invalid inputs, in-process fuzzing is not applicable.; * Bugs in the target library may accumulate without being detected. E.g. a memory; corruption that goes undetected at first and then leads to a crash while; testing another input. This is why it is highly recommended to run this; in-process fuzzer with all sanitizers to detect most bugs on the spot.; * It is harder to protect the in-process fuzzer from excessive memory; consumption and infinite loops in the target library (still possible).; * The target library should not have significant global state that is not; reset between the runs.; * Many interesting target libraries are not designed in a way that supports; the in-process fuzzer interface (e.g. require a file path instead of a; byte array).; * If a single test run takes a considerable fraction of a second (or; more) the speed benefit from the in-process fuzzer is negligible.; * If the target library runs persistent threads (that outlive; execution of one test) the fuzzing results will be unreliable. Q. So, what exactly this Fuzzer is good for?; --------------------------------------------. This Fuzzer might be a good choice for testing libraries that have relatively; small inputs, each input takes < 10ms to run, and the library code is not expected; to crash on invalid inputs.; Examples: regular expression matchers, text or binary format parsers, compression,; network, crypto. Q. LibFuzzer crashes on my complicated fuzz target (but works fine for me on smaller targets).; ----------------------------------------------------------------------------------------------. Check if your fuzz target uses ``dlclose``.; Currently, libFuzzer doesn't support targets that call ``dlclose``,; this may be fixed in future. Trophies; ========; * Thousands of bugs found on OSS-Fuzz: https://opensource.google",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:30243,test,test,30243,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['test'],['test']
Testability," for blocks that capture uninitialized values. void test() {; int x;; ^{ int y = x; }(); // warn; }. core.uninitialized.UndefReturn; (C); Check for uninitialized values being returned to the caller. int test() {; int x;; return x; // warn; }. C++ Checkers. Name, DescriptionExample. cplusplus.NewDelete; (C++); Check for double-free, use-after-free and offset problems involving C++ ; delete. void f(int *p);. void testUseMiddleArgAfterDelete(int *p) {; delete p;; f(p); // warn: use after free; }. class SomeClass {; public:; void f();; };. void test() {; SomeClass *c = new SomeClass;; delete c;; c->f(); // warn: use after free; }. void test() {; int *p = (int *)__builtin_alloca(sizeof(int));; delete p; // warn: deleting memory allocated by alloca; }. void test() {; int *p = new int;; delete p;; delete p; // warn: attempt to free released; }. void test() {; int i;; delete &i; // warn: delete address of local; }. void test() {; int *p = new int[1];; delete[] (++p);; // warn: argument to 'delete[]' is offset by 4 bytes; // from the start of memory allocated by 'new[]'; }. cplusplus.NewDeleteLeaks; (C++); Check for memory leaks. Traces memory managed by new/; delete. void test() {; int *p = new int;; } // warn. Dead Code Checkers. Name, DescriptionExample. deadcode.DeadStores; (C); Check for values stored to variables that are never read afterwards. void test() {; int x;; x = 1; // warn; }. Nullability Checkers. Name, DescriptionExample. nullability.NullPassedToNonnull; (ObjC); Warns when a null pointer is passed to a pointer which has a; _Nonnull type. if (name != nil); return;; // Warning: nil passed to a callee that requires a non-null 1st parameter; NSString *greeting = [@""Hello "" stringByAppendingString:name];. nullability.NullReturnedFromNonnull; (ObjC); Warns when a null pointer is returned from a function that has; _Nonnull return type. - (nonnull id)firstChild {; id result = nil;; if ([_children count] > 0); result = _children[0];. // Warning: nil returned from a me",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:5723,test,test,5723,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability," for the later entries will be very large (because of the cluster size in entries is large!). TTreeCache::FillBuffer was always attempting to load complete clusters not matter the; size (even with the size was larger than 2GB!). This patch resolves the issue by limiting the amount of memory used to:. The requested size if more than one cluster fits in the cache.; Twice the requested size if at least one basket per branch fits in the cache.; Four time the requested size in the case where the cache can not even hold one basket per branch. The filling will restart at the next cluster boundary in the case a) and will; restart at the maximum of entry number read in the cache in the case b) and c).; Baskets that are below this boundary and did not fit in the cache will be read; individually.; Repaired the basket flushing frequency when the TTree has already more than one cluster size.; Repaired binning of string histogram generated by TTree::Draw.; Many bug fixes and fix for issues discovery by Coverity, see change log for more details.; In TTree::MakeProxy add proper support for top level stl collection of objects and for stl collection of objects that are 'empty' in the file (and thus we know nothing about its content).; Avoid deficiency in hadd when the resulting TTree is longer than the AutoSave length *and* the TFileMerger needs to handle the input files in more than one pass for example when there is more than 1000 input files or the -n option is passed to hadd.; Fix support for emulated class that derived from an abstract class.; This can happen when reading a file containing an ancient; class layout where the derived class is no longer provided in the; compiled code but the abstract base class is still provided. It also happens when using schema evolution rules on a class derived; from an abstract base class (in which case the system introduce; implicitly an emulated class deriving from the same base classes; as the evolved from class). To fix the issue, we introdu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v534/index.html:3922,log,log,3922,tree/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v534/index.html,1,['log'],['log']
Testability," for. The query either returns the element; matching the ID or it returns an opaque ID that indicates where insertion should; take place. Construction of the ID usually does not require heap traffic. Because FoldingSet uses intrusive links, it can support polymorphic objects in; the set (for example, you can have SDNode instances mixed with LoadSDNodes).; Because the elements are individually allocated, pointers to the elements are; stable: inserting or removing elements does not invalidate any pointers to other; elements. .. _dss_set:. <set>; ^^^^^. ``std::set`` is a reasonable all-around set class, which is decent at many; things but great at nothing. std::set allocates memory for each element; inserted (thus it is very malloc intensive) and typically stores three pointers; per element in the set (thus adding a large amount of per-element space; overhead). It offers guaranteed log(n) performance, which is not particularly; fast from a complexity standpoint (particularly if the elements of the set are; expensive to compare, like strings), and has extremely high constant factors for; lookup, insertion and removal. The advantages of std::set are that its iterators are stable (deleting or; inserting an element from the set does not affect iterators or pointers to other; elements) and that iteration over the set is guaranteed to be in sorted order.; If the elements in the set are large, then the relative overhead of the pointers; and malloc traffic is not a big deal, but if the elements of the set are small,; std::set is almost never a good choice. .. _dss_setvector:. llvm/ADT/SetVector.h; ^^^^^^^^^^^^^^^^^^^^. LLVM's ``SetVector<Type>`` is an adapter class that combines your choice of a; set-like container along with a :ref:`Sequential Container <ds_sequential>` The; important property that this provides is efficient insertion with uniquing; (duplicate elements are ignored) with iteration support. It implements this by; inserting elements into both a set-like container",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:83552,log,log,83552,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['log'],['log']
Testability," format, it is; **divided** into individual files, each one containing the logical view; output for a single compilation unit. .. option:: --output-folder=<name>. The folder to write a file per compilation unit when **--output=split**; is specified. .. option:: --output-level=<level>. Only print elements up to the given **lexical level** value. The input; file is at lexical level zero and a compilation unit is at lexical level; one. .. option:: --output=<value[,value,...]>. With **value** being one of the options in the following lists. .. code-block:: text. =all: Include all the below outputs. .. code-block:: text. =json: Use JSON as the output format (Not implemented).; =split: Split the output by Compile Units.; =text: Use a free form text output. .. option:: --output-sort=<key>. Primary key when ordering the elements in the output (default: line).; Sorting by logical element kind, requires be familiarity with the; element kind selection options (:option:`--select-lines`,; :option:`--select-scopes`, :option:`--select-symbols`,; :option:`--select-types`), as those options describe the different; logical element kinds. .. code-block:: text. =kind: Sort by element kind.; =line: Sort by element line number.; =name: Sort by element name.; =offset: Sort by element offset. .. _report_:. REPORT; ~~~~~~; Depending on the task being executed (print, compare, select), several; layouts are supported to display the elements in a more suitable way,; to make the output easier to understand. .. option:: --report=<value[,value,...]>. With **value** being one of the options in the following list. .. code-block:: text. =all: Include all the below reports. .. code-block:: text. =children: Elements and children are displayed in a tree format.; =list: Elements are displayed in a tabular format.; =parents: Elements and parents are displayed in a tree format.; =view: Elements, parents and children are displayed in a tree format. The **list** layout presents the logical elements in a tab",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:11867,log,logical,11867,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,2,['log'],['logical']
Testability," from ``FnTree``, and mark them to be rescanned, namely; put them into ``Deferred`` list. runOnModule; """"""""""""""""""""""; The algorithm is pretty simple:. 1. Put all module's functions into the *worklist*. 2. Scan *worklist*'s functions twice: first enumerate only strong functions and; then only weak ones:. 2.1. Loop body: take a function from *worklist* (call it *FCur*) and try to; insert it into *FnTree*: check whether *FCur* is equal to one of functions; in *FnTree*. If there *is* an equal function in *FnTree*; (call it *FExists*): merge function *FCur* with *FExists*. Otherwise add; the function from the *worklist* to *FnTree*. 3. Once the *worklist* scanning and merging operations are complete, check the; *Deferred* list. If it is not empty: refill the *worklist* contents with; *Deferred* list and redo step 2, if the *Deferred* list is empty, then exit; from method. Comparison and logarithmical search; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Let's recall our task: for every function *F* from module *M*, we have to find; equal functions *F`* in the shortest time possible , and merge them into a; single function. Defining total ordering among the functions set allows us to organize; functions into a binary tree. The lookup procedure complexity would be; estimated as O(log(N)) in this case. But how do we define *total-ordering*?. We have to introduce a single rule applicable to every pair of functions, and; following this rule, then evaluate which of them is greater. What kind of rule; could it be? Let's declare it as the ""compare"" method that returns one of 3; possible values:. -1, left is *less* than right,. 0, left and right are *equal*,. 1, left is *greater* than right. Of course it means, that we have to maintain; *strict and non-strict order relation properties*:. * reflexivity (``a <= a``, ``a == a``, ``a >= a``),; * antisymmetry (if ``a <= b`` and ``b <= a`` then ``a == b``),; * transitivity (``a <= b`` and ``b <= c``, then ``a <= c``); * asymmetry (if ``a < b``, th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:9153,log,logarithmical,9153,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['log'],['logarithmical']
Testability," from indexed offsets into the byte array and applying a mask, a program can; test bits from the bit set with a relatively short instruction sequence. Bit; vectors may overlap so long as they use different bits. For the full details,; see the `ByteArrayBuilder`_ class. In this case, assuming A is laid out at offset 0 in bit 0, B at offset 0 in; bit 1 and C at offset 0 in bit 2, the byte array would look like this:. .. code-block:: c++. char bits[] = { 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 5, 0, 0 };. To emit a virtual call, the compiler will assemble code that checks that; the object's virtual table pointer is in-bounds and aligned and that the; relevant bit is set in the bit vector. For example on x86 a typical virtual call may look like this:. .. code-block:: none. ca7fbb: 48 8b 0f mov (%rdi),%rcx; ca7fbe: 48 8d 15 c3 42 fb 07 lea 0x7fb42c3(%rip),%rdx; ca7fc5: 48 89 c8 mov %rcx,%rax; ca7fc8: 48 29 d0 sub %rdx,%rax; ca7fcb: 48 c1 c0 3d rol $0x3d,%rax; ca7fcf: 48 3d 7f 01 00 00 cmp $0x17f,%rax; ca7fd5: 0f 87 36 05 00 00 ja ca8511; ca7fdb: 48 8d 15 c0 0b f7 06 lea 0x6f70bc0(%rip),%rdx; ca7fe2: f6 04 10 10 testb $0x10,(%rax,%rdx,1); ca7fe6: 0f 84 25 05 00 00 je ca8511; ca7fec: ff 91 98 00 00 00 callq *0x98(%rcx); [...]; ca8511: 0f 0b ud2. The compiler relies on co-operation from the linker in order to assemble; the bit vectors for the whole program. It currently does this using LLVM's; `type metadata`_ mechanism together with link-time optimization. .. _address point: https://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-general; .. _type metadata: https://llvm.org/docs/TypeMetadata.html; .. _ByteArrayBuilder: https://llvm.org/docs/doxygen/html/structllvm_1_1ByteArrayBuilder.html. Optimizations; -------------. The scheme as described above is the fully general variant of the scheme.; Most of the time we are able to apply one or more of the following; optimizations to improve binary size or performance. In fact, if you try the above example with the current version of t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:2861,test,testb,2861,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['test'],['testb']
Testability," from trees, data sources or `Define`d columns; - Add `OnPartialResult` and `OnPartialResultSlot`: users can now register one or more functions to be executed on partial results of TDF actions during the event loop.; This mechanism is meant to be used to inspect partial results of the analysis or print useful debug information.; For example, both in single- and multi-thread event loops, one can draw a result histogram and update the canvas every 100 entries like this:; ```c++; auto h = tdf.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; ```; See the tutorials for more examples.; - Add `Sum`, an action that sums all values of a column for the processed entries; - The new TDataSource interface allows developers to pipe any kind of columnar data format into TDataFrame. Two example data sources have been provided: the TRootDS and the TTrivialDS. The former allows to read via the novel data source mechanism ROOT data, while the latter is a simple generator, created for testing and didactic purposes. It is therefore now possible to interface *any* kind of dataset/data format to ROOT as long as an adaptor which implements the pure virtual methods of the TDataSource interface can be written in C++.; - TDF can now read CSV files through a specialized TDataSource. Just create the TDF with `MakeCsvDataFrame(""f.csv"")`. Just create the TDF with MakeCsvDataFrame(""f.csv""). The data types of the CSV columns are automatically inferred. You can also specify if you want to use a different delimiter or if your file does not have headers.; - Users can now configure Snapshot to use different file open modes (""RECREATE"" or ""UPDATE""), compression level, compression algorithm, TTree split-level and autoflush settings; - Users can now access multi-threading slot and entry number as pre-defined columns ""tdfslot_"" and ""tdfentry_"". Especially useful for pyROOT users.; - Users can now specify filters and definitions as strings ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:12716,test,testing,12716,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['test'],['testing']
Testability," function is called on the input RooFit objects (e.g., x, mean, sigma). That's; the only way to propagate these upwards into the compute graph. **translate() Example 3:** A more complicated example of a `translate()`; function can be seen here:. ``` {.cpp}; void RooNLLVarNew::translate(RooFit::Detail::RooFit::Detail::CodeSquashContext &ctx) const; {; std::string weightSumName = ctx.makeValidVarName(GetName()) + ""WeightSum"";; std::string resName = ctx.makeValidVarName(GetName()) + ""Result"";; ctx.addResult(this, resName);; ctx.addToGlobalScope(""double "" + weightSumName + "" = 0.0;\n"");; ctx.addToGlobalScope(""double "" + resName + "" = 0.0;\n"");. const bool needWeightSum = _expectedEvents || _simCount > 1;. if (needWeightSum) {; auto scope = ctx.beginLoop(this);; ctx.addToCodeBody(weightSumName + "" += "" + ctx.getResult(*_weightVar) + "";\n"");; }. if (_simCount > 1) {; std::string simCountStr = std::to_string(static_cast<double>(_simCount));; ctx.addToCodeBody(resName + "" += "" + weightSumName + "" * std::log("" + simCountStr + "");\n"");; }; ... }; ```. > Source: - [RooNLLVarNew](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooNLLVarNew.cxx). The complexity of the `RooNLLVarNew::translate()` function in this example can; be attributed to the more complex scenarios/operations specific to the; computation of negative log-likelihood (NLL) values for probability density; functions (PDFs) in RooFit, especially for simultaneous fits (multiple; simultaneous PDFs being considered) and binned likelihoods (adding further; complexity). In this example, the `RooNLLVarNew::translate()` function generates code to; compute the Negative Log likelihood (NLL). We can see that the intermediate; result variable `resName` is added to the context so that it can be accessed; and used in the generated code. This variable is made available globally; (using `addToGlobalScope()`). If a weight sum is needed, then it creates a loop, and `weightSumName` is; accumulated with the wei",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:15827,log,log,15827,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['log'],['log']
Testability," generated object, shows **'4'**, which is the correct value. Note that there is no requirement that GCC must produce identical or; similar DWARF to Clang to allow the comparison. We're only comparing; the semantics. The same case when comparing CodeView debug information; generated by MSVC and Clang. There are 2 comparison methods: logical view and logical elements. LOGICAL VIEW; """"""""""""""""""""""""; It compares the logical view as a whole unit; for a match, each compared; logical element must have the same parents and children. Using the :program:`llvm-debuginfo-analyzer` comparison functionality,; that issue can be seen in a more global context, that can include the; logical view. The output shows in view form the **missing (-), added (+)** elements,; giving more context by swapping the reference and target object files. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level; --compare=types; --report=view; --print=symbols,types; test-dwarf-clang.o test-dwarf-gcc.o. Reference: 'test-dwarf-clang.o'; Target: 'test-dwarf-gcc.o'. Logical View:; [000] {File} 'test-dwarf-clang.o'. [001] {CompileUnit} 'test.cpp'; [002] 1 {TypeAlias} 'INTPTR' -> '* const int'; [002] 2 {Function} extern not_inlined 'foo' -> 'int'; [003] {Block}; [004] 5 {Variable} 'CONSTANT' -> 'const INTEGER'; +[004] 4 {TypeAlias} 'INTEGER' -> 'int'; [003] 2 {Parameter} 'ParamBool' -> 'bool'; [003] 2 {Parameter} 'ParamPtr' -> 'INTPTR'; [003] 2 {Parameter} 'ParamUnsigned' -> 'unsigned int'; -[003] 4 {TypeAlias} 'INTEGER' -> 'int'. The output shows the merging view path (reference and target) with the; missing and added elements. LOGICAL ELEMENTS; """"""""""""""""""""""""""""""""; It compares individual logical elements without considering if their; parents are the same. For both comparison methods, the equal criteria; includes the name, source code location, type, lexical scope level. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level; --compare=types; --report=list; --print=symbols,types,summary; test-dwa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:30418,test,test-dwarf-clang,30418,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['test'],['test-dwarf-clang']
Testability," generation instrumentation enabled; and setup for training data. The lit runner will merge the profile files; using `llvm-profdata` so they can be used by the second compilation run. Example:; ```bash; # Profile generation run using LLVM IR PGO:; % cmake -DTEST_SUITE_PROFILE_GENERATE=ON \; -DTEST_SUITE_USE_IR_PGO=ON \; -DTEST_SUITE_RUN_TYPE=train \; ../test-suite; % make; % llvm-lit .; # Use the profile data for compilation and actual benchmark run:; % cmake -DTEST_SUITE_PROFILE_GENERATE=OFF \; -DTEST_SUITE_PROFILE_USE=ON \; -DTEST_SUITE_RUN_TYPE=ref \; .; % make; % llvm-lit -o result.json .; ```. To use Clang frontend's PGO instead of LLVM IR PGO, set `-DTEST_SUITE_USE_IR_PGO=OFF`. The `TEST_SUITE_RUN_TYPE` setting only affects the SPEC benchmark suites. Cross Compilation and External Devices; --------------------------------------. ### Compilation. CMake allows to cross compile to a different target via toolchain files. More; information can be found here:. - [https://llvm.org/docs/lnt/tests.html#cross-compiling](https://llvm.org/docs/lnt/tests.html#cross-compiling). - [https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html](https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html). Cross compilation from macOS to iOS is possible with the; `test-suite/cmake/caches/target-target-*-iphoneos-internal.cmake` CMake cache; files; this requires an internal iOS SDK. ### Running. There are two ways to run the tests in a cross compilation setting:. - Via SSH connection to an external device: The `TEST_SUITE_REMOTE_HOST` option; should be set to the SSH hostname. The executables and data files need to be; transferred to the device after compilation. This is typically done via the; `rsync` make target. After this, the lit runner can be used on the host; machine. It will prefix the benchmark and verification command lines with an; `ssh` command. Example:. ```bash; % cmake -G Ninja -D CMAKE_C_COMPILER=path/to/clang \; -C ../test-suite/cmake/caches/target-a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:11109,test,tests,11109,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['test'],['tests']
Testability," has associated error bars ( **`TH1`**`::Sumw2()` has; been called), the resulting error bars are also computed assuming; independent histograms. In case of divisions, binomial errors are also; supported. ## Projections. One can make:. - a 1-D projection of a 2-D histogram or profile. See; **`TH2`**`::ProfileX`,; **`TH2`**`::ProfileY, `**`TProfile`**`::ProjectionX`,; **`TProfile2D`**`::ProjectionXY`, **`TH2`**`::ProjectionX`,; **`TH2`**`::ProjectionY` . - a 1-D, 2-D or profile out of a 3-D histogram see; **`TH3`**`::ProjectionZ`, **`TH3`**`::Project3D`. These projections can be fit via: **`TH2`**`::FitSlicesX`,; **`TH2`**`::FitSlicesY`, **`TH3`**`::FitSlicesZ`. ## Drawing Histograms. When you call the `Draw` method of a histogram ( **`TH1`**` ::Draw` ); for the first time, it creates a **`THistPainter`** object and saves a; pointer to painter as a data member of the histogram. The; **`THistPainter`** class specializes in the drawing of histograms. It; allows logarithmic axes (x, y, z) when the CONT drawing option is; using. The **`THistPainter`** class is separated from the histogram so; that one can have histograms without the graphics overhead, for; example in a batch program. The choice to give each histogram has its; own painter rather than a central singleton painter, allows two; histograms to be drawn in two threads without overwriting the; painter's values. When a displayed histogram is filled again, you do; not have to call the `Draw` method again. The image is refreshed the; next time the pad is updated. A pad is updated after one of these; three actions:. - A carriage control on the ROOT command line. - A click inside the pad. - A call to **`TPad`**`::Update()`. By default, the **`TH1`**`::Draw` clears the pad before drawing the; new image of the histogram. You can use the `""SAME""` option to leave; the previous display intact and superimpose the new histogram. The; same histogram can be drawn with different graphics options in; different pads. When a displ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:13165,log,logarithmic,13165,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['log'],['logarithmic']
Testability," having a separate file per; test. Check if there are files already covering your feature and consider; adding your code there instead of creating a new file. Generating assertions in regression tests; -----------------------------------------. Some regression test cases are very large and complex to write/update by hand.; In that case to reduce the human work we can use the scripts available in; llvm/utils/ to generate the assertions. For example to generate assertions in an :program:`llc`-based test, after; adding one or more RUN lines use:. .. code-block:: bash. % llvm/utils/update_llc_test_checks.py --llc-binary build/bin/llc test.ll. This will generate FileCheck assertions, and insert a ``NOTE:`` line at the; top to indicate that assertions were automatically generated. If you want to update assertions in an existing test case, pass the `-u` option; which first checks the ``NOTE:`` line exists and matches the script name. Sometimes a test absolutely depends on hand-written assertions and should not; have assertions automatically generated. In that case, add the text ``NOTE: Do; not autogenerate`` to the first line, and the scripts will skip that test. It; is a good idea to explain why generated assertions will not work for the test; so future developers will understand what is going on. These are the most common scripts and their purposes/applications in generating; assertions:. .. code-block:: none. update_analyze_test_checks.py; opt -passes='print<cost-model>'. update_cc_test_checks.py; C/C++, or clang/clang++ (IR checks). update_llc_test_checks.py; llc (assembly checks). update_mca_test_checks.py; llvm-mca. update_mir_test_checks.py; llc (MIR checks). update_test_checks.py; opt. Precommit workflow for tests; ----------------------------. If the test does not crash, assert, or infinite loop, commit the test with; baseline check-lines first. That is, the test will show a miscompile or; missing optimization. Add a ""TODO"" or ""FIXME"" comment to indicate that; som",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:11942,test,test,11942,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,3,"['assert', 'test']","['assertions', 'test']"
Testability," healthy than some other open source projects,; and our norms are a bit different. How should you respond if someone reverted your change?. * Remember, it is normal and healthy to have patches reverted. Having a patch; reverted does not necessarily mean you did anything wrong.; * We encourage explicitly thanking the person who reverted the patch for doing; the task on your behalf.; * If you need more information to address the problem, please follow up in the; original commit thread with the reverting patch author. When should you revert your own change?. * Any time you learn of a serious problem with a change, you should revert it.; We strongly encourage ""revert to green"" as opposed to ""fixing forward"". We; encourage reverting first, investigating offline, and then reapplying the; fixed patch - possibly after another round of review if warranted.; * If you break a buildbot in a way which can't be quickly fixed, please revert.; * If a test case that demonstrates a problem is reported in the commit thread,; please revert and investigate offline.; * If you receive substantial :ref:`post-commit review <post_commit_review>`; feedback, please revert and address said feedback before recommitting.; (Possibly after another round of review.); * If you are asked to revert by another contributor, please revert and discuss; the merits of the request offline (unless doing so would further destabilize; tip of tree). When should you revert someone else's change?. * In general, if the author themselves would revert the change per these; guidelines, we encourage other contributors to do so as a courtesy to the; author. This is one of the major cases where our norms differ from others;; we generally consider reverting a normal part of development. We don't; expect contributors to be always available, and the assurance that a; problematic patch will be reverted and we can return to it at our next; opportunity enables this. What are the expectations around a revert?. * Use your best ju",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:19652,test,test,19652,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['test'],['test']
Testability," histogram is filled; with a weight. If the weight is not explicitly specified it is assumed; to be 1. For example, this selection will add 1 to the histogram if x is less; than y and the square root of z is less than 3.2. ``` {.cpp}; ""x<y && sqrt(z)>3.2""; ```. On the other hand, this selection will add `x+y` to the histogram if the; square root of z is larger than 3.2. ``` {.cpp}; ""(x+y)*(sqrt(z)>3.2)""; ```. The `Draw` method has its own parser, and it only looks in the current; tree for variables. This means that any variable used in the selection; must be defined in the tree. You cannot use an arbitrary global variable; in the `TTree::Draw` method. ### Using TCut Objects in TTree::Draw. The `TTree::Draw` method also accepts **`TCutG`** objects. A; **`TCut`** is a specialized string object used for **`TTree`**; selections. A **`TCut`** object has a name and a title. It does not have; any data members in addition to what it inherits from **`TNamed`**. It; only adds a set of operators to do logical string concatenation. For; example, assume:. ``` {.cpp}; TCut cut1 = ""x<1""; TCut cut2 = ""y>2""; ```. then. ``` {.cpp}; cut1 && cut2; //result is the string ""(x<1)&&(y>2)""; ```. Operators =, +=, +, \*, !, &&, || are overloaded, here are some; examples:. ``` {.cpp}; root[] TCut c1 = ""x < 1""; root[] TCut c2 = ""y < 0""; root[] TCut c3 = c1 && c2; root[] MyTree.Draw(""x"", c1); root[] MyTree.Draw(""x"", c1 || ""x>0""); root[] MyTree.Draw(""x"", c1 && c2); root[] MyTree.Draw(""x"", ""(x + y)"" * (c1 && c2)); ```. ### Accessing the Histogram in Batch Mode. The `TTree::Draw` method creates a histogram called `htemp` and puts it; on the active pad. In a batch program, the histogram `htemp` created by; default, is reachable from the current pad. ``` {.cpp}; // draw the histogram; nt->Draw(""x"", ""cuts"");; // get the histogram from the current pad; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp"");; // now we have full use of the histogram; htemp->GetEntries();; ```. If you pipe the result of the `TT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:72840,log,logical,72840,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['log'],['logical']
Testability," histograms with all provided functions (#125). ## Changes in 5.1.0; 1. New 'float' browser kind overlays with objects drawing; 2. Browser can be enabled after drawing with 'nobrowser' mode; 3. One can hide browser or switch browser kind at any time; 4. New 'horizontal' and 'vertical' layouts for object display.; One could configure several frames, each divided on sub-frames.; Like display=horiz231 will create three horizontal frames,; divided on 2,3 and 1 sub-frames.; 5. One could enable status line where current tooltip info will be shown; 6. Improve enlarge functionality - now works with all layouts; 7. Do not display all canvas tool buttons by default - provide toggle button instead; 8. Let move TAxis title, its position now similar to ROOT graphics; 9. Support 'col0' option for TH2Poly class to suppress empty bins; 10. Implement for TH3 'box2', 'box3', 'glbox2', 'glcol' draw options; 11. Support more superscript/subscript letters in normal text output; 12. Correctly handle unzoom with logx/logy scales; 13. Let disable stamp parameter in file url with ""-"" sign at the end of file name; 14. Let use quotes in the URL parameters to protect complex arguments with special symbols; 15. Introduce direct streamers - like TBasket or TRef; Benefit - one can add custom streamers of such kind or reuse existing; 16. Handle TMatrixTSym classes in I/O; 17. Correctly count TH3 statistic in TTree::Draw; 18. Recognize bower installation when ""bower_components/jsroot/scripts"" string; appears in the script path (#120). ## Changes in 5.0.3; 1. Fix - prevent exception when discover HTML element position (#121); 2. Fix - prevent I/O failure when server automatically gzip response (#119); 3. Fix - lego drawing for stacked TH1 histograms; 4. Fix - when change global tooltips settings, also change for each sub-pad. ## Changes in 5.0.2; 1. Fix - read branch entries as arrays; 2. Fix - command submission to THttpServer; 3. Fix - let refill statbox also for empty histogram; 4. Fix - problem w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:45293,log,logx,45293,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,2,['log'],"['logx', 'logy']"
Testability," human readable output. If :option:`--inlining` is specified, the; enclosing scope is prefixed by (inlined by).; For JSON output, the option will cause JSON to be indented and split over; new lines. Otherwise, the JSON output will be printed in a compact form. .. code-block:: console. $ llvm-symbolizer --obj=inlined.elf 0x4004be --inlining --pretty-print; baz() at /tmp/test.cpp:11:18; (inlined by) main at /tmp/test.cpp:15:0. .. option:: --print-address, --addresses, -a. Print address before the source code location. Defaults to false. .. code-block:: console. $ llvm-symbolizer --obj=inlined.elf --print-address 0x4004be; 0x4004be; baz(); /tmp/test.cpp:11:18; main; /tmp/test.cpp:15:0. $ llvm-symbolizer --obj=inlined.elf 0x4004be --pretty-print --print-address; 0x4004be: baz() at /tmp/test.cpp:11:18; (inlined by) main at /tmp/test.cpp:15:0. .. option:: --print-source-context-lines <N>. Print ``N`` lines of source context for each symbolized address. .. code-block:: console. $ llvm-symbolizer --obj=test.elf 0x400490 --print-source-context-lines=3; baz(); /tmp/test.cpp:11:0; 10 : volatile int k = 42;; 11 >: return foz() + k;; 12 : }. .. option:: --relativenames. Print the file's path relative to the compilation directory, instead; of the absolute path. If the command-line to the compiler included; the full path, this will be the same as the default. .. option:: --verbose. Print verbose address, line and column information. .. code-block:: console. $ llvm-symbolizer --obj=inlined.elf --verbose 0x4004be; baz(); Filename: /tmp/test.cpp; Function start filename: /tmp/test.cpp; Function start line: 9; Function start address: 0x4004b6; Line: 11; Column: 18; main; Filename: /tmp/test.cpp; Function start filename: /tmp/test.cpp; Function start line: 14; Function start address: 0x4004b0; Line: 15; Column: 18. .. option:: --version, -v. Print version information for the tool. .. option:: @<FILE>. Read command-line options from response file `<FILE>`. WINDOWS/PDB SPECIFIC OPTIONS; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst:11692,test,test,11692,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,1,['test'],['test']
Testability," hypothesis test; HypoTestCalculator: interface for a statistical tool performing an hypothesis test. ; CombinedCalculator: interface for a statistical tool which can produce both hypothesis test results and confidence intervals. ; RooStats concrete classes. The concrete classes describing statistical tools implementing the above interfaces are:; ; ProfileLikelihoodCalculator: it is an implementation of a CombinedCalculator using the profile likelihood ratio as a test statistics. After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer).; LikelihoodInterval: concrete implementation of a ConfInterval interface. It implements connected N-dimensional intervals based on the contour of a likelihood ratio. The boundary of the interval is equivalent to a MINUIT/MINOS contour about the maximum likelihood estimator. . HybridCalculator: hypothesis test calculator using a Bayesian-frequentist hybrid method (often called in HEP as CLs method). This class extends the functionality of the TLimit class by taking advantage of the RooFit package. The result of the calculator is returned as an HybridResult pointer. HybridResult implements the HypoTestResult interface. The class HybridPlot allows for a graphical representation of a HybridResult.; ; HybridCalculator implements the interface class HypoTestCalculator. A constructor exists taking as input the pdf's (expressed as RooAbsPdf instances) for the signal+background (alternate) and background only (null) hypothesis and the data set (as RooAbsData instance). One can provide optionally also the nuisance parameters and its pdf which will be marginalized by the calculator. The HypoTestCalculator interface provides also the possibility of setting the model via a Rooworkspace class and names of the pdf. This possibility is not yet supported for the HybridCalculator class. ; ; . Additional classes or functions provided by",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:11021,test,test,11021,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['test'],['test']
Testability," if a non-NULL buffer was returned; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);. st = SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);; // warn: release data before another call to the allocator. if (st == noErr); SecKeychainItemFreeContent(ptr, outData);; }. void test() {; SecKeychainItemRef itemRef = 0;; SecKeychainAttributeInfo *info = 0;; SecItemClass *itemClass = 0;; SecKeychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(assign) id myproperty;; @end. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:14783,test,test,14783,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability," if this was written; as ``__builtin_dynamic_object_size(buffer, 0)``, Clang will fold it into; ``size``, providing some extra runtime safety. Deprecating Macros; ==================. Clang supports the pragma ``#pragma clang deprecated``, which can be used to; provide deprecation warnings for macro uses. For example:. .. code-block:: c. #define MIN(x, y) x < y ? x : y; #pragma clang deprecated(MIN, ""use std::min instead""). int min(int a, int b) {; return MIN(a, b); // warning: MIN is deprecated: use std::min instead; }. ``#pragma clang deprecated`` should be preferred for this purpose over; ``#pragma GCC warning`` because the warning can be controlled with; ``-Wdeprecated``. Restricted Expansion Macros; ===========================. Clang supports the pragma ``#pragma clang restrict_expansion``, which can be; used restrict macro expansion in headers. This can be valuable when providing; headers with ABI stability requirements. Any expansion of the annotated macro; processed by the preprocessor after the ``#pragma`` annotation will log a; warning. Redefining the macro or undefining the macro will not be diagnosed, nor; will expansion of the macro within the main source file. For example:. .. code-block:: c. #define TARGET_ARM 1; #pragma clang restrict_expansion(TARGET_ARM, ""<reason>""). /// Foo.h; struct Foo {; #if TARGET_ARM // warning: TARGET_ARM is marked unsafe in headers: <reason>; uint32_t X;; #else; uint64_t X;; #endif; };. /// main.c; #include ""foo.h""; #if TARGET_ARM // No warning in main source file; X_TYPE uint32_t; #else; X_TYPE uint64_t; #endif. This warning is controlled by ``-Wpedantic-macros``. Final Macros; ============. Clang supports the pragma ``#pragma clang final``, which can be used to; mark macros as final, meaning they cannot be undef'd or re-defined. For example:. .. code-block:: c. #define FINAL_MACRO 1; #pragma clang final(FINAL_MACRO). #define FINAL_MACRO // warning: FINAL_MACRO is marked final and should not be redefined; #undef FINAL_MACRO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:190276,log,log,190276,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['log'],['log']
Testability," if((x = f() != y)) {} // warn; }. different.OpPrecedenceIifShift; (C, C++); ?: has lower precedence then <<.; Source: Stephen C. Dewhurst ""C++ Gotchas: Avoiding Common Problems in Coding; and Design"", advise 15. #include <iostream>. void test(int a) {; std::cout << a ? ""a"" : ""b""; // warn; }. void test(int a) {; a << a > 7 ? 1 : 2; // warn; }. different.ObjectUnused; (C++); The object was created but is not being used. struct S {; int x, y;; S(int xx, int yy) : x(xx), y(yy) {}; S(int xx) {; S(xx, 0); // warn; }; };. #include <exception>. void test() {; std::exception();; // warn (did you mean 'throw std::exception()'?); }. different.StaticArrayPtrCompare; (C); Pointer to static array is being compared to NULL. May the subscripting is; missing. void test() {; int a[1][1];; if (a[0] == 0) {}; // warn; }. different.ConversionToBool; (C, C++); Odd implicit conversion to boolean.; Note: possibly merge with ; alpha.core.BoolAssignment. bool test() {; return 1.; // warn; }. bool test() {; return """"; // warn; }. different.ArrayBound; (C++); Out-of-bound dynamic array access.; Note: possibly an enhancement to ; alpha.security.ArrayBoundV2. void test() {; int *p = new int[1];; int i = 1;; if(p[i]) {}; // warn; delete[] p;; }. different.StrcpyInputSize; (C); Buffer copy without checking the size of input.; Note: possibly an enhancement to ; alpha.unix.cstring.OutOfBounds. void test(char* string) {; char buf[24];; strcpy(buf, string); // warn; }. different.IntegerOverflow; (C); Integer overflow.; Note: partially handled by Clang core; (search for 'overflow in expression' warning in Clang tests).; Source: ; CWE-190. #include <limits.h>. int f(int x);. void test() {; f(INT_MAX + 1); // warn; }. #include <limits.h>. int test() {; int x = INT_MAX / 2 + 1;; return x * 2; // warn; }. different.SignExtension; (C); Unexpected sign extension might take place.; Source: ; CWE-194. unsigned long long test(long long sll) {; unsigned long long ull = sll; // warn; return ull;; }. void f(unsig",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:24046,test,test,24046,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability," if(BLAS_FOUND); target_link_libraries(TMVA PRIVATE ${BLAS_LINKER_FLAGS} ${BLAS_LIBRARIES}); elseif(GSL_FOUND); target_compile_definitions(TMVA PRIVATE -DDNN_USE_CBLAS); target_include_directories(TMVA SYSTEM PRIVATE ${GSL_INCLUDE_DIR}); target_link_libraries(TMVA PRIVATE ${GSL_CBLAS_LIBRARY}); if(builtin_gsl); add_dependencies(TMVA GSL); endif(); else(); message(FATAL_ERROR ""tmva-cpu enabled but neither BLAS nor GSL BLAS were found""); endif(); endif(). if(tmva-gpu); target_sources(TMVA PRIVATE; src/DNN/Architectures/Cuda.cu; src/DNN/Architectures/Cuda/CudaBuffers.cxx; src/DNN/Architectures/Cuda/CudaMatrix.cu; src/DNN/Architectures/Cuda/CudaTensor.cu ); target_link_libraries(TMVA PRIVATE CUDA::cuda_driver CUDA::cublas); if(tmva-cudnn); message(STATUS ""Using Cuda+cuDNN for TMVA Deep Learning on GPU""); target_sources(TMVA PRIVATE; src/DNN/Architectures/Cudnn/TensorDataLoader.cxx; src/DNN/Architectures/Cudnn.cu); target_link_libraries(TMVA PRIVATE ROOT::cuDNN); else(); message(STATUS ""cuDNN not found or disabled - use only Cuda+Cublas for TMVA Deep Learning on GPU""); endif(); endif(tmva-gpu). if(dataframe); ROOT_STANDARD_LIBRARY_PACKAGE(TMVAUtils; NO_INSTALL_HEADERS; HEADERS; TMVA/RTensorUtils.hxx; TMVA/RStandardScaler.hxx; TMVA/RReader.hxx; TMVA/RInferenceUtils.hxx; TMVA/RBDT.hxx; TMVA/RSofieReader.hxx; TMVA/RBatchGenerator.hxx; TMVA/RBatchLoader.hxx; TMVA/RChunkLoader.hxx. SOURCES. src/RBDT.cxx. DEPENDENCIES; TMVA ROOTDataFrame ROOTVecOps; ${TMVA_EXTRA_DEPENDENCIES}. LINKDEF LinkDefUtils.h; DICTIONARY_OPTIONS; -writeEmptyRootPCM. ${EXTRA_DICT_OPTS}; ); endif(). ROOT_ADD_TEST_SUBDIRECTORY(test); ROOT_ADD_TEST_SUBDIRECTORY(test/crossvalidation); ROOT_ADD_TEST_SUBDIRECTORY(test/DNN); ROOT_ADD_TEST_SUBDIRECTORY(test/Method); ROOT_ADD_TEST_SUBDIRECTORY(test/ROC); ROOT_ADD_TEST_SUBDIRECTORY(test/envelope); ROOT_ADD_TEST_SUBDIRECTORY(test/DNN/CNN); ROOT_ADD_TEST_SUBDIRECTORY(test/DNN/RNN); ROOT_ADD_TEST_SUBDIRECTORY(test/DNN/LSTM); ROOT_ADD_TEST_SUBDIRECTORY(test/DNN/GRU); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt:11392,test,test,11392,tmva/tmva/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/CMakeLists.txt,10,['test'],['test']
Testability," if, say, we're making an array of strings,; depending on the implementation you might have to allocate a new buffer; for each string, and in this case default-binding won't cut it.; We might want to come up with an auxiliary analysis in order to perform; widening of these simple loops more precisely.; . Handle constructors that can be elided due to Named Return Value Optimization (NRVO); Local variables which are returned by values on all return statements; may be stored directly at the address for the return value,; eliding the copy or move constructor call.; Such variables can be identified using the AST call VarDecl::isNRVOVariable.; . Handle constructors of lambda captures; Variables which are captured by value into a lambda require a call to; a copy constructor.; This call is not currently modeled.; . Handle constructors for default arguments; Default arguments in C++ are recomputed at every call,; and are therefore local, and not static, variables.; See tests cases in handle_constructors_for_default_arguments.cpp.; . Default arguments are annoying because the initializer expression is; evaluated at the call site but doesn't syntactically belong to the; caller's AST; instead it belongs to the ParmVarDecl for the default; parameter. This can lead to situations when the same expression has to; carry different values simultaneously -; when multiple instances of the same function are evaluated as part of the; same full-expression without specifying the default arguments.; Even simply calling the function twice (not necessarily within the; same full-expression) may lead to program points agglutinating because; it's the same expression. There are some nasty test cases already; in temporaries.cpp (struct DefaultParam and so on). I recommend adding a; new LocationContext kind specifically to deal with this problem. It'll; also help you figure out the construction context when you evaluate the; construct-expression (though you might still need to do some additional; CFG",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:4579,test,tests,4579,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['test'],['tests']
Testability," impl_part.o"",; ""file"": ""impl_part.cppm"",; ""output"": ""impl_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 interface_part.cppm -c -o interface_part.o"",; ""file"": ""interface_part.cppm"",; ""output"": ""interface_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 User.cpp -c -o User.o"",; ""file"": ""User.cpp"",; ""output"": ""User.o""; }; ]. And we can get the dependency information in P1689 format by:. .. code-block:: console. $ clang-scan-deps -format=p1689 -compilation-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35353,log,logical-name,35353,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['log'],['logical-name']
Testability," import before we could import a given node then the import error associated to the dependency propagates to the dependant node.; Let's modify the previous example and import a ``FieldDecl`` instead of the ``ClassTemplateSpecializationDecl``. .. code-block:: cpp. auto Matcher = fieldDecl(hasName(""i2""));; auto *From = getFirstDecl<FieldDecl>(Matcher, FromUnit);. In this case we can see that an error is associated (``getImportDeclErrorIfAny``) to the specialization also, not just to the field:. .. code-block:: cpp. llvm::Expected<Decl *> ImportedOrErr = Importer.Import(From);; if (!ImportedOrErr) {; llvm::Error Err = ImportedOrErr.takeError();; consumeError(std::move(Err));. // check that the ClassTemplateSpecializationDecl is also marked as; // erroneous.; auto *FromSpec = getFirstDecl<ClassTemplateSpecializationDecl>(; classTemplateSpecializationDecl(hasName(""X"")), FromUnit);; assert(Importer.getImportDeclErrorIfAny(FromSpec));; // Btw, the error is also set for the FieldDecl.; assert(Importer.getImportDeclErrorIfAny(From));; return 1;; }. Polluted AST; """""""""""""""""""""""". We may recognize an error during the import of a dependent node. However, by that time, we had already created the dependant.; In these cases we do not remove the existing erroneous node from the ""to"" context, rather we associate an error to that node.; Let's extend the previous example with another class ``Y``.; This class has a forward definition in the ""to"" context, but its definition is in the ""from"" context.; We'd like to import the definition, but it contains a member whose type conflicts with the type in the ""to"" context:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct X {};; // explicit specialization; template<>; struct X<int> { int i; };. class Y;; )"",; ""to.cc"");; ToUnit->enableSourceFileDiagnostics();; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; // primary template; template <typename T>; struct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:16294,assert,assert,16294,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,1,['assert'],['assert']
Testability," important part of the LLVM system, because LLVM; passes are where most of the interesting parts of the compiler exist. Passes; perform the transformations and optimizations that make up the compiler, they; build the analysis results that are used by these transformations, and they; are, above all, a structuring technique for compiler code. Unlike passes under the legacy pass manager where the pass interface is; defined via inheritance, passes under the new pass manager rely on; concept-based polymorphism, meaning there is no explicit interface (see; comments in ``PassManager.h`` for more details). All LLVM passes inherit from; the CRTP mix-in ``PassInfoMixin<PassT>``. The pass should have a ``run()``; method which returns a ``PreservedAnalyses`` and takes in some unit of IR; along with an analysis manager. For example, a function pass would have a; ``PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);`` method. We start by showing you how to construct a pass, from setting up the build,; creating the pass, to executing and testing it. Looking at existing passes is; always a great way to learn details. .. warning::; This document deals with the new pass manager. LLVM uses the legacy pass; manager for the codegen pipeline. For more details, see; :doc:`WritingAnLLVMPass` and :doc:`NewPassManager`. Quick Start --- Writing hello world; ===================================. Here we describe how to write the ""hello world"" of passes. The ""HelloWorld""; pass is designed to simply print out the name of non-external functions that; exist in the program being compiled. It does not modify the program at all,; it just inspects it. The code below already exists; feel free to create a pass with a different; name alongside the HelloWorld source files. .. _writing-an-llvm-npm-pass-build:. Setting up the build; --------------------. First, configure and build LLVM as described in :doc:`GettingStarted`. Next, we will reuse an existing directory (creating a new directory invol",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst:1257,test,testing,1257,interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,1,['test'],['testing']
Testability," in C based languages or in LLVM assembly language. These tests are compiled and run under a debugger. The debugger output; is checked to validate of debugging information. See README.txt in the; test suite for more information. This test suite is located in the; ``cross-project-tests/debuginfo-tests`` directory. Quick start; ===========. The tests are located in two separate repositories. The unit and; regression tests are in the main ""llvm""/ directory under the directories; ``llvm/unittests`` and ``llvm/test`` (so you get these tests for free with the; main LLVM tree). Use ``make check-all`` to run the unit and regression tests; after building LLVM. The ``test-suite`` module contains more comprehensive tests including whole C; and C++ programs. See the :doc:`TestSuiteGuide` for details. Unit and Regression tests; -------------------------. To run all of the LLVM unit tests use the check-llvm-unit target:. .. code-block:: bash. % make check-llvm-unit. To run all of the LLVM regression tests use the check-llvm target:. .. code-block:: bash. % make check-llvm. In order to get reasonable testing performance, build LLVM and subprojects; in release mode, i.e. .. code-block:: bash. % cmake -DCMAKE_BUILD_TYPE=""Release"" -DLLVM_ENABLE_ASSERTIONS=On. If you have `Clang <https://clang.llvm.org/>`_ checked out and built, you; can run the LLVM and Clang tests simultaneously using:. .. code-block:: bash. % make check-all. To run the tests with Valgrind (Memcheck by default), use the ``LIT_ARGS`` make; variable to pass the required options to lit. For example, you can use:. .. code-block:: bash. % make check LIT_ARGS=""-v --vg --vg-leak"". to enable testing with valgrind and with leak checking enabled. To run individual tests or subsets of tests, you can use the ``llvm-lit``; script which is built as part of LLVM. For example, to run the; ``Integer/BitPacked.ll`` test by itself you can run:. .. code-block:: bash. % llvm-lit ~/llvm/test/Integer/BitPacked.ll. or to run all of the ARM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:5215,test,tests,5215,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['tests']
Testability," in WriteQueryLog fill also the field 'totevents'; in; PacketEvent, add switch to control whether to send te information to; the monitoring system on per packet level (may be too much for SQL).; The switch is called fMonitorPerPacket and it is globally controlled by; the rootrc variable 'Proof.MonitorPerPacket' and at session level with; the parameter PROOF_MonitorPerPacket .; Improve treatment of the case when temporary files are asked to be; created on a shared file system not containing the sandboxes. This; case, which seems to be a rather common one, should be now fully; supported.; Correctly honour selector abort status settings; TSelector::kAbortProcess and TSelector::kAbortFile.; Improve reporting of the non-processed {files, events} in the final; 'MissingFiles' list.  ; Improved algorithm for TPacketizerUnit to fix issue with non; homogeneous machines.; Improve the way the information about log files is saved in case of; failures. The log paths for these failing now should be now correctly; saved and accessible via TProofLog.; Improve merging of histograms. Just use TH1::Add whne the axis are; equal; much faster than TH1::Merge. Fixes; ; In TDataSetManagerFile::NotifyUpdate fix handling of the case when; the global list file does not exist yet (new dataset directory). Fixes; error messages during editing dataset operations.; Fix issue with machine names consistency when working on a local; machine ('localhost' or 'localhost.localdomain' are mapped to; gSystem->HostName()); solves possible matching problems in the; packetizer.; In TProofServ, fill the ""grand total"" message with more blanks, so; that no remnants of the previous message are visible on the screen.; In the autoconf/bonjour interface, fix issue preventing the correct; port (the protocol one, which may be different from the application; default) being used when registering the service. . In TProofPlayer::AddQueryResult, fix a bug affecting the order in; whihc query results are registered when the st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:5046,log,log,5046,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,1,['log'],['log']
Testability," in a comment and ask them if the patch is safe to backport.; You should also review the bug yourself to ensure that it meets the requirements; for committing to the release branch. #. Once a bug has been reviewed, add the release:reviewed label and update the; issue's status to ""Needs Merge"". Check the pull request associated with the; issue. If all the tests pass, then the pull request can be merged. If not,; then add a comment on the issue asking someone to take a look at the failures. #. Once the pull request has been merged push it to the official release branch; with the script ``llvm/utils/git/sync-release-repo.sh``. Then add a comment to the issue stating that the fix has been merged along with; the git hashes from the release branch. Add the release:merged label to the issue; and close it. Release Patch Rules; -------------------. Below are the rules regarding patching the release branch:. #. Patches applied to the release branch may only be applied by the release; manager, the official release testers or the code owners with approval from; the release manager. #. Release managers are encouraged, but not required, to get approval from code; owners before approving patches. If there is no code owner or the code owner; is unreachable then release managers can ask approval from patch reviewers or; other developers active in that area. #. *Before RC1* Patches should be limited to bug fixes, important optimization; improvements, or completion of features that were started before the branch; was created. As with all phases, release managers and code owners can reject; patches that are deemed too invasive. #. *Before RC2* Patches should be limited to bug fixes or backend specific; improvements that are determined to be very safe. #. *Before RC3/Final Major Release* Patches should be limited to critical; bugs or regressions. #. *Bug fix releases* Patches should be limited to bug fixes or very safe; and critical performance improvements. Patches must maintain both A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:12653,test,testers,12653,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['test'],['testers']
Testability," in memory](pictures/030001CE.png). Nodes are never instantiated directly by users, but created as a result; of volume operations. Adding a volume named A with a given `user id`; inside a volume B will create a node named `A_id.` This will be added to; the list of nodes stored by B. In addition, when applying a division; operation in N slices to a volume A, a list of nodes `B_1`, `B_2`, ... ,; `B_N` is also created. A node `B_i` does not represent a unique object; in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of; nodes is fully defined up to the top node in the geometry, a given; path:` /TOP_1/`...`/A_3/B_7` will represent a unique object. Its global; transformation matrix can be computed as the pile-up of all local; transformations in its branch. We will therefore call `logical graph`; the hierarchy defined by nodes and volumes. The expansion of the logical; graph by all possible paths defines a tree structure where all nodes are; unique ""touchable"" objects. We will call this the ""physical tree"".; Unlike the logical graph, the physical tree can become a huge structure; with several millions of nodes in case of complex geometries; therefore,; it is not always a good idea to keep it transient in memory. Since the; logical and physical structures are correlated, the modeller rather; keeps track only of the current branch, updating the current global; matrix at each change of the level in geometry. The current physical; node is not an object that can be asked for at a given moment, but; rather represented by the combination: current node/current global; matrix. However, physical nodes have unique ID's that can be retrieved; for a given modeller state. These can be fed back to the modeller in; order to force a physical node to become current. The advantage of this; comes from the fact that all navigation queries check first the current; node; therefore the location of a point in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:61322,log,logical,61322,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['log'],['logical']
Testability," in other places too. Also passes can be; replaced entirely so long as their task is complete as shown in this (more; customized) example pipeline. .. image:: pipeline-overview-customized.png. .. _maintainability-verifier:. MachineVerifier; ---------------. The pass approach lets us use the ``MachineVerifier`` to enforce invariants; that are required beyond certain points of the pipeline. For example, a; function with the ``legalized`` property can have the ``MachineVerifier``; enforce that no illegal instructions occur. Similarly, a; ``regBankSelected`` function may not have virtual registers without a register; bank assigned. .. note::. For layering reasons, ``MachineVerifier`` isn't able to be the sole verifier; in GlobalISel. Currently some of the passes also perform verification while; we find a way to solve this problem. The main issue is that GlobalISel is a separate library, so we can't; directly reference it from CodeGen. Testing; -------. The ability to test GlobalISel is significantly improved over SelectionDAG.; SelectionDAG is something of a black box and there's a lot going on inside it.; This makes it difficult to write a test that reliably tests a particular aspect; of its behaviour. For comparison, see the following diagram:. .. image:: testing-pass-level.png. Each of the grey boxes indicates an opportunity to serialize the current state; and test the behaviour between two points in the pipeline. The current state; can be serialized using ``-stop-before`` or ``-stop-after`` and loaded using; ``-start-before``, ``-start-after``, and ``-run-pass``. We can also go further still, as many of GlobalISel's passes are readily unit; testable:. .. image:: testing-unit-level.png. It's possible to create an imaginary target such as in `LegalizerHelperTest.cpp <https://github.com/llvm/llvm-project/blob/93b29d3882baf7df42e4e9bc26b977b00373ef56/llvm/unittests/CodeGen/GlobalISel/LegalizerHelperTest.cpp#L28-L57>`_; and perform a single step of the algorithm and chec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/Pipeline.rst:3917,test,test,3917,interpreter/llvm-project/llvm/docs/GlobalISel/Pipeline.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/Pipeline.rst,1,['test'],['test']
Testability," in the loop preheader's; predecessor basic block, and are marked as ``IntrNoDuplicate`` to avoid; optimizers duplicating these instructions. Arguments:; """""""""""""""""""". The integer operand is the loop trip count of the hardware-loop, and thus; not e.g. the loop back-edge taken count. Semantics:; """""""""""""""""""". The '``llvm.test.set.loop.iterations.*``' intrinsics do not perform any; arithmetic on their operand. It's a hint to the backend that can use this to; set up the hardware-loop count with a target specific instruction, usually a; move of this value to a special register or a hardware-loop instruction.; The result is the conditional value of whether the given count is not zero. '``llvm.test.start.loop.iterations.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. ::. declare {i32, i1} @llvm.test.start.loop.iterations.i32(i32); declare {i64, i1} @llvm.test.start.loop.iterations.i64(i64). Overview:; """""""""""""""""". The '``llvm.test.start.loop.iterations.*``' intrinsics are similar to the; '``llvm.test.set.loop.iterations.*``' and '``llvm.start.loop.iterations.*``'; intrinsics, used to specify the hardware-loop trip count, but also produce a; value identical to the input that can be used as the input to the loop. The; second i1 output controls entry to a while-loop. Arguments:; """""""""""""""""""". The integer operand is the loop trip count of the hardware-loop, and thus; not e.g. the loop back-edge taken count. Semantics:; """""""""""""""""""". The '``llvm.test.start.loop.iterations.*``' intrinsics do not perform any; arithmetic on their operand. It's a hint to the backend that can use this to; set up the hardware-loop count with a target specific instruction, usually a; move of this value to a special register or a hardware-loop instruction.; The result is a pair of the input and a conditional value of whether the; given count is not zero. '``llvm.loop.decrement.reg.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Synt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:646722,test,test,646722,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['test'],['test']
Testability, include_directories(${CUDA_INCLUDE_DIRS}). endif(). #-- -test of reference architecture; if (Test_Reference). ROOT_EXECUTABLE(testIm2Col TestIm2Col.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Im2Col COMMAND testIm2Col). ROOT_EXECUTABLE(testPoolingLayer TestPoolingLayer.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-PoolingLayer COMMAND testPoolingLayer). ROOT_EXECUTABLE(testReshape TestReshape.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Reshape COMMAND testReshape). ROOT_EXECUTABLE(testRotWeights TestRotateWeights.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-RotWeights COMMAND testRotWeights). #-- features not implemeted in ref architectures; #ROOT_EXECUTABLE(testForwardPass TestForwardPass.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-CNN-Forward COMMAND testForwardPass). #ROOT_EXECUTABLE(testConvNetLoss TestConvNetLoss.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-CNN-Loss COMMAND testConvNetLoss). #ROOT_EXECUTABLE(testConvNetPred TestConvNetPrediction.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-CNN-Pred COMMAND testConvNetPred). #ROOT_EXECUTABLE(testDLMinimization TestMinimization.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-CNN-Minimization COMMAND testDLMinimization). #ROOT_EXECUTABLE(testTensorDataLoader TestTensorDataLoader.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-Tensor-Data-Loader COMMAND testTensorDataLoader). endif(). #--- CPU tests. ----------------------------; if ((BLAS_FOUND OR mathmore) AND imt AND tmva-cpu). ROOT_EXECUTABLE(testIm2ColCpu TestIm2ColCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Im2Col-CPU COMMAND testIm2ColCpu). ROOT_EXECUTABLE(testPoolingLayerCpu TestPoolingLayerCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-PoolingLayer-CPU COMMAND testPoolingLayerCpu). ROOT_EXECUTABLE(testConvLayerCpu TestConvLayerCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-ConvLayer-CPU COMMAND testConvLayerCpu). ROOT_EXECUTABLE(testRo,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt:4294,test,testConvNetPred,4294,tmva/tmva/test/DNN/CNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt,1,['test'],['testConvNetPred']
Testability," index can be included; after the name with a comma. ``llc -stop-after=dead-mi-elimination,1 bug-trigger.ll -o test.mir``. After generating the input MIR file, you'll have to add a run line that uses; the ``-run-pass`` option to it. In order to test the post register allocation; pseudo instruction expansion pass on X86-64, a run line like the one shown; below can be used:. ``# RUN: llc -o - %s -mtriple=x86_64-- -run-pass=postrapseudos | FileCheck %s``. The MIR files are target dependent, so they have to be placed in the target; specific test directories (``lib/CodeGen/TARGETNAME``). They also need to; specify a target triple or a target architecture either in the run line or in; the embedded LLVM IR module. Simplifying MIR files; ^^^^^^^^^^^^^^^^^^^^^. The MIR code coming out of ``-stop-after``/``-stop-before`` is very verbose;; Tests are more accessible and future proof when simplified:. - Use the ``-simplify-mir`` option with llc. - Machine function attributes often have default values or the test works just; as well with default values. Typical candidates for this are: `alignment:`,; `exposesReturnsTwice`, `legalized`, `regBankSelected`, `selected`.; The whole `frameInfo` section is often unnecessary if there is no special; frame usage in the function. `tracksRegLiveness` on the other hand is often; necessary for some passes that care about block livein lists. - The (global) `liveins:` list is typically only interesting for early; instruction selection passes and can be removed when testing later passes.; The per-block `liveins:` on the other hand are necessary if; `tracksRegLiveness` is true. - Branch probability data in block `successors:` lists can be dropped if the; test doesn't depend on it. Example:; `successors: %bb.1(0x40000000), %bb.2(0x40000000)` can be replaced with; `successors: %bb.1, %bb.2`. - MIR code contains a whole IR module. This is necessary because there are; no equivalents in MIR for global variables, references to external functions,; functi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:3257,test,test,3257,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['test'],['test']
Testability," individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/test/SemaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:4017,test,test,4017,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,1,['test'],['test']
Testability," initialization.; Aggregates; are objects that can be brace-initialized without calling a; constructor (that is, ; CXXConstructExpr does not occur in the AST),; but potentially calling; constructors for their fields and base classes; These; constructors of sub-objects need to know what object they are constructing.; Moreover, if the aggregate contains; references, lifetime extension needs to be properly modeled. One can start untangling this problem by trying to replace the; current ad-hoc ; ParentMap lookup in ; CXXConstructionKind::NonVirtualBase branch of; ExprEngine::VisitCXXConstructExpr(); with proper support for the feature.; (Difficulty: Medium) . Handle array constructors.; When an array of objects is allocated (say, using the; operator new[] or defining a stack array),; constructors for all elements of the array are called.; We should model (potentially some of) such evaluations,; and the same applies for destructors called from; operator delete[].; See tests cases in handle_constructors_with_new_array.cpp.; . Constructing an array requires invoking multiple (potentially unknown); amount of constructors with the same construct-expression.; Apart from the technical difficulties of juggling program points around; correctly to avoid accidentally merging paths together, we'll have to; be a judge on when to exit the loop and how to widen it.; Given that the constructor is going to be a default constructor,; a nice 95% solution might be to execute exactly one constructor and; then default-bind the resulting LazyCompoundVal to the whole array;; it'll work whenever the default constructor doesn't touch global state; but only initializes the object to various default values.; But if, say, we're making an array of strings,; depending on the implementation you might have to allocate a new buffer; for each string, and in this case default-binding won't cut it.; We might want to come up with an auxiliary analysis in order to perform; widening of these simple loops more",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:2873,test,tests,2873,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,1,['test'],['tests']
Testability," inlined 'InlineFunction' -> 'int'; [003] {Block}; [004] 5 {Variable} 'Var_2' -> 'int'; [003] 2 {Parameter} 'Param' -> 'int'; [003] 3 {Variable} 'Var_1' -> 'int'; [002] 11 {Function} extern not_inlined 'test' -> 'int'; [003] 12 {Variable} 'A' -> 'int'; [003] 14 {InlinedFunction} inlined 'InlineFunction' -> 'int'; [004] {Block}; [005] {Variable} 'Var_2' -> 'int'; [004] {Parameter} 'Param' -> 'int'; [004] {Variable} 'Var_1' -> 'int'; [003] 11 {Parameter} 'Param_1' -> 'int'; [003] 11 {Parameter} 'Param_2' -> 'int'. DWARF - GCC (Linux); ^^^^^^^^^^^^^^^^^^^. .. code-block:: none. Logical View:; [000] {File} 'pr-43860-dwarf-gcc.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [002] {Producer} 'GNU C++14 9.3.0'; [002] 2 {Function} extern declared_inlined 'InlineFunction' -> 'int'; [003] {Block}; [004] 5 {Variable} 'Var_2' -> 'int'; [003] 2 {Parameter} 'Param' -> 'int'; [003] 3 {Variable} 'Var_1' -> 'int'; [002] 11 {Function} extern not_inlined 'test' -> 'int'; [003] 12 {Variable} 'A' -> 'int'; [003] 13 {InlinedFunction} declared_inlined 'InlineFunction' -> 'int'; [004] {Block}; [005] {Variable} 'Var_2' -> 'int'; [004] {Parameter} 'Param' -> 'int'; [004] {Variable} 'Var_1' -> 'int'; [003] 11 {Parameter} 'Param_1' -> 'int'; [003] 11 {Parameter} 'Param_2' -> 'int'. From the previous logical views, we can see that the CodeView debug; information generated by the Clang compiler shows the variables **Var_1**; and **Var_2** are at the same lexical scope (**4**) in the function; **InlineFuction**. The DWARF generated by GCC/Clang and CodeView; generated by MSVC, show those variables at the correct lexical scope:; **3** and **4** respectively. Using the :program:`llvm-debuginfo-analyzer` selection facilities, we; can produce a simple tabular output showing just the logical elements; that have in their name the *var* pattern. The logical view is sorted; by the variables name. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format; --output-sort=name; --select-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:52626,test,test,52626,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['test'],['test']
Testability," input for our; VM. Performance is not wonderful, but it works right.; * The file is scheduled to be compiled (rigorously) at a later; time. This could be done by some background process or by a second; processor in the system during idle time or something...; * To keep things ""safe"" ie to enforce a sandbox on Java/foreign code,; we could sign the generated VM code with a host specific private; key. Then before the code is executed/loaded, we can check to see if; the trusted compiler generated the code. This would be much quicker; than having to validate consistency (especially if bounds checks have; been removed, for example). > This is important because the audiences for these two goals are very; > different. Architects and many compiler people care much more about; > the second question. The Java compiler and OS community care much more; > about the first one. 3. By focusing on a more low level virtual machine, we have much more room; for value add. The nice safe ""sandbox"" VM can be provided as a layer; on top of it. It also lets us focus on the more interesting compilers; related projects. > 2. Design issues to consider (an initial list that we should continue; > to modify). Note that I'm not trying to suggest actual solutions here,; > but just various directions we can pursue:. Understood. :). > a. A single-assignment VM, which we've both already been thinking; > about. Yup, I think that this makes a lot of sense. I am still intrigued,; however, by the prospect of a minimally allocated VM representation... I; think that it could have definite advantages for certain applications; (think very small machines, like PDAs). I don't, however, think that our; initial implementations should focus on this. :). Here are some other auxiliary goals that I think we should consider:. 1. Primary goal: Support a high performance dynamic compilation; system. This means that we have an ""ideal"" division of labor between; the runtime and static compilers. Of course, the other goals ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt:2366,sandbox,sandbox,2366,interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2000-11-18-EarlyDesignIdeasResp.txt,1,['sandbox'],['sandbox']
Testability," instructions only once. * While installing the packages make sure the executable is in a path that; doesn't contain spaces. For example, you should install Python in a path like. ```sh; C:\Python27; ```; rather than. ```sh; C:\Program Files (x86)\Python 2.7; ```; * Path to all the required executables should be present in the Windows; **PATH** environment variable.; * In case of MSYS Git, choose the option ""Run Git from Windows; Command Prompt"" during installation. A good way to check if everything is detected properly by the script is to; run the following command:; ```sh; cd tools/packaging/; ./cpt.py --check-requirements; ```. #### Red Hat Linux (Fedora/Scientific Linux CERN); This section applies to all distros based on Red Hat Linux like Fedora, and; Scientific Linux CERN (SLC). Apparently, you can build RPM packages in any; distro regardless of the package manager it uses. This has been tested on; Fedora, SLC, Ubuntu, and CrunchBang. If you are interested, you can test it; on your favourite platform and email me the results. Depending on the package manager of your distro, you can install the; packages required by CPT to build RPM bundles. For a Red Hat based distro; (which uses ```yum``` package manager), you can use the following command; (also performed automatically by CPT):; ```sh; sudo yum update; sudo yum install git gcc gcc-c++ rpm-build python; ```. #### Mac OS X; Mac OS X provides a sane environement for CPT to build Apple Disk Images; (DMG Installers). On older versions of Mac OS, you need to update XCode to; get the latest version of Clang supporting c++11 features. A great package; manager for Mac OS X is [Macports]. It is recommended that you use the; packages provided by Macports for running CPT (or any other tool if that; is the case) rather than the ones which come pre-installed with Mac OS.; Assuming that you have Macports installed on your Mac, you can use the; following command to install the requisite packages (also done automatically; by ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md:5122,test,test,5122,interpreter/cling/tools/packaging/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md,1,['test'],['test']
Testability," int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. .. _core-uninitialized-Assign:. core.uninitialized.Assign (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for assigning uninitialized values. .. code-block:: c. void test() {; int x;; x |= 1; // warn: left expression is uninitialized; }. .. _core-uninitialized-Branch:. core.uninitialized.Branch (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as branch conditions. .. code-block:: c. void test() {; int x;; if (x) // warn; return;; }. .. _core-uninitialized-CapturedBlockVariable:. core.uninitialized.CapturedBlockVariable (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for blocks that capture uninitialized values. .. code-block:: c. void test() {; int x;; ^{ int y = x; }(); // warn; }. .. _core-uninitialized-UndefReturn:. core.uninitialized.UndefReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values being returned to the caller. .. code-block:: c. int test() {; int x;; return x; // warn; }. .. _core-uninitialized-NewArraySize:. core.uninitialized.NewArraySize (C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Check if the element count in new[] is garbage or undefined. .. code-block:: cpp. void test() {; int n;; int *arr = new int[n]; // warn: Element count in new[] is a garbage value; delete[] arr;; }. .. _cplusplus-checkers:. cplusplus; ^^^^^^^^^. C++ Checkers. .. _cplusplus-InnerPointer:. cplusplus.InnerPointer (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for inner pointers of C++ containers used after re/deallocation. Many container methods in the C++ standard library are known to invalidate; ""references"" (including actual references, iterators and raw pointers) to; elements of the container. Using such references after they are invalidated; causes undefined behavior, which is a common source of memory errors in C++ that; this checker is capable of finding. The checker is currently limited to ``std::string`` objects and doesn't; recognize some of the m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:6806,test,test,6806,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability," int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test.cc:7:7; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. Origin value: 0x9e00001, Taint value was created at; #0 0x55676db85a08 in main test.cc:6:3; #1 0x7f0083611bbc in __libc_sta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:12077,assert,assert,12077,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,3,['assert'],['assert']
Testability," int main(int argc, char *argv[]) {; printf(""hello, world!\n"");; return 0;; }. % clang -c -o hello-world.o hello-world.c; % llvm-jitlink hello-world.o; Hello, World!. Multiple objects may be specified, and arguments may be provided to the JIT'd; main function using the -args option:. .. code-block:: sh. % cat print-args.c; #include <stdio.h>. void print_args(int argc, char *argv[]) {; for (int i = 0; i != argc; ++i); printf(""arg %i is \""%s\""\n"", i, argv[i]);; }. % cat print-args-main.c; void print_args(int argc, char *argv[]);. int main(int argc, char *argv[]) {; print_args(argc, argv);; return 0;; }. % clang -c -o print-args.o print-args.c; % clang -c -o print-args-main.o print-args-main.c; % llvm-jitlink print-args.o print-args-main.o -args a b c; arg 0 is ""a""; arg 1 is ""b""; arg 2 is ""c"". Alternative entry points may be specified using the ``-entry <entry point; name>`` option. Other options can be found by calling ``llvm-jitlink -help``. llvm-jitlink as a regression testing utility; --------------------------------------------. One of the primary aims of ``llvm-jitlink`` was to enable readable regression; tests for JITLink. To do this it supports two options:. The ``-noexec`` option tells llvm-jitlink to stop after looking up the entry; point, and before attempting to execute it. Since the linked code is not; executed, this can be used to link for other targets even if you do not have; access to the target being linked (the ``-define-abs`` or ``-phony-externals``; options can be used to supply any missing definitions in this case). The ``-check <check-file>`` option can be used to run a set of ``jitlink-check``; expressions against working memory. It is typically used in conjunction with; ``-noexec``, since the aim is to validate JIT'd memory rather than to run the; code and ``-noexec`` allows us to link for any supported target architecture; from the current process. In ``-check`` mode, ``llvm-jitlink`` will scan the; given check-file for lines of the form ``# j",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:38563,test,testing,38563,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['test'],['testing']
Testability," intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Float_t fCharge; //Charge of this track; Float_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion. // method definitions ...; ClassDef(Track,1) //A track segment; };; ```. ### Writing the Tree. We create a simple tree with two branches both holding `Event` objects.; One is split and the other is not. We also create a pointer to an; `Event` object (`event`). ``` {.cpp}; void tree4w() {; // check to see if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; // create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; // create a pointer to an Event object; Event *event = new Event();; // create two branches, split one; t4.Branch(""event_branch"", ""Event"", &event,16000,2);; t4.Branch(""event_not_split"", ""Event"", &event,16000,0);. // a local variable for the event type; char etype[20];. // fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:62438,test,test,62438,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['test'],['test']
Testability," into; ``llvm/lib/Passes/PassBuilder.cpp`` multiple times for various reasons. Since; it constructs our pass, we need to also add the proper #include in; ``llvm/lib/Passes/PassBuilder.cpp``:. .. code-block:: c++. #include ""llvm/Transforms/Utils/HelloWorld.h"". This should be all the code necessary for our pass, now it's time to compile; and run it. Running a pass with ``opt``; ---------------------------. Now that you have a brand new shiny pass, we can build :program:`opt` and use; it to run some LLVM IR through the pass. .. code-block:: console. $ ninja -C build/ opt; # or whatever build system/build directory you are using. $ cat /tmp/a.ll; define i32 @foo() {; %a = add i32 2, 3; ret i32 %a; }. define void @bar() {; ret void; }. $ build/bin/opt -disable-output /tmp/a.ll -passes=helloworld; foo; bar. Our pass ran and printed the names of functions as expected!. Testing a pass; --------------. Testing our pass is important to prevent future regressions. We'll add a lit; test at ``llvm/test/Transforms/Utils/helloworld.ll``. See; :doc:`TestingGuide` for more information on testing. .. code-block:: llvm. $ cat llvm/test/Transforms/Utils/helloworld.ll; ; RUN: opt -disable-output -passes=helloworld %s 2>&1 | FileCheck %s. ; CHECK: {{^}}foo{{$}}; define i32 @foo() {; %a = add i32 2, 3; ret i32 %a; }. ; CHECK-NEXT: {{^}}bar{{$}}; define void @bar() {; ret void; }. $ ninja -C build check-llvm; # runs our new test alongside all other llvm lit tests. FAQs; ====. Required passes; ---------------. A pass that defines a static ``isRequired()`` method that returns true is a required pass. For example:. .. code-block:: c++. class HelloWorldPass : public PassInfoMixin<HelloWorldPass> {; public:; PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);. static bool isRequired() { return true; }; };. A required pass is a pass that may not be skipped. An example of a required; pass is ``AlwaysInlinerPass``, which must always be run to preserve; ``alwaysinline`` semantics. Pass",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst:5927,test,test,5927,interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,2,['test'],['test']
Testability," invocation.; set(extra_deps """"); if(""openmp"" IN_LIST LLVM_ENABLE_RUNTIMES); foreach(dep opt llvm-link llvm-extract clang clang-offload-packager); if(TARGET ${dep} AND OPENMP_ENABLE_LIBOMPTARGET); list(APPEND extra_deps ${dep}); endif(); endforeach(); endif(); if(""libc"" IN_LIST LLVM_ENABLE_PROJECTS AND; (LLVM_LIBC_FULL_BUILD OR LIBC_GPU_BUILD OR LIBC_GPU_ARCHITECTURES)); if(LIBC_HDRGEN_EXE); set(hdrgen_exe ${LIBC_HDRGEN_EXE}); else(); if(TARGET ${LIBC_TABLEGEN_EXE}); set(hdrgen_exe $<TARGET_FILE:${LIBC_TABLEGEN_EXE}>); else(); set(hdrgen_exe ${LIBC_TABLEGEN_EXE}); endif(); set(hdrgen_deps ${LIBC_TABLEGEN_TARGET}); endif(); if(NOT hdrgen_exe); message(FATAL_ERROR ""libc-hdrgen executable missing""); endif(); set(libc_cmake_args ""-DLIBC_HDRGEN_EXE=${hdrgen_exe}""; ""-DLLVM_LIBC_FULL_BUILD=ON""); list(APPEND extra_deps ${hdrgen_deps}); if(LIBC_GPU_BUILD OR LIBC_GPU_ARCHITECTURES); foreach(dep clang-offload-packager nvptx-arch amdgpu-arch); if(TARGET ${dep}); list(APPEND extra_deps ${dep}); endif(); endforeach(); endif(); endif(); if(NOT LLVM_RUNTIME_TARGETS); runtime_default_target(; DEPENDS ${builtins_dep} ${extra_deps}; CMAKE_ARGS ${libc_cmake_args}; PREFIXES ${prefixes}); set(test_targets check-runtimes); else(); if(""default"" IN_LIST LLVM_RUNTIME_TARGETS); runtime_default_target(; DEPENDS ${builtins_dep} ${extra_deps}; CMAKE_ARGS ${libc_cmake_args}; PREFIXES ${prefixes}); list(REMOVE_ITEM LLVM_RUNTIME_TARGETS ""default""); else(); add_custom_target(runtimes); add_custom_target(runtimes-configure); add_custom_target(install-runtimes); add_custom_target(install-runtimes-stripped); if(LLVM_INCLUDE_TESTS); add_custom_target(check-runtimes); add_custom_target(runtimes-test-depends); set(test_targets """"); endif(); if(LLVM_RUNTIME_DISTRIBUTION_COMPONENTS); foreach(component ${LLVM_RUNTIME_DISTRIBUTION_COMPONENTS}); add_custom_target(${component}); add_custom_target(install-${component}); add_custom_target(install-${component}-stripped); endforeach(); endif(); endif(). foreach(nam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt:17060,test,test-depends,17060,interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/runtimes/CMakeLists.txt,1,['test'],['test-depends']
Testability," is a direct function call, but; indirect ``call``'s are just as possible, calling an arbitrary pointer; to function value.; #. '``function args``': argument list whose types match the function; signature argument types and parameter attributes. All arguments must; be of :ref:`first class <t_firstclass>` type. If the function signature; indicates the function accepts a variable number of arguments, the; extra arguments can be specified.; #. The optional :ref:`function attributes <fnattrs>` list.; #. The optional :ref:`operand bundles <opbundles>` list. Semantics:; """""""""""""""""""". The '``call``' instruction is used to cause control flow to transfer to; a specified function, with its incoming arguments bound to the specified; values. Upon a '``ret``' instruction in the called function, control; flow continues with the instruction after the function call, and the; return value of the function is bound to the result argument. Example:; """""""""""""""". .. code-block:: llvm. %retval = call i32 @test(i32 %argc); call i32 (ptr, ...) @printf(ptr %msg, i32 12, i8 42) ; yields i32; %X = tail call i32 @foo() ; yields i32; %Y = tail call fastcc i32 @foo() ; yields i32; call void %foo(i8 signext 97). %struct.A = type { i32, i8 }; %r = call %struct.A @foo() ; yields { i32, i8 }; %gr = extractvalue %struct.A %r, 0 ; yields i32; %gr1 = extractvalue %struct.A %r, 1 ; yields i8; %Z = call void @foo() noreturn ; indicates that %foo never returns normally; %ZZ = call zeroext i32 @bar() ; Return value is %zero extended. llvm treats calls to some functions with names and arguments that match; the standard C99 library as being the C99 library functions, and may; perform optimizations or generate code for them under that assumption.; This is something we'd like to change in the future to provide better; support for freestanding environments and non-C-based languages. .. _i_va_arg:. '``va_arg``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = va_arg <va_list*> <arglist>, <ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:478155,test,test,478155,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['test'],['test']
Testability," is checked to validate of debugging information. See README.txt in the; test suite for more information. This test suite is located in the; ``cross-project-tests/debuginfo-tests`` directory. Quick start; ===========. The tests are located in two separate repositories. The unit and; regression tests are in the main ""llvm""/ directory under the directories; ``llvm/unittests`` and ``llvm/test`` (so you get these tests for free with the; main LLVM tree). Use ``make check-all`` to run the unit and regression tests; after building LLVM. The ``test-suite`` module contains more comprehensive tests including whole C; and C++ programs. See the :doc:`TestSuiteGuide` for details. Unit and Regression tests; -------------------------. To run all of the LLVM unit tests use the check-llvm-unit target:. .. code-block:: bash. % make check-llvm-unit. To run all of the LLVM regression tests use the check-llvm target:. .. code-block:: bash. % make check-llvm. In order to get reasonable testing performance, build LLVM and subprojects; in release mode, i.e. .. code-block:: bash. % cmake -DCMAKE_BUILD_TYPE=""Release"" -DLLVM_ENABLE_ASSERTIONS=On. If you have `Clang <https://clang.llvm.org/>`_ checked out and built, you; can run the LLVM and Clang tests simultaneously using:. .. code-block:: bash. % make check-all. To run the tests with Valgrind (Memcheck by default), use the ``LIT_ARGS`` make; variable to pass the required options to lit. For example, you can use:. .. code-block:: bash. % make check LIT_ARGS=""-v --vg --vg-leak"". to enable testing with valgrind and with leak checking enabled. To run individual tests or subsets of tests, you can use the ``llvm-lit``; script which is built as part of LLVM. For example, to run the; ``Integer/BitPacked.ll`` test by itself you can run:. .. code-block:: bash. % llvm-lit ~/llvm/test/Integer/BitPacked.ll. or to run all of the ARM CodeGen tests:. .. code-block:: bash. % llvm-lit ~/llvm/test/CodeGen/ARM. The regression tests will use the Python psutil ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:5317,test,testing,5317,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['testing']
Testability," is different from the LLVM schedule profile values (`analysis` mode). .. option:: --analysis-display-unstable-clusters. If there is more than one benchmark for an opcode, said benchmarks may end up; not being clustered into the same cluster if the measured performance; characteristics are different. by default all such opcodes are filtered out.; This flag will instead show only such unstable opcodes. .. option:: --ignore-invalid-sched-class=false. If set, ignore instructions that do not have a sched class (class idx = 0). .. option:: --mtriple=<triple name>. Target triple. See `-version` for available targets. .. option:: --mcpu=<cpu name>. If set, measure the cpu characteristics using the counters for this CPU. This; is useful when creating new sched models (the host CPU is unknown to LLVM).; (`-mcpu=help` for details). .. option:: --analysis-override-benchmark-triple-and-cpu. By default, llvm-exegesis will analyze the benchmarks for the triple/CPU they; were measured for, but if you want to analyze them for some other combination; (specified via `-mtriple`/`-mcpu`), you can pass this flag. .. option:: --dump-object-to-disk=true. If set, llvm-exegesis will dump the generated code to a temporary file to; enable code inspection. Disabled by default. .. option:: --use-dummy-perf-counters. If set, llvm-exegesis will not read any real performance counters and; return a dummy value instead. This can be used to ensure a snippet doesn't; crash when hardware performance counters are unavailable and for; debugging :program:`llvm-exegesis` itself. .. option:: --execution-mode=[inprocess,subprocess]. This option specifies what execution mode to use. The `inprocess` execution; mode is the default. The `subprocess` execution mode allows for additional; features such as memory annotations but is currently restricted to X86-64; on Linux. .. option:: --benchmark-repeat-count=<repeat-count>. This option enables specifying the number of times to repeat the measurement; when performi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:17183,benchmark,benchmarks,17183,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['benchmark'],['benchmarks']
Testability," is ill-formed. .. note::. Could define this case as returning an implicit location description as; if the ``DW_OP_implicit`` operation is performed. * If the current result kind specifies a value, then:. * If the top stack entry is a value, or can be converted to one (see; :ref:`amdgpu-dwarf-memory-location-description-operations`), then the result; is that, possibly converted, value. Any other entries on the stack are; discarded. * Otherwise the DWARF expression is ill-formed. * If the current result kind is not specified, then:. * If the stack is empty, the result is a location description with one; undefined location description. *This rule is for backwards compatibility with DWARF Version 5 which has no; explicit operation to create an undefined location description, and uses an; empty operation expression for this purpose.*. .. note::. This rule is consistent with the rule above for when a location; description is requested. However, GDB appears to report this as an error; and no GDB tests appear to cause an empty stack for this case. * Otherwise, the top stack entry is returned. Any other entries on the stack; are discarded. An operation expression is encoded as a byte block with some form of prefix that; specifies the byte count. It can be used:. * as the value of a debugging information entry attribute that is encoded using; class ``exprloc`` (see :ref:`amdgpu-dwarf-classes-and-forms`),. * as the operand to certain operation expression operations,. * as the operand to certain call frame information operations (see; :ref:`amdgpu-dwarf-call-frame-information`),. * and in location list entries (see; :ref:`amdgpu-dwarf-location-list-expressions`). .. _amdgpu-dwarf-vendor-extensions-operations:. A.2.5.4.0 Vendor Extension Operations; #####################################. 1. ``DW_OP_LLVM_user``. ``DW_OP_LLVM_user`` encodes a vendor extension operation. It has at least one; operand: a ULEB128 constant identifying a vendor extension operation. The; remaining opera",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:67013,test,tests,67013,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['test'],['tests']
Testability," is now `index`.; ```; coordinates are now passed into calcTreeIndex without side effects:; ```; // In a subclass:; auto index = calcTreeIndex(externalCoordinates, fast=<true/false>); // No side effect. // From the outside:; auto index = dataHist.getIndex(externalCoordinates); // No side effect; ```; This will allow for marking more functions const, or for lying less about const correctness. - RooDataHist now supports fits with RooFit's faster `BatchMode()`.; - Lower memory footprint. If weight errors are not needed, RooDataHist now allocates only 40% of the memory that the old implementation used. #### Fix bin volume correction logic in `RooDataHist::sum()`. The public member function `RooDataHist::sum()` has three overloads.; Two of these overloads accept a `sumSet` parameter to not sum over all variables.; These two overloads previously behaved inconsistently when the `correctForBinSize` or `inverseBinCor` flags were set.; If you use the `RooDataHist::sum()` function in you own classes, please check that it can still be used with its new logic.; The new and corrected bin correction behaviour is:. - `correctForBinSize`: multiply counts in each bin by the bin volume corresponding to the variables in `sumSet`; - `inverseBinCor`: divide counts in each bin by the bin volume corresponding to the variables *not* in `sumSet`. ### New fully parametrised Crystal Ball shape class. So far, the Crystal Ball distribution has been represented in RooFit only by the `RooCBShape` class, which has a Gaussian core and a single power-law tail on one side.; This release introduces [`RooCrystalBall`](https://root.cern/doc/v624/classRooCrystalBall.html), which implements some common generalizations of the Crystal Ball shape:. - symmetric or asymmetric power-law tails on both sides; - different width parameters for the left and right sides of the Gaussian core. The new `RooCrystalBall` class can substitute the `RooDSCBShape` and `RooSDSCBShape`, which were passed around in the community. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:23661,log,logic,23661,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['log'],['logic']
Testability," is only used for that; specific function. In above example, `gamma_cdf()` falls back to Numeric; Differentiation but other functions in `MathFuncs.h` will still be; able to use AD. This is because Clad is going to assume that you have a; derivative for this `gamma_cdf()` function, and the remaining functions will; use AD as expected. In the end, the remaining functions (including; `gamma_cdf()`) will try to fall back to Numeric Differentiation. However, if you want to add pure AD support, you need to make sure that all; your external functions are supported by Clad (meaning there is a custom; derivative defined for each of them). ### How do I test my new class while adding AD support?. Please look at the test classes that test the derivatives, evaluates,; fixtures, etc. (defined in 'roofit/roofitcore/test'). You can clone and adapt; these tests to your class as needed. For example:. > [roofit/roofitcore/test/testRooFuncWrapper.cxx](https://github.com/root-project/root/blob/master/roofit/roofitcore/test/testRooFuncWrapper.cxx). > Tip: Tests like above can be referenced to see which parts of RooFit already; support AD. ### How do I control my compile time?. This is an area of research that still needs some work. In most cases, the; compile times are reasonable, but with an increase in the level of complexity,; higher compile times may be encountered. ## Appendix B - Where does AD Logic Implementation reside?. Following classes provide several Helper Functions to translate existing logic; into AD-supported logic. a - RooFit::Detail::CodeSquashContext. b - RooFuncWrapper. ### a. RooFit::Detail::CodeSquashContext. > [roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h](https://github.com/root-project/root/blob/master/roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h). It handles how to create a C++ function out of the compute graph (which is; created with different RooFit classes). This C++ function will be independent; of these RooFit classes. RooFit::Detail:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:29259,test,test,29259,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,2,['test'],"['test', 'testRooFuncWrapper']"
Testability," is profitable. .. code-block:: c++. void foo(int *A, char *B, int n) {; for (int i = 0; i < n; ++i); A[i] += 4 * B[i];; }. Global Structures Alias Analysis; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Access to global structures can also be vectorized, with alias analysis being; used to make sure accesses don't alias. Run-time checks can also be added on; pointer access to structure members. Many variations are supported, but some that rely on undefined behaviour being; ignored (as other compilers do) are still being left un-vectorized. .. code-block:: c++. struct { int A[100], K, B[100]; } Foo;. void foo() {; for (int i = 0; i < 100; ++i); Foo.A[i] = Foo.B[i] + 100;; }. Vectorization of function calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The Loop Vectorizer can vectorize intrinsic math functions.; See the table below for a list of these functions. +-----+-----+---------+; | pow | exp | exp2 |; +-----+-----+---------+; | sin | cos | sqrt |; +-----+-----+---------+; | log |log2 | log10 |; +-----+-----+---------+; |fabs |floor| ceil |; +-----+-----+---------+; |fma |trunc|nearbyint|; +-----+-----+---------+; | | | fmuladd |; +-----+-----+---------+. Note that the optimizer may not be able to vectorize math library functions; that correspond to these intrinsics if the library calls access external state; such as ""errno"". To allow better optimization of C/C++ math library functions,; use ""-fno-math-errno"". The loop vectorizer knows about special instructions on the target and will; vectorize a loop containing a function call that maps to the instructions. For; example, the loop below will be vectorized on Intel x86 if the SSE4.1 roundps; instruction is available. .. code-block:: c++. void foo(float *f) {; for (int i = 0; i != 1024; ++i); f[i] = floorf(f[i]);; }. Partial unrolling during vectorization; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Modern processors feature multiple execution units, and only programs that contain a; high degree of parallelism can fully utilize the entire wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:9466,log,log,9466,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['log'],['log']
Testability," is typically; ``cmake/llvm/`` within the lib directory. On Linux, this is typically; ``/usr/lib/cmake/llvm/LLVMConfig.cmake``. * ``<LLVM_BUILD_ROOT>/lib/cmake/llvm/LLVMConfig.cmake`` where; ``<LLVM_BUILD_ROOT>`` is the root of the LLVM build tree. **Note: this is only; available when building LLVM with CMake.**. If LLVM is installed in your operating system's normal installation prefix (e.g.; on Linux this is usually ``/usr/``) ``find_package(LLVM ...)`` will; automatically find LLVM if it is installed correctly. If LLVM is not installed; or you wish to build directly against the LLVM build tree you can use; ``LLVM_DIR`` as previously mentioned. The ``LLVMConfig.cmake`` file sets various useful variables. Notable variables; include. ``LLVM_CMAKE_DIR``; The path to the LLVM CMake directory (i.e. the directory containing; LLVMConfig.cmake). ``LLVM_DEFINITIONS``; A list of preprocessor defines that should be used when building against LLVM. ``LLVM_ENABLE_ASSERTIONS``; This is set to ON if LLVM was built with assertions, otherwise OFF. ``LLVM_ENABLE_EH``; This is set to ON if LLVM was built with exception handling (EH) enabled,; otherwise OFF. ``LLVM_ENABLE_RTTI``; This is set to ON if LLVM was built with run time type information (RTTI),; otherwise OFF. ``LLVM_INCLUDE_DIRS``; A list of include paths to directories containing LLVM header files. ``LLVM_PACKAGE_VERSION``; The LLVM version. This string can be used with CMake conditionals, e.g., ``if; (${LLVM_PACKAGE_VERSION} VERSION_LESS ""3.5"")``. ``LLVM_TOOLS_BINARY_DIR``; The path to the directory containing the LLVM tools (e.g. ``llvm-as``). Notice that in the above example we link ``simple-tool`` against several LLVM; libraries. The list of libraries is determined by using the; ``llvm_map_components_to_libnames()`` CMake function. For a list of available; components look at the output of running ``llvm-config --components``. Note that for LLVM < 3.5 ``llvm_map_components_to_libraries()`` was; used instead of ``llvm_ma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:43818,assert,assertions,43818,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['assert'],['assertions']
Testability," is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, the; distribution of the pull values is a standard normal distribution, i.e.; a Gaussian distribution centred around zero with a standard deviation of one. The macro performs a rather big number of toy experiments, where a; histogram is repeatedly filled with Gaussian distributed numbers,; representing the pseudo-data in this example. Each time, a fit is; performed according to the selected method, and the pull is calculated; and filled into a histogram. Here is the code:. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro9.C; ```. Your present knowledge of ROOT should be enough to understand all the; technicalities ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:4208,log,log-likelihood,4208,documentation/primer/functions_and_parameter_estimation.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md,1,['log'],['log-likelihood']
Testability," is; missing or neglected, the External tests won't work. * *--with-externals*. * *--with-externals=<directory>*. This tells LLVM where to find any external tests. They are expected to; be in specifically named subdirectories of <``directory``>. If; ``directory`` is left unspecified, ``configure`` uses the default value; ``/home/vadve/shared/benchmarks/speccpu2000/benchspec``. Subdirectory; names known to LLVM include:. * spec95. * speccpu2000. * speccpu2006. * povray31. Others are added from time to time, and can be determined from; ``configure``. Running Different Tests; =======================. In addition to the regular ""whole program"" tests, the ``test-suite``; module also provides a mechanism for compiling the programs in different; ways. If the variable TEST is defined on the ``gmake`` command line, the; test system will include a Makefile named; ``TEST.<value of TEST variable>.Makefile``. This Makefile can modify; build rules to yield different results. For example, the LLVM nightly tester uses ``TEST.nightly.Makefile`` to; create the nightly test reports. To run the nightly tests, run; ``gmake TEST=nightly``. There are several TEST Makefiles available in the tree. Some of them are; designed for internal LLVM research and will not work outside of the; LLVM research group. They may still be valuable, however, as a guide to; writing your own TEST Makefile for any optimization or analysis passes; that you develop with LLVM. Generating Test Output; ======================. There are a number of ways to run the tests and generate output. The; most simple one is simply running ``gmake`` with no arguments. This will; compile and run all programs in the tree using a number of different; methods and compare results. Any failures are reported in the output,; but are likely drowned in the other output. Passes are not reported; explicitly. Somewhat better is running ``gmake TEST=sometest test``, which runs the; specified test and usually adds per-program summaries to the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:3201,test,tester,3201,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,1,['test'],['tester']
Testability," it issues. They don't affect generated code or behavior at run-time. For historical reasons, prior versions of thread safety used macro names that; were very lock-centric. These macros have since been renamed to fit a more; general capability model. The prior names are still in use, and will be; mentioned under the tag *previously* where appropriate. GUARDED_BY(c) and PT_GUARDED_BY(c); ----------------------------------. ``GUARDED_BY`` is an attribute on data members, which declares that the data; member is protected by the given capability. Read operations on the data; require shared access, while write operations require exclusive access. ``PT_GUARDED_BY`` is similar, but is intended for use on pointers and smart; pointers. There is no constraint on the data member itself, but the *data that; it points to* is protected by the given capability. .. code-block:: c++. Mutex mu;; int *p1 GUARDED_BY(mu);; int *p2 PT_GUARDED_BY(mu);; unique_ptr<int> p3 PT_GUARDED_BY(mu);. void test() {; p1 = 0; // Warning!. *p2 = 42; // Warning!; p2 = new int; // OK. *p3 = 42; // Warning!; p3.reset(new int); // OK.; }. REQUIRES(...), REQUIRES_SHARED(...); -----------------------------------. *Previously*: ``EXCLUSIVE_LOCKS_REQUIRED``, ``SHARED_LOCKS_REQUIRED``. ``REQUIRES`` is an attribute on functions or methods, which; declares that the calling thread must have exclusive access to the given; capabilities. More than one capability may be specified. The capabilities; must be held on entry to the function, *and must still be held on exit*. ``REQUIRES_SHARED`` is similar, but requires only shared access. .. code-block:: c++. Mutex mu1, mu2;; int a GUARDED_BY(mu1);; int b GUARDED_BY(mu2);. void foo() REQUIRES(mu1, mu2) {; a = 0;; b = 0;; }. void test() {; mu1.Lock();; foo(); // Warning! Requires mu2.; mu1.Unlock();; }. ACQUIRE(...), ACQUIRE_SHARED(...), RELEASE(...), RELEASE_SHARED(...), RELEASE_GENERIC(...); ---------------------------------------------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:7376,test,test,7376,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['test'],['test']
Testability," jitlink-check: <expr>``. See; examples of this usage in ``llvm/test/ExecutionEngine/JITLink``. Remote execution via llvm-jitlink-executor; ------------------------------------------. By default ``llvm-jitlink`` will link the given objects into its own process,; but this can be overridden by two options:. The ``-oop-executor[=/path/to/executor]`` option tells ``llvm-jitlink`` to; execute the given executor (which defaults to ``llvm-jitlink-executor``) and; communicate with it via file descriptors which it passes to the executor; as the first argument with the format ``filedescs=<in-fd>,<out-fd>``. The ``-oop-executor-connect=<host>:<port>`` option tells ``llvm-jitlink`` to; connect to an already running executor via TCP on the given host and port. To; use this option you will need to start ``llvm-jitlink-executor`` manually with; ``listen=<host>:<port>`` as the first argument. Harness mode; ------------. The ``-harness`` option allows a set of input objects to be designated as a test; harness, with the regular object files implicitly treated as objects to be; tested. Definitions of symbols in the harness set override definitions in the; test set, and external references from the harness cause automatic scope; promotion of local symbols in the test set (these modifications to the usual; linker rules are accomplished via an ``ObjectLinkingLayer::Plugin`` installed by; ``llvm-jitlink`` when it sees the ``-harness`` option). With these modifications in place we can selectively test functions in an object; file by mocking those function's callees. For example, suppose we have an object; file, ``test_code.o``, compiled from the following C source (which we need not; have access to):. .. code-block:: c. void irrelevant_function() { irrelevant_external(); }. int function_to_mock(int X) {; return /* some function of X */;; }. static void function_to_test() {; ...; int Y = function_to_mock();; printf(""Y is %i\n"", Y);; }. If we want to know how ``function_to_test`` behaves whe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:40571,test,test,40571,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,2,['test'],"['test', 'tested']"
Testability," kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. osx.coreFoundation.CFRetainRelease; (C); Check for null arguments to CFRetain, CFRelease,; CFMakeCollectable. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. osx.coreFoundation.containers.OutOfBounds; (C); Checks for index out-of-bounds when using CFArray API. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. osx.coreFoundation.containers.PointerSizedValues; (C); Warns if CFArray, CFDictionary, CFSet are; created with non-pointer-size values. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // warn; }. Security Checkers. Name, DescriptionExample. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void tes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:21160,test,test,21160,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability," key adaptation. Notably, we only choose a very small percentage of allocations; to sample, and apply guard pages to these sampled allocations only. The sampling; is small enough to allow us to have very low performance overhead. There is a small, tunable memory overhead that is fixed for the lifetime of the; process. This is approximately ~40KiB per process using the default settings,; depending on the average size of your allocations. GWP-ASan vs. ASan; =================. Unlike `AddressSanitizer <https://clang.llvm.org/docs/AddressSanitizer.html>`_,; GWP-ASan does not induce a significant performance overhead. ASan often requires; the use of dedicated canaries to be viable in production environments, and as; such is often impractical. GWP-ASan is only capable of finding a subset of the memory issues detected by; ASan. Furthermore, GWP-ASan's bug detection capabilities are only probabilistic.; As such, we recommend using ASan over GWP-ASan in testing, as well as anywhere; else that guaranteed error detection is more valuable than the 2x execution; slowdown/binary size bloat. For the majority of production environments, this; impact is too high, and GWP-ASan proves extremely useful. Design; ======. **Please note:** The implementation of GWP-ASan is largely in-flux, and these; details are subject to change. There are currently other implementations of; GWP-ASan, such as the implementation featured in; `Chromium <https://cs.chromium.org/chromium/src/components/gwp_asan/>`_. The; long-term support goal is to ensure feature-parity where reasonable, and to; support compiler-rt as the reference implementation. Allocator Support; -----------------. GWP-ASan is not a replacement for a traditional allocator. Instead, it works by; inserting stubs into a supporting allocator to redirect allocations to GWP-ASan; when they're chosen to be sampled. These stubs are generally implemented in the; implementation of ``malloc()``, ``free()`` and ``realloc()``. The stubs are; extremely",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:1413,test,testing,1413,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['test'],['testing']
Testability," language with; LLVM <index.html>`_"" tutorial. In chapters 1 through 6, we've built a; very respectable, albeit simple, `functional programming; language <http://en.wikipedia.org/wiki/Functional_programming>`_. In our; journey, we learned some parsing techniques, how to build and represent; an AST, how to build LLVM IR, and how to optimize the resultant code as; well as JIT compile it. While Kaleidoscope is interesting as a functional language, the fact; that it is functional makes it ""too easy"" to generate LLVM IR for it. In; particular, a functional language makes it very easy to build LLVM IR; directly in `SSA; form <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_.; Since LLVM requires that the input code be in SSA form, this is a very; nice property and it is often unclear to newcomers how to generate code; for an imperative language with mutable variables. The short (and happy) summary of this chapter is that there is no need; for your front-end to build SSA form: LLVM provides highly tuned and; well tested support for this, though the way it works is a bit; unexpected for some. Why is this a hard problem?; ===========================. To understand why mutable variables cause complexities in SSA; construction, consider this extremely simple C example:. .. code-block:: c. int G, H;; int test(_Bool Condition) {; int X;; if (Condition); X = G;; else; X = H;; return X;; }. In this case, we have the variable ""X"", whose value depends on the path; executed in the program. Because there are two different possible values; for X before the return instruction, a PHI node is inserted to merge the; two values. The LLVM IR that we want for this example looks like this:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:1322,test,tested,1322,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['test'],['tested']
Testability," least):. %struct.t1 = type { i8, [3 x i8] }; @s2 = global %struct.t1 zeroinitializer, align 4; @s1 = global %struct.t1 zeroinitializer, align 4; define void @func1() nounwind ssp noredzone {; entry:; %0 = load i32* bitcast (%struct.t1* @s2 to i32*), align 4; %bf.val.sext5 = and i32 %0, 1; %1 = load i32* bitcast (%struct.t1* @s1 to i32*), align 4; %2 = and i32 %1, -4; %3 = or i32 %2, %bf.val.sext5; %bf.val.sext26 = and i32 %0, 2; %4 = or i32 %3, %bf.val.sext26; store i32 %4, i32* bitcast (%struct.t1* @s1 to i32*), align 4; ret void; }. The two or/and's should be merged into one each. //===---------------------------------------------------------------------===//. Machine level code hoisting can be useful in some cases. For example, PR9408; is about:. typedef union {; void (*f1)(int);; void (*f2)(long);; } funcs;. void foo(funcs f, int which) {; int a = 5;; if (which) {; f.f1(a);; } else {; f.f2(a);; }; }. which we compile to:. foo: # @foo; # %bb.0: # %entry; pushq %rbp; movq %rsp, %rbp; testl %esi, %esi; movq %rdi, %rax; je .LBB0_2; # %bb.1: # %if.then; movl $5, %edi; callq *%rax; popq %rbp; ret; .LBB0_2: # %if.else; movl $5, %edi; callq *%rax; popq %rbp; ret. Note that bb1 and bb2 are the same. This doesn't happen at the IR level; because one call is passing an i32 and the other is passing an i64. //===---------------------------------------------------------------------===//. I see this sort of pattern in 176.gcc in a few places (e.g. the start of; store_bit_field). The rem should be replaced with a multiply and subtract:. %3 = sdiv i32 %A, %B; %4 = srem i32 %A, %B. Similarly for udiv/urem. Note that this shouldn't be done on X86 or ARM,; which can do this in a single operation (instruction or libcall). It is; probably best to do this in the code generator. //===---------------------------------------------------------------------===//. unsigned foo(unsigned x, unsigned y) { return (x & y) == 0 || x == 0; }; should fold to (x & y) == 0. //===-----------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:66985,test,testl,66985,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['test'],['testl']
Testability," legitimate-seeming; return types and call everything else an error. This serves the secondary; purpose of encouraging programmers not to accidentally give methods names; in the ``init`` family. Note that a method with an ``init``-family selector which returns a; non-Objective-C type (e.g. ``void``) is perfectly well-formed; it simply; isn't in the ``init`` family. A program is ill-formed if a method's declarations, implementations, and; overrides do not all have the same method family. .. _arc.family.attribute:. Explicit method family control; ------------------------------. A method may be annotated with the ``objc_method_family`` attribute to; precisely control which method family it belongs to. If a method in an; ``@implementation`` does not have this attribute, but there is a method; declared in the corresponding ``@interface`` that does, then the attribute is; copied to the declaration in the ``@implementation``. The attribute is; available outside of ARC, and may be tested for with the preprocessor query; ``__has_attribute(objc_method_family)``. The attribute is spelled; ``__attribute__((objc_method_family(`` *family* ``)))``. If *family* is; ``none``, the method has no family, even if it would otherwise be considered to; have one based on its selector and type. Otherwise, *family* must be one of; ``alloc``, ``copy``, ``init``, ``mutableCopy``, or ``new``, in which case the; method is considered to belong to the corresponding family regardless of its; selector. It is an error if a method that is explicitly added to a family in; this way does not meet the requirements of the family other than the selector; naming convention. .. admonition:: Rationale. The rules codified in this document describe the standard conventions of; Objective-C. However, as these conventions have not heretofore been enforced; by an unforgiving mechanical system, they are only imperfectly kept,; especially as they haven't always even been precisely defined. While it is; possible to defi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:70516,test,tested,70516,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['test'],['tested']
Testability," length, &outData);. SecKeychainItemFreeContent(ptr, outData);; // warn: only call free if a non-NULL buffer was returned; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);. st = SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);; // warn: release data before another call to the allocator. if (st == noErr); SecKeychainItemFreeContent(ptr, outData);; }. void test() {; SecKeychainItemRef itemRef = 0;; SecKeychainAttributeInfo *info = 0;; SecItemClass *itemClass = 0;; SecKeychainAttributeList *attrList = 0;; UInt32 *length = 0;; void *outData = 0;. OSStatus st =; SecKeychainItemCopyAttributesAndData(itemRef, info,; itemClass, &attrList,; length, &outData);. SecKeychainItemFreeContent(attrList, outData);; // warn: deallocator doesn't match the allocator; }. osx.cocoa.AtSync; (ObjC); Check for nil pointers used as mutexes for @synchronized. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. osx.cocoa.ClassRelease; (ObjC); Check for sending retain, release, or ; autorelease directly to a class. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. osx.cocoa.Dealloc; (ObjC); Warn about Objective-C classes that lack a correct implementation; of -dealloc. @interface MyObject : NSObject {; id _myproperty;; }; @end. @implementation MyObject // warn: lacks 'dealloc'; @end. @interface MyObject : NSObject {}; @property(assign) id myproperty;; @end. @implementation MyObject // warn: does not send 'dealloc' to super; - (void)dealloc {; self.myproperty = 0;; }; @end. @interface MyObject : NSObject {; id _myproperty;; }; @property(retain) id myproperty;; @end. @implementation MyObject; @synthesize myproperty = _myproperty;; // warn: var was retained but wasn't released; - (void)dealloc {; [super dealloc];; }; @end. @interf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:14698,test,test,14698,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability, libc/src/__support/OSUtil/linux/io.h; libc/src/__support/OSUtil/linux/syscall.h; libc/src/__support/OSUtil/linux/aarch64/syscall.h; libc/src/__support/OSUtil/linux/x86_64/syscall.h; libc/src/__support/threads/mutex.h; libc/src/__support/threads/linux/mutex.h; libc/utils/HdrGen/Command.cpp; libc/utils/HdrGen/Command.h; libc/utils/HdrGen/Generator.cpp; libc/utils/HdrGen/Generator.h; libc/utils/HdrGen/IncludeFileCommand.cpp; libc/utils/HdrGen/IncludeFileCommand.h; libc/utils/HdrGen/Main.cpp; libc/utils/HdrGen/PublicAPICommand.cpp; libc/utils/HdrGen/PublicAPICommand.h; libc/utils/HdrGen/PrototypeTestGen/PrototypeTestGen.cpp; libc/utils/LibcTableGenUtil/APIIndexer.cpp; libc/utils/LibcTableGenUtil/APIIndexer.h; libc/utils/MPFRWrapper/check_mpfr.cpp; libc/utils/MPFRWrapper/MPFRUtils.cpp; libc/utils/MPFRWrapper/MPFRUtils.h; libc/utils/testutils/ExecuteFunction.h; libc/utils/testutils/ExecuteFunctionUnix.cpp; libc/utils/testutils/FDReader.h; libc/utils/testutils/FDReaderUnix.cpp; libc/utils/testutils/RandUtils.cpp; libc/utils/testutils/RandUtils.h; libc/utils/testutils/StreamWrapper.h; libc/utils/testutils/Timer.cpp; libc/utils/testutils/Timer.h; libc/utils/tools/WrapperGen/Main.cpp; libc/utils/UnitTest/FPExceptMatcher.cpp; libc/utils/UnitTest/FPExceptMatcher.h; libc/utils/UnitTest/FPMatcher.cpp; libc/utils/UnitTest/FPMatcher.h; libc/utils/UnitTest/FuchsiaTest.h; libc/utils/UnitTest/LibcTest.cpp; libc/utils/UnitTest/LibcTestMain.cpp; libc/utils/UnitTest/MemoryMatcher.cpp; libc/utils/UnitTest/MemoryMatcher.h; libc/utils/UnitTest/PlatformDefs.h; libc/utils/UnitTest/Test.h; libclc/generic/include/config.h; libclc/generic/include/clc/as_type.h; libclc/generic/include/clc/clcfunc.h; libclc/generic/include/clc/async/async_work_group_copy.h; libclc/generic/include/clc/async/async_work_group_strided_copy.h; libclc/generic/include/clc/async/prefetch.h; libclc/generic/include/clc/async/wait_group_events.h; libclc/generic/include/clc/atomic/atomic_add.h; libclc/generic/include/clc/ato,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:148961,test,testutils,148961,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['test'],['testutils']
Testability, libc/src/__support/OSUtil/syscall.h; libc/src/__support/OSUtil/linux/io.h; libc/src/__support/OSUtil/linux/syscall.h; libc/src/__support/OSUtil/linux/aarch64/syscall.h; libc/src/__support/OSUtil/linux/x86_64/syscall.h; libc/src/__support/threads/mutex.h; libc/src/__support/threads/linux/mutex.h; libc/utils/HdrGen/Command.cpp; libc/utils/HdrGen/Command.h; libc/utils/HdrGen/Generator.cpp; libc/utils/HdrGen/Generator.h; libc/utils/HdrGen/IncludeFileCommand.cpp; libc/utils/HdrGen/IncludeFileCommand.h; libc/utils/HdrGen/Main.cpp; libc/utils/HdrGen/PublicAPICommand.cpp; libc/utils/HdrGen/PublicAPICommand.h; libc/utils/HdrGen/PrototypeTestGen/PrototypeTestGen.cpp; libc/utils/LibcTableGenUtil/APIIndexer.cpp; libc/utils/LibcTableGenUtil/APIIndexer.h; libc/utils/MPFRWrapper/check_mpfr.cpp; libc/utils/MPFRWrapper/MPFRUtils.cpp; libc/utils/MPFRWrapper/MPFRUtils.h; libc/utils/testutils/ExecuteFunction.h; libc/utils/testutils/ExecuteFunctionUnix.cpp; libc/utils/testutils/FDReader.h; libc/utils/testutils/FDReaderUnix.cpp; libc/utils/testutils/RandUtils.cpp; libc/utils/testutils/RandUtils.h; libc/utils/testutils/StreamWrapper.h; libc/utils/testutils/Timer.cpp; libc/utils/testutils/Timer.h; libc/utils/tools/WrapperGen/Main.cpp; libc/utils/UnitTest/FPExceptMatcher.cpp; libc/utils/UnitTest/FPExceptMatcher.h; libc/utils/UnitTest/FPMatcher.cpp; libc/utils/UnitTest/FPMatcher.h; libc/utils/UnitTest/FuchsiaTest.h; libc/utils/UnitTest/LibcTest.cpp; libc/utils/UnitTest/LibcTestMain.cpp; libc/utils/UnitTest/MemoryMatcher.cpp; libc/utils/UnitTest/MemoryMatcher.h; libc/utils/UnitTest/PlatformDefs.h; libc/utils/UnitTest/Test.h; libclc/generic/include/config.h; libclc/generic/include/clc/as_type.h; libclc/generic/include/clc/clcfunc.h; libclc/generic/include/clc/async/async_work_group_copy.h; libclc/generic/include/clc/async/async_work_group_strided_copy.h; libclc/generic/include/clc/async/prefetch.h; libclc/generic/include/clc/async/wait_group_events.h; libclc/generic/include/clc/atomic/atomic_a,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:148922,test,testutils,148922,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['test'],['testutils']
Testability, libclc/generic/include/clc/workitem/get_work_dim.h; libclc/generic/include/integer/popcount.h; libclc/generic/include/math/clc_exp10.h; libclc/generic/include/math/clc_fma.h; libclc/generic/include/math/clc_fmod.h; libclc/generic/include/math/clc_hypot.h; libclc/generic/include/math/clc_ldexp.h; libclc/generic/include/math/clc_nextafter.h; libclc/generic/include/math/clc_pow.h; libclc/generic/include/math/clc_pown.h; libclc/generic/include/math/clc_powr.h; libclc/generic/include/math/clc_remainder.h; libclc/generic/include/math/clc_remquo.h; libclc/generic/include/math/clc_rootn.h; libclc/generic/include/math/clc_sqrt.h; libclc/generic/include/math/clc_tan.h; libclc/generic/include/math/clc_tanpi.h; libclc/generic/lib/math/ep_log.h; libcxx/benchmarks/format.bench.cpp; libcxx/benchmarks/formatted_size.bench.cpp; libcxx/benchmarks/formatter_float.bench.cpp; libcxx/benchmarks/format_to.bench.cpp; libcxx/benchmarks/format_to_n.bench.cpp; libcxx/benchmarks/to_chars.bench.cpp; libcxx/benchmarks/util_smartptr.bench.cpp; libcxx/benchmarks/variant_visit_1.bench.cpp; libcxx/benchmarks/variant_visit_2.bench.cpp; libcxx/benchmarks/variant_visit_3.bench.cpp; libcxx/include/__algorithm/adjacent_find.h; libcxx/include/__algorithm/all_of.h; libcxx/include/__algorithm/any_of.h; libcxx/include/__algorithm/count.h; libcxx/include/__algorithm/count_if.h; libcxx/include/__algorithm/find.h; libcxx/include/__algorithm/find_first_of.h; libcxx/include/__algorithm/find_if.h; libcxx/include/__algorithm/find_if_not.h; libcxx/include/__algorithm/for_each.h; libcxx/include/__algorithm/for_each_n.h; libcxx/include/__algorithm/iter_swap.h; libcxx/include/__algorithm/mismatch.h; libcxx/include/__algorithm/none_of.h; libcxx/include/__algorithm/swap_ranges.h; libcxx/include/__compare/is_eq.h; libcxx/include/__filesystem/file_time_type.h; libcxx/include/__filesystem/file_type.h; libcxx/include/__filesystem/space_info.h; libcxx/include/__format/formatter_floating_point.h; libcxx/include/__format/format,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:159672,benchmark,benchmarks,159672,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['benchmark'],['benchmarks']
Testability," liberal use of assert and ``llvm::Error``. Do *not* assume that the input; object is well formed: Return any errors produced by libObject (or your own; object parsing code) and validate as you construct. Think carefully about the; distinction between contract (which should be validated with asserts and; llvm_unreachable) and environmental errors (which should generate; ``llvm::Error`` instances). #. Don't assume you're linking in-process. Use libSupport's sized,; endian-specific types when reading/writing content in the ``LinkGraph``. As a ""minimum viable"" JITLink wrapper, the ``llvm-jitlink`` tool is an; invaluable resource for developers bringing in a new JITLink backend. A standard; workflow is to start by throwing an unsupported object at the tool and seeing; what error is returned, then fixing that (you can often make a reasonable guess; at what should be done based on existing code for other formats or; architectures). In debug builds of LLVM, the ``-debug-only=jitlink`` option dumps logs from the; JITLink library during the link process. These can be useful for spotting some bugs at; a glance. The ``-debug-only=llvm_jitlink`` option dumps logs from the ``llvm-jitlink``; tool, which can be useful for debugging both testcases (it is often less verbose than; ``-debug-only=jitlink``) and the tool itself. The ``-oop-executor`` and ``-oop-executor-connect`` options are helpful for testing; handling of cross-process and cross-architecture use cases. Roadmap; =======. JITLink is under active development. Work so far has focused on the MachO; implementation. In LLVM 12 there is limited support for ELF on x86-64. Major outstanding projects include:. * Refactor architecture support to maximize sharing across formats. All formats should be able to share the bulk of the architecture specific; code (especially relocations) for each supported architecture. * Refactor ELF link graph construction. ELF's link graph construction is currently implemented in the `ELF_x86_64.cpp`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:43935,log,logs,43935,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['log'],['logs']
Testability," line or in; the embedded LLVM IR module. Simplifying MIR files; ^^^^^^^^^^^^^^^^^^^^^. The MIR code coming out of ``-stop-after``/``-stop-before`` is very verbose;; Tests are more accessible and future proof when simplified:. - Use the ``-simplify-mir`` option with llc. - Machine function attributes often have default values or the test works just; as well with default values. Typical candidates for this are: `alignment:`,; `exposesReturnsTwice`, `legalized`, `regBankSelected`, `selected`.; The whole `frameInfo` section is often unnecessary if there is no special; frame usage in the function. `tracksRegLiveness` on the other hand is often; necessary for some passes that care about block livein lists. - The (global) `liveins:` list is typically only interesting for early; instruction selection passes and can be removed when testing later passes.; The per-block `liveins:` on the other hand are necessary if; `tracksRegLiveness` is true. - Branch probability data in block `successors:` lists can be dropped if the; test doesn't depend on it. Example:; `successors: %bb.1(0x40000000), %bb.2(0x40000000)` can be replaced with; `successors: %bb.1, %bb.2`. - MIR code contains a whole IR module. This is necessary because there are; no equivalents in MIR for global variables, references to external functions,; function attributes, metadata, debug info. Instead some MIR data references; the IR constructs. You can often remove them if the test doesn't depend on; them. - Alias Analysis is performed on IR values. These are referenced by memory; operands in MIR. Example: `:: (load 8 from %ir.foobar, !alias.scope !9)`.; If the test doesn't depend on (good) alias analysis the references can be; dropped: `:: (load 8)`. - MIR blocks can reference IR blocks for debug printing, profile information; or debug locations. Example: `bb.42.myblock` in MIR references the IR block; `myblock`. It is usually possible to drop the `.myblock` reference and simply; use `bb.42`. - If there are no memory ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:3949,test,test,3949,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['test'],['test']
Testability, lldb/unittests/ScriptInterpreter/Python/PythonTestSuite.h; lldb/unittests/Signals/UnixSignalsTest.cpp; lldb/unittests/Symbol/LocateSymbolFileTest.cpp; lldb/unittests/Symbol/MangledTest.cpp; lldb/unittests/Symbol/SymbolTest.cpp; lldb/unittests/Symbol/SymtabTest.cpp; lldb/unittests/Symbol/TestClangASTImporter.cpp; lldb/unittests/Symbol/TestDWARFCallFrameInfo.cpp; lldb/unittests/Symbol/TestTypeSystem.cpp; lldb/unittests/SymbolFile/DWARF/DWARFASTParserClangTests.cpp; lldb/unittests/SymbolFile/DWARF/DWARFDIETest.cpp; lldb/unittests/SymbolFile/DWARF/DWARFIndexCachingTest.cpp; lldb/unittests/SymbolFile/DWARF/DWARFUnitTest.cpp; lldb/unittests/SymbolFile/DWARF/Inputs/test-dwarf.cpp; lldb/unittests/SymbolFile/NativePDB/PdbFPOProgramToDWARFExpressionTests.cpp; lldb/unittests/SymbolFile/PDB/Inputs/test-pdb-alt.cpp; lldb/unittests/SymbolFile/PDB/Inputs/test-pdb-nested.h; lldb/unittests/SymbolFile/PDB/Inputs/test-pdb-types.cpp; lldb/unittests/SymbolFile/PDB/Inputs/test-pdb.cpp; lldb/unittests/SymbolFile/PDB/Inputs/test-pdb.h; lldb/unittests/Target/DynamicRegisterInfoTest.cpp; lldb/unittests/Target/ExecutionContextTest.cpp; lldb/unittests/Target/FindFileTest.cpp; lldb/unittests/Target/MemoryTagMapTest.cpp; lldb/unittests/Target/RemoteAwarePlatformTest.cpp; lldb/unittests/Target/StackFrameRecognizerTest.cpp; lldb/unittests/TestingSupport/MockTildeExpressionResolver.cpp; lldb/unittests/TestingSupport/MockTildeExpressionResolver.h; lldb/unittests/TestingSupport/SubsystemRAII.h; lldb/unittests/TestingSupport/TestUtilities.cpp; lldb/unittests/TestingSupport/Host/NativeProcessTestUtils.h; lldb/unittests/TestingSupport/Symbol/ClangTestUtils.h; lldb/unittests/TestingSupport/Symbol/YAMLModuleTester.cpp; lldb/unittests/TestingSupport/Symbol/YAMLModuleTester.h; lldb/unittests/Thread/ThreadTest.cpp; lldb/unittests/UnwindAssembly/PPC64/TestPPC64InstEmulation.cpp; lldb/unittests/Utility/AnsiTerminalTest.cpp; lldb/unittests/Utility/ArgsTest.cpp; lldb/unittests/Utility/BroadcasterTest.cpp; lldb/u,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:231953,test,test-pdb,231953,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['test'],['test-pdb']
Testability," llvm. If CMake can locate the code coverage; scripts and the llvm-cov and llvm-profdata tools that pair to your compiler,; the build will also generate the `generate-coverage-report` target to generate; the code coverage report for LLVM, and the `clear-profile-data` utility target; to delete captured profile data. See documentation for; *LLVM_CODE_COVERAGE_TARGETS* and *LLVM_COVERAGE_SOURCE_DIRS* for more; information on configuring code coverage reports. **LLVM_CODE_COVERAGE_TARGETS**:STRING; If set to a semicolon separated list of targets, those targets will be used; to drive the code coverage reports. If unset, the target list will be; constructed using the LLVM build's CMake export list. **LLVM_COVERAGE_SOURCE_DIRS**:STRING; If set to a semicolon separated list of directories, the coverage reports; will limit code coverage summaries to just the listed directories. If unset,; coverage reports will include all sources identified by the tooling. **LLVM_INDIVIDUAL_TEST_COVERAGE**:BOOL; Enable individual test case coverage. When set to ON, code coverage data for; each test case will be generated and stored in a separate directory under the; config.test_exec_root path. This feature allows code coverage analysis of each; individual test case. Defaults to OFF. **LLVM_BUILD_LLVM_DYLIB**:BOOL; If enabled, the target for building the libLLVM shared library is added.; This library contains all of LLVM's components in a single shared library.; Defaults to OFF. This cannot be used in conjunction with BUILD_SHARED_LIBS.; Tools will only be linked to the libLLVM shared library if LLVM_LINK_LLVM_DYLIB; is also ON.; The components in the library can be customised by setting LLVM_DYLIB_COMPONENTS; to a list of the desired components.; This option is not available on Windows. **LLVM_BUILD_TESTS**:BOOL; Include LLVM unit tests in the 'all' build target. Defaults to OFF. Targets; for building each unit test are generated in any case. You can build a; specific unit test using the tar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:15884,test,test,15884,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['test'],['test']
Testability," local git branch. This lets us work on other; things while the change is being reviewed. Changes should have a; description, to explain to reviewers and future readers of the code why; the change was made. .. code:: console. $ git checkout -b myfirstpatch; $ git commit -am ""[Diagnostic] Clarify -Winfinite-recursion message"". Now we're ready to send this change out into the world! By the way,; There is an unwritten convention of using tag for your commit. Tags; usually represent modules that you intend to modify. If you don't know; the tags for your modules, you can look at the commit history :; https://github.com/llvm/llvm-project/commits/main. Code review; ===========. Finding a reviewer; ------------------. Changes can be reviewed by anyone in the LLVM community who has commit; access.For larger and more complicated changes, it's important that the; reviewer has experience with the area of LLVM and knows the design goals; well. The author of a change will often assign a specific reviewer (git; blame and git log can be useful to find one). As our change is fairly simple, we'll add the cfe-commits mailing list; as a subscriber; anyone who works on clang can likely pick up the; review. (For changes outside clang, llvm-commits is the usual list. See; `http://lists.llvm.org/ <http://lists.llvm.org/mailman/listinfo>`__ for; all the \*-commits mailing lists). Uploading a change for review; -----------------------------. LLVM code reviews happen through pull-request on GitHub, see; :ref:`GitHub <github-reviews>` documentation for how to open; a pull-request on GitHub. Review process; --------------. When you open a pull-request, some automation will add a comment and; notify different member of the projects depending on the component you; changed.; Within a few days, someone should start the review. They may add; themselves as a reviewer, or simply start leaving comments. You'll get; another email any time the review is updated. The details are in the; `https://llvm.org/d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:9255,log,log,9255,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['log'],['log']
Testability," logs named; similarly to the basic log implementation, but will have a different log; format. All the trace analysis tools (and the trace reading library) will; support all versions of the FDR mode format as we add more functionality and; record types in the future. **NOTE:** We do not promise perpetual support for when we update the log; versions we support going forward. Deprecation of the formats will be; announced and discussed on the developers mailing list. Trace Analysis Tools; --------------------. We currently have the beginnings of a trace analysis tool in LLVM, which can be; found in the ``tools/llvm-xray`` directory. The ``llvm-xray`` tool currently; supports the following subcommands:. - ``extract``: Extract the instrumentation map from a binary, and return it as; YAML.; - ``account``: Performs basic function call accounting statistics with various; options for sorting, and output formats (supports CSV, YAML, and; console-friendly TEXT).; - ``convert``: Converts an XRay log file from one format to another. We can; convert from binary XRay traces (both basic and FDR mode) to YAML,; `flame-graph <https://github.com/brendangregg/FlameGraph>`_ friendly text; formats, as well as `Chrome Trace Viewer (catapult); <https://github.com/catapult-project/catapult>` formats.; - ``graph``: Generates a DOT graph of the function call relationships between; functions found in an XRay trace.; - ``stack``: Reconstructs function call stacks from a timeline of function; calls in an XRay trace. These subcommands use various library components found as part of the XRay; libraries, distributed with the LLVM distribution. These are:. - ``llvm/XRay/Trace.h`` : A trace reading library for conveniently loading; an XRay trace of supported forms, into a convenient in-memory representation.; All the analysis tools that deal with traces use this implementation.; - ``llvm/XRay/Graph.h`` : A semi-generic graph type used by the graph; subcommand to conveniently represent a function call",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst:11634,log,log,11634,interpreter/llvm-project/llvm/docs/XRay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst,1,['log'],['log']
Testability," long unless there are critical issues remaining. In most cases, the only; kind of bugs that are critical enough to block a release would be a major regression; from a previous release. Official Testing; ----------------. A few developers in the community have dedicated time to validate the release; candidates and volunteered to be the official release testers for each; architecture. These will be the ones testing, generating and uploading the official binaries; to the server, and will be the minimum tests *necessary* for the release to; proceed. This will obviously not cover all OSs and distributions, so additional community; validation is important. However, if community input is not reached before the; release is out, all bugs reported will have to go on the next stable release. The official release managers are:. * Even releases: Tom Stellard (tstellar@redhat.com); * Odd releases: Tobias Hieta (tobias@hieta.se). The official release testers are volunteered from the community and have; consistently validated and released binaries for their targets/OSs. To contact; them, you should post on the `Discourse forums (Project; Infrastructure - Release Testers). <https://discourse.llvm.org/c/infrastructure/release-testers/66>`_. The official testers list is in the file ``RELEASE_TESTERS.TXT``, in the ``LLVM``; repository. Community Testing; -----------------. Once all testing has been completed and appropriate bugs filed, the release; candidate tarballs are put on the website and the LLVM community is notified. We ask that all LLVM developers test the release in any the following ways:. #. Download ``llvm-X.Y``, ``llvm-test-X.Y``, and the appropriate ``clang``; binary. Build LLVM. Run ``make check`` and the full LLVM test suite (``make; TEST=nightly report``). #. Download ``llvm-X.Y``, ``llvm-test-X.Y``, and the ``clang`` sources. Compile; everything. Run ``make check`` and the full LLVM test suite (``make; TEST=nightly report``). #. Download ``llvm-X.Y``, ``llvm-test-X.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:7543,test,testers,7543,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['test'],['testers']
Testability," loop/cond-expression of; the for statement. Did you mean; 'proper_variable_name'?. void test() {; int i = 0;; int j = 0;; for (i = 0; i < 3; j += 1); // warn; }. void test() {; int i = 0;; int j = 0;; for (int j = 0; i < 3; ++j); // warn; }. different.FloatingCompare; (C); Comparing floating point numbers may be not precise. #include <math.h>. double test() {; double b = sin(M_PI / 6.0);; if (b == 0.5) // warn; b = 0;; return b;; }. different.BitwiseOpBoolArg; (C, C++); Boolean value met at the left/right part of the bitwise &; or | operator.; Did you mean && (||) ?. int f();. void test() {; bool b = true;; if (b & f()) {} // warn; }. different.LabelInsideSwitch; (C); Possibly a misprint: label found inside a switch(); statement. void test(int c) {; switch(c){; case 1:; c += 1; break;; defalt: // warn (did you mean 'default'?); c -= 1; break;; }; }. different.IdenticalCondIfIf; (C); The conditions of two subsequent if statements are; identical. int test(int c) {; if (c > 5); c += 1;; if (c > 5) // warn; c -= 1;; return c;; }. different.LogicalOpUselessArg; (C); The second operand of a && operator has no impact on; expression result. void test(unsigned a) {; if (a<7 && a<10) {}; // warn; }. different.SameResLogicalExpr; (C); An expression is always evaluated to true/false. void test() {; int i = 0;; if (i != 0) {}; // warn; }. void test(int i) {; if (i == 0 && i == 1) {}; // warn; }. void test(int i) {; if (i < 0 || i >= 0) {}; // warn; }. different.OpPrecedenceAssignCmp; (C, C++); Comparison operation has higher precedence then assignment. Boolean value is; assigned to a variable of other type. Parenthesis may bee required around an; assignment. int f();. void test(int x, int y) {; bool b;; if((b = x != y)) {} // ok; if((x = f() != y)) {} // warn; }. different.OpPrecedenceIifShift; (C, C++); ?: has lower precedence then <<.; Source: Stephen C. Dewhurst ""C++ Gotchas: Avoiding Common Problems in Coding; and Design"", advise 15. #include <iostream>. void test(int a) {; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:22276,test,test,22276,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability," major new extension, it is a good; idea to get consensus with the development community before you start working on; it. Once the design of the new feature is finalized, the work itself should be done; as a series of `incremental changes`_, not as a long-term development branch. .. _incremental changes:. Incremental Development; -----------------------. In the LLVM project, we do all significant changes as a series of incremental; patches. We have a strong dislike for huge changes or long-term development; branches. Long-term development branches have a number of drawbacks:. #. Branches must have mainline merged into them periodically. If the branch; development and mainline development occur in the same pieces of code,; resolving merge conflicts can take a lot of time. #. Other people in the community tend to ignore work on branches. #. Huge changes (produced when a branch is merged back onto mainline) are; extremely difficult to `code review`_. #. Branches are not routinely tested by our nightly tester infrastructure. #. Changes developed as monolithic large changes often don't work until the; entire set of changes is done. Breaking it down into a set of smaller; changes increases the odds that any of the work will be committed to the main; repository. To address these problems, LLVM uses an incremental development style and we; require contributors to follow this practice when making a large/invasive; change. Some tips:. * Large/invasive changes usually have a number of secondary changes that are; required before the big change can be made (e.g. API cleanup, etc). These; sorts of changes can often be done before the major change is done,; independently of that work. * The remaining inter-related work should be decomposed into unrelated sets of; changes if possible. Once this is done, define the first increment and get; consensus on what the end goal of the change is. * Each change in the set can be stand alone (e.g. to fix a bug), or part of a; planned series of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:27665,test,tested,27665,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,2,['test'],"['tested', 'tester']"
Testability," man page <CommandGuide/lit>`. Debugging Information tests; ---------------------------. To run debugging information tests simply add the ``cross-project-tests``; project to your ``LLVM_ENABLE_PROJECTS`` define on the cmake; command-line. Regression test structure; =========================. The LLVM regression tests are driven by :program:`lit` and are located in the; ``llvm/test`` directory. This directory contains a large array of small tests that exercise; various features of LLVM and to ensure that regressions do not occur.; The directory is broken into several sub-directories, each focused on a; particular area of LLVM. Writing new regression tests; ----------------------------. The regression test structure is very simple, but does require some; information to be set. This information is gathered via ``cmake``; and is written to a file, ``test/lit.site.cfg.py`` in the build directory.; The ``llvm/test`` Makefile does this work for you. In order for the regression tests to work, each directory of tests must; have a ``lit.local.cfg`` file. :program:`lit` looks for this file to determine; how to run the tests. This file is just Python code and thus is very; flexible, but we've standardized it for the LLVM regression tests. If; you're adding a directory of tests, just copy ``lit.local.cfg`` from; another directory to get running. The standard ``lit.local.cfg`` simply; specifies which files to look in for tests. Any directory that contains; only directories does not need the ``lit.local.cfg`` file. Read the :doc:`Lit; documentation <CommandGuide/lit>` for more information. Each test file must contain lines starting with ""RUN:"" that tell :program:`lit`; how to run it. If there are no RUN lines, :program:`lit` will issue an error; while running a test. RUN lines are specified in the comments of the test program using the; keyword ``RUN`` followed by a colon, and lastly the command (pipeline); to execute. Together, these lines form the ""script"" that :program:`lit`; e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:7650,test,tests,7650,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,2,['test'],['tests']
Testability," management is handled by volumes. These build; additional optimization structures upon geometry closure. In order to; have navigation features properly working one has to follow some rules; for building a valid geometry. - The daughter volume(s) must not extrude the mother shape. They are; allowed however to have a common boundaries.; - The volumes positioned in the same container must not overlap with; each other. They may touch on one boundaries or shape vertex. The daughter nodes of a volume can be also removed or replaced with; other nodes:. ``` {.cpp}; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); ```. The last method allows replacing an existing daughter of a volume with; another one. Providing only the node to be replaced will just create a; new volume for the node but having exactly the same parameters as the; old one. This helps in case of divisions for decoupling a node from the; logical hierarchy so getting new content/properties. For non-divided; volumes, one can change the shape and/or the position of the daughter. #### Virtual Containers and Assemblies of Volumes. Virtual containers are volumes that do not represent real objects, but; they are needed for grouping and positioning together other volumes.; Such grouping helps not only geometry creation, but also optimizes; tracking performance; therefore, it is highly recommended. Virtual; volumes need to inherit material/medium properties from the volume they; are placed into in order to be ""invisible"" at tracking time. Let us suppose that we need to group together two volumes `A` and `B`; into a structure and position this into several other volumes `D,E,` and; `F`. What we need to do is to create a virtual container volume `C`; holding `A` and `B`, then position `C` in the other volumes. Note that `C` is a volume having a determined medium. Since it is not a; real volume, we need to manually set its m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:69459,log,logical,69459,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['log'],['logical']
Testability," matcher would be as follows:. .. code-block:: text. CHECK: Name: foo; CHECK: Value:; CHECK-SAME: {{ 1$}}. This verifies that the *next* time ""``Value:``"" appears in the output, it has; the value ``1``. Note: a ""``CHECK-SAME:``"" cannot be the first directive in a file. The ""CHECK-EMPTY:"" directive; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If you need to check that the next line has nothing on it, not even whitespace,; you can use the ""``CHECK-EMPTY:``"" directive. .. code-block:: llvm. declare void @foo(). declare void @bar(); ; CHECK: foo; ; CHECK-EMPTY:; ; CHECK-NEXT: bar. Just like ""``CHECK-NEXT:``"" the directive will fail if there is more than one; newline before it finds the next blank line, and it cannot be the first; directive in a file. The ""CHECK-NOT:"" directive; ~~~~~~~~~~~~~~~~~~~~~~~~~~. The ""``CHECK-NOT:``"" directive is used to verify that a string doesn't occur; between two matches (or before the first match, or after the last match). For; example, to verify that a load is removed by a transformation, a test like this; can be used:. .. code-block:: llvm. define i8 @coerce_offset0(i32 %V, i32* %P) {; store i32 %V, i32* %P. %P2 = bitcast i32* %P to i8*; %P3 = getelementptr i8* %P2, i32 2. %A = load i8* %P3; ret i8 %A; ; CHECK: @coerce_offset0; ; CHECK-NOT: load; ; CHECK: ret i8; }. The ""CHECK-COUNT:"" directive; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If you need to match multiple lines with the same pattern over and over again; you can repeat a plain ``CHECK:`` as many times as needed. If that looks too; boring you can instead use a counted check ""``CHECK-COUNT-<num>:``"", where; ``<num>`` is a positive decimal number. It will match the pattern exactly; ``<num>`` times, no more and no less. If you specified a custom check prefix,; just use ""``<PREFIX>-COUNT-<num>:``"" for the same effect.; Here is a simple example:. .. code-block:: text. Loop at depth 1; Loop at depth 1; Loop at depth 1; Loop at depth 1; Loop at depth 2; Loop at depth 3. ; CHECK-COUNT-6: Loop at depth {{[0-9]+}",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:16845,test,test,16845,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['test'],['test']
Testability," memory allocated by new[].; C++11: to keep a pointer to memory allocated by new[] in; a shared_ptr one should use a custom deleter that calls ; delete[]..; Source: C++03 20.4.5p1; C++11 auto_ptr is deprecated (D.10). #include <stdlib.h>; #include <memory>. void test() {; std::auto_ptr<int> p1(new int); // Ok; std::auto_ptr<int> p2(new int[3]); // warn; }. #include <stdlib.h>; #include <memory>. void test() {; std::auto_ptr<int> p((int *)malloc(sizeof(int))); // warn; }. dead code. Name, DescriptionExampleProgress. deadcode.UnmodifiedVariable; (C, C++); A variable is never modified but was not declared const and is not a; reference.(opt-in checker). extern int computeDelta();. int test(bool cond) {; int i = 0;; if (cond) {; const int delta = computeDelta();; // warn: forgot to modify 'i'; }; return i;; }. PR16890. deadcode.IdempotentOperations; (C); Warn about idempotent operations. void test() {; int x = 7;; x = x; // warn: value is always the same; }. void test() {; int x = 7;; x /= x; // warn: value is always 1; }. void test() {; int x = 7, one = 1;; x *= one; // warn: right op is always 1; }. void test() {; int x = 7, zero = 0;; x = x - zero;; // warn: the right operand to '-' is always 0; }. removed from alpha.deadcode.* at; r198476. POSIX. Name, DescriptionExampleProgress. posix.Errno; (C); Record that errno is non-zero when certain functions; fail. #include <stdlib.h>. int readWrapper(int fd, int *count) {; int lcount = read(fd, globalBuf, sizeof(globalBuf));; if (lcount < 0); return errno;; *count = lcount;; return 0;; }. void use(int fd) {; int count;; if (!readWrapper(fd, &count)); print(""%d"", count); // should not warn; }. PR18701. undefined behavior. Name, DescriptionExampleProgress. undefbehavior.ExitInDtor; (C++); Undefined behavior: std::exit() is called to end the program during; the destruction of an object with static storage duration.; Source: C++11 3.6.1p4. #include <cstdlib>. class A {; public:; ~A() {; std::exit(1); // warn; }; };. undefbehavio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:4635,test,test,4635,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability," miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to en",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:63539,test,test,63539,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability," mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data as buffer size; }. Unix Alpha Checkers. Name, DescriptionExample. alpha.unix.BlockInCriticalSection; (C); Check for calls to blocking functions inside a critical section. Applies to:. lock; unlock; sleep; getc; fgets; read; revc; pthread_mutex_lock; pthread_mutex_unlock; mtx_lock; mtx_timedlock; mtx_trylock; mtx_unlock; lock_guard; unique_lock. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();; }. alpha.unix.Chroot; (C); Check improper use of chroot. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. alpha.unix.PthreadLock; (C); Simple lock -> unlock checker; applies to:; pthread_mutex_lock; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:12020,test,test,12020,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['test'],['test']
Testability," movl. The above instructions could be:; 	movl $32, -80(%ebp); ...; 	movl $32, -84(%ebp); ...; This seems like a cross between remat and spill folding. This has redundant subtractions of %eax from a stack slot. However, %ecx doesn't; change, so we could simply subtract %eax from %ecx first and then use %ecx (or; vice-versa). //===---------------------------------------------------------------------===//. This code:. 	%tmp659 = icmp slt i16 %tmp654, 0		; <i1> [#uses=1]; 	br i1 %tmp659, label %cond_true662, label %cond_next715. produces this:. 	testw	%cx, %cx; 	movswl	%cx, %esi; 	jns	LBB4_109	# cond_next715. Shark tells us that using %cx in the testw instruction is sub-optimal. It; suggests using the 32-bit register (which is what ICC uses). //===---------------------------------------------------------------------===//. We compile this:. void compare (long long foo) {; if (foo < 4294967297LL); abort();; }. to:. compare:; subl $4, %esp; cmpl $0, 8(%esp); setne %al; movzbw %al, %ax; cmpl $1, 12(%esp); setg %cl; movzbw %cl, %cx; cmove %ax, %cx; testb $1, %cl; jne .LBB1_2 # UnifiedReturnBlock; .LBB1_1: # ifthen; call abort; .LBB1_2: # UnifiedReturnBlock; addl $4, %esp; ret. (also really horrible code on ppc). This is due to the expand code for 64-bit; compares. GCC produces multiple branches, which is much nicer:. compare:; subl $12, %esp; movl 20(%esp), %edx; movl 16(%esp), %eax; decl %edx; jle .L7; .L5:; addl $12, %esp; ret; .p2align 4,,7; .L7:; jl .L4; cmpl $0, %eax; .p2align 4,,8; ja .L5; .L4:; .p2align 4,,9; call abort. //===---------------------------------------------------------------------===//. Tail call optimization improvements: Tail call optimization currently; pushes all arguments on the top of the stack (their normal place for; non-tail call optimized calls) that source from the callers arguments; or that source from a virtual register (also possibly sourcing from; callers arguments).; This is done to prevent overwriting of parameters (see example; below) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:17418,test,testb,17418,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['test'],['testb']
Testability," must agree). If a new patch; does not address all outstanding feedback, the author should explicitly state; that when providing the updated patch. When using the web-based code-review; tool, such notes can be provided in the ""Diff"" description (which is different; from the description of the ""Differential Revision"" as a whole used for the; commit message). If you suggest changes in a code review, but don't wish the suggestion to be; interpreted this strongly, please state so explicitly. Aim to Make Efficient Use of Everyone's Time; --------------------------------------------. Aim to limit the number of iterations in the review process. For example, when; suggesting a change, if you want the author to make a similar set of changes at; other places in the code, please explain the requested set of changes so that; the author can make all of the changes at once. If a patch will require; multiple steps prior to approval (e.g., splitting, refactoring, posting data; from specific performance tests), please explain as many of these up front as; possible. This allows the patch author and reviewers to make the most efficient; use of their time. LGTM - How a Patch Is Accepted; ------------------------------. A patch is approved to be committed when a reviewer accepts it, and this is; almost always associated with a message containing the text ""LGTM"" (which; stands for Looks Good To Me). Only approval from a single reviewer is required. When providing an unqualified LGTM (approval to commit), it is the; responsibility of the reviewer to have reviewed all of the discussion and; feedback from all reviewers ensuring that all feedback has been addressed and; that all other reviewers will almost surely be satisfied with the patch being; approved. If unsure, the reviewer should provide a qualified approval, (e.g.,; ""LGTM, but please wait for @someone, @someone_else""). You may also do this if; you are fairly certain that a particular community member will wish to review,; even if th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:6249,test,tests,6249,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['test'],['tests']
Testability," must take them; into account. Say that ``SpecialSquare`` and ``OtherSpecialSquare`` derive; from ``Square``, and so ``ShapeKind`` becomes:. .. code-block:: c++. enum ShapeKind {; SK_Square,; + SK_SpecialSquare,; + SK_OtherSpecialSquare,; SK_Circle; }. Then in ``Square``, we would need to modify the ``classof`` like so:. .. code-block:: c++. - static bool classof(const Shape *S) {; - return S->getKind() == SK_Square;; - }; + static bool classof(const Shape *S) {; + return S->getKind() >= SK_Square &&; + S->getKind() <= SK_OtherSpecialSquare;; + }. The reason that we need to test a range like this instead of just equality; is that both ``SpecialSquare`` and ``OtherSpecialSquare`` ""is-a""; ``Square``, and so ``classof`` needs to return ``true`` for them. This approach can be made to scale to arbitrarily deep hierarchies. The; trick is that you arrange the enum values so that they correspond to a; preorder traversal of the class hierarchy tree. With that arrangement, all; subclass tests can be done with two comparisons as shown above. If you just; list the class hierarchy like a list of bullet points, you'll get the; ordering right::. | Shape; | Square; | SpecialSquare; | OtherSpecialSquare; | Circle. A Bug to be Aware Of; --------------------. The example just given opens the door to bugs where the ``classof``\s are; not updated to match the ``Kind`` enum when adding (or removing) classes to; (from) the hierarchy. Continuing the example above, suppose we add a ``SomewhatSpecialSquare`` as; a subclass of ``Square``, and update the ``ShapeKind`` enum like so:. .. code-block:: c++. enum ShapeKind {; SK_Square,; SK_SpecialSquare,; SK_OtherSpecialSquare,; + SK_SomewhatSpecialSquare,; SK_Circle; }. Now, suppose that we forget to update ``Square::classof()``, so it still; looks like:. .. code-block:: c++. static bool classof(const Shape *S) {; // BUG: Returns false when S->getKind() == SK_SomewhatSpecialSquare,; // even though SomewhatSpecialSquare ""is a"" Square.; return S->g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst:8690,test,tests,8690,interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSetUpLLVMStyleRTTI.rst,1,['test'],['tests']
Testability," need to feed some distilled form of the contextual information to those; processes. An example of a type identifier is ``sancov``, for dumps from LLVM; `SanitizerCoverage <https://clang.llvm.org/docs/SanitizerCoverage.html>`_. Example::. {{{dumpfile:sancov:sancov.8675}}}. Contextual elements; ===================. These are elements that supply information necessary to convert presentation; elements to symbolic form. Unlike presentation elements, they are not directly; related to the surrounding text. Contextual elements should appear alone on; lines with no other non-whitespace text, so that the symbolizing filter might; elide the whole line from its output without hiding any other log text. The contextual elements themselves do not necessarily need to be presented in; human-readable output. However, the information they impart may be essential to; understanding the logging text even after symbolization. So it's recommended; that this information be preserved in some form when the original raw log with; markup may no longer be readily accessible for whatever reason. Contextual elements should appear in the logging stream before they are needed.; That is, if some piece of context may affect how the symbolizing filter would; interpret or present a later presentation element, the necessary contextual; elements should have appeared somewhere earlier in the logging stream. It should; always be possible for the symbolizing filter to be implemented as a single pass; over the raw logging stream, accumulating context and massaging text as it goes. ``{{{reset}}}``. This should be output before any other contextual element. The need for this; contextual element is to support implementations that handle logs coming from; multiple processes. Such implementations might not know when a new process; starts or ends. Because some identifying information (like process IDs) might; be the same between old and new processes, a way is needed to distinguish two; processes with such identic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:17680,log,log,17680,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['log'],['log']
Testability," new :program:`lit` testing implementation, or extending an existing one. :program:`lit` proper is primarily an infrastructure for discovering and running; arbitrary tests, and to expose a single convenient interface to these; tests. :program:`lit` itself doesn't know how to run tests, rather this logic is; defined by *test suites*. TEST SUITES; ~~~~~~~~~~~. As described in :ref:`test-discovery`, tests are always located inside a *test; suite*. Test suites serve to define the format of the tests they contain, the; logic for finding those tests, and any additional information to run the tests. :program:`lit` identifies test suites as directories containing ``lit.cfg`` or; ``lit.site.cfg`` files (see also :option:`--config-prefix`). Test suites are; initially discovered by recursively searching up the directory hierarchy for; all the input files passed on the command line. You can use; :option:`--show-suites` to display the discovered test suites at startup. Once a test suite is discovered, its config file is loaded. Config files; themselves are Python modules which will be executed. When the config file is; executed, two important global variables are predefined:. **lit_config**. The global **lit** configuration object (a *LitConfig* instance), which defines; the builtin test formats, global configuration parameters, and other helper; routines for implementing test configurations. **config**. This is the config object (a *TestingConfig* instance) for the test suite,; which the config file is expected to populate. The following variables are also; available on the *config* object, some of which must be set by the config and; others are optional or predefined:. **name** *[required]* The name of the test suite, for use in reports and; diagnostics. **test_format** *[required]* The test format object which will be used to; discover and run tests in the test suite. Generally this will be a builtin test; format available from the *lit.formats* module. **test_source_root** T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:14789,test,test,14789,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['test']
Testability," not followed by a lowercase letter and; not preceded by any letter, whether uppercase or lowercase. A second attribute, ``cf_unknown_transfer``, signifies that a function's; transfer semantics cannot be accurately captured using any of these; annotations. A program is ill-formed if it annotates the same function with; both ``cf_audited_transfer`` and ``cf_unknown_transfer``. A pragma is provided to facilitate the mass annotation of interfaces:. .. code-block:: objc. #pragma clang arc_cf_code_audited begin; ...; #pragma clang arc_cf_code_audited end. All C functions declared within the extent of this pragma are treated as if; annotated with the ``cf_audited_transfer`` attribute unless they otherwise have; the ``cf_unknown_transfer`` attribute. The pragma is accepted in all language; modes. A program is ill-formed if it attempts to change files, whether by; including a file or ending the current file, within the extent of this pragma. It is possible to test for all the features in this section with; ``__has_feature(arc_cf_code_audited)``. .. admonition:: Rationale. A significant inconvenience in ARC programming is the necessity of; interacting with APIs based around C retainable pointers. These features are; designed to make it relatively easy for API authors to quickly review and; annotate their interfaces, in turn improving the fidelity of tools such as; the static analyzer and ARC. The single-file restriction on the pragma is; designed to eliminate the risk of accidentally annotating some other header's; interfaces. .. _arc.runtime:. Runtime support; ===============. This section describes the interaction between the ARC runtime and the code; generated by the ARC compiler. This is not part of the ARC language; specification; instead, it is effectively a language-specific ABI supplement,; akin to the ""Itanium"" generic ABI for C++. Ownership qualification does not alter the storage requirements for objects,; except that it is undefined behavior if a ``__weak`` objec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:104623,test,test,104623,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['test'],['test']
Testability," objects.; Otherwise, all results will be contained in a single array. .. code-block:: console. $ llvm-symbolizer --obj=inlined.elf 0x4004be 0x400486 -p; baz() at /tmp/test.cpp:11:18; (inlined by) main at /tmp/test.cpp:15:0. foo() at /tmp/test.cpp:6:3. $ llvm-symbolizer --output-style=LLVM --obj=inlined.elf 0x4004be 0x400486 -p --no-inlines; main at /tmp/test.cpp:11:18. foo() at /tmp/test.cpp:6:3. $ llvm-symbolizer --output-style=GNU --obj=inlined.elf 0x4004be 0x400486 -p --no-inlines; baz() at /tmp/test.cpp:11; foo() at /tmp/test.cpp:6. $ clang -g -fdebug-info-for-profiling test.cpp -o profiling.elf; $ llvm-symbolizer --output-style=GNU --obj=profiling.elf 0x401167 -p --no-inlines; main at /tmp/test.cpp:15 (discriminator 2). $ llvm-symbolizer --output-style=JSON --obj=inlined.elf 0x4004be 0x400486 -p; [; {; ""Address"": ""0x4004be"",; ""ModuleName"": ""inlined.elf"",; ""Symbol"": [; {; ""Column"": 18,; ""Discriminator"": 0,; ""FileName"": ""/tmp/test.cpp"",; ""FunctionName"": ""baz()"",; ""Line"": 11,; ""StartAddress"": ""0x4004be"",; ""StartFileName"": ""/tmp/test.cpp"",; ""StartLine"": 9; },; {; ""Column"": 0,; ""Discriminator"": 0,; ""FileName"": ""/tmp/test.cpp"",; ""FunctionName"": ""main"",; ""Line"": 15,; ""StartAddress"": ""0x4004be"",; ""StartFileName"": ""/tmp/test.cpp"",; ""StartLine"": 14; }; ]; },; {; ""Address"": ""0x400486"",; ""ModuleName"": ""inlined.elf"",; ""Symbol"": [; {; ""Column"": 3,; ""Discriminator"": 0,; ""FileName"": ""/tmp/test.cpp"",; ""FunctionName"": ""foo()"",; ""Line"": 6,; ""StartAddress"": ""0x400486"",; ""StartFileName"": ""/tmp/test.cpp"",; ""StartLine"": 5; }; ]; }; ]. .. option:: --pretty-print, -p. Print human readable output. If :option:`--inlining` is specified, the; enclosing scope is prefixed by (inlined by).; For JSON output, the option will cause JSON to be indented and split over; new lines. Otherwise, the JSON output will be printed in a compact form. .. code-block:: console. $ llvm-symbolizer --obj=inlined.elf 0x4004be --inlining --pretty-print; baz() at /tmp/test.cpp:11:18; (inlined by) main at /tmp/test.c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst:10148,test,test,10148,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,1,['test'],['test']
Testability, of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building TMVA/DNN/CNN tests.; # @author Vladimir Ilievski; ############################################################################. set(Libraries TMVA). #--- CUDA tests. ---------------------------; if (tmva-gpu). list(APPEND Libraries CUDA::cuda_driver CUDA::cudart). set(DNN_CUDA_LIBRARIES ${CUDA_CUBLAS_LIBRARIES} ). add_executable(testIm2ColCuda TestIm2ColCuda.cxx); target_link_libraries(testIm2ColCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-Im2ColCuda COMMAND testIm2ColCuda). add_executable(testPoolingLayerCuda TestPoolingLayerCuda.cxx); target_link_libraries(testPoolingLayerCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-PoolingLayerCuda COMMAND testPoolingLayerCuda). add_executable(testReshapeCuda TestReshapeCuda.cxx); target_link_libraries(testReshapeCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ReshapeCuda COMMAND testReshapeCuda). add_executable(testConvLayerCuda TestConvLayerCuda.cxx); target_link_libraries(testConvLayerCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ConvLayerCuda COMMAND testConvLayerCuda). add_executable(testForwardPassCuda TestForwardPassCuda.cxx); target_link_libraries(testForwardPassCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ForwardCuda COMMAND testForwardPassCuda). add_executable(testRotateWeightsCuda TestRotateWeightsCuda.cxx); target_link_libraries(testRotateWeightsCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-RotateWeightsCuda COMMAND testRotateWeightsCuda). add_executable(testConvBackpropagationCuda TestConvBackpropagationCuda.cxx); target_link_libraries(testConvBackpropagationCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ConvBackpropagationCuda COMMAND testConvBackpropagationCuda). if (tmva-cudnn). add_executable(testFor,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt:1105,test,testReshapeCuda,1105,tmva/tmva/test/DNN/CNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt,2,['test'],['testReshapeCuda']
Testability," of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_y1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:52326,log,logical,52326,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['log'],['logical']
Testability," of itself, whether directly or via other; substitutions, should be avoided. It usually produces an infinitely recursive; definition that cannot be fully expanded. It does *not* define the; substitution in terms of its previous value, even when using ``REDEFINE:``. The relationship between the ``DEFINE:`` and ``REDEFINE:`` directive is; analogous to the relationship between a variable declaration and variable; assignment in many programming languages:. - ``DEFINE: %{name} = value``. This directive assigns the specified value to a new substitution whose; pattern is ``%{name}``, or it reports an error if there is already a; substitution whose pattern contains ``%{name}`` because that could produce; confusing expansions (e.g., a lit configuration file might define a; substitution with the pattern ``%{name}\[0\]``). The new substitution is; inserted at the start of the substitution list so that it will expand first.; Thus, its value can contain any substitution previously defined, whether in; the same test file or in a lit configuration file, and both will expand. - ``REDEFINE: %{name} = value``. This directive assigns the specified value to an existing substitution whose; pattern is ``%{name}``, or it reports an error if there are no substitutions; with that pattern or if there are multiple substitutions whose patterns; contain ``%{name}``. The substitution's current position in the substitution; list does not change so that expansion order relative to other existing; substitutions is preserved. The following properties apply to both the ``DEFINE:`` and ``REDEFINE:``; directives:. - **Substitution name**: In the directive, whitespace immediately before or; after ``%{name}`` is optional and discarded. ``%{name}`` must start with; ``%{``, it must end with ``}``, and the rest must start with a letter or; underscore and contain only alphanumeric characters, hyphens, underscores, and; colons. This syntax has a few advantages:. - It is impossible for ``%{name}`` to contain se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:33085,test,test,33085,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['test']
Testability," of options in a list, it is also possible to gather; information for enum values in a **bit vector**. The representation used by the; `cl::bits`_ class is an ``unsigned`` integer. An enum value is represented by a; 0/1 in the enum's ordinal value bit position. 1 indicating that the enum was; specified, 0 otherwise. As each specified value is parsed, the resulting enum's; bit is set in the option's bit vector:. .. code-block:: c++. bits |= 1 << (unsigned)enum;. Options that are specified multiple times are redundant. Any instances after; the first are discarded. Reworking the above list example, we could replace `cl::list`_ with `cl::bits`_:. .. code-block:: c++. cl::bits<Opts> OptimizationBits(cl::desc(""Available Optimizations:""),; cl::values(; clEnumVal(dce , ""Dead Code Elimination""),; clEnumVal(instsimplify , ""Instruction Simplification""),; clEnumValN(inlining, ""inline"", ""Procedure Integration""),; clEnumVal(strip , ""Strip Symbols"")));. To test to see if ``instsimplify`` was specified, we can use the ``cl:bits::isSet``; function:. .. code-block:: c++. if (OptimizationBits.isSet(instsimplify)) {; ...; }. It's also possible to get the raw bit vector using the ``cl::bits::getBits``; function:. .. code-block:: c++. unsigned bits = OptimizationBits.getBits();. Finally, if external storage is used, then the location specified must be of; **type** ``unsigned``. In all other ways a `cl::bits`_ option is equivalent to a; `cl::list`_ option. .. _additional extra text:. Adding freeform text to help output; -----------------------------------. As our program grows and becomes more mature, we may decide to put summary; information about what it does into the help output. The help output is styled; to look similar to a Unix ``man`` page, providing concise information about a; program. Unix ``man`` pages, however often have a description about what the; program does. To add this to your CommandLine program, simply pass a third; argument to the `cl::ParseCommandLineOptions`_ call",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:22445,test,test,22445,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['test'],['test']
Testability," of this; option. These two options provide a coarse mechanism for partitioning large; testsuites, for parallel execution on separate machines (say in a large; testing farm). .. option:: --order={lexical,random,smart}. Define the order in which tests are run. The supported values are:. - lexical - tests will be run in lexical order according to the test file; path. This option is useful when predictable test order is desired. - random - tests will be run in random order. - smart - tests that failed previously will be run first, then the remaining; tests, all in descending execution time order. This is the default as it; optimizes concurrency. .. option:: --run-shard=N. Select which shard to run, assuming the ``--num-shards=M`` option was; provided. The two options must be used together, and the value of ``N``; must be in the range ``1..M``. The environment variable; ``LIT_RUN_SHARD`` can also be used in place of this option. .. option:: --timeout=N. Spend at most ``N`` seconds (approximately) running each individual test.; ``0`` means no time limit, and ``0`` is the default. Note that this is not an; alias for :option:`--max-time`; the two are different kinds of maximums. .. option:: --filter=REGEXP. Run only those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER`` can be also used in place; of this option, which is especially useful in environments where the call; to ``lit`` is issued indirectly. .. option:: --filter-out=REGEXP. Filter out those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER_OUT`` can be also used in; place of this option, which is especially useful in environments where the; call to ``lit`` is issued indirectly. .. option:: --xfail=LIST. Treat those tests whose name is in the semicolon separated list ``LIST`` as; ``XFAIL``. This can be helpful when one does not want to modify the test; suite. The environment variable ``LI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:7921,test,test,7921,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['test']
Testability," of variable bin histogram, when using the histogram operation methods TH1::Add or TH1::Multiply or TH1::Divide. THistPainter. Round correctly the number of entries displayed in the statistics box to the closest integer value.; New plotting option SURF7. It is similar to SURF3 except; that the surface is plotted with colors and the contours on top with lines. TGraph. Fixed problem in <http://root.cern.ch/phpBB2/viewtopic.php?t=9208>. TGraphErrors. Add a new fitting option ""EX0"", to neglect the error in X when fitting; . TGraph2DErrors. New option ""ERR"" to draw TGraphErrors as error bars.; The following picture has been produced with the option ""ERR P0"". THnSparse. Make a function to generate a THnSparse from a corresponding TH1.; Fixed a problem with the division methods, as well as implement unit tests for them.; Remove some unnecessary parts of the methods Multiply and Divide.; Implement the multiplication proposal in; <http://root.cern.ch/phpBB2/viewtopic.php?t=7692>, as weel; as implemeting unit tests for it.; Add a new method Fit() for fitting a THNSparse. By default the likelihood method is used. For using a least square; method (not really reccomended) if the histogram is really sparse, the option ""X"" must be used. . new classes TFitResult, TFitResultPtr. All the Fit methods of the Hist library instead of returning an integer now return a TFitResultPtr object. The TFitResultPtr is an object that converts automatically to an integer, which represents the status code of the fit. If the Fit method is used as before, there is a no visible change for the user.; When using the fit option ""S"", the TFitResultPtr will now contain a pointer to the new TFitResult class. It will behave as a smart pointer to TFitResult,; by using the -> operator the user can call the TFitResult methods or access directly the TFitResult object, by using the de-reference operator * or; TFitResultPtr::Get().; The TFitResult class derives from the ROOT::Math::FitResult, which contains all the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html:4133,test,tests,4133,hist/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v526/index.html,1,['test'],['tests']
Testability," of; # your remotes here, if you don't remember what points to your; # fork, use git remote -v to see. Usually origin points to your; # fork and upstream to llvm/llvm-project; git push origin my_change. Navigate to the URL printed to the console from the git push command in the last step.; Create a pull request from your branch to llvm::main. ::. # If you get any review comments, come back to the branch and; # adjust them.; git switch my_change; $EDITOR file.cpp. # Commit your changes; git commit file.cpp -m ""Code Review adjustments"". # Format changes; git clang-format HEAD~. # Recommit if any formatting changes; git commit -a --amend. # Re-run tests and make sure nothing broke.; ninja check. # Push your changes to your fork branch, be mindful of; # your remotes here, if you don't remember what points to your; # fork, use git remote -v to see. Usually origin points to your; # fork and upstream to llvm/llvm-project; git push origin my_change. Before merging the PR, it is recommended that you rebase locally and re-run test; checks:. ::. # Add upstream as a remote (if you don't have it already); git remote add upstream https://github.com/llvm/llvm-project.git. # Make sure you have all the latest changes; git fetch upstream && git rebase -i upstream/main. # Make sure tests pass with latest changes and your change; ninja check. # Push the rebased changes to your fork.; git push origin my_change -f. Once your PR is approved, rebased, and tests are passing, click `Squash and; Merge` on your PR in the GitHub web interface. See more in-depth information about how to contribute in the following documentation:. * :doc:`Contributing`; * :doc:`MyFirstTypoFix`. Releases; ========. Backporting Fixes to the Release Branches; -----------------------------------------; You can use special comments on issues to make backport requests for the; release branches. This is done by making a comment containing one of the; following commands on any issue that has been added to one of the ""X.Y.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst:11435,test,test,11435,interpreter/llvm-project/llvm/docs/GitHub.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GitHub.rst,1,['test'],['test']
Testability," ok; }. // C++03, C++11; #include <valarray>. void test(void) {; std::valarray<int> a(0, 1), b(0, 2);; a *= b; // warn; }. // C++03, C++11; #include <valarray>. void test(void) {; std::valarray<int> a(0, 1), b(0, 2);; a = a + b; // warn; }. // C++03, C++11; #include <valarray>. void test(void) {; std::valarray<int> a(0, 1), b(0, 2);; std::valarray<bool> c(false, 1);; c = a == b; // warn; }. undefbehavior.ValarrayZeroLength; (C++); Undefined behavior: calling sum()/min()/; max() methods of a zero length valarray the behavior is; undefined.; Source: C++03 26.3.2.7p2, p3, p4; C++11 26.6.2.8p5, p6,; p7. #include <valarray>. void test(void) {; std::valarray<int> v(0, 0);; v.sum(); // warn; }. undefbehavior.ValarrayBadIndirection; (C++); Undefined behavior: element is specified more than once in an indirection.; Source: C++03 26.3.9.2p2, 26.3.9.3p2; C++11 26.6.9.2p2,; 26.6.9.3p2. #include <valarray>. void test() {; // '1' is specified more then once; size_t addr[] = {0, 1, 1};; std::valarray<size_t>indirect(addr, 3);; std::valarray<int> a(0, 5), b(1, 3);; a[indirect] = b; //warn; }. #include <valarray>. void test() {; // '1' is specified more then once; size_t addr[] = {0, 1, 1};; std::valarray<size_t>indirect(addr, 3);; std::valarray<int> a(0, 5), b(1, 3);; a[indirect] *= b; //warn; }. undefbehavior.IosBaseDestroyedBeforeInit; (C++); Undefined behavior: ios_base object is destroyed before; initialization have taken place. basic_ios::init should be call to; initialize ios_base members.; Source: C++03 27.4.2.7p1, 27.4.4.1p2; C++11 27.5.3.7p1,; 27.5.5.2p2. #include <ios>. using namespace std;; template <class T, class Traits = std::char_traits<T> >; class my_stream1 : public std::basic_ios<T, Traits> {; };. template <class T, class Traits = std::char_traits<T> >; class my_stream2 : public std::basic_ios<T, Traits> {; class my_streambuf; : public std::basic_streambuf<T, Traits> {; };; public:; my_stream2() {; this->init(new my_streambuf);; }; };. void test() {; my_stream1<ch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:17144,test,test,17144,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability," one large repository; (""the monorepo""). It may take a while to download!. .. code:: console. $ git clone https://github.com/llvm/llvm-project.git. This will create a directory ""llvm-project"" with all of the source; code. (Checking out anonymously is OK - pushing commits uses a different; mechanism, as we'll see later.). Configure your workspace; ------------------------. Before we can build the code, we must configure exactly how to build it; by running CMake. CMake combines information from three sources:. - explicit choices you make (is this a debug build?). - settings detected from your system (where are libraries installed?). - project structure (which files are part of 'clang'?). First, create a directory to build in. Usually, this is; llvm-project/build. .. code:: console. $ mkdir llvm-project/build; $ cd llvm-project/build. Now, run CMake:. .. code:: console. $ cmake -G Ninja ../llvm -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=clang. If all goes well, you'll see a lot of ""performing test"" lines, and; finally:. .. code:: console. Configuring done; Generating done; Build files have been written to: /path/llvm-project/build. And you should see a build.ninja file. Let's break down that last command a little:. - **-G Ninja**: we're going to use ninja to build; please create; build.ninja. - **../llvm**: this is the path to the source of the ""main"" LLVM; project. - The two **-D** flags set CMake variables, which override; CMake/project defaults:. - **CMAKE_BUILD_TYPE=Release**: build in optimized mode, which is; (surprisingly) the fastest option. If you want to run under a debugger, you should use the default Debug; (which is totally unoptimized, and will lead to >10x slower test; runs) or RelWithDebInfo which is a halfway point.; **CMAKE_BUILD_TYPE** affects code generation only, assertions are; on by default regardless! **LLVM_ENABLE_ASSERTIONS=Off** disables; them. - **LLVM_ENABLE_PROJECTS=clang**: this lists the LLVM subprojects; you are interested in bui",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:2962,test,test,2962,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['test'],['test']
Testability," one run to the next up to and including the value specified as the limit.; Above the limit value skipping of optimizations can cause a change in the; numbering, but because all optimizations above the limit are skipped this; is not a problem. When an opt-bisect index value refers to an entire invocation of the run; function for a pass, the pass will query whether or not it should be skipped; each time it is invoked and each invocation will be assigned a unique value.; For example, if a FunctionPass is used with a module containing three functions; a different index value will be assigned to the pass for each of the functions; as the pass is run. The pass may be run on two functions but skipped for the; third. If the pass internally performs operations on a smaller IR unit the pass must be; specifically instrumented to enable bisection at this finer level of granularity; (see below for details). Example Usage; =============. .. code-block:: console. $ opt -O2 -o test-opt.bc -opt-bisect-limit=16 test.ll. BISECT: running pass (1) Simplify the CFG on function (g); BISECT: running pass (2) SROA on function (g); BISECT: running pass (3) Early CSE on function (g); BISECT: running pass (4) Infer set function attributes on module (test.ll); BISECT: running pass (5) Interprocedural Sparse Conditional Constant Propagation on module (test.ll); BISECT: running pass (6) Global Variable Optimizer on module (test.ll); BISECT: running pass (7) Promote Memory to Register on function (g); BISECT: running pass (8) Dead Argument Elimination on module (test.ll); BISECT: running pass (9) Combine redundant instructions on function (g); BISECT: running pass (10) Simplify the CFG on function (g); BISECT: running pass (11) Remove unused exception handling info on SCC (<<null function>>); BISECT: running pass (12) Function Integration/Inlining on SCC (<<null function>>); BISECT: running pass (13) Deduce function attributes on SCC (<<null function>>); BISECT: running pass (14) Remove unused exc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst:5191,test,test,5191,interpreter/llvm-project/llvm/docs/OptBisect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst,1,['test'],['test']
Testability," only makes the analyzer more accurate when; finding bugs, but can help others better able to understand your code as well.; It can also help remove certain kinds of analyzer false positives by pruning off; false paths.; In order to exploit assertions, however, the analyzer must understand when it; encounters an ""assertion handler."" Typically assertions are; implemented with a macro, with the macro performing a check for the assertion; condition and, when the check fails, calling an assertion handler. For example, consider the following code; fragment:. void foo(int *p) {; assert(p != NULL);; }. When this code is preprocessed on Mac OS X it expands to the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:20992,assert,assertion,20992,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['assert'],['assertion']
Testability," open [issue](https://github.com/root-project/root/issues), make sure to link it.; This will be done automatically if you add; [closing keywords](https://docs.github.com/en/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue); to the PR description. Once a PR is created, a member of the ROOT team will review it as quickly as possible. If you are familiar with the; ROOT community, it may be beneficial to add a suggested reviewer to the PR in order to get quicker attention.; Please ping people :wave: should you not get timely feedback, for instance with `@root-project/core ping!`. ## Tests. As you contribute code, this code will likely fix an issue or add a feature.; Whatever it is: this requires you to add a new test, or to extend an existing test. Depending on the size and complexity; of this test, it exists either in the `test/` subdirectory of each part of ROOT (see for instance; [`tree/dataframe/test`](https://github.com/root-project/root/tree/master/tree/dataframe/test)), or in; [roottest](https://github.com/root-project/roottest.git). Tests in `test/` subdirectories are unit tests, mostly based on; [Google Test](https://github.com/google/googletest) and easily extended. Tests in; [roottest](https://github.com/root-project/roottest.git) are more involved (e.g., tests requiring custom dictionaries or; data files). When you create a branch in the main ROOT repository (i.e., this repository) and add a test to `roottest`,; make sure to do this under the same branch name (and open a PR for it). Our CI infrastructure automatically picks up the; changes defined in the `roottest` PR based on this branch name, and uses that for testing your PR here. ## Continuous Integration. To prevent bad surprises and make a better first impression, we; strongly encourage new developers to [run the tests](https://root.cern/for_developers/run_the_tests/); _before_ submitting a pull request. ROOT has automated CI tests :cop: that are used for pull requests:; - *Buil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md:5792,test,test,5792,CONTRIBUTING.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md,1,['test'],['test']
Testability," option:: --debug. Run :program:`lit` in debug mode, for debugging configuration issues and; :program:`lit` itself. .. option:: --show-suites. List the discovered test suites and exit. .. option:: --show-tests. List all of the discovered tests and exit. EXIT STATUS; -----------. :program:`lit` will exit with an exit code of 1 if there are any FAIL or XPASS; results. Otherwise, it will exit with the status 0. Other exit codes are used; for non-test related failures (for example a user error or an internal program; error). .. _test-discovery:. TEST DISCOVERY; --------------. The inputs passed to :program:`lit` can be either individual tests, or entire; directories or hierarchies of tests to run. When :program:`lit` starts up, the; first thing it does is convert the inputs into a complete list of tests to run; as part of *test discovery*. In the :program:`lit` model, every test must exist inside some *test suite*.; :program:`lit` resolves the inputs specified on the command line to test suites; by searching upwards from the input path until it finds a :file:`lit.cfg` or; :file:`lit.site.cfg` file. These files serve as both a marker of test suites; and as configuration files which :program:`lit` loads in order to understand; how to find and run the tests inside the test suite. Once :program:`lit` has mapped the inputs into test suites it traverses the; list of inputs adding tests for individual files and recursively searching for; tests in directories. This behavior makes it easy to specify a subset of tests to run, while still; allowing the test suite configuration to control exactly how tests are; interpreted. In addition, :program:`lit` always identifies tests by the test; suite they are in, and their relative path inside the test suite. For; appropriately configured projects, this allows :program:`lit` to provide; convenient and flexible support for out-of-tree builds. .. _test-status-results:. TEST STATUS RESULTS; -------------------. Each test ultimately produces ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:11406,test,test,11406,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['test']
Testability," option:: @<FILE>. Read command-line options from `<FILE>`. If no input file is specified, :program:`llvm-debuginfo-analyzer`; defaults to read `a.out` and return an error when no input file is found. If `-` is used as the input file, :program:`llvm-debuginfo-analyzer`; reads the input from its standard input stream. .. _attributes_:. ATTRIBUTES; ~~~~~~~~~~; The following options enable attributes given for the printed elements.; The attributes are divided in categories based on the type of data being; added, such as: internal offsets in the binary file, location descriptors,; register names, user source filenames, additional element transformations,; toolchain name, binary file format, etc. .. option:: --attribute=<value[,value,...]>. With **value** being one of the options in the following lists. .. code-block:: text. =all: Include all the below attributes.; =extended: Add low-level attributes.; =standard: Add standard high-level attributes. The following attributes describe the most common information for a; logical element. They help to identify the lexical scope level; the; element visibility across modules (global, local); the toolchain name; that produced the binary file. .. code-block:: text. =global: Element referenced across Compile Units.; =format: Object file format name.; =level: Lexical scope level (File=0, Compile Unit=1).; =local: Element referenced only in the Compile Unit.; =producer: Toolchain identification name. The following attributes describe files and directory names from the; user source code, where the elements are declared or defined; functions; with public visibility across modules. These options allow to map the; elements to their user code location, for cross references purposes. .. code-block:: text. =directories: Directories referenced in the debug information.; =filename: Filename where the element is defined.; =files: Files referenced in the debug information.; =pathname: Pathname where the object is defined.; =publics: Function na",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:4961,log,logical,4961,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['log'],['logical']
Testability," or was of a class type with a non-trivial destructor and; the pointer is used as the operand of a delete-expression; The object will be or was of a non-POD class type (C++11: any class type) and; the pointer is used to access a non-static data member or call a; non-static member function of the object; the pointer is implicitly converted to a pointer to a base class; type; the pointer is used as the operand of a static_cast (except; when the conversion is to void*, or to void* and; subsequently to char*, or unsigned char*); the pointer is used as the operand of a dynamic_cast; Source: C++03 3.8p5, p7; C++11 3.8p5, p7. #include <new>. class A {; public:; ~A();; };. class B : public A {};. void test() {; A *a = new A;; new(a) B;; delete a; // warn; }. #include <new>. class A {; public:; ~A();; };. class B {};. void test() {; A *a = new A;; new(a) B;; a->~A();; }. #include <new>. class A {; public:; ~A();; };. class B : public A {};. class C {};. void f(A*);. void test() {; B *b = new B;; new(b) C;; f(b); // warn; }. #include <new>. class A {; public:; ~A();; };. class B : public A {};. class C {};. A* test() {; B *b = new B;; new(b) C;; return static_cast<A*>(b); // warn; }. #include <new>. class A {; public:; ~A();; };. class B : public A {};. class C {};. A* test() {; B *b = new B;; new(b) C;; return dynamic_cast<A*>(b); // warn; }. undefbehavior.ObjLocChanges; (C++); Undefined behavior: the program must ensure that an object occupies the same; storage location when the implicit or explicit destructor call takes place.; Source: C++11 3.8p8. #include <new>. class A {};. class B {; public:; ~B();; };. void test() {; B b;; new (&b) A;; } // warn. #include <new>. class A {};. class B {; public:; ~B();; };. void test() {; B *b = new B;; new (b) A;; delete b; // warn; }. undefbehavior.ExprEvalOrderUndef; (C, C++03); Undefined behavior: a scalar object shall have its stored value modified at; most once by the evaluation of an expression.; Note: most cases are currently han",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:7654,test,test,7654,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability," or; :ref:`vector <t_vector>` of floating-point values. Returns two values; in a struct. The first struct field matches the argument type, and the; second field is an integer or a vector of integer values with the same; number of elements as the argument. Semantics:; """""""""""""""""""". This intrinsic splits a floating point value into a normalized; fractional component and integral exponent. For a non-zero argument, returns the argument multiplied by some power; of two such that the absolute value of the returned value is in the; range [0.5, 1.0), with the same sign as the argument. The second; result is an integer such that the first result raised to the power of; the second result is the input argument. If the argument is a zero, returns a zero with the same sign and a 0; exponent. If the argument is a NaN, a NaN is returned and the returned exponent; is unspecified. If the argument is an infinity, returns an infinity with the same sign; and an unspecified exponent. .. _int_log:. '``llvm.log.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.log`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.log.f32(float %Val); declare double @llvm.log.f64(double %Val); declare x86_fp80 @llvm.log.f80(x86_fp80 %Val); declare fp128 @llvm.log.f128(fp128 %Val); declare ppc_fp128 @llvm.log.ppcf128(ppc_fp128 %Val). Overview:; """""""""""""""""". The '``llvm.log.*``' intrinsics compute the base-e logarithm of the specified; value. Arguments:; """""""""""""""""""". The argument and return value are floating-point numbers of the same type. Semantics:; """""""""""""""""""". Return the same value as a corresponding libm '``log``' function but without; trapping or setting ``errno``. When specified with the fast-math-flag 'afn', the result may be approximated; using a less accurate calculation. .. _int_log10:. '``llvm.log10.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:567533,log,log,567533,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['log'],['log']
Testability," order* will not see ``getc`` defined as a macro. Module Map Language; ===================. .. warning::. The module map language is not currently guaranteed to be stable between major revisions of Clang. The module map language describes the mapping from header files to the; logical structure of modules. To enable support for using a library as; a module, one must write a ``module.modulemap`` file for that library. The; ``module.modulemap`` file is placed alongside the header files themselves,; and is written in the module map language described below. .. note::; For compatibility with previous releases, if a module map file named; ``module.modulemap`` is not found, Clang will also search for a file named; ``module.map``. This behavior is deprecated and we plan to eventually; remove it. As an example, the module map file for the C standard library might look a bit like this:. .. parsed-literal::. module std [system] [extern_c] {; module assert {; textual header ""assert.h""; header ""bits/assert-decls.h""; export *; }. module complex {; header ""complex.h""; export *; }. module ctype {; header ""ctype.h""; export *; }. module errno {; header ""errno.h""; header ""sys/errno.h""; export *; }. module fenv {; header ""fenv.h""; export *; }. // ...more headers follow...; }. Here, the top-level module ``std`` encompasses the whole C standard library. It has a number of submodules containing different parts of the standard library: ``complex`` for complex numbers, ``ctype`` for character types, etc. Each submodule lists one of more headers that provide the contents for that submodule. Finally, the ``export *`` command specifies that anything included by that submodule will be automatically re-exported. Lexical structure; -----------------; Module map files use a simplified form of the C99 lexer, with the same rules for identifiers, tokens, string literals, ``/* */`` and ``//`` comments. The module map language has the following reserved words; all other C identifiers are valid identifi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:28125,assert,assert-decls,28125,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['assert'],['assert-decls']
Testability," other helper; routines for implementing test configurations. **config**. This is the config object (a *TestingConfig* instance) for the test suite,; which the config file is expected to populate. The following variables are also; available on the *config* object, some of which must be set by the config and; others are optional or predefined:. **name** *[required]* The name of the test suite, for use in reports and; diagnostics. **test_format** *[required]* The test format object which will be used to; discover and run tests in the test suite. Generally this will be a builtin test; format available from the *lit.formats* module. **test_source_root** The filesystem path to the test suite root. For out-of-dir; builds this is the directory that will be scanned for tests. **test_exec_root** For out-of-dir builds, the path to the test suite root inside; the object directory. This is where tests will be run and temporary output files; placed. **environment** A dictionary representing the environment to use when executing; tests in the suite. **standalone_tests** When true, mark a directory with tests expected to be run; standalone. Test discovery is disabled for that directory. *lit.suffixes* and; *lit.excludes* must be empty when this variable is true. **suffixes** For **lit** test formats which scan directories for tests, this; variable is a list of suffixes to identify test files. Used by: *ShTest*. **substitutions** For **lit** test formats which substitute variables into a test; script, the list of substitutions to perform. Used by: *ShTest*. **unsupported** Mark an unsupported directory, all tests within it will be; reported as unsupported. Used by: *ShTest*. **parent** The parent configuration, this is the config object for the directory; containing the test suite, or None. **root** The root configuration. This is the top-most :program:`lit` configuration in; the project. **pipefail** Normally a test using a shell pipe fails if any of the commands; on the pipe fail.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:16184,test,tests,16184,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['tests']
Testability," page is geared towards users of the LLVM CMake build. If you're looking for; information about modifying the LLVM CMake build system you may want to see the; :doc:`CMakePrimer` page. It has a basic overview of the CMake language. .. _Quick start:. Quick start; ===========. We use here the command-line, non-interactive CMake interface. #. `Download <http://www.cmake.org/cmake/resources/software.html>`_ and install; CMake. Version 3.20.0 is the minimum required. #. Open a shell. Your development tools must be reachable from this shell; through the PATH environment variable. #. Create a build directory. Building LLVM in the source; directory is not supported. cd to this directory:. .. code-block:: console. $ mkdir mybuilddir; $ cd mybuilddir. #. Execute this command in the shell replacing `path/to/llvm/source/root` with; the path to the root of your LLVM source tree:. .. code-block:: console. $ cmake path/to/llvm/source/root. CMake will detect your development environment, perform a series of tests, and; generate the files required for building LLVM. CMake will use default values; for all build parameters. See the `Options and variables`_ section for; a list of build parameters that you can modify. This can fail if CMake can't detect your toolset, or if it thinks that the; environment is not sane enough. In this case, make sure that the toolset that; you intend to use is the only one reachable from the shell, and that the shell; itself is the correct one for your development environment. CMake will refuse; to build MinGW makefiles if you have a POSIX shell reachable through the PATH; environment variable, for instance. You can force CMake to use a given build; tool; for instructions, see the `Usage`_ section, below. You may; also wish to control which targets LLVM enables, or which LLVM; components are built; see the `Frequently Used LLVM-related; variables`_ below. #. After CMake has finished running, proceed to use IDE project files, or start; the build from the buil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:1935,test,tests,1935,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['test'],['tests']
Testability," performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31280,test,testing,31280,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['test'],['testing']
Testability," places; in the IR. If the MDNode contains multiple constants, the code generator; will use the one that corresponds to the line of the asm that the error; occurs on. .. _metadata:. Metadata; ========. LLVM IR allows metadata to be attached to instructions and global objects in the; program that can convey extra information about the code to the optimizers and; code generator. One example application of metadata is source-level; debug information. There are two metadata primitives: strings and nodes. Metadata does not have a type, and is not a value. If referenced from a; ``call`` instruction, it uses the ``metadata`` type. All metadata are identified in syntax by an exclamation point ('``!``'). .. _metadata-string:. Metadata Nodes and Metadata Strings; -----------------------------------. A metadata string is a string surrounded by double quotes. It can; contain any character by escaping non-printable characters with; ""``\xx``"" where ""``xx``"" is the two digit hex code. For example:; ""``!""test\00""``"". Metadata nodes are represented with notation similar to structure; constants (a comma separated list of elements, surrounded by braces and; preceded by an exclamation point). Metadata nodes can have any values as; their operand. For example:. .. code-block:: llvm. !{ !""test\00"", i32 10}. Metadata nodes that aren't uniqued use the ``distinct`` keyword. For example:. .. code-block:: text. !0 = distinct !{!""test\00"", i32 10}. ``distinct`` nodes are useful when nodes shouldn't be merged based on their; content. They can also occur when transformations cause uniquing collisions; when metadata operands change. A :ref:`named metadata <namedmetadatastructure>` is a collection of; metadata nodes, which can be looked up in the module symbol table. For; example:. .. code-block:: llvm. !foo = !{!4, !3}. Metadata can be used as function arguments. Here the ``llvm.dbg.value``; intrinsic is using three metadata arguments:. .. code-block:: llvm. call void @llvm.dbg.value(metadata !24,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:243327,test,test,243327,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['test'],['test']
Testability," platforms; // but not on 32-bit platforms.; NSUInteger x;; [decoder decodeValueOfObjCType:""I"" at:&x]; // warn; }. Unix Checkers. Name, DescriptionExample. unix.API; (C); Check calls to various UNIX/POSIX functions:; open; pthread_once; calloc; malloc; realloc; alloca. // Currently the check is performed for apple targets only.; void test(const char *path) {; int fd = open(path, O_CREAT);; // warn: call to 'open' requires a third argument when the; // 'O_CREAT' flag is set; }. void f();. void test() {; pthread_once_t pred = {0x30B1BCBA, {0}};; pthread_once(&pred, f);; // warn: call to 'pthread_once' uses the local variable; }. void test() {; void *p = malloc(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = calloc(0, 42); // warn: allocation size of 0 bytes; }. void test() {; void *p = malloc(1);; p = realloc(p, 0); // warn: allocation size of 0 bytes; }. void test() {; void *p = alloca(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = valloc(0); // warn: allocation size of 0 bytes; }. unix.Malloc; (C); Check for memory leaks, double free, and use-after-free and offset problems; involving malloc. void test() {; int *p = malloc(1);; free(p);; free(p); // warn: attempt to free released memory; }. void test() {; int *p = malloc(sizeof(int));; free(p);; *p = 1; // warn: use after free; }. void test() {; int *p = malloc(1);; if (p); return; // warn: memory is never released; }. void test() {; int a[] = { 1 };; free(a); // warn: argument is not allocated by malloc; }. void test() {; int *p = malloc(sizeof(char));; p = p - 1;; free(p); // warn: argument to free() is offset by -4 bytes; }. unix.MallocSizeof; (C); Check for dubious malloc, calloc or; realloc arguments involving sizeof. void test() {; long *p = malloc(sizeof(short));; // warn: result is converted to 'long *', which is; // incompatible with operand type 'short'; free(p);; }. unix.MismatchedDeallocator; (C, C++, ObjC); Check for mismatched deallocators (e.g. passing a point",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:24097,test,test,24097,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability," point values and pointers and references to subobjects.; This feature is still experimental. Accordingly, ``__cpp_nontype_template_args`` was not updated.; However, its support can be tested with ``__has_extension(cxx_generalized_nttp)``. - Clang won't perform ODR checks for decls in the global module fragment any; more to ease the implementation and improve the user's using experience.; This follows the MSVC's behavior. Users interested in testing the more strict; behavior can use the flag '-Xclang -fno-skip-odr-check-in-gmf'.; (`#79240 <https://github.com/llvm/llvm-project/issues/79240>`_). C++23 Feature Support; ^^^^^^^^^^^^^^^^^^^^^; - Implemented `P0847R7: Deducing this <https://wg21.link/P0847R7>`_. Some related core issues were also; implemented (`CWG2553 <https://wg21.link/CWG2553>`_, `CWG2554 <https://wg21.link/CWG2554>`_,; `CWG2653 <https://wg21.link/CWG2653>`_, `CWG2687 <https://wg21.link/CWG2687>`_). Because the; support for this feature is still experimental, the feature test macro ``__cpp_explicit_this_parameter``; was not set in this version.; However, its support can be tested with ``__has_extension(cxx_explicit_this_parameter)``. - Added a separate warning to warn the use of attributes on lambdas as a C++23 extension; in previous language versions: ``-Wc++23-lambda-attributes``. C++2c Feature Support; ^^^^^^^^^^^^^^^^^^^^^. - Implemented `P2169R4: A nice placeholder with no name <https://wg21.link/P2169R4>`_. This allows using ``_``; as a variable name multiple times in the same scope and is supported in all C++ language modes as an extension.; An extension warning is produced when multiple variables are introduced by ``_`` in the same scope.; Unused warnings are no longer produced for variables named ``_``.; Currently, inspecting placeholders variables in a debugger when more than one are declared in the same scope; is not supported. .. code-block:: cpp. struct S {; int _, _; // Was invalid, now OK; };; void func() {; int _, _; // Was invalid, now",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:9921,test,test,9921,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['test'],['test']
Testability," pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.NullDereference; (C, C++, ObjC); Check for dereferences of null pointers. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. core.StackAddressEscape; (C); Check that addresses of stack memory do not escape the function. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. core.UndefinedBinaryOperatorResult; (C); Check for undefined results of binary operators. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. core.VLASize; (C); Check for declarations of VLA of undefined or zero size. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. core.uninitialized.ArraySubscript; (C); Check for uninitialized values used as array subscripts. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. core.uninitialized.Assign; (C); Check for assigning uninitialized values. void test() {; int x;; x |= 1; // warn: left expression is uninitialized; }. core.uninitialized.Branch; (C); Check for uninitialized values used as branch conditions. void test() {; int x;; if (x) // warn; return;; }. core.u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:3724,test,test,3724,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability," policy; document, including license, patent, and coding standards. * The target should have either reasonable documentation on how it; works (ISA, ABI, etc.) or a publicly available simulator/hardware; (either free or cheap enough) - preferably both. This allows; developers to validate assumptions, understand constraints and review code; that can affect the target. In addition, the rules for a back-end to be promoted to **official** are:. * The target must have addressed every other minimum requirement and; have been stable in tree for at least 3 months. This cool down; period is to make sure that the back-end and the target community can; endure continuous upstream development for the foreseeable future. * The target's code must have been completely adapted to this policy; as well as the :doc:`coding standards<CodingStandards>`. Any exceptions that; were made to move into experimental mode must have been fixed **before**; becoming official. * The test coverage needs to be broad and well written (small tests,; well documented). The build target ``check-all`` must pass with the; new target built, and where applicable, the ``test-suite`` must also; pass without errors, in at least one configuration (publicly; demonstrated, for example, via buildbots). * Public buildbots need to be created and actively maintained, unless; the target requires no additional buildbots (ex. ``check-all`` covers; all tests). The more relevant and public the new target's CI infrastructure; is, the more the LLVM community will embrace it. To **continue** as a supported and official target:. * The maintainer(s) must continue following these rules throughout the lifetime; of the target. Continuous violations of aforementioned rules and policies; could lead to complete removal of the target from the code base. * Degradation in support, documentation or test coverage will make the target as; nuisance to other targets and be considered a candidate for deprecation and; ultimately removed. In essen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:41759,test,test,41759,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,2,['test'],"['test', 'tests']"
Testability," positions of 2D peaks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate x positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 2D peaks, output parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 2D peaks (not fit). However, they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate x positions of 1D ridges (not fit). However, they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D pea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:51361,log,logical,51361,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['log'],['logical']
Testability," prefixed; with '[C++4OpenCL]' - click `here; <https://github.com/llvm/llvm-project/issues?q=is%3Aissue+is%3Aopen+%5BC%2B%2B4OpenCL%5D>`__; to view the full bug list. Missing features or with limited support; ----------------------------------------. - Support of C++ for OpenCL 2021 is currently in experimental phase. Refer to; :ref:`OpenCL 3.0 status <opencl_300>` for details of common missing; functionality from OpenCL 3.0. - IR generation for non-trivial global destructors is incomplete (See:; `PR48047 <https://llvm.org/PR48047>`_). - Support of `destructors with non-default address spaces; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html#_construction_initialization_and_destruction>`_; is incomplete (See: `D109609 <https://reviews.llvm.org/D109609>`_). .. _opencl_300:. OpenCL C 3.0 Usage; ==================. OpenCL C 3.0 language standard makes most OpenCL C 2.0 features optional. Optional; functionality in OpenCL C 3.0 is indicated with the presence of feature-test macros; (list of feature-test macros is `here <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_C.html#features>`__).; Command-line flag :option:`-cl-ext` can be used to override features supported by a target. For cases when there is an associated extension for a specific feature (fp64 and 3d image writes); user should specify both (extension and feature) in command-line flag:. .. code-block:: console. $ clang -cl-std=CL3.0 -cl-ext=+cl_khr_fp64,+__opencl_c_fp64 ...; $ clang -cl-std=CL3.0 -cl-ext=-cl_khr_fp64,-__opencl_c_fp64 ... OpenCL C 3.0 Implementation Status; ----------------------------------. The following table provides an overview of features in OpenCL C 3.0 and their; implementation status. +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Category | Featur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:14399,test,test,14399,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,2,['test'],['test']
Testability," probably have no reason to flush the output stream, so; it's better to use a literal ``'\n'``. Don't use ``inline`` when defining a function in a class definition; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A member function defined in a class definition is implicitly inline, so don't; put the ``inline`` keyword in this case. Don't:. .. code-block:: c++. class Foo {; public:; inline void bar() {; // ...; }; };. Do:. .. code-block:: c++. class Foo {; public:; void bar() {; // ...; }; };. Microscopic Details; -------------------. This section describes preferred low-level formatting guidelines along with; reasoning on why we prefer them. Spaces Before Parentheses; ^^^^^^^^^^^^^^^^^^^^^^^^^. Put a space before an open parenthesis only in control flow statements, but not; in normal function call expressions and function-like macros. For example:. .. code-block:: c++. if (X) ...; for (I = 0; I != 100; ++I) ...; while (LLVMRocks) ... somefunc(42);; assert(3 != 4 && ""laws of math are failing me"");. A = foo(42, 92) + bar(X);. The reason for doing this is not completely arbitrary. This style makes control; flow operators stand out more, and makes expressions flow better. Prefer Preincrement; ^^^^^^^^^^^^^^^^^^^. Hard fast rule: Preincrement (``++X``) may be no slower than postincrement; (``X++``) and could very well be a lot faster than it. Use preincrementation; whenever possible. The semantics of postincrement include making a copy of the value being; incremented, returning it, and then preincrementing the ""work value"". For; primitive types, this isn't a big deal. But for iterators, it can be a huge; issue (for example, some iterators contains stack and set objects in them...; copying an iterator could invoke the copy ctor's of these as well). In general,; get in the habit of always using preincrement, and you won't have a problem. Namespace Indentation; ^^^^^^^^^^^^^^^^^^^^^. In general, we strive to reduce indentation wherever possible. This is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:57536,assert,assert,57536,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['assert'],['assert']
Testability," processed twice or more times).; Fix problem with the transmission of non-default file; attributes (e.g. the number of entries) from TChainElement to; TDSetElement during TChain processing in PROOF; Fix problem in the default packetizer with validating the; exact number of needed files when the information about the entries is; already available.; Fix problem with 'xpd.putenv' and 'xpd.putrc' occuring when the variables themselves contain commas.; Avoid resolving the workers FQDN when running in PROOF-Lite,; creating unnecessary delays when running PROOF-Lite within virtual; machines.; Fix problem with the permissions of the user data directory.; Add files to the list of files to process only when finally validated.; Fix; problem with canvases when the feedback canvas and the final canvas are; the same (do not delete the feedback canvas at the end of processing); Make sure that TProof::Load, TProofPlayer::SendSelector and; TSelector::GetSelector treat consistently the extensions of the; implementation files.; Unlock the cache after failure to load a selector; prevents session freezing; Correctly update the number of submergers when workers die; Add missing protection causing a crash in submergers when the output list contained TProofOutputFile objects.; Move the creation and start of the idle timeout from the end; of SetupCommon to the end of CreateServer, so that the timeout is not; active during worker setup.; Make sure that the TProof instance on the client is invalidated after an idle timeout.; Fix an old issue with DeactivateWorker(""*"") (the session is; was terminated because no worker was active; this call coudl not be; used as intermediate step to select a small number of workers).; Consistently check both Proof.Sandbox and ProofLite.Sandbox for sandbox non-default location as done in TProofLite; Fix a problem with the registration of missing files in the; 'MissingFiles' list (files which could not be open on the workers were; not always added to the list). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:13238,sandbox,sandbox,13238,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,1,['sandbox'],['sandbox']
Testability," produce identical or; similar DWARF to Clang to allow the comparison. We're only comparing; the semantics. The same case when comparing CodeView debug information; generated by MSVC and Clang. There are 2 comparison methods: logical view and logical elements. LOGICAL VIEW; """"""""""""""""""""""""; It compares the logical view as a whole unit; for a match, each compared; logical element must have the same parents and children. Using the :program:`llvm-debuginfo-analyzer` comparison functionality,; that issue can be seen in a more global context, that can include the; logical view. The output shows in view form the **missing (-), added (+)** elements,; giving more context by swapping the reference and target object files. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level; --compare=types; --report=view; --print=symbols,types; test-dwarf-clang.o test-dwarf-gcc.o. Reference: 'test-dwarf-clang.o'; Target: 'test-dwarf-gcc.o'. Logical View:; [000] {File} 'test-dwarf-clang.o'. [001] {CompileUnit} 'test.cpp'; [002] 1 {TypeAlias} 'INTPTR' -> '* const int'; [002] 2 {Function} extern not_inlined 'foo' -> 'int'; [003] {Block}; [004] 5 {Variable} 'CONSTANT' -> 'const INTEGER'; +[004] 4 {TypeAlias} 'INTEGER' -> 'int'; [003] 2 {Parameter} 'ParamBool' -> 'bool'; [003] 2 {Parameter} 'ParamPtr' -> 'INTPTR'; [003] 2 {Parameter} 'ParamUnsigned' -> 'unsigned int'; -[003] 4 {TypeAlias} 'INTEGER' -> 'int'. The output shows the merging view path (reference and target) with the; missing and added elements. LOGICAL ELEMENTS; """"""""""""""""""""""""""""""""; It compares individual logical elements without considering if their; parents are the same. For both comparison methods, the equal criteria; includes the name, source code location, type, lexical scope level. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level; --compare=types; --report=list; --print=symbols,types,summary; test-dwarf-clang.o test-dwarf-gcc.o. Reference: 'test-dwarf-clang.o'; Target: 'test-dwarf-gcc.o'. (1) Missing Types:; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:30538,test,test,30538,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['test'],['test']
Testability," prohibitively expensive given the; attack it is defending against. ## Implementation Details. There are a number of complex details impacting the implementation of this; technique, both on a particular architecture and within a particular compiler.; We discuss proposed implementation techniques for the x86 architecture and the; LLVM compiler. These are primarily to serve as an example, as other; implementation techniques are very possible. ### x86 Implementation Details. On the x86 platform we break down the implementation into three core; components: accumulating the predicate state through the control flow graph,; checking the loads, and checking control transfers between procedures. #### Accumulating Predicate State. Consider baseline x86 instructions like the following, which test three; conditions and if all pass, loads data from memory and potentially leaks it; through some side channel:; ```; # %bb.0: # %entry; pushq %rax; testl %edi, %edi; jne .LBB0_4; # %bb.1: # %then1; testl %esi, %esi; jne .LBB0_4; # %bb.2: # %then2; testl %edx, %edx; je .LBB0_3; .LBB0_4: # %exit; popq %rax; retq; .LBB0_3: # %danger; movl (%rcx), %edi; callq leak; popq %rax; retq; ```. When we go to speculatively execute the load, we want to know whether any of; the dynamically executed predicates have been misspeculated. To track that,; along each conditional edge, we need to track the data which would allow that; edge to be taken. On x86, this data is stored in the flags register used by the; conditional jump instruction. Along both edges after this fork in control flow,; the flags register remains alive and contains data that we can use to build up; our accumulated predicate state. We accumulate it using the x86 conditional; move instruction which also reads the flag registers where the state resides.; These conditional move instructions are known to not be predicted on any x86; processors, making them immune to misprediction that could reintroduce the; vulnerability. When we insert t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:15369,test,testl,15369,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['test'],['testl']
Testability," project LLVM_EXTERNAL_<NAME>_SOURCE_DIR have to be specified; with the path for the source code of the project. Example:; ``-DLLVM_EXTERNAL_PROJECTS=""Foo;Bar""; -DLLVM_EXTERNAL_FOO_SOURCE_DIR=/src/foo; -DLLVM_EXTERNAL_BAR_SOURCE_DIR=/src/bar``. **LLVM_EXTERNALIZE_DEBUGINFO**:BOOL; Generate dSYM files and strip executables and libraries (Darwin Only).; Defaults to OFF. **LLVM_FORCE_USE_OLD_TOOLCHAIN**:BOOL; If enabled, the compiler and standard library versions won't be checked. LLVM; may not compile at all, or might fail at runtime due to known bugs in these; toolchains. **LLVM_INCLUDE_BENCHMARKS**:BOOL; Generate build targets for the LLVM benchmarks. Defaults to ON. **LLVM_INCLUDE_EXAMPLES**:BOOL; Generate build targets for the LLVM examples. Defaults to ON. You can use this; option to disable the generation of build targets for the LLVM examples. **LLVM_INCLUDE_TESTS**:BOOL; Generate build targets for the LLVM unit tests. Defaults to ON. You can use; this option to disable the generation of build targets for the LLVM unit; tests. **LLVM_INCLUDE_TOOLS**:BOOL; Generate build targets for the LLVM tools. Defaults to ON. You can use this; option to disable the generation of build targets for the LLVM tools. **LLVM_INSTALL_BINUTILS_SYMLINKS**:BOOL; Install symlinks from the binutils tool names to the corresponding LLVM tools.; For example, ar will be symlinked to llvm-ar. **LLVM_INSTALL_CCTOOLS_SYMLINKS**:BOOL; Install symliks from the cctools tool names to the corresponding LLVM tools.; For example, lipo will be symlinked to llvm-lipo. **LLVM_INSTALL_OCAMLDOC_HTML_DIR**:STRING; The path to install OCamldoc-generated HTML documentation to. This path can; either be absolute or relative to the CMAKE_INSTALL_PREFIX. Defaults to; ``${CMAKE_INSTALL_DOCDIR}/llvm/ocaml-html``. **LLVM_INSTALL_SPHINX_HTML_DIR**:STRING; The path to install Sphinx-generated HTML documentation to. This path can; either be absolute or relative to the CMAKE_INSTALL_PREFIX. Defaults to; ``${CMAKE_INST",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:28401,test,tests,28401,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['test'],['tests']
Testability," project, which also compiles executables; requiring their own ``main`` symbol, it may be desirable to request just the; instrumentation without linking::. clang -fsanitize=fuzzer-no-link mytarget.c. Then libFuzzer can be linked to the desired driver by passing in; ``-fsanitize=fuzzer`` during the linking stage. .. _libfuzzer-corpus:. Corpus; ------. Coverage-guided fuzzers like libFuzzer rely on a corpus of sample inputs for the; code under test. This corpus should ideally be seeded with a varied collection; of valid and invalid inputs for the code under test; for example, for a graphics; library the initial corpus might hold a variety of different small PNG/JPG/GIF; files. The fuzzer generates random mutations based around the sample inputs in; the current corpus. If a mutation triggers execution of a previously-uncovered; path in the code under test, then that mutation is saved to the corpus for; future variations. LibFuzzer will work without any initial seeds, but will be less; efficient if the library under test accepts complex,; structured inputs. The corpus can also act as a sanity/regression check, to confirm that the; fuzzing entrypoint still works and that all of the sample inputs run through; the code under test without problems. If you have a large corpus (either generated by fuzzing or acquired by other means); you may want to minimize it while still preserving the full coverage. One way to do that; is to use the `-merge=1` flag:. .. code-block:: console. mkdir NEW_CORPUS_DIR # Store minimized corpus here.; ./my_fuzzer -merge=1 NEW_CORPUS_DIR FULL_CORPUS_DIR. You may use the same flag to add more interesting items to an existing corpus.; Only the inputs that trigger new coverage will be added to the first corpus. .. code-block:: console. ./my_fuzzer -merge=1 CURRENT_CORPUS_DIR NEW_POTENTIALLY_INTERESTING_INPUTS_DIR. Running; -------. To run the fuzzer, first create a Corpus_ directory that holds the; initial ""seed"" sample inputs:. .. code-block:: consol",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:4732,test,test,4732,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['test'],['test']
Testability," ptr %p2; }. Migration Instructions; ======================. In order to support opaque pointers, two types of changes tend to be necessary.; The first is the removal of all calls to ``PointerType::getElementType()`` and; ``Type::getPointerElementType()``. In the LLVM middle-end and backend, this is usually accomplished by inspecting; the type of relevant operations instead. For example, memory access related; analyses and optimizations should use the types encoded in the load and store; instructions instead of querying the pointer type. Here are some common ways to avoid pointer element type accesses:. * For loads, use ``getType()``.; * For stores, use ``getValueOperand()->getType()``.; * Use ``getLoadStoreType()`` to handle both of the above in one call.; * For getelementptr instructions, use ``getSourceElementType()``.; * For calls, use ``getFunctionType()``.; * For allocas, use ``getAllocatedType()``.; * For globals, use ``getValueType()``.; * For consistency assertions, use; ``PointerType::isOpaqueOrPointeeTypeEquals()``.; * To create a pointer type in a different address space, use; ``PointerType::getWithSamePointeeType()``.; * To check that two pointers have the same element type, use; ``PointerType::hasSameElementTypeAs()``.; * While it is preferred to write code in a way that accepts both typed and; opaque pointers, ``Type::isOpaquePointerTy()`` and; ``PointerType::isOpaque()`` can be used to handle opaque pointers specially.; ``PointerType::getNonOpaquePointerElementType()`` can be used as a marker in; code-paths where opaque pointers have been explicitly excluded.; * To get the type of a byval argument, use ``getParamByValType()``. Similar; method exists for other ABI-affecting attributes that need to know the; element type, such as byref, sret, inalloca and preallocated.; * Some intrinsics require an ``elementtype`` attribute, which can be retrieved; using ``getParamElementType()``. This attribute is required in cases where; the intrinsic does not natura",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:7187,assert,assertions,7187,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['assert'],['assertions']
Testability," quicker attention.; Please ping people :wave: should you not get timely feedback, for instance with `@root-project/core ping!`. ## Tests. As you contribute code, this code will likely fix an issue or add a feature.; Whatever it is: this requires you to add a new test, or to extend an existing test. Depending on the size and complexity; of this test, it exists either in the `test/` subdirectory of each part of ROOT (see for instance; [`tree/dataframe/test`](https://github.com/root-project/root/tree/master/tree/dataframe/test)), or in; [roottest](https://github.com/root-project/roottest.git). Tests in `test/` subdirectories are unit tests, mostly based on; [Google Test](https://github.com/google/googletest) and easily extended. Tests in; [roottest](https://github.com/root-project/roottest.git) are more involved (e.g., tests requiring custom dictionaries or; data files). When you create a branch in the main ROOT repository (i.e., this repository) and add a test to `roottest`,; make sure to do this under the same branch name (and open a PR for it). Our CI infrastructure automatically picks up the; changes defined in the `roottest` PR based on this branch name, and uses that for testing your PR here. ## Continuous Integration. To prevent bad surprises and make a better first impression, we; strongly encourage new developers to [run the tests](https://root.cern/for_developers/run_the_tests/); _before_ submitting a pull request. ROOT has automated CI tests :cop: that are used for pull requests:; - *Build and test*: a [Jenkins-based CI workflow](https://github.com/phsft-bot/build-configuration/blob/master/README.md); as well as a GitHub Actions CI workflow tests PRs automatically; only a; [project member](https://github.com/orgs/root-project/people) is allowed to initiate this build.; The results are posted to the pull request.; Compared to ROOT's nightly builds, PRs are tested with less tests, on less platforms.; - *Formatting check*: `clang-format` automatically checks th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md:6235,test,test,6235,CONTRIBUTING.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md,1,['test'],['test']
Testability," quote characters so they will get passed to the invoked program.; To avoid this use curly braces to tell :program:`lit` that it should treat; everything enclosed as one value. In general, you should strive to keep your RUN lines as simple as possible,; using them only to run tools that generate textual output you can then examine.; The recommended way to examine output to figure out if the test passes is using; the :doc:`FileCheck tool <CommandGuide/FileCheck>`. *[The usage of grep in RUN; lines is deprecated - please do not send or commit patches that use it.]*. Put related tests into a single file rather than having a separate file per; test. Check if there are files already covering your feature and consider; adding your code there instead of creating a new file. Generating assertions in regression tests; -----------------------------------------. Some regression test cases are very large and complex to write/update by hand.; In that case to reduce the human work we can use the scripts available in; llvm/utils/ to generate the assertions. For example to generate assertions in an :program:`llc`-based test, after; adding one or more RUN lines use:. .. code-block:: bash. % llvm/utils/update_llc_test_checks.py --llc-binary build/bin/llc test.ll. This will generate FileCheck assertions, and insert a ``NOTE:`` line at the; top to indicate that assertions were automatically generated. If you want to update assertions in an existing test case, pass the `-u` option; which first checks the ``NOTE:`` line exists and matches the script name. Sometimes a test absolutely depends on hand-written assertions and should not; have assertions automatically generated. In that case, add the text ``NOTE: Do; not autogenerate`` to the first line, and the scripts will skip that test. It; is a good idea to explain why generated assertions will not work for the test; so future developers will understand what is going on. These are the most common scripts and their purposes/applications in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:11417,assert,assertions,11417,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['assert'],['assertions']
Testability," reference outputs so that their correctness can be checked. The suite comes; with tools to collect metrics such as benchmark runtime, compilation time and; code size. The test-suite is divided into several directories:. - `SingleSource/`. Contains test programs that are only a single source file in size. A; subdirectory may contain several programs. - `MultiSource/`. Contains subdirectories which entire programs with multiple source files.; Large benchmarks and whole applications go here. - `MicroBenchmarks/`. Programs using the [google-benchmark](https://github.com/google/benchmark); library. The programs define functions that are run multiple times until the; measurement results are statistically significant. - `External/`. Contains descriptions and test data for code that cannot be directly; distributed with the test-suite. The most prominent members of this; directory are the SPEC CPU benchmark suites.; See [External Suites](#external-suites). - `Bitcode/`. These tests are mostly written in LLVM bitcode. - `CTMark/`. Contains symbolic links to other benchmarks forming a representative sample; for compilation performance measurements. ### Benchmarks. Every program can work as a correctness test. Some programs are unsuitable for; performance measurements. Setting the `TEST_SUITE_BENCHMARKING_ONLY` CMake; option to `ON` will disable them. Configuration; -------------. The test-suite has configuration options to customize building and running the; benchmarks. CMake can print a list of them:. ```bash; % cd test-suite-build; # Print basic options:; % cmake -LH; # Print all options:; % cmake -LAH; ```. ### Common Configuration Options. - `CMAKE_C_FLAGS`. Specify extra flags to be passed to C compiler invocations. The flags are; also passed to the C++ compiler and linker invocations. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html). - `CMAKE_C_COMPILER`. Select the C compiler e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:3336,test,tests,3336,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['test'],['tests']
Testability," release or release; candidate. You don't need to fix all the bugs in the test-suite, since they're; not necessarily meant to pass on all architectures all the time. This is; due to the nature of the result checking, which relies on direct comparison,; and most of the time, the failures are related to bad output checking, rather; than bad code generation. If the errors are in LLVM itself, please report every single regression found; as blocker, and all the other bugs as important, but not necessarily blocking; the release to proceed. They can be set as ""known failures"" and to be; fix on a future date. .. _pre-release-process:. Pre-Release Process; ===================. .. contents::; :local:. When the release process is announced on the mailing list, you should prepare; for the testing, by applying the same testing you'll do on the release; candidates, on the previous release. You should:. * Download the previous release sources from; https://llvm.org/releases/download.html. * Run the test-release.sh script on ``final`` mode (change ``-rc 1`` to; ``-final``). * Once all three stages are done, it'll test the final stage. * Using the ``Phase3/Release+Asserts/llvmCore-MAJ.MIN-final.install`` base,; run the test-suite. If the final phase's ``make check-all`` failed, it's a good idea to also test; the intermediate stages by going on the obj directory and running; ``make check-all`` to find if there's at least one stage that passes (helps; when reducing the error for bug report purposes). .. _release-process:. Release Process; ===============. .. contents::; :local:. When the Release Manager sends you the release candidate, download all sources,; unzip on the same directory (there will be sym-links from the appropriate places; to them), and run the release test as above. You should:. * Download the current candidate sources from where the release manager points; you (ex. https://llvm.org/pre-releases/3.3/rc1/). * Repeat the steps above with ``-rc 1``, ``-rc 2`` etc modes a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:5135,test,test-release,5135,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,1,['test'],['test-release']
Testability," reports are welcome but will likely not be investigated for some time.; Patches welcome!. Clone Alpha Checkers; Core Alpha Checkers; C++ Alpha Checkers; LLVM Checkers; Variable Argument Alpha Checkers; Dead Code Alpha Checkers; OS X Alpha Checkers; Security Alpha Checkers; Unix Alpha Checkers; Non-determinism Alpha Checkers. Clone Alpha Checkers. Name, DescriptionExample. alpha.clone.CloneChecker; (C, C++, ObjC); Reports similar pieces of code. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. Core Alpha Checkers. Name, DescriptionExample. alpha.core.BoolAssignment; (ObjC); Warn about assigning non-{0,1} values to boolean variables. void test() {; BOOL b = -1; // warn; }. alpha.core.CallAndMessageUnInitRefArg; (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:1195,test,test,1195,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['test'],['test']
Testability," represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang perm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47162,test,test,47162,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['test'],['test']
Testability," representations of the debugging information that; is embedded in the object file. :program:`llvm-debuginfo-analyzer`; produces a canonical view of the debug information regardless of how it; is formatted. The same logical view will be seen regardless of object; file format, assuming the debug information correctly represents the; same original source code. The logical view includes the following **logical elements**: *type*,; *scope*, *symbol* and *line*, which are the basic software elements used; in the C/C++ programming language. Each logical element has a set of; **attributes**, such as *types*, *classes*, *functions*, *variables*,; *parameters*, etc. The :option:`--attribute` can be used to specify which; attributes to include when printing a logical element. A logical element; may have a **kind** that describes specific types of elements. For; instance, a *scope* could have a kind value of *function*, *class*,; *namespace*. :program:`llvm-debuginfo-analyzer` defaults to print a pre-defined; layout of logical elements and attributes. The command line options can; be used to control the printed elements (:option:`--print`), using a; specific layout (:option:`--report`), matching a given pattern; (:option:`--select`, :option:`--select-offsets`). Also, the output can; be limited to specified logical elements using (:option:`--select-lines`,; :option:`--select-scopes`, :option:`--select-symbols`,; :option:`--select-types`). :program:`llvm-debuginfo-analyzer` can also compare a set of logical; views (:option:`--compare`), to find differences and identify possible; debug information syntax issues (:option:`--warning`) in any object file. OPTIONS; -------; :program:`llvm-debuginfo-analyzer` options are separated into several; categories, each tailored to a different purpose:. * :ref:`general_` - Standard LLVM options to display help, version, etc.; * :ref:`attributes_` - Describe how to include different details when; printing an element.; * :ref:`print_` - Specify w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:1776,log,logical,1776,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['log'],['logical']
Testability," represents a function which is; functionally equivalent to a given function, but is always defined in the; current linkage unit. The resulting pointer has the same type as the underlying; function. The resulting pointer is permitted, but not required, to be different; from a pointer to the function, and it may have different values in different; translation units. The target function may not have ``extern_weak`` linkage. ``dso_local_equivalent`` can be implemented as such:. - If the function has local linkage, hidden visibility, or is; ``dso_local``, ``dso_local_equivalent`` can be implemented as simply a pointer; to the function.; - ``dso_local_equivalent`` can be implemented with a stub that tail-calls the; function. Many targets support relocations that resolve at link time to either; a function or a stub for it, depending on if the function is defined within the; linkage unit; LLVM will use this when available. (This is commonly called a; ""PLT stub"".) On other targets, the stub may need to be emitted explicitly. This can be used wherever a ``dso_local`` instance of a function is needed without; needing to explicitly make the original function ``dso_local``. An instance where; this can be used is for static offset calculations between a function and some other; ``dso_local`` symbol. This is especially useful for the Relative VTables C++ ABI,; where dynamic relocations for function pointers in VTables can be replaced with; static relocations for offsets between the VTable and virtual functions which; may not be ``dso_local``. This is currently only supported for ELF binary formats. .. _no_cfi:. No CFI; ------. ``no_cfi @func``. With `Control-Flow Integrity (CFI); <https://clang.llvm.org/docs/ControlFlowIntegrity.html>`_, a '``no_cfi``'; constant represents a function reference that does not get replaced with a; reference to the CFI jump table in the ``LowerTypeTests`` pass. These constants; may be useful in low-level programs, such as operating system kernels, whi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:202076,stub,stub,202076,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['stub'],['stub']
Testability," reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. # @author Danilo Piparo CERN, 2018; # @author Patrick Bos, NL eScience Center, 2018. ROOT_ADD_GTEST(testSimple testSimple.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooAddPdf testRooAddPdf.cxx LIBRARIES RooFitCore RooStats); ROOT_ADD_GTEST(testRooCacheManager testRooCacheManager.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooCategory testRooCategory.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testWorkspace testWorkspace.cxx LIBRARIES RooFitCore RooStats); ROOT_ADD_GTEST(testRooDataHist testRooDataHist.cxx LIBRARIES RooFitCore; COPY_TO_BUILDDIR ${CMAKE_CURRENT_SOURCE_DIR}/dataHistv4_ref.root; ${CMAKE_CURRENT_SOURCE_DIR}/dataHistv5_ref.root; ${CMAKE_CURRENT_SOURCE_DIR}/dataHistv6_ref.root); ROOT_ADD_GTEST(testRooBinSamplingPdf testRooBinSamplingPdf.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooWrapperPdf testRooWrapperPdf.cxx LIBRARIES Gpad RooFitCore); ROOT_ADD_GTEST(testGenericPdf testGenericPdf.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooAbsPdf testRooAbsPdf.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooAbsCollection testRooAbsCollection.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooDataSet testRooDataSet.cxx LIBRARIES Tree RooFitCore; COPY_TO_BUILDDIR ${CMAKE_CURRENT_SOURCE_DIR}/dataSet_with_errors_6_26_10.root); ROOT_ADD_GTEST(testRooFormula testRooFormula.cxx LIBRARIES RooFitCore ROOT::TestSupport); ROOT_ADD_GTEST(testRooProdPdf testRooProdPdf.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testProxiesAndCategories testProxiesAndCategories.cxx; LIBRARIES RooFitCore; COPY_TO_BUILDDIR ${CMAKE_CURRENT_SOURCE_DIR}/testProxiesAndCategories_1.root; ${CMAKE_CURRENT_SOURCE_DIR}/categories_v620.root; ${CMAKE_CURRENT_SOURCE_DIR}/categories_v621.root; ${CMAKE_CURRENT_SOURCE_DIR}/categories_v622.root; ${CMAKE_CURRENT_SOURCE_DIR}/categories_v624.root); ROOT_ADD_GTEST(testRooCollectionProxy testRooCollectionProxy.cxx; LIBRARIES RooFitCore; COPY",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/CMakeLists.txt:1080,test,testGenericPdf,1080,roofit/roofitcore/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/CMakeLists.txt,2,['test'],['testGenericPdf']
Testability," resolve symbols in the target. RuntimeDyld; -----------. In order to keep RuntimeDyld's implementation simple MCJIT imposed some; restrictions on compiled code:. #. It had to use the Large code model, and often restricted available relocation; models in order to limit the kinds of relocations that had to be supported. #. It required strong linkage and default visibility on all symbols -- behavior; for other linkages/visibilities was not well defined. #. It constrained and/or prohibited the use of features requiring runtime; support, e.g. static initializers or thread local storage. As a result of these restrictions not all language features supported by LLVM; worked under MCJIT, and objects to be loaded under the JIT had to be compiled to; target it (precluding the use of precompiled code from other sources under the; JIT). RuntimeDyld also provided very limited visibility into the linking process; itself: Clients could access conservative estimates of section size; (RuntimeDyld bundled stub size and padding estimates into the section size; value) and the final relocated bytes, but could not access RuntimeDyld's; internal object representations. Eliminating these restrictions and limitations was one of the primary motivations; for the development of JITLink. The llvm-jitlink tool; =====================. The ``llvm-jitlink`` tool is a command line wrapper for the JITLink library.; It loads some set of relocatable object files and then links them using; JITLink. Depending on the options used it will then execute them, or validate; the linked memory. The ``llvm-jitlink`` tool was originally designed to aid JITLink development by; providing a simple environment for testing. Basic usage; -----------. By default, ``llvm-jitlink`` will link the set of objects passed on the command; line, then search for a ""main"" function and execute it:. .. code-block:: sh. % cat hello-world.c; #include <stdio.h>. int main(int argc, char *argv[]) {; printf(""hello, world!\n"");; return 0;; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:36658,stub,stub,36658,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['stub'],['stub']
Testability," return i; }; void setI(int& ii) { i = ii; }; };. different.LibFuncResultUnised; (C, C++); Calling a function ignoring its return value is of no use (create the list of; known system/library/API functions falling into this category). #include <vector>. void test() {; std::vector<int> v;; v.empty(); // warn; }. different.WrongVarForStmt; (C, C++); Wrong variable is possibly used in the loop/cond-expression of; the for statement. Did you mean; 'proper_variable_name'?. void test() {; int i = 0;; int j = 0;; for (i = 0; i < 3; j += 1); // warn; }. void test() {; int i = 0;; int j = 0;; for (int j = 0; i < 3; ++j); // warn; }. different.FloatingCompare; (C); Comparing floating point numbers may be not precise. #include <math.h>. double test() {; double b = sin(M_PI / 6.0);; if (b == 0.5) // warn; b = 0;; return b;; }. different.BitwiseOpBoolArg; (C, C++); Boolean value met at the left/right part of the bitwise &; or | operator.; Did you mean && (||) ?. int f();. void test() {; bool b = true;; if (b & f()) {} // warn; }. different.LabelInsideSwitch; (C); Possibly a misprint: label found inside a switch(); statement. void test(int c) {; switch(c){; case 1:; c += 1; break;; defalt: // warn (did you mean 'default'?); c -= 1; break;; }; }. different.IdenticalCondIfIf; (C); The conditions of two subsequent if statements are; identical. int test(int c) {; if (c > 5); c += 1;; if (c > 5) // warn; c -= 1;; return c;; }. different.LogicalOpUselessArg; (C); The second operand of a && operator has no impact on; expression result. void test(unsigned a) {; if (a<7 && a<10) {}; // warn; }. different.SameResLogicalExpr; (C); An expression is always evaluated to true/false. void test() {; int i = 0;; if (i != 0) {}; // warn; }. void test(int i) {; if (i == 0 && i == 1) {}; // warn; }. void test(int i) {; if (i < 0 || i >= 0) {}; // warn; }. different.OpPrecedenceAssignCmp; (C, C++); Comparison operation has higher precedence then assignment. Boolean value is; assigned to a variable of oth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:21902,test,test,21902,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability," return integralFoo();; }; };; ```. \note All RooFit classes are deriving from the RooAbsReal object, but; its details are not relevant to the current example. Note how the `evaluate()` function overrides the `RooAbsReal` for the RooFoo; class. Similarly, the `analyticalIntegral()` function has also been overridden; from the `RooAbsReal` class. The `evaluate()` function includes some bookkeeping steps (commented out in; above example) that are not relevant to AD. The important part is that it; calls a specific function (doFoo() in this example), and returns the results. Similarly, the `analyticalIntegral()` function calls a specific function (; `integralFoo()` in this example), and returns the results. It may also include; some code that may need to be looked at, but for simplicity, its contents are; commented out in this example. #### Adding Code Generation Support to RooFoo class. Before creating the translate() function, move the mathematical logic (; `doFoo()` function in this example) out of the source class (RooFoo in this; example) and into a separate header file called `MathFuncs.h`. Also note; that the parameters a and b have been defined as inputs, instead of them just; being class members. ``` {.cpp}; ///// The MathFuncs.h file; int doFoo(int a, int b) { return a* b + a + b; }; ```. > Directory path: [roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h](https://github.com/root-project/root/blob/master/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h). So now that the `doFoo()` function exists in the `MathFuncs` namespace, we; need to comment out its original function definition in the RooFoo class and; also add the namespace `MathFuncs` to wherever `doFoo()` it is referenced; (and also define input parameters for it). ``` {.cpp}; class RooFoo : public RooAbsReal {; ...; // int doFoo() { return a* b + a + b; }. double evaluate() override {; ...; return MathFuncs::doFoo(a, b);; };; ```. Next, create the translate function. Most translate functions include a; `bu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:20673,log,logic,20673,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['log'],['logic']
Testability," return to it at our next; opportunity enables this. What are the expectations around a revert?. * Use your best judgment. If you're uncertain, please start an email on; the commit thread asking for assistance. We aren't trying to enumerate; every case, but rather give a set of guidelines.; * You should be sure that reverting the change improves the stability of tip; of tree. Sometimes reverting one change in a series can worsen things; instead of improving them. We expect reasonable judgment to ensure that; the proper patch or set of patches is being reverted.; * The commit message for the reverting commit should explain why patch; is being reverted.; * It is customary to respond to the original commit email mentioning the; revert. This serves as both a notice to the original author that their; patch was reverted, and helps others following llvm-commits track context.; * Ideally, you should have a publicly reproducible test case ready to share.; Where possible, we encourage sharing of test cases in commit threads, or; in PRs. We encourage the reverter to minimize the test case and to prune; dependencies where practical. This even applies when reverting your own; patch; documenting the reasons for others who might be following along; is critical.; * It is not considered reasonable to revert without at least the promise to; provide a means for the patch author to debug the root issue. If a situation; arises where a public reproducer can not be shared for some reason (e.g.; requires hardware patch author doesn't have access to, sharp regression in; compile time of internal workload, etc.), the reverter is expected to be; proactive about working with the patch author to debug and test candidate; patches.; * Reverts should be reasonably timely. A change submitted two hours ago; can be reverted without prior discussion. A change submitted two years ago; should not be. Where exactly the transition point is is hard to say, but; it's probably in the handful of days in tree t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:21589,test,test,21589,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['test'],['test']
Testability," run; optimizations or code generator components against every program in the; tree, collecting statistics or running custom checks for correctness. At; base, this is how the nightly tester works, it's just one example of a; general framework. Lets say that you have an LLVM optimization pass, and you want to see; how many times it triggers. First thing you should do is add an LLVM; `statistic <ProgrammersManual.html#Statistic>`_ to your pass, which will; tally counts of things you care about. Following this, you can set up a test and a report that collects these; and formats them for easy viewing. This consists of two files, a; ""``test-suite/TEST.XXX.Makefile``"" fragment (where XXX is the name of; your test) and a ""``test-suite/TEST.XXX.report``"" file that indicates; how to format the output into a table. There are many example reports of; various levels of sophistication included with the test suite, and the; framework is very general. If you are interested in testing an optimization pass, check out the; ""libcalls"" test as an example. It can be run like this:. .. code-block:: bash. % cd llvm/projects/test-suite/MultiSource/Benchmarks # or some other level; % make TEST=libcalls report. This will do a bunch of stuff, then eventually print a table like this:. ::. Name | total | #exit |; ...; FreeBench/analyzer/analyzer | 51 | 6 |; FreeBench/fourinarow/fourinarow | 1 | 1 |; FreeBench/neural/neural | 19 | 9 |; FreeBench/pifft/pifft | 5 | 3 |; MallocBench/cfrac/cfrac | 1 | * |; MallocBench/espresso/espresso | 52 | 12 |; MallocBench/gs/gs | 4 | * |; Prolangs-C/TimberWolfMC/timberwolfmc | 302 | * |; Prolangs-C/agrep/agrep | 33 | 12 |; Prolangs-C/allroots/allroots | * | * |; Prolangs-C/assembler/assembler | 47 | * |; Prolangs-C/bison/mybison | 74 | * |; ... This basically is grepping the -stats output and displaying it in a; table. You can also use the ""TEST=libcalls report.html"" target to get; the table in HTML form, similarly for report.csv and report.tex. The source for t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:6143,test,testing,6143,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,2,['test'],"['test', 'testing']"
Testability," running inside node.js; - supports openui5 sap.ui.require loader if available before JSRoot.core.js; - deprecates old JSROOT.AssertPrerequisites() function; 8. Upgrade d3.js to v6.1.1, skip support of older versions; 9. Upgrade three.js to r121:; - SoftwareRenderer deprecated and removed; - let use WebGL for browser, batch and node.js (via headless-gl); - support r3d_gl, r3d_img, r3d_svg rendering options for TGeo and histograms; - keep support of SVGRendered as backup solution; 10. Upgrade MathJax.js to version 3.1.1; - reliably works in browser and node.js!; - all latex/mathjax related methods moved to special JSRoot.latex.js script, loaded on demand; 11. Update jquery to 3.5.1, openui5 to 1.82.2; 12. Use JS classes only in few places - performance is not good enough compared to Object.prototype; 13. Deprecate IE support; 14. Deprecate bower package manager; 15. Add support of ZSTD compression - works only on https://root.cern/js/ website; 16. Add support of log2 scale for axes drawing, v7 can have arbitrary log base; 17. Improve TH2 col drawings for large number of bins - up to factor 5 faster; 18. Allow to move axis title to opposite position; 19. Fix zooming in color palette; 20. Implement monitoring of object inspector. ## Changes in 5.9.1; 1. Fix zooming in color palette; 2. Fix interactive update of TGraph painting on time scale; 3. Fix I/O error in reading std::map (#204); 4. Fix functionality of ""open all"" / ""close all"" GUI buttons. ## Changes in 5.9.0; 1. Support RX and RY drawing option together with COL of TH2; 2. Add support of #overline, #underline, #strike into TLatex parsing (#196); 3. Add support of TGeoTessellated shape; 4. Major changes in v7 drawing: RFrame, RPalette, RColor, RStatBox, ...; 5. Fix in reading std::map member-wise; 6. Better handling of context menu position; 7. Support TASImage class - both PNG and binary content, including palette; 8. Let change TH2 values range via context menu; 9. Fix problem with TH2 col drawing when bins si",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:26662,log,log,26662,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['log'],['log']
Testability," s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:62057,test,test,62057,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability," same elements. But the; **'typedef INTEGER'** is located at different scope level. The GCC; generated object, shows **'4'**, which is the correct value. Note that there is no requirement that GCC must produce identical or; similar DWARF to Clang to allow the comparison. We're only comparing; the semantics. The same case when comparing CodeView debug information; generated by MSVC and Clang. There are 2 comparison methods: logical view and logical elements. LOGICAL VIEW; """"""""""""""""""""""""; It compares the logical view as a whole unit; for a match, each compared; logical element must have the same parents and children. Using the :program:`llvm-debuginfo-analyzer` comparison functionality,; that issue can be seen in a more global context, that can include the; logical view. The output shows in view form the **missing (-), added (+)** elements,; giving more context by swapping the reference and target object files. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level; --compare=types; --report=view; --print=symbols,types; test-dwarf-clang.o test-dwarf-gcc.o. Reference: 'test-dwarf-clang.o'; Target: 'test-dwarf-gcc.o'. Logical View:; [000] {File} 'test-dwarf-clang.o'. [001] {CompileUnit} 'test.cpp'; [002] 1 {TypeAlias} 'INTPTR' -> '* const int'; [002] 2 {Function} extern not_inlined 'foo' -> 'int'; [003] {Block}; [004] 5 {Variable} 'CONSTANT' -> 'const INTEGER'; +[004] 4 {TypeAlias} 'INTEGER' -> 'int'; [003] 2 {Parameter} 'ParamBool' -> 'bool'; [003] 2 {Parameter} 'ParamPtr' -> 'INTPTR'; [003] 2 {Parameter} 'ParamUnsigned' -> 'unsigned int'; -[003] 4 {TypeAlias} 'INTEGER' -> 'int'. The output shows the merging view path (reference and target) with the; missing and added elements. LOGICAL ELEMENTS; """"""""""""""""""""""""""""""""; It compares individual logical elements without considering if their; parents are the same. For both comparison methods, the equal criteria; includes the name, source code location, type, lexical scope level. .. code-block:: none. llvm-debuginfo-analyze",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:30369,test,test-dwarf-clang,30369,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['test'],['test-dwarf-clang']
Testability," second character.; Otherwise, %t but with a single leading ``/`` removed.; %:T On Windows, %/T but a ``:`` is removed if its the second character.; Otherwise, %T but with a single leading ``/`` removed.; ======================= ==============. Other substitutions are provided that are variations on this base set and; further substitution patterns can be defined by each test module. See the; modules :ref:`local-configuration-files`. More detailed information on substitutions can be found in the; :doc:`../TestingGuide`. TEST RUN OUTPUT FORMAT; ~~~~~~~~~~~~~~~~~~~~~~. The :program:`lit` output for a test run conforms to the following schema, in; both short and verbose modes (although in short mode no PASS lines will be; shown). This schema has been chosen to be relatively easy to reliably parse by; a machine (for example in buildbot log scraping), and for other tools to; generate. Each test result is expected to appear on a line that matches:. .. code-block:: none. <result code>: <test name> (<progress info>). where ``<result-code>`` is a standard test result such as PASS, FAIL, XFAIL,; XPASS, UNRESOLVED, or UNSUPPORTED. The performance result codes of IMPROVED and; REGRESSED are also allowed. The ``<test name>`` field can consist of an arbitrary string containing no; newline. The ``<progress info>`` field can be used to report progress information such; as (1/300) or can be empty, but even when empty the parentheses are required. Each test result may include additional (multiline) log information in the; following format:. .. code-block:: none. <log delineator> TEST '(<test name>)' <trailing delineator>; ... log message ...; <log delineator>. where ``<test name>`` should be the name of a preceding reported test, ``<log; delineator>`` is a string of ""*"" characters *at least* four characters long; (the recommended length is 20), and ``<trailing delineator>`` is an arbitrary; (unparsed) string. The following is an example of a test run output which consists of four test",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:22626,test,test,22626,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['test']
Testability," second field is an integer or a vector of integer values with the same; number of elements as the argument. Semantics:; """""""""""""""""""". This intrinsic splits a floating point value into a normalized; fractional component and integral exponent. For a non-zero argument, returns the argument multiplied by some power; of two such that the absolute value of the returned value is in the; range [0.5, 1.0), with the same sign as the argument. The second; result is an integer such that the first result raised to the power of; the second result is the input argument. If the argument is a zero, returns a zero with the same sign and a 0; exponent. If the argument is a NaN, a NaN is returned and the returned exponent; is unspecified. If the argument is an infinity, returns an infinity with the same sign; and an unspecified exponent. .. _int_log:. '``llvm.log.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.log`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.log.f32(float %Val); declare double @llvm.log.f64(double %Val); declare x86_fp80 @llvm.log.f80(x86_fp80 %Val); declare fp128 @llvm.log.f128(fp128 %Val); declare ppc_fp128 @llvm.log.ppcf128(ppc_fp128 %Val). Overview:; """""""""""""""""". The '``llvm.log.*``' intrinsics compute the base-e logarithm of the specified; value. Arguments:; """""""""""""""""""". The argument and return value are floating-point numbers of the same type. Semantics:; """""""""""""""""""". Return the same value as a corresponding libm '``log``' function but without; trapping or setting ``errno``. When specified with the fast-math-flag 'afn', the result may be approximated; using a less accurate calculation. .. _int_log10:. '``llvm.log10.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.log10`` on any; floating-point or vector of floating-point type. Not all targets support; all t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:567651,log,log,567651,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['log'],['log']
Testability," selective plotting and; loop through each entry of the tree and tracks. We chose a simple; example: we want to plot `fPx` of the first 100 tracks of each entry. We; have a ROOT tree with a branch for each data member in the ""`Event`""; object. To build this file and tree follow the instructions on how to; build the examples in `$ROOTSYS/test`. Execute `Event` and instruct it; to split the object with this command (from the UNIX command line). ``` {.cpp}; > $ROOTSYS/test/Event 400 1 2 1; ```. This creates an `Event.root` file with 400 events, compressed, split,; and filled. See `$ROOTSYS/test/MainEvent.cxx` for more info. The person who designed the tree makes a shared library available to; you, which defines the classes needed. In this case, the classes are; Event, `EventHeader`, and Track and they are defined in the shared; library `libEvent.so`. The designer also gives you the `Event.h` file to; see the definition of the classes. You can locate `Event.h` in; `$ROOTSYS/test`, and if you have not yet built `libEvent.so`, please see; the instructions of how to build it (typing make in \$ROOTSYS/test is; enough). If you have already built it, you can now use it again. ### Creating a Class with MakeClass. First, we load the shared library and open `Event.root`. ``` {.cpp}; root[] .L libEvent.so; root[] TFile *f = new TFile(""Event.root"");; root[] f->ls();; TFile** Event.root TTree benchmark ROOT file; TFile* Event.root TTree benchmark ROOT file; KEY: TH1F htime;1 Real-Time to write versus time; KEY: TTree T;1 An example of a ROOT tree; ```. We can see there is a tree ""`T`"", and just to verify that we are working; with the correct one, we print the tree, which will show us the header; and branches. ``` {.cpp}; root[] T->Print();; ```. From the output of print we can see that the tree has one branch for; each data member of `Event`, `Track`, and `EventHeader`. Now we can use; `TTree::MakeClass` on our tree ""`T`"". `MakeClass` takes one parameter, a; string containing the n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:122878,test,test,122878,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['test'],['test']
Testability," skipped; each time it is invoked and each invocation will be assigned a unique value.; For example, if a FunctionPass is used with a module containing three functions; a different index value will be assigned to the pass for each of the functions; as the pass is run. The pass may be run on two functions but skipped for the; third. If the pass internally performs operations on a smaller IR unit the pass must be; specifically instrumented to enable bisection at this finer level of granularity; (see below for details). Example Usage; =============. .. code-block:: console. $ opt -O2 -o test-opt.bc -opt-bisect-limit=16 test.ll. BISECT: running pass (1) Simplify the CFG on function (g); BISECT: running pass (2) SROA on function (g); BISECT: running pass (3) Early CSE on function (g); BISECT: running pass (4) Infer set function attributes on module (test.ll); BISECT: running pass (5) Interprocedural Sparse Conditional Constant Propagation on module (test.ll); BISECT: running pass (6) Global Variable Optimizer on module (test.ll); BISECT: running pass (7) Promote Memory to Register on function (g); BISECT: running pass (8) Dead Argument Elimination on module (test.ll); BISECT: running pass (9) Combine redundant instructions on function (g); BISECT: running pass (10) Simplify the CFG on function (g); BISECT: running pass (11) Remove unused exception handling info on SCC (<<null function>>); BISECT: running pass (12) Function Integration/Inlining on SCC (<<null function>>); BISECT: running pass (13) Deduce function attributes on SCC (<<null function>>); BISECT: running pass (14) Remove unused exception handling info on SCC (f); BISECT: running pass (15) Function Integration/Inlining on SCC (f); BISECT: running pass (16) Deduce function attributes on SCC (f); BISECT: NOT running pass (17) Remove unused exception handling info on SCC (g); BISECT: NOT running pass (18) Function Integration/Inlining on SCC (g); BISECT: NOT running pass (19) Deduce function attributes on SCC (g)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst:5598,test,test,5598,interpreter/llvm-project/llvm/docs/OptBisect.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OptBisect.rst,1,['test'],['test']
Testability," soft-float; target by substituting soft-float equivalents for the sysroot and target. The; target to use is:. * ``-DCMAKE_C_COMPILER_TARGET=arm-linux-gnueabi``. Depending on whether you want to use floating point instructions or not you; may need extra c-flags such as ``-mfloat-abi=softfp`` for use of floating-point; instructions, and ``-mfloat-abi=soft -mfpu=none`` for software floating-point; emulation. You will need to use an arm-linux-gnueabi GNU toolchain for soft-float. AArch64 Target; --------------; The instructions for Arm can be used for AArch64 by substituting AArch64; equivalents for the sysroot, emulator and target. * ``-DCMAKE_C_COMPILER_TARGET=aarch64-linux-gnu``; * ``-DCOMPILER_RT_EMULATOR=""qemu-aarch64 -L /path/to/aarch64/sysroot``. The CMAKE_C_FLAGS and COMPILER_RT_TEST_COMPILER_CFLAGS may also need:; ``""--sysroot=/path/to/aarch64/sysroot --gcc-toolchain=/path/to/gcc-toolchain""``. Armv6-m, Armv7-m and Armv7E-M targets; -------------------------------------; To build and test the libraries using a similar method to Armv7-A is possible; but more difficult. The main problems are:. * There isn't a ``qemu-arm`` user-mode emulator for bare-metal systems. The ``qemu-system-arm`` can be used but this is significantly more difficult to setup.; * The targets to compile compiler-rt have the suffix -none-eabi. This uses the BareMetal driver in clang and by default won't find the libraries needed to pass the cmake compiler check. As the Armv6-M, Armv7-M and Armv7E-M builds of compiler-rt only use instructions; that are supported on Armv7-A we can still get most of the value of running the; tests using the same ``qemu-arm`` that we used for Armv7-A by building and; running the test cases for Armv7-A but using the builtins compiled for; Armv6-M, Armv7-M or Armv7E-M. This will test that the builtins can be linked; into a binary and execute the tests correctly but it will not catch if the; builtins use instructions that are supported on Armv7-A but not Armv6-M,; Ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:9510,test,test,9510,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,1,['test'],['test']
Testability," space | tab; CComment: ""/*"" ... ""*/""; BCPLComment: ""//"" ... `LineEnd`; WhiteSpaceOrCComment: `WhiteSpace` | `CComment`; WhiteSpaceOrAnyComment: `WhiteSpace` | `CComment` | `BCPLComment`; MacroName: `ualpha` (`ualpha` | ""0""...""9"")*; PreDefine: `LineBegin` (`WhiteSpaceOrCComment`)*; : ""#define"" (`WhiteSpace`)+ `MacroName`; : (`WhiteSpaceOrAnyComment`)* `LineEnd`; PreIfdef: `LineBegin` (`WhiteSpaceOrCComment`)*; : (""#ifdef"" | ""#ifndef"") (`WhiteSpace`)+ `MacroName`; : (`WhiteSpaceOrAnyComment`)* `LineEnd`; PreElse: `LineBegin` (`WhiteSpaceOrCComment`)*; : ""#else"" (`WhiteSpaceOrAnyComment`)* `LineEnd`; PreEndif: `LineBegin` (`WhiteSpaceOrCComment`)*; : ""#endif"" (`WhiteSpaceOrAnyComment`)* `LineEnd`. ..; PreRegContentException: `PreIfdef` | `PreElse` | `PreEndif` | EOF; PreRegion: .* - `PreRegContentException`; :| `PreIfdef`; : (`PreRegion`)*; : [`PreElse`]; : (`PreRegion`)*; : `PreEndif`. A :token:`MacroName` can be defined anywhere in a TableGen file. The name has; no value; it can only be tested to see whether it is defined. A macro test region begins with an ``#ifdef`` or ``#ifndef`` directive. If; the macro name is defined (``#ifdef``) or undefined (``#ifndef``), then the; source code between the directive and the corresponding ``#else`` or; ``#endif`` is processed. If the test fails but there is an ``#else``; clause, the source code between the ``#else`` and the ``#endif`` is; processed. If the test fails and there is no ``#else`` clause, then no; source code in the test region is processed. Test regions may be nested, but they must be properly nested. A region; started in a file must end in that file; that is, must have its; ``#endif`` in the same file. A :token:`MacroName` may be defined externally using the ``-D`` option on the; ``*-tblgen`` command line::. llvm-tblgen self-reference.td -Dmacro1 -Dmacro3. Appendix A: Bang Operators; ==========================. Bang operators act as functions in value expressions. A bang operator takes; one or more arguments, ope",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:57915,test,tested,57915,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['test'],['tested']
Testability," special case, ``XFAIL: *`` is expected to fail everywhere. .. code-block:: llvm. ; This test is disabled when running on Windows,; ; and is disabled when targeting Linux, except for Android Linux.; ; UNSUPPORTED: system-windows, target={{.*linux.*}} && !target={{.*android.*}}; ; This test is expected to fail when targeting PowerPC or running on Darwin.; ; XFAIL: target=powerpc{{.*}}, system-darwin. Tips for writing constraints; ----------------------------. **``REQUIRES`` and ``UNSUPPORTED``**. These are logical inverses. In principle, ``UNSUPPORTED`` isn't absolutely; necessary (the logical negation could be used with ``REQUIRES`` to get; exactly the same effect), but it can make these clauses easier to read and; understand. Generally, people use ``REQUIRES`` to state things that the test; depends on to operate correctly, and ``UNSUPPORTED`` to exclude cases where; the test is expected never to work. **``UNSUPPORTED`` and ``XFAIL``**. Both of these indicate that the test isn't expected to work; however, they; have different effects. ``UNSUPPORTED`` causes the test to be skipped;; this saves execution time, but then you'll never know whether the test; actually would start working. Conversely, ``XFAIL`` actually runs the test; but expects a failure output, taking extra execution time but alerting you; if/when the test begins to behave correctly (an XPASS test result). You; need to decide which is more appropriate in each case. **Using ``target=...``**. Checking the target triple can be tricky; it's easy to mis-specify. For; example, ``target=mips{{.*}}`` will match not only mips, but also mipsel,; mips64, and mips64el. ``target={{.*}}-linux-gnu`` will match; x86_64-unknown-linux-gnu, but not armv8l-unknown-linux-gnueabihf.; Prefer to use hyphens to delimit triple components (``target=mips-{{.*}}``); and it's generally a good idea to use a trailing wildcard to allow for; unexpected suffixes. Also, it's generally better to write regular expressions that use entire; tr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:22336,test,test,22336,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['test']
Testability," specific platform,; either related to code generated, specific output or back-end features,; you must make sure to isolate the features, so that buildbots that; run on different architectures (and don't even compile all back-ends),; don't fail. The first problem is to check for target-specific output, for example sizes; of structures, paths and architecture names, for example:. * Tests containing Windows paths will fail on Linux and vice-versa.; * Tests that check for ``x86_64`` somewhere in the text will fail anywhere else.; * Tests where the debug information calculates the size of types and structures. Also, if the test rely on any behaviour that is coded in any back-end, it must; go in its own directory. So, for instance, code generator tests for ARM go; into ``test/CodeGen/ARM`` and so on. Those directories contain a special; ``lit`` configuration file that ensure all tests in that directory will; only run if a specific back-end is compiled and available. For instance, on ``test/CodeGen/ARM``, the ``lit.local.cfg`` is:. .. code-block:: python. config.suffixes = ['.ll', '.c', '.cpp', '.test']; if not 'ARM' in config.root.targets:; config.unsupported = True. Other platform-specific tests are those that depend on a specific feature; of a specific sub-architecture, for example only to Intel chips that support ``AVX2``. For instance, ``test/CodeGen/X86/psubus.ll`` tests three sub-architecture; variants:. .. code-block:: llvm. ; RUN: llc -mcpu=core2 < %s | FileCheck %s -check-prefix=SSE2; ; RUN: llc -mcpu=corei7-avx < %s | FileCheck %s -check-prefix=AVX1; ; RUN: llc -mcpu=core-avx2 < %s | FileCheck %s -check-prefix=AVX2. And the checks are different:. .. code-block:: llvm. ; SSE2: @test1; ; SSE2: psubusw LCPI0_0(%rip), %xmm0; ; AVX1: @test1; ; AVX1: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0; ; AVX2: @test1; ; AVX2: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0. So, if you're testing for a behaviour that you know is platform-specific or; depends on special features of sub-architec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:18326,test,test,18326,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['test']
Testability," specified by `config.test_exec_root`. .. option:: --max-failures N. Stop execution after the given number ``N`` of failures.; An integer argument should be passed on the command line; prior to execution. .. option:: --max-tests=N. Run at most ``N`` tests and then terminate. .. option:: --max-time=N. Spend at most ``N`` seconds (approximately) running tests and then terminate.; Note that this is not an alias for :option:`--timeout`; the two are; different kinds of maximums. .. option:: --num-shards=M. Divide the set of selected tests into ``M`` equal-sized subsets or; ""shards"", and run only one of them. Must be used with the; ``--run-shard=N`` option, which selects the shard to run. The environment; variable ``LIT_NUM_SHARDS`` can also be used in place of this; option. These two options provide a coarse mechanism for partitioning large; testsuites, for parallel execution on separate machines (say in a large; testing farm). .. option:: --order={lexical,random,smart}. Define the order in which tests are run. The supported values are:. - lexical - tests will be run in lexical order according to the test file; path. This option is useful when predictable test order is desired. - random - tests will be run in random order. - smart - tests that failed previously will be run first, then the remaining; tests, all in descending execution time order. This is the default as it; optimizes concurrency. .. option:: --run-shard=N. Select which shard to run, assuming the ``--num-shards=M`` option was; provided. The two options must be used together, and the value of ``N``; must be in the range ``1..M``. The environment variable; ``LIT_RUN_SHARD`` can also be used in place of this option. .. option:: --timeout=N. Spend at most ``N`` seconds (approximately) running each individual test.; ``0`` means no time limit, and ``0`` is the default. Note that this is not an; alias for :option:`--max-time`; the two are different kinds of maximums. .. option:: --filter=REGEXP. Run only those test",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:7134,test,tests,7134,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['tests']
Testability," src/RooVectorDataStore.cxx; src/RooWorkspace.cxx; src/RooWrapperPdf.cxx; src/TestStatistics/ConstantTermsOptimizer.cxx; src/TestStatistics/LikelihoodGradientWrapper.cxx; src/TestStatistics/LikelihoodSerial.cxx; src/TestStatistics/LikelihoodWrapper.cxx; src/TestStatistics/MinuitFcnGrad.cxx; src/TestStatistics/RooAbsL.cxx; src/TestStatistics/RooBinnedL.cxx; src/TestStatistics/RooRealL.cxx; src/TestStatistics/RooSubsidiaryL.cxx; src/TestStatistics/RooSumL.cxx; src/TestStatistics/RooUnbinnedL.cxx; src/TestStatistics/buildLikelihood.cxx; src/TestStatistics/SharedOffset.cxx; ${LegacyEvalBackendSources}; ${RooFitMPTestStatisticsSources}; DICTIONARY_OPTIONS; ""-writeEmptyRootPCM""; LIBRARIES; RooBatchCompute; ${EXTRA_LIBRARIES}; DEPENDENCIES; Core; Hist; Graf; Matrix; Tree; Minuit; RIO; MathCore; Foam; Smatrix; ${EXTRA_DEPENDENCIES}; LINKDEF; inc/LinkDef.h; ${EXTRA_DICT_OPTS}; ). # The following definitions are PUBLIC so they can also be used in ROOT-internal tests. if(roofit_legacy_eval_backend); target_compile_definitions(RooFitCore PUBLIC ROOFIT_LEGACY_EVAL_BACKEND); endif(). if(roofit_multiprocess); target_compile_definitions(RooFitCore PUBLIC ROOFIT_MULTIPROCESS); endif(). if(clad); target_compile_definitions(RooFitCore PUBLIC ROOFIT_CLAD); endif(). if(cuda); target_compile_definitions(RooFitCore PUBLIC ROOFIT_CUDA); endif(). if(fftw3); target_compile_definitions(RooFitCore PUBLIC ROOFIT_MATH_FFTW3); endif(). # To avoid deprecation warnings when including old test statistics headers.; # RooFit has to include them to build the documentation.; target_compile_definitions(RooFitCore PUBLIC ROOFIT_BUILDS_ITSELF). target_include_directories(RooFitCore PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/res>). # For recent clang, this can facilitate auto-vectorisation.; # In RooFit, the errno side effect is not needed, anyway:; if(""${CMAKE_CXX_COMPILER_ID}"" MATCHES ""Clang""); target_compile_options(RooFitCore PUBLIC -fno-math-errno); endif(). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/CMakeLists.txt:11136,test,test,11136,roofit/roofitcore/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/CMakeLists.txt,2,['test'],['test']
Testability," struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an; object are unrelated. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. alpha.core.FixedAddr; (C); Check for assignment of a fixed address to a pointer. void test() {; int *p;; p = (int *) 0x10000; // warn; }. alpha.core.IdenticalExpr; (C, C++); Warn about suspicious uses of identical expressions. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. alpha.core.PointerArithm; (C); Check for pointer arithmetic on locations other than array; elements. void test() {; int x;; int *p;; p = &x + 1; // warn; }. alpha.core.PointerSub; (C); Check for pointer subtractions on two pointers pointing to different memory; chunks. void test() {; int x, y;; int d = &y - &x; // warn; }. alpha.core.SizeofPtr; (C); Warn about unintended use of sizeof() on pointer; expressions. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. alpha.core.StackAddressAsyncEscape; (C); Check that addresses to stack memory do not escape the function that involves; dispatch_after or dispatch_async. This checker is; a part of core.StackAddressEscape, but is; temporarily disable",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:2675,test,test,2675,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['test'],['test']
Testability," supported by clang; (x86_64, arm7, etc.). LLVM Function Attribute; -----------------------. If you're using LLVM IR directly, you can add the ``function-instrument``; string attribute to your functions, to get the similar effect that the; C/C++/Objective-C source-level attributes would get:. .. code-block:: llvm. define i32 @always_instrument() uwtable ""function-instrument""=""xray-always"" {; ; ...; }. define i32 @never_instrument() uwtable ""function-instrument""=""xray-never"" {; ; ...; }. You can also set the ``xray-instruction-threshold`` attribute and provide a; numeric string value for how many instructions should be in the function before; it gets instrumented. .. code-block:: llvm. define i32 @maybe_instrument() uwtable ""xray-instruction-threshold""=""2"" {; ; ...; }. Special Case File; -----------------. Attributes can be imbued through the use of special case files instead of; adding them to the original source files. You can use this to mark certain; functions and classes to be never, always, or instrumented with first-argument; logging from a file. The file's format is described below:. .. code-block:: bash. # Comments are supported; [always]; fun:always_instrument; fun:log_arg1=arg1 # Log the first argument for the function. [never]; fun:never_instrument. These files can be provided through the ``-fxray-attr-list=`` flag to clang.; You may have multiple files loaded through multiple instances of the flag. XRay Runtime Library; --------------------. The XRay Runtime Library is part of the compiler-rt project, which implements; the runtime components that perform the patching and unpatching of inserted; instrumentation points. When you use ``clang`` to link your binaries and the; ``-fxray-instrument`` flag, it will automatically link in the XRay runtime. The default implementation of the XRay runtime will enable XRay instrumentation; before ``main`` starts, which works for applications that have a short; lifetime. This implementation also records all function entr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst:4155,log,logging,4155,interpreter/llvm-project/llvm/docs/XRay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst,1,['log'],['logging']
Testability," supported values are:. - lexical - tests will be run in lexical order according to the test file; path. This option is useful when predictable test order is desired. - random - tests will be run in random order. - smart - tests that failed previously will be run first, then the remaining; tests, all in descending execution time order. This is the default as it; optimizes concurrency. .. option:: --run-shard=N. Select which shard to run, assuming the ``--num-shards=M`` option was; provided. The two options must be used together, and the value of ``N``; must be in the range ``1..M``. The environment variable; ``LIT_RUN_SHARD`` can also be used in place of this option. .. option:: --timeout=N. Spend at most ``N`` seconds (approximately) running each individual test.; ``0`` means no time limit, and ``0`` is the default. Note that this is not an; alias for :option:`--max-time`; the two are different kinds of maximums. .. option:: --filter=REGEXP. Run only those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER`` can be also used in place; of this option, which is especially useful in environments where the call; to ``lit`` is issued indirectly. .. option:: --filter-out=REGEXP. Filter out those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER_OUT`` can be also used in; place of this option, which is especially useful in environments where the; call to ``lit`` is issued indirectly. .. option:: --xfail=LIST. Treat those tests whose name is in the semicolon separated list ``LIST`` as; ``XFAIL``. This can be helpful when one does not want to modify the test; suite. The environment variable ``LIT_XFAIL`` can be also used in place of; this option, which is especially useful in environments where the call to; ``lit`` is issued indirectly. A test name can specified as a file name relative to the test suite directory.; For example:. .. code-block:: none. LIT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:8124,test,tests,8124,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['tests']
Testability," supported. ### The Idea Behind TClonesArray. To reduce the very large number of new and delete calls in large loops; like this (O(100000) x O(10000) times new/delete):. ``` {.cpp}; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; ```. You better use a **`TClonesArray`** which reduces the number of; new/delete calls to only O(10000):. ``` {.cpp}; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; ```. Considering that a pair of new/delete calls on average cost about 70 ms,; O(109) new/deletes will save about 19 hours. For the other collections,; see the class reference guide on the web and the test program; `$ROOTSYS/test/tcollex.cxx.`. ## Template Containers and STL. Some people dislike polymorphic containers because they are not truly; ""type safe"". In the end, the compiler leaves it the user to ensure that; the types are correct. This only leaves the other alternative: creating; a new class each time a new (container organization) / (contained; object) combination is needed. To say the least this could be very; tedious. Most people faced with this choice would, for each type of; container:. Define the class leaving a dummy name for the contained object type.; When a particular container was needed, copy the code and then do a; global search and replace for the contained class. C++ has a built in; template scheme that effectively does just this. For example:. ``` {.cpp}; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; ```. This is an array container with a 10-element array of pointers to T, it; could hold up to 10 T objects.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:17897,test,test,17897,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,2,['test'],['test']
Testability," tail; call wrapper around *F* and replace *G* with that call. 3. Neither *F* nor *G* could be overridden. We can't use *RAUW*. We can just; change the callers: call *F* instead of *G*. That's what; ``replaceDirectCallers`` does. Below is a detailed body description. If “F” may be overridden; ------------------------; As follows from ``mayBeOverridden`` comments: “whether the definition of this; global may be replaced by something non-equivalent at link time”. If so, that's; ok: we can use alias to *F* instead of *G* or change call instructions itself. HasGlobalAliases, removeUsers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; First consider the case when we have global aliases of one function name to; another. Our purpose is make both of them with aliases to the third strong; function. Though if we keep *F* alive and without major changes we can leave it; in ``FnTree``. Try to combine these two goals. Do stub replacement of *F* itself with an alias to *F*. 1. Create stub function *H*, with the same name and attributes like function; *F*. It takes maximum alignment of *F* and *G*. 2. Replace all uses of function *F* with uses of function *H*. It is the two; steps procedure instead. First of all, we must take into account, all functions; from whom *F* is called would be changed: since we change the call argument; (from *F* to *H*). If so we must to review these caller functions again after; this procedure. We remove callers from ``FnTree``, method with name; ``removeUsers(F)`` does that (don't confuse with ``replaceAllUsesWith``):. 2.1. ``Inside removeUsers(Value*; V)`` we go through the all values that use value *V* (or *F* in our context).; If value is instruction, we go to function that holds this instruction and; mark it as to-be-analyzed-again (put to ``Deferred`` set), we also remove; caller from ``FnTree``. 2.2. Now we can do the replacement: call ``F->replaceAllUsesWith(H)``. 3. *H* (that now ""officially"" plays *F*'s role) is replaced with alias to *F*.; Do the same with *",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:28187,stub,stub,28187,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['stub'],['stub']
Testability," target-specific runtime and standard libraries in directories named after the; target (e.g. if you're building with ``--target=aarch64-none-linux-android21``,; Clang will look for ``lib/aarch64-none-linux-android21`` under its resource; directory to find runtime libraries). If an exact match isn't found, Clang; would previously fall back to a directory without any version (which would be; ``lib/aarch64-none-linux-android`` in our example). Clang will now look for; directories for lower versions and use the newest version it finds instead,; e.g. if you have ``lib/aarch64-none-linux-android21`` and; ``lib/aarch64-none-linux-android29``, ``-target aarch64-none-linux-android23``; will use the former and ``-target aarch64-none-linux-android30`` will use the; latter. Falling back to a versionless directory will now emit a warning, and; the fallback will be removed in Clang 19. Windows Support; ^^^^^^^^^^^^^^^; - Fixed an assertion failure that occurred due to a failure to propagate; ``MSInheritanceAttr`` attributes to class template instantiations created; for explicit template instantiation declarations. - The ``-fno-auto-import`` option was added for MinGW targets. The option both; affects code generation (inhibiting generating indirection via ``.refptr``; stubs for potentially auto imported symbols, generating smaller and more; efficient code) and linking (making the linker error out on such cases).; If the option only is used during code generation but not when linking,; linking may succeed but the resulting executables may expose issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:62620,assert,assertion,62620,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['assert'],['assertion']
Testability," target. * ``-DCMAKE_C_COMPILER_TARGET=aarch64-linux-gnu``; * ``-DCOMPILER_RT_EMULATOR=""qemu-aarch64 -L /path/to/aarch64/sysroot``. The CMAKE_C_FLAGS and COMPILER_RT_TEST_COMPILER_CFLAGS may also need:; ``""--sysroot=/path/to/aarch64/sysroot --gcc-toolchain=/path/to/gcc-toolchain""``. Armv6-m, Armv7-m and Armv7E-M targets; -------------------------------------; To build and test the libraries using a similar method to Armv7-A is possible; but more difficult. The main problems are:. * There isn't a ``qemu-arm`` user-mode emulator for bare-metal systems. The ``qemu-system-arm`` can be used but this is significantly more difficult to setup.; * The targets to compile compiler-rt have the suffix -none-eabi. This uses the BareMetal driver in clang and by default won't find the libraries needed to pass the cmake compiler check. As the Armv6-M, Armv7-M and Armv7E-M builds of compiler-rt only use instructions; that are supported on Armv7-A we can still get most of the value of running the; tests using the same ``qemu-arm`` that we used for Armv7-A by building and; running the test cases for Armv7-A but using the builtins compiled for; Armv6-M, Armv7-M or Armv7E-M. This will test that the builtins can be linked; into a binary and execute the tests correctly but it will not catch if the; builtins use instructions that are supported on Armv7-A but not Armv6-M,; Armv7-M and Armv7E-M. To get the cmake compile test to pass you will need to pass the libraries; needed to successfully link the cmake test via ``CMAKE_CFLAGS``. It is; strongly recommended that you use version 3.6 or above of cmake so you can use; ``CMAKE_TRY_COMPILE_TARGET=STATIC_LIBRARY`` to skip the link step. * ``-DCMAKE_TRY_COMPILE_TARGET_TYPE=STATIC_LIBRARY``; * ``-DCOMPILER_RT_OS_DIR=""baremetal""``; * ``-DCOMPILER_RT_BUILD_BUILTINS=ON``; * ``-DCOMPILER_RT_BUILD_SANITIZERS=OFF``; * ``-DCOMPILER_RT_BUILD_XRAY=OFF``; * ``-DCOMPILER_RT_BUILD_LIBFUZZER=OFF``; * ``-DCOMPILER_RT_BUILD_PROFILE=OFF``; * ``-DCMAKE_C_COMPILER=$",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:10129,test,tests,10129,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,2,['test'],"['test', 'tests']"
Testability," test is not fuzzing-friendly. Examples:. - The target code uses a PRNG seeded e.g. by system time and; thus two consequent invocations may potentially execute different code paths; even if the end result will be the same. This will cause a fuzzer to treat; two similar inputs as significantly different and it will blow up the test corpus.; E.g. libxml uses ``rand()`` inside its hash table.; - The target code uses checksums to protect from invalid inputs.; E.g. png checks CRC for every chunk. In many cases it makes sense to build a special fuzzing-friendly build; with certain fuzzing-unfriendly features disabled. We propose to use a common build macro; for all such cases for consistency: ``FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION``. .. code-block:: c++. void MyInitPRNG() {; #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION; // In fuzzing mode the behavior of the code should be deterministic.; srand(0);; #else; srand(time(0));; #endif; }. AFL compatibility; -----------------; LibFuzzer can be used together with AFL_ on the same test corpus.; Both fuzzers expect the test corpus to reside in a directory, one file per input.; You can run both fuzzers on the same corpus, one after another:. .. code-block:: console. ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@; ./llvm-fuzz testcase_dir findings_dir # Will write new tests to testcase_dir. Periodically restart both fuzzers so that they can use each other's findings.; Currently, there is no simple way to run both fuzzing engines in parallel while sharing the same corpus dir. You may also use AFL on your target function ``LLVMFuzzerTestOneInput``:; see an example `here <https://github.com/llvm/llvm-project/tree/main/compiler-rt/lib/fuzzer/afl>`__. How good is my fuzzer?; ----------------------. Once you implement your target function ``LLVMFuzzerTestOneInput`` and fuzz it to death,; you will want to know whether the function or the corpus can be improved further.; One easy to use metric is, of course, code cove",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:22326,test,test,22326,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['test'],['test']
Testability," test suite. For; appropriately configured projects, this allows :program:`lit` to provide; convenient and flexible support for out-of-tree builds. .. _test-status-results:. TEST STATUS RESULTS; -------------------. Each test ultimately produces one of the following eight results:. **PASS**. The test succeeded. **FLAKYPASS**. The test succeeded after being re-run more than once. This only applies to; tests containing an ``ALLOW_RETRIES:`` annotation. **XFAIL**. The test failed, but that is expected. This is used for test formats which allow; specifying that a test does not currently work, but wish to leave it in the test; suite. **XPASS**. The test succeeded, but it was expected to fail. This is used for tests which; were specified as expected to fail, but are now succeeding (generally because; the feature they test was broken and has been fixed). **FAIL**. The test failed. **UNRESOLVED**. The test result could not be determined. For example, this occurs when the test; could not be run, the test itself is invalid, or the test was interrupted. **UNSUPPORTED**. The test is not supported in this environment. This is used by test formats; which can report unsupported tests. **TIMEOUT**. The test was run, but it timed out before it was able to complete. This is; considered a failure. Depending on the test format tests may produce additional information about; their status (generally only for failures). See the :ref:`output-options`; section for more information. .. _lit-infrastructure:. LIT INFRASTRUCTURE; ------------------. This section describes the :program:`lit` testing architecture for users interested in; creating a new :program:`lit` testing implementation, or extending an existing one. :program:`lit` proper is primarily an infrastructure for discovering and running; arbitrary tests, and to expose a single convenient interface to these; tests. :program:`lit` itself doesn't know how to run tests, rather this logic is; defined by *test suites*. TEST SUITES; ~~~~~~~~",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:13144,test,test,13144,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,3,['test'],['test']
Testability," test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // warn; }. Security Checkers. Name, DescriptionExample. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. secu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:21850,test,test,21850,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability," test(int *p) {; if (!p); f(p); // warn; }. .. _core-NullDereference:. core.NullDereference (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereferences of null pointers. This checker specifically does; not report null pointer dereferences for x86 and x86-64 targets when the; address space is 256 (x86 GS Segment), 257 (x86 FS Segment), or 258 (x86 SS; segment). See `X86/X86-64 Language Extensions; <https://clang.llvm.org/docs/LanguageExtensions.html#memory-references-to-specified-segments>`__; for reference. The ``SuppressAddressSpaces`` option suppresses; warnings for null dereferences of all pointers with address spaces. You can; disable this behavior with the option; ``-analyzer-config core.NullDereference:SuppressAddressSpaces=false``.; *Defaults to true*. .. code-block:: objc. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. .. _core-StackAddressEscape:. core.StackAddressEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function. .. code-block:: c. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. .. _core-UndefinedBinaryOperatorResult:. core.UndefinedBinaryOperatorResult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary operators. .. code-block:: c. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. .. _core-VLASize:. core.VLASize (C); """"""""""""""""""""""""""""""""; Check for declarations of Variable Length Arrays of undefined or zero size. Check for declarations of VLA of undefined or zero size. .. code-block:: c. void test",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:4475,test,test,4475,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability," test-suite. The `perf` is usually available on linux systems. - `TEST_SUITE_SPEC2000_ROOT`, `TEST_SUITE_SPEC2006_ROOT`, `TEST_SUITE_SPEC2017_ROOT`, ... Specify installation directories of external benchmark suites. You can find; more information about expected versions or usage in the README files in the; `External` directory (such as `External/SPEC/README`). ### Common CMake Flags. - `-GNinja`. Generate build files for the ninja build tool. - `-Ctest-suite/cmake/caches/<cachefile.cmake>`. Use a CMake cache. The test-suite comes with several CMake caches which; predefine common or tricky build configurations. Displaying and Analyzing Results; --------------------------------. The `compare.py` script displays and compares result files. A result file is; produced when invoking lit with the `-o filename.json` flag. Example usage:. - Basic Usage:. ```text; % test-suite/utils/compare.py baseline.json; Warning: 'test-suite :: External/SPEC/CINT2006/403.gcc/403.gcc.test' has No metrics!; Tests: 508; Metric: exec_time. Program baseline. INT2006/456.hmmer/456.hmmer 1222.90; INT2006/464.h264ref/464.h264ref 928.70; ...; baseline; count 506.000000; mean 20.563098; std 111.423325; min 0.003400; 25% 0.011200; 50% 0.339450; 75% 4.067200; max 1222.896800; ```. - Show compile_time or text segment size metrics:. ```bash; % test-suite/utils/compare.py -m compile_time baseline.json; % test-suite/utils/compare.py -m size.__text baseline.json; ```. - Compare two result files and filter short running tests:. ```bash; % test-suite/utils/compare.py --filter-short baseline.json experiment.json; ...; Program baseline experiment diff. SingleSour.../Benchmarks/Linpack/linpack-pc 5.16 4.30 -16.5%; MultiSourc...erolling-dbl/LoopRerolling-dbl 7.01 7.86 12.2%; SingleSour...UnitTests/Vectorizer/gcc-loops 3.89 3.54 -9.0%; ...; ```. - Merge multiple baseline and experiment result files by taking the minimum; runtime each:. ```bash; % test-suite/utils/compare.py base0.json base1.json base2.json vs exp0",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:7546,test,test,7546,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['test'],['test']
Testability," test.c; $ lldb -- clang -cc1 -analyze -analyzer-checker=core test.c. Otherwise, if your command line contains --analyze,; the actual clang instance would be run in a separate process. In; order to debug it, use the -### flag for obtaining; the command line of the child process:. $ clang --analyze test.c -\#\#\#. Below we describe a few useful command line arguments, all of which assume that; you are running clang -cc1. Narrowing Down the Problem; While investigating a checker-related issue, instruct the analyzer to only; execute a single checker:. $ clang -cc1 -analyze -analyzer-checker=osx.KeychainAPI test.c. If you are experiencing a crash, to see which function is failing while; processing a large file use the -analyzer-display-progress; option.; To selectively analyze only the given function, use the; -analyze-function option:. $ clang -cc1 -analyze -analyzer-checker=core test.c -analyzer-display-progress; ANALYZE (Syntax): test.c foo; ANALYZE (Syntax): test.c bar; ANALYZE (Path, Inline_Regular): test.c bar; ANALYZE (Path, Inline_Regular): test.c foo; $ clang -cc1 -analyze -analyzer-checker=core test.c -analyzer-display-progress -analyze-function=foo; ANALYZE (Syntax): test.c foo; ANALYZE (Path, Inline_Regular): test.c foo. Note: a fully qualified function name has to be used when selecting; C++ functions and methods, Objective-C methods and blocks, e.g.:. $ clang -cc1 -analyze -analyzer-checker=core test.cc -analyze-function='foo(int)'. The fully qualified name can be found from the; -analyzer-display-progress output. The bug reporter mechanism removes path diagnostics inside intermediate; function calls that have returned by the time the bug was found and contain; no interesting pieces. Usually it is up to the checkers to produce more; interesting pieces by adding custom BugReporterVisitor objects.; However, you can disable path pruning while debugging with the; -analyzer-config prune-paths=false option. Visualizing the Analysis; To dump the AST, which often ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:20040,test,test,20040,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['test'],['test']
Testability," test.cl; $ clang -cl-std=CL2.0 -cl-no-stdinc test.cl; error: use of undeclared identifier 'get_enqueued_local_size'; error: use of undeclared identifier 'get_local_size'. More information about the standard types and functions is provided in :ref:`the; section on the OpenCL Header <opencl_header>`. .. _opencl_cl_ext:. .. option:: -cl-ext. Enables/Disables support of OpenCL extensions and optional features. All OpenCL; targets set a list of extensions that they support. Clang allows to amend this using; the ``-cl-ext`` flag with a comma-separated list of extensions prefixed with; ``'+'`` or ``'-'``. The syntax: ``-cl-ext=<(['-'|'+']<extension>[,])+>``, where; extensions can be either one of `the OpenCL published extensions; <https://www.khronos.org/registry/OpenCL>`_; or any vendor extension. Alternatively, ``'all'`` can be used to enable; or disable all known extensions. Example disabling double support for the 64-bit SPIR-V target:. .. code-block:: console. $ clang -c --target=spirv64 -cl-ext=-cl_khr_fp64 test.cl. Enabling all extensions except double support in R600 AMD GPU can be done using:. .. code-block:: console. $ clang --target=r600 -cl-ext=-all,+cl_khr_fp16 test.cl. Note that some generic targets e.g. SPIR/SPIR-V enable all extensions/features in; clang by default. OpenCL Targets; --------------. OpenCL targets are derived from the regular Clang target classes. The OpenCL; specific parts of the target representation provide address space mapping as; well as a set of supported extensions. Specific Targets; ^^^^^^^^^^^^^^^^. There is a set of concrete HW architectures that OpenCL can be compiled for. - For AMD target:. .. code-block:: console. $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. - For Nvidia architectures:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl. Generic Targets; ^^^^^^^^^^^^^^^. - A SPIR-V binary can be produced for 32 or 64 bit targets. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:144401,test,test,144401,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['test'],['test']
Testability," that will be scanned for tests. **test_exec_root** For out-of-dir builds, the path to the test suite root inside; the object directory. This is where tests will be run and temporary output files; placed. **environment** A dictionary representing the environment to use when executing; tests in the suite. **standalone_tests** When true, mark a directory with tests expected to be run; standalone. Test discovery is disabled for that directory. *lit.suffixes* and; *lit.excludes* must be empty when this variable is true. **suffixes** For **lit** test formats which scan directories for tests, this; variable is a list of suffixes to identify test files. Used by: *ShTest*. **substitutions** For **lit** test formats which substitute variables into a test; script, the list of substitutions to perform. Used by: *ShTest*. **unsupported** Mark an unsupported directory, all tests within it will be; reported as unsupported. Used by: *ShTest*. **parent** The parent configuration, this is the config object for the directory; containing the test suite, or None. **root** The root configuration. This is the top-most :program:`lit` configuration in; the project. **pipefail** Normally a test using a shell pipe fails if any of the commands; on the pipe fail. If this is not desired, setting this variable to false; makes the test fail only if the last command in the pipe fails. **available_features** A set of features that can be used in `XFAIL`,; `REQUIRES`, and `UNSUPPORTED` directives. TEST DISCOVERY; ~~~~~~~~~~~~~~. Once test suites are located, :program:`lit` recursively traverses the source; directory (following *test_source_root*) looking for tests. When :program:`lit`; enters a sub-directory, it first checks to see if a nested test suite is; defined in that directory. If so, it loads that test suite recursively,; otherwise it instantiates a local test config for the directory (see; :ref:`local-configuration-files`). Tests are identified by the test suite they are contained within, a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:16937,test,test,16937,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['test']
Testability," that work. * The remaining inter-related work should be decomposed into unrelated sets of; changes if possible. Once this is done, define the first increment and get; consensus on what the end goal of the change is. * Each change in the set can be stand alone (e.g. to fix a bug), or part of a; planned series of changes that works towards the development goal. * Each change should be kept as small as possible. This simplifies your work; (into a logical progression), simplifies code review and reduces the chance; that you will get negative feedback on the change. Small increments also; facilitate the maintenance of a high quality code base. * Often, an independent precursor to a big change is to add a new API and slowly; migrate clients to use the new API. Each change to use the new API is often; ""obvious"" and can be committed without review. Once the new API is in place; and used, it is much easier to replace the underlying implementation of the; API. This implementation change is logically separate from the API; change. If you are interested in making a large change, and this scares you, please make; sure to first `discuss the change/gather consensus`_ then ask about the best way; to go about making the change. Attribution of Changes; ----------------------. When contributors submit a patch to an LLVM project, other developers with; commit access may commit it for the author once appropriate (based on the; progression of code review, etc.). When doing so, it is important to retain; correct attribution of contributions to their contributors. However, we do not; want the source code to be littered with random attributions ""this code written; by J. Random Hacker"" (this is noisy and distracting). In practice, the revision; control system keeps a perfect history of who changed what, and the CREDITS.txt; file describes higher-level contributions. If you commit a patch for someone; else, please follow the attribution of changes in the simple manner as outlined; by the `com",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:29356,log,logically,29356,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['log'],['logically']
Testability," the ""abort"" implementation. Use ``llvm_unreachable`` to mark a specific point in code that should never be; reached. This is especially desirable for addressing warnings about unreachable; branches, etc., but can be used whenever reaching a particular code path is; unconditionally a bug (not originating from user input; see below) of some kind.; Use of ``assert`` should always include a testable predicate (as opposed to; ``assert(false)``). If the error condition can be triggered by user input then the; recoverable error mechanism described in :doc:`ProgrammersManual` should be; used instead. In cases where this is not practical, ``report_fatal_error`` may; be used. Another issue is that values used only by assertions will produce an ""unused; value"" warning when assertions are disabled. For example, this code will warn:. .. code-block:: c++. unsigned Size = V.size();; assert(Size > 42 && ""Vector smaller than it should be"");. bool NewToSet = Myset.insert(Value);; assert(NewToSet && ""The value shouldn't be in the set yet"");. These are two interesting different cases. In the first case, the call to; ``V.size()`` is only useful for the assert, and we don't want it executed when; assertions are disabled. Code like this should move the call into the assert; itself. In the second case, the side effects of the call must happen whether; the assert is enabled or not. In this case, the value should be cast to void to; disable the warning. To be specific, it is preferred to write the code like; this:. .. code-block:: c++. assert(V.size() > 42 && ""Vector smaller than it should be"");. bool NewToSet = Myset.insert(Value); (void)NewToSet;; assert(NewToSet && ""The value shouldn't be in the set yet"");. Do Not Use ``using namespace std``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In LLVM, we prefer to explicitly prefix all identifiers from the standard; namespace with an ""``std::``"" prefix, rather than rely on ""``using namespace; std;``"". In header files, adding a ``'using namespace XXX'`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:48019,assert,assert,48019,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['assert'],['assert']
Testability," the *repl*; record if the *target* record name equals the *value* record name; otherwise it; produces the *value*. ``!substr(``\ *string*\ ``,`` *start*\ [``,`` *length*]\ ``)``; This operator extracts a substring of the given *string*. The starting; position of the substring is specified by *start*, which can range; between 0 and the length of the string. The length of the substring; is specified by *length*; if not specified, the rest of the string is; extracted. The *start* and *length* arguments must be integers. ``!tail(``\ *a*\ ``)``; This operator produces a new list with all the elements; of the list *a* except for the zeroth one. (See also ``!head``.). ``!tolower(``\ *a*\ ``)``; This operator converts a string input *a* to lower case. ``!toupper(``\ *a*\ ``)``; This operator converts a string input *a* to upper case. ``!xor(``\ *a*\ ``,`` *b*\ ``, ...)``; This operator does a bitwise EXCLUSIVE OR on *a*, *b*, etc., and produces; the result. A logical XOR can be performed if all the arguments are either; 0 or 1. Appendix B: Paste Operator Examples; ===================================. Here is an example illustrating the use of the paste operator in record names. .. code-block:: text. defvar suffix = ""_suffstring"";; defvar some_ints = [0, 1, 2, 3];. def name # suffix {; }. foreach i = [1, 2] in {; def rec # i {; }; }. The first ``def`` does not use the value of the ``suffix`` variable. The; second def does use the value of the ``i`` iterator variable, because it is not a; global name. The following records are produced. .. code-block:: text. def namesuffix {; }; def rec1 {; }; def rec2 {; }. Here is a second example illustrating the paste operator in field value expressions. .. code-block:: text. def test {; string strings = suffix # suffix;; list<int> integers = some_ints # [4, 5, 6];; }. The ``strings`` field expression uses ``suffix`` on both sides of the paste; operator. It is evaluated normally on the left hand side, but taken verbatim; on the right han",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:73739,log,logical,73739,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['log'],['logical']
Testability," the Objective-C methods; associated with that selector into the appropriate front-end data structure; (``Sema::InstanceMethodPool`` and ``Sema::FactoryMethodPool`` for instance and; class methods, respectively). As with identifiers, selectors are represented by numeric values within the AST; file. A separate index maps these numeric selector values to the offset of the; selector within the on-disk hash table, and will be used when de-serializing an; Objective-C method declaration (or other Objective-C construct) that refers to; the selector. AST Reader Integration Points; -----------------------------. The ""lazy"" deserialization behavior of AST files requires their integration; into several completely different submodules of Clang. For example, lazily; deserializing the declarations during name lookup requires that the name-lookup; routines be able to query the AST file to find entities stored there. For each Clang data structure that requires direct interaction with the AST; reader logic, there is an abstract class that provides the interface between; the two modules. The ``ASTReader`` class, which handles the loading of an AST; file, inherits from all of these abstract classes to provide lazy; deserialization of Clang's data structures. ``ASTReader`` implements the; following abstract classes:. ``ExternalSLocEntrySource``; This abstract interface is associated with the ``SourceManager`` class, and; is used whenever the :ref:`source manager <pchinternals-sourcemgr>` needs to; load the details of a file, buffer, or macro instantiation. ``IdentifierInfoLookup``; This abstract interface is associated with the ``IdentifierTable`` class, and; is used whenever the program source refers to an identifier that has not yet; been seen. In this case, the AST reader searches for this identifier within; its :ref:`identifier table <pchinternals-ident-table>` to load any top-level; declarations or macros associated with that identifier. ``ExternalASTSource``; This abstract interf",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:21890,log,logic,21890,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['log'],['logic']
Testability," the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option as a way to; validate diagnostic behavior. This option will use special comments within the; test file to verify that expected diagnostics appear in the correct source; locations. If all of the expected diagnostics match the actual output of Clang,; then the invocation will return normally. If there are discrepancies between; the expected and actual output, Clang will emit detailed information about; which expected diagnostics were not seen or which unexpected diagnostics were; seen, etc. A complete example is:. .. code-block: c++. // RUN: %clang_cc1 -verify %s; int A = B; // expected-error {{use of undeclared identifier 'B'}}. If the test is run and the expected error is emitted on the expected line",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:154321,test,test,154321,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['test'],['test']
Testability," the actual documentation itself.; Additionally, it can specify a custom heading for the attribute, though a; default heading will be chosen when possible. There are four predefined documentation categories: ``DocCatFunction`` for; attributes that appertain to function-like subjects, ``DocCatVariable`` for; attributes that appertain to variable-like subjects, ``DocCatType`` for type; attributes, and ``DocCatStmt`` for statement attributes. A custom documentation; category should be used for groups of attributes with similar functionality.; Custom categories are good for providing overview information for the attributes; grouped under it. For instance, the consumed annotation attributes define a; custom category, ``DocCatConsumed``, that explains what consumed annotations are; at a high level. Documentation content (whether it is for an attribute or a category) is written; using reStructuredText (RST) syntax. After writing the documentation for the attribute, it should be locally tested; to ensure that there are no issues generating the documentation on the server.; Local testing requires a fresh build of clang-tblgen. To generate the attribute; documentation, execute the following command::. clang-tblgen -gen-attr-docs -I /path/to/clang/include /path/to/clang/include/clang/Basic/Attr.td -o /path/to/clang/docs/AttributeReference.rst. When testing locally, *do not* commit changes to ``AttributeReference.rst``.; This file is generated by the server automatically, and any changes made to this; file will be overwritten. Arguments; ~~~~~~~~~; Attributes may optionally specify a list of arguments that can be passed to the; attribute. Attribute arguments specify both the parsed form and the semantic; form of the attribute. For example, if ``Args`` is; ``[StringArgument<""Arg1"">, IntArgument<""Arg2"">]`` then; ``__attribute__((myattribute(""Hello"", 3)))`` will be a valid use; it requires; two arguments while parsing, and the Attr subclass' constructor for the; semantic attribute ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:136015,test,tested,136015,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['test'],['tested']
Testability," the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any selection or with only a single one, it was not easy to; understand. ![Several selections can be defined each of them having its own color.](pictures/para8.png). Interactive selections on Parallel Coordinates are a powerful tool because; they can be defined graphically on many variables (graphical cuts in ROOT can; be defined on two variables only) which allow",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:100492,log,logical,100492,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,2,['log'],['logical']
Testability," the check-llvm-unit target:. .. code-block:: bash. % make check-llvm-unit. To run all of the LLVM regression tests use the check-llvm target:. .. code-block:: bash. % make check-llvm. In order to get reasonable testing performance, build LLVM and subprojects; in release mode, i.e. .. code-block:: bash. % cmake -DCMAKE_BUILD_TYPE=""Release"" -DLLVM_ENABLE_ASSERTIONS=On. If you have `Clang <https://clang.llvm.org/>`_ checked out and built, you; can run the LLVM and Clang tests simultaneously using:. .. code-block:: bash. % make check-all. To run the tests with Valgrind (Memcheck by default), use the ``LIT_ARGS`` make; variable to pass the required options to lit. For example, you can use:. .. code-block:: bash. % make check LIT_ARGS=""-v --vg --vg-leak"". to enable testing with valgrind and with leak checking enabled. To run individual tests or subsets of tests, you can use the ``llvm-lit``; script which is built as part of LLVM. For example, to run the; ``Integer/BitPacked.ll`` test by itself you can run:. .. code-block:: bash. % llvm-lit ~/llvm/test/Integer/BitPacked.ll. or to run all of the ARM CodeGen tests:. .. code-block:: bash. % llvm-lit ~/llvm/test/CodeGen/ARM. The regression tests will use the Python psutil module only if installed in a; **non-user** location. Under Linux, install with sudo or within a virtual; environment. Under Windows, install Python for all users and then run; ``pip install psutil`` in an elevated command prompt. For more information on using the :program:`lit` tool, see ``llvm-lit --help``; or the :doc:`lit man page <CommandGuide/lit>`. Debugging Information tests; ---------------------------. To run debugging information tests simply add the ``cross-project-tests``; project to your ``LLVM_ENABLE_PROJECTS`` define on the cmake; command-line. Regression test structure; =========================. The LLVM regression tests are driven by :program:`lit` and are located in the; ``llvm/test`` directory. This directory contains a large array of sma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:6094,test,test,6094,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['test']
Testability," the config object for the directory; containing the test suite, or None. **root** The root configuration. This is the top-most :program:`lit` configuration in; the project. **pipefail** Normally a test using a shell pipe fails if any of the commands; on the pipe fail. If this is not desired, setting this variable to false; makes the test fail only if the last command in the pipe fails. **available_features** A set of features that can be used in `XFAIL`,; `REQUIRES`, and `UNSUPPORTED` directives. TEST DISCOVERY; ~~~~~~~~~~~~~~. Once test suites are located, :program:`lit` recursively traverses the source; directory (following *test_source_root*) looking for tests. When :program:`lit`; enters a sub-directory, it first checks to see if a nested test suite is; defined in that directory. If so, it loads that test suite recursively,; otherwise it instantiates a local test config for the directory (see; :ref:`local-configuration-files`). Tests are identified by the test suite they are contained within, and the; relative path inside that suite. Note that the relative path may not refer to; an actual file on disk; some test formats (such as *GoogleTest*) define; ""virtual tests"" which have a path that contains both the path to the actual; test file and a subpath to identify the virtual test. .. _local-configuration-files:. LOCAL CONFIGURATION FILES; ~~~~~~~~~~~~~~~~~~~~~~~~~. When :program:`lit` loads a subdirectory in a test suite, it instantiates a; local test configuration by cloning the configuration for the parent directory; --- the root of this configuration chain will always be a test suite. Once the; test configuration is cloned :program:`lit` checks for a *lit.local.cfg* file; in the subdirectory. If present, this file will be loaded and can be used to; specialize the configuration for each individual directory. This facility can; be used to define subdirectories of optional tests, or to change other; configuration parameters --- for example, to change the test for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:17859,test,test,17859,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['test']
Testability," the fact that symbol names in the; LLVM symbol table are allowed to have any character in them, including; embedded nul characters. The next interesting thing to add, is codegen support for these binary; operators. Given our current structure, this is a simple addition of a; default case for our existing binary operator node:. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, R, ""multmp"");; case '<':; L = Builder->CreateFCmpULT(L, R, ""cmptmp"");; // Convert bool 0/1 to double 0.0 or 1.0; return Builder->CreateUIToFP(L, Type::getDoubleTy(*TheContext),; ""booltmp"");; default:; break;; }. // If it wasn't a builtin binary operator, it must be a user defined one. Emit; // a call to it.; Function *F = getFunction(std::string(""binary"") + Op);; assert(F && ""binary operator not found!"");. Value *Ops[2] = { L, R };; return Builder->CreateCall(F, Ops, ""binop"");; }. As you can see above, the new code is actually really simple. It just; does a lookup for the appropriate operator in the symbol table and; generates a function call to it. Since user-defined operators are just; built as normal functions (because the ""prototype"" boils down to a; function with the right name) everything falls into place. The final piece of code we are missing, is a bit of top-level magic:. .. code-block:: c++. Function *FunctionAST::codegen() {; // Transfer ownership of the prototype to the FunctionProtos map, but keep a; // reference to it for use below.; auto &P = *Proto;; FunctionProtos[Proto->getName()] = std::move(Proto);; Function *TheFunction = getFunction(P.getName());; if (!TheFunction); return nullptr;. // If this is an operator, install it.; if (P.isBinaryOp()); BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence();. // Create",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst:8633,assert,assert,8633,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl06.rst,1,['assert'],['assert']
Testability," the features, so that buildbots that; run on different architectures (and don't even compile all back-ends),; don't fail. The first problem is to check for target-specific output, for example sizes; of structures, paths and architecture names, for example:. * Tests containing Windows paths will fail on Linux and vice-versa.; * Tests that check for ``x86_64`` somewhere in the text will fail anywhere else.; * Tests where the debug information calculates the size of types and structures. Also, if the test rely on any behaviour that is coded in any back-end, it must; go in its own directory. So, for instance, code generator tests for ARM go; into ``test/CodeGen/ARM`` and so on. Those directories contain a special; ``lit`` configuration file that ensure all tests in that directory will; only run if a specific back-end is compiled and available. For instance, on ``test/CodeGen/ARM``, the ``lit.local.cfg`` is:. .. code-block:: python. config.suffixes = ['.ll', '.c', '.cpp', '.test']; if not 'ARM' in config.root.targets:; config.unsupported = True. Other platform-specific tests are those that depend on a specific feature; of a specific sub-architecture, for example only to Intel chips that support ``AVX2``. For instance, ``test/CodeGen/X86/psubus.ll`` tests three sub-architecture; variants:. .. code-block:: llvm. ; RUN: llc -mcpu=core2 < %s | FileCheck %s -check-prefix=SSE2; ; RUN: llc -mcpu=corei7-avx < %s | FileCheck %s -check-prefix=AVX1; ; RUN: llc -mcpu=core-avx2 < %s | FileCheck %s -check-prefix=AVX2. And the checks are different:. .. code-block:: llvm. ; SSE2: @test1; ; SSE2: psubusw LCPI0_0(%rip), %xmm0; ; AVX1: @test1; ; AVX1: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0; ; AVX2: @test1; ; AVX2: vpsubusw LCPI0_0(%rip), %xmm0, %xmm0. So, if you're testing for a behaviour that you know is platform-specific or; depends on special features of sub-architectures, you must add the specific; triple, test with the specific FileCheck and put it into the specific; directory that will",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:18439,test,test,18439,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['test']
Testability," the following:. target datalayout = ""e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128-S128""; target triple = ""i386-apple-darwin8""; @in_exit.4870.b = internal global i1 false		; <i1*> [#uses=2]; define fastcc void @abort_gzip() noreturn nounwind {; entry:; 	%tmp.b.i = load i1* @in_exit.4870.b		; <i1> [#uses=1]; 	br i1 %tmp.b.i, label %bb.i, label %bb4.i; bb.i:		; preds = %entry; 	tail call void @exit( i32 1 ) noreturn nounwind ; 	unreachable; bb4.i:		; preds = %entry; 	store i1 true, i1* @in_exit.4870.b; 	tail call void @exit( i32 1 ) noreturn nounwind ; 	unreachable; }; declare void @exit(i32) noreturn nounwind . This compiles into:; _abort_gzip: ## @abort_gzip; ## %bb.0: ## %entry; 	subl	$12, %esp; 	movb	_in_exit.4870.b, %al; 	cmpb	$1, %al; 	jne	LBB0_2. We somehow miss folding the movb into the cmpb. //===---------------------------------------------------------------------===//. We compile:. int test(int x, int y) {; return x-y-1;; }. into (-m64):. _test:; 	decl	%edi; 	movl	%edi, %eax; 	subl	%esi, %eax; 	ret. it would be better to codegen as: x+~y (notl+addl). //===---------------------------------------------------------------------===//. This code:. int foo(const char *str,...); {; __builtin_va_list a; int x;; __builtin_va_start(a,str); x = __builtin_va_arg(a,int); __builtin_va_end(a);; return x;; }. gets compiled into this on x86-64:; 	subq $200, %rsp; movaps %xmm7, 160(%rsp); movaps %xmm6, 144(%rsp); movaps %xmm5, 128(%rsp); movaps %xmm4, 112(%rsp); movaps %xmm3, 96(%rsp); movaps %xmm2, 80(%rsp); movaps %xmm1, 64(%rsp); movaps %xmm0, 48(%rsp); movq %r9, 40(%rsp); movq %r8, 32(%rsp); movq %rcx, 24(%rsp); movq %rdx, 16(%rsp); movq %rsi, 8(%rsp); leaq (%rsp), %rax; movq %rax, 192(%rsp); leaq 208(%rsp), %rax; movq %rax, 184(%rsp); movl $48, 180(%rsp); movl $8, 176(%rsp); movl 176(%rsp), %eax; cmpl $47, %eax; jbe .LBB1_3 # bb; .LBB1_1: # bb3; movq 184(%rsp), %rcx; leaq 8(%rcx), %rax; movq %rax,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:26504,test,test,26504,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['test'],['test']
Testability," the following:. void foo(int *p) {; (__builtin_expect(!(p != NULL), 0) ? __assert_rtn(__func__, ""t.c"", 4, ""p != NULL"") : (void)0);; }. In this example, the assertion handler is __assert_rtn. When called,; most assertion handlers typically print an error and terminate the program. The; analyzer can exploit such semantics by ending the analysis of a path once it; hits a call to an assertion handler.; The trick, however, is that the analyzer needs to know that a called function; is an assertion handler; otherwise the analyzer might assume the function call; returns and it will continue analyzing the path where the assertion condition; failed. This can lead to false positives, as the assertion condition usually; implies a safety condition (e.g., a pointer is not null) prior to performing; some action that depends on that condition (e.g., dereferencing a pointer).; The analyzer knows about several well-known assertion handlers, but can; automatically infer if a function should be treated as an assertion handler if; it is annotated with the 'noreturn' attribute or the (Clang-specific); 'analyzer_noreturn' attribute. Note that, currently, clang does not support; these attributes on Objective-C methods and C++ methods.; Attribute 'noreturn'; The 'noreturn' attribute is a GCC-attribute that can be placed on the; declarations of functions. It means exactly what its name implies: a function; with a 'noreturn' attribute should never return.; Specific details of the syntax of using the 'noreturn' attribute can be found; in GCC's; documentation.; Not only does the analyzer exploit this information when pruning false paths,; but the compiler also takes it seriously and will generate different code (and; possibly better optimized) under the assumption that the function does not; return.; Example; On Mac OS X, the function prototype for __assert_rtn (declared in; assert.h) is specifically annotated with the 'noreturn' attribute:. void __assert_rtn(const char *, const char *, int, c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:21527,assert,assertion,21527,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,2,['assert'],['assertion']
Testability," the fuzz target with ASAN; clang -g -O1 -fsanitize=fuzzer,signed-integer-overflow mytarget.c # Builds the fuzz target with a part of UBSAN; clang -g -O1 -fsanitize=fuzzer,memory mytarget.c # Builds the fuzz target with MSAN. This will perform the necessary instrumentation, as well as linking with the libFuzzer library.; Note that ``-fsanitize=fuzzer`` links in the libFuzzer's ``main()`` symbol. If modifying ``CFLAGS`` of a large project, which also compiles executables; requiring their own ``main`` symbol, it may be desirable to request just the; instrumentation without linking::. clang -fsanitize=fuzzer-no-link mytarget.c. Then libFuzzer can be linked to the desired driver by passing in; ``-fsanitize=fuzzer`` during the linking stage. .. _libfuzzer-corpus:. Corpus; ------. Coverage-guided fuzzers like libFuzzer rely on a corpus of sample inputs for the; code under test. This corpus should ideally be seeded with a varied collection; of valid and invalid inputs for the code under test; for example, for a graphics; library the initial corpus might hold a variety of different small PNG/JPG/GIF; files. The fuzzer generates random mutations based around the sample inputs in; the current corpus. If a mutation triggers execution of a previously-uncovered; path in the code under test, then that mutation is saved to the corpus for; future variations. LibFuzzer will work without any initial seeds, but will be less; efficient if the library under test accepts complex,; structured inputs. The corpus can also act as a sanity/regression check, to confirm that the; fuzzing entrypoint still works and that all of the sample inputs run through; the code under test without problems. If you have a large corpus (either generated by fuzzing or acquired by other means); you may want to minimize it while still preserving the full coverage. One way to do that; is to use the `-merge=1` flag:. .. code-block:: console. mkdir NEW_CORPUS_DIR # Store minimized corpus here.; ./my_fuzzer -merge=1 ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:4266,test,test,4266,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['test'],['test']
Testability," the in-tree subdirectory for an external project; exists (e.g., llvm/tools/clang for Clang), then the corresponding variable; will not be used. If the variable for an external project does not point; to a valid path, then that project will not be built. **LLVM_EXTERNAL_PROJECTS**:STRING; Semicolon-separated list of additional external projects to build as part of; llvm. For each project LLVM_EXTERNAL_<NAME>_SOURCE_DIR have to be specified; with the path for the source code of the project. Example:; ``-DLLVM_EXTERNAL_PROJECTS=""Foo;Bar""; -DLLVM_EXTERNAL_FOO_SOURCE_DIR=/src/foo; -DLLVM_EXTERNAL_BAR_SOURCE_DIR=/src/bar``. **LLVM_EXTERNALIZE_DEBUGINFO**:BOOL; Generate dSYM files and strip executables and libraries (Darwin Only).; Defaults to OFF. **LLVM_FORCE_USE_OLD_TOOLCHAIN**:BOOL; If enabled, the compiler and standard library versions won't be checked. LLVM; may not compile at all, or might fail at runtime due to known bugs in these; toolchains. **LLVM_INCLUDE_BENCHMARKS**:BOOL; Generate build targets for the LLVM benchmarks. Defaults to ON. **LLVM_INCLUDE_EXAMPLES**:BOOL; Generate build targets for the LLVM examples. Defaults to ON. You can use this; option to disable the generation of build targets for the LLVM examples. **LLVM_INCLUDE_TESTS**:BOOL; Generate build targets for the LLVM unit tests. Defaults to ON. You can use; this option to disable the generation of build targets for the LLVM unit; tests. **LLVM_INCLUDE_TOOLS**:BOOL; Generate build targets for the LLVM tools. Defaults to ON. You can use this; option to disable the generation of build targets for the LLVM tools. **LLVM_INSTALL_BINUTILS_SYMLINKS**:BOOL; Install symlinks from the binutils tool names to the corresponding LLVM tools.; For example, ar will be symlinked to llvm-ar. **LLVM_INSTALL_CCTOOLS_SYMLINKS**:BOOL; Install symliks from the cctools tool names to the corresponding LLVM tools.; For example, lipo will be symlinked to llvm-lipo. **LLVM_INSTALL_OCAMLDOC_HTML_DIR**:STRING; The path to inst",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:28008,benchmark,benchmarks,28008,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['benchmark'],['benchmarks']
Testability," the inputs into test suites it traverses the; list of inputs adding tests for individual files and recursively searching for; tests in directories. This behavior makes it easy to specify a subset of tests to run, while still; allowing the test suite configuration to control exactly how tests are; interpreted. In addition, :program:`lit` always identifies tests by the test; suite they are in, and their relative path inside the test suite. For; appropriately configured projects, this allows :program:`lit` to provide; convenient and flexible support for out-of-tree builds. .. _test-status-results:. TEST STATUS RESULTS; -------------------. Each test ultimately produces one of the following eight results:. **PASS**. The test succeeded. **FLAKYPASS**. The test succeeded after being re-run more than once. This only applies to; tests containing an ``ALLOW_RETRIES:`` annotation. **XFAIL**. The test failed, but that is expected. This is used for test formats which allow; specifying that a test does not currently work, but wish to leave it in the test; suite. **XPASS**. The test succeeded, but it was expected to fail. This is used for tests which; were specified as expected to fail, but are now succeeding (generally because; the feature they test was broken and has been fixed). **FAIL**. The test failed. **UNRESOLVED**. The test result could not be determined. For example, this occurs when the test; could not be run, the test itself is invalid, or the test was interrupted. **UNSUPPORTED**. The test is not supported in this environment. This is used by test formats; which can report unsupported tests. **TIMEOUT**. The test was run, but it timed out before it was able to complete. This is; considered a failure. Depending on the test format tests may produce additional information about; their status (generally only for failures). See the :ref:`output-options`; section for more information. .. _lit-infrastructure:. LIT INFRASTRUCTURE; ------------------. This section describes ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:12688,test,test,12688,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,3,['test'],['test']
Testability," the loop trip count, and also test that the given count is not zero, allowing; it to control entry to a while-loop. They are placed in the loop preheader's; predecessor basic block, and are marked as ``IntrNoDuplicate`` to avoid; optimizers duplicating these instructions. Arguments:; """""""""""""""""""". The integer operand is the loop trip count of the hardware-loop, and thus; not e.g. the loop back-edge taken count. Semantics:; """""""""""""""""""". The '``llvm.test.set.loop.iterations.*``' intrinsics do not perform any; arithmetic on their operand. It's a hint to the backend that can use this to; set up the hardware-loop count with a target specific instruction, usually a; move of this value to a special register or a hardware-loop instruction.; The result is the conditional value of whether the given count is not zero. '``llvm.test.start.loop.iterations.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. ::. declare {i32, i1} @llvm.test.start.loop.iterations.i32(i32); declare {i64, i1} @llvm.test.start.loop.iterations.i64(i64). Overview:; """""""""""""""""". The '``llvm.test.start.loop.iterations.*``' intrinsics are similar to the; '``llvm.test.set.loop.iterations.*``' and '``llvm.start.loop.iterations.*``'; intrinsics, used to specify the hardware-loop trip count, but also produce a; value identical to the input that can be used as the input to the loop. The; second i1 output controls entry to a while-loop. Arguments:; """""""""""""""""""". The integer operand is the loop trip count of the hardware-loop, and thus; not e.g. the loop back-edge taken count. Semantics:; """""""""""""""""""". The '``llvm.test.start.loop.iterations.*``' intrinsics do not perform any; arithmetic on their operand. It's a hint to the backend that can use this to; set up the hardware-loop count with a target specific instruction, usually a; move of this value to a special register or a hardware-loop instruction.; The result is a pair of the input and a conditional value",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:646590,test,test,646590,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['test'],['test']
Testability," the preservation of; pre-existing debug info metadata. It could be run as follows:. .. code-block:: bash. # Run the pass by checking original Debug Info preservation.; $ opt -verify-debuginfo-preserve -pass-to-test sample.ll. # Check the preservation of original Debug Info after each pass.; $ opt -verify-each-debuginfo-preserve -O2 sample.ll. Limit number of observed functions to speed up the analysis:. .. code-block:: bash. # Test up to 100 functions (per compile unit) per pass.; $ opt -verify-each-debuginfo-preserve -O2 -debugify-func-limit=100 sample.ll. Please do note that running ``-verify-each-debuginfo-preserve`` on big projects; could be heavily time consuming. Therefore, we suggest using; ``-debugify-func-limit`` with a suitable limit number to prevent extremely long; builds. Furthermore, there is a way to export the issues that have been found into; a JSON file as follows:. .. code-block:: bash. $ opt -verify-debuginfo-preserve -verify-di-preserve-export=sample.json -pass-to-test sample.ll. and then use the ``llvm/utils/llvm-original-di-preservation.py`` script; to generate an HTML page with the issues reported in a more human readable form; as follows:. .. code-block:: bash. $ llvm-original-di-preservation.py sample.json sample.html. Testing of original debug info preservation can be invoked from front-end level; as follows:. .. code-block:: bash. # Test each pass.; $ clang -Xclang -fverify-debuginfo-preserve -g -O2 sample.c. # Test each pass and export the issues report into the JSON file.; $ clang -Xclang -fverify-debuginfo-preserve -Xclang -fverify-debuginfo-preserve-export=sample.json -g -O2 sample.c. Please do note that there are some known false positives, for source locations; and debug intrinsic checking, so that will be addressed as a future work. Mutation testing for MIR-level transformations; ----------------------------------------------. A variant of the ``debugify`` utility described in; :ref:`Mutation testing for IR-level transformations<I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:14860,test,test,14860,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,1,['test'],['test']
Testability," the resident and virtual; memory of a proofserv using 'ulimit', which has less limitations and; more flexibility than setrlimit.; Deactivate workers when the requested packages could not be enabled properly.; Add support for reconfiguring the group manager and the; {env,rootrc} settings. The related configuration files are checked for; changes during the regular checks done by the XrdProofdManager.; Add support for selective definition of env and rootrc; variables. Different values can be set for different users, groups, SVN; versions or ROOT versions.; Improve the diagnostic in case of exceptions. Information; about the event and file being processed at the moment the exception; was raised is sent to the client, e.g.;    0.5: caught exception triggered by signal '1' while; processing dset:'EventTree',; file:'http://root.cern.ch/files/data/event_3.root', event:1 - check; logs for possible stacktrace; The patch also fixes a problem with submergers observed when a worker; was stopped because above the memory limits: this worker was; established as merger but could not do the work, for obvious reasons,; freezing the session.; Add two new methods to TProof: ShowMissingFiles() to facilitate; the display of the list of missing files; and GetMissingFiles() to get; a TFileCollection (dataset) with the missing files for further; processing. Fixes. Fix a bug in error status transmission which avoid; session freezing in some cases; FIx; a few issues in libXrdProofd.so with handling of connection used for; admin operation: this should solve some cases where the daemon was not; responding. ; Fix a few memory leaks showing up when; running several queries in the same session; Fix a few issues affecting the new sub-merging option; Fix an issue preventing proper real-time notification; during VerifyDataSet; Fix an issue with TQueryResult ordering (was causing; random 'stressProof' failures); Fix; an issue with TProof::AskStatistics (fBytesRead, fRealTime and fCpuTime; were not corr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:8992,log,logs,8992,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,1,['log'],['logs']
Testability," the result of the; expression is defined to be -0.0. If we look at the uses of the fmul for example, we might be able to prove that; all uses don't care about the sign of zero. For example, if we have:. fadd(fmul(sitofp(x), 0.0), 2.0). Since we know that x+2.0 doesn't care about the sign of any zeros in X, we can; transform the fmul to 0.0, and then the fadd to 2.0. //===---------------------------------------------------------------------===//. We should enhance memcpy/memcpy/memset to allow a metadata node on them; indicating that some bytes of the transfer are undefined. This is useful for; frontends like clang when lowering struct copies, when some elements of the; struct are undefined. Consider something like this:. struct x {; char a;; int b[4];; };; void foo(struct x*P);; struct x testfunc() {; struct x V1, V2;; foo(&V1);; V2 = V1;. return V2;; }. We currently compile this to:; $ clang t.c -S -o - -O0 -emit-llvm | opt -sroa -S. %struct.x = type { i8, [4 x i32] }. define void @testfunc(%struct.x* sret %agg.result) nounwind ssp {; entry:; %V1 = alloca %struct.x, align 4; call void @foo(%struct.x* %V1); %tmp1 = bitcast %struct.x* %V1 to i8*; %0 = bitcast %struct.x* %V1 to i160*; %srcval1 = load i160* %0, align 4; %tmp2 = bitcast %struct.x* %agg.result to i8*; %1 = bitcast %struct.x* %agg.result to i160*; store i160 %srcval1, i160* %1, align 4; ret void; }. This happens because SRoA sees that the temp alloca has is being memcpy'd into; and out of and it has holes and it has to be conservative. If we knew about the; holes, then this could be much much better. Having information about these holes would also improve memcpy (etc) lowering at; llc time when it gets inlined, because we can use smaller transfers. This also; avoids partial register stalls in some important cases. //===---------------------------------------------------------------------===//. We don't fold (icmp (add) (add)) unless the two adds only have a single use.; There are a lot of cases that we're",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:62661,test,testfunc,62661,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['test'],['testfunc']
Testability," the usual way: in a case like ``if v1 then if v2 then {...} else {...}``, the; ``else`` associates with the inner ``if`` rather than the outer one. The :token:`IfBody` of the then and else arms of the ``if`` establish an; inner scope. Any ``defvar`` variables defined in the bodies go out of scope; when the bodies are finished (see `Defvar in a Record Body`_ for more details). The ``if`` statement can also be used in a record :token:`Body`. ``assert`` --- check that a condition is true; ---------------------------------------------. The ``assert`` statement checks a boolean condition to be sure that it is true; and prints an error message if it is not. .. productionlist::; Assert: ""assert"" `condition` "","" `message` "";"". If the boolean condition is true, the statement does nothing. If the; condition is false, it prints a nonfatal error message. The **message**, which; can be an arbitrary string expression, is included in the error message as a; note. The exact behavior of the ``assert`` statement depends on its; placement. * At top level, the assertion is checked immediately. * In a record definition, the statement is saved and all assertions are; checked after the record is completely built. * In a class definition, the assertions are saved and inherited by all; the subclasses and records that inherit from the class. The assertions are; then checked when the records are completely built. * In a multiclass definition, the assertions are saved with the other; components of the multiclass and then checked each time the multiclass; is instantiated with ``defm``. Using assertions in TableGen files can simplify record checking in TableGen; backends. Here is an example of an ``assert`` in two class definitions. .. code-block:: text. class PersonName<string name> {; assert !le(!size(name), 32), ""person name is too long: "" # name;; string Name = name;; }. class Person<string name, int age> : PersonName<name> {; assert !and(!ge(age, 1), !le(age, 120)), ""person age is invalid:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:49389,assert,assert,49389,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['assert'],['assert']
Testability," the; original file referencing argument on the command line. A response file can; reference other response files. Users interested in the :program:`lit` architecture or designing a; :program:`lit` testing implementation should see :ref:`lit-infrastructure`. GENERAL OPTIONS; ---------------. .. option:: -h, --help. Show the :program:`lit` help message. .. option:: -j N, --workers=N. Run ``N`` tests in parallel. By default, this is automatically chosen to; match the number of detected available CPUs. .. option:: --config-prefix=NAME. Search for :file:`{NAME}.cfg` and :file:`{NAME}.site.cfg` when searching for; test suites, instead of :file:`lit.cfg` and :file:`lit.site.cfg`. .. option:: -D NAME[=VALUE], --param NAME[=VALUE]. Add a user defined parameter ``NAME`` with the given ``VALUE`` (or the empty; string if not given). The meaning and use of these parameters is test suite; dependent. .. _output-options:. OUTPUT OPTIONS; --------------. .. option:: -q, --quiet. Suppress any output except for test failures. .. option:: -s, --succinct. Show less output, for example don't show information on tests that pass.; Also show a progress bar, unless ``--no-progress-bar`` is specified. .. option:: -v, --verbose. Show more information on test failures, for example the entire test output; instead of just the test result. Each command is printed before it is executed. This can be valuable for; debugging test failures, as the last printed command is the one that failed.; Moreover, :program:`lit` inserts ``'RUN: at line N'`` before each; command pipeline in the output to help you locate the source line of; the failed command. .. option:: -vv, --echo-all-commands. Deprecated alias for -v. .. option:: -a, --show-all. Enable -v, but for all tests not just failed tests. .. option:: --no-progress-bar. Do not use curses based progress bar. .. option:: --show-unsupported. Show the names of unsupported tests. .. option:: --show-xfail. Show the names of tests that were expected to fail. ..",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:3070,test,test,3070,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['test']
Testability," the; registers ``EAX``, ``AX`` and ``AL`` share the first eight bits. These physical; registers are marked as *aliased* in LLVM. Given a particular architecture, you; can check which registers are aliased by inspecting its ``RegisterInfo.td``; file. Moreover, the class ``MCRegAliasIterator`` enumerates all the physical; registers aliased to a register. Physical registers, in LLVM, are grouped in *Register Classes*. Elements in the; same register class are functionally equivalent, and can be interchangeably; used. Each virtual register can only be mapped to physical registers of a; particular class. For instance, in the X86 architecture, some virtuals can only; be allocated to 8 bit registers. A register class is described by; ``TargetRegisterClass`` objects. To discover if a virtual register is; compatible with a given physical, this code can be used:. .. code-block:: c++. bool RegMapping_Fer::compatible_class(MachineFunction &mf,; unsigned v_reg,; unsigned p_reg) {; assert(TargetRegisterInfo::isPhysicalRegister(p_reg) &&; ""Target register must be physical"");; const TargetRegisterClass *trc = mf.getRegInfo().getRegClass(v_reg);; return trc->contains(p_reg);; }. Sometimes, mostly for debugging purposes, it is useful to change the number of; physical registers available in the target architecture. This must be done; statically, inside the ``TargetRegisterInfo.td`` file. Just ``grep`` for; ``RegisterClass``, the last parameter of which is a list of registers. Just; commenting some out is one simple way to avoid them being used. A more polite; way is to explicitly exclude some registers from the *allocation order*. See the; definition of the ``GR8`` register class in; ``lib/Target/X86/X86RegisterInfo.td`` for an example of this. Virtual registers are also denoted by integer numbers. Contrary to physical; registers, different virtual registers never share the same number. Whereas; physical registers are statically defined in a ``TargetRegisterInfo.td`` file; and cannot ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:60060,assert,assert,60060,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['assert'],['assert']
Testability," these lines are still drowned in the output, it's easy; to grep the output logs in the Output directories. Even better are the ``report`` and ``report.format`` targets (where; ``format`` is one of ``html``, ``csv``, ``text`` or ``graphs``). The; exact contents of the report are dependent on which ``TEST`` you are; running, but the text results are always shown at the end of the run and; the results are always stored in the ``report.<type>.format`` file (when; running with ``TEST=<type>``). The ``report`` also generate a file; called ``report.<type>.raw.out`` containing the output of the entire; test run. Writing Custom Tests for the test-suite; =======================================. Assuming you can run the test suite, (e.g.; ""``gmake TEST=nightly report``"" should work), it is really easy to run; optimizations or code generator components against every program in the; tree, collecting statistics or running custom checks for correctness. At; base, this is how the nightly tester works, it's just one example of a; general framework. Lets say that you have an LLVM optimization pass, and you want to see; how many times it triggers. First thing you should do is add an LLVM; `statistic <ProgrammersManual.html#Statistic>`_ to your pass, which will; tally counts of things you care about. Following this, you can set up a test and a report that collects these; and formats them for easy viewing. This consists of two files, a; ""``test-suite/TEST.XXX.Makefile``"" fragment (where XXX is the name of; your test) and a ""``test-suite/TEST.XXX.report``"" file that indicates; how to format the output into a table. There are many example reports of; various levels of sophistication included with the test suite, and the; framework is very general. If you are interested in testing an optimization pass, check out the; ""libcalls"" test as an example. It can be run like this:. .. code-block:: bash. % cd llvm/projects/test-suite/MultiSource/Benchmarks # or some other level; % make TEST=libcalls",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:5350,test,tester,5350,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,1,['test'],['tester']
Testability," this function:. - connect your Tree file (eg: `TFile f(""myfile.root"");`); - `T->MakeSelector(""myselect"");`. where T is the name of the Tree in file myfile.root; and myselect.h, myselect.C the name of the files created by this function.; In a ROOT session, you can do:; ``` {.cpp}; root > T->Process(""myselect.C""); ```. ### Other improvements. We fixed the handling of the case when an object, stored in a TTree, used to have a defaulted Streamer and when the TTree is being read, the object now has a custom Streamer that we must use. ## Histogram Libraries. ### TH1. * Fix a bug in using the buffer with weights different than one; * Remove the `kCanRebin` bit, that it was not used anymore. Its functionality is replaced by the `TH1::SetCanExtend` function. ### TGraph. * `TGraph::GetHistogram()` was resetting the TimeDisplay attribute of axis.; The problem was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-7766).; * Change `TGraph::ComputeRange`: in case of log scale the minimum along X and; Y axis are now set to the lowest positive values of the graph. Previously a % of the; maximum was used which may hide some points like in the following example; ``` {.cpp}; {; TGraph * gr = new TGraph(10);; for (int i = 0;i<10;i++) gr->SetPoint(i,i,TMath::Exp(-10.0*i));; for (int i = 5;i<10;i++) gr->SetPoint(i,i,0.);; gr->Draw(""apl"");; gr->SetMarkerStyle(20);; gPad->SetLogy(true);; }; ```; The problem was reported [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=20484). ### TGraph2D. Add a new implementation for Delauney interpolation using the triangle code from Jonathan Shewchuk, see [[ http://www.cs.cmu.edu/~quake/triangle.html ]]. ; A new class for Delauney triangulator and interpolation has been added in the MathCore library ( `ROOT::Math::Delauney2D` ). ### Fitting. * Improve thread safety of TH1::Fit by making static member of TVirtualFitter and TMinuitMinimizer thread local. This fixes [ROOT-7791].; * Fix some bugs in TF1NormSum (to fit normalized sum of function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:11983,log,log,11983,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['log'],['log']
Testability," throw. The term used to define the place where an ``invoke`` continues after an; exception is called a *landing pad*. LLVM landing pads are conceptually; alternative function entry points where an exception structure reference and a; type info index are passed in as arguments. The landing pad saves the exception; structure reference and then proceeds to select the catch block that corresponds; to the type info of the exception object. The LLVM :ref:`i_landingpad` is used to convey information about the landing; pad to the back end. For C++, the ``landingpad`` instruction returns a pointer; and integer pair corresponding to the pointer to the *exception structure* and; the *selector value* respectively. The ``landingpad`` instruction looks for a reference to the personality; function to be used for this ``try``/``catch`` sequence in the parent; function's attribute list. The instruction contains a list of *cleanup*,; *catch*, and *filter* clauses. The exception is tested against the clauses; sequentially from first to last. The clauses have the following meanings:. - ``catch <type> @ExcType``. - This clause means that the landingpad block should be entered if the; exception being thrown is of type ``@ExcType`` or a subtype of; ``@ExcType``. For C++, ``@ExcType`` is a pointer to the ``std::type_info``; object (an RTTI object) representing the C++ exception type. - If ``@ExcType`` is ``null``, any exception matches, so the landingpad; should always be entered. This is used for C++ catch-all blocks (""``catch; (...)``""). - When this clause is matched, the selector value will be equal to the value; returned by ""``@llvm.eh.typeid.for(i8* @ExcType)``"". This will always be a; positive value. - ``filter <type> [<type> @ExcType1, ..., <type> @ExcTypeN]``. - This clause means that the landingpad should be entered if the exception; being thrown does *not* match any of the types in the list (which, for C++,; are again specified as ``std::type_info`` pointers). - C++ front-ends u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:8190,test,tested,8190,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['test'],['tested']
Testability," time and; thus two consequent invocations may potentially execute different code paths; even if the end result will be the same. This will cause a fuzzer to treat; two similar inputs as significantly different and it will blow up the test corpus.; E.g. libxml uses ``rand()`` inside its hash table.; - The target code uses checksums to protect from invalid inputs.; E.g. png checks CRC for every chunk. In many cases it makes sense to build a special fuzzing-friendly build; with certain fuzzing-unfriendly features disabled. We propose to use a common build macro; for all such cases for consistency: ``FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION``. .. code-block:: c++. void MyInitPRNG() {; #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION; // In fuzzing mode the behavior of the code should be deterministic.; srand(0);; #else; srand(time(0));; #endif; }. AFL compatibility; -----------------; LibFuzzer can be used together with AFL_ on the same test corpus.; Both fuzzers expect the test corpus to reside in a directory, one file per input.; You can run both fuzzers on the same corpus, one after another:. .. code-block:: console. ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@; ./llvm-fuzz testcase_dir findings_dir # Will write new tests to testcase_dir. Periodically restart both fuzzers so that they can use each other's findings.; Currently, there is no simple way to run both fuzzing engines in parallel while sharing the same corpus dir. You may also use AFL on your target function ``LLVMFuzzerTestOneInput``:; see an example `here <https://github.com/llvm/llvm-project/tree/main/compiler-rt/lib/fuzzer/afl>`__. How good is my fuzzer?; ----------------------. Once you implement your target function ``LLVMFuzzerTestOneInput`` and fuzz it to death,; you will want to know whether the function or the corpus can be improved further.; One easy to use metric is, of course, code coverage. We recommend to use; `Clang Coverage <https://clang.llvm.org/docs/SourceBasedCodeCoverag",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:22364,test,test,22364,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['test'],['test']
Testability," time measurement instead of the `timeit` tool that; comes with the test-suite. The `perf` is usually available on linux systems. - `TEST_SUITE_SPEC2000_ROOT`, `TEST_SUITE_SPEC2006_ROOT`, `TEST_SUITE_SPEC2017_ROOT`, ... Specify installation directories of external benchmark suites. You can find; more information about expected versions or usage in the README files in the; `External` directory (such as `External/SPEC/README`). ### Common CMake Flags. - `-GNinja`. Generate build files for the ninja build tool. - `-Ctest-suite/cmake/caches/<cachefile.cmake>`. Use a CMake cache. The test-suite comes with several CMake caches which; predefine common or tricky build configurations. Displaying and Analyzing Results; --------------------------------. The `compare.py` script displays and compares result files. A result file is; produced when invoking lit with the `-o filename.json` flag. Example usage:. - Basic Usage:. ```text; % test-suite/utils/compare.py baseline.json; Warning: 'test-suite :: External/SPEC/CINT2006/403.gcc/403.gcc.test' has No metrics!; Tests: 508; Metric: exec_time. Program baseline. INT2006/456.hmmer/456.hmmer 1222.90; INT2006/464.h264ref/464.h264ref 928.70; ...; baseline; count 506.000000; mean 20.563098; std 111.423325; min 0.003400; 25% 0.011200; 50% 0.339450; 75% 4.067200; max 1222.896800; ```. - Show compile_time or text segment size metrics:. ```bash; % test-suite/utils/compare.py -m compile_time baseline.json; % test-suite/utils/compare.py -m size.__text baseline.json; ```. - Compare two result files and filter short running tests:. ```bash; % test-suite/utils/compare.py --filter-short baseline.json experiment.json; ...; Program baseline experiment diff. SingleSour.../Benchmarks/Linpack/linpack-pc 5.16 4.30 -16.5%; MultiSourc...erolling-dbl/LoopRerolling-dbl 7.01 7.86 12.2%; SingleSour...UnitTests/Vectorizer/gcc-loops 3.89 3.54 -9.0%; ...; ```. - Merge multiple baseline and experiment result files by taking the minimum; runtime each:. ```bash; % t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:7493,test,test-suite,7493,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['test'],['test-suite']
Testability," to 1 to disable parallelism. .. option:: --max-pass-iterations=<int>. Maximum number of times to run the full set of delta passes (default=5). .. option:: --mtriple=<string> . Set the target triple. .. option:: --preserve-debug-environment. Don't disable features used for crash debugging (crash reports, llvm-symbolizer and core dumps). .. option:: --print-delta-passes . Print list of delta passes, passable to --delta-passes as a comma separated liste. .. option:: --skip-delta-passes=<string> . Delta passes to not run, separated by commas. By default, run all delta passes. .. option:: --starting-granularity-level=<uint>. Number of times to divide chunks prior to first test. Note : Granularity refers to the level of detail at which the reduction process operates.; A lower granularity means that the reduction process operates at a more coarse-grained level,; while a higher granularity means that it operates at a more fine-grained level. .. option:: --test=<string> . Name of the interesting-ness test to be run. .. option:: --test-arg=<string> . Arguments passed onto the interesting-ness test. .. option:: --verbose . Print extra debugging information.; ; .. option:: --write-tmp-files-as-bitcode . Always write temporary files as bitcode instead of textual IR. .. option:: -x={ir|mir}. Input language as ir or mir. EXIT STATUS; ------------. :program:`llvm-reduce` returns 0 under normal operation. It returns a non-zero; exit code if there were any errors. EXAMPLE; -------. :program:`llvm-reduce` can be used to simplify a test that causes a; compiler crash. For example, let's assume that `opt` is crashing on the IR file; `test.ll` with error message `Assertion failed at line 1234 of; WhateverFile.cpp`, when running at `-O2`. The test case of `test.ll` can be reduced by invoking the following; command:. .. code-block:: bash. $(LLVM_BUILD_FOLDER)/bin/llvm-reduce --test=script.sh <path to>/test.ll. The shell script passed to the option `test` consists of the; following:. .. code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst:2366,test,test,2366,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-reduce.rst,1,['test'],['test']
Testability," to Numeric Differentiation and works fine, since `; gamma_cdf()` doesn't have a lot of parameters. > In such cases, Numeric Differentiation fallback is only used for that; specific function. In above example, `gamma_cdf()` falls back to Numeric; Differentiation but other functions in `MathFuncs.h` will still be; able to use AD. This is because Clad is going to assume that you have a; derivative for this `gamma_cdf()` function, and the remaining functions will; use AD as expected. In the end, the remaining functions (including; `gamma_cdf()`) will try to fall back to Numeric Differentiation. However, if you want to add pure AD support, you need to make sure that all; your external functions are supported by Clad (meaning there is a custom; derivative defined for each of them). ### How do I test my new class while adding AD support?. Please look at the test classes that test the derivatives, evaluates,; fixtures, etc. (defined in 'roofit/roofitcore/test'). You can clone and adapt; these tests to your class as needed. For example:. > [roofit/roofitcore/test/testRooFuncWrapper.cxx](https://github.com/root-project/root/blob/master/roofit/roofitcore/test/testRooFuncWrapper.cxx). > Tip: Tests like above can be referenced to see which parts of RooFit already; support AD. ### How do I control my compile time?. This is an area of research that still needs some work. In most cases, the; compile times are reasonable, but with an increase in the level of complexity,; higher compile times may be encountered. ## Appendix B - Where does AD Logic Implementation reside?. Following classes provide several Helper Functions to translate existing logic; into AD-supported logic. a - RooFit::Detail::CodeSquashContext. b - RooFuncWrapper. ### a. RooFit::Detail::CodeSquashContext. > [roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h](https://github.com/root-project/root/blob/master/roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h). It handles how to create a C++ function out of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:29097,test,tests,29097,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['test'],['tests']
Testability," to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.NullDereference; (C, C++, ObjC); Check for dereferences of null pointers. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. core.StackAddressEscape; (C); Check that addresses of stack memory do not escape the function. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. core.UndefinedBinaryOperatorResult; (C); Check for undefined results of binary operators. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. core.VLASize; (C); Check for declarations of VLA of undefined or zero size. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. core.uninitialized.ArraySubscript; (C); Check for uninitialized values used as array subscripts. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. core.uninitialized.Assign; (C); Check for assigning uninitialized values. void test() {; int x;; x |= 1; // warn: left expression is uninitialized; }. core.uninitialized.Branch; (C); Check for uninitialized values used as branch conditions. void test() {; int x;; if (x) // warn; return;; }. core.uninitialized.CapturedBlockVariable; (C); Check for blocks that capture uninitialized values. void test() {; int x;; ^{ int y = x; }(); // warn; }. core.uninitialized.UndefReturn; (C); Check for uninitialized values being returned to the caller. int test() {; int x;; return x; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:3996,test,test,3996,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability," to follow this exactly.; Releases should be tagged on Tuesdays. =============================== =========================; Release Approx. Date; =============================== =========================; *release branch: even releases* *4th Tue in January*; *release branch: odd releases* *4th Tue in July*; X.1.0-rc1 3 days after branch.; X.1.0-rc2 2 weeks after branch.; X.1.0-rc3 4 weeks after branch; **X.1.0-final** **6 weeks after branch**; **X.1.1** **8 weeks after branch**; **X.1.2** **10 weeks after branch**; **X.1.3** **12 weeks after branch**; **X.1.4** **14 weeks after branch**; **X.1.5** **16 weeks after branch**; **X.1.6 (if necessary)** **18 weeks after branch**; =============================== =========================. Release Process Summary; -----------------------. * Announce release schedule to the LLVM community and update the website. Do; this at least 3 weeks before the -rc1 release. * Create release branch and begin release process. * Send out release candidate sources for first round of testing. Testing lasts; 6 weeks. During the first round of testing, any regressions found should be; fixed. Patches are merged from mainline into the release branch. Also, all; features need to be completed during this time. Any features not completed at; the end of the first round of testing will be removed or disabled for the; release. * Generate and send out the second release candidate sources. Only *critical*; bugs found during this testing phase will be fixed. Any bugs introduced by; merged patches will be fixed. If so a third round of testing is needed. * The release notes are updated. * Finally, release!. * Announce bug fix release schedule to the LLVM community and update the website. * Do bug-fix releases every two weeks until X.1.5 or X.1.6 (if necessary). Release Process; ===============. .. contents::; :local:. Release Administrative Tasks; ----------------------------. This section describes a few administrative tasks that need to be done for the; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:2303,test,testing,2303,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['test'],['testing']
Testability," to merge functions? The obvious answer is: Yes, that is quite a; possible case. We usually *do* have duplicates and it would be good to get rid; of them. But how do we detect duplicates? This is the idea: we split functions; into smaller bricks or parts and compare the ""bricks"" amount. If equal,; we compare the ""bricks"" themselves, and then do our conclusions about functions; themselves. What could the difference be? For example, on a machine with 64-bit pointers; (let's assume we have only one address space), one function stores a 64-bit; integer, while another one stores a pointer. If the target is the machine; mentioned above, and if functions are identical, except the parameter type (we; could consider it as a part of function type), then we can treat a ``uint64_t``; and a ``void*`` as equal. This is just an example; more possible details are described a bit below. As another example, the reader may imagine two more functions. The first; function performs a multiplication by 2, while the second one performs an; logical left shift by 1. Possible solutions; ^^^^^^^^^^^^^^^^^^; Let's briefly consider possible options about how and what we have to implement; in order to create full-featured functions merging, and also what it would; mean for us. Equal function detection obviously supposes that a ""detector"" method to be; implemented and latter should answer the question ""whether functions are equal"".; This ""detector"" method consists of tiny ""sub-detectors"", which each answers; exactly the same question, but for function parts. As the second step, we should merge equal functions. So it should be a ""merger""; method. ""Merger"" accepts two functions *F1* and *F2*, and produces *F1F2*; function, the result of merging. Having such routines in our hands, we can process a whole module, and merge all; equal functions. In this case, we have to compare every function with every another function. As; the reader may notice, this way seems to be quite expensive. Of course we could;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:4431,log,logical,4431,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['log'],['logical']
Testability," to parse identifiers) has been updated to 15.1. * Clang now defines macro ``__LLVM_INSTR_PROFILE_GENERATE`` when compiling with; PGO instrumentation profile generation, and ``__LLVM_INSTR_PROFILE_USE`` when; compiling with PGO profile use. New Compiler Flags; ------------------. * ``-fverify-intermediate-code`` and its complement ``-fno-verify-intermediate-code``.; Enables or disables verification of the generated LLVM IR.; Users can pass this to turn on extra verification to catch certain types of; compiler bugs at the cost of extra compile time.; Since enabling the verifier adds a non-trivial cost of a few percent impact on; build times, it's disabled by default, unless your LLVM distribution itself is; compiled with runtime checks enabled.; * ``-fkeep-system-includes`` modifies the behavior of the ``-E`` option,; preserving ``#include`` directives for ""system"" headers instead of copying; the preprocessed text to the output. This can greatly reduce the size of the; preprocessed output, which can be helpful when trying to reduce a test case.; * ``-fassume-nothrow-exception-dtor`` is added to assume that the destructor of; a thrown exception object will not throw. The generated code for catch; handlers will be smaller. A throw expression of a type with a; potentially-throwing destructor will lead to an error. * ``-fopenacc`` was added as a part of the effort to support OpenACC in Clang. * ``-fcx-limited-range`` enables the naive mathematical formulas for complex; division and multiplication with no NaN checking of results. The default is; ``-fno-cx-limited-range``, but this option is enabled by ``-ffast-math``. * ``-fcx-fortran-rules`` enables the naive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun. ACM 5, 8; (1962). The default is ``-fno-cx-fortran-rules``. * ``-fvisibility-global-new-delete=<value>`` gives more freedom to users to; cont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:16067,test,test,16067,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['test'],['test']
Testability," to put some kind of error message in; the assertion statement, which is printed if the assertion is tripped. This; helps the poor debugger make sense of why an assertion is being made and; enforced, and hopefully what to do about it. Here is one complete example:. .. code-block:: c++. inline Value *getOperand(unsigned I) {; assert(I < Operands.size() && ""getOperand() out of range!"");; return Operands[I];; }. Here are more examples:. .. code-block:: c++. assert(Ty->isPointerType() && ""Can't allocate a non-pointer type!"");. assert((Opcode == Shl || Opcode == Shr) && ""ShiftInst Opcode invalid!"");. assert(idx < getNumSuccessors() && ""Successor # out of range!"");. assert(V1.getType() == V2.getType() && ""Constant types must be identical!"");. assert(isa<PHINode>(Succ->front()) && ""Only works on PHId BBs!"");. You get the idea. In the past, asserts were used to indicate a piece of code that should not be; reached. These were typically of the form:. .. code-block:: c++. assert(0 && ""Invalid radix for integer literal"");. This has a few issues, the main one being that some compilers might not; understand the assertion, or warn about a missing return in builds where; assertions are compiled out. Today, we have something much better: ``llvm_unreachable``:. .. code-block:: c++. llvm_unreachable(""Invalid radix for integer literal"");. When assertions are enabled, this will print the message if it's ever reached; and then exit the program. When assertions are disabled (i.e. in release; builds), ``llvm_unreachable`` becomes a hint to compilers to skip generating; code for this branch. If the compiler does not support this, it will fall back; to the ""abort"" implementation. Use ``llvm_unreachable`` to mark a specific point in code that should never be; reached. This is especially desirable for addressing warnings about unreachable; branches, etc., but can be used whenever reaching a particular code path is; unconditionally a bug (not originating from user input; see below) of some kind.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:46363,assert,assert,46363,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['assert'],['assert']
Testability," to save a canvas into `file.xml` file; format instead of `file.root`. XML files do not have any advantages; compared to the normal ROOT files, except that the information in these; files can be edited via a normal editor. The main motivation for this; new format is to facilitate the communication with other non ROOT; applications. Currently writing and reading XML files is limited to ROOT; applications. It is our intention to develop a simple reader independent; of the ROOT libraries that could be used as an example for real; applications. The XML format should be used only for small data volumes, typically; histogram files, pictures, geometries, calibrations. The XML file is; built in memory before being dumped to disk. Like for normal ROOT files,; XML files use the same I/O mechanism exploiting the ROOT/Cling; dictionary. Any class having a dictionary can be saved in XML format.; This first implementation does not support subdirectories or trees. The shared library `libRXML.so` may be loaded dynamically via; `gSystem->Load(""libRXML"")`. This library is also automatically loaded by; the plug-in manager as soon a XML file is created. To create an XTM; file, simply specify a filename with an .xml extension when calling; **`TFile`**`::Open`. **`TFile`**`::Open` will recognize that you are trying to; open an XML file and return a **`TXMLFile`** object. When a XML file is; open in write mode, one can use the normal `TObject::Write` to write an; object in the file. ``` {.cpp}; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"",""recreate"");; TH1F *h = new TH1F(""h"",""test"",1000,-2,2); h->FillRandom(""gaus"");; h->Write();; delete f;; // example of a session saving a histogram to a XML file; TFile *f = TFile::Open(""Example.xml"");; TH1F *h = (TH1F*)f->Get(""h"");; h->Draw();; ```. The canvas can be saved as a XML file format via File menu / Save or; Save As menu entries. One can do also:. ``` {.cpp}; canvas->Print(""Example.xml"");; ```; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:98721,test,test,98721,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['test'],['test']
Testability," to show the call stack, but does NOT do any; special handling of branches, meaning different paths could end up; interleaved. - debug.DumpTraversal: Prints the name of each branch statement encountered; during a path traversal (""IfStmt"", ""WhileStmt"", etc). Currently used to check; whether the analysis engine is doing BFS or DFS. State Checking; ==============. These checkers will print out information about the analyzer state in the form; of analysis warnings. They are intended for use with the -verify functionality; in regression tests. - debug.TaintTest: Prints out the word ""tainted"" for every expression that; carries taint. At the time of this writing, taint was only introduced by the; checks under experimental.security.taint.TaintPropagation; this checker may; eventually move to the security.taint package. - debug.ExprInspection: Responds to certain function calls, which are modeled; after builtins. These function calls should affect the program state other; than the evaluation of their arguments; to use them, you will need to declare; them within your test file. The available functions are described below. (FIXME: debug.ExprInspection should probably be renamed, since it no longer only; inspects expressions.). ExprInspection checks; ---------------------. - ``void clang_analyzer_eval(bool);``. Prints TRUE if the argument is known to have a non-zero value, FALSE if the; argument is known to have a zero or null value, and UNKNOWN if the argument; isn't sufficiently constrained on this path. You can use this to test other; values by using expressions like ""x == 5"". Note that this functionality is; currently DISABLED in inlined functions, since different calls to the same; inlined function could provide different information, making it difficult to; write proper -verify directives. In C, the argument can be typed as 'int' or as '_Bool'. Example usage::. clang_analyzer_eval(x); // expected-warning{{UNKNOWN}}; if (!x) return;; clang_analyzer_eval(x); // expected-warn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:2700,test,test,2700,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,1,['test'],['test']
Testability," to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data as buffer size; }. Unix Alpha Checkers. Name, DescriptionExample. alpha.unix.BlockInCriticalSection; (C); Check for calls to blocking functions inside a critical section. Applies to:. lock; unlock; sleep; getc; fgets; read; revc; pthread_mutex_lock; pthread_mutex_unlock; mtx_lock; mtx_timedlock; mtx_trylock; mtx_unlock; lock_guard; unique_lock. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();; }. alpha.unix.Chroot; (C); Check improper use of chroot. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. alpha.unix.PthreadLock; (C); Simple lock -> unlock checker; applies to:; pthread_mutex_lock; pthread_rwlock_rdlock; pthread_rwlock_wrlock; lck_mtx_lock; lck_rw_lock_exclusive; lck_rw_lock_shared; pthread_mutex_trylock; pthread_rwlock_tryrdlock; pthread_rwlock_tryrwlock; lck_mtx_try_lock; lck_rw_try_lock_exclusive; lck_rw_try_lock_shared; pthread_mutex_unlock; pthread_rwlock_unlock; lck_mtx_unlock; lck_rw_done. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. alpha.unix.SimpleStream; (C); Check for misu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:12866,test,test,12866,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['test'],['test']
Testability," toolchain. .. note:: BUILD_SHARED_LIBS is only recommended for use by LLVM developers.; If you want to build LLVM as a shared library, you should use the; ``LLVM_BUILD_LLVM_DYLIB`` option. **LLVM_ABI_BREAKING_CHECKS**:STRING; Used to decide if LLVM should be built with ABI breaking checks or; not. Allowed values are `WITH_ASSERTS` (default), `FORCE_ON` and; `FORCE_OFF`. `WITH_ASSERTS` turns on ABI breaking checks in an; assertion enabled build. `FORCE_ON` (`FORCE_OFF`) turns them on; (off) irrespective of whether normal (`NDEBUG`-based) assertions are; enabled or not. A version of LLVM built with ABI breaking checks; is not ABI compatible with a version built without it. **LLVM_ADDITIONAL_BUILD_TYPES**:LIST; Adding a semicolon separated list of additional build types to this flag; allows for them to be specified as values in CMAKE_BUILD_TYPE without; encountering a fatal error during the configuration process. **LLVM_UNREACHABLE_OPTIMIZE**:BOOL; This flag controls the behavior of `llvm_unreachable()` in release build; (when assertions are disabled in general). When ON (default) then; `llvm_unreachable()` is considered ""undefined behavior"" and optimized as; such. When OFF it is instead replaced with a guaranteed ""trap"". **LLVM_APPEND_VC_REV**:BOOL; Embed version control revision info (Git revision id).; The version info is provided by the ``LLVM_REVISION`` macro in; ``llvm/include/llvm/Support/VCSRevision.h``. Developers using git who don't; need revision info can disable this option to avoid re-linking most binaries; after a branch switch. Defaults to ON. **LLVM_FORCE_VC_REVISION**:STRING; Force a specific Git revision id rather than calling to git to determine it.; This is useful in environments where git is not available or non-functional; but the VC revision is available through other means. **LLVM_FORCE_VC_REPOSITORY**:STRING; Set the git repository to include in version info rather than calling git to; determine it. **LLVM_BUILD_32_BITS**:BOOL; Build 32-bit exe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:12842,assert,assertions,12842,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['assert'],['assertions']
Testability," top of RooFit. It is a joint effort between the LHC experiments and the ROOT team (see the RooStats Wiki page).; ; This version contains the interfaces for performing the statistical calculations and dealing with the obtained results and concrete classes implementing the statistical methods.; ; All the classes and functions in RooStats are provided in the namespace RooStats.; ; RooStats interfaces. ConfInterval: interface for describing a confidence interval. ; IntervalCalculator: interface for a statistical tool producing confidence intervals (class ConfInterval).; HypoTestResult: interface for representing results of a hypothesis test; HypoTestCalculator: interface for a statistical tool performing an hypothesis test. ; CombinedCalculator: interface for a statistical tool which can produce both hypothesis test results and confidence intervals. ; RooStats concrete classes. The concrete classes describing statistical tools implementing the above interfaces are:; ; ProfileLikelihoodCalculator: it is an implementation of a CombinedCalculator using the profile likelihood ratio as a test statistics. After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer).; LikelihoodInterval: concrete implementation of a ConfInterval interface. It implements connected N-dimensional intervals based on the contour of a likelihood ratio. The boundary of the interval is equivalent to a MINUIT/MINOS contour about the maximum likelihood estimator. . HybridCalculator: hypothesis test calculator using a Bayesian-frequentist hybrid method (often called in HEP as CLs method). This class extends the functionality of the TLimit class by taking advantage of the RooFit package. The result of the calculator is returned as an HybridResult pointer. HybridResult implements the HypoTestResult interface. The class HybridPlot allows for a graphical representation of a HybridResult.; ; Hyb",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:10521,test,test,10521,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['test'],['test']
Testability," tree can be explicit selected by list them in; column separated list:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"");; ```. will print the values of `var1`, `var2` and `var3`. A selection can be; applied in the second argument:. ``` {.cpp}; root[] MyTree->Scan(""var1:var2:var3"",""var1==0"");; ```. will print the values of `var1`, `var2` and `var3` for the entries where; var1 is exactly 0. `TTree::Scan` returns the number of entries passing the selection. By; default 50 rows are shown before `TTree::Scan` pauses and ask you to; press the Enter key to see the next 50 rows. You can change the default; number of rows to be shown before \<CR\> via; `mytree->SetScanfield(maxrows)` where maxrows is 50 by default. If; maxrows is set to 0 all rows of the **`Tree`** are shown. This option is; interesting when dumping the contents of a Tree to an ascii file, eg; from the command line:. ``` {.cpp}; root[] tree->SetScanField(0);; root[] tree->Scan(""*""); >tree.log; ```. will create a file `tree.log`. Arrays (within an entry) are printed in their linear forms. If several; arrays with multiple dimensions are printed together, they will NOT be; synchronized. For example, with a tree containing `arr1[4][2] `and; `arr2[2][3]`,. ``` {.cpp}; root[] MyTree(""arr1:arr2"");; ```. will results in a printing similar to:. ``` {.cpp}; ************************************************; * Row * Instance * arr1 * arr2 *; ***********************************************; * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *; ```. However, if there is a selection criterium which is an array, then all; the formulas will be synchronized with the selection criterium (see; **`TTree::Draw` for more information).**. The third parameter of `TTree::Scan` can be use to specific the layout; of the table:. - `l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:105984,log,log,105984,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['log'],['log']
Testability," try to describe the **why** (and in this case, to a lesser extent the **what**), rather than the **how**. If your PR is related to an open [issue](https://github.com/root-project/root/issues), make sure to link it.; This will be done automatically if you add; [closing keywords](https://docs.github.com/en/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue); to the PR description. Once a PR is created, a member of the ROOT team will review it as quickly as possible. If you are familiar with the; ROOT community, it may be beneficial to add a suggested reviewer to the PR in order to get quicker attention.; Please ping people :wave: should you not get timely feedback, for instance with `@root-project/core ping!`. ## Tests. As you contribute code, this code will likely fix an issue or add a feature.; Whatever it is: this requires you to add a new test, or to extend an existing test. Depending on the size and complexity; of this test, it exists either in the `test/` subdirectory of each part of ROOT (see for instance; [`tree/dataframe/test`](https://github.com/root-project/root/tree/master/tree/dataframe/test)), or in; [roottest](https://github.com/root-project/roottest.git). Tests in `test/` subdirectories are unit tests, mostly based on; [Google Test](https://github.com/google/googletest) and easily extended. Tests in; [roottest](https://github.com/root-project/roottest.git) are more involved (e.g., tests requiring custom dictionaries or; data files). When you create a branch in the main ROOT repository (i.e., this repository) and add a test to `roottest`,; make sure to do this under the same branch name (and open a PR for it). Our CI infrastructure automatically picks up the; changes defined in the `roottest` PR based on this branch name, and uses that for testing your PR here. ## Continuous Integration. To prevent bad surprises and make a better first impression, we; strongly encourage new developers to [run the tests](https://root.cern/for_develo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md:5613,test,test,5613,CONTRIBUTING.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CONTRIBUTING.md,3,['test'],['test']
Testability," type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a particular relevant target?. If the answer to any of these is ""yes"", the feature test macro should either; not be defined or there should be very strong rationale for why the issues; should not prevent defining it. Note, it is acceptable to define the feature; test macro on a per-target basis if needed. When in doubt, being conservative is better than being aggressive. If we don't; claim support for the feature but it does useful things, users can still use it; and provide us with useful feedback on what is missing. But if we claim support; for a feature that has significant bugs, we've eliminated most of the utility; of having a feature testing macro at all because users are then forced to test; what compiler version is in use to get a more accurate answer. The status reported by the feature test macro should always be reflected in the; language support page for the corres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:163532,assert,assertions,163532,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['assert'],['assertions']
Testability," types much easier.; Depending on how you configure the project, Visual Studio may automatically; use these visualizers when debugging or you may be required to put the files; into %USERPROFILE%\Documents\Visual Studio <version>\Visualizers; or create a symbolic link so they update automatically. See; ; Microsoft's documentation for more details on use of NATVIS. Testing. Testing on Unix-like Systems. Clang includes a basic regression suite in the tree which can be; run with make test from the top-level clang directory, or; just make in the test sub-directory.; make VERBOSE=1 can be used to show more detail; about what is being run.; If you built LLVM and Clang using CMake, the test suite can be run; with make check-clang from the top-level LLVM directory.; The tests primarily consist of a test runner script running the compiler; under test on individual test files grouped in the directories under the; test directory. The individual test files include comments at the; beginning indicating the Clang compile options to use, to be read; by the test runner. Embedded comments also can do things like telling; the test runner that an error is expected at the current line.; Any output files produced by the test will be placed under; a created Output directory.; During the run of make test, the terminal output will; display a line similar to the following:; --- Running clang tests for i686-pc-linux-gnu ---; followed by a line continually overwritten with the current test; file being compiled, and an overall completion percentage.; After the make test run completes, the absence of any; Failing Tests (count): message indicates that no tests; failed unexpectedly. If any tests did fail, the; Failing Tests (count): message will be followed by a list; of the test source file paths that failed. For example:. Failing Tests (3):; /home/john/llvm/tools/clang/test/SemaCXX/member-name-lookup.cpp; /home/john/llvm/tools/clang/test/SemaCXX/namespace-alias.cpp; /home/john/llvm/tools/clang/t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:3027,test,test,3027,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,2,['test'],['test']
Testability," uniform with the other calculator tools, which is different from the original; HybridCalculator's interface. Users wishing to run their old macro are advised to use ModelConfig, but if that is too time consuming one can just change the; name of the class from HybridCalculator to; HybridCalculatorOriginal; Note also that with the new class no HybridResult is; returned but directly the base class HypoTestResult which; has been improved for this release.; The plot class, HybridPlot is not returned, but; the user can create an HypoTestPlot object from the; HypoTestResult.; The classes HybridResult and HybridPlot work only; with the HybridCalculatorOriginal and remain for maintaining; a backward compatibility. ; Given a ModelConfig, the tool will attempt to form the posterior pdf ; for the nuisance parameters based on the prior and the constraint terms ; in the pdf. However, this is not yet implemented. In order to keep; logical consistency with other tools, the distribution being used; to smear the nuisance parameters should NOT be considered the prior in ; the model config. Instead, one should use HybridCalculator's; ForcePriorNuisanceNull and ForcePriorNuisanceAlt. HybridCalculatorOriginal. Apply a fix for test statistic = 3 (profile likelihood); Apply a fix for using non-extended pdf. TestStatSampler and TestStatistics. Cleanup of the interfaces.; TestStatistics now have a method PValueIsRightTail to specify the sign conventions for the test statistic. This is used when making plots and calculating p-values.; make clear that TestStatistic::Evaluate should take data and values of the parameters that define the null.; Add method TestStatSampler::SetParametersForTestStat that ; allows for greater control of parameters used for generating toy data; and parameters used for evaluating the test statistic.; ProfileLikelihoodTestStatUsing the raw profile likelihood while reviewing the old algorithm used to provide robustness in situations with local minima.; New test statist",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html:6044,log,logical,6044,roofit/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html,1,['log'],['logical']
Testability," update of a condition bitmap that is local to a; function and will cause the ``-instrprof`` pass to generate the code to; instrument the control flow around each condition in a boolean expression. The; ID of each condition corresponds to a bit index in the condition bitmap which; is set based on the evaluation of the condition. '``llvm.instrprof.mcdc.tvbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.tvbitmap.update(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>); i32 <bitmap-index>,; ptr <mcdc-temp-addr>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.tvbitmap.update``' intrinsic is used to track MC/DC; test vector execution after each boolean expression has been fully executed.; The overall value of the condition bitmap, after it has been successively; updated using the '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic with; the true or false evaluation of each condition, uniquely identifies an executed; MC/DC test vector and is used as a bit index into the global test vector; bitmap. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vectors executed for each boolean expression. The fourth argument is the byte index into the global test vector bitmap; corresponding to the function. The fifth argument is the address of the condition bitmap, which contains a; value representing an executed MC/DC test vector. It is loaded and used as the; bit index of the test vector bitmap. Semantics:; """""""""""""""""""". This intrinsic represents the final operation of an MC/DC instrumentation; sequence and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:535440,test,test,535440,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['test'],['test']
Testability," use ""``CHECK:``""; and ""``CHECK-SAME:``"" directives to specify this. If you specified a custom; check prefix, just use ""``<PREFIX>-SAME:``"". ""``CHECK-SAME:``"" is particularly powerful in conjunction with ""``CHECK-NOT:``""; (described below). For example, the following works like you'd expect:. .. code-block:: llvm. !0 = !DILocation(line: 5, scope: !1, inlinedAt: !2). ; CHECK: !DILocation(line: 5,; ; CHECK-NOT: column:; ; CHECK-SAME: scope: ![[SCOPE:[0-9]+]]. ""``CHECK-SAME:``"" directives reject the input if there are any newlines between; it and the previous directive. ""``CHECK-SAME:``"" is also useful to avoid writing matchers for irrelevant; fields. For example, suppose you're writing a test which parses a tool that; generates output like this:. .. code-block:: text. Name: foo; Field1: ...; Field2: ...; Field3: ...; Value: 1. Name: bar; Field1: ...; Field2: ...; Field3: ...; Value: 2. Name: baz; Field1: ...; Field2: ...; Field3: ...; Value: 1. To write a test that verifies ``foo`` has the value ``1``, you might first; write this:. .. code-block:: text. CHECK: Name: foo; CHECK: Value: 1{{$}}. However, this would be a bad test: if the value for ``foo`` changes, the test; would still pass because the ""``CHECK: Value: 1``"" line would match the value; from ``baz``. To fix this, you could add ``CHECK-NEXT`` matchers for every; ``FieldN:`` line, but that would be verbose, and need to be updated when; ``Field4`` is added. A more succinct way to write the test using the; ""``CHECK-SAME:``"" matcher would be as follows:. .. code-block:: text. CHECK: Name: foo; CHECK: Value:; CHECK-SAME: {{ 1$}}. This verifies that the *next* time ""``Value:``"" appears in the output, it has; the value ``1``. Note: a ""``CHECK-SAME:``"" cannot be the first directive in a file. The ""CHECK-EMPTY:"" directive; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. If you need to check that the next line has nothing on it, not even whitespace,; you can use the ""``CHECK-EMPTY:``"" directive. .. code-block:: llvm. declare void @foo()",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:15289,test,test,15289,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['test'],['test']
Testability," use `inset` because of old Chrome browsers; 5. Fix - properly provide object hints. ## Changes in 7.5.3; 1. Fix - draw histograms with negative bins #276; 2. Fix - correctly read TLeaf with fixed-size array; 3. Fix - bug in options handling in startGUI; 4. Fix - greyscale support in TLegend drawing; 5. Fix - correctly use text font for TGaxis title; 6. Fix - preserve auto colors in THStack #277; 7. Fix - correctly set pave name #278. ## Changes in 7.5.2; 1. Fix - proper fit pars display in stats, proper #chi^{2}; 2. Fix - several bugs in TFormula parsing; 3. Fix - correctly use saved buffer in TF1/TF2; 4. Fix - properly adjust size of stats box; 5. Fix - support pol0..pol9 functions; 6. Fix - TGraph bar width should be at least 1 pixel; 7. Fix - prevent drawing of empty TGraph. ## Changes in 7.5.1; 1. Fix - expand item in hierarchy painter; 2. Fix - correctly use saved TF1 values for non-equidistant bins #270; 3. Fix - in log scales replace 10^1 label by 10; 4. Fix - vertical align of log labels on X axis; 5. Fix - second click of the same item in hierarchy painter. ## Changes in 7.5.0; 1. Correctly implement `TH2` projections like MERCATOR or PARABOLIC, add MOLLWEIDE; 2. Support ""pol"", ""cyl"", ""sph"" and ""psr"" coordinates systems for lego and surf plots; 3. Support orthographic camera for lego and surface plots; 4. Implement ""tri1"", ""tri2"", ""triw"" draw options for `TGraph2D` with Delaunay algorithm; 5. Add support of `TProfile3D` and `TPaveClass` classes; 6. Use ""col"" as default draw option for `TH2`, ""box2"" for `TH3`; 7. Draw axes grids in front of objects - making it equivalent to original ROOT; 8. Change `TF1` and `TF2` drawing - always convert into histogram, support TWebCanvas, handle log scales; 9. Provide ""Bring to front"" menu command for different objects like pave, box, marker, ...; 10. Provide ""Build legend"" context menu command for the pad; 11. Let toggle vertical/horizontal flag for color palette via context menu; 12. Support canvas grayscale, let toggle ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:8764,log,log,8764,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['log'],['log']
Testability," use the proposed code:. LVStringRefs::iterator Iter = std::find_if(Components.begin(), Components.end(),; [](StringRef Name) {; return IdentifiedNamespaces.find(Name) == IdentifiedNamespaces.end();; });; LVStringRefs::size_type FirstNonNamespace = std::distance(Components.begin(), Iter);. //===----------------------------------------------------------------------===//; // Move all the printing support to a common module.; //===----------------------------------------------------------------------===//; Factor out printing functionality from the logical elements into a; common module. //===----------------------------------------------------------------------===//; // Refactor 'LVBinaryReader::processLines'.; //===----------------------------------------------------------------------===//; https://reviews.llvm.org/D125783#inline-1246155; https://reviews.llvm.org/D137156. During the traversal of the debug information sections, we created the; logical lines representing the disassembled instructions from the text; section and the logical lines representing the line records from the; debug line section. Using the ranges associated with the logical scopes,; we will allocate those logical lines to their logical scopes. Consider the case when any of those lines become orphans, causing; incorrect scope parent for disassembly or line records. //===----------------------------------------------------------------------===//; // Add support for '-ffunction-sections'.; //===----------------------------------------------------------------------===//; https://reviews.llvm.org/D125783#inline-1295012. Only linked executables are handled. It does not support relocatable; files compiled with -ffunction-sections. //===----------------------------------------------------------------------===//; // Add support for DWARF v5 .debug_names section.; // Add support for CodeView public symbols stream.; //===----------------------------------------------------------------------===//; https://r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/README.txt:7904,log,logical,7904,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/README.txt,2,['log'],['logical']
Testability," used in randomised (and bagged) trees. NNodesMax No 0 − deprecated: Use MaxDepth instead to limit the tree size. Configuration options for MVA method :. Configuration options reference for MVA method: Boost. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). Boost_Num No 100 − Number of times the classifier is boosted. Boost_MonitorMethod No True − Write monitoring histograms for each boosted classifier. Boost_DetailedMonitoring No False − Produce histograms for detailed boost-wise monitoring. Boost_Type No AdaBoost AdaBoost, Bagging, HighEdgeGauss, HighEdgeCoPara Boosting type for the classifiers. Boost_BaggedSampleFraction No 0.6 − Relative size of bagged event sample to original size of the data sample (used whenever bagging is used). Boost_MethodWeightType No ByError ByError, Average, ByROC, ByOverlap, LastMethod How to set the final weight of the boosted classifiers. Boost_RecalculateMVACut No True − Recalculate the classifier MVA Signallike cut at every boost iteration. Boost_AdaBoostBeta No 1 − The ADA boost parameter that sets the effect of every boost step on the events' weights. Boost_Transform No step step, linear, log, gauss Type of transform applied ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:16523,test,testing,16523,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['test'],['testing']
Testability," value of the returned value is in the; range [0.5, 1.0), with the same sign as the argument. The second; result is an integer such that the first result raised to the power of; the second result is the input argument. If the argument is a zero, returns a zero with the same sign and a 0; exponent. If the argument is a NaN, a NaN is returned and the returned exponent; is unspecified. If the argument is an infinity, returns an infinity with the same sign; and an unspecified exponent. .. _int_log:. '``llvm.log.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.log`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.log.f32(float %Val); declare double @llvm.log.f64(double %Val); declare x86_fp80 @llvm.log.f80(x86_fp80 %Val); declare fp128 @llvm.log.f128(fp128 %Val); declare ppc_fp128 @llvm.log.ppcf128(ppc_fp128 %Val). Overview:; """""""""""""""""". The '``llvm.log.*``' intrinsics compute the base-e logarithm of the specified; value. Arguments:; """""""""""""""""""". The argument and return value are floating-point numbers of the same type. Semantics:; """""""""""""""""""". Return the same value as a corresponding libm '``log``' function but without; trapping or setting ``errno``. When specified with the fast-math-flag 'afn', the result may be approximated; using a less accurate calculation. .. _int_log10:. '``llvm.log10.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.log10`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.log10.f32(float %Val); declare double @llvm.log10.f64(double %Val); declare x86_fp80 @llvm.log10.f80(x86_fp80 %Val); declare fp128 @llvm.log10.f128(fp128 %Val); declare ppc_fp128 @llvm.log10.ppcf128(ppc_fp128 %Val). Overview:; """""""""""""""""". The '``llvm.log10.*``' intrinsics compute the base-10 logarithm of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:568022,log,log,568022,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['log'],['log']
Testability," value of this option is ``true``. This allows save of the errno value; for possible later error handling. **Limitations**. - Only the very first usage of ``errno`` is checked after an affected function; call. Value of ``errno`` is not followed when it is stored into a variable; or returned from a function.; - Documentation of function ``lseek`` is not clear about what happens if the; function returns different value than the expected file position but not -1.; To avoid possible false-positives ``errno`` is allowed to be used in this; case. .. _unix-Malloc:. unix.Malloc (C); """"""""""""""""""""""""""""""; Check for memory leaks, double free, and use-after-free problems. Traces memory managed by malloc()/free(). .. literalinclude:: checkers/unix_malloc_example.c; :language: c. .. _unix-MallocSizeof:. unix.MallocSizeof (C); """"""""""""""""""""""""""""""""""""""""""; Check for dubious ``malloc`` arguments involving ``sizeof``. .. code-block:: c. void test() {; long *p = malloc(sizeof(short));; // warn: result is converted to 'long *', which is; // incompatible with operand type 'short'; free(p);; }. .. _unix-MismatchedDeallocator:. unix.MismatchedDeallocator (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for mismatched deallocators. .. literalinclude:: checkers/mismatched_deallocator_example.cpp; :language: c. .. _unix-Vfork:. unix.Vfork (C); """"""""""""""""""""""""""""; Check for proper usage of ``vfork``. .. code-block:: c. int test(int x) {; pid_t pid = vfork(); // warn; if (pid != 0); return 0;. switch (x) {; case 0:; pid = 1;; execl("""", """", 0);; _exit(1);; break;; case 1:; x = 0; // warn: this assignment is prohibited; break;; case 2:; foo(); // warn: this function call is prohibited; break;; default:; return 0; // warn: return is prohibited; }. while(1);; }. .. _unix-cstring-BadSizeArg:. unix.cstring.BadSizeArg (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check the size argument passed into C string functions for common erroneous patterns. Use ``-Wno-strncat-size`` compiler option to mute other ``strncat``-related ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:29043,test,test,29043,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability," var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-generate; Generate instrumented code to collect execution counts into default.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-use=<value>; Use instrumentation data for coverage testing or profile-guided optimization; -fprofile-use=<value>; Use instrumentation data for profile-guided optimization; -fprofile-remapping-file=<file>; Use the remappings described in <file> to match the profile data against names in the program; -fprofile-list=<file>; Filename defining the list of functions/files to instrument; -fsanitize-address-field-padding=<value>; Level of field padding for AddressSanitizer; -fsanitize-address-globals-dead-stripping; Enable linker dead stripping of globals in AddressSanitizer; -fsanitize-address-poison-custom-array-cookie; Enable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, defaul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:182557,test,testing,182557,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['test'],['testing']
Testability," vector of the source spectrum; - **`sizex`**: x length of the source spectrum; - **`sizey`**: y length of the source spectrum; - **`sigma`**: sigma of searched peaks. An example of the two-dimensional spectrum with the identified peaks is; shown in Figure 3.8. ![Two-dimensional spectrum with the identified peaks](figures/image072.png). We have also generalized the peak searching function similarly to one-dimensional data. The generalized peak searching function for two-dimensional spectra has the form of. ```{.cpp}; Int_t Search2General(float **source,; int sizex,; int sizey,; double sigma,; int threshold,; bool markov,; int aver_window);; ```. This function searches for peaks in the source spectrum. The number of found; peaks and their positions are written into the structure pointed by; `two_dim_peak` structure pointer. Function parameters:. - **`source`**: pointer to the vector of the source spectrum; - **`sizex`**: x length of the source spectrum; - **`sizey`**: y length of the source spectrum; - **`sigma`**: sigma of searched peaks; - **`threshold`**: threshold value for peaks selection; - **`markov`**: logical variable. If it is set to `true`, then the source spectrum is first replaced by the new spectrum calculated using Markov chains method; - **`aver_window`** averaging window of searched peaks (applies only for the Markov method). An example of experimental 2-dimensional spectrum is given in Figure 3.9.; The number of peaks identified by the function now is 295. ![Experimental 2-dimensional spectrum](figures/image074.png). The function works even for very noisy data. In Figure 3.10 we present; synthetic 2-dimensional spectrum with 5 peaks. The method should; recognize what is the real 2-dimensional peak and what is the crossing of; two 1-dimensional ridges. The Markov spectrum with averaging window=3 is; given in Figure 3.11. One can observe that this spectrum is smoother than; the original one. After applying the general peak searching function to; the M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:23113,log,logical,23113,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['log'],['logical']
Testability," verified the; variable is assigned to the value. The unified syntax for both checking a; numeric expression and capturing its value into a numeric variable is thus; ``[[#%<fmtspec>,<NUMVAR>: <constraint> <expr>]]`` with each element as; described previously. One can use this syntax to make a testcase more; self-describing by using variables instead of values:. .. code-block:: gas. ; CHECK: mov r[[#REG_OFFSET:]], 0x[[#%X,FIELD_OFFSET:12]]; ; CHECK-NEXT: load r[[#]], [r[[#REG_BASE:]], r[[#REG_OFFSET]]]. which would match:. .. code-block:: gas. mov r4, 0xC; load r6, [r5, r4]. The ``--enable-var-scope`` option has the same effect on numeric variables as; on string variables. Important note: In its current implementation, an expression cannot use a; numeric variable defined earlier in the same CHECK directive. FileCheck Pseudo Numeric Variables; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Sometimes there's a need to verify output that contains line numbers of the; match file, e.g. when testing compiler diagnostics. This introduces a certain; fragility of the match file structure, as ""``CHECK:``"" lines contain absolute; line numbers in the same file, which have to be updated whenever line numbers; change due to text addition or deletion. To support this case, FileCheck expressions understand the ``@LINE`` pseudo; numeric variable which evaluates to the line number of the CHECK pattern where; it is found. This way match patterns can be put near the relevant test lines and include; relative line number references, for example:. .. code-block:: c++. // CHECK: test.cpp:[[# @LINE + 4]]:6: error: expected ';' after top level declarator; // CHECK-NEXT: {{^int a}}; // CHECK-NEXT: {{^ \^}}; // CHECK-NEXT: {{^ ;}}; int a. To support legacy uses of ``@LINE`` as a special string variable,; :program:`FileCheck` also accepts the following uses of ``@LINE`` with string; substitution block syntax: ``[[@LINE]]``, ``[[@LINE+<offset>]]`` and; ``[[@LINE-<offset>]]`` without any spaces inside the bra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:33732,test,testing,33732,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['test'],['testing']
Testability," version cannot read). When future versions of ROOT utilize an IO feature that this version does not support, ROOT will provide a clear error message instead of crashing or returning garbage data. In future ROOT6 releases, forward-compatibility breaks will only be allowed if a non-default feature is enabled via the ``ROOT::Experimental`` namespace; it is expected ROOT7 will enable forward-compatibility breaks by default. - When a file using an unsupported file format feature is encountered, the error message will be similar to the following:; ```; Error in <TBasket::Streamer>: The value of fIOBits (00000000000000000000000001111110) contains unknown flags (supported flags are 00000000000000000000000000000001), indicating this was written with a newer version of ROOT utilizing critical IO features this version of ROOT does not support. Refusing to deserialize.; ```; - When an older version of ROOT, without this logic, encounters the file, the error message will be similar to the following:; ```; Error in <TBasket::Streamer>: The value of fNevBufSize is incorrect (-72) ; trying to recover by setting it to zero; ```. - Added an experimental feature that allows the IO libraries to skip writing out redundant information for some split classes, resulting in disk space savings. This is disabled by default and may be enabled by setting:. ```; ROOT::TIOFeatures features;; features.Set(ROOT::Experimental::EIOFeatures::kGenerateOffsetMap);; ttree_ref.SetIOFeatures(features);; ```; - Added `GetAutoSave()` and `SetAutoSave()` methods to `TBufferMerger`, to allow; it to accumulate several buffers in memory before merging, to reduce the; amount of compression work done due to `TTree` metadata. - Added a non-blocking callback mechanism to `TBufferMerger` to allow users to; control the rate at which data is pushed into the merging queue. The callback; mechanism can be used, for example, to launch tasks asynchronously whenever a; buffer is done processing. ## TTree Libraries. - Resolv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:8442,log,logic,8442,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['log'],['logic']
Testability," version of; libFuzzer. On Linux installations, this is typically located at:. .. code-block:: bash. /usr/lib/<llvm-version>/lib/clang/<clang-version>/lib/linux/libclang_rt.fuzzer_no_main-<architecture>.a. If building libFuzzer from source, this is located at the following path; in the build output directory:. .. code-block:: bash. lib/linux/libclang_rt.fuzzer_no_main-<architecture>.a. From here, the code can do whatever setup it requires, and when it's ready; to start fuzzing, it can call `LLVMFuzzerRunDriver`, passing in the program; arguments and a callback. This callback is invoked just like; `LLVMFuzzerTestOneInput`, and has the same signature. .. code-block:: c++. extern ""C"" int LLVMFuzzerRunDriver(int *argc, char ***argv,; int (*UserCb)(const uint8_t *Data, size_t Size));. Rejecting unwanted inputs; -------------------------. It may be desirable to reject some inputs, i.e. to not add them to the corpus. For example, when fuzzing an API consisting of parsing and other logic,; one may want to allow only those inputs into the corpus that parse successfully. If the fuzz target returns -1 on a given input,; libFuzzer will not add that input top the corpus, regardless of what coverage; it triggers. .. code-block:: c++. extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {; if (auto *Obj = ParseMe(Data, Size)) {; Obj->DoSomethingInteresting();; return 0; // Accept. The input may be added to the corpus.; }; return -1; // Reject; The input will not be added to the corpus.; }. Leaks; -----. Binaries built with AddressSanitizer_ or LeakSanitizer_ will try to detect; memory leaks at the process shutdown.; For in-process fuzzing this is inconvenient; since the fuzzer needs to report a leak with a reproducer as soon as the leaky; mutation is found. However, running full leak detection after every mutation; is expensive. By default (``-detect_leaks=1``) libFuzzer will count the number of; ``malloc`` and ``free`` calls when executing every mutation.; If t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:25800,log,logic,25800,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['log'],['logic']
Testability," violating nullability?; In some cases, it may make sense for methods to intentionally violate; nullability. For example, your method may — for reasons of backward; compatibility — chose to return nil and log an error message in a method; with a non-null return type when the client violated a documented precondition; rather than check the precondition with NSAssert(). In these cases, you; can suppress the analyzer warning with a cast:. return (id _Nonnull)nil;. Note that this cast does not affect code generation. Q: The analyzer assumes that a loop body is never entered. How can I tell it that the loop body will be entered at least once?. In the contrived example above, the analyzer has detected that the body of; the loop is never entered for the case where length <= 0. In this; particular example, you may know that the loop will always be entered because; the input parameter length will be greater than zero in all calls to this; function. You can teach the analyzer facts about your code as well as document; it by using assertions. By adding assert(length > 0) in the beginning; of the function, you tell the analyzer that your code is never expecting a zero; or a negative value, so it won't need to test the correctness of those paths. int foo(int length) {; int x = 0;; assert(length > 0);; for (int i = 0; i < length; i++); x += 1;; return length/x;; }. Q: How can I suppress a specific analyzer warning?; When you encounter an analyzer bug/false positive, check if it's one of the; issues discussed above or if the analyzer; annotations can; resolve the issue by helping the static analyzer understand the code better.; Second, please report it to help us improve; user experience.; Sometimes there's really no ""good"" way to eliminate the issue. In such cases; you can ""silence"" it directly by annotating the problematic line of code with; the help of Clang attribute 'suppress':. int foo() {; int *x = nullptr;; ...; [[clang::suppress]] {; // all warnings in this scope are supp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html:7702,assert,assertions,7702,interpreter/llvm-project/clang/www/analyzer/faq.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/faq.html,1,['assert'],['assertions']
Testability," void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. core.UndefinedBinaryOperatorResult; (C); Check for undefined results of binary operators. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. core.VLASize; (C); Check for declarations of VLA of undefined or zero size. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. core.uninitialized.ArraySubscript; (C); Check for uninitialized values used as array subscripts. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. core.uninitialized.Assign; (C); Check for assigning uninitialized values. void test() {; int x;; x |= 1; // warn: left expression is uninitialized; }. core.uninitialized.Branch; (C); Check for uninitialized values used as branch conditions. void test() {; int x;; if (x) // warn; return;; }. core.uninitialized.CapturedBlockVariable; (C); Check for blocks that capture uninitialized values. void test() {; int x;; ^{ int y = x; }(); // warn; }. core.uninitialized.UndefReturn; (C); Check for uninitialized values being returned to the caller. int test() {; int x;; return x; // warn; }. C++ Checkers. Name, DescriptionExample. cplusplus.NewDelete; (C++); Check for double-free, use-after-free and offset problems involving C++ ; delete. void f(int *p);. void testUseMiddleArgAfterDelete(int *p) {; delete p;; f(p); // warn: use after free; }. class SomeClass {; public:; void f();; };. void test() {; SomeClass *c = new SomeClass;; delete c;; c->f(); // warn: use after free; }. void test() {; int *p = (int *)__builtin_alloca(sizeof(int));; delete p; // warn: deleting memory allocated by alloca; }. void test() {; int *p = new int;; delete p;; delete p; // warn: attempt to free released; }. void test() {; int i;; delete &i; // warn: delete address of local; }. v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:4699,test,test,4699,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability," void test(char* string) {; char buf[24];; strcpy(buf, string); // warn; }. different.IntegerOverflow; (C); Integer overflow.; Note: partially handled by Clang core; (search for 'overflow in expression' warning in Clang tests).; Source: ; CWE-190. #include <limits.h>. int f(int x);. void test() {; f(INT_MAX + 1); // warn; }. #include <limits.h>. int test() {; int x = INT_MAX / 2 + 1;; return x * 2; // warn; }. different.SignExtension; (C); Unexpected sign extension might take place.; Source: ; CWE-194. unsigned long long test(long long sll) {; unsigned long long ull = sll; // warn; return ull;; }. void f(unsigned int i);. void test(int si) {; f(si); // warn; }. unsigned int test(int i) {; return i;; }. different.NumericTruncation; (C); Numeric truncation might take place.; Source: ; CWE-197. unsigned long test(unsigned long long ull) {; unsigned long ul = ull; // warn; return ul;; }. void f(int i);. void test(long long sll) {; f(sll); // warn; }. int f();. short test(long long sll) {; short ss = f();; return ss;; }. different.MissingCopyCtorAssignOp; (C++); A class has dynamically allocated data members but do not define a copy; constructor/assignment operator.; Source: Scott Meyers ""Effective C++"", item 11: Prevent exceptions from; leaving destructors. class C {; int *p; // warn; public:; C() { p = new int; }; ~C() { delete p; }; };. WinAPI. Name, DescriptionExampleProgress. WinAPI.CreateProcess; (C); CreateProcess(): if the first parameter ; lpApplicationName is NULL then the executable name must be in the; white space-delimited string pointed to by lpCommandLine.; If the executable or path name has a space in it, there is a risk that a; different executable could be run because of the way the function parses; spaces.; Source: ; MSDN: CreateProcess function, Security Remarks. #include <windows.h>. void test() {; STARTUPINFO si;; PROCESS_INFORMATION pi;; CreateProcess(NULL, TEXT(""C:\\Program Files\\App -L -S""),; NULL, NULL, TRUE, 0, NULL, NULL, &si, π);; // warn; }.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:25419,test,test,25419,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability," volumes) models, only most significant volumes are shown; - one could activate several clip planes (only with WebGL); - interaction with object browser to change visibility flags or focus on selected volume; - support of floating browser for TGeo objects; - intensive use of HTML Worker to offload computation tasks and keep interactivity; - enable more details when changing camera position/zoom; - Improvements in histograms 3D drawing; - all lego options: lego1..lego4, combined with 'fb', 'bb', '0' or 'z'; - support axis labels on lego plots; - support lego plots for TH1; - Significant (up to factor 10) performance improvement in 3D-graphics; - Implement ROOT6-like color palettes; - Support non-equidistant bins for TH1/TH2 objects.; - Improve TF1 drawing - support exp function in TFormula, fix errors with logx scale, enable zoom-in, (re)calculate function points when zooming; - Introduce many context menus for improving interactivity; - Implement col0 and col0z draw option for TH2 histograms, similar to ROOT6; - Implement box and hbox draw options for TH1 class; - Significant (factor 4) I/O performance improvement; - New 'flex' layout:; - create frames like in Multi Document Interface; - one could move/resize/minimize/maximize such frames. For more details, like the complete change log, the documentation, and very detailed examples, see the [JSROOT home page](https://root.cern.ch/js) and the [JSROOT project github page](https://github.com/linev/jsroot) . ## Tutorials; * New tutorial `treegetval.C` illustrating how to retrieve `TTree` variables in arrays.; * Add script to automatically translate tutorials into notebooks; * Embed it into the documentation generation; * Make the notebooks available in the [tutorials section of the class documentation](https://root.cern/doc/master/group__Tutorials.html). ## Build, Configuration and Testing Infrastructure; - `root-config` does not suppress deprecation warnings (-Wno-deprecated-declarations) anymore. This means compilers ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:27152,log,logx,27152,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['log'],['logx']
Testability," warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. Core Alpha Checkers. Name, DescriptionExample. alpha.core.BoolAssignment; (ObjC); Warn about assigning non-{0,1} values to boolean variables. void test() {; BOOL b = -1; // warn; }. alpha.core.CallAndMessageUnInitRefArg; (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an; object are unrelated. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. alpha.core.FixedAddr; (C); Check for assignment of a fixed address to a pointer. void test() {; int *p;; p = (int *) 0x10000; // warn; }. alpha.core.IdenticalExpr; (C, C++); Warn about suspicious uses of identical expressions. // C; void test() {; int a = 5;; int b = a | 4 | a; // wa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:1695,test,test,1695,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['test'],['test']
Testability," warnings, they are used to; support the analyzer core and model known APIs. See also; Default Checkers; and Experimental (Alpha) Checkers. Core Implicit Checkers; OS X Implicit Checkers. Core Implicit Checkers. Name, DescriptionExample. core.DynamicTypePropagation; (C++, ObjC); Generate dynamic type information. // C++; class A {; public:; A(int x) {}; virtual int foo();; };. class B: public A {; public:; B(); :A(foo()); // DynamicTypeInfo for 'this' rigion will wrap type 'A'; // unless the base constructor call expression is processed; {}; virtual int foo();; };. // Objective-C; @interface MyClass : NSObject {}; @end. @implementation MyClass; + (void)foo {; MyClass *x = [[self alloc] init];; // DynamicTypeInfo from a cast: from 'id' to 'MyClass *'; }; @end. void test() {; MyClass *x = [MyClass alloc];; // DynamicTypeInfo from a call to alloc:; // from 'id' to 'MyClass *'; }. core.builtin.BuiltinFunctions; (C); Evaluate compiler builtin functions (e.g., alloca()). void test(int x) {; int *p = (int *)__builtin_alloca(8);; // evaluates to AllocaRegion. if(__builtin_expect(x > 10, 0)) // evaluates to 'x > 10'; x = 0;; }. core.builtin.NoReturnFunctions; (C, ObjC); Evaluate ""panic"" functions that are known to not return to the caller. // C; void test() {; panic(); // generate sink; }. // Objective-C; @interface MyObj : NSObject {}; - (void)foo;; @end. @implementation MyObj; - (void)foo {; [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd; object:self; file:(@""somefile.m""); lineNumber:1; description:(@""some text"")];; // generate sink; }; @end. OS X Implicit Checkers. Name, DescriptionExample. osx.cocoa.Loops; (ObjC); Improved modeling of loops using Cocoa collection types. void test() {; id x;; for (x in [NSArray testObject]) {; // assume the value of 'x' is non-nil; }; }. osx.cocoa.NonNilReturnValue; (ObjC); Model the APIs that are guaranteed to return a non-nil value. void test(NSArray *A) {; id subscriptObj = A[1]; // assume the value is non-nil; }. ; . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/implicit_checks.html:1075,test,test,1075,interpreter/llvm-project/clang/www/analyzer/implicit_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/implicit_checks.html,5,['test'],"['test', 'testObject']"
Testability," way for the user; See [the online documentation](https://root.cern.ch/doc/master/classROOT_1_1Experimental_1_1TDF_1_1TDataFrame.html) for more details. ## 2D Graphics Libraries; - If one used ""col2"" or ""colz2"", the value of `TH1::fMaximum` got modified.; This deviated from the behavior of ""col"" or ""colz"". This is now fixed as; requested [here](https://sft.its.cern.ch/jira/browse/ROOT-8389).; - When the option SAME (or ""SAMES"") is used with the option COL, the boxes' color; are computing taking the previous plots into account. The range along the Z axis; is imposed by the first plot (the one without option SAME); therefore the order; in which the plots are done is relevant.; - With option BOX on 2D histos with negative content:; - do not draw the empty bins as requested [here](https://sft.its.cern.ch/jira/browse/ROOT-8385).; - fix the issue mentioned [here](https://sft.its.cern.ch/jira/browse/ROOT-*402).; - When several histogram were drawn on top of each other with the option; `BOX SAME` and if the log scale along Z was on, the plot showed only the; first histogram. This can be reproduce by using the documentation example; illustrating `BOX SAME`and turning the canvas into log scale along Z.; - In TLatex:; - Do not paint the text when the text size is <= 0. This fixes; the problem mentioned [here](https://sft.its.cern.ch/jira/browse/ROOT-8305); - Do not paint text if the text string is empty.; - From: Sergey Linev: In `TPad::SaveAs` method json file extension is now handled; - Because of some precision issue some data points exactly on the plot limits of; a `TGraph2D` were not drawn (option `P`).; The problem was reported [here](https://sft.its.cern.ch/jira/browse/ROOT-8447).; - New options for automatic coloring of graphs and histograms. When several; histograms or graphs are painted in the same canvas thanks to the option ""SAME""; via a `THStack` or `TMultigraph` it might be useful to have an easy and automatic; way to choose their color. The simplest way is to pi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:8101,log,log,8101,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['log'],['log']
Testability," way; to the stack (the two marked instrs): spilling it to a GPR is quite enough. Implementing this will require some codegen improvements. Nate writes:. ""So basically what we need to support the ""no stack frame save and restore"" is a; generalization of the LR optimization to ""callee-save regs"". Currently, we have LR marked as a callee-save reg. The register allocator sees; that it's callee save, and spills it directly to the stack. Ideally, something like this would happen:. LR would be in a separate register class from the GPRs. The class of LR would be; marked ""unspillable"". When the register allocator came across an unspillable; reg, it would ask ""what is the best class to copy this into that I *can* spill""; If it gets a class back, which it will in this case (the gprs), it grabs a free; register of that class. If it is then later necessary to spill that reg, so be; it. ===-------------------------------------------------------------------------===. We compile this:; int test(_Bool X) {; return X ? 524288 : 0;; }. to: ; _test:; cmplwi cr0, r3, 0; lis r2, 8; li r3, 0; beq cr0, LBB1_2 ;entry; LBB1_1: ;entry; mr r3, r2; LBB1_2: ;entry; blr . instead of:; _test:; addic r2,r3,-1; subfe r0,r2,r3; slwi r3,r0,19; blr. This sort of thing occurs a lot due to globalopt. ===-------------------------------------------------------------------------===. We compile:. define i32 @bar(i32 %x) nounwind readnone ssp {; entry:; %0 = icmp eq i32 %x, 0 ; <i1> [#uses=1]; %neg = sext i1 %0 to i32 ; <i32> [#uses=1]; ret i32 %neg; }. to:. _bar:; 	cntlzw r2, r3; 	slwi r2, r2, 26; 	srawi r3, r2, 31; 	blr . it would be better to produce:. _bar: ; addic r3,r3,-1; subfe r3,r3,r3; blr. ===-------------------------------------------------------------------------===. We generate horrible ppc code for this:. #define N 2000000; double a[N],c[N];; void simpleloop() {; int j;; for (j=0; j<N; j++); c[j] = a[j];; }. LBB1_1: ;bb; lfdx f0, r3, r4; addi r5, r5, 1 ;; Extra IV for the exit value compare.; s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt:7888,test,test,7888,interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,1,['test'],['test']
Testability," we have to convert every function part into some number, and then add it; into the hash. The lookup-up time would be small, but such an approach adds some; delay due to the hashing routine. Logarithmical search; """"""""""""""""""""""""""""""""""""""""; We could introduce total ordering among the functions set, once ordered we; could then implement a logarithmical search. Lookup time still depends on N,; but adds a little of delay (*log(N)*). Present state; """"""""""""""""""""""""""; Both of the approaches (random-access and logarithmical) have been implemented; and tested and both give a very good improvement. What was most; surprising is that logarithmical search was faster; sometimes by up to 15%. The; hashing method needs some extra CPU time, which is the main reason why it works; slower; in most cases, total ""hashing"" time is greater than total; ""logarithmical-search"" time. So, preference has been granted to the ""logarithmical search"". Though in the case of need, *logarithmical-search* (read ""total-ordering"") could; be used as a milestone on our way to the *random-access* implementation. Every comparison is based either on the numbers or on the flags comparison. In; the *random-access* approach, we could use the same comparison algorithm.; During comparison, we exit once we find the difference, but here we might have; to scan the whole function body every time (note, it could be slower). Like in; ""total-ordering"", we will track every number and flag, but instead of; comparison, we should get the numbers sequence and then create the hash number.; So, once again, *total-ordering* could be considered as a milestone for even; faster (in theory) random-access approach. MergeFunctions, main fields and runOnModule; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; There are two main important fields in the class:. ``FnTree`` – the set of all unique functions. It keeps items that couldn't be; merged with each other. It is defined as:. ``std::set<FunctionNode> FnTree;``. Here ``FunctionNode`` is a wrapper ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:6858,log,logarithmical-search,6858,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['log'],['logarithmical-search']
Testability," we need something else. 2. Provide a **format adapter** inheriting from ``llvm::FormatAdapter<T>``. .. code-block:: c++. namespace anything {; struct format_int_custom : public llvm::FormatAdapter<int> {; explicit format_int_custom(int N) : llvm::FormatAdapter<int>(N) {}; void format(llvm::raw_ostream &Stream, StringRef Style) override {; // Do whatever is necessary to format ``this->Item`` into ``Stream``; }; };; }; namespace llvm {; void foo() {; std::string S = formatv(""{0}"", anything::format_int_custom(42));; }; }. If the type is detected to be derived from ``FormatAdapter<T>``, ``formatv``; will call the; ``format`` method on the argument passing in the specified style. This allows; one to provide custom formatting of any type, including one which already has; a builtin format provider. ``formatv`` Examples; ^^^^^^^^^^^^^^^^^^^^; Below is intended to provide an incomplete set of examples demonstrating; the usage of ``formatv``. More information can be found by reading the; doxygen documentation or by looking at the unit test suite. .. code-block:: c++. std::string S;; // Simple formatting of basic types and implicit string conversion.; S = formatv(""{0} ({1:P})"", 7, 0.35); // S == ""7 (35.00%)"". // Out-of-order referencing and multi-referencing; outs() << formatv(""{0} {2} {1} {0}"", 1, ""test"", 3); // prints ""1 3 test 1"". // Left, right, and center alignment; S = formatv(""{0,7}"", 'a'); // S == "" a"";; S = formatv(""{0,-7}"", 'a'); // S == ""a "";; S = formatv(""{0,=7}"", 'a'); // S == "" a "";; S = formatv(""{0,+7}"", 'a'); // S == "" a"";. // Custom styles; S = formatv(""{0:N} - {0:x} - {1:E}"", 12345, 123908342); // S == ""12,345 - 0x3039 - 1.24E8"". // Adapters; S = formatv(""{0}"", fmt_align(42, AlignStyle::Center, 7)); // S == "" 42 ""; S = formatv(""{0}"", fmt_repeat(""hi"", 3)); // S == ""hihihi""; S = formatv(""{0}"", fmt_pad(""hi"", 2, 6)); // S == "" hi "". // Ranges; std::vector<int> V = {8, 9, 10};; S = formatv(""{0}"", make_range(V.begin(), V.end())); // S == ""8, 9, 10""; S = formatv(""{",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:15189,test,test,15189,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['test'],['test']
Testability," when the start time is within 1; second.; Fix worker name in TSlaveLite.; Fix problem with enabling packages with option 'notOnClient' in; PROOF-Lite .; Make sure the log file is flushed at the end of startup to avoid; spurious log messages on next commands .; In CreateSession(), fix an issue with the validity check for existing; sessions .; In TProofLite: fix problem with passing the 'varexp' and 'selection'; strings for processing, preventing correct usage of the operators '|'; and '||' in TTreeFormula.; In the TProofOutputFile constructor, remove the 'localroot' prefix; only if present in the path. Fixes possible truncation problems; occuring when the paths are not under the localroot scope.; In TXSocket and TXSlave: fix problem with the way collection over a; socket just marked as 'bad' was interrupted; the interrupt was de facto; ineffective, so that collection stayed always until the timeout expired; (default: 5 minutes). Should solve some of the cases were slow response; was experienced.; Fix a problem with log path transmission when the node dies early or; not even starts. The log path was empty and wrong was filled in when; retrieving the log buffers, disorienting debugging.; Fix a bug checking the first event which rendered ineffective the; request for processing a subset of events in a given dataset or; chain.; In pq2-ana-dist, fix problem with the labels of the distribution; histo occuring when machines are represented by IPs instead of; names.; Add missing calls to closedir() and TSystem::FreeDirectory, cuasing a; large number of filedescriptors remaining opened after xproofd; initialization.; Fix a problem with the final update of the progress information; affecting occasionally cases with skipped events.; Fix merging of TproofOutputFile when using submergers (the; intermediate files were not correctly handled).; Fix the way TChain weights are transmitted to TProofDraw in; DrawSelect operations. AoB; ; The class TFileMerger has been moved to 'io/io'. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:7109,log,log,7109,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,3,['log'],['log']
Testability," when; execution is correct rather than overwriting it. We now have a value in `%rax` in each basic block that indicates if at some; point previously a predicate was mispredicted. And we have arranged for that; value to be particularly effective when used below to harden loads. ##### Indirect Call, Branch, and Return Predicates. There is no analogous flag to use when tracing indirect calls, branches, and; returns. The predicate state must be accumulated through some other means.; Fundamentally, this is the reverse of the problem posed in CFI: we need to; check where we came from rather than where we are going. For function-local; jump tables, this is easily arranged by testing the input to the jump table; within each destination (not yet implemented, use retpolines):; ```; pushq %rax; xorl %eax, %eax # Zero out initial predicate state.; movq $-1, %r8 # Put all-ones mask into a register.; jmpq *.LJTI0_0(,%rdi,8) # Indirect jump through table.; .LBB0_2: # %sw.bb; testq $0, %rdi # Validate index used for jump table.; cmovneq %r8, %rax # Conditionally update predicate state.; ...; jmp _Z4leaki # TAILCALL. .LBB0_3: # %sw.bb1; testq $1, %rdi # Validate index used for jump table.; cmovneq %r8, %rax # Conditionally update predicate state.; ...; jmp _Z4leaki # TAILCALL. .LBB0_5: # %sw.bb10; testq $2, %rdi # Validate index used for jump table.; cmovneq %r8, %rax # Conditionally update predicate state.; ...; jmp _Z4leaki # TAILCALL; ... .section .rodata,""a"",@progbits; .p2align 3; .LJTI0_0:; .quad .LBB0_2; .quad .LBB0_3; .quad .LBB0_5; ...; ```. Returns have a simple mitigation technique on x86-64 (or other ABIs which have; what is called a ""red zone"" region beyond the end of the stack). This region is; guaranteed to be preserved across interrupts and context switches, making the; return address used in returning to the current code remain on the stack and; valid to read. We can emit code in the caller to verify that a return edge was; not mispredicted:; ```; callq other_functi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:18508,test,testq,18508,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['test'],['testq']
Testability," where the logs are generated and of; the host operating system and machine architecture where the filter runs. This format assumes that the symbolizing filter processes intact whole lines. If; long lines might be split during some stage of a logging pipeline, they must be; reassembled to restore the original line breaks before feeding lines into the; symbolizing filter. Most markup elements must appear entirely on a single line; (often with other text before and/or after the markup element). There are some; markup elements that are specified to span lines, with line breaks in the middle; of the element. Even in those cases, the filter is not expected to handle line; breaks in arbitrary places inside a markup element, but only inside certain; fields. This format assumes that the symbolizing filter processes a coherent stream of; log lines from a single process address space context. If a logging stream; interleaves log lines from more than one process, these must be collated into; separate per-process log streams and each stream processed by a separate; instance of the symbolizing filter. Because the kernel and user processes use; disjoint address regions in most operating systems, a single user process; address space plus the kernel address space can be treated as a single address; space for symbolization purposes if desired. Dependence on Build IDs; =======================. The symbolizer markup scheme relies on contextual information about runtime; memory address layout to make it possible to convert markup elements into useful; symbolic form. This relies on having an unmistakable identification of which; binary was loaded at each address. An ELF Build ID is the payload of an ELF note with name ``""GNU""`` and type; ``NT_GNU_BUILD_ID``, a unique byte sequence that identifies a particular binary; (executable, shared library, loadable module, or driver module). The linker; generates this automatically based on a hash that includes the complete symbol; table and debug",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:3030,log,logging,3030,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,3,['log'],"['log', 'logging']"
Testability," which; :ref:`doesn't imply you have to build all of them <build_single_project>`. You; can still build only compiler-rt for instance. In this way it's not different; from someone who would check out all the projects with SVN today. If you want to avoid checking out all the sources, you can hide the other; directories using a Git sparse checkout::. git config core.sparseCheckout true; echo /compiler-rt > .git/info/sparse-checkout; git read-tree -mu HEAD. The data for all sub-projects is still in your `.git` directory, but in your; checkout, you only see `compiler-rt`.; Before you push, you'll need to fetch and rebase (`git pull --rebase`) as; usual. Note that when you fetch you'll likely pull in changes to sub-projects you don't; care about. If you are using sparse checkout, the files from other projects; won't appear on your disk. The only effect is that your commit hash changes. You can check whether the changes in the last fetch are relevant to your commit; by running::. git log origin/main@{1}..origin/main -- libcxx. This command can be hidden in a script so that `git llvmpush` would perform all; these steps, fail only if such a dependent change exists, and show immediately; the change that prevented the push. An immediate repeat of the command would; (almost) certainly result in a successful push.; Note that today with SVN or git-svn, this step is not possible since the; ""rebase"" implicitly happens while committing (unless a conflict occurs). Checkout/Clone Multiple Projects, with Commit Access; ----------------------------------------------------. Let's look how to assemble llvm+clang+libcxx at a given revision. Currently; ^^^^^^^^^. ::. svn co https://llvm.org/svn/llvm-project/llvm/trunk llvm -r $REVISION; cd llvm/tools; svn co https://llvm.org/svn/llvm-project/clang/trunk clang -r $REVISION; cd ../projects; svn co https://llvm.org/svn/llvm-project/libcxx/trunk libcxx -r $REVISION. Or using git-svn::. git clone https://llvm.org/git/llvm.git; cd llvm/; git svn ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:14715,log,log,14715,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['log'],['log']
Testability," which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass in the --no-progress-bar option if you wish to disable; progress indications while the tests are running.; Your output might look something like this:; lit.py: lit.cfg:152: note: using clang: 'C:\Tools\llvm\bin\Release\clang.EXE'; -- Testing: Testing: 2534 tests, 4 threads --; Testing: 0 .. 10.. 20.. 30.. 40.. 50.. 60.. 70.. 80.. 90..; Testing Time: 81.52s; Passed : 2503; Expectedly Failed: 28; Unsupported : 3. The statistic, ""Failed"" (not shown if all tests pass), is the important one. Testing changes affecting libc++. Some changes in Clang affect libc++,; for example:. Changing the output of Clang's diagnostics.; Changing compiler builtins, especially the builtins used for type traits; or replacements of library functions like std::move or; std::forward. After adjusting libc++ to work with the changes, the next revision will be; tested by libc++'s; pre-commit CI. For most configurations, the pre-commit CI uses a recent; nightly build of Clang from LLVM's main; branch. These configurations do not use the Clang changes in the; patch. They only use the libc++ changes.; The ""Bootstrapping build"" builds Clang and uses it to build and; test libc++. This build does use the Clang changes in the patch.; Libc++ supports multiple versions of Clang",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:7653,test,tests,7653,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,1,['test'],['tests']
Testability," while the main; reason for it to exist is extreme speed. Q. Does libFuzzer Support Windows?; ------------------------------------------------------------------------------------. Yes, libFuzzer now supports Windows. Initial support was added in r341082.; Any build of Clang 9 supports it. You can download a build of Clang for Windows; that has libFuzzer from; `LLVM Snapshot Builds <https://llvm.org/builds/>`_. Using libFuzzer on Windows without ASAN is unsupported. Building fuzzers with the; ``/MD`` (dynamic runtime library) compile option is unsupported. Support for these; may be added in the future. Linking fuzzers with the ``/INCREMENTAL`` link option; (or the ``/DEBUG`` option which implies it) is also unsupported. Send any questions or comments to the mailing list: libfuzzer(#)googlegroups.com. Q. When libFuzzer is not a good solution for a problem?; ---------------------------------------------------------. * If the test inputs are validated by the target library and the validator; asserts/crashes on invalid inputs, in-process fuzzing is not applicable.; * Bugs in the target library may accumulate without being detected. E.g. a memory; corruption that goes undetected at first and then leads to a crash while; testing another input. This is why it is highly recommended to run this; in-process fuzzer with all sanitizers to detect most bugs on the spot.; * It is harder to protect the in-process fuzzer from excessive memory; consumption and infinite loops in the target library (still possible).; * The target library should not have significant global state that is not; reset between the runs.; * Many interesting target libraries are not designed in a way that supports; the in-process fuzzer interface (e.g. require a file path instead of a; byte array).; * If a single test run takes a considerable fraction of a second (or; more) the speed benefit from the in-process fuzzer is negligible.; * If the target library runs persistent threads (that outlive; execution of one",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:29380,test,test,29380,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,2,"['assert', 'test']","['asserts', 'test']"
Testability," will be executed. When the config file is; executed, two important global variables are predefined:. **lit_config**. The global **lit** configuration object (a *LitConfig* instance), which defines; the builtin test formats, global configuration parameters, and other helper; routines for implementing test configurations. **config**. This is the config object (a *TestingConfig* instance) for the test suite,; which the config file is expected to populate. The following variables are also; available on the *config* object, some of which must be set by the config and; others are optional or predefined:. **name** *[required]* The name of the test suite, for use in reports and; diagnostics. **test_format** *[required]* The test format object which will be used to; discover and run tests in the test suite. Generally this will be a builtin test; format available from the *lit.formats* module. **test_source_root** The filesystem path to the test suite root. For out-of-dir; builds this is the directory that will be scanned for tests. **test_exec_root** For out-of-dir builds, the path to the test suite root inside; the object directory. This is where tests will be run and temporary output files; placed. **environment** A dictionary representing the environment to use when executing; tests in the suite. **standalone_tests** When true, mark a directory with tests expected to be run; standalone. Test discovery is disabled for that directory. *lit.suffixes* and; *lit.excludes* must be empty when this variable is true. **suffixes** For **lit** test formats which scan directories for tests, this; variable is a list of suffixes to identify test files. Used by: *ShTest*. **substitutions** For **lit** test formats which substitute variables into a test; script, the list of substitutions to perform. Used by: *ShTest*. **unsupported** Mark an unsupported directory, all tests within it will be; reported as unsupported. Used by: *ShTest*. **parent** The parent configuration, this is the con",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:15924,test,tests,15924,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['tests']
Testability," will exit with the status 0. Other exit codes are used; for non-test related failures (for example a user error or an internal program; error). .. _test-discovery:. TEST DISCOVERY; --------------. The inputs passed to :program:`lit` can be either individual tests, or entire; directories or hierarchies of tests to run. When :program:`lit` starts up, the; first thing it does is convert the inputs into a complete list of tests to run; as part of *test discovery*. In the :program:`lit` model, every test must exist inside some *test suite*.; :program:`lit` resolves the inputs specified on the command line to test suites; by searching upwards from the input path until it finds a :file:`lit.cfg` or; :file:`lit.site.cfg` file. These files serve as both a marker of test suites; and as configuration files which :program:`lit` loads in order to understand; how to find and run the tests inside the test suite. Once :program:`lit` has mapped the inputs into test suites it traverses the; list of inputs adding tests for individual files and recursively searching for; tests in directories. This behavior makes it easy to specify a subset of tests to run, while still; allowing the test suite configuration to control exactly how tests are; interpreted. In addition, :program:`lit` always identifies tests by the test; suite they are in, and their relative path inside the test suite. For; appropriately configured projects, this allows :program:`lit` to provide; convenient and flexible support for out-of-tree builds. .. _test-status-results:. TEST STATUS RESULTS; -------------------. Each test ultimately produces one of the following eight results:. **PASS**. The test succeeded. **FLAKYPASS**. The test succeeded after being re-run more than once. This only applies to; tests containing an ``ALLOW_RETRIES:`` annotation. **XFAIL**. The test failed, but that is expected. This is used for test formats which allow; specifying that a test does not currently work, but wish to leave it in the test;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:11753,test,test,11753,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,3,['test'],"['test', 'tests']"
Testability," will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems, you need to use structures with same length members.; If your structure does not qualify, you need to create one branch for; each element of the structure. The leaf name is NOT used to pick the variable out of the structure, but; is only used as the name for the leaf. This me",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:19257,test,test,19257,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['test'],['test']
Testability," win. //===----------------------------------------------------------------------===//. extract_vector_elt of an arbitrary constant vector can be done with the ; following instructions:. vTemp = vec_splat(v0,2); // 2 is the element the src is in.; vec_ste(&destloc,0,vTemp);. We can do an arbitrary non-constant value by using lvsr/perm/ste. //===----------------------------------------------------------------------===//. If we want to tie instruction selection into the scheduler, we can do some; constant formation with different instructions. For example, we can generate; ""vsplti -1"" with ""vcmpequw R,R"" and 1,1,1,1 with ""vsubcuw R,R"", and 0,0,0,0 with; ""vsplti 0"" or ""vxor"", each of which use different execution units, thus could; help scheduling. This is probably only reasonable for a post-pass scheduler. //===----------------------------------------------------------------------===//. For this function:. void test(vector float *A, vector float *B) {; vector float C = (vector float)vec_cmpeq(*A, *B);; if (!vec_any_eq(*A, *B)); *B = (vector float){0,0,0,0};; *A = C;; }. we get the following basic block:. 	...; lvx v2, 0, r4; lvx v3, 0, r3; vcmpeqfp v4, v3, v2; vcmpeqfp. v2, v3, v2; bne cr6, LBB1_2 ; cond_next. The vcmpeqfp/vcmpeqfp. instructions currently cannot be merged when the; vcmpeqfp. result is used by a branch. This can be improved. //===----------------------------------------------------------------------===//. The code generated for this is truly aweful:. vector float test(float a, float b) {; return (vector float){ 0.0, a, 0.0, 0.0}; ; }. LCPI1_0: ; float; .space 4; .text; .globl _test; .align 4; _test:; mfspr r2, 256; oris r3, r2, 4096; mtspr 256, r3; lis r3, ha16(LCPI1_0); addi r4, r1, -32; stfs f1, -16(r1); addi r5, r1, -16; lfs f0, lo16(LCPI1_0)(r3); stfs f0, -32(r1); lvx v2, 0, r4; lvx v3, 0, r5; vmrghw v3, v3, v2; vspltw v2, v2, 0; vmrghw v2, v2, v3; mtspr 256, r2; blr. //===----------------------------------------------------------------------===//. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt:3063,test,test,3063,interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,1,['test'],['test']
Testability," with -gmodules."" ON); else(); option(LLVM_ENABLE_MODULE_DEBUGGING ""Compile with -gmodules."" OFF); endif(); option(LLVM_ENABLE_LOCAL_SUBMODULE_VISIBILITY ""Compile with -fmodules-local-submodule-visibility."" ON); option(LLVM_ENABLE_LIBCXX ""Use libc++ if available."" OFF); option(LLVM_ENABLE_LLVM_LIBC ""Set to on to link all LLVM executables against LLVM libc, assuming it is accessible by the host compiler."" OFF); option(LLVM_STATIC_LINK_CXX_STDLIB ""Statically link the standard library."" OFF); option(LLVM_ENABLE_LLD ""Use lld as C and C++ linker."" OFF); option(LLVM_ENABLE_PEDANTIC ""Compile with pedantic enabled."" ON); option(LLVM_ENABLE_WERROR ""Fail and stop if a warning is triggered."" OFF). option(LLVM_ENABLE_DUMP ""Enable dump functions even when assertions are disabled"" OFF); option(LLVM_UNREACHABLE_OPTIMIZE ""Optimize llvm_unreachable() as undefined behavior (default), guaranteed trap when OFF"" ON). if( NOT uppercase_CMAKE_BUILD_TYPE STREQUAL ""DEBUG"" ); option(LLVM_ENABLE_ASSERTIONS ""Enable assertions"" OFF); else(); option(LLVM_ENABLE_ASSERTIONS ""Enable assertions"" ON); endif(). option(LLVM_ENABLE_EXPENSIVE_CHECKS ""Enable expensive checks"" OFF). # While adding scalable vector support to LLVM, we temporarily want to; # allow an implicit conversion of TypeSize to uint64_t, and to allow; # code to get the fixed number of elements from a possibly scalable vector.; # This CMake flag enables a more strict mode where it asserts that the type; # is not a scalable vector type.; #; # Enabling this flag makes it easier to find cases where the compiler makes; # assumptions on the size being 'fixed size', when building tests for; # SVE/SVE2 or other scalable vector architectures.; option(LLVM_ENABLE_STRICT_FIXED_SIZE_VECTORS; ""Enable assertions that type is not scalable in implicit conversion from TypeSize to uint64_t and calls to getNumElements"" OFF). set(LLVM_ABI_BREAKING_CHECKS ""WITH_ASSERTS"" CACHE STRING; ""Enable abi-breaking checks. Can be WITH_ASSERTS, FORCE_ON or FORCE_OFF."")",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:25318,assert,assertions,25318,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,2,['assert'],['assertions']
Testability," with a value of ``10``. .. option:: -l. Display verbose address and offset information for segments and sections in; Mach-O files in ``darwin`` format. .. option:: --format=<format>. Set the output format to the ``<format>`` specified. Available ``<format>``; options are ``berkeley`` (the default), ``sysv`` and ``darwin``. Berkeley output summarises text, data and bss sizes in each file, as shown; below for a typical pair of ELF files:. .. code-block:: console. $ llvm-size --format=berkeley test.o test2.o; text data bss dec hex filename; 182 16 5 203 cb test.elf; 82 8 1 91 5b test2.o. For Mach-O files, the output format is slightly different:. .. code-block:: console. $ llvm-size --format=berkeley macho.obj macho2.obj; __TEXT __DATA __OBJC others dec hex; 4 8 0 0 12 c macho.obj; 16 32 0 0 48 30 macho2.obj. Sysv output displays size and address information for most sections, with each; file being listed separately:. .. code-block:: console. $ llvm-size --format=sysv test.elf test2.o; test.elf :; section size addr; .eh_frame 92 2097496; .text 90 2101248; .data 16 2105344; .bss 5 2105360; .comment 209 0; Total 412. test2.o :; section size addr; .text 26 0; .data 8 0; .bss 1 0; .comment 106 0; .note.GNU-stack 0 0; .eh_frame 56 0; .llvm_addrsig 2 0; Total 199. ``darwin`` format only affects Mach-O input files. If an input of a different; file format is specified, :program:`llvm-size` falls back to ``berkeley``; format. When producing ``darwin`` format, the tool displays information about; segments and sections:. .. code-block:: console. $ llvm-size --format=darwin macho.obj macho2.obj; macho.obj:; Segment : 12; Section (__TEXT, __text): 4; Section (__DATA, __data): 8; total 12; total 12; macho2.obj:; Segment : 48; Section (__TEXT, __text): 16; Section (__DATA, __data): 32; total 48; total 48. .. option:: --help, -h. Display a summary of command line options. .. option:: -m. Equivalent to :option:`--format` with a value of ``darwin``. .. option:: -o. Equivalent to :optio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-size.rst:2190,test,test,2190,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-size.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-size.rst,1,['test'],['test']
Testability, with the same Python version as ROOT; set(root_jupyter_dir notebook); set(root_jupyter_config jupyter_notebook_config.py); configure_file(etc/${root_jupyter_dir}/${root_jupyter_config}.in etc/${root_jupyter_dir}/${root_jupyter_config}); install(FILES ${CMAKE_BINARY_DIR}/etc/${root_jupyter_dir}/${root_jupyter_config} DESTINATION ${CMAKE_INSTALL_SYSCONFDIR}/${root_jupyter_dir}). set(root_kernel_dir ${root_jupyter_dir}/kernels/root); set(root_kernel_file kernel.json); configure_file(etc/${root_kernel_dir}/${root_kernel_file}.in etc/${root_kernel_dir}/${root_kernel_file}); install(FILES ${CMAKE_BINARY_DIR}/etc/${root_kernel_dir}/${root_kernel_file} DESTINATION ${CMAKE_INSTALL_SYSCONFDIR}/${root_kernel_dir}). #---install clad header files-------------------------------------------------------------------; if(clad); install(DIRECTORY ${CMAKE_BINARY_DIR}/etc/cling/plugins/; DESTINATION ${CMAKE_INSTALL_SYSCONFDIR}/cling/plugins); endif(). #---Set flag for PyROOT tests that are expected to fail; if(pyroot); set(PYTESTS_WILLFAIL WILLFAIL); endif(). #---Configure Testing using CTest----------------------------------------------------------------; configure_file(${CMAKE_SOURCE_DIR}/cmake/modules/CTestCustom.cmake ${CMAKE_BINARY_DIR} COPYONLY); if(testing); include(RootCTest); set(upstreamprefix https://github.com/root-project). if(roottest); find_package(Git REQUIRED). # Check whether the repository exists in the source directory or its parent; get_filename_component(source_dir ${CMAKE_CURRENT_SOURCE_DIR} REALPATH); if(IS_DIRECTORY ${source_dir}/roottest/.git); set(repo_dir ${source_dir}/roottest); elseif(IS_DIRECTORY ${source_dir}/../roottest/.git); set(repo_dir ${source_dir}/../roottest); endif(); if(DEFINED repo_dir); execute_process(COMMAND ${GIT_EXECUTABLE} --git-dir=${repo_dir}/.git; remote get-url origin OUTPUT_VARIABLE originurl OUTPUT_STRIP_TRAILING_WHITESPACE). else(); # The fetch URL of the 'origin' remote is used to determine the prefix for other repositories by; #,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:27702,test,tests,27702,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['test'],['tests']
Testability," with the; ``i686-pc-win32`` target, ``%itanium_abi_triple`` will expand to; ``i686-pc-mingw32``. This allows a test to run with a specific ABI without; constraining it to a specific triple. **FileCheck-specific substitutions:**. ``%ProtectFileCheckOutput``; This should precede a ``FileCheck`` call if and only if the call's textual; output affects test results. It's usually easy to tell: just look for; redirection or piping of the ``FileCheck`` call's stdout or stderr. .. _Test-specific substitutions:. **Test-specific substitutions:**. Additional substitutions can be defined as follows:. - Lit configuration files (e.g., ``lit.cfg`` or ``lit.local.cfg``) can define; substitutions for all tests in a test directory. They do so by extending the; substitution list, ``config.substitutions``. Each item in the list is a tuple; consisting of a pattern and its replacement, which lit applies using python's; ``re.sub`` function.; - To define substitutions within a single test file, lit supports the; ``DEFINE:`` and ``REDEFINE:`` directives, described in detail below. So that; they have no effect on other test files, these directives modify a copy of the; substitution list that is produced by lit configuration files. For example, the following directives can be inserted into a test file to define; ``%{cflags}`` and ``%{fcflags}`` substitutions with empty initial values, which; serve as the parameters of another newly defined ``%{check}`` substitution:. .. code-block:: llvm. ; DEFINE: %{cflags} =; ; DEFINE: %{fcflags} =. ; DEFINE: %{check} = \; ; DEFINE: %clang_cc1 -verify -fopenmp -fopenmp-version=51 %{cflags} \; ; DEFINE: -emit-llvm -o - %s | \; ; DEFINE: FileCheck %{fcflags} %s. Alternatively, the above substitutions can be defined in a lit configuration; file to be shared with other test files. Either way, the test file can then; specify directives like the following to redefine the parameter substitutions as; desired before each use of ``%{check}`` in a ``RUN:`` line:. .. cod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:29013,test,test,29013,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['test']
Testability," with typeinfo (would need a specialization; to expose equality and hasher) for the allocators and the creation; functions could be a function template. //===----------------------------------------------------------------------===//; // Use a lit test instead of a unit test for the logical readers.; //===----------------------------------------------------------------------===//; https://reviews.llvm.org/D125783#inline-1324376. As the DebugInfoLogicalView library is sufficiently exposed via the; llvm-debuginfo-analyzer tool, follow the LLVM general approach and; use LIT tests to validate the logical readers. Convert the unitests:; llvm-project/llvm/unittests/DebugInfo/LogicalView/CodeViewReaderTest.cpp; llvm-project/llvm/unittests/DebugInfo/LogicalView/ELFReaderTest.cpp. into LIT tests:; llvm-project/llvm/test/DebugInfo/LogicalView/CodeViewReader.test; llvm-project/llvm/test/DebugInfo/LogicalView/ELFReader.test. //===----------------------------------------------------------------------===//; // Eliminate calls to 'getInputFileDirectory()' in the unit tests.; //===----------------------------------------------------------------------===//; https://reviews.llvm.org/D125783#inline-1324359. Rewrite the unittests 'LFReaderTest' and 'CodeViewReaderTest'to eliminate; the call:. getInputFileDirectory(). as use of that call is discouraged. See: Use a lit test instead of a unit test for the logical readers. //===----------------------------------------------------------------------===//; // Fix mismatch between %d/%x format strings and uint64_t type.; //===----------------------------------------------------------------------===//; https://reviews.llvm.org/D137400; https://github.com/llvm/llvm-project/issues/58758. Incorrect printing of uint64_t on 32-bit platforms.; Add the PRIx64 specifier to the printing code (format()). //===----------------------------------------------------------------------===//; // Remove 'LVScope::Children' container.; //===------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/README.txt:1994,test,tests,1994,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/README.txt,1,['test'],['tests']
Testability," with:. .. code-block:: sh. % clang -c -o test_code_harness.o test_code_harness.c; % llvm-jitlink -phony-externals test_code.o -harness test_code_harness.o; used mock utility function; Y is 42. The ``-harness`` option may be of interest to people who want to perform some; very late testing on build products to verify that compiled code behaves as; expected. On basic C test cases this is relatively straightforward. Mocks for; more complicated languages (e.g. C++) are much trickier: Any code involving; classes tends to have a lot of non-trivial surface area (e.g. vtables) that; would require great care to mock. Tips for JITLink backend developers; -----------------------------------. #. Make liberal use of assert and ``llvm::Error``. Do *not* assume that the input; object is well formed: Return any errors produced by libObject (or your own; object parsing code) and validate as you construct. Think carefully about the; distinction between contract (which should be validated with asserts and; llvm_unreachable) and environmental errors (which should generate; ``llvm::Error`` instances). #. Don't assume you're linking in-process. Use libSupport's sized,; endian-specific types when reading/writing content in the ``LinkGraph``. As a ""minimum viable"" JITLink wrapper, the ``llvm-jitlink`` tool is an; invaluable resource for developers bringing in a new JITLink backend. A standard; workflow is to start by throwing an unsupported object at the tool and seeing; what error is returned, then fixing that (you can often make a reasonable guess; at what should be done based on existing code for other formats or; architectures). In debug builds of LLVM, the ``-debug-only=jitlink`` option dumps logs from the; JITLink library during the link process. These can be useful for spotting some bugs at; a glance. The ``-debug-only=llvm_jitlink`` option dumps logs from the ``llvm-jitlink``; tool, which can be useful for debugging both testcases (it is often less verbose than; ``-debug-only=jitl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:43222,assert,asserts,43222,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['assert'],['asserts']
Testability," with:. ``` {.cpp}; TExec *myExec = gROOT->GetExec(execName);; myExec->SetAction(actionCommand);; ```. The parameter `actionCommand` is a string containing a Cling instruction.; Examples:. ``` {.cpp}; myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");; ```. When a `TRef` is de-referenced via **`TRef::GetObject`, its; **`TExec`** is automatically executed. The **`TExec`** function/script; can do one or more of the following:**. - Load a file containing the referenced object. This function; typically looks in the file catalog. - Compute a pointer to the referenced object and communicate this; pointer back to the calling function **`TRef`**`::SetObject` via:. ``` {.cpp}; TRef::SetObject(object); ```. As soon as an object is returned to `GetObject`, the `fUniqueID` of the; **`TRef`** is set to the `fUniqueID` of the referenced object. At the; next call to `GetObject`, the pointer stored in; `fPid:fObjects[fUniqueID]` will be returned directly. An example of; action on demand is in `$ROOTSYS/test/Event.h`:. ``` {.cpp}; TRef fWebHistogram; //EXEC:GetWebHistogram; ```. When calling `fWebHistogram.GetObject()`, the function `GetObject` will; automatically invoke the script `GetWebHistogram.C` via the interpreter.; An example of a `GetWebHistogram.C` script is shown below:. ``` {.cpp}; void GetWebHistogram() {; TFile *f=TFile::Open(""http://root.cern.ch/files/pippa.root"");; f->cd(""DM/CJ"");; TH1 *h6 = (TH1*)gDirectory->Get(""h6"");; h6->SetDirectory(0);; delete f;; TRef::SetObject(h6);; }; ```. In the above example, a call to `fWebHistogram.GetObject()` executes the; script with the function `GetWebHistogram`. This script connects a file; with histograms: `pippa.root` on the ROOT Web site and returns the; object `h6` to **`TRef`**`::GetObject`. ``` {.cpp}; TRef fWebHistogram; //EXEC:GetWebHistogram(); ```. Note that if the definition of the `TRef fWebHistogram` had been changed; the compiled or interpreted function `GetWebHistogram()` would have been; called ins",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:65713,test,test,65713,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['test'],['test']
Testability," would be a nan, it produces; a :ref:`poison value <poisonvalues>` instead. ``ninf``; No Infs - Allow optimizations to assume the arguments and result are not; +/-Inf. If an argument is +/-Inf, or the result would be +/-Inf, it; produces a :ref:`poison value <poisonvalues>` instead. ``nsz``; No Signed Zeros - Allow optimizations to treat the sign of a zero; argument or zero result as insignificant. This does not imply that -0.0; is poison and/or guaranteed to not exist in the operation. ``arcp``; Allow Reciprocal - Allow optimizations to use the reciprocal of an; argument rather than perform division. ``contract``; Allow floating-point contraction (e.g. fusing a multiply followed by an; addition into a fused multiply-and-add). This does not enable reassociating; to form arbitrary contractions. For example, ``(a*b) + (c*d) + e`` can not; be transformed into ``(a*b) + ((c*d) + e)`` to create two fma operations. .. _fastmath_afn:. ``afn``; Approximate functions - Allow substitution of approximate calculations for; functions (sin, log, sqrt, etc). See floating-point intrinsic definitions; for places where this can apply to LLVM's intrinsic math functions. ``reassoc``; Allow reassociation transformations for floating-point instructions.; This may dramatically change results in floating-point. ``fast``; This flag implies all of the others. .. _uselistorder:. Use-list Order Directives; -------------------------. Use-list directives encode the in-memory order of each use-list, allowing the; order to be recreated. ``<order-indexes>`` is a comma-separated list of; indexes that are assigned to the referenced value's uses. The referenced; value's use-list is immediately sorted by these indexes. Use-list directives may appear at function scope or global scope. They are not; instructions, and have no effect on the semantics of the IR. When they're at; function scope, they must appear after the terminator of the final basic block. If basic blocks have their address taken via ``blo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:162992,log,log,162992,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['log'],['log']
Testability," x || y && z""). * Branch coverage is the percentage of ""true"" and ""false"" branches that have; been taken at least once. Each branch is tied to individual conditions in the; source code that may each evaluate to either ""true"" or ""false"". These; conditions may comprise larger boolean expressions linked by boolean logical; operators. For example, ""x = (y == 2) || (z < 10)"" is a boolean expression; that is comprised of two individual conditions, each of which evaluates to; either true or false, producing four total branch outcomes. * Modified Condition/Decision Coverage (MC/DC) is the percentage of individual; branch conditions that have been shown to independently affect the decision; outcome of the boolean expression they comprise. This is accomplished using; the analysis of executed control flow through the expression (i.e. test; vectors) to show that as a condition's outcome is varied between ""true"" and; false"", the decision's outcome also varies between ""true"" and false"", while; the outcome of all other conditions is held fixed (or they are masked out as; unevaluatable, as happens in languages whose logical operators have; short-circuit semantics). MC/DC builds on top of branch coverage and; requires that all code blocks and all execution paths have been tested. This; statistic is hidden by default in reports, but it can be enabled via the; ``-show-mcdc-summary`` option as long as code was also compiled using the; clang option ``-fcoverage-mcdc``. * Boolean expressions that are only comprised of one condition (and therefore; have no logical operators) are not included in MC/DC analysis and are; trivially deducible using branch coverage. Of these six statistics, function coverage is usually the least granular while; branch coverage (with MC/DC) is the most granular. 100% branch coverage for a; function implies 100% region coverage for a function. The project-wide totals; for each statistic are listed in the summary. Format compatibility guarantees; ==================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:12539,test,test,12539,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,2,"['log', 'test']","['logical', 'test']"
Testability," y = x + 1; // warn: left operand is garbage; }. core.VLASize; (C); Check for declarations of VLA of undefined or zero size. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. core.uninitialized.ArraySubscript; (C); Check for uninitialized values used as array subscripts. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. core.uninitialized.Assign; (C); Check for assigning uninitialized values. void test() {; int x;; x |= 1; // warn: left expression is uninitialized; }. core.uninitialized.Branch; (C); Check for uninitialized values used as branch conditions. void test() {; int x;; if (x) // warn; return;; }. core.uninitialized.CapturedBlockVariable; (C); Check for blocks that capture uninitialized values. void test() {; int x;; ^{ int y = x; }(); // warn; }. core.uninitialized.UndefReturn; (C); Check for uninitialized values being returned to the caller. int test() {; int x;; return x; // warn; }. C++ Checkers. Name, DescriptionExample. cplusplus.NewDelete; (C++); Check for double-free, use-after-free and offset problems involving C++ ; delete. void f(int *p);. void testUseMiddleArgAfterDelete(int *p) {; delete p;; f(p); // warn: use after free; }. class SomeClass {; public:; void f();; };. void test() {; SomeClass *c = new SomeClass;; delete c;; c->f(); // warn: use after free; }. void test() {; int *p = (int *)__builtin_alloca(sizeof(int));; delete p; // warn: deleting memory allocated by alloca; }. void test() {; int *p = new int;; delete p;; delete p; // warn: attempt to free released; }. void test() {; int i;; delete &i; // warn: delete address of local; }. void test() {; int *p = new int[1];; delete[] (++p);; // warn: argument to 'delete[]' is offset by 4 bytes; // from the start of memory allocated by 'new[]'; }. cplusplus.NewDeleteLeaks; (C++); Check for memory leaks. Traces memory managed by new/; delete. void test() {; int *p = new int;; } // war",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:5000,test,test,5000,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability," y-size of source spectrum; int xmin; // x-starting channel of spectrum; int xmax; // x-end channel of spectrum; int ymin; // y-starting channel of spectrum; int ymax; // y-end channel of spectrum; int zmin; // base counts; int zmax; // counts full scale; int bx1; // position of picture on Canvas, min x; int bx2; // position of picture on Canvas, max x; int by1; // position of picture on Canvas, min y; int by2; // position of picture on Canvas, max y; int mode_group; // display mode algorithm group (simple modes-; // PICTURE2_MODE_GROUP_SIMPLE, modes with shading; // according to light-PICTURE2_MODE_GROUP_LIGHT, modes with; // shading according to channels counts-; // PICTURE2_MODE_GROUP_HEIGHT, modes of combination of; // shading according to light and to channels counts-; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT); int display_mode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:76752,log,log,76752,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['log'],['log']
Testability," you must first understand recursion"". Test again; ----------. To verify our change, we can build clang and manually check that it; works. .. code:: console. $ ninja clang; $ bin/clang -Wall ~/test.cc; /path/test.cc:1:124: warning: in order to understand recursion, you must; first understand recursion [-Winfinite-recursion]. We should also run the tests to make sure we didn't break something. .. code:: console. $ ninja check-clang. Notice that it is much faster to build this time, but the tests take; just as long to run. Ninja doesn't know which tests might be affected,; so it runs them all. .. code:: console. ********************; Testing Time: 408.84s; ********************; Failing Tests (1):; Clang :: SemaCXX/warn-infinite-recursion.cpp. Well, that makes sense… and the test output suggests it's looking for; the old string ""call itself"" and finding our new message instead.; Note that more tests may fail in a similar way as new tests are; added time to time. Let's fix it by updating the expectation in the test. .. code:: console. $ vi ../clang/test/SemaCXX/warn-infinite-recursion.cpp. Everywhere we see `// expected-warning{{call itself}}` (or something similar; from the original warning text), let's replace it with; `// expected-warning{{to understand recursion}}`. Now we could run **all** the tests again, but this is a slow way to; iterate on a change! Instead, let's find a way to re-run just the; specific test. There are two main types of tests in LLVM:. - **lit tests** (e.g. SemaCXX/warn-infinite-recursion.cpp). These are fancy shell scripts that run command-line tools and verify the; output. They live in files like; clang/**test**/FixIt/dereference-addressof.c. Re-run like this:. .. code:: console. $ bin/llvm-lit -v ../clang/test/SemaCXX/warn-infinite-recursion.cpp. - **unit tests** (e.g. ToolingTests/ReplacementTest.CanDeleteAllText). These are C++ programs that call LLVM functions and verify the results.; They live in suites like ToolingTests. Re-run like thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:7053,test,test,7053,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['test'],['test']
Testability," you to generate project files for several IDEs: Xcode,; Eclipse CDT4, CodeBlocks, Qt-Creator (use the CodeBlocks generator),; KDevelop3. For more details see; Building LLVM with CMake; page. If you intend to use Clang's C++ support, you may need to tell it how; to find your C++ standard library headers. In general, Clang will detect; the best version of libstdc++ headers available and use them - it will; look both for system installations of libstdc++ as well as installations; adjacent to Clang itself. If your configuration fits neither of these; scenarios, you can use the -DGCC_INSTALL_PREFIX cmake option; to tell Clang where the gcc containing the desired libstdc++ is installed.; ; Try it out (assuming you add llvm/build/bin to your path):; ; clang --help; clang file.c -fsyntax-only (check for correctness); clang file.c -S -emit-llvm -o - (print out unoptimized llvm code); clang file.c -S -emit-llvm -o - -O3; clang file.c -S -O3 -o - (output native machine code). Run the testsuite:; ; make check-clang. Using Visual Studio; The following details setting up for and building Clang on Windows using; Visual Studio:. Get the required tools:; ; Git. Source code control program. Get it from:; ; https://git-scm.com/download; CMake. This is used for generating Visual Studio solution and; project files. Get it from:; ; https://cmake.org/download/; Visual Studio 2019 16.7 or later; Python. It is used to run the clang test suite. Get it from:; ; https://www.python.org/download/; GnuWin32 tools; The Clang and LLVM test suite use various GNU core utilities, such as; grep, sed, and find. The gnuwin32 packages; are the oldest and most well-tested way to get these tools. However, the; MSys utilities provided by git for Windows have been known to work.; Cygwin has worked in the past, but is not well tested.; If you don't already have the core utilies from some other source, get; gnuwin32 from ; http://getgnuwin32.sourceforge.net/. Check out LLVM and Clang:; ; git clone https://gith",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html:3272,test,testsuite,3272,interpreter/llvm-project/clang/www/get_started.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_started.html,1,['test'],['testsuite']
Testability," { // similar code here; log();; if (x > y); return x;; return y;; }. Core Alpha Checkers. Name, DescriptionExample. alpha.core.BoolAssignment; (ObjC); Warn about assigning non-{0,1} values to boolean variables. void test() {; BOOL b = -1; // warn; }. alpha.core.CallAndMessageUnInitRefArg; (C, C++); Check for uninitialized arguments in function calls and Objective-C; message expressions. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. alpha.core.CastSize; (C); Check when casting a malloc'ed type T, whether the size is a multiple of the; size of T (Works only with unix.Malloc; or alpha.unix.MallocWithAnnotations; checks enabled). void test() {; int *x = (int *)malloc(11); // warn; }. alpha.core.CastToStruct; (C, C++); Check for cast from non-struct pointer to struct pointer. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. alpha.core.Conversion; (C, C++, ObjC); Loss of sign or precision in implicit conversions. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. alpha.core.DynamicTypeChecker; (ObjC); Check for cases where the dynamic and the static type of an; object are unrelated. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. alpha.core.FixedAddr; (C); Check for assignment of a fixed address to a pointer. void test() {; int *p;; p = (int *) 0x10000; // warn; }. alpha.core.IdenticalExpr; (C, C++); Warn about suspicious uses of identical expressions. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:1780,test,test,1780,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['test'],['test']
Testability," {.cpp}; TLorentzRotation l; // l is initialized as identity; TLorentzRotation m(l);// m = l; TRotation r;; TLorentzRotation lr(r);; TLorentzRotation lb1(bx,by,bz);; TVector3 b;; TLorentzRotation lb2(b);; ```. The Matrix for a Lorentz boosts is:. $$; \left|; \begin{array}{cccc}; 1+gamma'*bx*bx & gamma'*bx*by & gamma'*bx*bz & gamma*bx \\; gamma'*bx*bz & 1+gamma'*by*by & gamma'*by*by & gamma*by \\; gamma'*bz*bx & gamma'*bz*by & 1+gamma'*bz*bz & gamma*bz \\; gamma*bx & gamma*by & gamma*bz & gamma; \end{array}; \right|; $$. with the boost vector `b=(bx,by,bz)`;; `gamma=1/Sqrt(1-beta*beta)`;` gamma'=(gamma-1)/beta*beta.`. ### Access to the Matrix Components/Comparisons. The access to the matrix components is possible with the methods `XX()`,; `XY()` ... `TT()`, and with the operator` (int,int)`:. ``` {.cpp}; Double_t xx;; TLorentzRotation l;; xx = l.XX(); // gets the xx component; xx = l(0,0); // gets the xx component; if (l == m) {...} // test for equality; if (l != m) {...} // test for inequality; if (l.IsIdentity()) {...} // test for identity; ```. ### Transformations of a Lorentz Rotation. There are four possibilities to find the product of two; **`TLorentzRotation`** transformations:. ``` {.cpp}; TLorentzRotation a,b,c;; c = b*a; // product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b; // a=a*b; c = a.Transform(b) // a=b*a then c=a; ```. Lorentz boosts:. ``` {.cpp}; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; ```. Rotations:. ``` {.cpp}; TVector3 axis;; l.RotateX(TMath::Pi()); // rotation around x-axis; l.Rotate(.5,axis); // rotation around specified vector; ```. Inverse transformation: use the method `Inverse() `to return the inverse; transformation keeping the current one unchanged`.` The method; `Invert()` inverts the current **`TLorentzRotation`**:. ``` {.cpp}; l1 = l2.Inverse(); // l1 is inverse of l2, l2 unchanged; l1 = l2.Invert(); // invert l2, then l1=l2; ```. The matrix for the inverse tra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:16442,test,test,16442,documentation/users-guide/PhysicsVectors.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md,1,['test'],['test']
Testability," {.cpp}; if (reqSections & TBuffer3D::kBoundingBox) {; Double_t halfLengths[3] = { fDX, fDY, fDZ };; buffer.SetAABoundingBox(fOrigin, halfLengths);; if (!buffer.fLocalFrame) {; TransformPoints(buffer.fBBVertex[0], 8);; }; buffer.SetSectionsValid(TBuffer3D::kBoundingBox);; }; ```. #### Logical and Physical Objects. Some viewers can support two types of object placement:. - Add object as a single independent entity in the world reference; frame - e.g. a sphere, radius `r`, at `x`, `y`, `z`. - Repeated placement (copying) in world frame of this locally unique; piece of geometry (described in local reference frame) e.g. define a; sphere `S` (radius `r`), place copy at `x1`, `y1`, `z1`, another; copy at `x2`, `y2`, `z2` etc. The second case is very typical in geometry packages, e.g. ROOT's; **`TGeo`** package, GEANT4 etc, where we have very large number repeated; placements of relatively few unique ""shapes"". Some viewers (GL Viewer only at present) are able to take advantage of; this by identifying unique logical shapes from the `fID` logical ID; member of **`TBuffer3D`**. If repeated addition of the same `fID` is; found, the shape is cached already - and the costly tessellation does; not need to be sent again. The viewer can also perform internal GL; specific caching (display lists) with considerable performance gains in; these cases. For this to work correctly the logical object in must be; described in **`TBuffer3D`** in the local reference frame, complete with; the local`/`master translation. In some cases you will not have a real; object you can reasonably set **`TBuffer3D::fID` to, or the object is; recycled or temporary. To suppress internal caching in the GL Viewer in; these cases, set `TBuffer3D::fID` to 0 (null).**. The viewer indicates it can support local frame objects through the; **`TVirtualViewer3D`** interface method: `PreferLocalFrame()`. If this; returns `kTRUE` you can make repeated calls to `AddObject()`, with; **`TBuffer3D`** containing the same `fID",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:134922,log,logical,134922,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,2,['log'],['logical']
Testability," {; *error = 0; // warn: potential null dereference; return 0;; }. .. _osx-coreFoundation-CFNumber:. osx.coreFoundation.CFNumber (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of CFNumber APIs. .. code-block:: c. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. .. _osx-coreFoundation-CFRetainRelease:. osx.coreFoundation.CFRetainRelease (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null arguments to CFRetain/CFRelease/CFMakeCollectable. .. code-block:: c. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. .. _osx-coreFoundation-containers-OutOfBounds:. osx.coreFoundation.containers.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for index out-of-bounds when using 'CFArray' API. .. code-block:: c. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. .. _osx-coreFoundation-containers-PointerSizedValues:. osx.coreFoundation.containers.PointerSizedValues (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns if 'CFArray', 'CFDictionary', 'CFSet' are created with non-pointer-size values. .. code-block:: c. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void """""""""""""""""""""""""""""""""""""""""""""""")x, 1,; &kCFTypeArrayCallBacks); // warn; }. Fuchsia; ^^^^^^^. Fuchsia is an open source capability-based operating system currently being; developed by Google. This section describes checkers that can find various; misuses of Fuchsia APIs. .. _fuchsia-HandleChecker:. fuchsia.HandleChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Handles identify resources. Similar to pointers they can be leaked,; double freed, or use after freed. This check attempts to find such problems. .. code-block:: cpp. void checkLeak08(int tag) {; zx_handle_t sa, sb;; zx_channel_create(0, &sa, &sb);",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:43239,test,test,43239,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability," {; f();; }; catch (...) {; i=2; // warn; }; };. undefbehavior.ReturnAtCatchEnd; (C++); Undefined behavior: a function returns when control reaches the end of a; handler. This results in undefined behavior in a value-returning function.; Source: C++11 15.3p10. void f() { throw 1; }. int test() try {; f();; return 1;; }; catch(int) {; } // warn. undefbehavior.AutoptrsOwnSameObj; (C++03); Undefined behavior: if more than one auto_ptr owns the same object; at the same time the behavior of the program is undefined.; Source: C++03 20.4.5p3; C++11 auto_ptr is deprecated; (D.10). #include <memory>. void test() {; int *data = new int;; std::auto_ptr<int> p(data);; std::auto_ptr<int> q(data); // warn; }. undefbehavior.BasicStringOutOfBound; (C++03); Undefined behavior: out-of-bound basic_string access/modification.; Note: possibly an enhancement to ; alpha.security.ArrayBoundV2.; Source: C++03 21.3.4p1; C++11 behavior is defined; (21.4.5p2). #include <string>. void test() {; std::basic_string<char> s;; char c = s[10]; // warn; }. #include <string>. void test() {; std::basic_string<char> s;; s[10] = 0; // warn; }. undefbehavior.EosDereference; (C++); Undefined behavior: the result of operator*() on an end of a; stream is undefined.; Source: C++03 24.5.3p2; C++11 24.6.3p2. #include <vector>. int test() {; std::vector<int> v;; return *v.end(); // warn; }. undefbehavior.QsortNonPODNonTrivial; (C++); C++03: Undefined behavior: the objects in the array passed to qsort are of; non-POD type.; C++11: Undefined behavior: the objects in the array passed to qsort are of; non-trivial type.; Source: C++03 25.4p4; C++11 25.5p4. // C++03; #include <cstdlib>. struct non_POD {; non_POD();; };. non_POD values[] = { non_POD(), non_POD() };. int compare(const void *a, const void *b);. void test() {; qsort(values, 2, sizeof(non_POD), compare); // warn; }. // C++11; #include <cstdlib>. struct S {};. struct trivial_non_POD : public S {; int i;; };. struct non_trivial {; int i;; non_trivial();; };. t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:13810,test,test,13810,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability," {Struct} 'Struct'; [003] 5 {Member} public 'U' -> 'Union'. DWARF - GCC (Linux); ^^^^^^^^^^^^^^^^^^^. .. code-block:: none. Logical View:; [000] {File} 'pr-46466-dwarf-gcc.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-46466.cpp'; [002] {Producer} 'GNU C++14 9.3.0'; [002] 8 {Variable} extern 'S' -> 'Struct'; [002] 1 {Struct} 'Struct'; [003] 5 {Member} public 'U' -> 'Union'; [003] 2 {Union} 'Union'; [004] 3 {Enumeration} 'NestedEnum' -> 'unsigned int'; [005] {Enumerator} 'BLUE' = '0x1'; [005] {Enumerator} 'RED' = '0x0'. From the previous logical views, we can see that the DWARF debug; information generated by the Clang compiler does not include any; references to the enumerators **RED** and **BLUE**. The DWARF; generated by GCC, CodeView generated by Clang and MSVC, they do; include such references. Using the :program:`llvm-debuginfo-analyzer` selection facilities, we; can produce a logical view showing just the logical types that are; **Enumerator** and its parents. The logical view is sorted by the types; name. .. code-block:: none. llvm-debuginfo-analyzer --attribute=format,level; --output-sort=name; --select-types=Enumerator; --report=parents; --print=types; pr-46466-*.o. .. code-block:: none. Logical View:; [000] {File} 'pr-46466-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-46466.cpp'; [002] 1 {Struct} 'Struct'; [003] 2 {Union} 'Union'; [004] 3 {Enumeration} 'NestedEnum' -> 'int'; [005] {Enumerator} 'BLUE' = '0x1'; [005] {Enumerator} 'RED' = '0x0'. Logical View:; [000] {File} 'pr-46466-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr-46466.cpp'; [002] 1 {Struct} 'Struct'; [003] 2 {Union} 'Union'; [004] 3 {Enumeration} 'NestedEnum' -> 'int'; [005] {Enumerator} 'BLUE' = '0x1'; [005] {Enumerator} 'RED' = '0x0'. Logical View:; [000] {File} 'pr-46466-dwarf-clang.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-46466.cpp'. Logical View:; [000] {File} 'pr-46466-dwarf-gcc.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-46466.cpp'; [002] 1 {Struct} 'Struct'; [003] ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:45338,log,logical,45338,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['log'],['logical']
Testability," {}; };. struct Foo {; RefCntbl * ptr; // warn; RefCntbl & ptr; // warn; // ...; };. .. _webkit-UncountedLambdaCapturesChecker:. webkit.UncountedLambdaCapturesChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Raw pointers and references to uncounted types can't be captured in lambdas. Only ref-counted types are allowed. .. code-block:: cpp. struct RefCntbl {; void ref() {}; void deref() {}; };. void foo(RefCntbl* a, RefCntbl& b) {; [&, a](){ // warn about 'a'; do_something(b); // warn about 'b'; };; };. .. _alpha-checkers:. Experimental Checkers; ---------------------. *These are checkers with known issues or limitations that keep them from being on by default. They are likely to have false positives. Bug reports and especially patches are welcome.*. alpha.clone; ^^^^^^^^^^^. .. _alpha-clone-CloneChecker:. alpha.clone.CloneChecker (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports similar pieces of code. .. code-block:: c. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. alpha.core; ^^^^^^^^^^. .. _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:46998,log,log,46998,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['log'],['log']
Testability," }. different.BitwiseOpBoolArg; (C, C++); Boolean value met at the left/right part of the bitwise &; or | operator.; Did you mean && (||) ?. int f();. void test() {; bool b = true;; if (b & f()) {} // warn; }. different.LabelInsideSwitch; (C); Possibly a misprint: label found inside a switch(); statement. void test(int c) {; switch(c){; case 1:; c += 1; break;; defalt: // warn (did you mean 'default'?); c -= 1; break;; }; }. different.IdenticalCondIfIf; (C); The conditions of two subsequent if statements are; identical. int test(int c) {; if (c > 5); c += 1;; if (c > 5) // warn; c -= 1;; return c;; }. different.LogicalOpUselessArg; (C); The second operand of a && operator has no impact on; expression result. void test(unsigned a) {; if (a<7 && a<10) {}; // warn; }. different.SameResLogicalExpr; (C); An expression is always evaluated to true/false. void test() {; int i = 0;; if (i != 0) {}; // warn; }. void test(int i) {; if (i == 0 && i == 1) {}; // warn; }. void test(int i) {; if (i < 0 || i >= 0) {}; // warn; }. different.OpPrecedenceAssignCmp; (C, C++); Comparison operation has higher precedence then assignment. Boolean value is; assigned to a variable of other type. Parenthesis may bee required around an; assignment. int f();. void test(int x, int y) {; bool b;; if((b = x != y)) {} // ok; if((x = f() != y)) {} // warn; }. different.OpPrecedenceIifShift; (C, C++); ?: has lower precedence then <<.; Source: Stephen C. Dewhurst ""C++ Gotchas: Avoiding Common Problems in Coding; and Design"", advise 15. #include <iostream>. void test(int a) {; std::cout << a ? ""a"" : ""b""; // warn; }. void test(int a) {; a << a > 7 ? 1 : 2; // warn; }. different.ObjectUnused; (C++); The object was created but is not being used. struct S {; int x, y;; S(int xx, int yy) : x(xx), y(yy) {}; S(int xx) {; S(xx, 0); // warn; }; };. #include <exception>. void test() {; std::exception();; // warn (did you mean 'throw std::exception()'?); }. different.StaticArrayPtrCompare; (C); Pointer to static a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:22724,test,test,22724,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability," }. different.StrcpyInputSize; (C); Buffer copy without checking the size of input.; Note: possibly an enhancement to ; alpha.unix.cstring.OutOfBounds. void test(char* string) {; char buf[24];; strcpy(buf, string); // warn; }. different.IntegerOverflow; (C); Integer overflow.; Note: partially handled by Clang core; (search for 'overflow in expression' warning in Clang tests).; Source: ; CWE-190. #include <limits.h>. int f(int x);. void test() {; f(INT_MAX + 1); // warn; }. #include <limits.h>. int test() {; int x = INT_MAX / 2 + 1;; return x * 2; // warn; }. different.SignExtension; (C); Unexpected sign extension might take place.; Source: ; CWE-194. unsigned long long test(long long sll) {; unsigned long long ull = sll; // warn; return ull;; }. void f(unsigned int i);. void test(int si) {; f(si); // warn; }. unsigned int test(int i) {; return i;; }. different.NumericTruncation; (C); Numeric truncation might take place.; Source: ; CWE-197. unsigned long test(unsigned long long ull) {; unsigned long ul = ull; // warn; return ul;; }. void f(int i);. void test(long long sll) {; f(sll); // warn; }. int f();. short test(long long sll) {; short ss = f();; return ss;; }. different.MissingCopyCtorAssignOp; (C++); A class has dynamically allocated data members but do not define a copy; constructor/assignment operator.; Source: Scott Meyers ""Effective C++"", item 11: Prevent exceptions from; leaving destructors. class C {; int *p; // warn; public:; C() { p = new int; }; ~C() { delete p; }; };. WinAPI. Name, DescriptionExampleProgress. WinAPI.CreateProcess; (C); CreateProcess(): if the first parameter ; lpApplicationName is NULL then the executable name must be in the; white space-delimited string pointed to by lpCommandLine.; If the executable or path name has a space in it, there is a risk that a; different executable could be run because of the way the function parses; spaces.; Source: ; MSDN: CreateProcess function, Security Remarks. #include <windows.h>. void test() {; STA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:25259,test,test,25259,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability," }. void f();. void test() {; pthread_once_t pred = {0x30B1BCBA, {0}};; pthread_once(&pred, f);; // warn: call to 'pthread_once' uses the local variable; }. void test() {; void *p = malloc(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = calloc(0, 42); // warn: allocation size of 0 bytes; }. void test() {; void *p = malloc(1);; p = realloc(p, 0); // warn: allocation size of 0 bytes; }. void test() {; void *p = alloca(0); // warn: allocation size of 0 bytes; }. void test() {; void *p = valloc(0); // warn: allocation size of 0 bytes; }. unix.Malloc; (C); Check for memory leaks, double free, and use-after-free and offset problems; involving malloc. void test() {; int *p = malloc(1);; free(p);; free(p); // warn: attempt to free released memory; }. void test() {; int *p = malloc(sizeof(int));; free(p);; *p = 1; // warn: use after free; }. void test() {; int *p = malloc(1);; if (p); return; // warn: memory is never released; }. void test() {; int a[] = { 1 };; free(a); // warn: argument is not allocated by malloc; }. void test() {; int *p = malloc(sizeof(char));; p = p - 1;; free(p); // warn: argument to free() is offset by -4 bytes; }. unix.MallocSizeof; (C); Check for dubious malloc, calloc or; realloc arguments involving sizeof. void test() {; long *p = malloc(sizeof(short));; // warn: result is converted to 'long *', which is; // incompatible with operand type 'short'; free(p);; }. unix.MismatchedDeallocator; (C, C++, ObjC); Check for mismatched deallocators (e.g. passing a pointer allocating; with new to free()). // C, C++; void test() {; int *p = (int *)malloc(sizeof(int));; delete p; // warn; }. // C, C++; void __attribute((ownership_returns(malloc))) *user_malloc(size_t);. void test() {; int *p = (int *)user_malloc(sizeof(int));; delete p; // warn; }. // C, C++; void test() {; int *p = new int;; free(p); // warn; }. // C, C++; void test() {; int *p = new int[1];; realloc(p, sizeof(long)); // warn; }. // C, C++; template <typename T>; struct Simp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:24568,test,test,24568,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability,"!repr(``\ *value*\ ``)``; Represents *value* as a string. String format for the value is not; guaranteed to be stable. Intended for debugging purposes only. ``!setdagarg(``\ *dag*\ ``,``\ *key*\ ``,``\ *arg*\ ``)``; This operator produces a DAG node with the same operator and arguments as; *dag*, but replacing the value of the argument specified by the *key* with; *arg*. That *key* could be either an integer index or a string name. ``!setdagname(``\ *dag*\ ``,``\ *key*\ ``,``\ *name*\ ``)``; This operator produces a DAG node with the same operator and arguments as; *dag*, but replacing the name of the argument specified by the *key* with; *name*. That *key* could be either an integer index or a string name. ``!setdagop(``\ *dag*\ ``,`` *op*\ ``)``; This operator produces a DAG node with the same arguments as *dag*, but with its; operator replaced with *op*. Example: ``!setdagop((foo 1, 2), bar)`` results in ``(bar 1, 2)``. ``!shl(``\ *a*\ ``,`` *count*\ ``)``; This operator shifts *a* left logically by *count* bits and produces the resulting; value. The operation is performed on a 64-bit integer; the result; is undefined for shift counts outside 0...63. ``!size(``\ *a*\ ``)``; This operator produces the size of the string, list, or dag *a*.; The size of a DAG is the number of arguments; the operator does not count. ``!sra(``\ *a*\ ``,`` *count*\ ``)``; This operator shifts *a* right arithmetically by *count* bits and produces the resulting; value. The operation is performed on a 64-bit integer; the result; is undefined for shift counts outside 0...63. ``!srl(``\ *a*\ ``,`` *count*\ ``)``; This operator shifts *a* right logically by *count* bits and produces the resulting; value. The operation is performed on a 64-bit integer; the result; is undefined for shift counts outside 0...63. ``!strconcat(``\ *str1*\ ``,`` *str2*\ ``, ...)``; This operator concatenates the string arguments *str1*, *str2*, etc., and; produces the resulting string. ``!sub(``\ *a*\ ``,`` *b*\ ``)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:71365,log,logically,71365,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['log'],['logically']
Testability,"""""""""""""""""""""""""""""""""""""""""""""""; Check for dereferences of null pointers. This checker specifically does; not report null pointer dereferences for x86 and x86-64 targets when the; address space is 256 (x86 GS Segment), 257 (x86 FS Segment), or 258 (x86 SS; segment). See `X86/X86-64 Language Extensions; <https://clang.llvm.org/docs/LanguageExtensions.html#memory-references-to-specified-segments>`__; for reference. The ``SuppressAddressSpaces`` option suppresses; warnings for null dereferences of all pointers with address spaces. You can; disable this behavior with the option; ``-analyzer-config core.NullDereference:SuppressAddressSpaces=false``.; *Defaults to true*. .. code-block:: objc. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. .. _core-StackAddressEscape:. core.StackAddressEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function. .. code-block:: c. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. .. _core-UndefinedBinaryOperatorResult:. core.UndefinedBinaryOperatorResult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary operators. .. code-block:: c. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. .. _core-VLASize:. core.VLASize (C); """"""""""""""""""""""""""""""""; Check for declarations of Variable Length Arrays of undefined or zero size. Check for declarations of VLA of undefined or zero size. .. code-block:: c. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. .",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:4593,test,test,4593,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability,"""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; // warn: method accepting NSError"""""""""""""""""""""""""""""""""""""""""""""""" should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilArg:. osx.cocoa.NilArg (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for prohibited nil arguments to ObjC method calls. - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. .. code-block:: objc. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. .. _osx-cocoa-NonNilReturnValue:. osx.cocoa.NonNilReturnValue; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Models the APIs that are guaranteed to return a non-nil value. .. _osx-cocoa-ObjCGenerics:. osx.cocoa.ObjCGenerics (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for type errors when using Objective-C generics. .. code-block:: objc. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. .. _osx-cocoa-RetainCount:. osx.cocoa.RetainCount (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaks and improper reference count management. .. code-block:: objc. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. .",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:39186,test,test,39186,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability,"""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; // warn: method accepting NSError"""""""""""""""""""""""""""""""""""""""""""""""" should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilArg:. osx.cocoa.NilArg (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for prohibited nil arguments to ObjC method calls. - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. .. code-blo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:38110,test,test,38110,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability,"""""""""""""""""""""""""; Check stream handling functions: ``fopen, tmpfile, fclose, fread, fwrite, fseek, ftell, rewind, fgetpos,``; ``fsetpos, clearerr, feof, ferror, fileno``. .. code-block:: c. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTerminated:. alpha.unix.cstring.NotNullTerminated (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for arguments which are not null-terminated strings; applies to: ``strlen, strnlen, strcpy, strncpy, strcat, strncat, wcslen, wcsnlen``. .. code-block:: c. void test() {; int y = strlen((char *)&test); // warn; }. .. _alpha-unix-cstring-OutOfBounds:. alpha.unix.cstring.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for out-of-bounds access in string functions, such as:; ``memcpy, bcopy, strcpy, strncpy, strcat, strncat, memmove, memcmp, memset`` and more. This check also works with string literals, except there is a known bug in that; the analyzer cannot detect embedded NULL characters when determining the string length. .. code-block:: c. void test1() {; const char str[] = ""Hello world"";; char buffer[] = ""Hello world"";; memcpy(buffer, str, sizeof(str) + 1); // warn; }. void test2() {; const char str[] = ""Hel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:77946,test,test,77946,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability,"""""""""""""""""""""""; Check for declarations of Variable Length Arrays of undefined or zero size. Check for declarations of VLA of undefined or zero size. .. code-block:: c. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. .. _core-uninitialized-ArraySubscript:. core.uninitialized.ArraySubscript (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as array subscripts. .. code-block:: c. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. .. _core-uninitialized-Assign:. core.uninitialized.Assign (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for assigning uninitialized values. .. code-block:: c. void test() {; int x;; x |= 1; // warn: left expression is uninitialized; }. .. _core-uninitialized-Branch:. core.uninitialized.Branch (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as branch conditions. .. code-block:: c. void test() {; int x;; if (x) // warn; return;; }. .. _core-uninitialized-CapturedBlockVariable:. core.uninitialized.CapturedBlockVariable (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for blocks that capture uninitialized values. .. code-block:: c. void test() {; int x;; ^{ int y = x; }(); // warn; }. .. _core-uninitialized-UndefReturn:. core.uninitialized.UndefReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values being returned to the caller. .. code-block:: c. int test() {; int x;; return x; // warn; }. .. _core-uninitialized-NewArraySize:. core.uninitialized.NewArraySize (C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Check if the element count in new[] is garbage or undefined. .. code-block:: cpp. void test() {; int n;; int *arr = new int[n]; // warn: Element count in new[] is a garbage value; delete[] arr;; }. .. _cplusplus-checkers:. cplusplus; ^^^^^^^^^. C++ Checkers. .. _cplusplus-InnerPointer:. cplusplus.InnerPointer (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for inn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:6303,test,test,6303,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability,"""""""""""""""; Check that addresses to stack memory do not escape the function that involves dispatch_after or dispatch_async.; This checker is a part of ``core.StackAddressEscape``, but is temporarily disabled until some false positives are fixed. .. code-block:: c. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. .. _alpha-core-StdVariant:. alpha.core.StdVariant (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check if a value of active type is retrieved from an ``std::variant`` instance with ``std::get``.; In case of bad variant type access (the accessed type differs from the active type); a warning is emitted. Currently, this checker does not take exception handling into account. .. code-block:: cpp. void test() {; std::variant<int, char> v = 25;; char c = stg::get<char>(v); // warn: ""int"" is the active alternative; }. .. _alpha-core-TestAfterDivZero:. alpha.core.TestAfterDivZero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. .. code-block:: c. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. alpha.cplusplus; ^^^^^^^^^^^^^^^. .. _alpha-cplusplus-ArrayDelete:. alpha.cplusplus.ArrayDelete (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports destructions of arrays of polymorphic objects that are destructed as their base class.; This checker corresponds to the CERT rule `EXP51-CPP: Do not delete an array through a pointer of the incorrect type <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_. .. code-block:: cpp. class Base {; virtual ~Base() {}; };; class Derived : public Base {}. Base *create() {; Base *x = new Derived[10]; // note:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:52047,test,test,52047,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability,""""""". The '``llvm.log10.*``' intrinsics compute the base-10 logarithm of the; specified value. Arguments:; """""""""""""""""""". The argument and return value are floating-point numbers of the same type. Semantics:; """""""""""""""""""". Return the same value as a corresponding libm '``log10``' function but without; trapping or setting ``errno``. When specified with the fast-math-flag 'afn', the result may be approximated; using a less accurate calculation. .. _int_log2:. '``llvm.log2.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.log2`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.log2.f32(float %Val); declare double @llvm.log2.f64(double %Val); declare x86_fp80 @llvm.log2.f80(x86_fp80 %Val); declare fp128 @llvm.log2.f128(fp128 %Val); declare ppc_fp128 @llvm.log2.ppcf128(ppc_fp128 %Val). Overview:; """""""""""""""""". The '``llvm.log2.*``' intrinsics compute the base-2 logarithm of the specified; value. Arguments:; """""""""""""""""""". The argument and return value are floating-point numbers of the same type. Semantics:; """""""""""""""""""". Return the same value as a corresponding libm '``log2``' function but without; trapping or setting ``errno``. When specified with the fast-math-flag 'afn', the result may be approximated; using a less accurate calculation. .. _int_fma:. '``llvm.fma.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.fma`` on any; floating-point or vector of floating-point type. Not all targets support; all types however. ::. declare float @llvm.fma.f32(float %a, float %b, float %c); declare double @llvm.fma.f64(double %a, double %b, double %c); declare x86_fp80 @llvm.fma.f80(x86_fp80 %a, x86_fp80 %b, x86_fp80 %c); declare fp128 @llvm.fma.f128(fp128 %a, fp128 %b, fp128 %c); declare ppc_fp128 @llvm.fma.ppcf128(ppc_fp128 %a, ppc_fp128 %b, ppc_fp128 %c). Overview:; """""""""""""""""". The '``llvm.fm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:569954,log,logarithm,569954,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['log'],['logarithm']
Testability,"""""""; Check for misuses of stream APIs. Check for misuses of stream APIs: ``fopen, fclose``; (demo checker, the subject of the demo (`Slides <https://llvm.org/devmtg/2012-11/Zaks-Rose-Checker24Hours.pdf>`_ ,; `Video <https://youtu.be/kdxlsP5QVPw>`_) by Anna Zaks and Jordan Rose presented at the; `2012 LLVM Developers' Meeting <https://llvm.org/devmtg/2012-11/>`_). .. code-block:: c. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. .. _alpha-unix-Stream:. alpha.unix.Stream (C); """"""""""""""""""""""""""""""""""""""""""; Check stream handling functions: ``fopen, tmpfile, fclose, fread, fwrite, fseek, ftell, rewind, fgetpos,``; ``fsetpos, clearerr, feof, ferror, fileno``. .. code-block:: c. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTerminated:. alpha.unix.cstring.NotNullTerminated (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for arguments which are not null-terminated strings; applies to: ``strlen, strnlen, strcpy, strncpy, strcat, strncat, wcslen, wcsnlen``. .. code-block:: c. void t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:77250,test,test,77250,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability,""""". ::. declare void @llvm.instrprof.mcdc.parameters(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.parameters``' intrinsic is used to initiate MC/DC; code coverage instrumentation for a function. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vectors executed for each boolean expression. Semantics:; """""""""""""""""""". This intrinsic represents basic MC/DC parameters initiating one or more MC/DC; instrumentation sequences in a function. It will cause the ``-instrprof`` pass; to generate the appropriate data structures and the code to instrument MC/DC; test vectors in a format that can be written out by a compiler runtime and; consumed via the ``llvm-profdata`` tool. '``llvm.instrprof.mcdc.condbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.condbitmap.update(ptr <name>, i64 <hash>,; i32 <condition-id>,; ptr <mcdc-temp-addr>,; i1 <bool-value>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic is used to track; MC/DC condition evaluation for each condition in a boolean expression. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is an ID of a condition to track. This value is used as a; bit index into the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:533188,test,test,533188,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['test'],['test']
Testability,"""""; Check for out-of-bounds access in string functions, such as:; ``memcpy, bcopy, strcpy, strncpy, strcat, strncat, memmove, memcmp, memset`` and more. This check also works with string literals, except there is a known bug in that; the analyzer cannot detect embedded NULL characters when determining the string length. .. code-block:: c. void test1() {; const char str[] = ""Hello world"";; char buffer[] = ""Hello world"";; memcpy(buffer, str, sizeof(str) + 1); // warn; }. void test2() {; const char str[] = ""Hello world"";; char buffer[] = ""Helloworld"";; memcpy(buffer, str, sizeof(str)); // warn; }. .. _alpha-unix-cstring-UninitializedRead:. alpha.unix.cstring.UninitializedRead (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized reads from common memory copy/manipulation functions such as:; ``memcpy, mempcpy, memmove, memcmp, strcmp, strncmp, strcpy, strlen, strsep`` and many more. .. code-block:: c. void test() {; char src[10];; char dst[5];; memcpy(dst,src,sizeof(dst)); // warn: Bytes string function accesses uninitialized/garbage values; }. Limitations:. - Due to limitations of the memory modeling in the analyzer, one can likely; observe a lot of false-positive reports like this:. .. code-block:: c. void false_positive() {; int src[] = {1, 2, 3, 4};; int dst[5] = {0};; memcpy(dst, src, 4 * sizeof(int)); // false-positive:; // The 'src' buffer was correctly initialized, yet we cannot conclude; // that since the analyzer could not see a direct initialization of the; // very last byte of the source buffer.; }. More details at the corresponding `GitHub issue <https://github.com/llvm/llvm-project/issues/43459>`_. .. _alpha-nondeterminism-PointerIteration:. alpha.nondeterminism.PointerIteration (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for non-determinism caused by iterating unordered containers of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::unordered_set<int *> UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:79395,test,test,79395,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability,""",; ""output"": ""User.o""; }; ]. And we can get the dependency information in P1689 format by:. .. code-block:: console. $ clang-scan-deps -format=p1689 -compilation-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35749,log,logical-name,35749,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['log'],['logical-name']
Testability,"""--cmakedir""; ""--build-mode""; ""--version""); execute_process(; COMMAND ${CONFIG_COMMAND}; RESULT_VARIABLE HAD_ERROR; OUTPUT_VARIABLE CONFIG_OUTPUT; ); if(NOT HAD_ERROR); string(REGEX REPLACE; ""[ \t]*[\r\n]+[ \t]*"" "";""; CONFIG_OUTPUT ${CONFIG_OUTPUT}); else(); string(REPLACE "";"" "" "" CONFIG_COMMAND_STR ""${CONFIG_COMMAND}""); message(STATUS ""${CONFIG_COMMAND_STR}""); message(FATAL_ERROR ""llvm-config failed with status ${HAD_ERROR}""); endif(); else(); message(FATAL_ERROR ""llvm-config not found -- ${LLVM_CONFIG}""); endif(). list(GET CONFIG_OUTPUT 0 ENABLE_ASSERTIONS); list(GET CONFIG_OUTPUT 1 TOOLS_BINARY_DIR); list(GET CONFIG_OUTPUT 2 LIBRARY_DIR); list(GET CONFIG_OUTPUT 3 INCLUDE_DIR); list(GET CONFIG_OUTPUT 4 LLVM_OBJ_ROOT); list(GET CONFIG_OUTPUT 5 LLVM_CONFIG_CMAKE_PATH); list(GET CONFIG_OUTPUT 6 LLVM_BUILD_MODE); list(GET CONFIG_OUTPUT 7 LLVM_VERSION). message(STATUS ""External llvm built in ${LLVM_BUILD_MODE} mode.""). if(NOT MSVC_IDE); set(LLVM_ENABLE_ASSERTIONS ${ENABLE_ASSERTIONS}; CACHE BOOL ""Enable assertions""); # Assertions should follow llvm-config's.; mark_as_advanced(LLVM_ENABLE_ASSERTIONS); endif(). set(LLVM_TOOLS_BINARY_DIR ${TOOLS_BINARY_DIR} CACHE PATH ""Path to llvm/bin""); set(LLVM_LIBRARY_DIR ${LIBRARY_DIR} CACHE PATH ""Path to llvm/lib""); set(LLVM_MAIN_INCLUDE_DIR ${INCLUDE_DIR} CACHE PATH ""Path to llvm/include""); set(LLVM_BINARY_DIR ${LLVM_OBJ_ROOT} CACHE PATH ""Path to LLVM build tree""). set(LLVM_DIR ""${LLVM_BINARY_DIR}""). # Normalize LLVM_CMAKE_PATH. --cmakedir might contain backslashes.; # CMake assumes slashes as PATH.; file(TO_CMAKE_PATH ${LLVM_CONFIG_CMAKE_PATH} LLVM_CMAKE_PATH). find_program(LLVM_TABLEGEN_EXE ""llvm-tblgen"" ${LLVM_TOOLS_BINARY_DIR}; NO_DEFAULT_PATH). set(LLVMCONFIG_FILE ""${LLVM_CMAKE_PATH}/LLVMConfig.cmake""); if(EXISTS ${LLVMCONFIG_FILE}); list(APPEND CMAKE_MODULE_PATH ""${LLVM_CMAKE_PATH}""); include(${LLVMCONFIG_FILE}); else(); message(FATAL_ERROR ""Not found: ${LLVMCONFIG_FILE}""); endif(); # We already FORCE-d the CACHE value to OFF",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:13832,assert,assertions,13832,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['assert'],['assertions']
Testability,"""; feature that can be used to conditionally disable (or expect failure in); certain tests. .. option:: --time-tests. Track the wall time individual tests take to execute and includes the results; in the summary output. This is useful for determining which tests in a test; suite take the most time to execute. .. option:: --ignore-fail. Exit with status zero even if some tests fail. .. _selection-options:. SELECTION OPTIONS; -----------------. By default, `lit` will run failing tests first, then run tests in descending; execution time order to optimize concurrency. The execution order can be; changed using the :option:`--order` option. The timing data is stored in the `test_exec_root` in a file named; `.lit_test_times.txt`. If this file does not exist, then `lit` checks the; `test_source_root` for the file to optionally accelerate clean builds. .. option:: --shuffle. Run the tests in a random order, not failing/slowest first. Deprecated,; use :option:`--order` instead. .. option:: --per-test-coverage. Emit the necessary test coverage data, divided per test case (involves; setting a unique value to LLVM_PROFILE_FILE for each RUN). The coverage; data files will be emitted in the directory specified by `config.test_exec_root`. .. option:: --max-failures N. Stop execution after the given number ``N`` of failures.; An integer argument should be passed on the command line; prior to execution. .. option:: --max-tests=N. Run at most ``N`` tests and then terminate. .. option:: --max-time=N. Spend at most ``N`` seconds (approximately) running tests and then terminate.; Note that this is not an alias for :option:`--timeout`; the two are; different kinds of maximums. .. option:: --num-shards=M. Divide the set of selected tests into ``M`` equal-sized subsets or; ""shards"", and run only one of them. Must be used with the; ``--run-shard=N`` option, which selects the shard to run. The environment; variable ``LIT_NUM_SHARDS`` can also be used in place of this; option. These two option",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:5924,test,test-coverage,5924,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['test-coverage']
Testability,"""Found distcc: ${DISTCC_COMMAND}""); if (ccache); # If ccache is enabled, use distcc as CCACHE_PREFIX; message(STATUS ""Because ccache is enabled, CCACHE_PREFIX is set to ${DISTCC_COMMAND}""); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ""CCACHE_PREFIX=${DISTCC_COMMAND} ${CCACHE_COMMAND}""); else(); set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${DISTCC_COMMAND}); endif(); execute_process(COMMAND ${DISTCC_COMMAND} ""--version"" OUTPUT_VARIABLE DISTCC_VERSION); string(REGEX REPLACE ""distcc ([0-9\\.]+).*"" ""\\1"" DISTCC_VERSION ${DISTCC_VERSION}); else(); message(STATUS ""Could NOT find distcc""); set(distcc OFF CACHE BOOL ""Use distcc (disabled since distcc was not found)"" FORCE); endif(); endif(). #---Enable test coverage -----------------------------------------------------------------------; if(coverage); set(GCC_COVERAGE_COMPILE_FLAGS ""-fprofile-arcs -ftest-coverage""); set(GCC_COVERAGE_LINK_FLAGS ""-fprofile-arcs""); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} ${GCC_COVERAGE_COMPILE_FLAGS}""); set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} ${GCC_COVERAGE_LINK_FLAGS}""); set(CMAKE_SHARED_LINKER_FLAGS ""${CMAKE_SHAREDLINKER_FLAGS} ${GCC_COVERAGE_LINK_FLAGS}""); set(CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS ""${CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS} ${GCC_COVERAGE_COMPILE_FLAGS}""); endif(). #--- Enable build timing -----------------------------------------------------------------------; if (build_timing); # FIXME: This currently will override the use of ccache if -Dbuild_timing=On -Dccache=On is passed.; set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ""${CMAKE_COMMAND} -E time""); set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ""${CMAKE_COMMAND} -E time""); #set_property(GLOBAL PROPERTY RULE_LAUNCH_CUSTOM ""${CMAKE_COMMAND} -E time""); endif(). #--- Set up address sanitizer builds ----------------------------------------------------------; if(asan); if(NOT CMAKE_COMPILER_IS_GNUCXX AND NOT CMAKE_CXX_COMPILER_ID MATCHES Clang); message(WARNING ""Address sanitizer builds only tested with",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:10236,test,test,10236,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['test'],['test']
Testability,"""StartLine"": 14; }; ]; },; {; ""Address"": ""0x400486"",; ""ModuleName"": ""inlined.elf"",; ""Symbol"": [; {; ""Column"": 3,; ""Discriminator"": 0,; ""FileName"": ""/tmp/test.cpp"",; ""FunctionName"": ""foo()"",; ""Line"": 6,; ""StartAddress"": ""0x400486"",; ""StartFileName"": ""/tmp/test.cpp"",; ""StartLine"": 5; }; ]; }; ]. .. option:: --pretty-print, -p. Print human readable output. If :option:`--inlining` is specified, the; enclosing scope is prefixed by (inlined by).; For JSON output, the option will cause JSON to be indented and split over; new lines. Otherwise, the JSON output will be printed in a compact form. .. code-block:: console. $ llvm-symbolizer --obj=inlined.elf 0x4004be --inlining --pretty-print; baz() at /tmp/test.cpp:11:18; (inlined by) main at /tmp/test.cpp:15:0. .. option:: --print-address, --addresses, -a. Print address before the source code location. Defaults to false. .. code-block:: console. $ llvm-symbolizer --obj=inlined.elf --print-address 0x4004be; 0x4004be; baz(); /tmp/test.cpp:11:18; main; /tmp/test.cpp:15:0. $ llvm-symbolizer --obj=inlined.elf 0x4004be --pretty-print --print-address; 0x4004be: baz() at /tmp/test.cpp:11:18; (inlined by) main at /tmp/test.cpp:15:0. .. option:: --print-source-context-lines <N>. Print ``N`` lines of source context for each symbolized address. .. code-block:: console. $ llvm-symbolizer --obj=test.elf 0x400490 --print-source-context-lines=3; baz(); /tmp/test.cpp:11:0; 10 : volatile int k = 42;; 11 >: return foz() + k;; 12 : }. .. option:: --relativenames. Print the file's path relative to the compilation directory, instead; of the absolute path. If the command-line to the compiler included; the full path, this will be the same as the default. .. option:: --verbose. Print verbose address, line and column information. .. code-block:: console. $ llvm-symbolizer --obj=inlined.elf --verbose 0x4004be; baz(); Filename: /tmp/test.cpp; Function start filename: /tmp/test.cpp; Function start line: 9; Function start address: 0x4004b6; Line: 11; Column",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst:11359,test,test,11359,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,1,['test'],['test']
Testability,"""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 User.cpp -c -o User.o"",; ""file"": ""User.cpp"",; ""output"": ""User.o""; }; ]. And we can get the dependency information in P1689 format by:. .. code-block:: console. $ clang-scan-deps -format=p1689 -compilation-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35659,log,logical-name,35659,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,1,['log'],['logical-name']
Testability,"# Bugpoint Redesign; Author: Diego Treviño (diegotf@google.com). Date: 2019-06-05. Status: Draft. ## Introduction; As use of bugpoint has grown several areas of improvement have been identified; through years of use: confusing to use, slow, it doesn’t always produce high; quality test cases, etc. This document proposes a new approach with a narrower; focus: minimization of IR test cases. ## Proposed New Design. ### Narrow focus: test-case reduction; The main focus will be a code reduction strategy to obtain much smaller test; cases that still have the same property as the original one. This will be done; via classic delta debugging and by adding some IR-specific reductions (e.g.; replacing globals, removing unused instructions, etc), similar to what; already exists, but with more in-depth minimization. Granted, if the community differs on this proposal, the legacy code could still; be present in the tool, but with the caveat of still being documented and; designed towards delta reduction. ### Command-Line Options; We are proposing to reduce the plethora of bugpoint’s options to just two: an; interesting-ness test and the arguments for said test, similar to other delta; reduction tools such as CReduce, Delta, and Lithium; the tool should feel less; cluttered, and there should also be no uncertainty about how to operate it. The interesting-ness test that’s going to be run to reduce the code is given; by name:; `--test=<test_name>`; If a `--test` option is not given, the program exits; this option is similar; to bugpoint’s current `-compile-custom` option, which lets the user run a; custom script. The interesting-ness test would be defined as a script that returns 0 when the; IR achieves a user-defined behaviour (e.g. failure to compile on clang) and a; nonzero value when otherwise. Leaving the user the freedom to determine what is; and isn’t interesting to the tool, and thus, streamlining the process of; reducing a test-case. If the test accepts any arguments (excludin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugpointRedesign.md:281,test,test,281,interpreter/llvm-project/llvm/docs/BugpointRedesign.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BugpointRedesign.md,4,['test'],"['test', 'test-case']"
Testability,"# Collection Classes. Collections are a key feature of the ROOT system. Many, if not most, of; the applications you write will use collections. If you have used; parameterized C++ collections or polymorphic collections before, some of; this material will be review. However, much of this chapter covers; aspects of collections specific to the ROOT system. When you have read; this chapter, you will know. - How to create instances of collections. - The difference between lists, arrays, hash tables, maps, etc. - How to add and remove elements of a collection. - How to search a collection for a specific element. - How to access and modify collection elements. - How to iterate over a collection to access collection elements. - How to manage memory for collections and collection elements. - How collection elements are tested for equality (`IsEqual(`)). - How collection elements are compared (`Compare())` in case of sorted; collections. - How collection elements are hashed (`Hash()`) in hash tables. ## Understanding Collections. A collection is a group of related objects. You will find it easier to; manage a large number of items as a collection. For example, a diagram; editor might manage a collection of points and lines. A set of widgets; for a graphical user interface can be placed in a collection. A; geometrical model can be described by collections of shapes, materials; and rotation matrices. Collections can themselves be placed in; collections. Collections act as flexible alternatives to traditional; data structures of computers science such as arrays, lists and trees. ### General Characteristics. The ROOT collections are polymorphic containers that hold pointers to; `TObjects`, so:. - They can only hold objects that inherit from **`TObject`**. - They return pointers to `TObjects`, that have to be cast back to the; correct subclass. Collections are dynamic; they can grow in size as required. Collections; themselves are descendants of **`TObject`** so can themselves be h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:822,test,tested,822,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['test'],['tested']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. # @author Danilo Piparo CERN, 2018; # @author Patrick Bos, NL eScience Center, 2018. ROOT_ADD_GTEST(testSimple testSimple.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooAddPdf testRooAddPdf.cxx LIBRARIES RooFitCore RooStats); ROOT_ADD_GTEST(testRooCacheManager testRooCacheManager.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooCategory testRooCategory.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testWorkspace testWorkspace.cxx LIBRARIES RooFitCore RooStats); ROOT_ADD_GTEST(testRooDataHist testRooDataHist.cxx LIBRARIES RooFitCore; COPY_TO_BUILDDIR ${CMAKE_CURRENT_SOURCE_DIR}/dataHistv4_ref.root; ${CMAKE_CURRENT_SOURCE_DIR}/dataHistv5_ref.root; ${CMAKE_CURRENT_SOURCE_DIR}/dataHistv6_ref.root); ROOT_ADD_GTEST(testRooBinSamplingPdf testRooBinSamplingPdf.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooWrapperPdf testRooWrapperPdf.cxx LIBRARIES Gpad RooFitCore); ROOT_ADD_GTEST(testGenericPdf testGenericPdf.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooAbsPdf testRooAbsPdf.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooAbsCollection testRooAbsCollection.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testRooDataSet testRooDataSet.cxx LIBRARIES Tree RooFitCore; COPY_TO_BUILDDIR ${CMAKE_CURRENT_SOURCE_DIR}/dataSet_with_errors_6_26_10.root); ROOT_ADD_GTEST(testRooFormula testRooFormula.cxx LIBRARIES RooFitCore ROOT::TestSupport); ROOT_ADD_GTEST(testRooProdPdf testRooProdPdf.cxx LIBRARIES RooFitCore); ROOT_ADD_GTEST(testProxiesAndCategories testProxiesAndCategories.cxx; LIBRARIES RooFitCore; COPY_TO_BUILDDIR ${CMAKE_CURRENT_SOURCE_DIR}/testProxiesAndCategories_1.root; ${CMAKE_CURRENT_SOURCE_DIR}/categories_v620.root; ${CMAKE_CURRENT_SOURCE_DIR}/categories_v621.root; ${CMAKE_CURRENT_SOURCE_DIR}/categories_v622.root; ${CMAKE_CURRENT_SOURCE_DIR}/categories_v624.root); ROOT_ADD_GTEST(testRo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/CMakeLists.txt:295,test,testSimple,295,roofit/roofitcore/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/CMakeLists.txt,16,['test'],"['testRooAddPdf', 'testRooBinSamplingPdf', 'testRooCacheManager', 'testRooCategory', 'testRooDataHist', 'testRooWrapperPdf', 'testSimple', 'testWorkspace']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. # @author Jonas Rembser CERN, 2024. # Even for the C++ tests, we need to setup the right environment to use PyROOT,; # because we are using PyROOT from C++. This environment mimics the one used in; # ROOT_ADD_PYUNITTEST.; if(MSVC); set(tpython_gtest_env ROOTSYS=${ROOTSYS}; PYTHONPATH=${ROOTSYS}/bin;$ENV{PYTHONPATH}); else(); set(tpython_gtest_env ROOTSYS=${ROOTSYS}; PATH=${ROOTSYS}/bin:$ENV{PATH}; LD_LIBRARY_PATH=${ROOTSYS}/lib:$ENV{LD_LIBRARY_PATH}; PYTHONPATH=${ROOTSYS}/lib:$ENV{PYTHONPATH}); endif(). if(NOT MSVC); # These tests fail on Windows because of a problem with std::any; # input_line_33:7:52: error: address of overloaded function 'make_any' does not match required type 'std::any (int &&)'; # new (ret) (std::any) (((std::any (&)(int &&))std::make_any<int, int, 0>)((int&&)*(int*)args[0]));; ROOT_ADD_GTEST(testTPython testTPython.cxx LIBRARIES ROOTTPython ENVIRONMENT ${tpython_gtest_env}); ROOT_ADD_PYUNITTEST(test_tpython test_tpython.py); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/tpython/test/CMakeLists.txt:250,test,tests,250,bindings/tpython/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/tpython/test/CMakeLists.txt,4,['test'],"['testTPython', 'tests']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. # @author Stephan Hageboeck CERN, 2019. if(NOT MSVC OR win_broken_tests); ROOT_ADD_GTEST(stressHistFactory stressHistFactory.cxx; LIBRARIES RooFitCore RooFit RooStats HistFactory; COPY_TO_BUILDDIR ${CMAKE_CURRENT_SOURCE_DIR}/HistFactoryTest.tar ${CMAKE_CURRENT_SOURCE_DIR}/HistFactoryTest.tar); endif(). ROOT_ADD_GTEST(testHistFactory testHistFactory.cxx; LIBRARIES RooFitCore RooFit RooStats HistFactory RooFitHS3; COPY_TO_BUILDDIR ${CMAKE_CURRENT_SOURCE_DIR}/ref_6.16_example_UsingC_channel1_meas_model.root ${CMAKE_CURRENT_SOURCE_DIR}/ref_6.16_example_UsingC_combined_meas_model.root). if(clad); target_compile_definitions(testHistFactory PUBLIC TEST_CODEGEN_AD); endif(clad). ROOT_ADD_GTEST(testParamHistFunc testParamHistFunc.cxx LIBRARIES RooFitCore HistFactory); ROOT_ADD_GTEST(testHistFactoryPlotting testHistFactoryPlotting.cxx LIBRARIES RooFitCore HistFactory); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/CMakeLists.txt:514,test,testHistFactory,514,roofit/histfactory/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/test/CMakeLists.txt,7,['test'],"['testHistFactory', 'testHistFactoryPlotting', 'testParamHistFunc']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. # @author Stephan Hageboeck, CERN, 2019. ROOT_ADD_GTEST(stabilityTests stabilityTests.cxx LIBRARIES RooFit); ROOT_ADD_GTEST(testRooBernstein testRooBernstein.cxx LIBRARIES RooFit); ROOT_ADD_GTEST(testRooBifurGauss testRooBifurGauss.cxx LIBRARIES RooFit); ROOT_ADD_GTEST(testRooCrystalBall testRooCrystalBall.cxx LIBRARIES Gpad RooFit); ROOT_ADD_GTEST(testRooExponential testRooExponential.cxx; COPY_TO_BUILDDIR ${CMAKE_CURRENT_SOURCE_DIR}/exponentialPdf.root; LIBRARIES Core RooFit); ROOT_ADD_GTEST(testRooGaussian testRooGaussian.cxx LIBRARIES RooFit); ROOT_ADD_GTEST(testRooJohnson testRooJohnson.cxx LIBRARIES Gpad RooFit); ROOT_ADD_GTEST(testRooKeysPdf testRooKeysPdf.cxx LIBRARIES Gpad RooFit); ROOT_ADD_GTEST(testRooLandau testRooLandau.cxx LIBRARIES RooFit); ROOT_ADD_GTEST(testRooParamHistFunc testRooParamHistFunc.cxx LIBRARIES Gpad RooFit); ROOT_ADD_GTEST(testRooPoisson testRooPoisson.cxx LIBRARIES RooFit). if(mathmore); ROOT_EXECUTABLE(testRooFit testRooFit.cxx LIBRARIES RooFit MathMore); ROOT_ADD_TEST(test-fit-testRooFit COMMAND testRooFit); ROOT_EXECUTABLE(testFitPerf testFitPerf.cxx LIBRARIES RooFit MathMore); ROOT_ADD_TEST(test-fit-testFitPerf COMMAND testFitPerf); else(); ROOT_EXECUTABLE(testRooFit testRooFit.cxx LIBRARIES RooFit); ROOT_ADD_TEST(test-fit-testRooFit COMMAND testRooFit); endif(). add_subdirectory(vectorisedPDFs); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/CMakeLists.txt:319,test,testRooBernstein,319,roofit/roofit/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/CMakeLists.txt,32,['test'],"['test-fit-testFitPerf', 'test-fit-testRooFit', 'testFitPerf', 'testRooBernstein', 'testRooBifurGauss', 'testRooCrystalBall', 'testRooExponential', 'testRooFit', 'testRooGaussian', 'testRooJohnson', 'testRooKeysPdf', 'testRooLandau', 'testRooParamHistFunc', 'testRooPoisson']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. # CMakeLists.txt for the ROOT tutorials programs.; # Author: Pere Mato, 25/10/2010; cmake_minimum_required(VERSION 3.10 FATAL_ERROR). project(tutorials). # Sergey: make no sence while CMakeLists.txt file cannot be used separately from ROOT; # but variables like ROOT_asimage_FOUND used here and produced in ROOTConfig.cmake; find_package(ROOT REQUIRED). if(DEFINED ROOT_SOURCE_DIR) # Testing using the binary tree; set(ROOT_root_CMD root.exe); if(NOT MSVC) # Ignore environment on Windows; set(ROOT_environ PATH=${CMAKE_BINARY_DIR}/bin:$ENV{PATH}; ${ld_library_path}=${CMAKE_BINARY_DIR}/lib:$ENV{${ld_library_path}}; ROOTSYS=${CMAKE_BINARY_DIR}; PYTHONPATH=${CMAKE_BINARY_DIR}/lib:$ENV{PYTHONPATH}); else(); set(ROOT_environ ROOTSYS=${CMAKE_BINARY_DIR}; PYTHONPATH=${CMAKE_BINARY_DIR}/bin;$ENV{PYTHONPATH}); endif(); else() # testing using an installation; include(${ROOT_USE_FILE}); if(DEFINED ROOT_CONFIG_EXECUTABLE) #---If ROOT was built with the classic configure/make---; set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/../cmake/modules); include(RootMacros); set(ROOT_root_CMD root.exe); endif(); enable_testing(); endif(). # Set the environment for the tutorials, which is the eventual ROOT_environ; # plus some environment variables related to limiting the number of threads; # used by NumPy.; # See: https://stackoverflow.com/questions/30791550/limit-number-of-threads-in-numpy; set(TUTORIAL_ENV ${ROOT_environ} OMP_NUM_THREADS=1 OPENBLAS_NUM_THREADS=1 MKL_NUM_THREADS=1). #---Copy the CTestCustom.cmake file into the build directory--------; configure_file(${CMAKE_CURRENT_SOURCE_DIR}/CTestCustom.cmake ${CMAKE_CURRENT_BINARY_DIR} COPYONLY). #---Provide a rootlogon.C file in the current build directory that; # will affect the way we run all tutorials.; # This overwrites ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt:1021,test,testing,1021,tutorials/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/CMakeLists.txt,1,['test'],['testing']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. # FIXME: The tests in core should require only libCore. OTOH, TQObjectTests uses the interpreter to register the class.; # This means that if we run make CoreBaseTests the executable wouldn't be runnable because it requires libCling and; # onepcm targets to be built.; # N.B. We don't link with libCling on Windows, since linking with libCling leads to the following error:; # MSVCRT.lib(tncleanup.obj) : error LNK2005: ""struct __type_info_node __type_info_root_node""; # (?__type_info_root_node@@3U__type_info_node@@A) already defined in libCling.lib(libCling.dll); # [C:\build\workspace\root-pullrequests-build\build\core\base\test\CoreBaseTests.vcxproj]. if(NOT MSVC); set(extralibs Cling dl); endif(). ROOT_ADD_GTEST(CoreBaseTests; TNamedTests.cxx; TQObjectTests.cxx; TExceptionHandlerTests.cxx; TStringTest.cxx; TBitsTests.cxx; LIBRARIES ${extralibs} RIO Core). ROOT_ADD_GTEST(CoreErrorTests TErrorTests.cxx LIBRARIES Core). ROOT_ADD_GTEST(CoreSystemTests TSystemTests.cxx LIBRARIES Core). configure_file(Foo.C Foo.C COPYONLY); ROOT_ADD_GTEST(IncludePathTest IncludePathTest.cxx LIBRARIES Core); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/test/CMakeLists.txt:208,test,tests,208,core/base/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/test/CMakeLists.txt,2,['test'],"['test', 'tests']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. # Make llvm and clang available here as we are mostly testing methods directly; # depending on them.; include_directories(SYSTEM; ${CLANG_INCLUDE_DIRS}; ${LLVM_INCLUDE_DIRS}; ${CLAD_INCLUDE_DIRS}; ). include_directories(; ../res; ../../clingutils/res; ../../foundation/res; ${CLING_INCLUDE_DIRS}; ). if(APPLE); # ignore; # ld: warning: direct access in function 'unsigned long std::__1::__str_find_first_of<char, unsigned long, std::__1::char_traits<char>, 18446744073709551615ul>(char const*, unsigned long, char const*, unsigned long, unsigned long)' from file '../CMakeFiles/ClingUtils.dir/src/TClingUtils.cxx.o' to global weak symbol 'std::__1::char_traits<char>::eq(char, char)' from file 'CMakeFiles/coreclingutilstestUnit.dir/TClingUtilsTests.cxx.o' means the weak symbol cannot be overridden at runtime. This was likely caused by different translation units being compiled with different visibility settings.; # ld: warning: direct access in function 'unsigned long std::__1::__str_find_first_of<char, unsigned long, std::__1::char_traits<char>, 18446744073709551615ul>(char const*, unsigned long, char const*, unsigned long, unsigned long)' from file '../../../interpreter/llvm-project/llvm/lib/libLLVMProfileData.a(InstrProf.cpp.o)' to global weak symbol 'std::__1::char_traits<char>::eq(char, char)' from file 'CMakeFiles/coreclingutilstestUnit.dir/TClingUtilsTests.cxx.o' means the weak symbol cannot be overridden at runtime. This was likely caused by different translation units being compiled with different visibility settings.; set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} -w""); endif(). if(NOT builtin_clang); link_directories(""${LLVM_LIBRARY_DIR}""); endif(). ROOT_ADD_UNITTEST_DIR(Core RIO ${CLING_LIBRARIES} $<TARGET_OBJECTS:ClingUtils>); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/test/CMakeLists.txt:249,test,testing,249,core/clingutils/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/test/CMakeLists.txt,1,['test'],['testing']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. # Test library loads during importing ROOT; # Testing only the Linux systems is sufficient to detect unwanted links to libraries at import time.; # Mac (and potentially Windows) pull in many system libraries which makes this test very complex.; if (NOT APPLE AND NOT WIN32); ROOT_ADD_PYUNITTEST(pyroot_import_load_libs import_load_libs.py); endif(). # Test ROOT module; ROOT_ADD_PYUNITTEST(pyroot_root_module root_module.py). # @pythonization decorator; ROOT_ADD_PYUNITTEST(pyroot_pyz_decorator pythonization_decorator.py). # General pythonizations; ROOT_ADD_PYUNITTEST(pyroot_pyz_pretty_printing pretty_printing.py); ROOT_ADD_PYUNITTEST(pyroot_pyz_array_interface array_interface.py PYTHON_DEPS numpy). # STL containers pythonizations; ROOT_ADD_PYUNITTEST(pyroot_pyz_stl_vector stl_vector.py); ROOT_ADD_PYUNITTEST(pyroot_pyz_stl_set stl_set.py). # TObject and subclasses pythonisations; ROOT_ADD_PYUNITTEST(pyroot_pyz_tobject_contains tobject_contains.py); ROOT_ADD_PYUNITTEST(pyroot_pyz_tobject_comparisonops tobject_comparisonops.py). # TClass pythonisations; ROOT_ADD_PYUNITTEST(pyroot_pyz_tclass_dynamiccast tclass_dynamiccast.py). # TContext pythonizations; ROOT_ADD_PYUNITTEST(pyroot_pyz_tcontext_contextmanager tcontext_contextmanager.py). # TDirectory and subclasses pythonizations; ROOT_ADD_PYUNITTEST(pyroot_pyz_tdirectory_attrsyntax tdirectory_attrsyntax.py); ROOT_ADD_PYUNITTEST(pyroot_pyz_tdirectoryfile_attrsyntax_get tdirectoryfile_attrsyntax_get.py); ROOT_ADD_PYUNITTEST(pyroot_pyz_tfile_attrsyntax_get_writeobject_open tfile_attrsyntax_get_writeobject_open.py); ROOT_ADD_PYUNITTEST(pyroot_pyz_tfile_constructor tfile_constructor.py); ROOT_ADD_PYUNITTEST(pyroot_pyz_tfile_context_manager tfile_context_manager.py). # TTree and subclasses pythonizations; file(COPY TreeHelper.h DESTINATION ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/CMakeLists.txt:420,test,test,420,bindings/pyroot/pythonizations/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/test/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for PyMVA package; ############################################################################; #Author: Omar Zapata, Lorenzo Moneta, Sergei Glayzer 22/08/2015; #website:http://oproject.org. ROOT_STANDARD_LIBRARY_PACKAGE(PyMVA; HEADERS; TMVA/MethodPyAdaBoost.h; TMVA/MethodPyGTB.h; TMVA/MethodPyKeras.h; TMVA/MethodPyRandomForest.h; TMVA/MethodPyTorch.h; TMVA/RModelParser_Keras.h; TMVA/RModelParser_PyTorch.h; TMVA/PyMethodBase.h; SOURCES; src/MethodPyAdaBoost.cxx; src/MethodPyGTB.cxx; src/MethodPyKeras.cxx; src/MethodPyRandomForest.cxx; src/MethodPyTorch.cxx; src/RModelParser_Keras.cxx; src/RModelParser_PyTorch.cxx; src/PyMethodBase.cxx; LIBRARIES; Python3::NumPy; Python3::Python; DEPENDENCIES; Core; Matrix; Thread; RIO; TMVA; ROOTTMVASofie; ). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/CMakeLists.txt:1076,test,test,1076,tmva/pymva/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building Envelope tests.; # @author Omar Zapata; ############################################################################; ROOT_ADD_GTEST(TMVA-Envelope testEnvelope.cxx LIBRARIES Core TMVA RIO); ROOT_ADD_GTEST(TMVA-Classification testClassification.cxx LIBRARIES Core TMVA RIO); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/CMakeLists.txt:317,test,tests,317,tmva/tmva/test/envelope/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/envelope/CMakeLists.txt,3,['test'],"['testClassification', 'testEnvelope', 'tests']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building PyMVA tests; # @author Stefan Wunsch; ############################################################################. project(pymva-tests). set(Libraries Core MathCore TMVA PyMVA ROOTTMVASofie). # Look for needed python modules; find_python_module(torch QUIET); find_python_module(keras QUIET); find_python_module(theano QUIET); find_python_module(tensorflow QUIET); find_python_module(sklearn QUIET). if(PY_SKLEARN_FOUND); # Test PyRandomForest: Classification; ROOT_EXECUTABLE(testPyRandomForestClassification testPyRandomForestClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-RandomForest-Classification COMMAND testPyRandomForestClassification). # Test PyRandomForest: Multi-class classification; ROOT_EXECUTABLE(testPyRandomForestMulticlass testPyRandomForestMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-RandomForest-Multiclass COMMAND testPyRandomForestMulticlass). # Test PyGTB: Classification; ROOT_EXECUTABLE(testPyGTBClassification testPyGTBClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-GTB-Classification COMMAND testPyGTBClassification DEPENDS PyMVA-RandomForest-Classification). # Test PyGTB: Multi-class classification; ROOT_EXECUTABLE(testPyGTBMulticlass testPyGTBMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-GTB-Multiclass COMMAND testPyGTBMulticlass DEPENDS PyMVA-RandomForest-Multiclass). # Test PyAdaBoost: Classification; ROOT_EXECUTABLE(testPyAdaBoostClassification testPyAdaBoostClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-AdaBoost-Classification COMMAND testPyAdaBoostClassification DEPENDS PyMVA-GTB-Classification). # Test PyAdaBoost: Multi-class classification; ROOT_EXECUTABLE(testPyAdaBoos",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt:314,test,tests,314,tmva/pymva/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt,5,['test'],"['testPyRandomForestClassification', 'tests']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT RooFitJSONInterface package; # @author Jonas Rembser, CERN; ############################################################################. # If RapidYAML can be found on the system, we will also compile the RapidYAML backend besides the; # nlohmann-json backend. Like this we can also convert to yaml. # The RapidYAML backend is always disabled because it doesn't work anymore for; # RooFitHS3. The nlohmann_json interface is always used and works well, hence; # rapidyaml was not tested anymore. The relevant code is still left in the; # CMakeLists.txt in case someone wants to revive the RapilYAML backend. # message(STATUS ""Looking for RapidYAML (used by RooFit)""); # find_package(ryml). if(${RYML_FOUND}); message(STATUS ""RapidYAML found, compiling also RooFit JSON Interface with RapidYAML parser""); set(ParserSources src/JSONParser.cxx src/RYMLParser.cxx); add_compile_definitions(ROOFIT_WITH_RYML); else(); set(ParserSources src/JSONParser.cxx); message(STATUS ""RapidYAML not found, only compiling RooFit with nlohmann-json parser""); endif(). ROOT_STANDARD_LIBRARY_PACKAGE(RooFitJSONInterface; HEADERS; RooFit/Detail/JSONInterface.h; SOURCES; src/JSONInterface.cxx; ${ParserSources}; DICTIONARY_OPTIONS; ""-writeEmptyRootPCM""; LIBRARIES; Core; ). if(${RYML_FOUND}); target_include_directories(RooFitJSONInterface PRIVATE ${RYML_INCLUDE_DIRS}); target_link_libraries(RooFitJSONInterface PRIVATE -lc4core -lryml); target_link_directories(RooFitJSONInterface PRIVATE ${RYML_LIB_DIR}); endif(). if(builtin_nlohmannjson); target_include_directories(RooFitJSONInterface PRIVATE ${CMAKE_SOURCE_DIR}/builtins); else(); target_link_libraries(RooFitJSONInterface PRIVATE nlohmann_json::nlohman",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/CMakeLists.txt:793,test,tested,793,roofit/jsoninterface/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/jsoninterface/CMakeLists.txt,1,['test'],['tested']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT TMVA tests.; # @author Kim Albertsson; ############################################################################. # Tests using google test; ROOT_ADD_GTEST(TestRandomGenerator; TestRandomGenerator.cxx; LIBRARIES TMVA); ROOT_ADD_GTEST(TestOptimizeConfigParameters; TestOptimizeConfigParameters.cxx; LIBRARIES TMVA). if(dataframe); # RTensor; ROOT_ADD_GTEST(rtensor rtensor.cxx LIBRARIES ROOTVecOps TMVA); ROOT_ADD_GTEST(rtensor-iterator rtensor_iterator.cxx LIBRARIES ROOTVecOps TMVA); ROOT_ADD_GTEST(rtensor-utils rtensor_utils.cxx LIBRARIES ROOTVecOps TMVA ROOTDataFrame); # RStandardScaler; ROOT_ADD_GTEST(rstandardscaler rstandardscaler.cxx LIBRARIES ROOTVecOps TMVA ROOTDataFrame); # RReader; ROOT_ADD_GTEST(rreader rreader.cxx LIBRARIES ROOTVecOps TMVA ROOTDataFrame); # Tree inference system and user interface; # Commented out right now because RBDT doesn't provide low-level interfaces; # since the sync with FastForest. Only the construction from XGBoost models; # is supported. If this feature becomes necessary to implement, one can; # resurrect these tests.; # ROOT_ADD_GTEST(branchlessForest branchlessForest.cxx LIBRARIES TMVA); # ROOT_ADD_GTEST(rbdt rbdt.cxx LIBRARIES ROOTVecOps TMVAUtils); endif(). if(dataframe); find_python_module(xgboost QUIET); if (PY_XGBOOST_FOUND); ROOT_ADD_PYUNITTEST(rbdt_xgboost rbdt_xgboost.py); endif(); endif(). #--stressTMVA--------------------------------------------------------------------------------------. ROOT_EXECUTABLE(stressTMVA stressTMVA.cxx LIBRARIES TMVA). if(tmva-gpu); target_compile_definitions(stressTMVA PRIVATE DNNCUDA); endif(). if(tmva-cpu); target_compile_definitions(stressTMVA PRIVATE DNNCPU); endif(). ROOT_ADD_T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/CMakeLists.txt:318,test,tests,318,tmva/tmva/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/CMakeLists.txt,2,['test'],"['test', 'tests']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT TMVA tests.; # @author Kim Albertsson; ############################################################################. set(Libraries TMVA). # Tests utilising google test; ROOT_ADD_GTEST(testCrossValidationSplitting; TestCrossValidationSplitting.cxx; LIBRARIES ${Libraries}). ROOT_ADD_GTEST(testCrossValidationIntVar; TestCrossValidationIntVar.cxx; LIBRARIES ${Libraries}). if(NOT MSVC); #---Multiproc is not supported on Windows; ROOT_ADD_GTEST(testCrossValidationMultiProc; TestCrossValidationMultiProc.cxx; LIBRARIES ${Libraries}); endif(). # Tests; ROOT_EXECUTABLE(testCrossValidationSerialise; TestCrossValidationSerialise.cxx; LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-CrossValidation-Serialise; COMMAND testCrossValidationSerialise); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/crossvalidation/CMakeLists.txt:318,test,tests,318,tmva/tmva/test/crossvalidation/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/crossvalidation/CMakeLists.txt,7,['test'],"['test', 'testCrossValidationIntVar', 'testCrossValidationMultiProc', 'testCrossValidationSerialise', 'testCrossValidationSplitting', 'tests']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT core/base package; ############################################################################. if(MSVC AND MSVC_VERSION GREATER_EQUAL 1925 AND MSVC_VERSION LESS 1929); # FIXME: since Visual Studio v16.5.0 the /O2 optimization flag makes most of the roofit/roostats tests failing; # Try to re-enable /O2 after the upgrade of llvm & clang, or when upgrading Visual Studio; string(REPLACE ""-O2"" ""-O1 -Oi"" CMAKE_CXX_FLAGS_RELEASE ""${CMAKE_CXX_FLAGS_RELEASE}""); string(REPLACE ""-O2"" ""-O1 -Oi"" CMAKE_CXX_FLAGS_RELWITHDEBINFO ""${CMAKE_CXX_FLAGS_RELWITHDEBINFO}""); endif(). set(BASE_HEADERS; ROOT/TErrorDefaultHandler.hxx; ROOT/TExecutorCRTP.hxx; ROOT/TSequentialExecutor.hxx; ROOT/StringConv.hxx; Buttons.h; Bytes.h; Byteswap.h; KeySymbols.h; MessageTypes.h; Riostream.h; Rtypes.h; TApplication.h; TAtt3D.h; TAttAxis.h; TAttBBox2D.h; TAttBBox.h; TAttFill.h; TAttLine.h; TAttMarker.h; TAttPad.h; TAttText.h; TBase64.h; TBenchmark.h; TBuffer3D.h; TBuffer3DTypes.h; TBuffer.h; TColor.h; TColorGradient.h; TDatime.h; TDirectory.h; TEnv.h; TException.h; TExec.h; TFileCollection.h; TFileInfo.h; TFolder.h; TInetAddress.h; TMacro.h; TMathBase.h; TMD5.h; TMemberInspector.h; TMessageHandler.h; TNamed.h; TNotifyLink.h; TObject.h; TObjString.h; TParameter.h; TPluginManager.h; TPoint.h; TPRegexp.h; TProcessID.h; TProcessUUID.h; TQClass.h; TQCommand.h; TQConnection.h; TQObject.h; TRedirectOutputGuard.h; TRefCnt.h; TRef.h; TRegexp.h; TRemoteObject.h; TROOT.h; TRootIOCtor.h; TStopwatch.h; TStorage.h; TString.h; TStringLong.h; TStyle.h; TSysEvtHandler.h; TSystemDirectory.h; TSystemFile.h; TSystem.h; TTask.h; TThreadSlots.h; TTime.h; TTimer.h; TTimeStamp.h; TUri.h; TUrl.h; TUUID.h; TVersionCheck.h;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/CMakeLists.txt:580,test,tests,580,core/base/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/CMakeLists.txt,1,['test'],['tests']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT core/cont package; ############################################################################. set_property(TARGET Core APPEND PROPERTY DICT_HEADERS; ROOT/TSeq.hxx; TArrayC.h; TArrayD.h; TArrayF.h; TArray.h; TArrayI.h; TArrayL64.h; TArrayL.h; TArrayS.h; TBits.h; TBtree.h; TClassTable.h; TClonesArray.h; TCollection.h; TCollectionProxyInfo.h; TExMap.h; THashList.h; THashTable.h; TIterator.h; TList.h; TMap.h; TObjArray.h; TObjectTable.h; TOrdCollection.h; TRefArray.h; TRefTable.h; TSeqCollection.h; TSortedList.h; TVirtualCollectionProxy.h; ). target_sources(Core PRIVATE; src/TArrayC.cxx; src/TArray.cxx; src/TArrayD.cxx; src/TArrayF.cxx; src/TArrayI.cxx; src/TArrayL64.cxx; src/TArrayL.cxx; src/TArrayS.cxx; src/TBits.cxx; src/TBtree.cxx; src/TClassTable.cxx; src/TClonesArray.cxx; src/TCollection.cxx; src/TExMap.cxx; src/THashList.cxx; src/THashTable.cxx; src/TIterator.cxx; src/TList.cxx; src/TMap.cxx; src/TObjArray.cxx; src/TObjectTable.cxx; src/TOrdCollection.cxx; src/TRefArray.cxx; src/TRefTable.cxx; src/TSeqCollection.cxx; src/TSortedList.cxx; ). target_include_directories(Core; PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/inc>). ROOT_INSTALL_HEADERS(). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/CMakeLists.txt:1520,test,test,1520,core/cont/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT core/foundation package; ############################################################################. set_property(TARGET Core APPEND PROPERTY DICT_HEADERS; ESTLType.h; RStringView.h; TClassEdit.h; TError.h; ThreadLocalStorage.h; ROOT/RLogger.hxx; ROOT/RNotFn.hxx; ROOT/RRangeCast.hxx; ROOT/RSpan.hxx; ROOT/RStringView.hxx; ROOT/StringUtils.hxx; ROOT/span.hxx; ROOT/TypeTraits.hxx; ). set(FOUNDATION_SOURCES; src/FoundationUtils.cxx; src/RConversionRuleParser.cxx; src/RLogger.cxx; src/StringUtils.cxx; src/TClassEdit.cxx; src/TError.cxx; ). set(FOUNDATION_HEADER_DIRS inc/). if(root7); set_property(TARGET Core APPEND PROPERTY DICT_HEADERS ROOT/RError.hxx); list(APPEND FOUNDATION_SOURCES; v7/src/RError.cxx); list(APPEND FOUNDATION_HEADER_DIRS v7/inc/); ROOT_ADD_TEST_SUBDIRECTORY(v7/test); endif(). target_sources(Core PRIVATE ${FOUNDATION_SOURCES}). target_include_directories(Core; PUBLIC; $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/inc>; $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/v7/inc>; PRIVATE; res; ). ROOT_OBJECT_LIBRARY(Foundation_Stage1 ${FOUNDATION_SOURCES}) # used by rootcling_stage1. target_include_directories(Foundation_Stage1; PUBLIC; $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/inc>; PRIVATE; $<$<BOOL:${MSVC}>:${CMAKE_SOURCE_DIR}/core/winnt/inc>; ${CMAKE_BINARY_DIR}/ginclude res; ). set_target_properties(Foundation_Stage1 PROPERTIES; COMPILE_FLAGS ""${COMPILE_FLAGS} ${CLING_CXXFLAGS}""; VISIBILITY_INLINES_HIDDEN ""ON""; ). ROOT_INSTALL_HEADERS(${FOUNDATION_HEADER_DIRS}); ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/CMakeLists.txt:1100,test,test,1100,core/foundation/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/CMakeLists.txt,2,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT core/imt package; ############################################################################. if(NOT WIN32); set(MULTIPROC_LIB ""MultiProc""); endif(). ROOT_LINKER_LIBRARY(Imt; src/base.cxx; src/RSlotStack.cxx; src/TExecutor.cxx; src/TTaskGroup.cxx; DEPENDENCIES; ${MULTIPROC_LIB}; BUILTINS; TBB; ). target_link_libraries(Imt PRIVATE Thread INTERFACE Core). if(imt); ROOT_GENERATE_DICTIONARY(G__Imt STAGE1; ROOT/TTaskGroup.hxx; ROOT/RTaskArena.hxx; ROOT/RSlotStack.hxx; ROOT/TExecutor.hxx; ROOT/TThreadExecutor.hxx; LINKDEF; LinkDef.h; MODULE; Imt; DEPENDENCIES; Core; Thread; ${MULTIPROC_LIB}; BUILTINS; TBB; ). # G__Imt.cxx is automatically added by ROOT_GENERATE_DICTIONARY(); target_sources(Imt PRIVATE; src/RTaskArena.cxx; src/TImplicitMT.cxx; src/TThreadExecutor.cxx; ). target_include_directories(Imt SYSTEM PRIVATE ${TBB_INCLUDE_DIRS}); target_link_libraries(Imt PRIVATE ${TBB_LIBRARIES}); set_target_properties(Imt PROPERTIES COMPILE_FLAGS ""${TBB_CXXFLAGS}""). ROOT_ADD_TEST_SUBDIRECTORY(test); else(); ROOT_GENERATE_DICTIONARY(G__Imt STAGE1; ROOT/TExecutor.hxx; LINKDEF; LinkDef.h; MODULE; Imt; DEPENDENCIES; Core; ${MULTIPROC_LIB}; ); endif(). ROOT_INSTALL_HEADERS(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/CMakeLists.txt:1309,test,test,1309,core/imt/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT core/metacling package; ############################################################################. add_subdirectory(src). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/CMakeLists.txt:465,test,test,465,core/metacling/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT core/rint package; ############################################################################. ROOT_STANDARD_LIBRARY_PACKAGE(Rint; STAGE1; HEADERS; TRint.h; TTabCom.h; SOURCES; src/TRint.cxx; src/TTabCom.cxx; DICTIONARY_OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; Core; ). target_include_directories(Core PRIVATE inc). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rint/CMakeLists.txt:660,test,test,660,core/rint/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rint/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT graf2d/gpadv7 package; # @author Pere Mato, CERN; ############################################################################. ROOT_STANDARD_LIBRARY_PACKAGE(ROOTGpadv7; HEADERS; ROOT/RCanvas.hxx; ROOT/RFrame.hxx; ROOT/RMenuItems.hxx; ROOT/RColor.hxx; ROOT/RDisplayItem.hxx; ROOT/RAttrMap.hxx; ROOT/RAttrBase.hxx; ROOT/RAttrAggregation.hxx; ROOT/RAttrAxis.hxx; ROOT/RAttrBorder.hxx; ROOT/RAttrLine.hxx; ROOT/RAttrFill.hxx; ROOT/RAttrFont.hxx; ROOT/RAttrMarker.hxx; ROOT/RAttrMargins.hxx; ROOT/RAttrText.hxx; ROOT/RAttrValue.hxx; ROOT/RAxisDrawable.hxx; ROOT/RPalette.hxx; ROOT/RPaletteDrawable.hxx; ROOT/RDrawable.hxx; ROOT/ROnFrameDrawable.hxx; ROOT/RDrawableRequest.hxx; ROOT/RStyle.hxx; ROOT/RPadDisplayItem.hxx; ROOT/RPadExtent.hxx; ROOT/RPadBase.hxx; ROOT/RPad.hxx; ROOT/RPadLength.hxx; ROOT/RPadPos.hxx; ROOT/RPave.hxx; ROOT/RVirtualCanvasPainter.hxx; ROOT/TObjectDisplayItem.hxx; ROOT/TObjectDrawable.hxx; SOURCES; src/RCanvas.cxx; src/RFrame.cxx; src/RMenuItems.cxx; src/RColor.cxx; src/RDisplayItem.cxx; src/RDrawable.cxx; src/RDrawableRequest.cxx; src/RAttrMap.cxx; src/RAttrBase.cxx; src/RAttrAggregation.cxx; src/RPalette.cxx; src/RStyle.cxx; src/RPadBase.cxx; src/RPad.cxx; src/RPadExtent.cxx; src/RPadLength.cxx; src/RPadPos.cxx; src/RVirtualCanvasPainter.cxx; src/TObjectDrawable.cxx; DICTIONARY_OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; Core; RIO; ). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/CMakeLists.txt:1708,test,test,1708,graf2d/gpadv7/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT graf2d/primitives package; # @author Pere Mato, CERN; ############################################################################. ROOT_STANDARD_LIBRARY_PACKAGE(ROOTGraphicsPrimitives; HEADERS; ROOT/RBox.hxx; ROOT/RFont.hxx; ROOT/RFrameTitle.hxx; ROOT/RLegend.hxx; ROOT/RLine.hxx; ROOT/RMarker.hxx; ROOT/RPaveText.hxx; ROOT/RText.hxx; SOURCES; src/RBox.cxx; src/RFont.cxx; src/RLegend.cxx; src/RLine.cxx; src/RMarker.cxx; src/RText.cxx; DICTIONARY_OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; Core; ROOTGpadv7; ). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/primitivesv7/CMakeLists.txt:853,test,test,853,graf2d/primitivesv7/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/primitivesv7/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT hist/hist package; ############################################################################. ROOT_STANDARD_LIBRARY_PACKAGE(ROOTHist; HEADERS; ROOT/RAxis.hxx; ROOT/RAxisConfig.hxx; ROOT/RHist.hxx; ROOT/RHistBinIter.hxx; ROOT/RHistBufferedFill.hxx; ROOT/RHistConcurrentFill.hxx; ROOT/RHistData.hxx; ROOT/RHistImpl.hxx; ROOT/RHistUtils.hxx; ROOT/RHistView.hxx; SOURCES; src/RAxis.cxx; DICTIONARY_OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; MathCore; Matrix; RIO; ). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/CMakeLists.txt:806,test,test,806,hist/histv7/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT hist/histdraw package; ############################################################################. ROOT_STANDARD_LIBRARY_PACKAGE(ROOTHistDraw; HEADERS; ROOT/RHistDisplayItem.hxx; ROOT/RHistDrawable.hxx; ROOT/RHistStatBox.hxx; SOURCES; src/RHistDisplayItem.cxx; src/RHistDrawable.cxx; src/RHistStatBox.cxx; DICTIONARY_OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; Core; MathCore; ROOTHist; ROOTGpadv7; ). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/CMakeLists.txt:743,test,test,743,hist/histdrawv7/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT math/foam package; ############################################################################. ROOT_STANDARD_LIBRARY_PACKAGE(Foam; HEADERS; TFoam.h; TFoamCell.h; TFoamIntegrand.h; TFoamMaxwt.h; TFoamSampler.h; TFoamVect.h; SOURCES; src/TFoam.cxx; src/TFoamCell.cxx; src/TFoamIntegrand.cxx; src/TFoamMaxwt.cxx; src/TFoamSampler.cxx; src/TFoamVect.cxx; DEPENDENCIES; Hist; MathCore; ). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/CMakeLists.txt:726,test,test,726,math/foam/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT math/genetic package; # @author Pere Mato, CERN; ############################################################################; ROOT_STANDARD_LIBRARY_PACKAGE(Genetic; HEADERS; Math/GeneticMinimizer.h; SOURCES; src/GeneticMinimizer.cxx; DICTIONARY_OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; Core; MathCore; TMVA; ). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genetic/CMakeLists.txt:654,test,test,654,math/genetic/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genetic/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT math/matrix package; ############################################################################. ROOT_STANDARD_LIBRARY_PACKAGE(Matrix; HEADERS; TDecompBK.h; TDecompBase.h; TDecompChol.h; TDecompLU.h; TDecompQRH.h; TDecompSVD.h; TDecompSparse.h; TMatrix.h; TMatrixD.h; TMatrixDBase.h; TMatrixDBasefwd.h; TMatrixDEigen.h; TMatrixDLazy.h; TMatrixDSparse.h; TMatrixDSparsefwd.h; TMatrixDSym.h; TMatrixDSymEigen.h; TMatrixDSymfwd.h; TMatrixDUtils.h; TMatrixDUtilsfwd.h; TMatrixDfwd.h; TMatrixF.h; TMatrixFBase.h; TMatrixFBasefwd.h; TMatrixFLazy.h; TMatrixFSparse.h; TMatrixFSparsefwd.h; TMatrixFSym.h; TMatrixFSymfwd.h; TMatrixFUtils.h; TMatrixFUtilsfwd.h; TMatrixFfwd.h; TMatrixT.h; TMatrixTBase.h; TMatrixTCramerInv.h; TMatrixTLazy.h; TMatrixTSparse.h; TMatrixTSym.h; TMatrixTSymCramerInv.h; TMatrixTUtils.h; TVector.h; TVectorD.h; TVectorDfwd.h; TVectorF.h; TVectorFfwd.h; TVectorT.h; TVectorfwd.h; SOURCES; src/TDecompBK.cxx; src/TDecompBase.cxx; src/TDecompChol.cxx; src/TDecompLU.cxx; src/TDecompQRH.cxx; src/TDecompSVD.cxx; src/TDecompSparse.cxx; src/TMatrixDEigen.cxx; src/TMatrixDSymEigen.cxx; src/TMatrixT.cxx; src/TMatrixTBase.cxx; src/TMatrixTCramerInv.cxx; src/TMatrixTLazy.cxx; src/TMatrixTSparse.cxx; src/TMatrixTSym.cxx; src/TMatrixTSymCramerInv.cxx; src/TMatrixTUtils.cxx; src/TVectorT.cxx; DEPENDENCIES; MathCore; DICTIONARY_OPTIONS; -writeEmptyRootPCM; ). ROOT_ADD_TEST_SUBDIRECTORY(test). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/CMakeLists.txt:1712,test,test,1712,math/matrix/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT montecarlo/eg package; # @author Pere Mato, CERN; ############################################################################. ROOT_STANDARD_LIBRARY_PACKAGE(EG; HEADERS; TAttParticle.h; TDatabasePDG.h; TDecayChannel.h; TGenerator.h; TPDGCode.h; TParticleClassPDG.h; TParticle.h; TParticlePDG.h; TPrimary.h; TVirtualMCDecayer.h; SOURCES; src/TAttParticle.cxx; src/TDatabasePDG.cxx; src/TDecayChannel.cxx; src/TGenerator.cxx; src/TParticleClassPDG.cxx; src/TParticle.cxx; src/TParticlePDG.cxx; src/TPrimary.cxx; src/TVirtualMCDecayer.cxx; DEPENDENCIES; Gpad; Graf; Graf3d; MathCore; Physics; ). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/CMakeLists.txt:934,test,test,934,montecarlo/eg/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT net/davix package; # @author Pere Mato, CERN; ############################################################################. ROOT_STANDARD_LIBRARY_PACKAGE(RDAVIX; HEADERS; ROOT/RRawFileDavix.hxx; TDavixFile.h; TDavixSystem.h; SOURCES; src/RRawFileDavix.cxx; src/TDavixFile.cxx; src/TDavixSystem.cxx; LIBRARIES; Davix::Davix; DEPENDENCIES; Net; RIO; ). target_compile_options(RDAVIX PRIVATE -Wno-deprecated-declarations). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/davix/CMakeLists.txt:760,test,test,760,net/davix/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/davix/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT net/netxng package; # @author Lukasz Janyst <ljanyst@cern.ch>; ############################################################################. ROOT_STANDARD_LIBRARY_PACKAGE(NetxNG; HEADERS; TNetXNGFile.h; TNetXNGFileStager.h; TNetXNGSystem.h; ROOT/RRawFileNetXNG.hxx; SOURCES; src/TNetXNGFile.cxx; src/TNetXNGFileStager.cxx; src/TNetXNGSystem.cxx; src/RRawFileNetXNG.cxx; DEPENDENCIES; Net; RIO; Thread; ). target_link_libraries(NetxNG PRIVATE ROOT::XRootD); target_compile_options(NetxNG PRIVATE -Wno-shadow). # When linking against the XRootD target, XRootD includes become ""-isystem"".; # By linking explicitly here, we suppress a warning during dictionary compilation.; target_link_libraries(G__NetxNG PRIVATE ROOT::XRootD). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/netxng/CMakeLists.txt:1066,test,test,1066,net/netxng/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/netxng/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT proof/proofbench package; ############################################################################. ROOT_STANDARD_LIBRARY_PACKAGE(ProofBench; HEADERS; TProofBenchDataSet.h; TProofBench.h; TProofBenchRunCPU.h; TProofBenchRunDataRead.h; TProofBenchRun.h; TProofBenchTypes.h; TProofNodes.h; TProofPerfAnalysis.h; SOURCES; src/TProofBench.cxx; src/TProofBenchDataSet.cxx; src/TProofBenchRunCPU.cxx; src/TProofBenchRun.cxx; src/TProofBenchRunDataRead.cxx; src/TProofNodes.cxx; src/TProofPerfAnalysis.cxx; DEPENDENCIES; Core; Gpad; Hist; ProofPlayer; INSTALL_OPTIONS; FILTER ""TSel""; ). # Generation and installation of the PAR files required by the benchmark; add_custom_target(ProofBenchPARFiles ALL; DEPENDS; ${CMAKE_BINARY_DIR}/etc/proof/proofbench/ProofBenchCPUSel.par; ${CMAKE_BINARY_DIR}/etc/proof/proofbench/ProofBenchDataSel.par; ). add_custom_command(OUTPUT; ${CMAKE_BINARY_DIR}/etc/proof/proofbench/ProofBenchCPUSel.par; ${CMAKE_BINARY_DIR}/etc/proof/proofbench/ProofBenchDataSel.par; DEPENDS; ${CMAKE_SOURCE_DIR}/etc/proof/utils/makepbenchpars.sh; COMMAND; ${CMAKE_COMMAND} -E make_directory ${CMAKE_BINARY_DIR}/etc/proof/proofbench; COMMAND; ${CMAKE_SOURCE_DIR}/etc/proof/utils/makepbenchpars.sh ProofBenchCPUSel ${CMAKE_SOURCE_DIR} ${CMAKE_BINARY_DIR}; COMMAND; ${CMAKE_SOURCE_DIR}/etc/proof/utils/makepbenchpars.sh ProofBenchDataSel ${CMAKE_SOURCE_DIR} ${CMAKE_BINARY_DIR}; WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}; ). install(DIRECTORY ${CMAKE_BINARY_DIR}/etc/proof/proofbench; DESTINATION ${CMAKE_INSTALL_SYSCONFDIR}/proof USE_SOURCE_PERMISSIONS); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/CMakeLists.txt:960,benchmark,benchmark,960,proof/proofbench/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/CMakeLists.txt,1,['benchmark'],['benchmark']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT roofitmore package; # @author Lorenzo Moneta, CERN; ############################################################################. if(mathmore); set(ROOT_MATHMORE_LIBRARY MathMore); endif(). set (EXTRA_DICT_OPTS); if (runtime_cxxmodules AND WIN32); set (EXTRA_DICT_OPTS NO_CXXMODULE); endif(). ROOT_STANDARD_LIBRARY_PACKAGE(RooFitMore; HEADERS; RooFitMoreLib.h; RooLegendre.h; RooMathMoreReg.h; RooSpHarmonic.h; RooNonCentralChiSquare.h; RooHypatia2.h; SOURCES; src/RooFitMoreLib.cxx; src/RooAdaptiveGaussKronrodIntegrator1D.cxx; src/RooGaussKronrodIntegrator1D.cxx; src/RooLegendre.cxx; src/RooMathMoreReg.cxx; src/RooSpHarmonic.cxx; src/RooNonCentralChiSquare.cxx; src/RooHypatia2.cxx; DICTIONARY_OPTIONS; ""-writeEmptyRootPCM""; LINKDEF; LinkDef.h; LIBRARIES; RooBatchCompute; DEPENDENCIES; ${ROOT_MATHMORE_LIBRARY}; Core; RooFitCore; RooFit; Hist; Matrix; Tree; Minuit; RIO; MathCore; Foam; BUILTINS; GSL; ${EXTRA_DICT_OPTS}; ). target_include_directories(RooFitMore SYSTEM PRIVATE ${GSL_INCLUDE_DIR}); target_link_libraries(RooFitMore PRIVATE ${GSL_LIBRARIES}). # For recent clang, this can facilitate auto-vectorisation.; # In RooFit, the errno side effect is not needed, anyway:; if(""${CMAKE_CXX_COMPILER_ID}"" MATCHES ""Clang""); target_compile_options(RooFitMore PUBLIC -fno-math-errno); endif(). #ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/CMakeLists.txt:1641,test,test,1641,roofit/roofitmore/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT rootfit/histfactory package; # @author Carsten Burgard, CERN; ############################################################################. ROOT_STANDARD_LIBRARY_PACKAGE(RooFitHS3; HEADERS; RooFitHS3/JSONIO.h; RooFitHS3/RooJSONFactoryWSTool.h; SOURCES; src/Domains.cxx; src/JSONIO.cxx; src/RooJSONFactoryWSTool.cxx; src/JSONFactories_RooFitCore.cxx; src/JSONFactories_HistFactory.cxx; src/JSONIOUtils.cxx; DICTIONARY_OPTIONS; ""-writeEmptyRootPCM""; DEPENDENCIES; RooFitCore; RooFitJSONInterface; LIBRARIES; RooFit; HistFactory; ). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/CMakeLists.txt:870,test,test,870,roofit/hs3/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building TMVA/DNN tests.; # @author Simon Pfreundschuh; ############################################################################. set(Libraries TMVA). #--- CUDA tests. ---------------------------; if (tmva-gpu). include_directories(${CUDA_INCLUDE_DIRS}). SET(DNN_CUDA_LIBRARIES ${CUDA_CUBLAS_LIBRARIES} ). list(APPEND Libraries ${DNN_CUDA_LIBRARIES} CUDA::cuda_driver CUDA::cudart). # DNN - Activation Functions Cuda; add_executable(testActivationFunctionsCuda TestActivationFunctionsCuda.cxx); TARGET_LINK_LIBRARIES(testActivationFunctionsCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-ActivationFunctionsCuda COMMAND testActivationFunctionsCuda). # DNN - Loss Functions Cuda; add_executable(testLossFunctionsCuda TestLossFunctionsCuda.cxx); TARGET_LINK_LIBRARIES(testLossFunctionsCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-LossFunctionsCuda COMMAND testLossFunctionsCuda). # DNN - Derivatives Cuda; add_executable(testDerivativesCuda TestDerivativesCuda.cxx); TARGET_LINK_LIBRARIES(testDerivativesCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-DerivativesCuda COMMAND testDerivativesCuda). # DNN - Backpropagation Cuda; add_executable(testBackpropagationCuda TestBackpropagationCuda.cxx); TARGET_LINK_LIBRARIES(testBackpropagationCuda ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-BackpropagationCuda COMMAND testBackpropagationCuda). # DNN - Backpropagation DL Cuda; add_executable(testBackpropagationDLCuda TestBackpropagationDLCuda.cxx ); TARGET_LINK_LIBRARIES(testBackpropagationDLCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-Backpropagation-DLCuda COMMAND testBackpropagationDLCuda). # DNN - Batch normalization Cuda; add_executable(testBatchNormalizationCuda TestBatchNormalizationCuda.cxx ); TARGET_LINK",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt:317,test,tests,317,tmva/tmva/test/DNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt,6,['test'],"['testActivationFunctionsCuda', 'testLossFunctionsCuda', 'tests']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building TMVA/DNN/CNN tests.; # @author Vladimir Ilievski; ############################################################################. set(Libraries TMVA). #--- CUDA tests. ---------------------------; if (tmva-gpu). list(APPEND Libraries CUDA::cuda_driver CUDA::cudart). set(DNN_CUDA_LIBRARIES ${CUDA_CUBLAS_LIBRARIES} ). add_executable(testIm2ColCuda TestIm2ColCuda.cxx); target_link_libraries(testIm2ColCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-Im2ColCuda COMMAND testIm2ColCuda). add_executable(testPoolingLayerCuda TestPoolingLayerCuda.cxx); target_link_libraries(testPoolingLayerCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-PoolingLayerCuda COMMAND testPoolingLayerCuda). add_executable(testReshapeCuda TestReshapeCuda.cxx); target_link_libraries(testReshapeCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ReshapeCuda COMMAND testReshapeCuda). add_executable(testConvLayerCuda TestConvLayerCuda.cxx); target_link_libraries(testConvLayerCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ConvLayerCuda COMMAND testConvLayerCuda). add_executable(testForwardPassCuda TestForwardPassCuda.cxx); target_link_libraries(testForwardPassCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ForwardCuda COMMAND testForwardPassCuda). add_executable(testRotateWeightsCuda TestRotateWeightsCuda.cxx); target_link_libraries(testRotateWeightsCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-RotateWeightsCuda COMMAND testRotateWeightsCuda). add_executable(testConvBackpropagationCuda TestConvBackpropagationCuda.cxx); target_link_libraries(testConvBackpropagationCuda ${Libraries} ${D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt:321,test,tests,321,tmva/tmva/test/DNN/CNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt,5,['test'],"['testPoolingLayerCuda', 'tests']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building TMVA/DNN/RNN tests.; # @author Saurav Shekhar; ############################################################################. set(Libraries TMVA). if (tmva-gpu); list(APPEND Libraries CUDA::cuda_driver CUDA::cudart); endif(). #---Reference test. if (Test_Reference). # RNN - BackPropagation Reference; ROOT_EXECUTABLE(testRecurrentBackpropagation TestRecurrentBackpropagation.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-RNN-Backpropagation COMMAND testRecurrentBackpropagation); #; # RNN - Forward Reference; ROOT_EXECUTABLE(testRecurrentForwardPass TestRecurrentForwardPass.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-RNN-Forward COMMAND testRecurrentForwardPass). # RNN - Full Test Reference; ROOT_EXECUTABLE(testFullRNN TestFullRNN.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-RNN-FullRNN COMMAND testFullRNN). endif(). #--- CUDA tests. ---------------------------; if (tmva-gpu). set(DNN_CUDA_LIBRARIES ${CUDA_CUBLAS_LIBRARIES}). add_executable(testRecurrentBackpropagationCuda TestRecurrentBackpropagationCuda.cxx); target_link_libraries(testRecurrentBackpropagationCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-RNN-BackpropagationCuda COMMAND testRecurrentBackpropagationCuda); #mark the native Cuda test failing since RNN are supported only with Cudnn; set_tests_properties(TMVA-DNN-RNN-BackpropagationCuda PROPERTIES WILL_FAIL true). if (tmva-cudnn). add_executable(testRecurrentForwardPassCudnn TestRecurrentForwardPassCudnn.cxx); target_link_libraries(testRecurrentForwardPassCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-RNN-Forwaed-Cudnn COMMAND testRecurrentForwardPassCudnn). add_executable(testRecurrentBackpropagatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/CMakeLists.txt:321,test,tests,321,tmva/tmva/test/DNN/RNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/CMakeLists.txt,6,['test'],"['test', 'testRecurrentBackpropagation', 'testRecurrentForwardPass', 'tests']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building TMVA/Method tests.; # @author Kim Albertsson; ############################################################################. # As the reference implementation is deprecated and; # can't be instantiated, we can only run this test; # if there if we can run CPU or CUDA versions.; #if (defined DNNCPU || defined DNNCUDA); if(tmva-cpu OR tmva-gpu); ROOT_ADD_GTEST(TestMethodDNNValidationSize; TestMethodDNNValidationSize.cxx; LIBRARIES TMVA); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/CMakeLists.txt:320,test,tests,320,tmva/tmva/test/Method/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/Method/CMakeLists.txt,2,['test'],"['test', 'tests']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building TMVA/ROC tests.; # @author Kim Albertsson; ############################################################################. ROOT_ADD_GTEST(testRocWeights; testRocWeights.cxx; LIBRARIES TMVA); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/CMakeLists.txt:317,test,tests,317,tmva/tmva/test/ROC/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/CMakeLists.txt,3,['test'],"['testRocWeights', 'tests']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ###########################################################; # CMakeLists.txt file for building TPython; ###########################################################. ROOT_STANDARD_LIBRARY_PACKAGE(ROOTTPython; HEADERS; TPyArg.h; TPyReturn.h; TPython.h; SOURCES; src/TPyArg.cxx; src/TPyClassGenerator.cxx; src/TPyReturn.cxx; src/TPython.cxx; DICTIONARY_OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; Core; LIBRARIES; cppyy; # We link libTPython against Python libraries to compensate for the fact that libcppyy; # is built with unresolved symbols. If we didn't do this, invoking TPython from C++; # would not work.; Python3::Python; ). # Disables warnings originating from deprecated register keyword in Python; if(""${CMAKE_CXX_COMPILER_ID}"" STREQUAL ""GNU"" AND CMAKE_CXX_STANDARD GREATER_EQUAL 11); target_compile_options(ROOTTPython PRIVATE -Wno-register); endif(); if(""${CMAKE_CXX_COMPILER_ID}"" MATCHES ""Clang"" AND CMAKE_CXX_STANDARD GREATER_EQUAL 11); target_compile_options(ROOTTPython PRIVATE -Wno-register); target_compile_options(ROOTTPython PRIVATE -Wno-deprecated-register); endif(). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/tpython/CMakeLists.txt:1309,test,test,1309,bindings/tpython/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/tpython/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ROOT_ADD_GTEST(RRawFile RRawFile.cxx LIBRARIES RIO); ROOT_ADD_GTEST(TFile TFileTests.cxx LIBRARIES RIO); ROOT_ADD_GTEST(TBufferFile TBufferFileTests.cxx LIBRARIES RIO); ROOT_ADD_GTEST(TBufferMerger TBufferMerger.cxx LIBRARIES RIO Imt Tree); ROOT_ADD_GTEST(TBufferJSON TBufferJSONTests.cxx LIBRARIES RIO); ROOT_ADD_GTEST(TFileMerger TFileMergerTests.cxx LIBRARIES RIO Tree Hist); ROOT_ADD_GTEST(TROMemFile TROMemFileTests.cxx LIBRARIES RIO Tree); if(uring AND NOT DEFINED ENV{ROOTTEST_IGNORE_URING}); ROOT_ADD_GTEST(RIoUring RIoUring.cxx LIBRARIES RIO); endif(). # Temporarily disabled. Test routinely fails on MacOS and some Linuxes.; #if(NOT WIN32 AND (NOT MACOS_VERSION OR NOT MACOSX_VERSION VERSION_LESS 13.00)); # ROOT_EXECUTABLE(TMapFileTest TMapFileTest.cxx LIBRARIES RIO Hist New); # ROOT_ADD_TEST(io-io-test-TMapFileTest COMMAND TMapFileTest complete); #endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/test/CMakeLists.txt:1006,test,test-TMapFileTest,1006,io/io/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/test/CMakeLists.txt,1,['test'],['test-TMapFileTest']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ROOT_ADD_GTEST(drawUnit draw.cxx LIBRARIES ROOTHistDraw); # On Windows, this test receives ""unexpected diagnostic of severity 2000""; # because ""pointer was truncated (due a missing dictionary)"" and then trying; # to allocate ""an object of abstract class type 'RHistImplBase'"".; if(NOT MSVC OR win_broken_tests); ROOT_ADD_GTEST(ioUnit io.cxx LIBRARIES ROOTHistDraw); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/test/CMakeLists.txt:272,test,test,272,hist/histdrawv7/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/test/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ROOT_ADD_GTEST(testMake_unique testMake_unique.cxx LIBRARIES Core); ROOT_ADD_GTEST(testTypeTraits testTypeTraits.cxx LIBRARIES Core); ROOT_ADD_GTEST(testNotFn testNotFn.cxx LIBRARIES Core); ROOT_ADD_GTEST(testClassEdit testClassEdit.cxx LIBRARIES Core); ROOT_ADD_GTEST(testLogger testLogger.cxx LIBRARIES Core); ROOT_ADD_GTEST(testRRangeCast testRRangeCast.cxx LIBRARIES Core); ROOT_ADD_GTEST(testStringUtils testStringUtils.cxx LIBRARIES Core); ROOT_ADD_GTEST(FoundationUtilsTests FoundationUtilsTests.cxx LIBRARIES Core INCLUDE_DIRS ../res); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/test/CMakeLists.txt:278,test,testTypeTraits,278,core/foundation/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/test/CMakeLists.txt,12,['test'],"['testClassEdit', 'testLogger', 'testNotFn', 'testRRangeCast', 'testStringUtils', 'testTypeTraits']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ROOT_ADD_GTEST(testStatusBitsChecker testStatusBitsChecker.cxx LIBRARIES Core); ROOT_ADD_GTEST(testHashRecursiveRemove testHashRecursiveRemove.cxx LIBRARIES Core); ROOT_ADD_GTEST(testTClass testTClass.cxx LIBRARIES Core GenVector); ROOT_ADD_GTEST(testTDataType testTDataType.cxx LIBRARIES Core); ROOT_ADD_GTEST(testTEnum testTEnum.cxx LIBRARIES Core); configure_file(stlDictCheck.h . COPYONLY); configure_file(stlDictCheckAux.h . COPYONLY); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/test/CMakeLists.txt:210,test,testStatusBitsChecker,210,core/meta/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/test/CMakeLists.txt,10,['test'],"['testHashRecursiveRemove', 'testStatusBitsChecker', 'testTClass', 'testTDataType', 'testTEnum']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ROOT_ADD_GTEST(testTProfile2Poly test_tprofile2poly.cxx LIBRARIES Hist Matrix MathCore RIO); ROOT_ADD_GTEST(testTH2PolyBinError test_TH2Poly_BinError.cxx LIBRARIES Hist Matrix MathCore RIO); ROOT_ADD_GTEST(testTH2PolyAdd test_TH2Poly_Add.cxx LIBRARIES Hist Matrix MathCore RIO); ROOT_ADD_GTEST(testTH2PolyGetNumberOfBins test_TH2Poly_GetNumberOfBins.cxx LIBRARIES Hist Matrix MathCore RIO); ROOT_ADD_GTEST(testTHn THn.cxx LIBRARIES Hist Matrix MathCore RIO); ROOT_ADD_GTEST(testTH1 test_TH1.cxx LIBRARIES Hist); ROOT_ADD_GTEST(testTHStack test_THStack.cxx LIBRARIES Hist); ROOT_ADD_GTEST(testProject3Dname test_Project3D_name.cxx LIBRARIES Hist); ROOT_ADD_GTEST(testTFormula test_TFormula.cxx LIBRARIES Hist); ROOT_ADD_GTEST(testTKDE test_tkde.cxx LIBRARIES Hist); ROOT_ADD_GTEST(testTH1FindFirstBinAbove test_TH1_FindFirstBinAbove.cxx LIBRARIES Hist); ROOT_ADD_GTEST(test_TEfficiency test_TEfficiency.cxx LIBRARIES Hist); ROOT_ADD_GTEST(TGraphMultiErrorsTests TGraphMultiErrorsTests.cxx LIBRARIES Hist RIO); ROOT_ADD_GTEST(test_TF123_Moments test_TF123_Moments.cxx LIBRARIES Hist); ROOT_ADD_GTEST(test_THBinIterator test_THBinIterator.cxx LIBRARIES Hist); ROOT_ADD_GTEST(testTMultiGraphGetHistogram test_TMultiGraph_GetHistogram.cxx LIBRARIES Hist Gpad); ROOT_ADD_GTEST(testMapCppName test_MapCppName.cxx LIBRARIES Hist Gpad); ROOT_ADD_GTEST(testTGraphSorting test_TGraph_sorting.cxx LIBRARIES Hist); ROOT_ADD_GTEST(testSpline test_spline.cxx LIBRARIES Hist); ROOT_ADD_GTEST(testTF1Simple test_tf1_simple.cxx LIBRARIES Hist RIO). if(fftw3); ROOT_ADD_GTEST(testTF1 test_tf1.cxx LIBRARIES Hist); endif(). ROOT_ADD_GTEST(testTF2 test_tf2.cxx LIBRARIES Hist); ROOT_ADD_GTEST(testTF3 test_tf3.cxx LIBRARIES Hist). ROOT_ADD_GTEST(testTH1sa test_TH1_SaveAs.cxx LIBRARIES Hist). if(clad); ROOT_ADD_GTEST(TFormulaG",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/CMakeLists.txt:601,test,testTHn,601,hist/hist/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/CMakeLists.txt,4,['test'],"['testTFormula', 'testTHStack', 'testTHn', 'testTKDE']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ROOT_ADD_GTEST(testTaskArena testRTaskArena.cxx LIBRARIES Imt ${TBB_LIBRARIES} FAILREGEX """"); ROOT_ADD_GTEST(testTBBGlobalControl testTBBGlobalControl.cxx LIBRARIES Imt ${TBB_LIBRARIES}); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/test/CMakeLists.txt:210,test,testTaskArena,210,core/imt/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/test/CMakeLists.txt,4,['test'],"['testRTaskArena', 'testTBBGlobalControl', 'testTaskArena']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ROOT_ADD_UNITTEST_DIR(Core). ROOT_ADD_GTEST(testTypedIteration testTypedIteration.cxx LIBRARIES Core); ROOT_ADD_GTEST(TSeqTests TSeqTests.cxx LIBRARIES Core); ROOT_ADD_GTEST(testIter testIter.cxx LIBRARIES Core); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/test/CMakeLists.txt:239,test,testTypedIteration,239,core/cont/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/test/CMakeLists.txt,4,['test'],"['testIter', 'testTypedIteration']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ROOT_GENERATE_DICTIONARY(ElementStructDict ElementStruct.h LINKDEF ElementStructLinkDef.h OPTIONS -inlineInputHeader); ROOT_ADD_GTEST(testTOffsetGeneration TOffsetGeneration.cxx ElementStruct.cxx ElementStructDict.cxx; LIBRARIES RIO Tree MathCore; ); if(MSVC AND NOT CMAKE_GENERATOR MATCHES Ninja); add_custom_command(TARGET testTOffsetGeneration POST_BUILD; COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_BINARY_DIR}/libElementStructDict_rdict.pcm; ${CMAKE_CURRENT_BINARY_DIR}/$<CONFIG>/libElementStructDict_rdict.pcm); endif(); target_include_directories(testTOffsetGeneration PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}); ROOT_STANDARD_LIBRARY_PACKAGE(SillyStruct NO_INSTALL_HEADERS HEADERS ${CMAKE_CURRENT_SOURCE_DIR}/SillyStruct.h SOURCES SillyStruct.cxx LINKDEF SillyStructLinkDef.h DEPENDENCIES RIO); ROOT_ADD_GTEST(testBulkApi BulkApi.cxx LIBRARIES RIO Tree TreePlayer); #FIXME: tests are having timeout on 32bit CERN VM (in docker container everything is fine),; # to be reverted after investigation.; if(NOT CMAKE_SIZEOF_VOID_P EQUAL 4); ROOT_ADD_GTEST(testBulkApiMultiple BulkApiMultiple.cxx LIBRARIES RIO Tree TreePlayer TIMEOUT 3000); ROOT_ADD_GTEST(testBulkApiVarLength BulkApiVarLength.cxx LIBRARIES RIO Tree TreePlayer); ROOT_ADD_GTEST(testBulkApiSillyStruct BulkApiSillyStruct.cxx LIBRARIES RIO Tree TreePlayer SillyStruct); endif(); ROOT_ADD_GTEST(testTBasket TBasket.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(testTBranch TBranch.cxx LIBRARIES RIO Tree MathCore); ROOT_ADD_GTEST(testTIOFeatures TIOFeatures.cxx LIBRARIES RIO Tree); ROOT_ADD_GTEST(testTTreeCluster TTreeClusterTest.cxx LIBRARIES RIO Tree MathCore); ROOT_ADD_GTEST(testTChainParsing TChainParsing.cxx LIBRARIES RIO Tree); if(imt); ROOT_ADD_GTEST(testTTreeImplicitMT ImplicitMT.cxx LIBRARIES RIO Tree); endif(); ROOT_ADD_GTEST(testT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/CMakeLists.txt:329,test,testTOffsetGeneration,329,tree/tree/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/test/CMakeLists.txt,3,['test'],['testTOffsetGeneration']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. add_minuit2_test(Quad1F Quad1FMain.cxx Quad1F.h). add_minuit2_test(Quad4F Quad4FMain.cxx Quad4F.h). add_minuit2_test(Quad8F Quad8FMain.cxx Quad8F.h). add_minuit2_test(Quad12F Quad12FMain.cxx Quad12F.h). add_test(; NAME ExampleCMakeBuild; COMMAND ""${CMAKE_CTEST_COMMAND}""; --build-and-test; ""${Minuit2_SOURCE_DIR}/examples/simple/""; ""${CMAKE_CURRENT_BINARY_DIR}/simple/""; --build-generator ""${CMAKE_GENERATOR}""; --test-command ""${CMAKE_CTEST_COMMAND}""; ); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/MnTutorial/CMakeLists.txt:479,test,test,479,math/minuit2/test/MnTutorial/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/MnTutorial/CMakeLists.txt,2,['test'],"['test', 'test-command']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. add_subdirectory (geom) # special CMakeLists.txt; if(geombuilder); add_subdirectory (geombuilder) # special CMakeLists.txt; endif(); add_subdirectory (geompainter) # special CMakeLists.txt. if(gdml); add_subdirectory(gdml); if(NOT gnuinstall); install(DIRECTORY gdml/ DESTINATION geom/gdml; FILES_MATCHING PATTERN ""*.py""; PATTERN ""inc"" EXCLUDE; PATTERN ""src"" EXCLUDE); endif(); endif(). if(vecgeom); add_subdirectory(vecgeom); endif(). if(webgui); add_subdirectory(webviewer); endif(). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/CMakeLists.txt:708,test,test,708,geom/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. add_subdirectory(mathcore); if(mathmore); add_subdirectory(mathmore); endif(); add_subdirectory(matrix); add_subdirectory(minuit); add_subdirectory(minuit2); add_subdirectory(fumili); add_subdirectory(physics); add_subdirectory(mlp); add_subdirectory(quadp); add_subdirectory(foam); add_subdirectory(smatrix); add_subdirectory(splot); #add_subdirectory(mathcore/test EXCLUDE_FROM_ALL); add_subdirectory(genvector); if(tmva); add_subdirectory(genetic); endif(); if(unuran); add_subdirectory(unuran); endif(); if(fftw3); add_subdirectory(fftw); endif(). if(r); add_subdirectory(rtools); endif(). add_subdirectory(vecops); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/CMakeLists.txt:557,test,test,557,math/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. cmake_minimum_required(VERSION 3.10); # This is a test of the Minuit2 CMake build system. project(Quad1F LANGUAGES CXX). # CMake should be able to find the Minuit2 package if you have either built it or installed it; find_package(Minuit2 CONFIG REQUIRED). # Reusing the existing test file for simplicity; add_executable(Quad1F; ../../test/MnTutorial/Quad1FMain.cxx; ../../test/MnTutorial/Quad1F.h; ). # Linking with Minuit2::Minuit2 target; target_link_libraries(Quad1F PUBLIC Minuit2::Minuit2). # Run this executable as a test with make test; enable_testing(); add_test(NAME Quad1F COMMAND Quad1F); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/examples/simple/CMakeLists.txt:245,test,test,245,math/minuit2/examples/simple/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/examples/simple/CMakeLists.txt,6,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. find_package(ZLIB REQUIRED). target_sources(Core PRIVATE; src/Bits.c; src/ZDeflate.c; src/ZTrees.c; src/ZInflate.c; src/Compression.cxx; src/RZip.cxx; ). target_link_libraries(Core PRIVATE ZLIB::ZLIB). target_include_directories(Core PUBLIC; $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/inc>; ). ROOT_INSTALL_HEADERS(). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/CMakeLists.txt:543,test,test,543,core/zip/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. if (tbb OR builtin_tbb); ROOT_ADD_UNITTEST_DIR(Core Thread Hist ${TBB_LIBRARIES}); else(); ROOT_ADD_UNITTEST_DIR(Core Thread Hist); endif(). ROOT_ADD_GTEST(testTThreadedObject testTThreadedObject.cxx LIBRARIES Hist). if(NOT MSVC OR CMAKE_SIZEOF_VOID_P EQUAL 8); ROOT_ADD_GTEST(testInterpreterLock testInterpreterLock.cxx LIBRARIES Imt REPEATS 50); else(); ROOT_ADD_GTEST(testInterpreterLock testInterpreterLock.cxx LIBRARIES Imt REPEATS 40); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/test/CMakeLists.txt:351,test,testTThreadedObject,351,core/thread/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/test/CMakeLists.txt,6,['test'],"['testInterpreterLock', 'testTThreadedObject']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. if(NOT DEFINED ROOT_SOURCE_DIR); cmake_minimum_required(VERSION 3.10); project(genetic-tests); find_package(ROOT REQUIRED); include(${ROOT_USE_FILE}); endif(). set(Libraries Core RIO Net Hist Graf Graf3d Gpad Tree; Rint Postscript Matrix Physics MathCore Thread Genetic). set(TestGeneticSource; testGAMinimizer.cxx; GAMinTutorial.cxx). #---Build and add all the defined test in the list---------------; foreach(file ${TestGeneticSource}); get_filename_component(testname ${file} NAME_WE); ROOT_EXECUTABLE(${testname} ${file} LIBRARIES ${Libraries}); ROOT_ADD_TEST(genetic-${testname} COMMAND ${testname}); endforeach(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genetic/test/CMakeLists.txt:282,test,tests,282,math/genetic/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genetic/test/CMakeLists.txt,7,['test'],"['test', 'testGAMinimizer', 'testname', 'tests']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. if(NOT DEFINED ROOT_SOURCE_DIR); cmake_minimum_required(VERSION 3.10); project(minuit2_tests); find_package(ROOT REQUIRED); include(${ROOT_USE_FILE}); endif(). set(TestSource testMinimizer.cxx); if (clad); list(APPEND TestSource testADMinim.cxx); endif(). set(TestSourceMnTutorial; MnTutorial/Quad1FMain.cxx; MnTutorial/Quad4FMain.cxx; MnTutorial/Quad8FMain.cxx; MnTutorial/Quad12FMain.cxx; ). set(TestSourceMnSim; MnSim/DemoGaussSim.cxx; MnSim/DemoFumili.cxx; MnSim/PaulTest.cxx; MnSim/PaulTest2.cxx; MnSim/PaulTest3.cxx; MnSim/PaulTest4.cxx; MnSim/ReneTest.cxx; MnSim/ParallelTest.cxx; MnSim/demoMinimizer.cxx; ). set(ParallelTest_LABELS longtest). #---For the simple Minuit2 tests build and defined them---------------; foreach(file ${TestSourceMnTutorial}); get_filename_component(testname ${file} NAME_WE); ROOT_EXECUTABLE(${testname} ${file} LIBRARIES Minuit2); ROOT_ADD_TEST(minuit2_${testname} COMMAND ${testname}); endforeach(). ROOT_LINKER_LIBRARY(Minuit2TestMnSim MnSim/GaussDataGen.cxx MnSim/GaussFcn.cxx MnSim/GaussFcn2.cxx LIBRARIES Minuit2). #input text files; configure_file(MnSim/paul.txt paul.txt COPYONLY); configure_file(MnSim/paul2.txt paul2.txt COPYONLY); configure_file(MnSim/paul3.txt paul3.txt COPYONLY); configure_file(MnSim/paul4.txt paul4.txt COPYONLY). foreach(file ${TestSourceMnSim}); get_filename_component(testname ${file} NAME_WE); ROOT_EXECUTABLE(${testname} ${file} LIBRARIES Minuit2 Minuit2TestMnSim MathCore); ROOT_ADD_TEST(minuit2_${testname} COMMAND ${testname}); endforeach(). #for the global tests using ROOT libs (Minuit2 should be taken via the PluginManager). set(RootLibraries Core RIO Net Hist Graf Graf3d Gpad Tree; Rint Postscript Matrix Physics MathCore Thread). foreach(file ${TestSource}); get_filename_component(testname ${file} NAME_WE); ROOT_EXECUTABL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/CMakeLists.txt:370,test,testMinimizer,370,math/minuit2/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/CMakeLists.txt,7,['test'],"['testADMinim', 'testMinimizer', 'testname', 'tests']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. project(mathcore-tests). set(Libraries Core RIO Net Hist Graf Graf3d Gpad Tree Minuit2; Rint Postscript Matrix Physics MathCore Thread). set(TestSource; testMathRandom.cxx; testTMath.cxx; testBinarySearch.cxx; testSortOrder.cxx; stressGoFTest.cxx; stressTMath.cxx; stressTF1.cxx; testIntegration.cxx; testSampleQuantiles.cxx; kDTreeTest.cxx; testkdTreeBinning.cxx; newKDTreeTest.cxx; binarySearchTime.cxx; stdsort.cxx; testSpecFuncErf.cxx; testSpecFuncGamma.cxx; testSpecFuncBeta.cxx; testSpecFuncBetaI.cxx; testSpecFuncSiCi.cxx; testIntegrationMultiDim.cxx; testAnalyticalIntegrals.cxx; testTStatistic.cxx; fit/SparseDataComparer.cxx; fit/SparseFit3.cxx; fit/SparseFit4.cxx; fit/testBinnedFitExecPolicy.cxx; fit/testFit.cxx; fit/testGraphFit.cxx; fit/testLogLExecPolicy.cxx; fit/testMinim.cxx). if(mathmore); list(APPEND Libraries MathMore); endif(). if(r); add_definitions(-DROOT_HAS_R); list(APPEND Libraries RInterface); endif(). #---Build and add all the defined test in the list---------------; foreach(file ${TestSource}); get_filename_component(testname ${file} NAME_WE); ROOT_EXECUTABLE(${testname} ${file} LIBRARIES ${Libraries}); ROOT_ADD_TEST(mathcore-${testname} COMMAND ${testname} LABELS ${${testname}_LABELS}); endforeach(). ROOT_STANDARD_LIBRARY_PACKAGE(TrackMathCoreUnitDict; NO_INSTALL_HEADERS; NO_SOURCES; HEADERS ${CMAKE_CURRENT_SOURCE_DIR}/stress/TrackMathCore.h; LINKDEF stress/TrackMathCoreLinkDef.h; DEPENDENCIES Core MathCore RIO GenVector Smatrix). if(MSVC AND NOT CMAKE_GENERATOR MATCHES Ninja); add_custom_command(TARGET TrackMathCoreUnitDict POST_BUILD; COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_BINARY_DIR}/$<CONFIG>/libTrackMathCoreUnitDict.dll; ${CMAKE_CURRENT_BINARY_DIR}/libTrackMathCoreUnitDict.dll); endif(). ROOT_ADD_GTEST(stressMathCoreUnit stress/testSMatrix.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/CMakeLists.txt:212,test,tests,212,math/mathcore/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/CMakeLists.txt,21,['test'],"['testAnalyticalIntegrals', 'testBinarySearch', 'testBinnedFitExecPolicy', 'testFit', 'testGraphFit', 'testIntegration', 'testIntegrationMultiDim', 'testLogLExecPolicy', 'testMathRandom', 'testMinim', 'testSampleQuantiles', 'testSortOrder', 'testSpecFuncBeta', 'testSpecFuncBetaI', 'testSpecFuncErf', 'testSpecFuncGamma', 'testSpecFuncSiCi', 'testTMath', 'testTStatistic', 'testkdTreeBinning', 'tests']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. project(mathmore-tests). set(Libraries Core RIO Net Hist Graf Graf3d Gpad Tree; Rint Postscript Matrix Physics Thread MathCore MathMore). set(TestMathMoreSource; testChebyshev.cxx; testPermute.cxx; testDerivation.cxx; testGSLIntegration.cxx; testMCIntegration.cxx; testGSLRootFinder.cxx; testMultiRootFinder.cxx; testMinimization1D.cxx; testInterpolation.cxx; testRandom.cxx; testRandomDist.cxx; testQuasiRandom.cxx; testSpecFunc.cxx; testStatFunc.cxx; testFunctor.cxx; testVavilov.cxx; simanTSP.cxx). set(testFunctor_LABELS longtest); set(testPermute_LABELS longtest); set(testRandom_LABELS longtest); set(testMCIntegration_LABELS longtest). if(unuran); list(APPEND Libraries Unuran); add_definitions(-DHAVE_UNURAN); endif(). #some tests requires directly gsl; include_directories(${GSL_INCLUDE_DIR}); add_definitions(-DHAVE_ROOTLIBS). #---Build and add all the defined test in the list---------------; foreach(file ${TestMathMoreSource}); get_filename_component(testname ${file} NAME_WE); ROOT_EXECUTABLE(${testname} ${file} LIBRARIES ${GSL_LIBRARIES} ${Libraries}); ROOT_ADD_TEST(mathmore-${testname} COMMAND ${testname} LABELS ${${testname}_LABELS}); endforeach(). ROOT_ADD_GTEST(stressMathMoreUnit testStress.cxx StatFunction.cxx LIBRARIES Core MathCore MathMore); ROOT_ADD_GTEST(testPolynomialRoots testPolynomialRoots.cxx LIBRARIES Core MathCore MathMore); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/CMakeLists.txt:212,test,tests,212,math/mathmore/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/CMakeLists.txt,26,['test'],"['test', 'testChebyshev', 'testDerivation', 'testFunctor', 'testGSLIntegration', 'testGSLRootFinder', 'testInterpolation', 'testMCIntegration', 'testMultiRootFinder', 'testPermute', 'testPolynomialRoots', 'testQuasiRandom', 'testRandom', 'testRandomDist', 'testSpecFunc', 'testStatFunc', 'testStress', 'testVavilov', 'testname', 'tests']"
Testability,"# Copyright (C) 1995-2019, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. set(Libraries Core MathCore Minuit Unuran Gpad Hist). if(mathmore); list(APPEND Libraries MathMore); endif(). set(TestUnuranSource; unuranSimple.cxx; unuranHist.cxx; unuranDiscrete.cxx; unuranDistr.cxx; unuranMulti2D.cxx; unuranMultiDim.cxx; ). # Configure some tests as longtest; set(unuranMultiDim_LABELS longtest); set(unuranDiscrete_LABELS longtest). #---Build and add all the defined test in the list---------------; foreach(file ${TestUnuranSource}); get_filename_component(testname ${file} NAME_WE); ROOT_EXECUTABLE(${testname} ${file} LIBRARIES ${Libraries}); ROOT_ADD_TEST(unuran-${testname} COMMAND ${testname} LABELS ${${testname}_LABELS}); endforeach(). # google tests; ROOT_ADD_GTEST(testUnuranSampler unuranSampler.cxx LIBRARIES ${Libraries} ); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/CMakeLists.txt:457,test,tests,457,math/unuran/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/CMakeLists.txt,9,['test'],"['test', 'testUnuranSampler', 'testname', 'tests']"
Testability,"# Copyright (C) 1995-2021, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. # Don't bother testing the distributed layer of RDataFrame if it's not available; # in the build. Also don't test on windows; if (dataframe AND NOT MSVC). ROOT_ADD_PYUNITTEST(distrdf_unit_test_callable_generator test_callable_generator.py); ROOT_ADD_PYUNITTEST(distrdf_unit_test_friendinfo test_friendinfo.py); ROOT_ADD_PYUNITTEST(distrdf_unit_test_headnode test_headnode.py); ROOT_ADD_PYUNITTEST(distrdf_unit_test_init test_init.py); ROOT_ADD_PYUNITTEST(distrdf_unit_test_node test_node.py); ROOT_ADD_PYUNITTEST(distrdf_unit_test_operation test_operation.py); ROOT_ADD_PYUNITTEST(distrdf_unit_test_proxy test_proxy.py); ROOT_ADD_PYUNITTEST(distrdf_unit_test_ranges test_ranges.py). endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/CMakeLists.txt:210,test,testing,210,bindings/experimental/distrdf/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/CMakeLists.txt,2,['test'],"['test', 'testing']"
Testability,"# Copyright (C) 1995-2021, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. # Don't bother testing the distributed layer of RDataFrame if it's not available; # in the build; if (dataframe AND NOT MSVC). file(COPY test_headers DESTINATION ${CMAKE_CURRENT_BINARY_DIR}); file(COPY 2clusters.root DESTINATION ${CMAKE_CURRENT_BINARY_DIR}); file(COPY 4clusters.root DESTINATION ${CMAKE_CURRENT_BINARY_DIR}); file(COPY 1000clusters.root DESTINATION ${CMAKE_CURRENT_BINARY_DIR}); file(COPY Slimmed_ntuple.root DESTINATION ${CMAKE_CURRENT_BINARY_DIR}); file(COPY 1cluster_20entries.root DESTINATION ${CMAKE_CURRENT_BINARY_DIR}). ROOT_ADD_PYUNITTEST(distrdf_unit_backend_test_common test_common.py); ROOT_ADD_PYUNITTEST(distrdf_unit_backend_test_dist test_dist.py); ROOT_ADD_PYUNITTEST(distrdf_unit_backend_test_graph_caching test_graph_caching.py). endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/CMakeLists.txt:210,test,testing,210,bindings/experimental/distrdf/test/backend/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/test/backend/CMakeLists.txt,1,['test'],['testing']
Testability,"# Copyright (C) 1995-2021, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT gui/webdisplay package; ############################################################################. ROOT_STANDARD_LIBRARY_PACKAGE(ROOTWebDisplay; HEADERS; ROOT/RWebDisplayArgs.hxx; ROOT/RWebDisplayHandle.hxx; ROOT/RWebWindow.hxx; ROOT/RWebWindowsManager.hxx; SOURCES; RWebDisplayArgs.cxx; RWebDisplayHandle.cxx; RWebWindow.cxx; RWebWindowsManager.cxx; DEPENDENCIES; Core; RHTTP; Net; MathCore; ). ROOT_ADD_TEST_SUBDIRECTORY(test). if(qt5web); target_compile_definitions(ROOTWebDisplay PRIVATE -DWITH_QT5WEB); endif(). if(qt6web); target_compile_definitions(ROOTWebDisplay PRIVATE -DWITH_QT6WEB); endif(). if(cefweb); target_compile_definitions(ROOTWebDisplay PRIVATE -DWITH_CEFWEB); endif()",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/CMakeLists.txt:739,test,test,739,gui/webdisplay/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2021, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building TMVA SOFIE tests.; # @author Federico Sossai, Sanjiban Sengupta; ############################################################################. set(SOFIE_PARSERS_DIR ${CMAKE_SOURCE_DIR}/tmva/sofie_parsers). if (NOT ONNX_MODELS_DIR); set(ONNX_MODELS_DIR input_models); endif(). #Finding .onnx files to be parsed and creating the appropriate code to; # parse all file. It is much faster to combine all parsing in a single executable; # which will avoid initialization time (especially when using ROOT); set(CAPTURE_STR ""EmitModel( \""@1\"", \""@2\"");""); set(ALL_CAPTURES """"); # Finding .onnx files to be parsed and creating the appropriate command; file(GLOB ONNX_FILES ""${ONNX_MODELS_DIR}/*.onnx""); foreach(onnx_file ${ONNX_FILES}); 	get_filename_component(fname ${onnx_file} NAME_WE); 	get_filename_component(fdir ${onnx_file} DIRECTORY); string(REPLACE ""@1"" ${onnx_file} cap ${CAPTURE_STR}); string(REPLACE ""@2"" ${fname} cap ${cap}); list(APPEND ALL_CAPTURES ${cap}); endforeach(); string(REPLACE "";"" "";\n"" EMIT_CAPTURES ""${ALL_CAPTURES}""); configure_file(EmitFromONNX.cxx.in EmitFromONNX_all.cxx @ONLY); configure_file(EmitFromRoot.cxx.in EmitFromRoot_all.cxx @ONLY). add_executable(emitFromONNX; EmitFromONNX_all.cxx; ); target_include_directories(emitFromONNX PRIVATE; ${CMAKE_SOURCE_DIR}/tmva/sofie/inc; ${SOFIE_PARSERS_DIR}/inc; ${CMAKE_SOURCE_DIR}/tmva/inc; ${CMAKE_CURRENT_BINARY_DIR} # this is for the protobuf headerfile; ). target_link_libraries(emitFromONNX protobuf::libprotobuf ROOTTMVASofie ROOTTMVASofieParser); set_target_properties(emitFromONNX PROPERTIES POSITION_INDEPENDENT_CODE TRUE); ## silence protobuf warnings seen in version 3.0 and 3.6. Not needed from protobuf version",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/test/CMakeLists.txt:319,test,tests,319,tmva/sofie/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/test/CMakeLists.txt,1,['test'],['tests']
Testability,"# Copyright (C) 1995-2021, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for testing components from ROOT gui/webdisplay package; ############################################################################. # test only can be run if Firefox or Chrome are detected on the system; if (CHROME_EXECUTABLE OR FIREFOX_EXECUTABLE); ROOT_ADD_TEST(test-webgui-ping; RUN_SERIAL; COPY_TO_BUILDDIR ${CMAKE_SOURCE_DIR}/tutorials/webgui/ping/ping.cxx ${CMAKE_SOURCE_DIR}/tutorials/webgui/ping/ping.html; COMMAND root.exe -b -q -l ping.cxx; PASSREGEX ""PING-PONG TEST COMPLETED""; TIMEOUT 300); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/test/CMakeLists.txt:299,test,testing,299,gui/webdisplay/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/test/CMakeLists.txt,3,['test'],"['test', 'test-webgui-ping', 'testing']"
Testability,"# Copyright (C) 1995-2022, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. # CMakeLists.txt for the ROOT test programs.; # This shows nicely how to compile and link applications; # using the ROOT libraries on all supported platforms.; #; # Author: Pere Mato, 25/10/2010; cmake_minimum_required(VERSION 3.10 FATAL_ERROR). project(test). # Sergey: make no sence while CMakeLists.txt file cannot be used separately from ROOT; # but variables like ROOT_asimage_FOUND used here and produced in ROOTConfig.cmake; find_package(ROOT REQUIRED). #---Copy the CTestCustom.cmake file into the build directory---------------------------------; configure_file(${CMAKE_CURRENT_SOURCE_DIR}/CTestCustom.cmake ${CMAKE_CURRENT_BINARY_DIR} COPYONLY); enable_testing(). if(CMAKE_SYSTEM_NAME MATCHES Darwin); # To avoid to set ld_Library_path to locate the test libraries; set(CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS} -Wl,-rpath,@loader_path/.""); endif(). if(DEFINED ROOT_SOURCE_DIR); # Testing using the binary tree; set(ROOT_root_CMD ${ROOT_BINDIR}/root.exe); include_directories(${ROOT_SOURCE_DIR}/tutorials); else(); # Testing using an installation (assuming access to ROOT CMake modules); include_directories(${ROOT_INCLUDE_DIRS}); include_directories(${ROOT_INCLUDE_DIRS}/../tutorials); add_definitions(${ROOT_DEFINITIONS}); include(RootMacros); endif(). #---environment-------------------------------------------------------------------------------; ROOT_ADD_TEST(show-environment COMMAND ${CMAKE_COMMAND} -E environment). #---hworld------------------------------------------------------------------------------------; ROOT_EXECUTABLE(hworld hworld.cxx LIBRARIES Gpad). #---event-------------------------------------------------------------------------------------; ROOT_STANDARD_LIBRARY_PACKAGE(Event; NO_INSTALL_HEADERS; HEADERS ${CMAKE_CURRENT_SOURCE_DIR}/Event.h; SOURCES Event.cxx L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/CMakeLists.txt:225,test,test,225,test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/CMakeLists.txt,3,['test'],['test']
Testability,"# Copyright (C) 1995-2022, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT math/vecops package; ############################################################################. ROOT_STANDARD_LIBRARY_PACKAGE(ROOTVecOps; HEADERS; ROOT/RVec.hxx; SOURCES; src/RVec.cxx; DICTIONARY_OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; Core; ). if(builtin_vdt OR vdt); target_link_libraries(ROOTVecOps PUBLIC VDT::VDT); endif(); if(builtin_vdt); add_dependencies(ROOTVecOps VDT); endif(). include(CheckCXXSymbolExists); check_symbol_exists(m __sqrt_finite HAVE_FINITE_MATH); if(NOT HAVE_FINITE_MATH AND NOT MSVC); target_compile_options(ROOTVecOps PRIVATE -fno-finite-math-only); endif(). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/CMakeLists.txt:935,test,test,935,math/vecops/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2022, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT ntuple extra utils package; # @author Jakob Blomer CERN; ############################################################################. if(NOT root7); return(); endif(). ROOT_STANDARD_LIBRARY_PACKAGE(ROOTNTupleUtil; HEADERS; ROOT/RNTupleImporter.hxx; ROOT/RNTupleInspector.hxx; SOURCES; v7/src/RNTupleImporter.cxx; v7/src/RNTupleInspector.cxx; LINKDEF; LinkDef.h; DEPENDENCIES; ROOTNTuple; Tree; Hist; ). if(MSVC); target_compile_definitions(ROOTNTupleUtil PRIVATE _USE_MATH_DEFINES); endif(). ROOT_ADD_TEST_SUBDIRECTORY(v7/test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/CMakeLists.txt:836,test,test,836,tree/ntupleutil/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2022, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT readspeed package; # @author Bertrand Bellenot CERN; ############################################################################. ROOT_OBJECT_LIBRARY(ReadSpeed; src/ReadSpeed.cxx; src/ReadSpeedCLI.cxx; ). target_include_directories(ReadSpeed PRIVATE; ${CMAKE_SOURCE_DIR}/io/io/inc; ${CMAKE_SOURCE_DIR}/tree/tree/inc; ${CMAKE_SOURCE_DIR}/tree/treeplayer/inc; ${CMAKE_SOURCE_DIR}/core/imt/inc; ). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/CMakeLists.txt:736,test,test,736,tree/readspeed/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/CMakeLists.txt,1,['test'],['test']
Testability,"# Copyright (C) 1995-2023, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. # @author Danilo Piparo CERN. ROOT_EXECUTABLE(rotationApplication rotationApplication.cxx LIBRARIES GenVector); ROOT_ADD_TEST(test-genvector-rotationApplication COMMAND rotationApplication). ROOT_EXECUTABLE(boost testBoost.cxx LIBRARIES GenVector); ROOT_ADD_TEST(test-genvector-boost COMMAND boost). ROOT_EXECUTABLE(testGenvector testGenVector.cxx LIBRARIES GenVector Hist Smatrix); ROOT_ADD_TEST(test-genvector-genvector COMMAND testGenvector). ROOT_EXECUTABLE(testVectorIO testVectorIO.cxx LIBRARIES GenVector Tree Hist Gpad Physics); ROOT_ADD_TEST(test-genvector-vectorio COMMAND testVectorIO; COPY_TO_BUILDDIR ${CMAKE_CURRENT_SOURCE_DIR}/Track.h). ROOT_EXECUTABLE(coordinates3D coordinates3D.cxx LIBRARIES GenVector); ROOT_ADD_TEST(test-genvector-coordinates3D COMMAND coordinates3D). ROOT_EXECUTABLE(coordinates4D coordinates4D.cxx LIBRARIES GenVector); ROOT_ADD_TEST(test-genvector-coordinates4D COMMAND coordinates4D); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/test/CMakeLists.txt:321,test,test-genvector-rotationApplication,321,math/genvector/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/test/CMakeLists.txt,13,['test'],"['test-genvector-', 'test-genvector-boost', 'test-genvector-genvector', 'test-genvector-rotationApplication', 'test-genvector-vectorio', 'testBoost', 'testGenVector', 'testGenvector', 'testVectorIO']"
Testability,"# Copyright (C) 1995-2024, Rene Brun and Fons Rademakers.; # All rights reserved.; #; # For the licensing terms see $ROOTSYS/LICENSE.; # For the list of contributors see $ROOTSYS/README/CREDITS. ############################################################################; # CMakeLists.txt file for building ROOT graf2d/gpad package; # @author Pere Mato, CERN; ############################################################################. ROOT_STANDARD_LIBRARY_PACKAGE(Gpad; HEADERS; TAnnotation.h; TAttCanvas.h; TButton.h; TCanvas.h; TClassTree.h; TColorWheel.h; TControlBarButton.h; TControlBar.h; TCreatePrimitives.h; TDialogCanvas.h; TGroupButton.h; TInspectCanvas.h; TPad.h; TPadPainter.h; TPaveClass.h; TRatioPlot.h; TSliderBox.h; TSlider.h; TViewer3DPad.h; TView.h; SOURCES; src/TAnnotation.cxx; src/TAttCanvas.cxx; src/TButton.cxx; src/TCanvas.cxx; src/TClassTree.cxx; src/TColorWheel.cxx; src/TControlBarButton.cxx; src/TControlBar.cxx; src/TCreatePrimitives.cxx; src/TDialogCanvas.cxx; src/TGroupButton.cxx; src/TInspectCanvas.cxx; src/TPad.cxx; src/TPadPainter.cxx; src/TPaveClass.cxx; src/TRatioPlot.cxx; src/TSliderBox.cxx; src/TSlider.cxx; src/TView.cxx; src/TViewer3DPad.cxx; DICTIONARY_OPTIONS; -writeEmptyRootPCM; DEPENDENCIES; Graf; Hist; ). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/CMakeLists.txt:1287,test,test,1287,graf2d/gpad/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/CMakeLists.txt,1,['test'],['test']
Testability,"# Discourse Migration Guide . ## Current Status of Migration: Discourse is back online at a new URL: [https://discourse.llvm.org](https://discourse.llvm.org). The old one still works as well. We are aware of an issue with reply by email to emails from before the merge. We will update once we know more. This document is intended to help LLVM users to migrate from the mailing lists to; Discourse. Discourse has two basic ways for interaction: Via the [web; UI](https://llvm.discourse.group/) and via emails. ## Setting up your account. The easiest way is to create an account using your GitHub account:. 1. Navigate to https://llvm.discourse.group/; 1. Click on ""Sign Up"" in the top right corner.; 1. Choose ""With GitHub"" on the right side and log in with your GitHub account. ## Structure of Discourse. Discourse's structure is similar to a set of mailing lists, however different; terms are used there. To help with the transition, here's a translation table; for the terms:. <table border=1>; <tr><th>Mailing list</th><th>Discourse</th></tr>; <tr><td><i>Mailing list</i>, consists of threads</td><td><i>category</i>, consists of topics</td></tr>; <tr><td><i>thread</i>, consists of emails</td><td><i>topic</i>, consists of posts</td></tr>; <tr><td>email</td><td>post</td></tr>; </table>. ## Setting up email interactions. Some folks want to interact with Discourse purely via their email program. Here; are the typical use cases:. * You can [subscribe to a category or topic](https://discourse.mozilla.org/t/how-do-i-subscribe-to-categories-and-topics/16024); * You can reply to a post, including quoting other peoples texts; ([tested](https://llvm.discourse.group/t/email-interaction-with-discourse/3306/4) on GMail).; * [Quoting previous topics in an reply](https://meta.discourse.org/t/single-quote-block-dropped-in-email-reply/144802); * You can filter incoming emails in your email client by category using the; `List-ID` email header field.; * You can create topics through email using the e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md:745,log,log,745,interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md,1,['log'],['log']
Testability,"# Discover the projects that use CMake in the subdirectories.; # Note that explicit cmake invocation is required every time a new project is; # added or removed.; file(GLOB entries *); foreach(entry ${entries}); if(IS_DIRECTORY ${entry} AND EXISTS ${entry}/CMakeLists.txt); if((NOT ${entry} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR}/compiler-rt) AND; (NOT ${entry} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR}/dragonegg) AND; (NOT ${entry} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR}/libcxx) AND; (NOT ${entry} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR}/libcxxabi) AND; (NOT ${entry} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR}/libunwind) AND; (NOT ${entry} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR}/test-suite) AND; (NOT ${entry} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR}/openmp) AND; (NOT ${entry} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR}/cross-project-tests)); get_filename_component(entry_name ""${entry}"" NAME); add_llvm_external_project(${entry_name}); endif(); endif(); endforeach(entry). # Also add in libc++ and compiler-rt trees if present (and we have; # a sufficiently recent version of CMake where required).; if(${LLVM_BUILD_RUNTIME}); # MSVC isn't quite working with libc++ yet, disable it until issues are; # fixed.; # FIXME: LLVM_FORCE_BUILD_RUNTIME is currently used by libc++ to force; # enable the in-tree build when targeting clang-cl.; if(NOT MSVC OR LLVM_FORCE_BUILD_RUNTIME); # Add the projects in reverse order of their dependencies so that the; # dependent projects can see the target names of their dependencies.; add_llvm_external_project(libunwind); add_llvm_external_project(pstl); add_llvm_external_project(libc); add_llvm_external_project(libcxxabi); add_llvm_external_project(libcxx); endif(); if(NOT LLVM_BUILD_EXTERNAL_COMPILER_RT); add_llvm_external_project(compiler-rt); endif(); endif(). add_llvm_external_project(dragonegg); add_llvm_external_project(openmp). if(LLVM_INCLUDE_TESTS); add_llvm_external_project(cross-project-tests); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/projects/CMakeLists.txt:662,test,test-suite,662,interpreter/llvm-project/llvm/projects/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/projects/CMakeLists.txt,3,['test'],"['test-suite', 'tests']"
Testability,"# Do not build unittest libraries automatically, they will be pulled in; # by unittests if these are built.; if (NOT ${LLVM_INSTALL_GTEST}); set (BUILDTREE_ONLY BUILDTREE_ONLY); set(EXCLUDE_FROM_ALL ON); endif(). add_llvm_library(LLVMTestingSupport; Error.cpp; SupportHelpers.cpp. ${BUILDTREE_ONLY}. ADDITIONAL_HEADER_DIRS; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Testing/Support. LINK_COMPONENTS; Support; ). target_link_libraries(LLVMTestingSupport PRIVATE llvm_gtest). # This is to avoid the error in gtest-death-test-internal.h; # (150,16): error: 'Create' overrides a member function but; # is not marked 'override' [-Werror,-Wsuggest-override]; # during self-compile on Windows. if (HOST_WINNT AND ""${CMAKE_CXX_COMPILER_ID}"" MATCHES ""Clang"" ); SET(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -Wno-suggest-override""); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Testing/Support/CMakeLists.txt:506,test,test-internal,506,interpreter/llvm-project/llvm/lib/Testing/Support/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Testing/Support/CMakeLists.txt,1,['test'],['test-internal']
Testability,"# Don't include this target in LLVMExports. FIXME: is there a cleaner way?; set(EXCLUDE_FROM_ALL ON). # Not add_clang_library: this is not part of clang's public library interface.; # Unit tests should depend on this with target_link_libraries(), rather; # than with clang_target_link_libraries().; add_llvm_library(clangTesting; CommandLineArgs.cpp; TestAST.cpp. BUILDTREE_ONLY. LINK_COMPONENTS; MC; Support; ). clang_target_link_libraries(clangTesting; PRIVATE; clangAST; clangBasic; clangFrontend; clangLex; clangSerialization; ). target_link_libraries(clangTesting; PRIVATE; llvm_gtest; ); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/CMakeLists.txt:189,test,tests,189,interpreter/llvm-project/clang/lib/Testing/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Testing/CMakeLists.txt,1,['test'],['tests']
Testability,"# Input/Output; \index{I/O}. This chapter covers the saving and reading of objects to and from ROOT; files. It begins with an explanation of the physical layout of a ROOT; file. It includes a discussion on compression, and file recovery. Then; we explain the logical file, the class **`TFile`** and its methods. We; show how to navigate in a file, how to save objects and read them back.; We also include a discussion on `Streamers`. `Streamers` are the methods; responsible to capture an objects current state to save it to disk or; send it over the network. At the end of the chapter is a discussion on; the two specialized ROOT files: **`TNetFile`** and **`TWebFile`**. ## The Physical Layout of ROOT Files. A ROOT file is like a UNIX file directory. It can contain directories; and objects organized in unlimited number of levels. It also is stored; in machine independent format (ASCII, IEEE floating point, Big Endian; byte ordering). To look at the physical layout of a ROOT file, we first; create one. This example creates a ROOT file and 15 histograms, fills; each histogram with 1000 entries from a Gaussian distribution, and; writes them to the file. ``` {.cpp}; {; char name[10], title[20];; TObjArray Hlist(0); // create an array of Histograms; TH1F* h; // create a pointer to a histogram; // make and fill 15 histograms and add them to the object array; for (Int_t i = 0; i < 15; i++) {; sprintf(name,""h%d"",i);; sprintf(title,""histo nr:%d"",i);; h = new TH1F(name,title,100,-4,4);; Hlist.Add(h);; h->FillRandom(""gaus"",1000);; }; // open a file and write the array to the file; TFile f(""demo.root"",""recreate"");; Hlist.Write();; f.Close();; }; ```. The example begins with a call to the **`TFile`** constructor. This; class is describing the ROOT file (that has the extension ""`.root`""). In; the next section, we will cover **`TFile`** in details. The last line of; the example closes the file. To view its contents we need to open it; again, and to create a **`TBrowser`** object by:. ``` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:259,log,logical,259,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['log'],['logical']
Testability,"# Introduction. In the mid 1990's, René Brun and Fons Rademakers had many years of; experience developing interactive tools and simulation packages. They; had lead successful projects such as PAW, PIAF, and GEANT, and they; knew PAW the twenty-year-old FORTRAN libraries had reached their; limits. Although still very popular, these tools could not scale up to; the challenges offered by the Large Hadron Collider, where the data is; a few orders of magnitude larger than anything seen before. At the same time, computer science had made leaps of progress; especially in the area of Object Oriented Design, and René and Fons; were ready to take advantage of it. ROOT was developed in the context of the NA49 experiment at CERN. NA49; has generated an impressive amount of data, around 10 Terabytes per; run. This rate provided the ideal environment to develop and test the; next generation data analysis. ROOT was, and still is, developed in the ""Bazaar style"", a term from; the book ""The Cathedral and the Bazaar"" by Eric S. Raymond. It means a; liberal, informal development style that heavily relies on the diverse; and deep talent of the user community. The result is that physicists; developed ROOT for themselves; this made it specific, appropriate,; useful, and over time refined and very powerful. The development of; ROOT is a continuous conversation between users and developers with; the line between the two blurring at times and the users becoming; co-developers. When it comes to storing and mining large amount of data, physics; plows the way with its Terabytes, but other fields and industry follow; close behind as they acquiring more and more data over time. They are; ready to use the true and tested technologies physics has invented. In; this way, other fields and industries have found ROOT useful and they; have started to use it also. In the bazaar view, software is released early and frequently to; expose it to thousands of eager co-developers to pound on, report; bugs, and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:864,test,test,864,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['test'],['test']
Testability,"# Latency tests for RWebWindow. Provide round-trip test under different conditions.; To run, execute `root ""ping.cxx(10,0)""`, where first argument is number of connections tested and; second argument is running mode. Can be tested:; 0 - default communication, no extra threads; 1 - minimal timer for THttpServer, should reduce round-trip significantly; 2 - use special thread for process requests in THttpServer, web window also runs in the thread; 3 - in addition to special THttpThread also window starts own thread; 4 - let invoke webwindow callbacks in the civetweb threads, expert mode only. One also can perform same tests with longpoll emulation of web sockets, if adding 10 to second parameter. When running in batch mode, function blocked until 200 round-trip packets send by the client; or 50s elappsed. Therefore ping.cxx test can be used for RWebWindow functionality tests ; like `root -l -b ""ping.cxx(10,2)"" -q`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/Readme.md:10,test,tests,10,tutorials/webgui/ping/Readme.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/Readme.md,7,['test'],"['test', 'tested', 'tests']"
Testability,"# ROOT Basics #. Now that you have installed ROOT, what's this interactive shell thing; you're running ? It's like this: ROOT leads a double life. It has an; interpreter for macros (Cling [@Cling]) that you can run from the command; line or run like applications. But it is also an interactive shell that; can evaluate arbitrary statements and expressions. This is extremely; useful for debugging, quick hacking and testing. Let us first have a; look at some very simple examples. ## ROOT as calculator ##. You can even use the ROOT interactive shell in lieu of a calculator!; Launch the ROOT interactive shell with the command. ``` {.cpp}; > root; ```. on your Linux box. The prompt should appear shortly:. ``` {.cpp}; root [0]; ```. and let's dive in with the steps shown here:. ``` {.cpp}; root [0] 1+1; (int) 2; root [1] 2*(4+2)/12.; (double) 1.000000; root [2] sqrt(3.); (double) 1.732051; root [3] 1 > 2; (bool) false; root [4] TMath::Pi(); (double) 3.141593; root [5] TMath::Erf(.2); (double) 0.222703; ```. Not bad. You can see that ROOT offers you the possibility not only to; type in `C++` statements, but also advanced mathematical functions,; which live in the `TMath` namespace. Now let's do something more elaborated. A numerical example with the; well known geometrical series:. ``` {.cpp}; root [6] double x=.5; (double) 0.500000; root [7] int N=30; (int) 30; root [8] double geom_series=0; (double) 0.000000; root [9] for (int i=0;i<N;++i)geom_series+=TMath::Power(x,i); root [10] cout << TMath::Abs(geom_series - (1-TMath::Power(x,N-1))/(1-x)) <<endl;; 1.86265e-09; ```. Here we made a step forward. We even declared variables and used a *for*; control structure. Note that there are some subtle differences between; Cling and the standard `C++` language. You do not need the "";"" at the end; of line in interactive mode -- try the difference e.g. using the command; at line `root [6]`. ## Learn C++ at the ROOT prompt ##; Behind the ROOT prompt there is an interpreter based on a rea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:416,test,testing,416,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['test'],['testing']
Testability,"# ROOT Development Practice. ## Overview. The development of ROOT almost exclusively happens using the [pull request](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests); model of github. A pull request (PR) should contain a set focused changes; organized in one or more [atomic commits](https://en.wikipedia.org/wiki/Atomic_commit#Revision_control).; PRs should be well-documented and well-tested in order to allow other community; members to use, maintain and modify. If the PR contains performance-critical; code consider writing a benchmark against the [rootbench repository](https://github.com/root-project/rootbench). ## Quality Assurance. Each contribution should contain developer documentation in the form of code; comments and sufficient amount of tests in the form of unit and/or integration; tests. Unit tests are relatively small and quick programs focused to check if; small pieces of code and API work as expected. Integration tests are checks; which ensure the synergy between different (unit tested) components. Put in; practice, unit tests verify (member) function behavior whereas integration tests; check classes and their cooperation. The boundary between both kinds of testing; is blurred. ROOT has support for both kinds of tests in the [roottest repository](https://github.com/root-project/roottest); and supports ""inline"" unit tests in each component's `test` folder. Unit testing; uses the [GTest and GMock](https://github.com/google/googletest) infrastructure; along with small ROOT-specific extensions located in; [TestSupport](../core/test_support/). The documentation of GTest; and GMock is rather extensive and we will describe some of the features of; ROOT::TestSupport. In order to write an inline unit test, add a new file in the; nearest to the tested component's `test` folder and call `ROOT_ADD_GTEST` in the; `CMakeLists.txt` file. In many cases using standard GTest facility is sufficient to write a good test.; How",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/DEVELOPMENT.md:438,test,tested,438,README/DEVELOPMENT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/DEVELOPMENT.md,5,"['benchmark', 'test']","['benchmark', 'tested', 'tests']"
Testability,"# ROOT::TestSupport: the unit-test support library. This library supports ROOT's unit tests. It implements two main functions; 1. It provides a static library target `ROOT::TestSupport`. All google tests that are defined using `ROOT_ADD_GTEST` will be linked against this target.; When a test executable starts up, this will install a ROOT message handler that intercepts all messages / diagnostics.; If a message with severity > kInfo is issued, this message handler will register a test failure. This way, we are ensuring that no gtest can issue unnoticed warning or error messages.; 2. However, some warnings and errors are expected as the result of certain tests. Therefore, the library provides tools to declare when messages are expected during a test. For this,; 1. Include the header `ROOT/TestSupport.hxx`.; 2. Declare a RAII object that temporarily replaces the message handler from 1.; 3. Register the expected messages to this object, so it can check that they are indeed sent. This could look as follows:; ```c++; #include <ROOT/TestSupport.hxx>. // In a test function:; ROOT::TestSupport::CheckDiagsRAII checkDiag;; checkDiag.requiredDiag(kError, ""prepareMethod"", ""Can't compile function TFormula"", /*matchFullMessage=*/false);; checkDiag.requiredDiag(kError, ""TFormula::InputFormulaIntoCling"", ""Error compiling formula expression in Cling"", true);; // run test that generates the above errors; ```; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/README.md:30,test,test,30,core/testsupport/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/README.md,9,['test'],"['test', 'tests']"
Testability,"# See docs/CMake.html for instructions about how to build LLVM with CMake. cmake_minimum_required(VERSION 3.20.0). set(LLVM_COMMON_CMAKE_UTILS ${CMAKE_CURRENT_SOURCE_DIR}/../cmake); include(${LLVM_COMMON_CMAKE_UTILS}/Modules/CMakePolicy.cmake; NO_POLICY_SCOPE). # Builds with custom install names and installation rpath setups may not work; # in the build tree. Allow these cases to use CMake's default build tree; # behavior by setting `LLVM_NO_INSTALL_NAME_DIR_FOR_BUILD_TREE` to do this.; option(LLVM_NO_INSTALL_NAME_DIR_FOR_BUILD_TREE ""If set, use CMake's default build tree install name directory logic (Darwin only)"" OFF); mark_as_advanced(LLVM_NO_INSTALL_NAME_DIR_FOR_BUILD_TREE); if(NOT LLVM_NO_INSTALL_NAME_DIR_FOR_BUILD_TREE); set(CMAKE_BUILD_WITH_INSTALL_NAME_DIR ON); endif(). if(NOT DEFINED LLVM_VERSION_MAJOR); set(LLVM_VERSION_MAJOR 18); endif(); if(NOT DEFINED LLVM_VERSION_MINOR); set(LLVM_VERSION_MINOR 1); endif(); if(NOT DEFINED LLVM_VERSION_PATCH); set(LLVM_VERSION_PATCH 6); endif(); if(NOT DEFINED LLVM_VERSION_SUFFIX); set(LLVM_VERSION_SUFFIX); endif(). if (NOT PACKAGE_VERSION); set(PACKAGE_VERSION; ""${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}.${LLVM_VERSION_PATCH}${LLVM_VERSION_SUFFIX}""); endif(). if(NOT DEFINED LLVM_SHLIB_SYMBOL_VERSION); # ""Symbol version prefix for libLLVM.so""; set(LLVM_SHLIB_SYMBOL_VERSION ""LLVM_${LLVM_VERSION_MAJOR}.${LLVM_VERSION_MINOR}""); endif(). if ((CMAKE_GENERATOR MATCHES ""Visual Studio"") AND (MSVC_TOOLSET_VERSION LESS 142) AND (CMAKE_GENERATOR_TOOLSET STREQUAL """")); message(WARNING ""Visual Studio generators use the x86 host compiler by ""; ""default, even for 64-bit targets. This can result in linker ""; ""instability and out of memory errors. To use the 64-bit ""; ""host compiler, pass -Thost=x64 on the CMake command line.""); endif(). if (CMAKE_GENERATOR STREQUAL ""Xcode"" AND NOT CMAKE_OSX_ARCHITECTURES); # Some CMake features like object libraries get confused if you don't; # explicitly specify an architecture setting with the Xcode g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:602,log,logic,602,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['log'],['logic']
Testability,"# Support library for diagnostic handling in ROOT unit tests.; # This library is linked into all googletest executables. It installs; # a ROOT message handler that triggers test failures when diagnostics; # higher than kInfo are issued by tests.; # Stephan Hageboeck, CERN, 2022. if(NOT testsupport); return(); endif(). set(libname TestSupport); set(header_dir ROOT/). add_library(${libname} OBJECT src/TestSupport.cxx); target_include_directories(${libname} PUBLIC; $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/inc/>; $<INSTALL_INTERFACE:./>; ); target_link_libraries(${libname} PUBLIC Core gtest). # Installation of header and library:; set_target_properties(${libname} PROPERTIES PUBLIC_HEADER inc/${header_dir}/TestSupport.hxx); install(TARGETS ${libname}; EXPORT ${CMAKE_PROJECT_NAME}Exports; OBJECTS DESTINATION ${CMAKE_INSTALL_LIBDIR}/${libname}; PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/${header_dir}); set_property(GLOBAL APPEND PROPERTY ROOT_EXPORTED_TARGETS ${libname}). # Make it usable inside and outside of ROOT under a single name if somebody writes their own tests using ROOT_ADD_GTEST; add_library(ROOT::${libname} ALIAS ${libname}). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/CMakeLists.txt:55,test,tests,55,core/testsupport/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/CMakeLists.txt,5,['test'],"['test', 'tests', 'testsupport']"
Testability,"# Testing TFoam; # @author Stephan Hageboeck, CERN, 2020. ROOT_ADD_GTEST(testTFoam testTFoam.cxx; LIBRARIES Tree Foam; COPY_TO_BUILDDIR ${CMAKE_CURRENT_SOURCE_DIR}/testTFoam_1.root). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/test/CMakeLists.txt:73,test,testTFoam,73,math/foam/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/test/CMakeLists.txt,2,['test'],['testTFoam']
Testability,"# The Tutorials and Tests. This chapter is a guide to the examples that come with the installation; of ROOT. They are located in two directories: `$ROOTSYS/tutorials` and; `$ROOTSYS/test`. ## \$ROOTSYS/tutorials. ![](pictures/030001F9.png). The tutorials directory contains many example; scripts. *To have all examples working you must have write permission; and you will need to execute`hsimple.C` first*. If you do not have write; permission in the directory` $ROOTSYS/tutorials`, copy the entire; directory to your area. The script `hsimple.C` displays a histogram as; it is being filled, and creates a ROOT file used by the other examples. To execute it type:. ``` {.cpp}; $ cd $ROOTSYS/tutorials; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for macosx64 |; | From heads/v6-10-00-patches@v6-10-00-25-g9f78c3a, Jul 03 2017, 11:39:44 |; | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q' |; -------------------------------------------------------------------------. root [0] .x hsimple.C; ```. Now execute `demos.C`, which brings up the button bar shown on the left.; You can click on any button to execute another example. To see the; source, open the corresponding source file (for example `fit1.C`). Once; you are done, and want to quit the ROOT session, you can do so by typing; **`.q`**. ``` {.cpp}; root[] .x demos.C; root[] .q; ```. ## \$ROOTSYS/test. The test directory contains a set of examples that represent all areas; of the framework. When a new release is cut, the examples in this; directory are compiled and run to test the new release's backward; compatibility. We see these source files:. +-------------------+--------------------------------------------------------+; | `Makefile` | Makefile to build all test programs. |; +-------------------+--------------------------------------------------------+; | `hsimple.cxx` | Simple test progra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md:182,test,test,182,documentation/users-guide/TutorialsandTests.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/TutorialsandTests.md,1,['test'],['test']
Testability,"# The configured file is not placed in the correct location; # until the tests are run as we need to copy it into; # a copy of the tests folder; configure_lit_site_cfg(; ""${CMAKE_CURRENT_SOURCE_DIR}/tests/lit.site.cfg.in""; ""${CMAKE_CURRENT_BINARY_DIR}/lit.site.cfg""; ). # Lit's test suite creates output files next to the sources which makes the; # source tree dirty. This is undesirable because we do out of source builds.; # To work around this the tests and the configuration file are copied into the; # build directory just before running them. The tests are not copied over at; # configure time (i.e. `file(COPY ...)`) because this could lead to stale; # tests being run.; add_custom_target(prepare-check-lit; COMMAND ${CMAKE_COMMAND} -E remove_directory ""${CMAKE_CURRENT_BINARY_DIR}/tests""; COMMAND ${CMAKE_COMMAND} -E copy_directory ""${CMAKE_CURRENT_SOURCE_DIR}/tests"" ""${CMAKE_CURRENT_BINARY_DIR}/tests""; COMMAND ${CMAKE_COMMAND} -E copy ""${CMAKE_CURRENT_BINARY_DIR}/lit.site.cfg"" ""${CMAKE_CURRENT_BINARY_DIR}/tests""; COMMENT ""Preparing lit tests""; ). # Add rules for lit's own test suite; add_lit_testsuite(check-lit ""Running lit's tests""; ${CMAKE_CURRENT_BINARY_DIR}; DEPENDS ""FileCheck"" ""not"" ""prepare-check-lit""; ). # For IDEs; set_target_properties(check-lit PROPERTIES FOLDER ""Tests""); set_target_properties(prepare-check-lit PROPERTIES FOLDER ""Tests""); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/CMakeLists.txt:73,test,tests,73,interpreter/llvm-project/llvm/utils/lit/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/lit/CMakeLists.txt,14,['test'],"['test', 'tests']"
Testability,# This Pull request:. ## Changes or fixes:. ## Checklist:. - [ ] tested changes locally; - [ ] updated the docs (if necessary). This PR fixes # . ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/.github/pull_request_template.md:65,test,tested,65,.github/pull_request_template.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/.github/pull_request_template.md,1,['test'],['tested']
Testability,"# Write an XFAIL test for this `FIXME` in `AVRInstrInfo.td`. ```; // :FIXME: DAGCombiner produces an shl node after legalization from these seq:; // BR_JT -> (mul x, 2) -> (shl x, 1); ```. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/TODO.md:17,test,test,17,interpreter/llvm-project/llvm/lib/Target/AVR/TODO.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/TODO.md,1,['test'],['test']
Testability,"# copy next entry into memory and verify; nb = mychain.GetEntry(jentry); if nb<=0:; continue. # use the values directly from the tree; nEvent = int(mychain.ev); if nEvent<0:; continue. print(mychain.pz, '=', mychain.px*mychain.px, '+', mychain.py*mychain.py); ```. Access to arrays works the same way as access to single value tree; elements, where the size of the array is determined by the number of; values actually read from the file. For example:. ``` {.cpp}; # loop over array tree element; for d in mychain.mydoubles:; print(d). # direct access into an array tree element; i5 = mychain.myints[5]; ```. #### Writing a Tree. Writing a ROOT **`TTree`** in a Python session is a little convoluted,; if only because you will need a C++ class to make sure that data members; can be mapped, unless you are working with built-in types. Here is an; example for working with the latter only:. ``` {.cpp}; from ROOT import TFile, TTree; from array import array. h = TH1F('h1','test',100,-10.,10.); f = TFile('test.root','recreate'); t = TTree('t1','tree with histos'); maxn = 10; n = array('i',[0]); d = array('f',maxn*[0.]); t.Branch('mynum',n,'mynum/I'); t.Branch('myval',d,'myval[mynum]/F'). for i in range(25):; n[0] = min(i,maxn); for j in range(n[0]):; d[j] = i*0.1+j; t.Fill(). f.Write(); f.Close(); ```. The use of arrays is needed, because the pointer to the address of the; object that is used for filling must be given to the **`TTree::Branch()`**; call, even though the formal argument is declared a '`void*'`. In the; case of ROOT objects, similar pointer manipulation is unnecessary,; because the full type information is available, and `TTree::Branch()`; has been Pythonized to take care of the call details. However, data; members of such objects that are of built-in types, still require; something extra since they are normally translated to Python primitive; types on access and hence their address cannot be taken. For that; purpose, there is the `AddressOf()` function. As an example:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:30438,test,test,30438,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['test'],['test']
Testability,"# llvm-exegesis. `llvm-exegesis` is a benchmarking tool that accepts or assembles a snippet and; can measure characteristics of that snippet by executing it while keeping track; of performance counters. ### Currently Supported Platforms. `llvm-exegesis` is quite platform-dependent and currently only supports a couple; platform configurations for benchmarking. The limitations are listed below.; Analysis mode in `llvm-exegesis` is supported on all platforms on which LLVM is. #### Currently Supported Operating Systems for Benchmarking. Currently, `llvm-exegesis` only supports benchmarking on Linux. This is mainly; due to a dependency on the Linux perf subsystem for reading performance; counters. The subprocess execution mode and memory annotations currently only supports; Linux due to a heavy reliance on many Linux specific syscalls/syscall; implementations. #### Currently Supported Architectures for Benchmarking. Currently, using `llvm-exegesis` for benchmarking is supported on the following; architectures:; * x86; * 64-bit only due to this being the only implemented calling convention; in `llvm-exegesis` currently.; * ARM; * AArch64 only; * MIPS; * PowerPC (PowerPC64LE only). Note that not benchmarking functionality is guaranteed to work on all platforms. Memory annotations are currently only supported on 64-bit X86. There is no; inherent limitations for porting memory annotations to other architectures, but; parts of the test harness are implemented as MCJITed assembly that is generated; in `./lib/X86/Target.cpp` that would need to be implemented on other architectures; to bring up support.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/README.md:38,benchmark,benchmarking,38,interpreter/llvm-project/llvm/tools/llvm-exegesis/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/README.md,6,"['benchmark', 'test']","['benchmarking', 'test']"
Testability,"# rootreadspeed. `rootreadspeed` is a tool used to help identify bottlenecks in root analysis programs; by providing an idea of what throughput you can expect when reading ROOT files in; certain configurations. It does this by providing information about the number of bytes read from your files,; how long this takes, and the different throughputs in MB/s, both in total and per thread. ## Compressed vs Uncompressed Throughput:. Throughput speeds are provided as compressed and uncompressed - ROOT files are usually; saved in compressed format, so these will often differ. Compressed bytes is the total; number of bytes read from TFiles during the readspeed test (possibly including meta-data).; Uncompressed bytes is the number of bytes processed by reading the branch values in the TTree.; Throughput is calculated as the total number of bytes over the total runtime (including; decompression time) in the uncompressed and compressed cases. ## Interpreting results:. ### There are three possible scenarios when using rootreadspeed, namely:. - The 'Real Time' is significantly lower than your own analysis runtime.; This would imply your actual application code is dominating the runtime of your analysis,; ie. your analysis logic or framework is taking up the time.; The best way to decrease the runtime would be to optimize your code (or the framework's),; parallelize it onto multiple threads if possible (for example with; [RDataFrame](https://root.cern/doc/master/classROOT_1_1RDataFrame.html); and [EnableImplicitMT](https://root.cern/doc/master/namespaceROOT.html#a06f2b8b216b615e5abbc872c9feff40f)); or switch to a machine with a more performant CPU.; - The 'Real Time' is significantly higher than 'CPU Time / number of threads'*.; If the real time is higher than the CPU time per core it implies the reading of data is the; bottleneck, as the CPU cores are wasting time waiting for data to arrive from your disk/drive; or network connection in order to decompress it.; The best way to dec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/README.md:660,test,test,660,tree/readspeed/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/README.md,1,['test'],['test']
Testability,"## Introduction to TableGen Part 1: Classes, Defs, Basic Types and Let. **Note:** The content in this notebook is adapted from [this document](https://llvm.org/docs/TableGen/index.html). Refer to it if you want more details. This tutorial will cover:; * Classes; * Defs; * Basic types; * `let` in various forms; * Class template arguments. ## What is TableGen?. TableGen is a language used in LLVM to automate the generation of certain types of code. Usually repetitive code that has a common structure. TableGen is used to generate ""records"" that are then processed by a ""backend"" into domain specific code. The compiler for TableGen is the binary `llvm-tblgen`. This contains the logic to convert TableGen source into records that can then be passed to a TableGen backend. TableGen allows you to define Classes and Defs (which are instances of classes) but it doesn't encode what to do with that structure. That's what the backend does. The backend converts this structure into something useful, for example C++ code. These backends are included in the `llvm-tblgen` binary and you can choose which one to run using a command line option. If you don't choose a backend you get a dump of the structure, and that is what this notebook will be showing. This tutorial will focus on the language itself only. The only thing you need to know now is that in addition to `llvm-tblgen` you will see other `*-tblgen` like `clang-tblgen`. The difference between them is the backends they include. The default output from `llvm-tblgen` looks like this:. ```tablegen; %config cellreset on. // Empty source file; ```. ------------- Classes -----------------; ------------- Defs -----------------. **Note:** `%config` is not a TableGen command but a ""magic"" command to the Jupyter kernel for this notebook. By default new cells include the content of previously run cells, but for this notebook we mostly want each to be isolated. On occasion we will use the `%noreset` magic to override this. No source means no c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md:682,log,logic,682,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,1,['log'],['logic']
Testability,"## Tree Libraries. ### TTreePlayer and TSelectorDraw. - The option `colz` in a command like `nt->Draw(""b:a:c>>h"", """", ""colz"");`; erased the histogram `h`. (Jira report ROOT-4508).; - Make sure the number of bins for 2D histograms generated when drawing; 3 variables with option COL is the same as drawing 2 variables.; - In case of a 2D scatter plot drawing (with or without option COL) the automatically; computed lower limits of the histogram's axis might be 0. In that case it is better to set them; to the minimum of the data set (if it is >0) to avoid data cut when plotting in log scale. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v602/index.md:583,log,log,583,tree/doc/v602/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v602/index.md,1,['log'],['log']
Testability,"## Tree Libraries. ### TTreeReader. ROOT offers a new class `TTreeReader` that gives simple, safe and fast access to the content of a `TTree`.; Using it is trivial:. ``` {.cpp}; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"". void hsimpleReader() {; TH1F *myHist = new TH1F(""h1"",""ntuple"",100,-4,4);; TFile *myFile = TFile::Open(""hsimple.root"");. // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);. // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");. // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }. myHist->Draw();; }; ```. TTreeReader checks whether the type that you expect can be extracted from the tree's branch and will clearly complain if not.; It reads on demand: only data that are actually needed are read, there is no need for `SetBranchStatus()`, `SetBranchAddress()`, `LoadTree()` or anything alike.; It uses the memory management of TTree, removing possible double deletions or memory leaks and relieveing you from the need to manage the memory yourself.; It turns on the tree cache, accelerating the reading of data.; It has been extensively tested on all known types of TTree branches and is thus a generic, fits-all access method for data stored in TTrees. ### TTreePlayer. - The TEntryList for ||-Coord plot was not defined correctly. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v600/index.md:1540,test,tested,1540,tree/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v600/index.md,1,['test'],['tested']
Testability,"### Compilation. CMake allows to cross compile to a different target via toolchain files. More; information can be found here:. - [https://llvm.org/docs/lnt/tests.html#cross-compiling](https://llvm.org/docs/lnt/tests.html#cross-compiling). - [https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html](https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html). Cross compilation from macOS to iOS is possible with the; `test-suite/cmake/caches/target-target-*-iphoneos-internal.cmake` CMake cache; files; this requires an internal iOS SDK. ### Running. There are two ways to run the tests in a cross compilation setting:. - Via SSH connection to an external device: The `TEST_SUITE_REMOTE_HOST` option; should be set to the SSH hostname. The executables and data files need to be; transferred to the device after compilation. This is typically done via the; `rsync` make target. After this, the lit runner can be used on the host; machine. It will prefix the benchmark and verification command lines with an; `ssh` command. Example:. ```bash; % cmake -G Ninja -D CMAKE_C_COMPILER=path/to/clang \; -C ../test-suite/cmake/caches/target-arm64-iphoneos-internal.cmake \; -D CMAKE_BUILD_TYPE=Release \; -D TEST_SUITE_REMOTE_HOST=mydevice \; ../test-suite; % ninja; % ninja rsync; % llvm-lit -j1 -o result.json .; ```. - You can specify a simulator for the target machine with the; `TEST_SUITE_RUN_UNDER` setting. The lit runner will prefix all benchmark; invocations with it. Running the test-suite via LNT; ------------------------------. The LNT tool can run the test-suite. Use this when submitting test results to; an LNT instance. See; [https://llvm.org/docs/lnt/tests.html#llvm-cmake-test-suite](https://llvm.org/docs/lnt/tests.html#llvm-cmake-test-suite); for details. Running the test-suite via Makefiles (deprecated); -------------------------------------------------. **Note**: The test-suite comes with a set of Makefiles that are considered; deprecated. They do not support ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:11930,benchmark,benchmark,11930,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['benchmark'],['benchmark']
Testability,"############################################################################; # CMakeLists.txt file for building ROOT RooFitMultiProcess package; # @author Patrick Bos, Netherlands eScience Center; ############################################################################. ROOT_LINKER_LIBRARY(RooFitMultiProcess; src/worker.cxx; src/Messenger.cxx; src/ProcessManager.cxx; src/util.cxx; src/Queue.cxx; src/FIFOQueue.cxx; src/PriorityQueue.cxx; src/JobManager.cxx; src/Job.cxx; src/Config.cxx; src/ProcessTimer.cxx; src/HeatmapAnalyzer.cxx; LIBRARIES; Core; DEPENDENCIES; RooFitZMQ; ). target_link_libraries(RooFitMultiProcess PUBLIC Hist RooFitZMQ); set(RooFitMultiProcess_INCLUDE_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/res""); target_include_directories(RooFitMultiProcess; PRIVATE ${RooFitMultiProcess_INCLUDE_DIR}; INTERFACE $<BUILD_INTERFACE:${RooFitMultiProcess_INCLUDE_DIR}>). if(builtin_nlohmannjson); target_include_directories(RooFitMultiProcess PRIVATE ${CMAKE_SOURCE_DIR}/builtins); else(); target_link_libraries(RooFitMultiProcess PRIVATE nlohmann_json::nlohmann_json); endif(). ROOT_ADD_TEST_SUBDIRECTORY(test). ROOT_INSTALL_HEADERS(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/CMakeLists.txt:1113,test,test,1113,roofit/multiprocess/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/CMakeLists.txt,1,['test'],['test']
Testability,"############################################################################; # CMakeLists.txt file for building ROOT roofitcore/ZMQ package; # @author Patrick Bos, Netherlands eScience Center; ############################################################################. ROOT_LINKER_LIBRARY(RooFitZMQ; src/ZeroMQSvc.cpp; src/ZeroMQPoller.cpp; src/functions.cpp; src/ppoll.cpp; ). target_link_libraries(RooFitZMQ PUBLIC libzmq cppzmq); set(RooFitZMQ_INCLUDE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/res); target_include_directories(RooFitZMQ; PRIVATE ${RooFitZMQ_INCLUDE_DIR}; INTERFACE $<BUILD_INTERFACE:${RooFitZMQ_INCLUDE_DIR}>). # zmq_ppoll is still in the draft API, and RooFitZMQ relies on it; target_compile_definitions(RooFitZMQ PUBLIC ZMQ_BUILD_DRAFT_API); # to avoid leaking symbols; target_compile_definitions(RooFitZMQ PUBLIC ZMQ_NO_EXPORT). ROOT_ADD_TEST_SUBDIRECTORY(test); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/CMakeLists.txt:872,test,test,872,roofit/roofitZMQ/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/CMakeLists.txt,1,['test'],['test']
Testability,############################################################################; # CMakeLists.txt file for building TMVA/DNN/GRU tests.; # @author Surya S Dwivedi; ############################################################################. set(Libraries TMVA). #--- CUDA tests. ---------------------------; if (tmva-gpu AND tmva-cudnn). list(APPEND Libraries CUDA::cuda_driver CUDA::cudart). set(DNN_CUDA_LIBRARIES ${CUDA_CUBLAS_LIBRARIES} ). add_executable(testGRUBackpropagationCudnn TestGRUBackpropagationCudnn.cxx); target_link_libraries(testGRUBackpropagationCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-GRU-BackpropagationCudnn COMMAND testGRUBackpropagationCudnn). add_executable(testGRUForwardPassCudnn TestGRUForwardPassCudnn.cxx); target_link_libraries(testGRUForwardPassCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-GRU-Forwaed-Cudnn COMMAND testGRUForwardPassCudnn). # GRU - Full Test GPU; add_executable(testFullGRUCudnn TestFullGRUCudnn.cxx); target_link_libraries(testFullGRUCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-GRU-Full-Cudnn COMMAND testFullGRUCudnn). endif (tmva-gpu AND tmva-cudnn). #--- CPU tests. ----------------------------; if (BLAS_FOUND AND imt). # GRU - Forward CPU; ROOT_EXECUTABLE(testGRUForwardPassCpu TestGRUForwardPassCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-GRU-Forward-Cpu COMMAND testGRUForwardPassCpu). # GRU - Backward CPU; ROOT_EXECUTABLE(testGRUBackpropagationCpu TestGRUBackpropagationCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-GRU-Backward-Cpu COMMAND testGRUBackpropagationCpu). # GRU - Full Test CPU; ROOT_EXECUTABLE(testFullGRUCpu TestFullGRUCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-GRU-Full-Cpu COMMAND testFullGRUCpu). endif (BLAS_FOUND AND imt); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/CMakeLists.txt:126,test,tests,126,tmva/tmva/test/DNN/GRU/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/GRU/CMakeLists.txt,18,['test'],"['testFullGRUCpu', 'testFullGRUCudnn', 'testGRUBackpropagationCpu', 'testGRUBackpropagationCudnn', 'testGRUForwardPassCpu', 'testGRUForwardPassCudnn', 'tests']"
Testability,############################################################################; # CMakeLists.txt file for building TMVA/DNN/LSTM tests.; # @author Surya S Dwivedi; ############################################################################. set(Libraries TMVA). # LSTM - Forward Reference; #ROOT_EXECUTABLE(testLSTMForwardPass TestLSTMForwardPass.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-LSTM-Forward COMMAND testLSTMForwardPass). # LSTM - Backpropagation Reference; #ROOT_EXECUTABLE(testLSTMBackpropagation TestLSTMBackpropagation.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-LSTM-Backpropagation COMMAND testLSTMBackpropagation). # LSTM - Full Test Reference; #ROOT_EXECUTABLE(testFullLSTM TestFullLSTM.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-LSTM-FullLSTM COMMAND testFullLSTM). #--- CUDA tests. ---------------------------; if (tmva-gpu AND tmva-cudnn); list(APPEND Libraries CUDA::cuda_driver CUDA::cudart). set(DNN_CUDA_LIBRARIES ${CUDA_CUBLAS_LIBRARIES} ). add_executable(testLSTMForwardPassCudnn TestLSTMForwardPassCudnn.cxx); target_link_libraries(testLSTMForwardPassCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-LSTM-Forwaed-Cudnn COMMAND testLSTMForwardPassCudnn). add_executable(testLSTMBackpropagationCudnn TestLSTMBackpropagationCudnn.cxx); target_link_libraries(testLSTMBackpropagationCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-LSTM-BackpropagationCudnn COMMAND testLSTMBackpropagationCudnn); # Test crashes on ubuntu2404-cuda-12.6.1. See root-project/root#16790:; set_tests_properties(TMVA-DNN-LSTM-BackpropagationCudnn PROPERTIES DISABLED True). # LSTM - Full Test GPU; add_executable(testFullLSTMCudnn TestFullLSTMCudnn.cxx); target_link_libraries(testFullLSTMCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-LSTM-Full-Cudnn COMMAND testFullLSTMCudnn). endif (tmva-gpu AND tmva-cudnn). #--- CPU tests. ----------------------------; if (BLAS_FOUND AND imt). # LSTM - Forward CPU; ROOT_EXECUTA,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/CMakeLists.txt:127,test,tests,127,tmva/tmva/test/DNN/LSTM/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/CMakeLists.txt,8,['test'],"['testFullLSTM', 'testLSTMBackpropagation', 'testLSTMForwardPass', 'tests']"
Testability,#######################################################; # CMakeLists.txt file for building TMVA/DNN tests.; # @author Simon Pfreundschuh; ############################################################################. set(Libraries TMVA). #--- CUDA tests. ---------------------------; if (tmva-gpu). include_directories(${CUDA_INCLUDE_DIRS}). SET(DNN_CUDA_LIBRARIES ${CUDA_CUBLAS_LIBRARIES} ). list(APPEND Libraries ${DNN_CUDA_LIBRARIES} CUDA::cuda_driver CUDA::cudart). # DNN - Activation Functions Cuda; add_executable(testActivationFunctionsCuda TestActivationFunctionsCuda.cxx); TARGET_LINK_LIBRARIES(testActivationFunctionsCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-ActivationFunctionsCuda COMMAND testActivationFunctionsCuda). # DNN - Loss Functions Cuda; add_executable(testLossFunctionsCuda TestLossFunctionsCuda.cxx); TARGET_LINK_LIBRARIES(testLossFunctionsCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-LossFunctionsCuda COMMAND testLossFunctionsCuda). # DNN - Derivatives Cuda; add_executable(testDerivativesCuda TestDerivativesCuda.cxx); TARGET_LINK_LIBRARIES(testDerivativesCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-DerivativesCuda COMMAND testDerivativesCuda). # DNN - Backpropagation Cuda; add_executable(testBackpropagationCuda TestBackpropagationCuda.cxx); TARGET_LINK_LIBRARIES(testBackpropagationCuda ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-BackpropagationCuda COMMAND testBackpropagationCuda). # DNN - Backpropagation DL Cuda; add_executable(testBackpropagationDLCuda TestBackpropagationDLCuda.cxx ); TARGET_LINK_LIBRARIES(testBackpropagationDLCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-Backpropagation-DLCuda COMMAND testBackpropagationDLCuda). # DNN - Batch normalization Cuda; add_executable(testBatchNormalizationCuda TestBatchNormalizationCuda.cxx ); TARGET_LINK_LIBRARIES(testBatchNormalizationCuda ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-BatchNormalization-Cuda COMMAND testBatchNormalizationCuda). # DNN - Minimization Cuda; add_executable(testMinimizationCuda TestMinimizatio,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt:1217,test,testDerivativesCuda,1217,tmva/tmva/test/DNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt,1,['test'],['testDerivativesCuda']
Testability,"######################################################. set(py_sources; DistRDF/__init__.py; DistRDF/_graph_cache.py; DistRDF/ComputationGraphGenerator.py; DistRDF/DataFrame.py; DistRDF/HeadNode.py; DistRDF/Node.py; DistRDF/Operation.py; DistRDF/Proxy.py; DistRDF/PythonMergeables.py; DistRDF/Ranges.py; DistRDF/Backends/__init__.py; DistRDF/Backends/Base.py; DistRDF/Backends/Utils.py; DistRDF/Backends/Spark/__init__.py; DistRDF/Backends/Spark/Backend.py; DistRDF/Backends/Dask/__init__.py; DistRDF/Backends/Dask/Backend.py; DistRDF/LiveVisualize.py; ). # Add custom rules to copy the Python sources into the build directory; foreach(py_source ${py_sources}); add_custom_command(; OUTPUT ${localruntimedir}/${py_source}; COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/python/${py_source}; ${localruntimedir}/${py_source}; DEPENDS python/${py_source}; COMMENT ""Copying ${CMAKE_CURRENT_SOURCE_DIR}/python/${py_source}""); list(APPEND py_sources_in_localruntimedir ${localruntimedir}/${py_source}); endforeach(). # A custom target that depends on the Python sources being present in the build; # directory. This will be used as a dependency of the pythonization libraries,; # such that the Python sources get re-copied to the build directory when; # changed.; add_custom_target(DistRDF ALL DEPENDS ${py_sources_in_localruntimedir}). # Compile .py files; # We include DistRDF in the build only if Python 3.8+ is used,; # so we can directly use the main Python executable to compile the sources; foreach(py_source ${py_sources}); install(CODE ""execute_process(COMMAND ${Python3_EXECUTABLE} -m py_compile ${localruntimedir}/${py_source})""); install(CODE ""execute_process(COMMAND ${Python3_EXECUTABLE} -O -m py_compile ${localruntimedir}/${py_source})""); endforeach(). # Install Python sources and bytecode; install(DIRECTORY ${localruntimedir}/DistRDF; DESTINATION ${CMAKE_INSTALL_PYTHONDIR}; COMPONENT libraries). ROOT_ADD_TEST_SUBDIRECTORY(test); ROOT_ADD_TEST_SUBDIRECTORY(test/backend); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/CMakeLists.txt:2256,test,test,2256,bindings/experimental/distrdf/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/experimental/distrdf/CMakeLists.txt,2,['test'],['test']
Testability,###################################################. project(pymva-tests). set(Libraries Core MathCore TMVA PyMVA ROOTTMVASofie). # Look for needed python modules; find_python_module(torch QUIET); find_python_module(keras QUIET); find_python_module(theano QUIET); find_python_module(tensorflow QUIET); find_python_module(sklearn QUIET). if(PY_SKLEARN_FOUND); # Test PyRandomForest: Classification; ROOT_EXECUTABLE(testPyRandomForestClassification testPyRandomForestClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-RandomForest-Classification COMMAND testPyRandomForestClassification). # Test PyRandomForest: Multi-class classification; ROOT_EXECUTABLE(testPyRandomForestMulticlass testPyRandomForestMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-RandomForest-Multiclass COMMAND testPyRandomForestMulticlass). # Test PyGTB: Classification; ROOT_EXECUTABLE(testPyGTBClassification testPyGTBClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-GTB-Classification COMMAND testPyGTBClassification DEPENDS PyMVA-RandomForest-Classification). # Test PyGTB: Multi-class classification; ROOT_EXECUTABLE(testPyGTBMulticlass testPyGTBMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-GTB-Multiclass COMMAND testPyGTBMulticlass DEPENDS PyMVA-RandomForest-Multiclass). # Test PyAdaBoost: Classification; ROOT_EXECUTABLE(testPyAdaBoostClassification testPyAdaBoostClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-AdaBoost-Classification COMMAND testPyAdaBoostClassification DEPENDS PyMVA-GTB-Classification). # Test PyAdaBoost: Multi-class classification; ROOT_EXECUTABLE(testPyAdaBoostMulticlass testPyAdaBoostMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-AdaBoost-Multiclass COMMAND testPyAdaBoostMulticlass DEPENDS PyMVA-GTB-Multiclass). endif(PY_SKLEARN_FOUND). # Enable tests based on available python modules; if(PY_TORCH_FOUND); configure_file(generatePyTorchModelClassification.py generatePyTorchModelClassification.py COPYONLY); conf,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt:1375,test,testPyGTBClassification,1375,tmva/pymva/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt,1,['test'],['testPyGTBClassification']
Testability,################################################; # CMakeLists.txt file for building TMVA/DNN/LSTM tests.; # @author Surya S Dwivedi; ############################################################################. set(Libraries TMVA). # LSTM - Forward Reference; #ROOT_EXECUTABLE(testLSTMForwardPass TestLSTMForwardPass.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-LSTM-Forward COMMAND testLSTMForwardPass). # LSTM - Backpropagation Reference; #ROOT_EXECUTABLE(testLSTMBackpropagation TestLSTMBackpropagation.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-LSTM-Backpropagation COMMAND testLSTMBackpropagation). # LSTM - Full Test Reference; #ROOT_EXECUTABLE(testFullLSTM TestFullLSTM.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-LSTM-FullLSTM COMMAND testFullLSTM). #--- CUDA tests. ---------------------------; if (tmva-gpu AND tmva-cudnn); list(APPEND Libraries CUDA::cuda_driver CUDA::cudart). set(DNN_CUDA_LIBRARIES ${CUDA_CUBLAS_LIBRARIES} ). add_executable(testLSTMForwardPassCudnn TestLSTMForwardPassCudnn.cxx); target_link_libraries(testLSTMForwardPassCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-LSTM-Forwaed-Cudnn COMMAND testLSTMForwardPassCudnn). add_executable(testLSTMBackpropagationCudnn TestLSTMBackpropagationCudnn.cxx); target_link_libraries(testLSTMBackpropagationCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-LSTM-BackpropagationCudnn COMMAND testLSTMBackpropagationCudnn); # Test crashes on ubuntu2404-cuda-12.6.1. See root-project/root#16790:; set_tests_properties(TMVA-DNN-LSTM-BackpropagationCudnn PROPERTIES DISABLED True). # LSTM - Full Test GPU; add_executable(testFullLSTMCudnn TestFullLSTMCudnn.cxx); target_link_libraries(testFullLSTMCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-LSTM-Full-Cudnn COMMAND testFullLSTMCudnn). endif (tmva-gpu AND tmva-cudnn). #--- CPU tests. ----------------------------; if (BLAS_FOUND AND imt). # LSTM - Forward CPU; ROOT_EXECUTABLE(testLSTMForwardPassCpu ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/CMakeLists.txt:1011,test,testLSTMForwardPassCudnn,1011,tmva/tmva/test/DNN/LSTM/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/LSTM/CMakeLists.txt,1,['test'],['testLSTMForwardPassCudnn']
Testability,#########################################; # CMakeLists.txt file for building ROOT math/mathmore package; ############################################################################. ROOT_STANDARD_LIBRARY_PACKAGE(MathMore; HEADERS; Math/ChebyshevApprox.h; Math/Derivator.h; Math/DistFuncMathMore.h; Math/GSLIntegrator.h; Math/GSLMCIntegrator.h; Math/GSLMinimizer.h; Math/GSLMinimizer1D.h; Math/GSLMultiRootFinder.h; Math/GSLNLSMinimizer.h; Math/GSLQuasiRandom.h; Math/GSLRandom.h; Math/GSLRandomFunctions.h; Math/GSLRndmEngines.h; Math/GSLRootFinder.h; Math/GSLRootFinderDeriv.h; Math/GSLSimAnMinimizer.h; Math/InterpolationTypes.h; Math/Interpolator.h; Math/MCParameters.h; Math/PdfFuncMathMore.h; Math/Polynomial.h; Math/ParamFunction.h; Math/QuasiRandom.h; Math/RootFinderAlgorithms.h; Math/SpecFuncMathMore.h; Math/Vavilov.h; Math/VavilovAccurate.h; Math/VavilovAccurateCdf.h; Math/VavilovAccuratePdf.h; Math/VavilovAccurateQuantile.h; Math/VavilovFast.h; SOURCES; src/ChebyshevApprox.cxx; src/Derivator.cxx; src/GSLDerivator.cxx; src/GSLError.cxx; src/GSLIntegrator.cxx; src/GSLInterpolator.cxx; src/GSLMCIntegrator.cxx; src/GSLMinimizer.cxx; src/GSLMinimizer1D.cxx; src/GSLMultiRootFinder.cxx; src/GSLNLSMinimizer.cxx; src/GSLQuasiRandom.cxx; src/GSLRndmEngines.cxx; src/GSLRootFinder.cxx; src/GSLRootFinderDeriv.cxx; src/GSLRootHelper.cxx; src/GSLSimAnMinimizer.cxx; src/GSLSimAnnealing.cxx; src/Interpolator.cxx; src/MCParameters.cxx; src/MultiNumGradFunction.cxx; src/PdfFuncMathMore.cxx; src/Polynomial.cxx; src/QuantFuncMathMore.cxx; src/RootFinderAlgorithms.cxx; src/SpecFuncMathMore.cxx; src/Vavilov.cxx; src/VavilovAccurate.cxx; src/VavilovAccurateCdf.cxx; src/VavilovAccuratePdf.cxx; src/VavilovAccurateQuantile.cxx; src/VavilovFast.cxx; src/cblas.cxx; LINKDEF; Math/LinkDef.h; DEPENDENCIES; MathCore; BUILTINS; GSL; ). target_include_directories(MathMore SYSTEM PRIVATE ${GSL_INCLUDE_DIR}); target_link_libraries(MathMore PRIVATE ${GSL_LIBRARIES}). ROOT_ADD_TEST_SUBDIRECTORY(test); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/CMakeLists.txt:2223,test,test,2223,math/mathmore/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/CMakeLists.txt,1,['test'],['test']
Testability,#######################; # CMakeLists.txt file for building TMVA/DNN/CNN tests.; # @author Vladimir Ilievski; ############################################################################. set(Libraries TMVA). #--- CUDA tests. ---------------------------; if (tmva-gpu). list(APPEND Libraries CUDA::cuda_driver CUDA::cudart). set(DNN_CUDA_LIBRARIES ${CUDA_CUBLAS_LIBRARIES} ). add_executable(testIm2ColCuda TestIm2ColCuda.cxx); target_link_libraries(testIm2ColCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-Im2ColCuda COMMAND testIm2ColCuda). add_executable(testPoolingLayerCuda TestPoolingLayerCuda.cxx); target_link_libraries(testPoolingLayerCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-PoolingLayerCuda COMMAND testPoolingLayerCuda). add_executable(testReshapeCuda TestReshapeCuda.cxx); target_link_libraries(testReshapeCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ReshapeCuda COMMAND testReshapeCuda). add_executable(testConvLayerCuda TestConvLayerCuda.cxx); target_link_libraries(testConvLayerCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ConvLayerCuda COMMAND testConvLayerCuda). add_executable(testForwardPassCuda TestForwardPassCuda.cxx); target_link_libraries(testForwardPassCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ForwardCuda COMMAND testForwardPassCuda). add_executable(testRotateWeightsCuda TestRotateWeightsCuda.cxx); target_link_libraries(testRotateWeightsCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-RotateWeightsCuda COMMAND testRotateWeightsCuda). add_executable(testConvBackpropagationCuda TestConvBackpropagationCuda.cxx); target_link_libraries(testConvBackpropagationCuda ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ConvBackpropagationCuda COMMAND testConvBackpropagationCuda). if (tmva-cudnn). add_executable(testForwardPassCudnn TestForwardPassCudnn.cxx); target_link_libraries(testForwardPassCudnn ${Libraries} $,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt:1238,test,testConvLayerCuda,1238,tmva/tmva/test/DNN/CNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt,1,['test'],['testConvLayerCuda']
Testability,###################; # CMakeLists.txt file for building PyMVA tests; # @author Stefan Wunsch; ############################################################################. project(pymva-tests). set(Libraries Core MathCore TMVA PyMVA ROOTTMVASofie). # Look for needed python modules; find_python_module(torch QUIET); find_python_module(keras QUIET); find_python_module(theano QUIET); find_python_module(tensorflow QUIET); find_python_module(sklearn QUIET). if(PY_SKLEARN_FOUND); # Test PyRandomForest: Classification; ROOT_EXECUTABLE(testPyRandomForestClassification testPyRandomForestClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-RandomForest-Classification COMMAND testPyRandomForestClassification). # Test PyRandomForest: Multi-class classification; ROOT_EXECUTABLE(testPyRandomForestMulticlass testPyRandomForestMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-RandomForest-Multiclass COMMAND testPyRandomForestMulticlass). # Test PyGTB: Classification; ROOT_EXECUTABLE(testPyGTBClassification testPyGTBClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-GTB-Classification COMMAND testPyGTBClassification DEPENDS PyMVA-RandomForest-Classification). # Test PyGTB: Multi-class classification; ROOT_EXECUTABLE(testPyGTBMulticlass testPyGTBMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-GTB-Multiclass COMMAND testPyGTBMulticlass DEPENDS PyMVA-RandomForest-Multiclass). # Test PyAdaBoost: Classification; ROOT_EXECUTABLE(testPyAdaBoostClassification testPyAdaBoostClassification.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-AdaBoost-Classification COMMAND testPyAdaBoostClassification DEPENDS PyMVA-GTB-Classification). # Test PyAdaBoost: Multi-class classification; ROOT_EXECUTABLE(testPyAdaBoostMulticlass testPyAdaBoostMulticlass.C; LIBRARIES ${Libraries}); ROOT_ADD_TEST(PyMVA-AdaBoost-Multiclass COMMAND testPyAdaBoostMulticlass DEPENDS PyMVA-GTB-Multiclass). endif(PY_SKLEARN_FOUND). # Enable tests based on available python modules; if(PY_TO,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt:1252,test,testPyGTBClassification,1252,tmva/pymva/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/test/CMakeLists.txt,2,['test'],['testPyGTBClassification']
Testability,"#-------------------------------------------------------------------------------; # CLING - the C++ LLVM-based InterpreterG :); #; # This file is dual-licensed: you can choose to license it under the University; # of Illinois Open Source License or the GNU Lesser General Public License. See; # LICENSE.TXT for details.; #-------------------------------------------------------------------------------. add_cling_library(clingDemoPlugin SHARED DemoPlugin.cpp); if (TARGET check-cling); # Make sure if we are running the testsuite to build clingDemoPlugin before.; add_dependencies(check-cling clingDemoPlugin); endif(). set_target_properties(clingDemoPlugin PROPERTIES LIBRARY_OUTPUT_DIRECTORY "".""); if(APPLE); target_link_libraries(clingDemoPlugin PUBLIC -Wl,-w -Wl,-bind_at_load -Wl,-undefined,dynamic_lookup); elseif(NOT MSVC); target_link_libraries(clingDemoPlugin PUBLIC -Wl,--unresolved-symbols=ignore-in-object-files); endif(). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/plugins/example/CMakeLists.txt:520,test,testsuite,520,interpreter/cling/tools/plugins/example/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/plugins/example/CMakeLists.txt,1,['test'],['testsuite']
Testability,"#------------------------------------------------------------------------------; # CLING - the C++ LLVM-based InterpreterG :); #; # This file is dual-licensed: you can choose to license it under the University; # of Illinois Open Source License or the GNU Lesser General Public License. See; # LICENSE.TXT for details.; #------------------------------------------------------------------------------. if (CMAKE_CFG_INTDIR STREQUAL "".""); set(LLVM_BUILD_MODE "".""); else (); set(LLVM_BUILD_MODE ""%(build_mode)s""); endif (). # Needed for '%shlibext'; set(TARGET_SHLIBEXT ""${CMAKE_SHARED_LIBRARY_SUFFIX}""). configure_lit_site_cfg(; ${CMAKE_CURRENT_SOURCE_DIR}/lit.site.cfg.in; ${CMAKE_CURRENT_BINARY_DIR}/lit.site.cfg; ). option(CLING_TEST_USE_VG ""Run Cling tests under Valgrind"" OFF); if(CLING_TEST_USE_VG); set(CLING_TEST_EXTRA_ARGS ${CLING_TEST_EXTRA_ARGS} ""--vg""); endif (). list(APPEND CLING_TEST_DEPS cling); if (TARGET llvm-config); list(APPEND CLING_TEST_DEPS llvm-config); endif(); if (TARGET FileCheck); list(APPEND CLING_TEST_DEPS FileCheck); endif(); if (TARGET opt); list(APPEND CLING_TEST_DEPS opt); endif(); if (TARGET not); list(APPEND CLING_TEST_DEPS not); endif(); if (TARGET count); list(APPEND CLING_TEST_DEPS count); endif(); if (TARGET clang); list(APPEND CLING_TEST_DEPS clang); endif(). set(CLING_TEST_PARAMS; cling_site_config=${CMAKE_CURRENT_BINARY_DIR}/lit.site.cfg; ). add_custom_target(cling-test-depends DEPENDS clingDemoPlugin ${CLING_TEST_DEPS}). set(LLVM_LIT_OUTPUT_DIR ""${LLVM_BINARY_DIR}/bin""); add_lit_testsuite(check-cling ""Running the Cling regression tests""; ${CMAKE_CURRENT_BINARY_DIR}; PARAMS ${CLING_TEST_PARAMS}; DEPENDS ${CLING_TEST_DEPS}; ARGS ${CLING_TEST_EXTRA_ARGS}; ); set_target_properties(check-cling PROPERTIES FOLDER ""Cling tests""). # Add a legacy target spelling: cling-test; add_custom_target(cling-test); add_dependencies(cling-test check-cling); set_target_properties(cling-test PROPERTIES FOLDER ""Cling tests""); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/test/CMakeLists.txt:753,test,tests,753,interpreter/cling/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/test/CMakeLists.txt,9,['test'],"['test', 'test-depends', 'tests']"
Testability,"#. Don't assume you're linking in-process. Use libSupport's sized,; endian-specific types when reading/writing content in the ``LinkGraph``. As a ""minimum viable"" JITLink wrapper, the ``llvm-jitlink`` tool is an; invaluable resource for developers bringing in a new JITLink backend. A standard; workflow is to start by throwing an unsupported object at the tool and seeing; what error is returned, then fixing that (you can often make a reasonable guess; at what should be done based on existing code for other formats or; architectures). In debug builds of LLVM, the ``-debug-only=jitlink`` option dumps logs from the; JITLink library during the link process. These can be useful for spotting some bugs at; a glance. The ``-debug-only=llvm_jitlink`` option dumps logs from the ``llvm-jitlink``; tool, which can be useful for debugging both testcases (it is often less verbose than; ``-debug-only=jitlink``) and the tool itself. The ``-oop-executor`` and ``-oop-executor-connect`` options are helpful for testing; handling of cross-process and cross-architecture use cases. Roadmap; =======. JITLink is under active development. Work so far has focused on the MachO; implementation. In LLVM 12 there is limited support for ELF on x86-64. Major outstanding projects include:. * Refactor architecture support to maximize sharing across formats. All formats should be able to share the bulk of the architecture specific; code (especially relocations) for each supported architecture. * Refactor ELF link graph construction. ELF's link graph construction is currently implemented in the `ELF_x86_64.cpp`; file, and tied to the x86-64 relocation parsing code. The bulk of the code is; generic and should be split into an ELFLinkGraphBuilder base class along the; same lines as the existing generic MachOLinkGraphBuilder. * Implement support for arm32. * Implement support for other new architectures. JITLink Availability and Feature Status; ---------------------------------------. The following table des",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:44335,test,testing,44335,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['test'],['testing']
Testability,"#Copyright(C) 1995 - 2023, Rene Brun and Fons Rademakers.; #All rights reserved.; #; #For the licensing terms see $ROOTSYS / LICENSE.; #For the list of contributors see $ROOTSYS / README / CREDITS. ROOT_ADD_GTEST(testMatrixTSparse testMatrixTSparse.cxx LIBRARIES Matrix); ROOT_ADD_GTEST(testMatrixTDecomp testMatrixTDecomp.cxx LIBRARIES Matrix); ROOT_ADD_GTEST(testMatrixT testMatrixT.cxx LIBRARIES Matrix)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/test/CMakeLists.txt:213,test,testMatrixTSparse,213,math/matrix/test/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/test/CMakeLists.txt,6,['test'],"['testMatrixT', 'testMatrixTDecomp', 'testMatrixTSparse']"
Testability,"#include <new>. class A {; public:; ~A();; };. class B : public A {};. class C {};. A* test() {; B *b = new B;; new(b) C;; return static_cast<A*>(b); // warn; }. #include <new>. class A {; public:; ~A();; };. class B : public A {};. class C {};. A* test() {; B *b = new B;; new(b) C;; return dynamic_cast<A*>(b); // warn; }. undefbehavior.ObjLocChanges; (C++); Undefined behavior: the program must ensure that an object occupies the same; storage location when the implicit or explicit destructor call takes place.; Source: C++11 3.8p8. #include <new>. class A {};. class B {; public:; ~B();; };. void test() {; B b;; new (&b) A;; } // warn. #include <new>. class A {};. class B {; public:; ~B();; };. void test() {; B *b = new B;; new (b) A;; delete b; // warn; }. undefbehavior.ExprEvalOrderUndef; (C, C++03); Undefined behavior: a scalar object shall have its stored value modified at; most once by the evaluation of an expression.; Note: most cases are currently handled by the Clang core (search for 'multiple; unsequenced modifications' warning in Clang tests).; Source: C++03 5p4. int test () {; int i = 0;; i = ++i + 1; // warn; return i;; }. undefbehavior.StaticInitReentered; (C++); Undefined behavior: static declaration is re-entered while the object is being; initialized.; Source: C++11 6.7p4. int test(int i) {; static int s = test(2 * i); // warn; return i + 1;; }. undefbehavior.ConstModified; (C, C++); Undefined behavior: const object is being modified.; Source: C++03 7.1.5.1p4, C++11 7.1.6.1p4. void test() {; const int *cp = new const int (0);; int *p = const_cast<int *>(cp);; *p = 1; // warn; delete p;; }. class C {; public :; int i;; C();; };. void test() {; const C cb;. C* cp = const_cast<C *>(&cb);; cp->i = 1; // warn; }. undefbehavior.DeadDestructed; (C++); Undefined behavior: the destructor is invoked for an object whose lifetime; has ended.; Source: C++11 12.4p14. class A {; public:; void f();; A();; ~A();; };. void test() {; A a;; a.~A();; } // warn. undefbehavio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:8768,test,tests,8768,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['tests']
Testability,"#lower[0.4]{j}#lower[0.1]{u}#lower[-0.1]{s}#lower[-0.3]{t}#lower[-0.4]{m}#lower[-0.2]{e}#lower[0.1]{n}t with #^{}lower[-0.4...+0.4]""))->Draw();; (new TLatex(0.01, 0.3, ""Font styles: #^{}bf{#bf{bold}}, #^{}it{#it{italic}}, #^{}bf{#^{}it{#bf{#it{bold italic}}}}, #^{}bf{#^{}bf{#bf{#bf{unbold}}}}""))->Draw();; (new TLatex(0.01, 0.1, ""Font styles: abc#alpha#beta#gamma, #^{}it{#it{abc#alpha#beta#gamma}}, #^{}it{#^{}it{#it{#it{abc#alpha#beta#gamma}}}}""))->Draw();; }. Done by: Oleksandr Grebenyuk <ogrebenyuk@lbl.gov>.; Two new characters: #forall and #exists. TText. New method GetTextAdvance to return the text advance for string; text taking the kerning into account or not. TGaxis. In case of horizontal axis with the font size in pixel (font precision = 3); the labels were not visible.; Alpha numeric labels are not scaled anymore in case of text precision 3; (size in pixels). They are in the other precisions.; Fix a precision issue on Mac. With the following lines the last label; (10^3) did not show:; ; t1 = new TH1F(""test"",""test"", 100,1,1000);; t1.Draw();; gPad->SetLogx(1);; . TPaveStats. The stats painting assumed that the stats position was always defined with; Y2>Y1 and X2>X1. This is true when the stats is created automatically but; might not true if the stats position is given by user. This is now; protected. The stats are correctly drawn whatever the orders of X and Y; coordinates are. ; Saving canvas as a .C macro discarded white title and stat box; background. Same thing with TPaveText. TCutG. IsInside(x,y) is now inherited from TGraph. TCanvas and TPad. In case of Canvas.MoveOpaque = true in $ROOTSYS/etc/system.rootrc; the rubberband was not visible during the zooming along axis.; TPad::SaveAs now takes care of the extensions .pdf],; .pdf[, .pad( and .pdf) to avoid the PS and PDF; mixing when a multiple pages PDF files is generated. To work around this; problem it was enough to specify the option ""pdf"" in SaveAs.; c->BuildLegend() created the legend in the current ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v528/index.html:6207,test,test,6207,graf2d/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v528/index.html,2,['test'],['test']
Testability,"$ clang -g -O2 test.cpp -o inlined.elf. Example 1 - addresses and object on command-line:. .. code-block:: console. $ llvm-symbolizer --obj=test.elf 0x4004d0 0x400490; foz; /tmp/test.h:1:0. baz(); /tmp/test.cpp:11:0. Example 2 - addresses on standard input:. .. code-block:: console. $ cat addr.txt; 0x4004a0; 0x400490; 0x4004d0; $ llvm-symbolizer --obj=test.elf < addr.txt; main; /tmp/test.cpp:15:0. baz(); /tmp/test.cpp:11:0. foz; /tmp/./test.h:1:0. Example 3 - object specified with address:. .. code-block:: console. $ llvm-symbolizer ""test.elf 0x400490"" ""FILE:inlined.elf 0x400480""; baz(); /tmp/test.cpp:11:0. foo(); /tmp/test.cpp:8:10. $ cat addr2.txt; FILE:test.elf 0x4004a0; inlined.elf 0x400480. $ llvm-symbolizer < addr2.txt; main; /tmp/test.cpp:15:0. foo(); /tmp/test.cpp:8:10. Example 4 - BUILDID and FILE prefixes:. .. code-block:: console. $ llvm-symbolizer ""FILE:test.elf 0x400490"" ""DATA BUILDID:123456789abcdef 0x601028""; baz(); /tmp/test.cpp:11:0. bar; 6295592 4. $ cat addr3.txt; FILE:test.elf 0x400490; DATA BUILDID:123456789abcdef 0x601028. $ llvm-symbolizer < addr3.txt; baz(); /tmp/test.cpp:11:0. bar; 6295592 4. Example 5 - CODE and DATA prefixes:. .. code-block:: console. $ llvm-symbolizer --obj=test.elf ""CODE 0x400490"" ""DATA 0x601028""; baz(); /tmp/test.cpp:11:0. bar; 6295592 4. $ cat addr4.txt; CODE test.elf 0x4004a0; DATA inlined.elf 0x601028. $ llvm-symbolizer < addr4.txt; main; /tmp/test.cpp:15:0. bar; 6295592 4. Example 6 - path-style options:. This example uses the same source file as above, but the source file's; full path is /tmp/foo/test.cpp and is compiled as follows. The first case; shows the default absolute path, the second --basenames, and the third; shows --relativenames. .. code-block:: console. $ pwd; /tmp; $ clang -g foo/test.cpp -o test.elf; $ llvm-symbolizer --obj=test.elf 0x4004a0; main; /tmp/foo/test.cpp:15:0; $ llvm-symbolizer --obj=test.elf 0x4004a0 --basenames; main; test.cpp:15:0; $ llvm-symbolizer --obj=test.elf 0x4004a0 --relativenam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst:3542,test,test,3542,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,1,['test'],['test']
Testability,"$ llvm-symbolizer --obj=inlined.elf 0x4004be 0x400486 -p; baz() at /tmp/test.cpp:11:18; (inlined by) main at /tmp/test.cpp:15:0. foo() at /tmp/test.cpp:6:3. $ llvm-symbolizer --output-style=LLVM --obj=inlined.elf 0x4004be 0x400486 -p --no-inlines; main at /tmp/test.cpp:11:18. foo() at /tmp/test.cpp:6:3. $ llvm-symbolizer --output-style=GNU --obj=inlined.elf 0x4004be 0x400486 -p --no-inlines; baz() at /tmp/test.cpp:11; foo() at /tmp/test.cpp:6. $ clang -g -fdebug-info-for-profiling test.cpp -o profiling.elf; $ llvm-symbolizer --output-style=GNU --obj=profiling.elf 0x401167 -p --no-inlines; main at /tmp/test.cpp:15 (discriminator 2). $ llvm-symbolizer --output-style=JSON --obj=inlined.elf 0x4004be 0x400486 -p; [; {; ""Address"": ""0x4004be"",; ""ModuleName"": ""inlined.elf"",; ""Symbol"": [; {; ""Column"": 18,; ""Discriminator"": 0,; ""FileName"": ""/tmp/test.cpp"",; ""FunctionName"": ""baz()"",; ""Line"": 11,; ""StartAddress"": ""0x4004be"",; ""StartFileName"": ""/tmp/test.cpp"",; ""StartLine"": 9; },; {; ""Column"": 0,; ""Discriminator"": 0,; ""FileName"": ""/tmp/test.cpp"",; ""FunctionName"": ""main"",; ""Line"": 15,; ""StartAddress"": ""0x4004be"",; ""StartFileName"": ""/tmp/test.cpp"",; ""StartLine"": 14; }; ]; },; {; ""Address"": ""0x400486"",; ""ModuleName"": ""inlined.elf"",; ""Symbol"": [; {; ""Column"": 3,; ""Discriminator"": 0,; ""FileName"": ""/tmp/test.cpp"",; ""FunctionName"": ""foo()"",; ""Line"": 6,; ""StartAddress"": ""0x400486"",; ""StartFileName"": ""/tmp/test.cpp"",; ""StartLine"": 5; }; ]; }; ]. .. option:: --pretty-print, -p. Print human readable output. If :option:`--inlining` is specified, the; enclosing scope is prefixed by (inlined by).; For JSON output, the option will cause JSON to be indented and split over; new lines. Otherwise, the JSON output will be printed in a compact form. .. code-block:: console. $ llvm-symbolizer --obj=inlined.elf 0x4004be --inlining --pretty-print; baz() at /tmp/test.cpp:11:18; (inlined by) main at /tmp/test.cpp:15:0. .. option:: --print-address, --addresses, -a. Print address before the source code loc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst:10236,test,test,10236,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-symbolizer.rst,1,['test'],['test']
Testability,"$0, %rdi # Validate index used for jump table.; cmovneq %r8, %rax # Conditionally update predicate state.; ...; jmp _Z4leaki # TAILCALL. .LBB0_3: # %sw.bb1; testq $1, %rdi # Validate index used for jump table.; cmovneq %r8, %rax # Conditionally update predicate state.; ...; jmp _Z4leaki # TAILCALL. .LBB0_5: # %sw.bb10; testq $2, %rdi # Validate index used for jump table.; cmovneq %r8, %rax # Conditionally update predicate state.; ...; jmp _Z4leaki # TAILCALL; ... .section .rodata,""a"",@progbits; .p2align 3; .LJTI0_0:; .quad .LBB0_2; .quad .LBB0_3; .quad .LBB0_5; ...; ```. Returns have a simple mitigation technique on x86-64 (or other ABIs which have; what is called a ""red zone"" region beyond the end of the stack). This region is; guaranteed to be preserved across interrupts and context switches, making the; return address used in returning to the current code remain on the stack and; valid to read. We can emit code in the caller to verify that a return edge was; not mispredicted:; ```; callq other_function; return_addr:; testq -8(%rsp), return_addr # Validate return address.; cmovneq %r8, %rax # Update predicate state.; ```. For an ABI without a ""red zone"" (and thus unable to read the return address; from the stack), we can compute the expected return address prior to the call; into a register preserved across the call and use that similarly to the above. Indirect calls (and returns in the absence of a red zone ABI) pose the most; significant challenge to propagate. The simplest technique would be to define a; new ABI such that the intended call target is passed into the called function; and checked in the entry. Unfortunately, new ABIs are quite expensive to deploy; in C and C++. While the target function could be passed in TLS, we would still; require complex logic to handle a mixture of functions compiled with and; without this extra logic (essentially, making the ABI backwards compatible).; Currently, we suggest using retpolines here and will continue to investig",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:19550,test,testq,19550,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['test'],['testq']
Testability,${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-PoolingLayer COMMAND testPoolingLayer). ROOT_EXECUTABLE(testReshape TestReshape.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Reshape COMMAND testReshape). ROOT_EXECUTABLE(testRotWeights TestRotateWeights.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-RotWeights COMMAND testRotWeights). #-- features not implemeted in ref architectures; #ROOT_EXECUTABLE(testForwardPass TestForwardPass.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-CNN-Forward COMMAND testForwardPass). #ROOT_EXECUTABLE(testConvNetLoss TestConvNetLoss.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-CNN-Loss COMMAND testConvNetLoss). #ROOT_EXECUTABLE(testConvNetPred TestConvNetPrediction.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-CNN-Pred COMMAND testConvNetPred). #ROOT_EXECUTABLE(testDLMinimization TestMinimization.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-CNN-Minimization COMMAND testDLMinimization). #ROOT_EXECUTABLE(testTensorDataLoader TestTensorDataLoader.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-Tensor-Data-Loader COMMAND testTensorDataLoader). endif(). #--- CPU tests. ----------------------------; if ((BLAS_FOUND OR mathmore) AND imt AND tmva-cpu). ROOT_EXECUTABLE(testIm2ColCpu TestIm2ColCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Im2Col-CPU COMMAND testIm2ColCpu). ROOT_EXECUTABLE(testPoolingLayerCpu TestPoolingLayerCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-PoolingLayer-CPU COMMAND testPoolingLayerCpu). ROOT_EXECUTABLE(testConvLayerCpu TestConvLayerCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-ConvLayer-CPU COMMAND testConvLayerCpu). ROOT_EXECUTABLE(testRotWeightsCpu TestRotateWeightsCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-RotWeights-CPU COMMAND testRotWeightsCpu). ROOT_EXECUTABLE(testForwardPassCpu TestForwardPassCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Forward-CPU COMMAND testForwardPassCpu). ROOT_EXECUTABL,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt:4589,test,testTensorDataLoader,4589,tmva/tmva/test/DNN/CNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt,1,['test'],['testTensorDataLoader']
Testability,"${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Regression-Cpu COMMAND testRegressionCpu). #( old-dnn-test ); # DNN - DataLoader CPU; ROOT_EXECUTABLE(testDataLoaderCpu TestDataLoaderCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Data-Loader-Cpu COMMAND testDataLoaderCpu). # DNN - Minimization CPU; ROOT_EXECUTABLE(testMinimizationCpu TestMinimizationCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Minimization-Cpu COMMAND testMinimizationCpu). # tests using TReference architecture; if ( reference-tests). # DNN - Activation Functions; ROOT_EXECUTABLE(testActivationFunctions TestActivationFunctions.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Activation-Functions COMMAND testActivationFunctions). # DNN - Loss Functions; ROOT_EXECUTABLE(testLossFunctions TestLossFunctions.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Loss-Functions COMMAND testLossFunctions). # DNN - Derivatives; ROOT_EXECUTABLE(testDerivatives TestDerivatives.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Derivatives COMMAND testDerivatives). # DNN - Backpropagation; ROOT_EXECUTABLE(testBackpropagation TestBackpropagation.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Backpropagation COMMAND testBackpropagation). # DNN - Backpropagation DL; ROOT_EXECUTABLE(testBackpropagationDL TestBackpropagationDL.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Backpropagation-DL COMMAND testBackpropagationDL). # DNN - Batch normalization; ROOT_EXECUTABLE(testBatchNormalization TestBatchNormalization.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-BatchNormalization COMMAND testBatchNormalization). # DNN - DataLoader; ROOT_EXECUTABLE(testDataLoader TestDataLoader.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Data-Loader COMMAND testDataLoader). # DNN - Minimization; # ROOT_EXECUTABLE(testMinimization TestMinimization.cxx LIBRARIES ${Libraries}); # # this test takes more than 20 minutes on arm in non-optimised mode; # if (NOT (CMAKE_SYSTEM_PROCESSOR STREQUAL ""aarch64"" AND CMAK",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt:7954,test,testDerivatives,7954,tmva/tmva/test/DNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt,1,['test'],['testDerivatives']
Testability,% ROOT Primer: ![](figures/logo.png); %; % May 2015. ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOTPrimer.md:27,log,logo,27,documentation/primer/ROOTPrimer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOTPrimer.md,1,['log'],['logo']
Testability,"% cat example_UseAfterFree.cc; int main(int argc, char **argv) {; int *array = new int[100];; delete [] array;; return array[argc]; // BOOM; }. # Compile and link; % clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer example_UseAfterFree.cc. or:. .. code-block:: console. # Compile; % clang++ -O1 -g -fsanitize=address -fno-omit-frame-pointer -c example_UseAfterFree.cc; # Link; % clang++ -g -fsanitize=address example_UseAfterFree.o. If a bug is detected, the program will print an error message to stderr and; exit with a non-zero exit code. AddressSanitizer exits on the first detected error.; This is by design:. * This approach allows AddressSanitizer to produce faster and smaller generated code; (both by ~5%).; * Fixing bugs becomes unavoidable. AddressSanitizer does not produce; false alarms. Once a memory corruption occurs, the program is in an inconsistent; state, which could lead to confusing results and potentially misleading; subsequent reports. If your process is sandboxed and you are running on OS X 10.10 or earlier, you; will need to set ``DYLD_INSERT_LIBRARIES`` environment variable and point it to; the ASan library that is packaged with the compiler used to build the; executable. (You can find the library by searching for dynamic libraries with; ``asan`` in their name.) If the environment variable is not set, the process will; try to re-exec. Also keep in mind that when moving the executable to another machine,; the ASan library will also need to be copied over. Symbolizing the Reports; =========================. To make AddressSanitizer symbolize its output; you need to set the ``ASAN_SYMBOLIZER_PATH`` environment variable to point to; the ``llvm-symbolizer`` binary (or make sure ``llvm-symbolizer`` is in your; ``$PATH``):. .. code-block:: console. % ASAN_SYMBOLIZER_PATH=/usr/local/bin/llvm-symbolizer ./a.out; ==9442== ERROR: AddressSanitizer heap-use-after-free on address 0x7f7ddab8c084 at pc 0x403c8c bp 0x7fff87fb82d0 sp 0x7fff87fb82c8; READ of siz",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:2878,sandbox,sandboxed,2878,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['sandbox'],['sandboxed']
Testability,%`; * - compiler-rt/lib/scudo/standalone/tools; - `1`; - `1`; - `0`; - :good:`100%`; * - compiler-rt/lib/stats; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/benchmarks; - `6`; - `0`; - `6`; - :none:`0%`; * - compiler-rt/lib/tsan/dd; - `3`; - `0`; - `3`; - :none:`0%`; * - compiler-rt/lib/tsan/go; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/tsan/rtl; - `59`; - `14`; - `45`; - :part:`23%`; * - compiler-rt/lib/tsan/rtl-old; - `61`; - `13`; - `48`; - :part:`21%`; * - compiler-rt/lib/tsan/tests/rtl; - `10`; - `0`; - `10`; - :none:`0%`; * - compiler-rt/lib/tsan/tests/unit; - `11`; - `3`; - `8`; - :part:`27%`; * - compiler-rt/lib/ubsan; - `27`; - `7`; - `20`; - :part:`25%`; * - compiler-rt/lib/ubsan_minimal; - `1`; - `0`; - `1`; - :none:`0%`; * - compiler-rt/lib/xray; - `40`; - `27`; - `13`; - :part:`67%`; * - compiler-rt/lib/xray/tests/unit; - `10`; - `8`; - `2`; - :part:`80%`; * - compiler-rt/tools/gwp_asan; - `2`; - `2`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/clang_llvm_roundtrip; - `2`; - `1`; - `1`; - :part:`50%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/penalty; - `10`; - `0`; - `10`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_address; - `7`; - `0`; - `7`; - :none:`0%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/dex_and_source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_declare_file/precompiled_binary_different_dir/source; - `1`; - `1`; - `0`; - :good:`100%`; * - cross-project-tests/debuginfo-tests/dexter/feature_tests/commands/perfect/dex_decl,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:25736,test,tests,25736,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['test'],['tests']
Testability,%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer/tests/ompt; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests/custom_data_storage; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/tools/multiplex/tests/print; - `2`; - `2`; - `0`; - :good:`100%`; * - polly/include/polly; - `25`; - `25`; - `0`; - :good:`100%`; * - polly/include/polly/CodeGen; - `14`; - `14`; - `0`; - :good:`100%`; * - polly/include/polly/Support; - `12`; - `12`; - `0`; - :good:`100%`; * - polly/lib/Analysis; - `9`; - `9`; - `0`; - :good:`100%`; * - polly/lib/CodeGen; - `15`; - `15`; - `0`; - :good:`100%`; * - polly/lib/Exchange; - `1`; - `1`; - `0`; - :good:`100%`; * - polly/lib/External/isl; - `68`; - `1`; - `67`; - :part:`1%`; * - polly/lib/External/isl/imath; - `6`; - `1`; - `5`; - :part:`16%`; * - polly/lib/External/isl/imath_wrap; - `4`; - `0`; - `4`; - :none:`0%`; * - polly/lib/External/isl/include/isl; - `59`; - `9`; - `50`; - :part:`15%`; * - polly/lib/External/isl/interface; - `8`; - `1`; - `7`; - :part:`12%`; * - polly/lib/External/pet/include; - `,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:123570,test,tests,123570,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['test'],['tests']
Testability,"%eax; ret. GCC knows several different ways to codegen it, one of which is this:. _test1:; movl 4(%esp), %eax; cmpl $-1, %eax; leal 7(%eax), %ecx; cmovle %ecx, %eax; sarl $3, %eax; ret. which is probably slower, but it's interesting at least :). //===---------------------------------------------------------------------===//. We are currently lowering large (1MB+) memmove/memcpy to rep/stosl and rep/movsl; We should leave these as libcalls for everything over a much lower threshold,; since libc is hand tuned for medium and large mem ops (avoiding RFO for large; stores, TLB preheating, etc). //===---------------------------------------------------------------------===//. Optimize this into something reasonable:; x * copysign(1.0, y) * copysign(1.0, z). //===---------------------------------------------------------------------===//. Optimize copysign(x, *y) to use an integer load from y. //===---------------------------------------------------------------------===//. The following tests perform worse with LSR:. lambda, siod, optimizer-eval, ackermann, hash2, nestedloop, strcat, and Treesor. //===---------------------------------------------------------------------===//. Adding to the list of cmp / test poor codegen issues:. int test(__m128 *A, __m128 *B) {; if (_mm_comige_ss(*A, *B)); return 3;; else; return 4;; }. _test:; 	movl 8(%esp), %eax; 	movaps (%eax), %xmm0; 	movl 4(%esp), %eax; 	movaps (%eax), %xmm1; 	comiss %xmm0, %xmm1; 	setae %al; 	movzbl %al, %ecx; 	movl $3, %eax; 	movl $4, %edx; 	cmpl $0, %ecx; 	cmove %edx, %eax; 	ret. Note the setae, movzbl, cmpl, cmove can be replaced with a single cmovae. There; are a number of issues. 1) We are introducing a setcc between the result of the; intrisic call and select. 2) The intrinsic is expected to produce a i32 value; so a any extend (which becomes a zero extend) is added. We probably need some kind of target DAG combine hook to fix this. //===---------------------------------------------------------------------===//. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:5454,test,tests,5454,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['test'],['tests']
Testability,"%ebp); 	movswl	-70(%ebp), %eax; 	movl	%ecx, -88(%ebp); 	subl	%eax, -88(%ebp); 	movswl	-50(%ebp), %eax; 	subl	%eax, %ecx; 	movl	%ecx, -76(%ebp); 	movswl	-42(%ebp), %eax; 	movl	%eax, -92(%ebp); 	movswl	-66(%ebp), %eax; 	movl	%eax, -96(%ebp); 	movw	$0, -98(%ebp). This appears to be bad because the RA is not folding the store to the stack ; slot into the movl. The above instructions could be:; 	movl $32, -80(%ebp); ...; 	movl $32, -84(%ebp); ...; This seems like a cross between remat and spill folding. This has redundant subtractions of %eax from a stack slot. However, %ecx doesn't; change, so we could simply subtract %eax from %ecx first and then use %ecx (or; vice-versa). //===---------------------------------------------------------------------===//. This code:. 	%tmp659 = icmp slt i16 %tmp654, 0		; <i1> [#uses=1]; 	br i1 %tmp659, label %cond_true662, label %cond_next715. produces this:. 	testw	%cx, %cx; 	movswl	%cx, %esi; 	jns	LBB4_109	# cond_next715. Shark tells us that using %cx in the testw instruction is sub-optimal. It; suggests using the 32-bit register (which is what ICC uses). //===---------------------------------------------------------------------===//. We compile this:. void compare (long long foo) {; if (foo < 4294967297LL); abort();; }. to:. compare:; subl $4, %esp; cmpl $0, 8(%esp); setne %al; movzbw %al, %ax; cmpl $1, 12(%esp); setg %cl; movzbw %cl, %cx; cmove %ax, %cx; testb $1, %cl; jne .LBB1_2 # UnifiedReturnBlock; .LBB1_1: # ifthen; call abort; .LBB1_2: # UnifiedReturnBlock; addl $4, %esp; ret. (also really horrible code on ppc). This is due to the expand code for 64-bit; compares. GCC produces multiple branches, which is much nicer:. compare:; subl $12, %esp; movl 20(%esp), %edx; movl 16(%esp), %eax; decl %edx; jle .L7; .L5:; addl $12, %esp; ret; .p2align 4,,7; .L7:; jl .L4; cmpl $0, %eax; .p2align 4,,8; ja .L5; .L4:; .p2align 4,,9; call abort. //===---------------------------------------------------------------------===//. Tail call optimization",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:17012,test,testw,17012,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['test'],['testw']
Testability,"%i\n"", Y);; }. If we want to know how ``function_to_test`` behaves when we change the behavior; of ``function_to_mock`` we can test it by writing a test harness:. .. code-block:: c. void function_to_test();. int function_to_mock(int X) {; printf(""used mock utility function\n"");; return 42;; }. int main(int argc, char *argv[]) {; function_to_test():; return 0;; }. Under normal circumstances these objects could not be linked together:; ``function_to_test`` is static and could not be resolved outside; ``test_code.o``, the two ``function_to_mock`` functions would result in a; duplicate definition error, and ``irrelevant_external`` is undefined.; However, using ``-harness`` and ``-phony-externals`` we can run this code; with:. .. code-block:: sh. % clang -c -o test_code_harness.o test_code_harness.c; % llvm-jitlink -phony-externals test_code.o -harness test_code_harness.o; used mock utility function; Y is 42. The ``-harness`` option may be of interest to people who want to perform some; very late testing on build products to verify that compiled code behaves as; expected. On basic C test cases this is relatively straightforward. Mocks for; more complicated languages (e.g. C++) are much trickier: Any code involving; classes tends to have a lot of non-trivial surface area (e.g. vtables) that; would require great care to mock. Tips for JITLink backend developers; -----------------------------------. #. Make liberal use of assert and ``llvm::Error``. Do *not* assume that the input; object is well formed: Return any errors produced by libObject (or your own; object parsing code) and validate as you construct. Think carefully about the; distinction between contract (which should be validated with asserts and; llvm_unreachable) and environmental errors (which should generate; ``llvm::Error`` instances). #. Don't assume you're linking in-process. Use libSupport's sized,; endian-specific types when reading/writing content in the ``LinkGraph``. As a ""minimum viable"" JITLink wrappe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:42514,test,testing,42514,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['test'],['testing']
Testability,"%xmm0; 	movsd	%xmm0, (%esp); 	movl	4(%esp), %eax; 	shrl	$31, %eax; 	addl	$12, %esp; 	ret. We should use movmskp{s|d} instead. //===---------------------------------------------------------------------===//. CodeGen/X86/vec_align.ll tests whether we can turn 4 scalar loads into a single; (aligned) vector load. This functionality has a couple of problems. 1. The code to infer alignment from loads of globals is in the X86 backend,; not the dag combiner. This is because dagcombine2 needs to be able to see; through the X86ISD::Wrapper node, which DAGCombine can't really do.; 2. The code for turning 4 x load into a single vector load is target ; independent and should be moved to the dag combiner.; 3. The code for turning 4 x load into a vector load can only handle a direct ; load from a global or a direct load from the stack. It should be generalized; to handle any load from P, P+4, P+8, P+12, where P can be anything.; 4. The alignment inference code cannot handle loads from globals in non-static; mode because it doesn't look through the extra dyld stub load. If you try; vec_align.ll without -relocation-model=static, you'll see what I mean. //===---------------------------------------------------------------------===//. We should lower store(fneg(load p), q) into an integer load+xor+store, which; eliminates a constant pool load. For example, consider:. define i64 @ccosf(float %z.0, float %z.1) nounwind readonly {; entry:; %tmp6 = fsub float -0.000000e+00, %z.1		; <float> [#uses=1]; %tmp20 = tail call i64 @ccoshf( float %tmp6, float %z.0 ) nounwind readonly; ret i64 %tmp20; }; declare i64 @ccoshf(float %z.0, float %z.1) nounwind readonly. This currently compiles to:. LCPI1_0:					# <4 x float>; 	.long	2147483648	# float -0; 	.long	2147483648	# float -0; 	.long	2147483648	# float -0; 	.long	2147483648	# float -0; _ccosf:; 	subl	$12, %esp; 	movss	16(%esp), %xmm0; 	movss	%xmm0, 4(%esp); 	movss	20(%esp), %xmm0; 	xorps	LCPI1_0, %xmm0; 	movss	%xmm0, (%esp); 	call	L_ccoshf$stub;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt:12236,stub,stub,12236,interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,1,['stub'],['stub']
Testability,"&y - &x; // warn; }. alpha.core.SizeofPtr; (C); Warn about unintended use of sizeof() on pointer; expressions. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. alpha.core.StackAddressAsyncEscape; (C); Check that addresses to stack memory do not escape the function that involves; dispatch_after or dispatch_async. This checker is; a part of core.StackAddressEscape, but is; temporarily disabled until some; false positives are fixed. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. alpha.core.TestAfterDivZero; (C, C++, ObjC); Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. C++ Alpha Checkers. Name, DescriptionExample. alpha.cplusplus.ArrayDelete; (C++); Reports destructions of arrays of polymorphic objects that are destructed as; their base class. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void sink(Base *x) {; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' undefined; }. alpha.cplusplus.DeleteWithNonVirtualDtor; (C++); Reports destructions of polymorphic objects with a non-virtual destructor in; their base class. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void sink(NonVirtual *x) {; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. alpha.cplusplus.InvalidatedIterator; (C++); Check for use of invalidated iterators. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:4225,test,test,4225,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['test'],['test']
Testability,"'**, which is the correct value. Note that there is no requirement that GCC must produce identical or; similar DWARF to Clang to allow the comparison. We're only comparing; the semantics. The same case when comparing CodeView debug information; generated by MSVC and Clang. There are 2 comparison methods: logical view and logical elements. LOGICAL VIEW; """"""""""""""""""""""""; It compares the logical view as a whole unit; for a match, each compared; logical element must have the same parents and children. Using the :program:`llvm-debuginfo-analyzer` comparison functionality,; that issue can be seen in a more global context, that can include the; logical view. The output shows in view form the **missing (-), added (+)** elements,; giving more context by swapping the reference and target object files. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level; --compare=types; --report=view; --print=symbols,types; test-dwarf-clang.o test-dwarf-gcc.o. Reference: 'test-dwarf-clang.o'; Target: 'test-dwarf-gcc.o'. Logical View:; [000] {File} 'test-dwarf-clang.o'. [001] {CompileUnit} 'test.cpp'; [002] 1 {TypeAlias} 'INTPTR' -> '* const int'; [002] 2 {Function} extern not_inlined 'foo' -> 'int'; [003] {Block}; [004] 5 {Variable} 'CONSTANT' -> 'const INTEGER'; +[004] 4 {TypeAlias} 'INTEGER' -> 'int'; [003] 2 {Parameter} 'ParamBool' -> 'bool'; [003] 2 {Parameter} 'ParamPtr' -> 'INTPTR'; [003] 2 {Parameter} 'ParamUnsigned' -> 'unsigned int'; -[003] 4 {TypeAlias} 'INTEGER' -> 'int'. The output shows the merging view path (reference and target) with the; missing and added elements. LOGICAL ELEMENTS; """"""""""""""""""""""""""""""""; It compares individual logical elements without considering if their; parents are the same. For both comparison methods, the equal criteria; includes the name, source code location, type, lexical scope level. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level; --compare=types; --report=list; --print=symbols,types,summary; test-dwarf-clang.o test-dwarf-gcc.o. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:30448,test,test-dwarf-gcc,30448,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['test'],['test-dwarf-gcc']
Testability,"'; ...; # While this is running, do `killall -SIGUSR1 my_fuzzer` in another console; ==9015== INFO: libFuzzer: exiting as requested. # This will leave the file SomeLocalPath with the partial state of the merge.; # Now, you can continue the merge by executing the same command. The merge; # will continue from where it has been interrupted.; % ./my_fuzzer CORPUS1 CORPUS2 -merge=1 -merge_control_file=SomeLocalPath; ...; MERGE-OUTER: non-empty control file provided: 'SomeLocalPath'; MERGE-OUTER: control file ok, 32 files total, first not processed file 20; ... Options; =======. To run the fuzzer, pass zero or more corpus directories as command line; arguments. The fuzzer will read test inputs from each of these corpus; directories, and any new test inputs that are generated will be written; back to the first corpus directory:. .. code-block:: console. ./fuzzer [-flag1=val1 [-flag2=val2 ...] ] [dir1 [dir2 ...] ]. If a list of files (rather than directories) are passed to the fuzzer program,; then it will re-run those files as test inputs but will not perform any fuzzing.; In this mode the fuzzer binary can be used as a regression test (e.g. on a; continuous integration system) to check the target function and saved inputs; still work. The most important command line options are:. ``-help``; Print help message (``-help=1``).; ``-seed``; Random seed. If 0 (the default), the seed is generated.; ``-runs``; Number of individual test runs, -1 (the default) to run indefinitely.; ``-max_len``; Maximum length of a test input. If 0 (the default), libFuzzer tries to guess; a good value based on the corpus (and reports it).; ``-len_control``; Try generating small inputs first, then try larger inputs over time.; Specifies the rate at which the length limit is increased (smaller == faster).; Default is 100. If 0, immediately try inputs with size up to max_len.; ``-timeout``; Timeout in seconds, default 1200. If an input takes longer than this timeout,; the process is treated as a failur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:9857,test,test,9857,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['test'],['test']
Testability,"'; [004] {Variable} 'Var_1' -> 'int'; [003] 11 {Parameter} 'Param_1' -> 'int'; [003] 11 {Parameter} 'Param_2' -> 'int'. DWARF - GCC (Linux); ^^^^^^^^^^^^^^^^^^^. .. code-block:: none. Logical View:; [000] {File} 'pr-43860-dwarf-gcc.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [002] {Producer} 'GNU C++14 9.3.0'; [002] 2 {Function} extern declared_inlined 'InlineFunction' -> 'int'; [003] {Block}; [004] 5 {Variable} 'Var_2' -> 'int'; [003] 2 {Parameter} 'Param' -> 'int'; [003] 3 {Variable} 'Var_1' -> 'int'; [002] 11 {Function} extern not_inlined 'test' -> 'int'; [003] 12 {Variable} 'A' -> 'int'; [003] 13 {InlinedFunction} declared_inlined 'InlineFunction' -> 'int'; [004] {Block}; [005] {Variable} 'Var_2' -> 'int'; [004] {Parameter} 'Param' -> 'int'; [004] {Variable} 'Var_1' -> 'int'; [003] 11 {Parameter} 'Param_1' -> 'int'; [003] 11 {Parameter} 'Param_2' -> 'int'. From the previous logical views, we can see that the CodeView debug; information generated by the Clang compiler shows the variables **Var_1**; and **Var_2** are at the same lexical scope (**4**) in the function; **InlineFuction**. The DWARF generated by GCC/Clang and CodeView; generated by MSVC, show those variables at the correct lexical scope:; **3** and **4** respectively. Using the :program:`llvm-debuginfo-analyzer` selection facilities, we; can produce a simple tabular output showing just the logical elements; that have in their name the *var* pattern. The logical view is sorted; by the variables name. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format; --output-sort=name; --select-regex --select-nocase --select=Var; --report=list; --print=symbols; pr-43860-*.o. .. code-block:: none. Logical View:; [000] {File} 'pr-43860-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [004] {Variable} 'Var_1' -> 'int'; [004] {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr-43860.cpp'; [003] {Vari",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:52968,log,logical,52968,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['log'],['logical']
Testability,"'INT'; [003] 3 {Line}; [003] 5 {Line}; [003] 5 {Line}; [003] 13 {Line}; [003] 13 {Line}; [003] 13 {Line}; [003] 13 {Line}. DWARF - GCC (Linux); ^^^^^^^^^^^^^^^^^^^. .. code-block:: none. Logical View:; [000] {File} 'pr-44884-dwarf-gcc.o' -> elf32-littlearm. [001] {CompileUnit} 'pr-44884.cpp'; [002] {Producer} 'GNU C++14 10.2.1 20201103'; [002] 1 {Function} extern not_inlined 'bar' -> 'int'; [003] 1 {Parameter} 'Input' -> 'float'; [003] 1 {Line}; [003] 1 {Line}; [003] 1 {Line}; [002] 3 {Function} extern not_inlined 'foo' -> 'unsigned int'; [003] {Block}; [004] {Block}; [005] 9 {Variable} 'Added' -> 'FLOAT'; [005] 9 {Line}; [005] 9 {Line}; [005] 9 {Line}; [005] 10 {Line}; [005] 13 {Line}; [004] 7 {TypeAlias} 'FLOAT' -> 'float'; [003] 3 {Parameter} 'Param' -> 'char'; [003] 4 {TypeAlias} 'INT' -> 'int'; [003] 5 {Variable} 'Value' -> 'INT'; [003] 3 {Line}; [003] 5 {Line}; [003] 13 {Line}; [003] 14 {Line}; [003] 14 {Line}. From the previous logical views, we can see that the Clang compiler; emits **both typedefs at the same lexical scope (3)**, which is wrong.; GCC and MSVC emit correct lexical scope for both typedefs. Using the :program:`llvm-debuginfo-analyzer` selection facilities, we; can produce a simple tabular output showing just the logical types that; are **Typedef**. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format; --output-sort=name; --select-types=Typedef; --report=list; --print=types; pr-44884-*.o. Logical View:; [000] {File} 'pr-44884-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr_44884.cpp'; [003] {TypeAlias} 'FLOAT' -> 'float'; [003] {TypeAlias} 'INT' -> 'int'. Logical View:; [000] {File} 'pr-44884-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr_44884.cpp'; [004] {TypeAlias} 'FLOAT' -> 'float'; [003] {TypeAlias} 'INT' -> 'int'. Logical View:; [000] {File} 'pr-44884-dwarf-clang.o' -> elf64-x86-64. [001] {CompileUnit} 'pr_44884.cpp'; [003] 7 {TypeAlias} 'FLOAT' -> 'float'; [003] 4 {TypeAlias} 'INT' -> 'int'. Logical V",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:40594,log,logical,40594,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['log'],['logical']
Testability,"'pyf2',Linear(),-1.,1.,2); f.SetParameters(5.,2.). # plot the function; c = TCanvas(); f.Draw(); ```. Note that this time the constructor is told that there are two; parameters, and note in particular how these parameters are set. It is,; of course, also possible (and preferable if you only use the function; for plotting) to keep the parameters as data members of the callable; instance and use and set them directly from Python. #### Fitting Histograms. Fitting a histogram with a Python function is no more difficult than; plotting: instantiate a **`TF1`** with the Python callable and supply; that **`TF1`** as a parameter to the `Fit()` member function of the; histogram. After the fit, you can retrieve the fit parameters from the; **`TF1`** instance. For example:. ``` {.cpp}; from ROOT import TF1, TH1F, TCanvas. class Linear:; def __call__( self, x, par ):; return par[0] + x[0]*par[1]. # create a linear function for fitting; f = TF1('pyf3',Linear(),-1.,1.,2). # create and fill a histogram; h = TH1F('h','test',100,-1.,1.); f2 = TF1('cf2','6.+x*4.5',-1.,1.); h.FillRandom('cf2',10000). # fit the histo with the python 'linear' function; h.Fit(f). # print results; par = f.GetParameters(); print('fit results: const =', par[0], ',pitch =', par[1]); ```. ### Working with Trees. Next to making histograms, working with trees is probably the most; common part of any analysis. The **`TTree`** implementation uses; pointers and dedicated buffers to reduce the memory usage and to speed; up access. Consequently, mapping **`TTree`** functionality to Python is; not straightforward, and most of the following features are implemented; in ROOT release 4.01/04 and later only, whereas you will need 5.02 if; you require all of them. #### Accessing an Existing Tree. Let us assume that you have a file containing **`TTrees`**,; **`TChains`**, or **`TNtuples`** and want to read the contents for use; in your analysis code. This is commonly the case when you work with the; result of the reconstruct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:27954,test,test,27954,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['test'],['test']
Testability,"'s a bit of a grey area what; should be fixed before the next candidate and what can wait until the next; release. It'll depend on:. * The severity of the bug, how many people it affects and if it's a regression; or a known bug. Known bugs are ""unsupported features"" and some bugs can be; disabled if they have been implemented recently. * The stage in the release. Less critical bugs should be considered to be; fixed between RC1 and RC2, but not so much at the end of it. * If it's a correctness or a performance regression. Performance regression; tends to be taken more lightly than correctness. .. _scripts:. Scripts; =======. The scripts are in the ``utils/release`` directory. test-release.sh; ---------------. This script will check-out, configure and compile LLVM+Clang (+ most add-ons,; like ``compiler-rt``, ``libcxx``, ``libomp`` and ``clang-extra-tools``) in; three stages, and will test the final stage.; It'll have installed the final binaries on the Phase3/Releasei(+Asserts); directory, and that's the one you should use for the test-suite and other; external tests. To run the script on a specific release candidate run::. ./test-release.sh \; -release 3.3 \; -rc 1 \; -no-64bit \; -test-asserts \; -no-compare-files. Each system will require different options. For instance, x86_64 will; obviously not need ``-no-64bit`` while 32-bit systems will, or the script will; fail. The important flags to get right are:. * On the pre-release, you should change ``-rc 1`` to ``-final``. On RC2,; change it to ``-rc 2`` and so on. * On non-release testing, you can use ``-final`` in conjunction with; ``-no-checkout``, but you'll have to create the ``final`` directory by hand; and link the correct source dir to ``final/llvm.src``. * For release candidates, you need ``-test-asserts``, or it won't create a; ""Release+Asserts"" directory, which is needed for release testing and; benchmarking. This will take twice as long. * On the final candidate you just need Release builds, and that's th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst:1967,test,test-suite,1967,interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseProcess.rst,2,['test'],"['test-suite', 'tests']"
Testability,"'t, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option as a way to; validate diagnostic behavior. This option will use special comments within the; test file to verify that expected diagnostics appear in the correct source; locations. If all of the expected diagnostics match the actual output of Clang,; then the invocation will return normally. If there are discrepancies between; the expected and actual output, Clang will emit detailed information about; which expected diagnostics were not seen or which unexpected diagnostics were; seen, etc. A complete example is:. .. code-block: c++. // RUN: %clang_cc1 -verify %s; int A = B; // expected-error {{use of undeclared identifier 'B'}}. If the test is run and the expected error is emitted on the expected line, the; diagnostic verifier will pass. However, if the expected error does not appear; or appears in a different location than expected, or if additional diagnostics; appear, the diagnostic verifier will fail and emit information as to why. The ``-verify`` command optionally accepts a comma-delimited list of one or; more verification prefixes that can be used to craft those special comments.; Each pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:154726,test,test,154726,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['test'],['test']
Testability,"() in external scripts; 7. Provide JSROOT.Painter.setDefaultDrawOpt() to change class default draw option; 8. Provide example of custom entries in histogram context menu; 9. Provide alternative external location for zstd-codec, let use zstd even when not found locally; 10. Let skip HEAD requests when reading files, adding ""^"" symbol to file name (#223); 11. Show long histogram names in stats box when possible; 12. Fix logic how ""ndiv"" parameter of TAxis is handled, showing really the configured number of ticks; 13. Fix problem with curved TGraph drawings (#218); 14. Fix problems with TGraph drawing updates; 15. Base version for ROOT 6.26 release. ## Changes in 6.2.2; 1. Fix - proper fill TH1 which drawn with line option; 2. Fix - object drawing from inspector; 3. Fix - error with filling data of TGeoTrack in ""extract tracks"" example; 4. Fix - error in pad items context menu; 5. Fix - assigned dropped item name only when new painter created. ## Changes in 6.2.1; 1. Fix logy and logz handling on lego plots; 2. Fix error in statistic calculations for projections; 3. Fix zstd-codec loading with minified jsroot scripts. ## Changes in 6.2.0; 1. Support fully interactive second X/Y axis for histograms, graphs, functions and spline; 2. Support X+, Y+, RX, RY draw options for TF1; 3. Remove deprecated JSRootCore.js script, one have to use JSRoot.core.js; 4. Upgrade three.js to r127; 5. Upgrade d3.js to 6.7.0; 6. Implement ""nozoomx"" and ""nozoomy"" draw options for TPad; 7. Implement ""frame"" draw option for TGaxis - fix position of axis relative to the frame; 8. Preserve position of TPaletteAxis, if provided with histogram; make default position like in ROOT; 9. Support basic TLatex symbols in lego plos axis title; 10. Use frame margins when create 3D lego drawings; 11. Implement ""nomargins"" draw option for pad/canvas; 12. Support custom mouse click/dblcklick handlers in lego plots; 13. Implement marker styles 35 - 49; 14. Let switch orthographic camera in geometry via control g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:22429,log,logy,22429,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,2,['log'],"['logy', 'logz']"
Testability,"() is called to end the program during; the destruction of an object with static storage duration.; Source: C++11 3.6.1p4. #include <cstdlib>. class A {; public:; ~A() {; std::exit(1); // warn; }; };. undefbehavior.LocalStaticDestroyed; (C++); Undefined behavior: function containing a definition of static local object is; called during the destruction of an object with static storage duration so that; flow of control passes through the definition of the previously destroyed; static local object.; Source: C++11 3.6.3p2. void f();. class A {; public:; ~A() {; f(); // warn; }; };. class B {};. A a;. void f() {; static B b;; }. undefbehavior.ZeroAllocDereference; (C, C++); The effect of dereferencing a pointer returned as a request for zero size is; undefined.; Note: possibly an enhancement to ; unix.Malloc.; Source: C++03 3.7.3.1p2; C++11 3.7.4.1p2. #include <stdlib.h>. void test() {; int *p = (int *)malloc(0);; *p = 1; // warn; free(p);; }. void f(int);. void test() {; int *p = new int[0];; f(*p); // warn; delete[] p;; }. D8273. undefbehavior.DeadReferenced; (C++); Undefined behavior: the following usage of the pointer to the object whose; lifetime has ended can result in undefined behavior:; The object will be or was of a class type with a non-trivial destructor and; the pointer is used as the operand of a delete-expression; The object will be or was of a non-POD class type (C++11: any class type) and; the pointer is used to access a non-static data member or call a; non-static member function of the object; the pointer is implicitly converted to a pointer to a base class; type; the pointer is used as the operand of a static_cast (except; when the conversion is to void*, or to void* and; subsequently to char*, or unsigned char*); the pointer is used as the operand of a dynamic_cast; Source: C++03 3.8p5, p7; C++11 3.8p5, p7. #include <new>. class A {; public:; ~A();; };. class B : public A {};. void test() {; A *a = new A;; new(a) B;; delete a; // warn; }. #include <ne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:6421,test,test,6421,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability,"() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. alpha.unix.Stream; (C); Check stream handling functions:fopen; tmpfile; fclose; fread; fwrite; fseek; ftell; rewind; fgetpos; fsetpos; clearerr; feof; ferror; fileno. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. alpha.unix.cstring.BufferOverlap; (C); Checks for overlap in two buffer arguments; applies to:; memcpy; mempcpy. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. alpha.unix.cstring.NotNullTerminated; (C); Check for arguments which are not null-terminated strings; applies; to:; strlen; strnlen; strcpy; strncpy; strcat; strncat. void test() {; int y = strlen((char *)&test); // warn; }. alpha.unix.cstring.OutOfBounds; (C); Check for out-of-bounds access in string functions; applies; to:; strncopy; strncat. void test(char *y) {; char x[4];; if (strlen(y) == 4); strncpy(x, y, 5); // warn; }. Non-determinism Alpha Checkers. Name, DescriptionExample. alpha.nondeterminism.PointerIteration; (C++); Check for non-determinism caused by iterating unordered containers of pointers. // C++; void test() {; int a = 1, b = 2;; std::unordered_set UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPtrSet) // warn; f(i);; }. alpha.nondeterminism.PointerSorting; (C++); Check for non-determinism caused by sorting of pointers. // C++; void test() {; int a = 1, b = 2;; std::vector V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. ; . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:15384,test,test,15384,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,5,['test'],['test']
Testability,"() {; int a[1][1];; if (a[0] == 0) {}; // warn; }. different.ConversionToBool; (C, C++); Odd implicit conversion to boolean.; Note: possibly merge with ; alpha.core.BoolAssignment. bool test() {; return 1.; // warn; }. bool test() {; return """"; // warn; }. different.ArrayBound; (C++); Out-of-bound dynamic array access.; Note: possibly an enhancement to ; alpha.security.ArrayBoundV2. void test() {; int *p = new int[1];; int i = 1;; if(p[i]) {}; // warn; delete[] p;; }. different.StrcpyInputSize; (C); Buffer copy without checking the size of input.; Note: possibly an enhancement to ; alpha.unix.cstring.OutOfBounds. void test(char* string) {; char buf[24];; strcpy(buf, string); // warn; }. different.IntegerOverflow; (C); Integer overflow.; Note: partially handled by Clang core; (search for 'overflow in expression' warning in Clang tests).; Source: ; CWE-190. #include <limits.h>. int f(int x);. void test() {; f(INT_MAX + 1); // warn; }. #include <limits.h>. int test() {; int x = INT_MAX / 2 + 1;; return x * 2; // warn; }. different.SignExtension; (C); Unexpected sign extension might take place.; Source: ; CWE-194. unsigned long long test(long long sll) {; unsigned long long ull = sll; // warn; return ull;; }. void f(unsigned int i);. void test(int si) {; f(si); // warn; }. unsigned int test(int i) {; return i;; }. different.NumericTruncation; (C); Numeric truncation might take place.; Source: ; CWE-197. unsigned long test(unsigned long long ull) {; unsigned long ul = ull; // warn; return ul;; }. void f(int i);. void test(long long sll) {; f(sll); // warn; }. int f();. short test(long long sll) {; short ss = f();; return ss;; }. different.MissingCopyCtorAssignOp; (C++); A class has dynamically allocated data members but do not define a copy; constructor/assignment operator.; Source: Scott Meyers ""Effective C++"", item 11: Prevent exceptions from; leaving destructors. class C {; int *p; // warn; public:; C() { p = new int; }; ~C() { delete p; }; };. WinAPI. Name, Descripti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:24794,test,test,24794,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['test'],['test']
Testability,"(*foo)(void);; foo = 0;; foo(); // warn: function pointer is null; }. // C++; class C {; public:; void f();; };. void test() {; C *pc;; pc->f(); // warn: object pointer is uninitialized; }. // C++; class C {; public:; void f();; };. void test() {; C *pc = 0;; pc->f(); // warn: object pointer is null; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; long double ld1 = [obj1 longDoubleM];; // warn: receiver is uninitialized; }. // Objective-C; @interface MyClass : NSObject; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1.x; // warn: uninitialized object pointer; }. // Objective-C; @interface Subscriptable : NSObject; - (id)objectAtIndexedSubscript:(unsigned int)index;; @end. @interface MyClass : Subscriptable; @property (readwrite,assign) id x;; - (long double)longDoubleM;; @end. void test() {; MyClass *obj1;; id i = obj1[0]; // warn: uninitialized object pointer; }. core.DivideZero; (C, C++, ObjC); Check for division by zero.co. void test(int z) {; if (z == 0); int x = 1 / z; // warn; }. void test() {; int x = 1;; int y = x % 0; // warn; }. core.NonNullParamChecker; (C, C++, ObjC); Check for null pointers passed as arguments to a function whose arguments are; marked with the nonnull attribute. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. core.NullDereference; (C, C++, ObjC); Check for dereferences of null pointers. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. core.StackAddressEscape; (C); Check that addresses of stack memory do not escape the function. char const *p;. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:2680,test,test,2680,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['test'],['test']
Testability,"(2.8 | 3.56 s.(5.4 | 0.79s.(24.2 | 0.79 s.(24.2 |; | | MB | MB/s) | MB/s) | MB/s) | MB/s) |; | Split = 1 | | | | | |; +------------+--------+---------------+---------------+----------------+----------------+; | Comp = 1 | 17.73 | 6.44 s.(3.0 | 4.02 s.(4.8 | 0.90 s.(21.3 | 0.90 s.(21.3 |; | | MB | MB/s) | MB/s) | MB/s) | MB/s) |; | Split = 1 | | | | | |; +------------+--------+---------------+---------------+----------------+----------------+; | Comp = 2 | 13.78 | 11.34s.(1.7 | 9.51 s.(2.0 | 2.17 s.(8.8 | 2.17 s.(8.8 |; | | MB | MB/s) | MB/s) | MB/s) | MB/s) |; | Split = 1 | | | | | |; +------------+--------+---------------+---------------+----------------+----------------+. The **Total Time** is the real time in seconds to run the program.; **Effective time** is the real time minus the time spent in non I/O; operations (essentially the random number generator). The program; `Event` generates in average 600 tracks per event. Each track has 17; data members. The read benchmark runs in the interactive version of; ROOT. The ‘Total Time to Read All' is the real time reported by the; execution of the script `&ROOTSYS/test/eventa`. We did not correct this time for the overhead coming from the; interpreter itself. The **Total time to read sample** is the execution; time of the script `$ROOTSYS/test/eventb`. This script loops on all; events. For each event, the branch containing the number of tracks is; read. In case the number of tracks is less than 585, the full event is; read in memory. This test is obviously not possible in non-split mode.; In non-split mode, the full event must be read in memory. The times; reported in the table correspond to complete I/O operations necessary to; deal with **machine independent binary files**. On **Linux**, this also; includes byte-swapping operations. The ROOT file allows for direct; access to any event in the file and direct access to any part of an; event when split=1. Note also that the uncompressed file generated with split=0 is 48.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:138526,benchmark,benchmark,138526,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['benchmark'],['benchmark']
Testability,"(APPEND copy_commands COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_SOURCE_DIR}/interpreter/cling/include/cling/cint/${file} ${CMAKE_BINARY_DIR}/etc/cling/cint/${file}); list(APPEND files_to_copy ${CMAKE_SOURCE_DIR}/interpreter/cling/include/cling/cint/${file}); install(FILES ${CMAKE_SOURCE_DIR}/interpreter/cling/include/cling/cint/${file} DESTINATION ${CMAKE_INSTALL_SYSCONFDIR}/cling/cint); endforeach(). set(stamp_file ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/LLVMRES.stamp); if(MSVC); add_custom_command(OUTPUT ${stamp_file}; COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_BINARY_DIR}/etc/cling/lib/clang/${CLANG_RESOURCE_DIR_VERSION}/include; ${copy_commands}; COMMAND ${CMAKE_COMMAND} -E copy_directory; ${CLANG_RESOURCE_DIR}; ${CMAKE_BINARY_DIR}/etc/cling/lib/clang/${CLANG_RESOURCE_DIR_VERSION}/include		; COMMAND ${CMAKE_COMMAND} -E touch ${stamp_file}; DEPENDS ${files_to_copy}; COMMENT ""Copying LLVM resource and header files""); else(); add_custom_command(OUTPUT ${stamp_file}; COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_BINARY_DIR}/etc/cling/lib/clang/${CLANG_RESOURCE_DIR_VERSION}/include; COMMAND ${CMAKE_COMMAND} -E copy_directory; ${CLANG_RESOURCE_DIR}; ${CMAKE_BINARY_DIR}/etc/cling/lib/clang/${CLANG_RESOURCE_DIR_VERSION}/include; ${copy_commands}; COMMAND ${CMAKE_COMMAND} -E touch ${stamp_file}; DEPENDS ${files_to_copy}; COMMENT ""Copying LLVM resource and header files""); endif(); add_custom_target(LLVMRES DEPENDS ${stamp_file} CLING); # CLING is a shorthand for CLING_LIBRARIES and some other clang-specific; # dependencies which ensure the correct order of building. Then the cling header; # files (such as RuntimeUniverse.h) are moved to a semi-private place in ROOT; # #ROOTSYS/etc. This is the place where ROOT will use them from and we should; # add an explcit dependency to something cling-related which ROOT knows.; # ClingUtils seems a good candidate because it is very foundational.; add_dependencies(ClingUtils LLVMRES); ROOT_ADD_TEST_SUBDIRECTORY(test). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/CMakeLists.txt:8561,test,test,8561,core/clingutils/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/CMakeLists.txt,1,['test'],['test']
Testability,(Libraries TMVA). #--- CUDA tests. ---------------------------; if (tmva-gpu). include_directories(${CUDA_INCLUDE_DIRS}). SET(DNN_CUDA_LIBRARIES ${CUDA_CUBLAS_LIBRARIES} ). list(APPEND Libraries ${DNN_CUDA_LIBRARIES} CUDA::cuda_driver CUDA::cudart). # DNN - Activation Functions Cuda; add_executable(testActivationFunctionsCuda TestActivationFunctionsCuda.cxx); TARGET_LINK_LIBRARIES(testActivationFunctionsCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-ActivationFunctionsCuda COMMAND testActivationFunctionsCuda). # DNN - Loss Functions Cuda; add_executable(testLossFunctionsCuda TestLossFunctionsCuda.cxx); TARGET_LINK_LIBRARIES(testLossFunctionsCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-LossFunctionsCuda COMMAND testLossFunctionsCuda). # DNN - Derivatives Cuda; add_executable(testDerivativesCuda TestDerivativesCuda.cxx); TARGET_LINK_LIBRARIES(testDerivativesCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-DerivativesCuda COMMAND testDerivativesCuda). # DNN - Backpropagation Cuda; add_executable(testBackpropagationCuda TestBackpropagationCuda.cxx); TARGET_LINK_LIBRARIES(testBackpropagationCuda ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-BackpropagationCuda COMMAND testBackpropagationCuda). # DNN - Backpropagation DL Cuda; add_executable(testBackpropagationDLCuda TestBackpropagationDLCuda.cxx ); TARGET_LINK_LIBRARIES(testBackpropagationDLCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-Backpropagation-DLCuda COMMAND testBackpropagationDLCuda). # DNN - Batch normalization Cuda; add_executable(testBatchNormalizationCuda TestBatchNormalizationCuda.cxx ); TARGET_LINK_LIBRARIES(testBatchNormalizationCuda ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-BatchNormalization-Cuda COMMAND testBatchNormalizationCuda). # DNN - Minimization Cuda; add_executable(testMinimizationCuda TestMinimizationCuda.cxx); TARGET_LINK_LIBRARIES(testMinimizationCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-MinimizationCuda COMMAND testMinimizationCuda). # DNN - Arithmetic Cuda; add_executable(testArithmeticCuda TestMatrixArithmeti,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt:1435,test,testBackpropagationCuda,1435,tmva/tmva/test/DNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt,1,['test'],['testBackpropagationCuda']
Testability,"(Note: negative; matches from ``CHECK-NOT`` are not affected by this option!). Passing this option is equivalent to inserting ``{{^ *}}`` or; ``{{^}}`` before, and ``{{ *$}}`` or ``{{$}}`` after every positive; check pattern. .. option:: --strict-whitespace. By default, FileCheck canonicalizes input horizontal whitespace (spaces and; tabs) which causes it to ignore these differences (a space will match a tab).; The :option:`--strict-whitespace` argument disables this behavior. End-of-line; sequences are canonicalized to UNIX-style ``\n`` in all modes. .. option:: --ignore-case. By default, FileCheck uses case-sensitive matching. This option causes; FileCheck to use case-insensitive matching. .. option:: --implicit-check-not check-pattern. Adds implicit negative checks for the specified patterns between positive; checks. The option allows writing stricter tests without stuffing them with; ``CHECK-NOT``\ s. For example, ""``--implicit-check-not warning:``"" can be useful when testing; diagnostic messages from tools that don't have an option similar to ``clang; -verify``. With this option FileCheck will verify that input does not contain; warnings not covered by any ``CHECK:`` patterns. .. option:: --dump-input <value>. Dump input to stderr, adding annotations representing currently enabled; diagnostics. When there are multiple occurrences of this option, the; ``<value>`` that appears earliest in the list below has precedence. The; default is ``fail``. * ``help`` - Explain input dump and quit; * ``always`` - Always dump input; * ``fail`` - Dump input on failure; * ``never`` - Never dump input. .. option:: --dump-input-context <N>. In the dump requested by ``--dump-input``, print ``<N>`` input lines before; and ``<N>`` input lines after any lines specified by ``--dump-input-filter``.; When there are multiple occurrences of this option, the largest specified; ``<N>`` has precedence. The default is 5. .. option:: --dump-input-filter <value>. In the dump requested by ``--dump",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:4291,test,testing,4291,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['test'],['testing']
Testability,"(all costs equal and set to ""one""), it is equivalent to the ""real-AdaBoost"" (i.e. using the option !UseYesNoLeaf (which uses the leave node purity rather than a signal or background attribute in the leaf node of each individual tree). Unfortunatly, no reasonable performance has been achieved yet when choosing different cost parameters. c) BDT's with little tree depth (as favoured for good performance) do not *like* it if; there are very clean signal and background separation cuts available, which however ; have NOT been applied yet as preselection. Now there is a possibility to choose the option; ""DoPreselection"" that looks for suitable preselection cuts and applies them prior to ; the Decision Tree training. While that works fine, this clearly gives ""sharp"" peaks at +1 (-1); for the MVA output distribution and therefore the ""smoothing"" of this distribution used to; produce the ROC curve and efficiency estimates are somewhat thwarted.; ; --> It's better if you do these preselection cuts YOURSELF when defining training and test; sample!. d) Removed completely the (hopefully never used) option of treating negative events weights; via: PairNegWeightsInNode. e) Renamed option: IgnoreNegEvents --> IgnoreNegEventsInTraining; and removed the IDENTICAL option NoNegeventsInTraining. 6) SVM; All but the Gauss kernel options have been ""removed"" (guess that was done already some; time ago, probably with the introduction of ""regression"", but was not properly announced; so far. 5) minor bug fixes . a) fix calculation of mean values of the MVA distribution; for signal and background samples, which is used to; decide if a cut on the MVA variable selects signal or; background. Due to the bug it sometimes was swapped. b) equalize the interpolation of the PDF-class that is used to; smooth the Gauss-Transformation, between the .xml weights and; the Standalone class. Now they give the same results even for; large data samples where numerical difference previously ; resulted in substanti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt:3257,test,test,3257,documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt,1,['test'],['test']
Testability,"(compiled) (NA):(NA) 0 public: virtual void SetBBoxY1(const Int_t y);; (compiled) (NA):(NA) 0 public: virtual void SetBBoxY2(const Int_t y);; (compiled) (NA):(NA) 0 public: static class TClass *Class();; (compiled) (NA):(NA) 0 public: static const char *Class_Name();; (compiled) (NA):(NA) 0 public: static Version_t Class_Version();; (compiled) (NA):(NA) 0 public: static void Dictionary();; (compiled) (NA):(NA) 0 public: virtual class TClass *IsA() const;; (compiled) (NA):(NA) 0 public: virtual void ShowMembers(class TMemberInspector &insp) const;; (compiled) (NA):(NA) 0 public: virtual void Streamer(class TBuffer &);; (compiled) (NA):(NA) 0 public: void StreamerNVirtual(class TBuffer &ClassDef_StreamerNVirtual_b);; (compiled) (NA):(NA) 0 public: static const char *DeclFileName();; (compiled) (NA):(NA) 0 public: static int ImplFileLine();; (compiled) (NA):(NA) 0 public: static const char *ImplFileName();; (compiled) (NA):(NA) 0 public: static int DeclFileLine();; root [] .> test.log; root [] l.Dump();; root [] .>; root [] ?; ```. Here we see:. - Use `.class` as quick help and reference; - Unix like I/O redirection using `.> out.txt` and unredirection with `.>`; - Use `?` to get help on all ‘‘raw'' interpreter commands; - Use @ to abort a multi-line command. Now let us execute a multi-line command:. ``` {.cpp}; root [] {; root [] ? TLine l;; root [] ? for (int i = 0; i < 5; i++) {; root [] ? l.SetX1(i);; root [] ? l.SetY1(i+1);; root [] ? l.Print();; root [] ? }; root [] ? }; TLine X1=0.000000 Y1=1.000000 X2=0.000000 Y2=0.000000; TLine X1=1.000000 Y1=2.000000 X2=0.000000 Y2=0.000000; TLine X1=2.000000 Y1=3.000000 X2=0.000000 Y2=0.000000; TLine X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; ```. Here we note:. - A multi-line command starts with a { and ends with a }.; - Inside continuation, every line has to be correctly terminated with a ; (like in ""real''; C++).; - All objects are created in *global*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:6378,log,log,6378,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['log'],['log']
Testability,"(default: off) When this is enabled,; floating point operations may flush `denormal; <https://en.wikipedia.org/wiki/Denormal_number>`_ inputs and/or outputs to 0.; Operations on denormal numbers are often much slower than the same operations; on normal numbers. * ``-fcuda-approx-transcendentals`` (default: off) When this is enabled, the; compiler may emit calls to faster, approximate versions of transcendental; functions, instead of using the slower, fully IEEE-compliant versions. For; example, this flag allows clang to emit the ptx ``sin.approx.f32``; instruction. This is implied by ``-ffast-math``. Standard library support; ========================. In clang and nvcc, most of the C++ standard library is not supported on the; device side. ``<math.h>`` and ``<cmath>``; ----------------------------. In clang, ``math.h`` and ``cmath`` are available and `pass; <https://github.com/llvm/llvm-test-suite/blob/main/External/CUDA/math_h.cu>`_; `tests; <https://github.com/llvm/llvm-test-suite/blob/main/External/CUDA/cmath.cu>`_; adapted from libc++'s test suite. In nvcc ``math.h`` and ``cmath`` are mostly available. Versions of ``::foof``; in namespace std (e.g. ``std::sinf``) are not available, and where the standard; calls for overloads that take integral arguments, these are usually not; available. .. code-block:: c++. #include <math.h>; #include <cmath.h>. // clang is OK with everything in this function.; __device__ void test() {; std::sin(0.); // nvcc - ok; std::sin(0); // nvcc - error, because no std::sin(int) override is available.; sin(0); // nvcc - same as above. sinf(0.); // nvcc - ok; std::sinf(0.); // nvcc - no such function; }. ``<std::complex>``; ------------------. nvcc does not officially support ``std::complex``. It's an error to use; ``std::complex`` in ``__device__`` code, but it often works in ``__host__; __device__`` code due to nvcc's interpretation of the ""wrong-side rule"" (see; below). However, we have heard from implementers that it's possible to get; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst:5953,test,test-suite,5953,interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CompileCudaWithLLVM.rst,1,['test'],['test-suite']
Testability,"(double )`. #### Wrapping Multi-dimensional Functions. The class `ROOT::Math::Functor` is used to wrap in a very simple and convenient way multi-dimensional function objects. It can wrap all the following types:; * Any C++ callable object implementing `double operator()( const double * )`.; * A free C function of type `double ()(const double * )`.; * A member function with the correct signature like `Foo::Eval(const double * )`. In this case one pass the object pointer and a pointer to the member function `(&Foo::Eval)`. The function dimension is required when constructing the functor. Example of using `Functor`:; ```{.cpp}; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test from a member function; ROOT::Math::Functor f3(&myf,&MyFunction::Eval,2);. double x[] = {1,2};. cout << f1(x) << endl;; cout << f2(x) << endl;; cout << f3(x) << endl;. return 0;; }; ```. #### Wrapping Multi-dimensional Gradient Functions. The class `ROOT::Math::GradFunctor` is used to wrap in a very C++ callable object to make gradient functions. It can be constructed in three different way:; * From an object implementing both `double operator()( const double * )` for the function evaluation and `double Derivative(const double *, int icoord)` for the partial derivatives.; * From an object implementing any member function like `Foo::XXX(const double *)` for the function evaluation and any member function like `Foo::XXX(const double *, int icoord)` for the partial derivatives.; * From an function object implementing `double operator()( const double * )` for the function evaluati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:45724,test,test,45724,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['test'],['test']
Testability,"(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test.cc:7:7; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. Origin value: 0x9e00001, Taint value was created at; #0 0x55676db85a08 in main test.cc:6:3; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. By ``-mllvm -dfsan-track-origins=1`` DataFlowSanitizer collects only; intermediate stores a labeled value went through. Origin tracking slows down; program execution by a factor of 2x on top of the usual DataFlowSanitizer; slowdown and increases memory overhead by 1x. By ``-mllvm -dfsan-track-origins=2``; DataFlowSanitizer also collects intermediate loads a labeled value went through.; This mode slows down program execution by a factor of 4x. Current status; ==============. DataFlowSanitizer is a work in progress, currently under development for; x8",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:12758,test,test,12758,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,1,['test'],['test']
Testability,"(or; ""test-suite"") and are in the ``test-suite``; `repository on GitHub <https://github.com/llvm/llvm-test-suite.git>`_.; For historical reasons, these tests are also referred to as the ""nightly; tests"" in places, which is less ambiguous than ""test-suite"" and remains; in use although we run them much more often than nightly. Unit tests; ----------. Unit tests are written using `Google Test <https://github.com/google/googletest/blob/master/docs/primer.md>`_; and `Google Mock <https://github.com/google/googletest/blob/master/docs/gmock_for_dummies.md>`_; and are located in the ``llvm/unittests`` directory.; In general unit tests are reserved for targeting the support library and other; generic data structure, we prefer relying on regression tests for testing; transformations and analysis on the IR. Regression tests; ----------------. The regression tests are small pieces of code that test a specific; feature of LLVM or trigger a specific bug in LLVM. The language they are; written in depends on the part of LLVM being tested. These tests are driven by; the :doc:`Lit <CommandGuide/lit>` testing tool (which is part of LLVM), and; are located in the ``llvm/test`` directory. Typically when a bug is found in LLVM, a regression test containing just; enough code to reproduce the problem should be written and placed; somewhere underneath this directory. For example, it can be a small; piece of LLVM IR distilled from an actual application or benchmark. Testing Analysis; ----------------. An analysis is a pass that infer properties on some part of the IR and not; transforming it. They are tested in general using the same infrastructure as the; regression tests, by creating a separate ""Printer"" pass to consume the analysis; result and print it on the standard output in a textual format suitable for; FileCheck.; See `llvm/test/Analysis/BranchProbabilityInfo/loop.ll <https://github.com/llvm/llvm-project/blob/main/llvm/test/Analysis/BranchProbabilityInfo/loop.ll>`_; for an example o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:2127,test,tested,2127,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['test'],['tested']
Testability,"(smaller) input that triggers previously; discovered features (set ``-reduce_inputs=0`` to disable).; ``pulse``; The fuzzer has generated 2\ :sup:`n` inputs (generated periodically to reassure; the user that the fuzzer is still working).; ``DONE``; The fuzzer has completed operation because it has reached the specified; iteration limit (``-runs``) or time limit (``-max_total_time``).; ``RELOAD``; The fuzzer is performing a periodic reload of inputs from the corpus; directory; this allows it to discover any inputs discovered by other; fuzzer processes (see `Parallel Fuzzing`_). Each output line also reports the following statistics (when non-zero):. ``cov:``; Total number of code blocks or edges covered by executing the current corpus.; ``ft:``; libFuzzer uses different signals to evaluate the code coverage:; edge coverage, edge counters, value profiles, indirect caller/callee pairs, etc.; These signals combined are called *features* (`ft:`).; ``corp:``; Number of entries in the current in-memory test corpus and its size in bytes.; ``lim:``; Current limit on the length of new entries in the corpus. Increases over time; until the max length (``-max_len``) is reached.; ``exec/s:``; Number of fuzzer iterations per second.; ``rss:``; Current memory consumption. For ``NEW`` and ``REDUCE`` events, the output line also includes information; about the mutation operation that produced the new input:. ``L:``; Size of the new input in bytes.; ``MS: <n> <operations>``; Count and list of the mutation operations used to generate the input. Examples; ========; .. contents::; :local:; :depth: 1. Toy example; -----------. A simple function that does something interesting if it receives the input; ""HI!""::. cat << EOF > test_fuzzer.cc; #include <stdint.h>; #include <stddef.h>; extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {; if (size > 0 && data[0] == 'H'); if (size > 1 && data[1] == 'I'); if (size > 2 && data[2] == '!'); __builtin_trap();; return 0;; }; EOF; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:17059,test,test,17059,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['test'],['test']
Testability,(testForwardPassCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ForwardCudnn COMMAND testForwardPassCudnn). add_executable(testConvBackpropagationCudnn TestConvBackpropagationCudnn.cxx); target_link_libraries(testConvBackpropagationCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ConvBackpropagationCudnn COMMAND testConvBackpropagationCudnn). add_executable(testConvLayerCudnn TestConvLayerCudnn.cxx); target_link_libraries(testConvLayerCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-ConvLayerCudnn COMMAND testConvLayerCudnn). add_executable(testPoolingLayerCudnn TestPoolingLayerCudnn.cxx); target_link_libraries(testPoolingLayerCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-PoolingLayerCudnn COMMAND testPoolingLayerCudnn). # test mixed architecture Cudnn Cpu; add_executable(testMixedArchitectures TestMixedArchitectures.cxx); target_link_libraries(testMixedArchitectures ${Libraries} ${DNN_CUDA_LIBRARIES}); ROOT_ADD_TEST(TMVA-DNN-CNN-MixedArchitectures COMMAND testMixedArchitectures). endif(). include_directories(${CUDA_INCLUDE_DIRS}). endif(). #-- -test of reference architecture; if (Test_Reference). ROOT_EXECUTABLE(testIm2Col TestIm2Col.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Im2Col COMMAND testIm2Col). ROOT_EXECUTABLE(testPoolingLayer TestPoolingLayer.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-PoolingLayer COMMAND testPoolingLayer). ROOT_EXECUTABLE(testReshape TestReshape.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-Reshape COMMAND testReshape). ROOT_EXECUTABLE(testRotWeights TestRotateWeights.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-CNN-RotWeights COMMAND testRotWeights). #-- features not implemeted in ref architectures; #ROOT_EXECUTABLE(testForwardPass TestForwardPass.cxx LIBRARIES ${Libraries}); #ROOT_ADD_TEST(TMVA-DNN-CNN-Forward COMMAND testForwardPass). #ROOT_EXECUTABLE(testConvNetLoss TestConvNetLoss.cxx LIBRARIES ${Librari,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt:3157,test,testMixedArchitectures,3157,tmva/tmva/test/DNN/CNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CNN/CMakeLists.txt,2,['test'],['testMixedArchitectures']
Testability,"(tools, examples, and tests).; #; # This is primarily to support building smaller or faster project files.; option(LLVM_INCLUDE_TOOLS ""Generate build targets for the LLVM tools."" ON); option(LLVM_BUILD_TOOLS; ""Build the LLVM tools. If OFF, just generate build targets."" ON). option(LLVM_INCLUDE_UTILS ""Generate build targets for the LLVM utils."" ON); option(LLVM_BUILD_UTILS; ""Build LLVM utility binaries. If OFF, just generate build targets."" ON). option(LLVM_INCLUDE_RUNTIMES ""Generate build targets for the LLVM runtimes."" ON); option(LLVM_BUILD_RUNTIMES; ""Build the LLVM runtimes. If OFF, just generate build targets."" ON). option(LLVM_BUILD_RUNTIME; ""Build the LLVM runtime libraries."" ON); option(LLVM_BUILD_EXAMPLES; ""Build the LLVM example programs. If OFF, just generate build targets."" OFF); option(LLVM_INCLUDE_EXAMPLES ""Generate build targets for the LLVM examples"" ON). if(LLVM_BUILD_EXAMPLES); add_compile_definitions(BUILD_EXAMPLES); endif(LLVM_BUILD_EXAMPLES). option(LLVM_BUILD_TESTS; ""Build LLVM unit tests. If OFF, just generate build targets."" OFF); option(LLVM_INCLUDE_TESTS ""Generate build targets for the LLVM unit tests."" ON). option(LLVM_INSTALL_GTEST; ""Install the llvm gtest library. This should be on if you want to do; stand-alone builds of the other projects and run their unit tests."" OFF). option(LLVM_BUILD_BENCHMARKS ""Add LLVM benchmark targets to the list of default; targets. If OFF, benchmarks still could be built using Benchmarks target."" OFF); option(LLVM_INCLUDE_BENCHMARKS ""Generate benchmark targets. If OFF, benchmarks can't be built."" ON). option (LLVM_BUILD_DOCS ""Build the llvm documentation."" OFF); option (LLVM_INCLUDE_DOCS ""Generate build targets for llvm documentation."" ON); option (LLVM_ENABLE_DOXYGEN ""Use doxygen to generate llvm API documentation."" OFF); option (LLVM_ENABLE_SPHINX ""Use Sphinx to generate llvm documentation."" OFF); option (LLVM_ENABLE_OCAMLDOC ""Build OCaml bindings documentation."" ON); option (LLVM_ENABLE_BINDINGS ""Build bind",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:31664,test,tests,31664,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['test'],['tests']
Testability,") in the logging stream may be necessary to decode the content; of the dump. So if the symbolizing filter triggers other processing, it may; need to feed some distilled form of the contextual information to those; processes. An example of a type identifier is ``sancov``, for dumps from LLVM; `SanitizerCoverage <https://clang.llvm.org/docs/SanitizerCoverage.html>`_. Example::. {{{dumpfile:sancov:sancov.8675}}}. Contextual elements; ===================. These are elements that supply information necessary to convert presentation; elements to symbolic form. Unlike presentation elements, they are not directly; related to the surrounding text. Contextual elements should appear alone on; lines with no other non-whitespace text, so that the symbolizing filter might; elide the whole line from its output without hiding any other log text. The contextual elements themselves do not necessarily need to be presented in; human-readable output. However, the information they impart may be essential to; understanding the logging text even after symbolization. So it's recommended; that this information be preserved in some form when the original raw log with; markup may no longer be readily accessible for whatever reason. Contextual elements should appear in the logging stream before they are needed.; That is, if some piece of context may affect how the symbolizing filter would; interpret or present a later presentation element, the necessary contextual; elements should have appeared somewhere earlier in the logging stream. It should; always be possible for the symbolizing filter to be implemented as a single pass; over the raw logging stream, accumulating context and massaging text as it goes. ``{{{reset}}}``. This should be output before any other contextual element. The need for this; contextual element is to support implementations that handle logs coming from; multiple processes. Such implementations might not know when a new process; starts or ends. Because some identifying info",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:17550,log,logging,17550,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['log'],['logging']
Testability,") is still open and waiting for new code to be; added. With just these two changes, let's see how Kaleidoscope works now!. ::. ready> 4+5;; Read top-level expression:; define double @0() {; entry:; ret double 9.000000e+00; }. Evaluated to 9.000000. Well this looks like it is basically working. The dump of the function; shows the ""no argument function that always returns double"" that we; synthesize for each top-level expression that is typed in. This; demonstrates very basic functionality, but can we do more?. ::. ready> def testfunc(x y) x + y*2;; Read function definition:; define double @testfunc(double %x, double %y) {; entry:; %multmp = fmul double %y, 2.000000e+00; %addtmp = fadd double %multmp, %x; ret double %addtmp; }. ready> testfunc(4, 10);; Read top-level expression:; define double @1() {; entry:; %calltmp = call double @testfunc(double 4.000000e+00, double 1.000000e+01); ret double %calltmp; }. Evaluated to 24.000000. ready> testfunc(5, 10);; ready> LLVM ERROR: Program used external function 'testfunc' which could not be resolved!. Function definitions and calls also work, but something went very wrong on that; last line. The call looks valid, so what happened? As you may have guessed from; the API a Module is a unit of allocation for the JIT, and testfunc was part; of the same module that contained anonymous expression. When we removed that; module from the JIT to free the memory for the anonymous expression, we deleted; the definition of ``testfunc`` along with it. Then, when we tried to call; testfunc a second time, the JIT could no longer find it. The easiest way to fix this is to put the anonymous expression in a separate; module from the rest of the function definitions. The JIT will happily resolve; function calls across module boundaries, as long as each of the functions called; has a prototype, and is added to the JIT before it is called. By putting the; anonymous expression in a different module we can delete it without affecting; the rest of th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:16204,test,testfunc,16204,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,2,['test'],['testfunc']
Testability,") looking for tests. When :program:`lit`; enters a sub-directory, it first checks to see if a nested test suite is; defined in that directory. If so, it loads that test suite recursively,; otherwise it instantiates a local test config for the directory (see; :ref:`local-configuration-files`). Tests are identified by the test suite they are contained within, and the; relative path inside that suite. Note that the relative path may not refer to; an actual file on disk; some test formats (such as *GoogleTest*) define; ""virtual tests"" which have a path that contains both the path to the actual; test file and a subpath to identify the virtual test. .. _local-configuration-files:. LOCAL CONFIGURATION FILES; ~~~~~~~~~~~~~~~~~~~~~~~~~. When :program:`lit` loads a subdirectory in a test suite, it instantiates a; local test configuration by cloning the configuration for the parent directory; --- the root of this configuration chain will always be a test suite. Once the; test configuration is cloned :program:`lit` checks for a *lit.local.cfg* file; in the subdirectory. If present, this file will be loaded and can be used to; specialize the configuration for each individual directory. This facility can; be used to define subdirectories of optional tests, or to change other; configuration parameters --- for example, to change the test format, or the; suffixes which identify test files. SUBSTITUTIONS; ~~~~~~~~~~~~~. :program:`lit` allows patterns to be substituted inside RUN commands. It also; provides the following base set of substitutions, which are defined in; TestRunner.py:. ======================= ==============; Macro Substitution; ======================= ==============; %s source path (path to the file currently being run); %S source dir (directory of the file currently being run); %p same as %S; %{pathsep} path separator; %{fs-src-root} root component of file system paths pointing to the LLVM checkout; %{fs-tmp-root} root component of file system paths pointing to the tes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:18512,test,test,18512,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['test'],['test']
Testability,") or a publicly available simulator/hardware; (either free or cheap enough) - preferably both. This allows; developers to validate assumptions, understand constraints and review code; that can affect the target. In addition, the rules for a back-end to be promoted to **official** are:. * The target must have addressed every other minimum requirement and; have been stable in tree for at least 3 months. This cool down; period is to make sure that the back-end and the target community can; endure continuous upstream development for the foreseeable future. * The target's code must have been completely adapted to this policy; as well as the :doc:`coding standards<CodingStandards>`. Any exceptions that; were made to move into experimental mode must have been fixed **before**; becoming official. * The test coverage needs to be broad and well written (small tests,; well documented). The build target ``check-all`` must pass with the; new target built, and where applicable, the ``test-suite`` must also; pass without errors, in at least one configuration (publicly; demonstrated, for example, via buildbots). * Public buildbots need to be created and actively maintained, unless; the target requires no additional buildbots (ex. ``check-all`` covers; all tests). The more relevant and public the new target's CI infrastructure; is, the more the LLVM community will embrace it. To **continue** as a supported and official target:. * The maintainer(s) must continue following these rules throughout the lifetime; of the target. Continuous violations of aforementioned rules and policies; could lead to complete removal of the target from the code base. * Degradation in support, documentation or test coverage will make the target as; nuisance to other targets and be considered a candidate for deprecation and; ultimately removed. In essence, these rules are necessary for targets to gain and retain their; status, but also markers to define bit-rot, and will be used to clean up the; tree from u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:41938,test,test-suite,41938,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['test'],['test-suite']
Testability,") returnsRetained {; return [[NSString alloc] initWithCString:""no leak here""];; }; - (NSString*) alsoReturnsRetained {; return [[NSString alloc] initWithCString:""flag a leak""];; }; @end. Running scan-build on this source file produces the following output:. Attribute 'ns_returns_not_retained'; (Clang-specific); The 'ns_returns_not_retained' attribute is the complement of 'ns_returns_retained'. Where a function or; method may appear to obey the Cocoa conventions and return a retained Cocoa; object, this attribute can be used to indicate that the object reference; returned should not be considered as an ""owning"" reference being; returned to the caller. The Foundation framework defines a; macro NS_RETURNS_NOT_RETAINED that is functionally equivalent to; the one shown below.; Usage is identical to ns_returns_retained. When using the; attribute, be sure to declare it within the proper macro that checks for; its availability, as it is not available in earlier versions of the analyzer:. $ cat test.m; #ifndef __has_feature // Optional.; #define __has_feature(x) 0 // Compatibility with non-clang compilers.; #endif. #ifndef NS_RETURNS_NOT_RETAINED; #if __has_feature(attribute_ns_returns_not_retained); #define NS_RETURNS_NOT_RETAINED __attribute__((ns_returns_not_retained)); #else; #define NS_RETURNS_NOT_RETAINED; #endif; #endif. Attribute 'cf_returns_retained'; (Clang-specific); The GCC-style (Clang-specific) attribute 'cf_returns_retained' allows one to; annotate an Objective-C method or C function as returning a retained Core; Foundation object that the caller is responsible for releasing. The; CoreFoundation framework defines a macro CF_RETURNS_RETAINED; that is functionally equivalent to the one shown below.; Placing on Objective-C methods: With respect to Objective-C methods.,; this attribute is identical in its behavior and usage to 'ns_returns_retained'; except for the distinction of returning a Core Foundation object instead of a; Cocoa object. This distinction is imp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html:5702,test,test,5702,interpreter/llvm-project/clang/www/analyzer/annotations.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/annotations.html,1,['test'],['test']
Testability,") {; c *pc = (c *) p; // warn; }. .. _alpha-core-Conversion:. alpha.core.Conversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Loss of sign/precision in implicit conversions. .. code-block:: c. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. .. _alpha-core-DynamicTypeChecker:. alpha.core.DynamicTypeChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cases where the dynamic and the static type of an object are unrelated. .. code-block:: objc. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. .. _alpha-core-FixedAddr:. alpha.core.FixedAddr (C); """"""""""""""""""""""""""""""""""""""""""""""""; Check for assignment of a fixed address to a pointer. .. code-block:: c. void test() {; int *p;; p = (int *) 0x10000; // warn; }. .. _alpha-core-IdenticalExpr:. alpha.core.IdenticalExpr (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about unintended use of identical expressions in operators. .. code-block:: cpp. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. .. _alpha-core-PointerArithm:. alpha.core.PointerArithm (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for pointer arithmetic on locations other than array elements. .. code-block:: c. void test() {; int x;; int *p;; p = &x + 1; // warn; }. .. _alpha-core-PointerSub:. alpha.core.PointerSub (C); """"""""""""""""""""""""""""""""""""""""""""""""""; Check for pointer subtractions on two pointers pointing to different memory chunks. .. code-block:: c. void test() {; int x, y;; int d = &y - &x; // warn; }. .. _alpha-core-SizeofPtr:. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:49713,test,test,49713,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
Testability,") | (a & 0x40);; b = (b & ~0x80) | (a & 0x80);; return (b);; }. define zeroext i8 @p1(i8 zeroext %b, i8 zeroext %a) nounwind readnone ssp {; entry:; %0 = and i8 %b, 63 ; <i8> [#uses=1]; %1 = and i8 %a, -64 ; <i8> [#uses=1]; %2 = or i8 %1, %0 ; <i8> [#uses=1]; ret i8 %2; }. define zeroext i8 @p2(i8 zeroext %b, i8 zeroext %a) nounwind readnone ssp {; entry:; %0 = and i8 %b, 63 ; <i8> [#uses=1]; %.masked = and i8 %a, 64 ; <i8> [#uses=1]; %1 = and i8 %a, -128 ; <i8> [#uses=1]; %2 = or i8 %1, %0 ; <i8> [#uses=1]; %3 = or i8 %2, %.masked ; <i8> [#uses=1]; ret i8 %3; }. //===---------------------------------------------------------------------===//. IPSCCP does not currently propagate argument dependent constants through; functions where it does not not all of the callers. This includes functions; with normal external linkage as well as templates, C99 inline functions etc.; Specifically, it does nothing to:. define i32 @test(i32 %x, i32 %y, i32 %z) nounwind {; entry:; %0 = add nsw i32 %y, %z ; %1 = mul i32 %0, %x ; %2 = mul i32 %y, %z ; %3 = add nsw i32 %1, %2 ; ret i32 %3; }. define i32 @test2() nounwind {; entry:; %0 = call i32 @test(i32 1, i32 2, i32 4) nounwind; ret i32 %0; }. It would be interesting extend IPSCCP to be able to handle simple cases like; this, where all of the arguments to a call are constant. Because IPSCCP runs; before inlining, trivial templates and inline functions are not yet inlined.; The results for a function + set of constant arguments should be memoized in a; map. //===---------------------------------------------------------------------===//. The libcall constant folding stuff should be moved out of SimplifyLibcalls into; libanalysis' constantfolding logic. This would allow IPSCCP to be able to; handle simple things like this:. static int foo(const char *X) { return strlen(X); }; int bar() { return foo(""abcd""); }. //===---------------------------------------------------------------------===//. function-attrs doesn't know much about memcpy/mem",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:45858,test,test,45858,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['test'],['test']
Testability,")); // S == ""8+9+10""; S = formatv(""{0:$[ + ]@[x]}"", make_range(V.begin(), V.end())); // S == ""0x8 + 0x9 + 0xA"". .. _error_apis:. Error handling; --------------. Proper error handling helps us identify bugs in our code, and helps end-users; understand errors in their tool usage. Errors fall into two broad categories:; *programmatic* and *recoverable*, with different strategies for handling and; reporting. Programmatic Errors; ^^^^^^^^^^^^^^^^^^^. Programmatic errors are violations of program invariants or API contracts, and; represent bugs within the program itself. Our aim is to document invariants, and; to abort quickly at the point of failure (providing some basic diagnostic) when; invariants are broken at runtime. The fundamental tools for handling programmatic errors are assertions and the; llvm_unreachable function. Assertions are used to express invariant conditions,; and should include a message describing the invariant:. .. code-block:: c++. assert(isPhysReg(R) && ""All virt regs should have been allocated already."");. The llvm_unreachable function can be used to document areas of control flow; that should never be entered if the program invariants hold:. .. code-block:: c++. enum { Foo, Bar, Baz } X = foo();. switch (X) {; case Foo: /* Handle Foo */; break;; case Bar: /* Handle Bar */; break;; default:; llvm_unreachable(""X should be Foo or Bar here"");; }. Recoverable Errors; ^^^^^^^^^^^^^^^^^^. Recoverable errors represent an error in the program's environment, for example; a resource failure (a missing file, a dropped network connection, etc.), or; malformed input. These errors should be detected and communicated to a level of; the program where they can be handled appropriately. Handling the error may be; as simple as reporting the issue to the user, or it may involve attempts at; recovery. .. note::. While it would be ideal to use this error handling scheme throughout; LLVM, there are places where this hasn't been practical to apply. In; situations where ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:17150,assert,assert,17150,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['assert'],['assert']
Testability,")); return i;; return 32;; }. This sort of thing should be added to the loop idiom pass. //===---------------------------------------------------------------------===//. These should turn into single 16-bit (unaligned?) loads on little/big endian; processors. unsigned short read_16_le(const unsigned char *adr) {; return adr[0] | (adr[1] << 8);; }; unsigned short read_16_be(const unsigned char *adr) {; return (adr[0] << 8) | adr[1];; }. //===---------------------------------------------------------------------===//. -instcombine should handle this transform:; icmp pred (sdiv X / C1 ), C2; when X, C1, and C2 are unsigned. Similarly for udiv and signed operands. . Currently InstCombine avoids this transform but will do it when the signs of; the operands and the sign of the divide match. See the FIXME in ; InstructionCombining.cpp in the visitSetCondInst method after the switch case ; for Instruction::UDiv (around line 4447) for more details. The SingleSource/Benchmarks/Shootout-C++/hash and hash2 tests have examples of; this construct. . //===---------------------------------------------------------------------===//. [LOOP OPTIMIZATION]. SingleSource/Benchmarks/Misc/dt.c shows several interesting optimization; opportunities in its double_array_divs_variable function: it needs loop; interchange, memory promotion (which LICM already does), vectorization and; variable trip count loop unrolling (since it has a constant trip count). ICC; apparently produces this very nice code with -ffast-math:. ..B1.70: # Preds ..B1.70 ..B1.69; mulpd %xmm0, %xmm1 #108.2; mulpd %xmm0, %xmm1 #108.2; mulpd %xmm0, %xmm1 #108.2; mulpd %xmm0, %xmm1 #108.2; addl $8, %edx #; cmpl $131072, %edx #108.2; jb ..B1.70 # Prob 99% #108.2. It would be better to count down to zero, but this is a lot better than what we; do. //===---------------------------------------------------------------------===//. Consider:. typedef unsigned U32;; typedef unsigned long long U64;; int test (U32 *inst, U64 *regs) {; U64",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:8121,test,tests,8121,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['test'],['tests']
Testability,"), %bl <<<--- spans 2 64 byte lines; 942 942 0x3d03 movl %dh, (1809(%esp, %esi); 937 937 0x3d0a incl %esi; 3 3 0x3d0b cmpb %bl, %dl; 27 27 0x3d0d jnz 0x000062db <main+11707>. //===---------------------------------------------------------------------===//. In c99 mode, the preprocessor doesn't like assembly comments like #TRUNCATE. //===---------------------------------------------------------------------===//. This could be a single 16-bit load. int f(char *p) {; if ((p[0] == 1) & (p[1] == 2)) return 1;; return 0;; }. //===---------------------------------------------------------------------===//. We should inline lrintf and probably other libc functions. //===---------------------------------------------------------------------===//. This code:. void test(int X) {; if (X) abort();; }. is currently compiled to:. _test:; subl $12, %esp; cmpl $0, 16(%esp); jne LBB1_1; addl $12, %esp; ret; LBB1_1:; call L_abort$stub. It would be better to produce:. _test:; subl $12, %esp; cmpl $0, 16(%esp); jne L_abort$stub; addl $12, %esp; ret. This can be applied to any no-return function call that takes no arguments etc.; Alternatively, the stack save/restore logic could be shrink-wrapped, producing; something like this:. _test:; cmpl $0, 4(%esp); jne LBB1_1; ret; LBB1_1:; subl $12, %esp; call L_abort$stub. Both are useful in different situations. Finally, it could be shrink-wrapped; and tail called, like this:. _test:; cmpl $0, 4(%esp); jne LBB1_1; ret; LBB1_1:; pop %eax # realign stack.; call L_abort$stub. Though this probably isn't worth it. //===---------------------------------------------------------------------===//. Sometimes it is better to codegen subtractions from a constant (e.g. 7-x) with; a neg instead of a sub instruction. Consider:. int test(char X) { return 7-X; }. we currently produce:; _test:; movl $7, %eax; movsbl 4(%esp), %ecx; subl %ecx, %eax; ret. We would use one fewer register if codegen'd as:. movsbl 4(%esp), %eax; 	neg %eax; add $7, %eax; ret. Note that th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt:12006,stub,stub,12006,interpreter/llvm-project/llvm/lib/Target/X86/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README.txt,1,['stub'],['stub']
Testability,"). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be installed into ``/usr/include``, create a subdirect",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47590,test,test,47590,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['test'],['test']
Testability,"). NCycles No 3000 − Number of training cycles. HiddenLayers No N,N-1 − Specification of hidden layer architecture. Configuration options for MVA method :. Configuration options reference for MVA method: KNN. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). nkNN No 20 − Number of k-nearest neighbors. BalanceDepth No 6 − Binary tree balance depth. ScaleFrac No 0.8 − Fraction of events used to compute variable width. SigmaFact No 1 − Scale factor for sigma in Gaussian kernel. Kernel No Gaus − Use polynomial (=Poln) or Gaussian (=Gaus) kernel. Trim No False − Use equal number of signal and background events. UseKernel No False − Use polynomial kernel weight. UseWeight No True − Use weight to count kNN events. UseLDA No False − Use local linear discriminant - experimental feature. Configuration options for MVA method :. Configuration options reference for MVA method: BDT. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:10340,test,testing,10340,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['test'],['testing']
Testability,"). update_mca_test_checks.py; llvm-mca. update_mir_test_checks.py; llc (MIR checks). update_test_checks.py; opt. Precommit workflow for tests; ----------------------------. If the test does not crash, assert, or infinite loop, commit the test with; baseline check-lines first. That is, the test will show a miscompile or; missing optimization. Add a ""TODO"" or ""FIXME"" comment to indicate that; something is expected to change in a test. A follow-up patch with code changes to the compiler will then show check-line; differences to the tests, so it is easier to see the effect of the patch.; Remove TODO/FIXME comments added in the previous step if a problem is solved. Baseline tests (no-functional-change or NFC patch) may be pushed to main; without pre-commit review if you have commit access. Best practices for regression tests; -----------------------------------. - Use auto-generated check lines (produced by the scripts mentioned above); whenever feasible.; - Include comments about what is tested/expected in a particular test. If there; are relevant issues in the bug tracker, add references to those bug reports; (for example, ""See PR999 for more details"").; - Avoid undefined behavior and poison/undef values unless necessary. For; example, do not use patterns like ``br i1 undef``, which are likely to break; as a result of future optimizations.; - Minimize tests by removing unnecessary instructions, metadata, attributes,; etc. Tools like ``llvm-reduce`` can help automate this.; - Outside PhaseOrdering tests, only run a minimal set of passes. For example,; prefer ``opt -S -passes=instcombine`` over ``opt -S -O3``.; - Avoid unnamed instructions/blocks (such as ``%0`` or ``1:``), because they may; require renumbering on future test modifications. These can be removed by; running the test through ``opt -S -passes=instnamer``.; - Try to give values (including variables, blocks and functions) meaningful; names, and avoid retaining complex names generated by the optimization; pipe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:13591,test,tested,13591,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,2,['test'],"['test', 'tested']"
Testability,"); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports similar pieces of code. .. code-block:: c. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. alpha.core; ^^^^^^^^^^. .. _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""; Check when casting a malloc'ed type ``T``, whether the size is a multiple of the size of ``T``. .. code-block:: c. void test() {; int *x = (int *) malloc(11); // warn; }. .. _alpha-core-CastToStruct:. alpha.core.CastToStruct (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cast from non-struct pointer to struct pointer. .. code-block:: cpp. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. .. _alpha-core-Conversion:. alpha.core.Conversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:47873,log,logical,47873,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['log'],['logical']
Testability,); TARGET_LINK_LIBRARIES(testMinimizationCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-MinimizationCuda COMMAND testMinimizationCuda). # DNN - Arithmetic Cuda; add_executable(testArithmeticCuda TestMatrixArithmeticCuda.cxx); TARGET_LINK_LIBRARIES(testArithmeticCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-ArithmeticCuda COMMAND testArithmeticCuda). # DNN - DataLoader Cuda; add_executable(testDataLoaderCuda TestDataLoaderCuda.cxx); TARGET_LINK_LIBRARIES(testDataLoaderCuda ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-DataLoaderCuda COMMAND testDataLoaderCuda). # DNN - Optimization GPU. add_executable(testOptimizationCuda TestOptimizationCuda.cxx); TARGET_LINK_LIBRARIES(testOptimizationCuda ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-Optimization-Cuda COMMAND testOptimizationCuda). #Cuda tests using CUDNN; if (tmva-cudnn). # DNN - Batch normalization Cudnn; add_executable(testBatchNormalizationCudnn TestBatchNormalizationCudnn.cxx ); TARGET_LINK_LIBRARIES(testBatchNormalizationCudnn ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-BatchNormalization-Cudnn COMMAND testBatchNormalizationCudnn). # DNN Optimization GPU Cudnn. add_executable(testOptimizationCudnn TestOptimizationCudnn.cxx); TARGET_LINK_LIBRARIES(testOptimizationCudnn ${Libraries} ); ROOT_ADD_TEST(TMVA-DNN-Optimization-Cudnn COMMAND testOptimizationCudnn). # DNN - TensorDataLoader Cudnn; #add_executable(testTensorDataLoaderCudnn TestTensorDataLoaderCudnn.cxx); #TARGET_LINK_LIBRARIES(testTensorDataLoaderCudnn ${Libraries} ${DNN_CUDA_LIBRARIES}); #ROOT_ADD_TEST(TMVA-DNN-TensorDataLoaderCudnn COMMAND testTensorDataLoaderCudnn). endif(). endif (). #--- CPU tests. ----------------------------; #; # always run the Cpu tests. If tmva-cpu is off (no Blas or no imt); # they will work using TMatrix operations. # DNN - Arithmetic Functions CPU; ROOT_EXECUTABLE(testArithmeticCpu TestMatrixArithmeticCpu.cxx LIBRARIES ${Libraries}); ROOT_ADD_TEST(TMVA-DNN-Arithmetic-Cpu COMMAND testArithmeticCpu). # DNN - Activation Functions CPU; ROOT_EXECUTABLE(te,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt:3176,test,testBatchNormalizationCudnn,3176,tmva/tmva/test/DNN/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/CMakeLists.txt,2,['test'],['testBatchNormalizationCudnn']
Testability,"); and refer to this page for additional information on writing a checker. The static analyzer is a; part of the Clang project, so consult Hacking on Clang; and LLVM Programmer's Manual; for developer guidelines and post your questions and proposals to the; Static Analyzer subcategory at; the official LLVM Discourse server. Getting Started; Static Analyzer Overview. Interaction with Checkers; Representing Values. Idea for a Checker; Checker Registration; Events, Callbacks, and Checker Class Structure; Custom Program States; Bug Reports; AST Visitors; Testing; Useful Commands/Debugging Hints. Attaching the Debugger; Narrowing Down the Problem; Visualizing the Analysis; Debug Prints and Tricks. Additional Sources of Information; Useful Links. Getting Started. To check out the source code and build the project, follow steps 1-4 of; the Clang Getting Started; page.; The analyzer source code is located under the Clang source tree:; ; $ cd llvm/tools/clang. See: include/clang/StaticAnalyzer, lib/StaticAnalyzer,; test/Analysis.; The analyzer regression tests can be executed from the Clang's build; directory:; ; $ cd ../../../; cd build/tools/clang; TESTDIRS=Analysis make test. Analyze a file with the specified checker:; ; $ clang -cc1 -analyze -analyzer-checker=core.DivideZero test.c. List the available checkers:; ; $ clang -cc1 -analyzer-checker-help. See the analyzer help for different output formats, fine tuning, and; debug options:; ; $ clang -cc1 -help | grep ""analyzer"". Static Analyzer Overview; The analyzer core performs symbolic execution of the given program. All the; input values are represented with symbolic values; further, the engine deduces; the values of all the expressions in the program based on the input symbols; and the path. The execution is path sensitive and every possible path through; the program is explored. The explored execution traces are represented with; ExplodedGraph object.; Each node of the graph is; ExplodedNode,; which consists of a Progra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:1430,test,test,1430,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['test'],['test']
Testability,"); declare i64 @llvm.start.loop.iterations.i64(i64). Overview:; """""""""""""""""". The '``llvm.start.loop.iterations.*``' intrinsics are similar to the; '``llvm.set.loop.iterations.*``' intrinsics, used to specify the; hardware-loop trip count but also produce a value identical to the input; that can be used as the input to the loop. They are placed in the loop; preheader basic block and the output is expected to be the input to the; phi for the induction variable of the loop, decremented by the; '``llvm.loop.decrement.reg.*``'. Arguments:; """""""""""""""""""". The integer operand is the loop trip count of the hardware-loop, and thus; not e.g. the loop back-edge taken count. Semantics:; """""""""""""""""""". The '``llvm.start.loop.iterations.*``' intrinsics do not perform any arithmetic; on their operand. It's a hint to the backend that can use this to set up the; hardware-loop count with a target specific instruction, usually a move of this; value to a special register or a hardware-loop instruction. '``llvm.test.set.loop.iterations.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. ::. declare i1 @llvm.test.set.loop.iterations.i32(i32); declare i1 @llvm.test.set.loop.iterations.i64(i64). Overview:; """""""""""""""""". The '``llvm.test.set.loop.iterations.*``' intrinsics are used to specify the; the loop trip count, and also test that the given count is not zero, allowing; it to control entry to a while-loop. They are placed in the loop preheader's; predecessor basic block, and are marked as ``IntrNoDuplicate`` to avoid; optimizers duplicating these instructions. Arguments:; """""""""""""""""""". The integer operand is the loop trip count of the hardware-loop, and thus; not e.g. the loop back-edge taken count. Semantics:; """""""""""""""""""". The '``llvm.test.set.loop.iterations.*``' intrinsics do not perform any; arithmetic on their operand. It's a hint to the backend that can use this to; set up the hardware-loop count with a target specific instruction,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:645244,test,test,645244,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['test'],['test']
Testability,"); endif(); else(); if ((NOT var MATCHES ""_(DOCS|TESTS|INSTALL)"") AND (NOT var MATCHES ""^_"")); set(ROOT_CONFIGARGS ""${ROOT_CONFIGARGS}${var}=${${var}} ""); endif(); endif(); endif(); endforeach(). #---Move (copy) directories to binary tree------------------------------------------------------; set(stamp_file ${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/move_artifacts.stamp); add_custom_command(OUTPUT ${stamp_file}; COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_SOURCE_DIR}/LICENSE ${CMAKE_BINARY_DIR}/LICENSE; COMMAND ${CMAKE_COMMAND} -E copy_directory ${CMAKE_SOURCE_DIR}/README ${CMAKE_BINARY_DIR}/README; COMMAND ${CMAKE_COMMAND} -E touch ${stamp_file}; COMMENT ""Copying directories such as etc, icons, fonts, js, ui5, etc. to build area""). if(http); set(jsroot_files js/*); endif(); if(webgui); set(openui5_files ui5/*); endif(). #---Copy files to the build area, with dependency---------------------------------; file(GLOB_RECURSE artifact_files RELATIVE ${CMAKE_SOURCE_DIR} tutorials/* etc/* test/* icons/* fonts/* macros/* ${jsroot_files} ${openui5_files}); set(artifact_files_builddir); foreach(artifact_file ${artifact_files}); # Filter out hsimple.root; someone might have created it in the src dir, and the hsimple.root; # target below will interfere.; if (NOT (artifact_file STREQUAL ""tutorials/hsimple.root"")); add_custom_command(OUTPUT ${CMAKE_BINARY_DIR}/${artifact_file}; COMMAND ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_SOURCE_DIR}/${artifact_file} ${CMAKE_BINARY_DIR}/${artifact_file}; COMMENT ""Copying ${CMAKE_SOURCE_DIR}/${artifact_file}""; DEPENDS ${CMAKE_SOURCE_DIR}/${artifact_file}); list(APPEND artifact_files_builddir ${CMAKE_BINARY_DIR}/${artifact_file}); endif(); endforeach(); add_custom_target(move_artifacts DEPENDS ${stamp_file} ${artifact_files_builddir}). add_subdirectory (interpreter). # Update etc/gitinfo.txt for every build.; add_custom_target(gitinfotxt; ALL; COMMAND ${CMAKE_COMMAND} -DSRCDIR=${CMAKE_SOURCE_DIR} -DBINDIR=${CMAKE_BINARY_DIR} -P ${CMAK",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:14543,test,test,14543,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['test'],['test']
Testability,"); subType = 9;; return subType;; }. //===---------------------------------------------------------------------===//. The following test case (from PR6576):. define i32 @mul(i32 %a, i32 %b) nounwind readnone {; entry:; %cond1 = icmp eq i32 %b, 0 ; <i1> [#uses=1]; br i1 %cond1, label %exit, label %bb.nph; bb.nph: ; preds = %entry; %tmp = mul i32 %b, %a ; <i32> [#uses=1]; ret i32 %tmp; exit: ; preds = %entry; ret i32 0; }. could be reduced to:. define i32 @mul(i32 %a, i32 %b) nounwind readnone {; entry:; %tmp = mul i32 %b, %a; ret i32 %tmp; }. //===---------------------------------------------------------------------===//. We should use DSE + llvm.lifetime.end to delete dead vtable pointer updates.; See GCC PR34949. Another interesting case is that something related could be used for variables; that go const after their ctor has finished. In these cases, globalopt (which; can statically run the constructor) could mark the global const (so it gets put; in the readonly section). A testcase would be:. #include <complex>; using namespace std;; const complex<char> should_be_in_rodata (42,-42);; complex<char> should_be_in_data (42,-42);; complex<char> should_be_in_bss;. Where we currently evaluate the ctors but the globals don't become const because; the optimizer doesn't know they ""become const"" after the ctor is done. See; GCC PR4131 for more examples. //===---------------------------------------------------------------------===//. In this code:. long foo(long x) {; return x > 1 ? x : 1;; }. LLVM emits a comparison with 1 instead of 0. 0 would be equivalent; and cheaper on most targets. LLVM prefers comparisons with zero over non-zero in general, but in this; case it choses instead to keep the max operation obvious. //===---------------------------------------------------------------------===//. define void @a(i32 %x) nounwind {; entry:; switch i32 %x, label %if.end [; i32 0, label %if.then; i32 1, label %if.then; i32 2, label %if.then; i32 3, label %if.then; i32 5, label",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:51085,test,testcase,51085,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['test'],['testcase']
Testability,");; // Symmetric matrix EigenVector algorithm; TMatrixDSym mtm(TMatrixDBase::kAtA,m);; const TMatrixDSymEigen eigen(mtm);; const TVectorD eigenVal = eigen.GetEigenValues();; const Bool_t ok = VerifyVectorIdentity(sig,eigenVal,1,1.-e-14);; ```. ## Speed Comparisons. Speed of four matrix operations have been compared between four matrix; libraries, `GSL` `CLHEP`, `ROOT v3.10` and `ROOT v4.0`. Next figure; shows the `CPU` time for these four operations as a function of the; matrix size:. 1. `A*B` The execution time is measured for the sum of A \* Bsym,; Bsym\* A and A \* B. Notice the matrix\_size3 dependence of execution; time. `CLHEP` results are hampered by a poor implementation of symmetric; matrix multiplications. For instance, for general matrices of size; 100x100, the time is 0.015 sec. while A \* Bsym takes 0.028 sec and; Bsym\* A takes 0.059 sec. Both `GSL` and `ROOT v4.0` can be setup to use the hardware-optimized; multiplication routines of the `BLAS` libraries. It was tested on a G4; PowerPC. The improvement becomes clearly visible around sizes of (50x50); were the execution speed improvement of the Altivec processor becomes; more significant than the overhead of filling its pipe. 2. $A^{-1}$ Here, the time is measured for an in-place matrix inversion. Except for `ROOT v3.10`, the algorithms are all based on an; `LU `factorization followed by forward/back-substitution. `ROOT v3.10`; is using the slower Gaussian elimination method. The numerical accuracy; of the `CLHEP` routine is poor:. - up to 6x6 the numerical imprecise Cramer multiplication is hard-coded.; For instance, calculating `U=H*H-1`, where `H` is a (5x5) Hilbert; matrix, results in off-diagonal elements of $10^{-7}$ instead of the $10^{-13}$; using an `LU `according to `Crout`. - scaling protection is non-existent and limits are hard-coded, as a; consequence inversion of a Hilbert matrix for `sizes>(12x12)` fails. In; order to gain speed the `CLHEP` algorithm stores its permutation info of; the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:50355,test,tested,50355,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['test'],['tested']
Testability,");; if (x > y); return x;; return y;; }. alpha.core; ^^^^^^^^^^. .. _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""; Check when casting a malloc'ed type ``T``, whether the size is a multiple of the size of ``T``. .. code-block:: c. void test() {; int *x = (int *) malloc(11); // warn; }. .. _alpha-core-CastToStruct:. alpha.core.CastToStruct (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cast from non-struct pointer to struct pointer. .. code-block:: cpp. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. .. _alpha-core-Conversion:. alpha.core.Conversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Loss of sign/precision in implicit conversions. .. code-block:: c. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:48061,test,test,48061,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['test'],['test']
